                                this.valueName = args[1].readUtf16String();
                                if (this.valueName.toLowerCase().indexOf("licen") !== -1 ||
                                    this.valueName.toLowerCase().indexOf("expire") !== -1 ||
                                    this.valueName.toLowerCase().indexOf("trial") !== -1) {{
                                    logHook("[Registry] Querying license-related value: " + this.valueName);
                                    this.isLicenseValue = true;
                                }}
                            }} catch (e) {{}}
                        }}

                        // Save params for response manipulation
                        this.lpType = args[2];
                        this.lpData = args[3];
                        this.lpcbData = args[4];
                    }},
                    onLeave: function(retval) {{
                        if (this.isLicenseValue && retval.toInt32() === 0 &&
                            this.lpData && !this.lpData.isNull() &&
                            this.lpType && !this.lpType.isNull()) {{

                            var dataType = Memory.readUInt(this.lpType);

                            // Handle REG_SZ (1) or REG_EXPAND_SZ (2)
                            if (dataType === 1 || dataType === 2) {{
                                try {{
                                    var value = Memory.readUtf16String(this.lpData);
                                    logHook("[Registry] License value: " + value);

                                    // Check for expiration dates or status
                                    if (this.valueName.toLowerCase().indexOf("expire") !== -1) {{
                                        Memory.writeUtf16String(this.lpData, "2099-12-31");
                                        logHook("[Registry] Changed expiration date to 2099-12-31");
                                    }} else if (this.valueName.toLowerCase().indexOf("status") !== -1 ||
                                               this.valueName.toLowerCase().indexOf("state") !== -1) {{
                                        Memory.writeUtf16String(this.lpData, "activated");
                                        logHook("[Registry] Changed status to activated");
                                    }} else if (this.valueName.toLowerCase().indexOf("trial") !== -1) {{
                                        Memory.writeUtf16String(this.lpData, "9999");
                                        logHook("[Registry] Changed trial to 9999");
                                    }}
                                }} catch (e) {{}}
                            }}
                            // Handle REG_DWORD (4)
                            else if (dataType === 4) {{
                                try {{
                                    var value = Memory.readUInt(this.lpData);
                                    logHook("[Registry] License value (DWORD): " + value);

                                    // For trial days or status, use high values
                                    if (this.valueName.toLowerCase().indexOf("day") !== -1 ||
                                        this.valueName.toLowerCase().indexOf("trial") !== -1 ||
                                        this.valueName.toLowerCase().indexOf("count") !== -1) {{
                                        Memory.writeUInt(this.lpData, 9999);
                                        logHook("[Registry] Changed counter to 9999");
                                    }} else if (this.valueName.toLowerCase().indexOf("status") !== -1 ||
                                               this.valueName.toLowerCase().indexOf("state") !== -1) {{
                                        Memory.writeUInt(this.lpData, 1);
                                        logHook("[Registry] Changed status to 1 (active)");
                                    }}
                                }} catch (e) {{}}
                            }}
                        }}
                    }}
                }});
            }}

            // Time manipulation for trials
            var getSystemTime = Module.findExportByName("kernel32.dll", "GetSystemTime");
            if (getSystemTime) {{
                Interceptor.attach(getSystemTime, {{
                    onEnter: function(args) {{
                        this.systemTimePtr = args[0];
                    }},
                    onLeave: function(retval) {{
                        if (this.systemTimePtr && !this.systemTimePtr.isNull()) {{
                            // Set date to beginning of 2022 (for trials)
                            Memory.writeUShort(this.systemTimePtr, 2022); // wYear
                            Memory.writeUShort(this.systemTimePtr.add(2), 1); // wMonth (January)
                            Memory.writeUShort(this.systemTimePtr.add(6), 1); // wDay (1st)
                            logHook("[Time] Spoofed GetSystemTime to 2022-01-01");
                        }}
                    }}
                }});
            }}

            // Hardware ID spoofing
            var getVolumeInformationW = Module.findExportByName("kernel32.dll", "GetVolumeInformationW");
            if (getVolumeInformationW) {{
                Interceptor.attach(getVolumeInformationW, {{
                    onEnter: function(args) {{
                        this.serialNumberPtr = args[5];
                    }},
                    onLeave: function(retval) {{
                        if (retval.toInt32() !== 0 && this.serialNumberPtr && !this.serialNumberPtr.isNull()) {{
                            Memory.writeUInt(this.serialNumberPtr, 0xDEADBEEF);
                            logHook("[Hardware] Spoofed volume serial number to 0xDEADBEEF");
                        }}
                    }}
                }});
            }}

            // Anti-debugging bypass
            var isDebuggerPresent = Module.findExportByName("kernel32.dll", "IsDebuggerPresent");
            if (isDebuggerPresent) {{
                Interceptor.replace(isDebuggerPresent, new NativeCallback(function() {{
                    logHook("[Anti-Debug] Returning FALSE for IsDebuggerPresent");
                    return 0; // FALSE
                }}, 'int', []));
            }}

            var checkRemoteDebuggerPresent = Module.findExportByName("kernel32.dll", "CheckRemoteDebuggerPresent");
            if (checkRemoteDebuggerPresent) {{
                Interceptor.attach(checkRemoteDebuggerPresent, {{
                    onEnter: function(args) {{
                        this.pbDebuggerPresent = args[1];
                    }},
                    onLeave: function(retval) {{
                        if (retval.toInt32() !== 0 && this.pbDebuggerPresent && !this.pbDebuggerPresent.isNull()) {{
                            Memory.writeU8(this.pbDebuggerPresent, 0);
                            logHook("[Anti-Debug] Spoofed CheckRemoteDebuggerPresent to FALSE");
                        }}
                    }}
                }});
            }}

            // Message box interception (for license errors)
            var messageBoxW = Module.findExportByName("user32.dll", "MessageBoxW");
            if (messageBoxW) {{
                Interceptor.attach(messageBoxW, {{
                    onEnter: function(args) {{
                        if (args[1]) {{
                            try {{
                                var text = args[1].readUtf16String();
                                var licenseKeywords = ["licen", "trial", "activ", "expire"];

                                for (var i = 0; i < licenseKeywords.length; i++) {{
                                    if (text.toLowerCase().indexOf(licenseKeywords[i]) !== -1) {{
                                        logHook("[UI] Blocking license message: " + text);
                                        this.shouldBlock = true;
                                        break;
                                    }}
                                }}
                            }} catch (e) {{}}
                        }}
                    }},
                    onLeave: function(retval) {{
                        if (this.shouldBlock) {{
                            retval.replace(1); // IDOK (simulate user clicking OK)
                            logHook("[UI] Auto-dismissed license message dialog");
                        }}
                    }}
                }});
            }}

            logHook("[Intellicrack] All hooks initialized successfully!");
        }})();
        '''

        # Create and load the script
        script = session.create_script(script_code)
        script.on('message', on_message)
        script.load()

        print("API hooks installed successfully. The application is now running with license bypasses.")
        print("Press Ctrl+C to exit (but the application will continue running)...")

        # Keep the script loaded while the application runs
        sys.stdin.read()

    except KeyboardInterrupt:
        print("Exiting...")
    except Exception as e:
        print(f"Error: {e}")
        target_process.terminate()

if __name__ == "__main__":
    main()
"""

    # Format patches for the script
    patches_str = ""
    for i, patch in enumerate(patches):
        desc = patch.get("description", "").replace(
            "'", "\\'").replace('"', '\\"')
        patches_str += f"                    {{address: \"{
            hex(
                patch['address'])}\", new_bytes: \"{
            patch['new_bytes']}\", description: \"{desc}\"}}"
        if i < len(patches) - 1:
            patches_str += ",\n"

    # Generate script with proper formatting
    formatted_script = script_template.format(
        date=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        binary_name=binary_name,
        binary_name_lower=binary_name.lower(),
        # Escape backslashes for string
        binary_path=binary_path.replace("\\", "\\\\"),
        patches_json=patches_str
    )

    # Save the script
    script_path = os.path.join(
        "scripts", f"intellicrack_launcher_{
            os.path.splitext(binary_name)[0]}.py")
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(formatted_script)

    app.update_output.emit(log_message(
        f"[Launcher] Script generated: {script_path}"))

    # Ask if user wants to run the script now
    response = QMessageBox.question(
        app,
        "Run Launcher",
        f"Launcher script generated: {script_path}\n\nWould you like to run it now?",
        QMessageBox.Yes | QMessageBox.No)

    if response == QMessageBox.Yes:
        app.update_output.emit(log_message("[Launcher] Launching script..."))

        # Run the script in a new command window
        if sys.platform == "win32":
            os.system(f"start cmd /k python \"{script_path}\"")
        else:
            os.system(f"xterm -e python \"{script_path}\" &")

        app.update_output.emit(log_message(
            "[Launcher] Script launched in a new window."))

    return script_path


def setup_memory_patching(app):
    """
    Sets up a memory patching environment for the binary.
    This is for heavily protected binaries where file patching won't work.
    """
    if not app.binary_path:
        app.update_output.emit(log_message(
            "[Memory Patching] No binary selected."))
        return

    app.update_output.emit(log_message(
        "[Memory Patching] Setting up memory patching environment..."))

    # First, run protection scan to check if memory patching is needed
    app.update_output.emit(log_message(
        "[Memory Patching] Analyzing binary protection..."))

    # Check for integrity verification
    checksum_results = detect_checksum_verification(app)
    has_integrity_checks = False
    for line in checksum_results:
        if "INTEGRITY VERIFICATION DETECTED" in line or "POSSIBLE INTEGRITY VERIFICATION" in line:
            has_integrity_checks = True
            break

    # Check for self-healing code
    healing_results = detect_self_healing_code(app)
    has_self_healing = False
    for line in healing_results:
        if "SELF-HEALING CODE DETECTED" in line or "POSSIBLE SELF-HEALING CODE" in line:
            has_self_healing = True
            break

    # Check for obfuscation
    obfuscation_results = detect_obfuscation(app)
    is_obfuscated = False
    for line in obfuscation_results:
        if "OBFUSCATION ASSESSMENT: HIGH CONFIDENCE" in line or "OBFUSCATION ASSESSMENT: MEDIUM CONFIDENCE" in line:
            is_obfuscated = True
            break

    # Determine if memory patching is necessary
    memory_patching_needed = has_integrity_checks or has_self_healing or is_obfuscated

    if not memory_patching_needed:
        app.update_output.emit(log_message(
            "[Memory Patching] No strong protection detected. Standard patching should work."))

        # Ask if user wants to continue anyway
        response = QMessageBox.question(
            app,
            "Continue with Memory Patching?",
            "No strong protection detected. Standard patching should work.\n\nDo you want to continue with memory patching anyway?",
            QMessageBox.Yes | QMessageBox.No)

        if response == QMessageBox.No:
            app.update_output.emit(log_message(
                "[Memory Patching] Memory patching setup cancelled."))
            return

    # Determine the best approach based on protection type
    approach = "memory"  # Default to memory patching

    if has_integrity_checks and not has_self_healing:
        approach = "api"  # API hooking might be more effective for integrity checks
        app.update_output.emit(log_message(
            "[Memory Patching] Integrity checks detected, will use API hooking approach."))
    elif has_self_healing:
        approach = "memory"  # Memory patching with continuous monitoring for self-healing
        app.update_output.emit(log_message(
            "[Memory Patching] Self-healing detected, will use memory patching with monitoring."))

    # Generate appropriate launcher script
    app.update_output.emit(log_message(
        f"[Memory Patching] Generating {approach} patching launcher..."))
    script_path = generate_launcher_script(app, patching_strategy=approach)

    if script_path:
        app.update_output.emit(
            log_message(
                f"[Memory Patching] Setup complete. Use the launcher script to patch {
                    os.path.basename(
                        app.binary_path)} at runtime."))

        # Add to analyze results
        app.analyze_results.append("\n=== MEMORY PATCHING SETUP ===")
        app.analyze_results.append(f"Launcher Script: {script_path}")
        app.analyze_results.append(
            f"Patching Strategy: {
                'API Hooking' if approach == 'api' else 'Memory Patching'}")

        if approach == "api":
            app.analyze_results.append(
                "\nAPI Hooking will intercept license-related functions without modifying the binary directly.")
            app.analyze_results.append(
                "This bypasses integrity checks and is effective against most license systems.")
        else:
            app.analyze_results.append(
                "\nMemory Patching will modify the code in memory at runtime.")
            app.analyze_results.append(
                "This avoids triggering integrity checks but may need to be reapplied if self-healing occurs.")

        app.analyze_results.append("\nInstructions:")
        app.analyze_results.append("1. Run the generated script with Python")
        app.analyze_results.append(
            "2. The script will launch the target program with patches applied")
        app.analyze_results.append(
            "3. Do not close the script window while using the program")
        app.analyze_results.append(
            "4. You can press Ctrl+C in the script window to exit when done")

        app.analyze_status.setText("Memory patching setup complete")
    else:
        app.update_output.emit(log_message(
            "[Memory Patching] Failed to generate launcher script."))

# -------------------------------
# Expanded Plugin System
# -------------------------------


def load_plugins(plugin_dir="plugins"):
    """
    Loads and initializes plugins from the plugin directory.
    Returns a dictionary of loaded plugins by category.
    """
    plugins = {
        "frida": [],
        "ghidra": [],
        "custom": []
    }

    # Check if plugin directory exists
    if not os.path.exists(plugin_dir):
        os.makedirs(plugin_dir)

        # Create subdirectories if needed
        for subdir in ["frida_scripts", "ghidra_scripts", "custom_modules"]:
            path = os.path.join(plugin_dir, subdir)
            if not os.path.exists(path):
                os.makedirs(path)

    # Load Frida scripts
    frida_dir = os.path.join(plugin_dir, "frida_scripts")
    if os.path.exists(frida_dir):
        for file in os.listdir(frida_dir):
            if file.endswith(".js"):
                plugin_path = os.path.join(frida_dir, file)
                plugin_name = os.path.splitext(
                    file)[0].replace("_", " ").title()

                # Read first 5 lines for description
                try:
                    with open(plugin_path, "r", encoding="utf-8") as f:
                        lines = [f.readline().strip() for _ in range(5)]
                        description = "".join(
                            [line for line in lines if line.startswith("//")]).replace("//", "").strip()

                        if not description:
                            description = f"Frida script: {plugin_name}"

                        plugins["frida"].append({
                            "name": plugin_name,
                            "path": plugin_path,
                            "description": description
                        })
                except Exception as e:
                    logger.error(f"Error loading Frida plugin {file}: {e}")

    # Load Ghidra scripts
    ghidra_dir = os.path.join(plugin_dir, "ghidra_scripts")
    if os.path.exists(ghidra_dir):
        for file in os.listdir(ghidra_dir):
            if file.endswith(".java"):
                plugin_path = os.path.join(ghidra_dir, file)
                plugin_name = os.path.splitext(
                    file)[0].replace("_", " ").title()

                # Read first 10 lines for description
                try:
                    with open(plugin_path, "r", encoding="utf-8") as f:
                        lines = [f.readline().strip() for _ in range(10)]
                        description = "".join(
                            [line for line in lines if line.startswith("//")]).replace("//", "").strip()

                        if not description:
                            description = f"Ghidra script: {plugin_name}"

                        plugins["ghidra"].append({
                            "name": plugin_name,
                            "path": plugin_path,
                            "description": description
                        })
                except Exception as e:
                    logger.error(f"Error loading Ghidra plugin {file}: {e}")

    # Load custom Python modules
    custom_dir = os.path.join(plugin_dir, "custom_modules")
    if os.path.exists(custom_dir):
        # Add to Python path
        sys.path.insert(0, custom_dir)

        for file in os.listdir(custom_dir):
            if file.endswith(".py") and not file.startswith("__"):
                plugin_name = os.path.splitext(file)[0]

                try:
                    # Import the module
                    module_name = plugin_name
                    module = importlib.import_module(module_name)

                    # Check if it has a register function
                    if hasattr(module, "register"):
                        plugin_instance = module.register()

                        name = getattr(plugin_instance, "name",
                                       plugin_name.replace("_", " ").title())
                        description = getattr(
                            plugin_instance, "description", f"Custom plugin: {name}")

                        plugins["custom"].append({
                            "name": name,
                            "module": module_name,
                            "instance": plugin_instance,
                            "description": description
                        })
                except Exception as e:
                    logger.error(f"Error loading custom plugin {file}: {e}")
                    logger.error(traceback.format_exc())

    logger.info(
        f"Loaded {
            len(
                plugins['frida'])} Frida plugins, {
            len(
                plugins['ghidra'])} Ghidra plugins, and {
            len(
                plugins['custom'])} custom plugins")
    return plugins


def run_plugin(app, plugin_name):
    """Runs a built-in plugin."""
    if not app.binary_path:
        app.update_output.emit(log_message("[Plugin] No binary selected."))
        return

    app.update_output.emit(log_message(f"[Plugin] Running {plugin_name}..."))

    if plugin_name == "HWID Spoofer":
        script = generate_complete_api_hooking_script(
            app, hook_types=["hardware_id"])
    elif plugin_name == "Anti-Debugger":
        script = generate_complete_api_hooking_script(
            app, hook_types=["debugger"])
    elif plugin_name == "Time Bomb Defuser":
        script = generate_complete_api_hooking_script(app, hook_types=["time"])
    elif plugin_name == "Telemetry Blocker":
        script = generate_complete_api_hooking_script(
            app, hook_types=["network"])
    else:
        app.update_output.emit(log_message(
            f"[Plugin] Unknown plugin: {plugin_name}"))
        return

    # Inject script
    inject_comprehensive_api_hooks(app, script)


def run_custom_plugin(app, plugin_info):
    """
    Runs a custom plugin with the current binary.

    Args:
        app: Application instance
        plugin_info: Plugin information dictionary
    """
    if not app.binary_path:
        app.update_output.emit(log_message("[Plugin] No binary selected."))
        return

    instance = plugin_info.get("instance")
    if not instance:
        app.update_output.emit(log_message(
            "[Plugin] Invalid plugin instance."))
        return

    app.update_output.emit(log_message(
        f"[Plugin] Running {plugin_info['name']}..."))

    # Check for analyze method
    if hasattr(instance, "analyze"):
        try:
            results = instance.analyze(app.binary_path)

            if results:
                if isinstance(results, list):
                    for line in results:
                        app.update_output.emit(log_message(
                            f"[{plugin_info['name']}] {line}"))
                else:
                    app.update_output.emit(log_message(
                        f"[{plugin_info['name']}] {results}"))
        except Exception as e:
            app.update_output.emit(log_message(
                f"[Plugin] Error running plugin: {e}"))
            app.update_output.emit(log_message(traceback.format_exc()))
    else:
        app.update_output.emit(log_message(
            "[Plugin] Plugin does not have an analyze method."))

    # Check for patch method
    if hasattr(instance, "patch"):
        # Ask user if they want to run the patch
        response = QMessageBox.question(
            app,
            "Run Patch?",
            f"Do you want to run the patch function of {plugin_info['name']}?",
            QMessageBox.Yes | QMessageBox.No
        )

        if response == QMessageBox.Yes:
            try:
                results = instance.patch(app.binary_path)

                if results:
                    if isinstance(results, list):
                        for line in results:
                            app.update_output.emit(log_message(
                                f"[{plugin_info['name']}] {line}"))
                    else:
                        app.update_output.emit(log_message(
                            f"[{plugin_info['name']}] {results}"))
            except Exception as e:
                app.update_output.emit(log_message(
                    f"[Plugin] Error running patch: {e}"))
                app.update_output.emit(log_message(traceback.format_exc()))


def run_frida_plugin_from_file(app, plugin_path):
    """
    Runs a Frida plugin script from a file.
    Enhanced with robust PID finding and error handling.
    Args:
        app: Application instance
        plugin_path: Path to the Frida script file
    """
    if not app.binary_path:
        app.update_output.emit(log_message("[Plugin] No binary selected."))
        return

    plugin_name = os.path.basename(plugin_path)
    app.update_output.emit(log_message(
        f"[Plugin] Loading Frida script '{plugin_name}' from {plugin_path}..."))

    try:
        # Read the script content
        with open(plugin_path, "r", encoding="utf-8") as f:
            script_content = f.read()
    except Exception as e:
        app.update_output.emit(log_message(
            f"[Plugin] Error reading script file {plugin_path}: {e}"))
        return

    # Get process information using the updated function
    app.update_output.emit(log_message(
        f"[Plugin] Finding target process for '{plugin_name}'..."))
    target_pid = get_target_process_pid(
        app.binary_path)  # Use the updated function

    if target_pid is None:
        app.update_output.emit(
            log_message(
                f"[Plugin] Target process PID not obtained for '{plugin_name}'. Aborting script injection."))
        return

    app.update_output.emit(log_message(
        f"[Plugin] Attempting to attach to PID {target_pid} for script '{plugin_name}'"))

    # Run the Frida script with improved error handling
    session = None  # Initialize session to None
    try:
        session = frida.attach(target_pid)
        app.update_output.emit(log_message(
            f"[Plugin] Attached to PID {target_pid} for '{plugin_name}'"))

        script = session.create_script(script_content)

        def on_message(message, data):
            """
            Callback for handling messages from a Frida script.

            Adds the plugin name as a prefix to log messages and processes payloads.
            """
            # Add plugin name prefix to logs
            prefix = f"[{plugin_name}]"
            if message["type"] == "send":
                # Check if payload is simple string or structured data
                payload = message.get('payload', '')
                if isinstance(payload, (str, int, float, bool)):
                    log_text = f"{prefix} {payload}"
                else:
                    # For complex payloads, just indicate type or stringify
                    try:
                        log_text = f"{prefix} Data: {json.dumps(payload)}"
                    except TypeError:
                        log_text = f"{prefix} Received complex data structure"
                app.update_output.emit(log_message(log_text))
            elif message["type"] == "error":
                # More specific error logging from Frida script errors
                description = message.get('description', 'Unknown error')
                stack = message.get('stack', 'No stack trace')
                app.update_output.emit(
                    log_message(
                        f"{prefix} Script Error: Desc: {description}\nStack: {stack}"))

        script.on("message", on_message)
        script.load()  # This can also raise exceptions

        app.update_output.emit(log_message(
            f"[Plugin] Frida script '{plugin_name}' loaded successfully"))

        # Store session and script to prevent garbage collection
        if not hasattr(app, "frida_sessions"):
            app.frida_sessions = {}
        # Ensure session is valid before storing
        if session:
            app.frida_sessions[plugin_name] = (session, script)

    except frida.ProcessNotFoundError:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Process PID {target_pid} not found (may have terminated)."))
    except frida.TransportError as e:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Connection to Frida server failed: {e}"))
        app.update_output.emit(
            log_message(
                f"[Plugin] Ensure frida-server is running on the target device (if applicable)."))
    except frida.InvalidArgumentError as e:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Invalid argument during Frida operation: {e}"))
    except frida.NotSupportedError as e:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Operation not supported by Frida: {e}"))
    except frida.ExecutableNotFoundError as e:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Frida could not find required executable: {e}"))
    except frida.IncompatibleExecutableError as e:
        app.update_output.emit(
            log_message(
                f"[Plugin] Error running '{plugin_name}': Target executable is incompatible: {e}"))
    except Exception as e:
        # Catch generic exceptions during attach or script load
        app.update_output.emit(
            log_message(
                f"[Plugin] Failed to attach or inject script '{plugin_name}' into PID {target_pid}: {e}"))
        app.update_output.emit(
            log_message(
                f"[Plugin] Possible causes: Insufficient permissions, anti-debugging measures, or Frida issues."))
        app.update_output.emit(log_message(traceback.format_exc()))
        # Clean up session if partially created
        if session:
            try:
                session.detach()
            except Exception:
                pass  # Ignore errors during cleanup detach


def run_ghidra_plugin_from_file(app, plugin_path):
    """
    Runs a Ghidra script on the current binary.

    Args:
        app: Application instance
        plugin_path: Path to the Ghidra script file
    """
    if not app.binary_path:
        app.update_output.emit(log_message("[Plugin] No binary selected."))
        return

    app.update_output.emit(log_message(
        f"[Plugin] Running Ghidra script from {plugin_path}..."))

    # Get Ghidra path from config
    ghidra_path = CONFIG.get(
        "ghidra_path", r"C:\Program Files\Ghidra\ghidraRun.bat")

    if not os.path.exists(ghidra_path):
        app.update_output.emit(log_message(
            f"[Plugin] Ghidra not found at {ghidra_path}"))
        app.update_output.emit(log_message(
            "[Plugin] Please configure the correct path in Settings"))
        return

    # Create a temporary directory for the Ghidra project
    temp_dir = tempfile.mkdtemp(prefix="intellicrack_ghidra_")
    project_name = "temp_project"

    try:
        app.update_output.emit(log_message(
            "[Plugin] Setting up Ghidra project..."))

        # Build the command
        cmd = [
            ghidra_path,
            temp_dir,
            project_name,
            "-import", app.binary_path,
            "-scriptPath", os.path.dirname(plugin_path),
            "-postScript", os.path.basename(plugin_path),
            "-overwrite"
        ]

        app.update_output.emit(log_message(
            "[Plugin] Running Ghidra headless analyzer..."))

        # Run Ghidra
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8"
        )

        stdout, stderr = process.communicate()

        # Process output
        if stdout:
            for line in stdout.splitlines():
                if line.strip():
                    app.update_output.emit(
                        log_message(f"[Ghidra] {line.strip()}"))

        if stderr:
            for line in stderr.splitlines():
                if line.strip():
                    app.update_output.emit(log_message(
                        f"[Ghidra Error] {line.strip()}"))

        app.update_output.emit(log_message(
            "[Plugin] Ghidra script execution complete"))

        # Check for any output files the script might have created
        result_files = []
        for file in os.listdir(temp_dir):
            if file not in [project_name, project_name + ".rep"]:
                result_files.append(os.path.join(temp_dir, file))

        if result_files:
            app.update_output.emit(log_message(
                "[Plugin] Ghidra script created output files:"))
            for file in result_files:
                app.update_output.emit(log_message(f"[Plugin] - {file}"))

    except Exception as e:
        app.update_output.emit(log_message(
            f"[Plugin] Error running Ghidra script: {e}"))
        app.update_output.emit(log_message(traceback.format_exc()))
    finally:
        # Clean up
        try:
            shutil.rmtree(temp_dir)
        except Exception as e:
            app.update_output.emit(
                log_message(
                    f"[Plugin] Warning: Failed to clean up temporary directory: {e}"))


def run_autonomous_patching(app):
    """
    Runs the fully autonomous patching process.
    This is the most automated method to bypass license protections.
    """
    if not app.binary_path:
        app.update_output.emit(log_message(
            "[AI Patching] No binary selected."))
        return

    app.update_output.emit(log_message(
        "[AI Patching] Starting autonomous patching process via UI action..."))
    app.analyze_status.setText("Running autonomous patching...")

    # Run in background thread
    threading.Thread(
        target=lambda: _run_autonomous_patching_thread(app)).start()


def _run_autonomous_patching_thread(self, app=None):
    """
    Background thread for autonomous patching.
    Integrates AdvancedVulnerabilityEngine, AdvancedPayloadGenerator, AdvancedDynamicAnalyzer, MLVulnerabilityPredictor.

    Args:
        self: The instance of the class
        app: Optional application instance. If None, uses self as the app.
    """
    # If app is not provided, use self as the app
    if app is None:
        app = self

    try:
        # --- Initial Setup ---
        self.clear_analysis_results.emit()
        self.update_analysis_results.emit(
            "Starting Autonomous AI Patching...\n")

        # --- Step 1: Comprehensive Analysis ---
        app.update_output.emit(
            log_message("[Patching] Phase 1: Comprehensive Analysis"))
        protection_results_text = []
        context = []  # Build context for AI
        context.append(f"Binary: {os.path.basename(app.binary_path)}")

        # 1a: Standard Protection Analysis
        app.update_output.emit(
            log_message("[ Patching] Running standard protection checks..."))
        app.update_analysis_results.emit(
            "\n--- Standard Protection Analysis ---\n")
        dongle_results = detect_hardware_dongles(app)
        protection_results_text.extend(dongle_results)
        dongle_found = any(
            "Detected hardware dongles" in line for line in dongle_results)
        context.append(f"Hardware Dongle: {'Yes' if dongle_found else 'No'}")
        app.update_analysis_results.emit(
            f"Hardware Dongle: {
                'Detected' if dongle_found else 'Not Detected'}\n")
        commercial_results = detect_commercial_protections(app.binary_path)
        protection_results_text.extend(commercial_results)
        commercial_found = any(
            "Detected " in line and "Confidence" in line for line in commercial_results)
        context.append(
            f"Commercial Protection: {
                'Yes' if commercial_found else 'No'}")
        app.update_analysis_results.emit(
            f"Commercial Protection: {
                'Detected' if commercial_found else 'Not Detected'}\n")
        integrity_results = detect_checksum_verification(app)
        protection_results_text.extend(integrity_results)
        integrity_found = any(
            "INTEGRITY VERIFICATION DETECTED" in line for line in integrity_results)
        context.append(
            f"Integrity Checks: {
                'Yes' if integrity_found else 'No'}")
        app.update_analysis_results.emit(
            f"Integrity Checks: {
                'Detected' if integrity_found else 'Not Detected'}\n")
        healing_results = detect_self_healing_code(app)
        protection_results_text.extend(healing_results)
        healing_found = any(
            "SELF-HEALING CODE DETECTED" in line for line in healing_results)
        context.append(
            f"Self-Healing Code: {'Yes' if healing_found else 'No'}")
        app.update_analysis_results.emit(
            f"Self-Healing Code: {'Detected' if healing_found else 'Not Detected'}\n")
        obfuscation_results = detect_obfuscation(app)
        protection_results_text.extend(obfuscation_results)
        obfuscation_found = any(
            "OBFUSCATION ASSESSMENT: HIGH CONFIDENCE" in line for line in obfuscation_results)
        context.append(
            f"Heavy Obfuscation: {
                'Yes' if obfuscation_found else 'No'}")
        app.update_analysis_results.emit(
            f"Heavy Obfuscation: {
                'Detected' if obfuscation_found else 'Not Detected'}\n")

        # 1b: Advanced Vulnerability Scan
        app.update_output.emit(
            log_message("[AI Patching] Running advanced vulnerability scan..."))
        app.update_analysis_results.emit(
            "\n--- Advanced Vulnerability Scan ---\n")
        vulnerabilities = []
        exploit_strategies = []
        vulnerability_summary = "Advanced scan not run or no vulnerabilities found."
        try:
            vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(
                app.binary_path)
            if vulnerabilities:
                vulnerability_summary = f"Found {
                    len(vulnerabilities)} vulnerabilities (Types: {
                    ', '.join(
                        list(
                            set(
                                v['type'] for v in vulnerabilities)))})"
                app.update_analysis_results.emit(vulnerability_summary + "\n")
                for vuln in vulnerabilities[:3]:
                    app.update_analysis_results.emit(
                        f" - Type: {vuln['type']}, Risk: {vuln.get('risk', 'N/A')}\n")
                try:
                    exploit_strategies = AdvancedVulnerabilityEngine.generate_exploit_strategy(
                        vulnerabilities)
                    app.update_output.emit(
                        log_message(
                            f"[AI Patching] Generated {
                                len(exploit_strategies)} exploit strategies."))
                    app.update_analysis_results.emit(
                        f"\n--- Potential Exploit Strategies ---\n")
                    for strat in exploit_strategies[:3]:
                        app.update_analysis_results.emit(
                            f" - Strategy: {strat.get('strategy')}, Technique: {strat.get('technique')}\n")
                    context.append("\n--- Potential Exploit Strategies ---")
                    for strat in exploit_strategies[:3]:
                        context.append(
                            f"- Strategy: {strat.get('strategy')}, Technique: {strat.get('technique')}")
                except Exception as e_strat:
                    app.update_output.emit(
                        log_message(
                            f"[AI Patching] Error generating exploit strategies: {e_strat}"))
            else:
                app.update_analysis_results.emit(vulnerability_summary + "\n")
            context.append(
                f"\n--- Vulnerability Summary ---\n{vulnerability_summary}")
        except Exception as e_vuln:
            app.update_output.emit(
                log_message(
                    f"[AI Patching] Advanced vulnerability scan error: {e_vuln}"))
            context.append(
                "\n--- Vulnerability Summary ---\nError during vulnerability scan.")

        # 1c: Advanced Dynamic Analysis (for context)
        app.update_output.emit(log_message(
            "[AI Patching] Running advanced dynamic analysis (for context)..."))
        app.update_analysis_results.emit(
            "\n--- Advanced Dynamic Analysis (Context) ---\n")
        dynamic_analysis_summary = "Dynamic analysis skipped (analyzer not available)."
        try:
            if hasattr(app, 'dynamic_analyzer') and app.dynamic_analyzer:
                dynamic_results = app.dynamic_analyzer.run_comprehensive_analysis()
                frida_msgs = dynamic_results.get(
                    'frida_runtime_analysis', {}).get(
                    'messages', [])
                process_behavior = dynamic_results.get(
                    'process_behavior_analysis', {})
                connections = process_behavior.get('connections', [])
                summary_parts = []
                if frida_msgs:
                    summary_parts.append(f"{len(frida_msgs)} Frida messages")
                if connections:
                    summary_parts.append(
                        f"{len(connections)} network connections")
                if summary_parts:
                    dynamic_analysis_summary = ", ".join(summary_parts)
                else:
                    dynamic_analysis_summary = "No significant runtime events detected."
                app.update_output.emit(
                    log_message(
                        f"[Dynamic Analysis] Context Summary: {dynamic_analysis_summary}"))
                app.update_analysis_results.emit(
                    dynamic_analysis_summary + "\n")
            else:
                app.update_analysis_results.emit(
                    dynamic_analysis_summary + "\n")
            context.append(
                f"\n--- Dynamic Analysis Summary ---\n{dynamic_analysis_summary}")
        except Exception as e_dyn_ctx:
            err_msg = f"[AI Patching] Error during dynamic analysis context run: {e_dyn_ctx}"
            app.update_output.emit(log_message(err_msg))
            app.update_analysis_results.emit(err_msg + "\n")
            context.append(
                f"\n--- Dynamic Analysis Summary ---\nError during dynamic analysis.")

        # 1d: ML Vulnerability Prediction
