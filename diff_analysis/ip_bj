            with open(temp_file.name, 'wb') as f:
                pickle.dump(results, f)
            return 0
        except Exception as e:
            # Write error to temp file
            with open(temp_file.name, 'wb') as f:
                pickle.dump([f"Error in sandbox: {e}"], f)
            return 1

    # Create and start the sandbox process
    process = multiprocessing.Process(target=sandbox_process)
    process.start()

    # Wait for the process to finish with configurable timeout
    timeout = CONFIG.get("plugin_timeout", 30)  # Get timeout from config, default 30 seconds
    start_time = time.time()

    while process.is_alive():
        if time.time() - start_time > timeout:
            # Process took too long, terminate it
            process.terminate()
            time.sleep(0.1)
            if process.is_alive():
                process.kill()

            return [f"Error: Plugin execution timed out after {timeout} seconds"]

        time.sleep(0.1)

    try:
        # Create request
        request = {
            "plugin_code": encoded_plugin,
            "method_name": method_name,
            "args": encoded_args,
            "kwargs": encoded_kwargs
        }

        # Connect to remote server
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((self.remote_host, self.remote_port))

            # Send request
            s.sendall(json.dumps(request).encode('utf-8') + b'\n')

            # Receive response
            response = b''
            while True:
                data = s.recv(4096)
                if not data:
                    break
                response += data

                # Check for end of response
                if response.endswith(b'\n'):
                    break

        # Parse response
        response_data = json.loads(response.decode('utf-8'))

        if response_data.get("status") == "success":
            # Decode results
            encoded_results = response_data.get("results", "")
            results = pickle.loads(base64.b64decode(encoded_results))
            return results
        else:
            error = response_data.get("error", "Unknown error")
            return [f"Remote execution error: {error}"]
    except Exception as e:
        self.logger.error(f"Error executing remote plugin: {e}")
        return [f"Error executing remote plugin: {e}"]

    @staticmethod
    def start_server(host="localhost", port=8765):
        """
        Start a remote plugin execution server

        Args:
            host: Host to bind to
            port: Port to bind to
        """
        logger = logging.getLogger(__name__)

        def handle_client(client_socket):
            """Handle a client connection"""
            try:
                # Receive request
                request_data = b''
                while True:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    request_data += data

                    # Check for end of request
                    if request_data.endswith(b'\n'):
                        break

                # Parse request
                request = json.loads(request_data.decode('utf-8'))

                # Extract plugin code and arguments
                plugin_code = base64.b64decode(request.get("plugin_code", ""))
                method_name = request.get("method_name", "")
                args = pickle.loads(base64.b64decode(request.get("args", "")))
                kwargs = pickle.loads(base64.b64decode(request.get("kwargs", "")))

                # Write plugin code to temporary file
                with tempfile.NamedTemporaryFile(suffix='.py', delete=False) as f:
                    plugin_path = f.name
                    f.write(plugin_code)

                try:
                    # Import plugin
                    sys.path.insert(0, os.path.dirname(plugin_path))
                    plugin_module = __import__(os.path.basename(plugin_path)[:-3])

                    # Create plugin instance
                    plugin_class = getattr(plugin_module, "Plugin")
                    plugin_instance = plugin_class()

                    # Run plugin in sandbox
                    results = run_plugin_in_sandbox(plugin_instance, method_name, *args, **kwargs)

                    # Encode results
                    encoded_results = base64.b64encode(pickle.dumps(results)).decode('utf-8')

                    # Create response
                    response = {
                        "status": "success",
                        "results": encoded_results
                    }
                except Exception as e:
                    # Create error response
                    response = {
                        "status": "error",
                        "error": str(e)
                    }
                finally:
                    # Clean up
                    try:
                        os.unlink(plugin_path)
                    except:
                        pass

                    # Remove plugin path from sys.path
                    if os.path.dirname(plugin_path) in sys.path:
                        sys.path.remove(os.path.dirname(plugin_path))

                # Send response
                client_socket.sendall(json.dumps(response).encode('utf-8') + b'\n')
            except Exception as e:
                logger.error(f"Error handling client: {e}")

                # Send error response
                response = {
                    "status": "error",
                    "error": str(e)
                }
                client_socket.sendall(json.dumps(response).encode('utf-8') + b'\n')
            finally:
                client_socket.close()

        # Create server socket
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            # Bind and listen
            server_socket.bind((host, port))
            server_socket.listen(5)

            logger.info(f"Remote plugin execution server started on {host}:{port}")

            # Accept connections
            while True:
                client_socket, addr = server_socket.accept()
                logger.info(f"Accepted connection from {addr}")

                # Handle client in a new thread
                client_thread = threading.Thread(target=handle_client, args=(client_socket,))
                client_thread.daemon = True
                client_thread.start()
        except KeyboardInterrupt:
            logger.info("Server shutting down")
        except Exception as e:
            logger.error(f"Server error: {e}")
        finally:
            server_socket.close()

def run_plugin_remotely(app, plugin_path, method_name, *args, **kwargs):
    """
    Run a plugin on a remote system

    Args:
        app: Application instance
        plugin_path: Path to the plugin file
        method_name: Method name to call
        *args: Arguments to pass to the method
        **kwargs: Keyword arguments to pass to the method

    Returns:
        list: Results from the plugin method
    """
    # Check if remote plugins are enabled
    if not CONFIG.get("enable_remote_plugins", False):
        app.update_output.emit(log_message(
            "[Remote Plugin] Error: Remote plugin execution is disabled in settings"))
        return ["Error: Remote plugin execution is disabled in settings"]

    # Ask for remote host and port

    remote_host, ok = QInputDialog.getText(
        app,
        "Remote Host",
        "Enter remote host:",
        text="localhost"
    )

    if not ok:
        return ["Cancelled by user"]

    remote_port, ok = QInputDialog.getInt(
        app,
        "Remote Port",
        "Enter remote port:",
        value=8765,
        min=1,
        max=65535
    )

    if not ok:
        return ["Cancelled by user"]

    # Execute plugin remotely
    app.update_output.emit(log_message(
        f"[Remote Plugin] Executing {os.path.basename(plugin_path)} on {remote_host}:{remote_port}"))

    executor = RemotePluginExecutor(remote_host, remote_port)
    results = executor.execute_plugin(plugin_path, method_name, *args, **kwargs)

    return results

# -------------------------------
# Binary Similarity Search
# -------------------------------

class BinarySimilaritySearchDialog(QDialog):
    """
    Binary similarity search dialog for finding similar cracking patterns
    """

    def __init__(self, binary_path, parent=None):
        """
        Initialize the binary similarity search dialog

        Args:
            binary_path: Path to the binary file
            parent: Parent widget
        """
        super().__init__(parent)
        self.binary_path = binary_path
        self.database_path = os.path.join(os.getcwd(), "binary_database.json")
        self.similar_binaries = []
        self.search_engine = BinarySimilaritySearch(self.database_path)

        self.setWindowTitle("Binary Similarity Search")
        self.setGeometry(100, 100, 900, 700)
        self.setModal(True)

        self.init_ui()
        self.load_database_info()

    def init_ui(self):
        """Initialize the user interface."""
        layout = QVBoxLayout(self)

        # Header with binary info
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel(f"<b>Target Binary:</b> {os.path.basename(self.binary_path)}"))
        header_layout.addStretch()

        # Database info
        self.db_info_label = QLabel("Database: Loading...")
        header_layout.addWidget(self.db_info_label)

        layout.addLayout(header_layout)

        # Main splitter
        splitter = QSplitter(Qt.Vertical)

        # Top panel - Search controls and results
        top_panel = QWidget()
        top_layout = QVBoxLayout(top_panel)

        # Search controls
        controls_layout = QHBoxLayout()

        controls_layout.addWidget(QLabel("Similarity Threshold:"))

        self.threshold_slider = QSlider(Qt.Horizontal)
        self.threshold_slider.setMinimum(1)
        self.threshold_slider.setMaximum(10)
        self.threshold_slider.setValue(7)  # Default 0.7
        self.threshold_slider.setTickPosition(QSlider.TicksBelow)
        self.threshold_slider.setTickInterval(1)
        controls_layout.addWidget(self.threshold_slider)

        self.threshold_label = QLabel("0.7")
        controls_layout.addWidget(self.threshold_label)

        self.threshold_slider.valueChanged.connect(self.update_threshold_label)

        search_btn = QPushButton("Search Similar Binaries")
        search_btn.clicked.connect(self.search_similar_binaries)
        controls_layout.addWidget(search_btn)

        add_to_db_btn = QPushButton("Add to Database")
        add_to_db_btn.clicked.connect(self.add_to_database)
        controls_layout.addWidget(add_to_db_btn)

        top_layout.addLayout(controls_layout)

        # Results table
        top_layout.addWidget(QLabel("<b>Similar Binaries:</b>"))

        self.results_table = QTableWidget()
        self.results_table.setColumnCount(4)
        self.results_table.setHorizontalHeaderLabels(["Binary", "Similarity", "Path", "Patterns"])
        self.results_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.results_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.results_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.results_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)
        self.results_table.itemSelectionChanged.connect(self.result_selected)

        top_layout.addWidget(self.results_table)

        splitter.addWidget(top_panel)

        # Bottom panel - Pattern details
        bottom_panel = QWidget()
        bottom_layout = QVBoxLayout(bottom_panel)

        bottom_layout.addWidget(QLabel("<b>Cracking Patterns:</b>"))

        self.patterns_view = QTextEdit()
        self.patterns_view.setReadOnly(True)
        bottom_layout.addWidget(self.patterns_view)

        # Apply pattern button
        apply_layout = QHBoxLayout()
        apply_layout.addStretch()

        self.apply_pattern_btn = QPushButton("Apply Selected Pattern")
        self.apply_pattern_btn.clicked.connect(self.apply_selected_pattern)
        self.apply_pattern_btn.setEnabled(False)
        apply_layout.addWidget(self.apply_pattern_btn)

        bottom_layout.addLayout(apply_layout)

        splitter.addWidget(bottom_panel)

        # Set initial sizes
        splitter.setSizes([400, 300])

        layout.addWidget(splitter)

        # Bottom buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.reject)
        button_layout.addWidget(close_btn)

        layout.addLayout(button_layout)

        # Status bar
        self.status_label = QLabel("Ready")
        layout.addWidget(self.status_label)

    def load_database_info(self):
        """Load database information."""
        try:
            if os.path.exists(self.database_path):
                with open(self.database_path, "r") as f:
                    database = json.load(f)
                    binary_count = len(database.get("binaries", []))
                    self.db_info_label.setText(f"Database: {binary_count} binaries")
            else:
                self.db_info_label.setText("Database: Not found (will be created)")
        except Exception as e:
            self.db_info_label.setText(f"Database Error: {e}")

    def update_threshold_label(self, value):
        """Update the threshold label when slider changes."""
        threshold = value / 10.0
        self.threshold_label.setText(f"{threshold:.1f}")

    def search_similar_binaries(self):
        """Search for similar binaries."""
        threshold = self.threshold_slider.value() / 10.0
        self.status_label.setText(f"Searching for similar binaries (threshold: {threshold:.1f})...")

        # Use QThread to avoid freezing the UI
        class SearchThread(QThread):
            """
            QThread for running binary similarity searches in the background.

            Emits results via result_signal to avoid blocking the UI.
            """
            result_signal = pyqtSignal(list)

            def __init__(self, search_engine, binary_path, threshold):
                """
                Initialize a SearchThread to perform binary similarity analysis.

                Args:
                    search_engine (BinarySimilarityEngine): Engine instance to perform the similarity search
                    binary_path (str): Path to the binary file to analyze
                    threshold (float): Similarity threshold between 0.0 and 1.0 to filter results
                """
                super().__init__()
                self.search_engine = search_engine
                self.binary_path = binary_path
                self.threshold = threshold

            def run(self):
                """Execute binary similarity search in a separate thread.

                Searches for similar binaries using the search engine and emits
                results via signal when complete. Returns empty list on error.
                """
                try:
                    results = self.search_engine.search_similar_binaries(self.binary_path, self.threshold)
                    self.result_signal.emit(results)
                except Exception as e:
                    # Log the error
                    logging.error(f"Binary similarity search failed: {str(e)}")

                    # For debugging, capture stack trace
                    import traceback
                    stack_trace = traceback.format_exc()
                    logging.debug(f"Stack trace: {stack_trace}")

                    # Return error information with the empty results
                    error_info = {
                        "error": str(e),
                        "error_type": type(e).__name__,
                        "stack_trace": stack_trace,
                        "binary_path": self.binary_path,
                        "timestamp": time.strftime('%Y-%m-%d %H:%M:%S')
                    }

                    # Emit empty list plus error information
                    self.result_signal.emit([{"error_info": error_info}])

        # Create and start thread
        self.search_thread = SearchThread(self.search_engine, self.binary_path, threshold)
        self.search_thread.result_signal.connect(self.show_search_results)
        self.search_thread.start()

    def show_search_results(self, results):
        """Show search results."""
        self.similar_binaries = results
        self.results_table.setRowCount(len(results))

        for i, result in enumerate(results):
            path = result.get("path", "")
            similarity = result.get("similarity", 0)
            patterns = result.get("cracking_patterns", [])

            self.results_table.setItem(i, 0, QTableWidgetItem(os.path.basename(path)))
            self.results_table.setItem(i, 1, QTableWidgetItem(f"{similarity:.2f}"))
            self.results_table.setItem(i, 2, QTableWidgetItem(path))
            self.results_table.setItem(i, 3, QTableWidgetItem(f"{len(patterns)} patterns"))

        if results:
            self.status_label.setText(f"Found {len(results)} similar binaries")
        else:
            self.status_label.setText("No similar binaries found")

    def result_selected(self):
        """Handle result selection."""
        selected_rows = self.results_table.selectionModel().selectedRows()
        if not selected_rows:
            self.patterns_view.clear()
            self.apply_pattern_btn.setEnabled(False)
            return

        row = selected_rows[0].row()
        if row < 0 or row >= len(self.similar_binaries):
            return

        result = self.similar_binaries[row]
        patterns = result.get("cracking_patterns", [])

        if patterns:
            patterns_text = f"Cracking patterns for {os.path.basename(result.get('path', ''))}:\n\n"

            for i, pattern in enumerate(patterns):
                patterns_text += f"Pattern {i+1}:\n"
                patterns_text += f"{pattern}\n\n"

            self.patterns_view.setText(patterns_text)
            self.apply_pattern_btn.setEnabled(True)
        else:
            self.patterns_view.setText("No cracking patterns available for this binary")
            self.apply_pattern_btn.setEnabled(False)

    def apply_selected_pattern(self):
        """Apply the selected pattern."""
        selected_rows = self.results_table.selectionModel().selectedRows()
        if not selected_rows:
            return

        row = selected_rows[0].row()
        if row < 0 or row >= len(self.similar_binaries):
            return

        result = self.similar_binaries[row]
        patterns = result.get("cracking_patterns", [])

        if not patterns:
            return

        # If multiple patterns, ask which one to apply
        pattern_to_apply = None
        if len(patterns) > 1:
            pattern_items = [f"Pattern {i+1}" for i in range(len(patterns))]
            pattern_index, ok = QInputDialog.getItem(
                self, "Select Pattern", "Choose a pattern to apply:", pattern_items, 0, False)

            if ok and pattern_index:
                index = pattern_items.index(pattern_index)
                pattern_to_apply = patterns[index]
        else:
            pattern_to_apply = patterns[0]

        if pattern_to_apply:
            # Parse the pattern and apply it
            try:
                # Extract patch instructions from the pattern
                instructions = parse_patch_instructions(pattern_to_apply)

                if instructions:
                    # Ask for confirmation
                    response = QMessageBox.question(
                        self,
                        "Apply Pattern",
                        f"Apply {len(instructions)} patches from this pattern?\n\nThis will create a new patched file.",
                        QMessageBox.Yes | QMessageBox.No
                    )

                    if response == QMessageBox.Yes:
                        # Get the parent app instance
                        parent = self.parent()

                        # Check if parent has the apply_cracking_pattern method (new approach)
                        if parent and hasattr(parent, "apply_cracking_pattern"):
                            # Get the source binary path from the selected result
                            source_binary = result.get("path", "")
                            target_binary = self.binary_path

                            # Call the parent's apply_cracking_pattern method
                            parent.apply_cracking_pattern(source_binary, target_binary)

                            self.status_label.setText("Applied cracking pattern from similar binary")
                        # Fall back to old approach
                        elif parent and hasattr(parent, "potential_patches") and hasattr(parent, "update_output"):
                            # Update parent's potential patches
                            parent.potential_patches = instructions
                            parent.update_output.emit(log_message(
                                f"[Similarity Search] Loaded {len(instructions)} patches from similar binary"))

                            # Apply the patches
                            apply_parsed_patch_instructions_with_validation(parent, instructions)

                            self.status_label.setText(f"Applied {len(instructions)} patches from pattern")
                        else:
                            QMessageBox.warning(self, "Error", "Could not apply pattern: Parent application not accessible")
                else:
                    QMessageBox.warning(self, "Error", "Could not parse any patch instructions from the pattern")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Error applying pattern: {e}")

    def add_to_database(self):
        """Add the current binary to the database."""
        # Ask for cracking patterns
        patterns_text, ok = QInputDialog.getMultiLineText(
            self,
            "Add to Database",
            "Enter cracking patterns for this binary (optional):",
            ""
        )

        if not ok:
            return

        patterns = []
        if patterns_text.strip():
            patterns = [patterns_text.strip()]

        # Add to database
        try:
            success = self.search_engine.add_binary(self.binary_path, patterns)

            if success:
                QMessageBox.information(
                    self,
                    "Success",
                    f"Added {os.path.basename(self.binary_path)} to the database"
                )
                self.load_database_info()
            else:
                QMessageBox.warning(
                    self,
                    "Error",
                    "Failed to add binary to database"
                )
        except Exception as e:
            QMessageBox.critical(
                self,
                "Error",
                f"Error adding binary to database: {e}"
            )

class BinarySimilaritySearch:
    """
    Binary similarity search to find similar cracking patterns
    """

    def __init__(self, database_path="binary_database.json"):
        """
        Initialize the binary similarity search

        Args:
            database_path: Path to the binary database
        """
        self.database_path = database_path
        self.database = self._load_database()
        self.logger = logging.getLogger(__name__)

    def _load_database(self):
        """
        Load the binary database

        Returns:
            dict: Binary database
        """
        if os.path.exists(self.database_path):
            try:
                with open(self.database_path, "r") as f:
                    return json.load(f)
            except Exception as e:
                self.logger.error(f"Error loading binary database: {e}")
                return {"binaries": []}
        else:
            return {"binaries": []}

    def _save_database(self):
        """Save the binary database"""
        try:
            with open(self.database_path, "w") as f:
                json.dump(self.database, f, indent=4)
        except Exception as e:
            self.logger.error(f"Error saving binary database: {e}")

    def add_binary(self, binary_path, cracking_patterns=None):
        """
        Add a binary to the database

        Args:
            binary_path: Path to the binary
            cracking_patterns: List of cracking patterns

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Extract binary features
            features = self._extract_binary_features(binary_path)

            # Add to database
            binary_entry = {
                "path": binary_path,
                "features": features,
                "cracking_patterns": cracking_patterns or [],
                "added": datetime.datetime.now().isoformat()
            }

            self.database["binaries"].append(binary_entry)
            self._save_database()

            self.logger.info(f"Added binary {binary_path} to database")
            return True
        except Exception as e:
            self.logger.error(f"Error adding binary {binary_path} to database: {e}")
            return False

    def _extract_binary_features(self, binary_path):
        """
        Extract features from a binary

        Args:
            binary_path: Path to the binary

        Returns:
            dict: Extracted features
        """
        try:
            pe = pefile.PE(binary_path)

            # Extract basic information
            features = {
                "machine": pe.FILE_HEADER.Machine,
                "timestamp": pe.FILE_HEADER.TimeDateStamp,
                "characteristics": pe.FILE_HEADER.Characteristics,
                "sections": [],
                "imports": [],
                "exports": []
            }

            # Extract section information
            for section in pe.sections:
                section_name = section.Name.decode('utf-8', 'ignore').strip("\x00")
                section_info = {
                    "name": section_name,
                    "virtual_address": section.VirtualAddress,
                    "virtual_size": section.Misc_VirtualSize,
                    "raw_data_size": section.SizeOfRawData,
                    "entropy": calculate_entropy(section.get_data())
                }
                features["sections"].append(section_info)

            # Extract import information
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', 'ignore')
                    for imp in entry.imports:
                        if imp.name:
                            imp_name = imp.name.decode('utf-8', 'ignore')
                            features["imports"].append(f"{dll_name}:{imp_name}")

            # Extract export information
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        exp_name = exp.name.decode('utf-8', 'ignore')
                        features["exports"].append(exp_name)

            return features
        except Exception as e:
            self.logger.error(f"Error extracting features from {binary_path}: {e}")
            return {}

    def search_similar_binaries(self, binary_path, threshold=0.7):
        """
        Search for similar binaries

        Args:
            binary_path: Path to the binary
            threshold: Similarity threshold (0.0 to 1.0)

        Returns:
            list: Similar binaries
        """
        try:
            # Extract binary features
            features = self._extract_binary_features(binary_path)

            # Calculate similarity with each binary in the database
            similar_binaries = []
            for binary in self.database["binaries"]:
                similarity = self._calculate_similarity(features, binary["features"])
                if similarity >= threshold:
                    similar_binaries.append({
                        "path": binary["path"],
                        "similarity": similarity,
                        "cracking_patterns": binary["cracking_patterns"]
                    })

            # Sort by similarity (descending)
            similar_binaries.sort(key=lambda x: x["similarity"], reverse=True)

            self.logger.info(f"Found {len(similar_binaries)} similar binaries for {binary_path}")
            return similar_binaries
        except Exception as e:
            self.logger.error(f"Error searching similar binaries for {binary_path}: {e}")
            return []

    def _calculate_similarity(self, features1, features2):
        """
        Calculate similarity between two sets of features

        Args:
            features1: First set of features
            features2: Second set of features

        Returns:
            float: Similarity score (0.0 to 1.0)
        """
        try:
            # This is a simplified similarity calculation
            # In a real implementation, you would use more sophisticated methods

            # Calculate section similarity
            section_similarity = self._calculate_section_similarity(
                features1.get("sections", []),
                features2.get("sections", [])
            )

            # Calculate import similarity
            import_similarity = self._calculate_list_similarity(
                features1.get("imports", []),
                features2.get("imports", [])
            )

            # Calculate export similarity
            export_similarity = self._calculate_list_similarity(
                features1.get("exports", []),
                features2.get("exports", [])
            )

            # Calculate overall similarity
            similarity = (section_similarity * 0.5 + import_similarity * 0.3 + export_similarity * 0.2)

            return similarity
        except Exception as e:
            self.logger.error(f"Error calculating similarity: {e}")
            return 0.0

    def _calculate_section_similarity(self, sections1, sections2):
        """
        Calculate similarity between two sets of sections

        Args:
            sections1: First set of sections
            sections2: Second set of sections

        Returns:
            float: Similarity score (0.0 to 1.0)
        """
        try:
            if not sections1 or not sections2:
                return 0.0

            # Compare section names
            names1 = [s.get("name", "") for s in sections1]
            names2 = [s.get("name", "") for s in sections2]

            name_similarity = self._calculate_list_similarity(names1, names2)

            # Compare section entropies
            entropies1 = [s.get("entropy", 0) for s in sections1]
            entropies2 = [s.get("entropy", 0) for s in sections2]

            entropy_similarity = 0.0
            if entropies1 and entropies2:
                # Calculate average entropy difference
                min_len = min(len(entropies1), len(entropies2))
                entropy_diff = sum(abs(entropies1[i] - entropies2[i]) for i in range(min_len)) / min_len
                entropy_similarity = max(0.0, 1.0 - entropy_diff / 8.0)  # Normalize by max entropy

            return name_similarity * 0.5 + entropy_similarity * 0.5
        except Exception as e:
            self.logger.error(f"Error calculating section similarity: {e}")
            return 0.0

    def _calculate_list_similarity(self, list1, list2):
        """
        Calculate similarity between two lists

        Args:
            list1: First list
            list2: Second list

        Returns:
            float: Similarity score (0.0 to 1.0)
        """
        try:
            if not list1 or not list2:
                return 0.0

            # Convert to sets
            set1 = set(list1)
            set2 = set(list2)

            # Calculate Jaccard similarity
            intersection = len(set1.intersection(set2))
            union = len(set1.union(set2))

            return intersection / union if union > 0 else 0.0
        except Exception as e:
            self.logger.error(f"Error calculating list similarity: {e}")
            return 0.0

# -------------------------------
# Visual Patch Editor
# -------------------------------

class VisualPatchEditorDialog(QDialog):
    """
    Visual Patch Editor with drag-and-drop functionality
    """

    def __init__(self, binary_path, patches, parent=None):
        """
        Initialize the Visual Patch Editor dialog

        Args:
            binary_path: Path to the binary file
            patches: List of patches to edit
            parent: Parent widget
        """
        super().__init__(parent)
        self.binary_path = binary_path
        self.patches = patches.copy() if patches else []
        self.original_patches = patches.copy() if patches else []
        self.disassembly_cache = {}

        self.setWindowTitle("Visual Patch Editor")
        self.setGeometry(100, 100, 1000, 800)
        self.setModal(True)

        self.init_ui()
        self.populate_patch_list()

    def init_ui(self):
        """Initialize the user interface."""
        layout = QVBoxLayout(self)

        # Header with binary info
        header_layout = QHBoxLayout()
        header_layout.addWidget(QLabel(f"<b>Binary:</b> {os.path.basename(self.binary_path)}"))
        header_layout.addStretch()
        patch_count_label = QLabel(f"<b>Patches:</b> {len(self.patches)}")
        header_layout.addWidget(patch_count_label)
        layout.addLayout(header_layout)

        # Main splitter
        splitter = QSplitter(Qt.Horizontal)

        # Left panel - Patch list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)

        # Toolbar for patch list
        list_toolbar = QHBoxLayout()
        add_btn = QPushButton("Add Patch")
        add_btn.clicked.connect(self.add_new_patch)
        list_toolbar.addWidget(add_btn)

        remove_btn = QPushButton("Remove Patch")
        remove_btn.clicked.connect(self.remove_selected_patch)
        list_toolbar.addWidget(remove_btn)

        duplicate_btn = QPushButton("Duplicate")
        duplicate_btn.clicked.connect(self.duplicate_selected_patch)
        list_toolbar.addWidget(duplicate_btn)

        left_layout.addLayout(list_toolbar)

        # Patch list with drag-drop support
        self.patch_list = QListWidget()
        self.patch_list.setDragDropMode(QAbstractItemView.InternalMove)
        self.patch_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.patch_list.currentItemChanged.connect(self.patch_selected)
        self.patch_list.model().rowsMoved.connect(self.patches_reordered)
        left_layout.addWidget(self.patch_list)

        splitter.addWidget(left_panel)

        # Right panel - Patch editor
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)

        # Patch details form
        form_layout = QFormLayout()

        self.address_edit = QLineEdit()
        self.address_edit.setPlaceholderText("e.g., 0x401000")
        form_layout.addRow("Address:", self.address_edit)

        self.bytes_edit = QLineEdit()
        self.bytes_edit.setPlaceholderText("e.g., 9090909090")
        form_layout.addRow("New Bytes:", self.bytes_edit)

        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(80)
        form_layout.addRow("Description:", self.description_edit)

        # Apply changes button
        update_btn = QPushButton("Update Patch")
        update_btn.clicked.connect(self.update_current_patch)
        form_layout.addRow("", update_btn)

        right_layout.addLayout(form_layout)

