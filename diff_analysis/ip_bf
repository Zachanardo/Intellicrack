        Add a formatted table to a section

        Args:
            section_index: Index of the section to add to
            title: Title for the table
            headers: List of column headers
            rows: List of rows, where each row is a list of cell values
            caption: Optional caption for the table
            column_widths: List of column width percentages (should sum to 100)
            styles: Dictionary of style settings for the table
        """
        if section_index < 0 or section_index >= len(self.sections):
            self.logger.error(f"Invalid section index: {section_index}")
            return -1

        # Format and validate table data
        formatted_rows = []
        for row in rows:
            # Ensure row has same length as headers
            if len(row) != len(headers):
                self.logger.warning(f"Row length {len(row)} doesn't match headers length {len(headers)}. Padding row.")
                # Pad or truncate row to match headers
                if len(row) < len(headers):
                    row = row + [""] * (len(headers) - len(row))
                else:
                    row = row[:len(headers)]
            formatted_rows.append(row)

        # Calculate column statistics for better formatting
        col_stats = []
        for i in range(len(headers)):
            col_values = [str(row[i]) for row in formatted_rows if i < len(row)]
            col_stats.append({
                'min_length': min([len(val) for val in col_values]) if col_values else 0,
                'max_length': max([len(val) for val in col_values]) if col_values else 0,
                'avg_length': sum([len(val) for val in col_values]) / len(col_values) if col_values else 0
            })

        # Create table subsection with enhanced metadata
        subsection = {
            'title': title,
            'content': {
                'headers': headers,
                'rows': formatted_rows,
                'stats': col_stats
            },
            'type': 'table',
            'row_count': len(formatted_rows),
            'col_count': len(headers),
            'caption': caption or title,
            'column_widths': column_widths,
            'styles': styles or {},
            'total_cells': len(headers) * len(formatted_rows)
        }

        # Add to section
        self.sections[section_index]['subsections'].append(subsection)

        # Add to index
        self.index_entries.append({
            'text': f"Table: {title}",
            'section': section_index,
            'type': 'table',
            'size': f"{len(formatted_rows)}x{len(headers)}"
        })

        # Add to TOC if it's a substantial table
        if len(formatted_rows) >= 5 or len(headers) >= 5:
            self.toc_entries.append({
                'title': f"Table: {title}",
                'section_id': section_index,
                'page': self.current_page,
                'type': 'table'
            })

        self.logger.info(f"Added table: {title} ({len(formatted_rows)}x{len(headers)}) to section: {self.sections[section_index]['title']}")
        return len(self.sections[section_index]['subsections']) - 1

    def generate_report(self, output_path, report_format='pdf'):
        """
        Generate the report in the specified format

        Args:
            output_path: Path where the report will be saved
            report_format: Format of the report (pdf, html, docx)

        Returns:
            Path to the generated report file
        """
        self.logger.info(f"Generating {report_format.upper()} report at {output_path}")

        try:
            # Determine report format
            if report_format not in ['pdf', 'html', 'docx']:
                self.logger.warning(f"Unsupported format: {report_format}. Defaulting to PDF.")
                report_format = 'pdf'

            # Ensure output directory exists
            os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)

            # Generate report based on format
            if report_format == 'pdf':
                return self._generate_pdf_report(output_path)
            elif report_format == 'html':
                return self._generate_html_report(output_path)
            elif report_format == 'docx':
                return self._generate_docx_report(output_path)

            # For now, we'll generate an HTML report and convert it to PDF
            html = self._generate_html_report()

            # Save HTML to a temporary file
            html_path = output_path.replace('.pdf', '.html')
            with open(html_path, 'w') as f:
                f.write(html)

            self.logger.info(f"Generated HTML report: {html_path}")

            # In a real implementation, we would convert HTML to PDF here
            # For now, we'll just copy the HTML file to the PDF path
            # and pretend it's a PDF

            # Check if output directory exists
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)

            # "Convert" HTML to PDF (in reality, just copy the file)
            # In a real implementation, we would use a library like weasyprint or wkhtmltopdf
            # to convert HTML to PDF
            with open(html_path, 'r') as f:
                html_content = f.read()

            with open(output_path, 'w') as f:
                f.write(html_content)

            self.logger.info(f"Generated PDF report: {output_path}")
            return output_path

        except Exception as e:
            self.logger.error(f"Error generating report: {e}")
            return None

    def _generate_html_report(self):
        """Generate an HTML version of the report"""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>{self.title}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1, h2, h3 {{ color: #333; }}
                table {{ border-collapse: collapse; width: 100%; margin-bottom: 20px; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                tr:nth-child(even) {{ background-color: #f9f9f9; }}
                .code {{ font-family: monospace; background-color: #f5f5f5; padding: 10px; border-radius: 5px; white-space: pre-wrap; }}
                .image {{ text-align: center; margin: 20px 0; }}
                .image img {{ max-width: 100%; }}
                .caption {{ font-style: italic; margin-top: 5px; }}
                .header {{ display: flex; align-items: center; margin-bottom: 20px; }}
                .logo {{ margin-right: 20px; }}
                .logo img {{ max-width: 100px; max-height: 100px; }}
                .title {{ flex-grow: 1; }}
                .metadata {{ margin-bottom: 20px; }}
                .toc {{ margin-bottom: 30px; }}
                .section {{ margin-bottom: 30px; }}
                .subsection {{ margin-bottom: 20px; }}
                .recommendations {{ margin-top: 20px; }}
                .recommendation {{ margin-bottom: 15px; padding: 10px; border-left: 4px solid #007bff; background-color: #f8f9fa; }}
                .priority-high {{ border-left-color: #dc3545; }}
                .priority-medium {{ border-left-color: #ffc107; }}
                .priority-low {{ border-left-color: #28a745; }}
            </style>
        </head>
        <body>
            <div class="header">
        """

        # Add logo if available
        if self.logo_path and os.path.exists(self.logo_path):
            html += f"""
                <div class="logo">
                    <img src="{self.logo_path}" alt="Logo">
                </div>
            """

        # Add title and metadata
        html += f"""
                <div class="title">
                    <h1>{self.title}</h1>
                    <div class="metadata">
                        <p>Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                        <p>Author: {self.author}</p>
        """

        if self.company:
            html += f"""
                        <p>Company: {self.company}</p>
            """

        html += """
                    </div>
                </div>
            </div>

            <div class="toc">
                <h2>Table of Contents</h2>
                <ol>
        """

        # Add table of contents
        for i, section in enumerate(self.sections):
            html += f"""
                    <li><a href="#section-{i}">{section['title']}</a></li>
            """

        html += """
                </ol>
            </div>
        """

        # Add sections
        for i, section in enumerate(self.sections):
            html += f"""
            <div class="section" id="section-{i}">
                <h2>{section['title']}</h2>
            """

            # Add section content if available
            if section['content'] and section['type'] == 'text':
                html += f"""
                <p>{section['content'].replace('\n', '<br>')}</p>
                """

            # Add subsections
            for j, subsection in enumerate(section['subsections']):
                html += f"""
                <div class="subsection" id="subsection-{i}-{j}">
                    <h3>{subsection['title']}</h3>
                """

                # Add subsection content based on type
                if subsection['type'] == 'text':
                    html += f"""
                    <p>{subsection['content'].replace('\n', '<br>')}</p>
                    """
                elif subsection['type'] == 'code':
                    html += f"""
                    <div class="code">{subsection['content']}</div>
                    """
                elif subsection['type'] == 'image':
                    html += f"""
                    <div class="image">
                        <img src="{subsection['content']}" alt="{subsection['title']}">
                    """

                    if 'caption' in subsection and subsection['caption']:
                        html += f"""
                        <div class="caption">{subsection['caption']}</div>
                        """

                    html += """
                    </div>
                    """
                elif subsection['type'] == 'table':
                    html += """
                    <table>
                        <tr>
                    """

                    # Add headers
                    for header in subsection['content']['headers']:
                        html += f"""
                            <th>{header}</th>
                        """

                    html += """
                        </tr>
                    """

                    # Add rows
                    for row in subsection['content']['rows']:
                        html += """
                        <tr>
                        """

                        for cell in row:
                            html += f"""
                            <td>{cell}</td>
                            """

                        html += """
                        </tr>
                        """

                    html += """
                    </table>
                    """

                html += """
                </div>
                """

            html += """
            </div>
            """

        html += """
        </body>
        </html>
        """

        return html

    def _format_size(self, size_bytes):
        """Format size in bytes to human-readable format"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.2f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.2f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"

def run_pdf_report_generator(app):
    """Initialize and run the PDF report generator"""


def run_incremental_analysis(app):
    """Initialize and run the incremental analysis engine

    This is a global wrapper function that forwards to the appropriate
    incremental analysis implementation.
    """
    app.update_output.emit(log_message("[Incremental] Starting incremental analysis..."))

    if not hasattr(app, 'binary_path') or not app.binary_path:
        app.update_output.emit(log_message("[Incremental] Error: No binary selected."))
        return

    # Create incremental analysis manager
    incremental_manager = IncrementalAnalysisManager()

    # Ask for analysis type
    analysis_types = ["Vulnerability", "License", "Protection"]
    analysis_type, ok = QInputDialog.getItem(app, "Analysis Type", "Select analysis type:", analysis_types, 0, False)
    if not ok:
        app.update_output.emit(log_message("[Incremental] Cancelled"))
        return

    # Ask if force full analysis
    force_full = QMessageBox.question(
        app,
        "Force Full Analysis",
        "Force full analysis (ignore cache)?",
        QMessageBox.Yes | QMessageBox.No
    ) == QMessageBox.Yes

    # Define analysis functions
    analysis_functions = {
        "Vulnerability": lambda binary: AdvancedVulnerabilityEngine.scan_binary(binary),
        "License": lambda binary: enhanced_deep_license_analysis(binary),
        "Protection": lambda binary: detect_commercial_protections(binary)
    }

    if analysis_type not in analysis_functions:
        app.update_output.emit(log_message(f"[Incremental] Unsupported analysis type: {analysis_type}"))
        return

    # Run incremental analysis
    app.update_output.emit(log_message(f"[Incremental] Running {analysis_type.lower()} analysis..."))

    try:
        start_time = time.time()
        results = incremental_manager.run_incremental_analysis(
            app.binary_path,
            analysis_functions[analysis_type],
            analysis_type.lower(),
            force_full
        )
        end_time = time.time()

        # Display results
        app.update_output.emit(log_message(f"[Incremental] Analysis completed in {end_time - start_time:.2f} seconds"))

        # Process results based on analysis type
        if analysis_type == "Vulnerability":
            app.update_output.emit(log_message(f"[Incremental] Found {len(results)} vulnerabilities"))

            # Add to analyze results
            if not hasattr(app, "analyze_results"):
                app.analyze_results = []

            app.analyze_results.append("\n=== INCREMENTAL VULNERABILITY ANALYSIS RESULTS ===")
            app.analyze_results.append(f"Analysis time: {end_time - start_time:.2f} seconds")
            app.analyze_results.append(f"Vulnerabilities found: {len(results)}")

            if results:
                app.analyze_results.append("\nTop vulnerabilities:")
                for i, vuln in enumerate(results[:5]):  # Show up to 5 vulnerabilities
                    app.analyze_results.append(f"\nVulnerability {i+1}:")
                    app.analyze_results.append(f"  Type: {vuln.get('type', 'Unknown')}")
                    app.analyze_results.append(f"  Risk: {vuln.get('risk', 'Unknown')}")
                    if 'function' in vuln:
                        app.analyze_results.append(f"  Function: {vuln['function']}")
                    if 'address' in vuln:
                        app.analyze_results.append(f"  Address: {vuln['address']}")

        elif analysis_type == "License":
            app.update_output.emit(log_message("[Incremental] License analysis completed"))

            # Add to analyze results
            if not hasattr(app, "analyze_results"):
                app.analyze_results = []

            app.analyze_results.append("\n=== INCREMENTAL LICENSE ANALYSIS RESULTS ===")
            app.analyze_results.append(f"Analysis time: {end_time - start_time:.2f} seconds")

            for line in results:
                app.analyze_results.append(line)

        elif analysis_type == "Protection":
            app.update_output.emit(log_message("[Incremental] Protection analysis completed"))

            # Add to analyze results
            if not hasattr(app, "analyze_results"):
                app.analyze_results = []

            app.analyze_results.append("\n=== INCREMENTAL PROTECTION ANALYSIS RESULTS ===")
            app.analyze_results.append(f"Analysis time: {end_time - start_time:.2f} seconds")

            for line in results:
                app.analyze_results.append(line)
    except Exception as e:
        app.update_output.emit(log_message(f"[Incremental] Error during analysis: {str(e)}"))
        import traceback
        app.update_output.emit(log_message(f"[Incremental] Traceback: {traceback.format_exc()}"))

    # Check if binary is loaded
    if not app.binary_path:
        app.update_output.emit(log_message("[PDF Report] No binary loaded"))
        return

    # Check if analysis results are available
    if not hasattr(app, "analyze_results") or not app.analyze_results:
        app.update_output.emit(log_message("[PDF Report] No analysis results available"))

        # Ask if user wants to continue anyway
        continue_anyway = QMessageBox.question(
            app,
            "No Analysis Results",
            "No analysis results are available. Do you want to continue anyway?",
            QMessageBox.Yes | QMessageBox.No
        ) == QMessageBox.Yes

        if not continue_anyway:
            return

    # Create and configure the generator
    generator = PDFReportGenerator({
        'title': f"Intellicrack Analysis Report - {os.path.basename(app.binary_path)}",
        'author': "Intellicrack",
        'logo_path': "assets/icon.ico"
    })

    # Ask for report title
    title, ok = QInputDialog.getText(
        app,
        "Report Title",
        "Enter report title:",
        text=generator.title
    )

    if not ok:
        app.update_output.emit(log_message("[PDF Report] Cancelled"))
        return

    generator.set_title(title)

    # Ask for author
    author, ok = QInputDialog.getText(
        app,
        "Report Author",
        "Enter report author:",
        text=generator.author
    )

    if not ok:
        app.update_output.emit(log_message("[PDF Report] Cancelled"))
        return

    generator.set_author(author)

    # Ask for company
    company, ok = QInputDialog.getText(
        app,
        "Company",
        "Enter company name (optional):",
        text=generator.company
    )

    if not ok:
        app.update_output.emit(log_message("[PDF Report] Cancelled"))
        return

    generator.set_company(company)

    # Add binary information
    app.update_output.emit(log_message("[PDF Report] Adding binary information..."))
    binary_info = {
        'path': app.binary_path,
        'size': os.path.getsize(app.binary_path),
        'modified': datetime.datetime.fromtimestamp(os.path.getmtime(app.binary_path)).strftime('%Y-%m-%d %H:%M:%S')
    }

    # Add more binary info if available
    if hasattr(app, "binary_info"):
        binary_info.update(app.binary_info)

    generator.add_binary_info(app.binary_path, binary_info)

    # Add analysis results
    app.update_output.emit(log_message("[PDF Report] Adding analysis results..."))

    # Add general analysis results
    if hasattr(app, "analyze_results") and app.analyze_results:
        # Convert analyze_results list to a string
        results_str = "\n".join(app.analyze_results)

        # Add as a section
        section_index = generator.add_section("Analysis Results", results_str, 'text')
        app.update_output.emit(log_message(f"[PDF Report] Created analysis results section with index {section_index}"))

        # Add detailed subsections to the main analysis section
        detailed_analysis_count = 0

        # Try to extract specific result types
        if hasattr(app, "symbolic_execution_engine") and app.symbolic_execution_engine:
            results = app.symbolic_execution_engine.get_results()
            generator.add_analysis_results(results, 'symbolic_execution', parent_section=section_index)
            detailed_analysis_count += 1
            app.update_output.emit(log_message(f"[PDF Report] Added symbolic execution analysis to section {section_index}"))

        if hasattr(app, "taint_analysis_engine") and app.taint_analysis_engine:
            results = app.taint_analysis_engine.get_results()
            generator.add_analysis_results(results, 'taint_analysis', parent_section=section_index)
            detailed_analysis_count += 1
            app.update_output.emit(log_message(f"[PDF Report] Added taint analysis to section {section_index}"))

        if hasattr(app, "rop_chain_generator") and app.rop_chain_generator:
            results = app.rop_chain_generator.get_results()
            generator.add_analysis_results(results, 'rop_chain', parent_section=section_index)
            detailed_analysis_count += 1
            app.update_output.emit(log_message(f"[PDF Report] Added ROP chain analysis to section {section_index}"))

        if hasattr(app, "network_analyzer_instance") and app.network_analyzer_instance:
            results = app.network_analyzer_instance.analyze_traffic()
            generator.add_analysis_results(results, 'network_traffic', parent_section=section_index)
            detailed_analysis_count += 1
            app.update_output.emit(log_message(f"[PDF Report] Added network traffic analysis to section {section_index}"))

        app.update_output.emit(log_message(f"[PDF Report] Added {detailed_analysis_count} detailed analysis subsections"))

    # Add recommendations
    app.update_output.emit(log_message("[PDF Report] Adding recommendations..."))

    # Generate some recommendations based on analysis results
    recommendations = []

    # Check for symbolic execution vulnerabilities
    if hasattr(app, "symbolic_execution_engine") and app.symbolic_execution_engine:
        results = app.symbolic_execution_engine.get_results()
        if results and 'summary' in results and results['summary'].get('vulnerabilities_found', 0) > 0:
            # Add recommendation for each vulnerability type
            vuln_types = set()
            for path in results['paths']:
                if 'vulnerability' in path:
                    vuln_types.add(path['vulnerability']['type'])

            for vuln_type in vuln_types:
                if vuln_type == 'buffer_overflow':
                    recommendations.append({
                        'title': 'Fix Buffer Overflow Vulnerability',
                        'priority': 'High',
                        'description': 'Buffer overflow vulnerabilities were detected in the application. These can lead to crashes or arbitrary code execution.',
                        'steps': [
                            'Add bounds checking to all buffer operations',
                            'Use safe string functions (e.g., strncpy instead of strcpy)',
                            'Consider using memory-safe languages or libraries'
                        ]
                    })
                elif vuln_type == 'integer_overflow':
                    recommendations.append({
                        'title': 'Fix Integer Overflow Vulnerability',
                        'priority': 'Medium',
                        'description': 'Integer overflow vulnerabilities were detected in the application. These can lead to unexpected behavior or security issues.',
                        'steps': [
                            'Add range checking for integer operations',
                            'Use appropriate integer types for the expected range of values',
                            'Consider using languages or libraries with built-in overflow protection'
                        ]
                    })
                elif vuln_type == 'license_bypass':
                    recommendations.append({
                        'title': 'Strengthen License Validation',
                        'priority': 'High',
                        'description': 'License validation bypass vulnerabilities were detected in the application. These can allow unauthorized use of the software.',
                        'steps': [
                            'Implement multiple layers of license validation',
                            'Use cryptographic techniques to verify license integrity',
                            'Consider using a hardware-based or network-based licensing solution'
                        ]
                    })

    # Add recommendations to the report
    if recommendations:
        generator.add_recommendations(recommendations)
    else:
        # Add a generic recommendation
        generic_recommendations = [{
            'title': 'Perform Regular Security Audits',
            'priority': 'Medium',
            'description': 'Regular security audits can help identify and address potential vulnerabilities before they are exploited.',
            'steps': [
                'Schedule regular security audits',
                'Use automated tools to scan for common vulnerabilities',
                'Consider hiring external security experts for penetration testing'
            ]
        }]

        generator.add_recommendations(generic_recommendations)

    # Ask for output path
    output_path, _ = QFileDialog.getSaveFileName(
        app,
        "Save PDF Report",
        "",
        "PDF Files (*.pdf);;All Files (*)"
    )

    if not output_path:
        app.update_output.emit(log_message("[PDF Report] Cancelled"))
        return

    if not output_path.endswith('.pdf'):
        output_path += '.pdf'

    # Generate report
    app.update_output.emit(log_message("[PDF Report] Generating report..."))
    report_path = generator.generate_report(output_path)

    if report_path:
        app.update_output.emit(log_message(f"[PDF Report] Report saved to {report_path}"))

        # Ask if user wants to open the report
        open_report = QMessageBox.question(
            app,
            "Open Report",
            "Do you want to open the report?",
            QMessageBox.Yes | QMessageBox.No
        ) == QMessageBox.Yes

        if open_report:
            webbrowser.open(f"file://{os.path.abspath(report_path)}")
    else:
        app.update_output.emit(log_message("[PDF Report] Failed to generate report"))

    # Store the generator instance
    app.pdf_report_generator = generator

class ROPChainGenerator:
    """
    Automatic ROP Chain Generation for Complex Bypasses.

    This enhanced class automatically generates Return-Oriented Programming (ROP) chains
    for bypassing security mechanisms, particularly in license validation routines.
    """

    def __init__(self, config=None):
        """Initialize the ROP chain generator with configuration"""
        self.config = config or {}
        self.logger = logging.getLogger("IntellicrackLogger.ROPChainGenerator")
        self.binary_path = None
        self.gadgets = []
        self.chains = []
        self.target_functions = []
        self.max_chain_length = self.config.get('max_chain_length', 20)
        self.max_gadget_size = self.config.get('max_gadget_size', 10)
        self.arch = self.config.get('arch', 'x86_64')

    def set_binary(self, binary_path):
        """Set the binary to analyze"""
        if not os.path.exists(binary_path):
            self.logger.error(f"Binary not found: {binary_path}")
            return False

        self.binary_path = binary_path
        return True

    def add_target_function(self, function_name, function_address=None, description=None):
        """Add a target function for ROP chain generation"""
        target = {
            'name': function_name,
            'address': function_address,
            'description': description or f"Target function: {function_name}"
        }

        self.target_functions.append(target)
        self.logger.info(f"Added target function: {function_name}")

    def find_gadgets(self):
        """Find ROP gadgets in the binary"""
        if not self.binary_path:
            self.logger.error("No binary set")
            return False

        # Clear previous gadgets
        self.gadgets = []

        try:
            # This is a simplified implementation
            # In a real implementation, we would use a tool like ROPgadget or Ropper
            # to find gadgets in the binary

            # For now, we'll simulate gadget finding
            self._simulate_gadget_finding()

            self.logger.info(f"Found {len(self.gadgets)} gadgets")
            return True

        except Exception as e:
            self.logger.error(f"Error finding gadgets: {e}")
            return False

    def generate_chains(self):
        """Generate ROP chains for target functions"""
        if not self.binary_path:
            self.logger.error("No binary set")
            return False

        if not self.gadgets:
            self.logger.warning("No gadgets found, running gadget finder first")
            if not self.find_gadgets():
                return False

        if not self.target_functions:
            self.logger.warning("No target functions specified, adding default targets")
            self._add_default_targets()

        # Clear previous chains
        self.chains = []

        try:
            # This is a simplified implementation
            # In a real implementation, we would use constraint solving
            # to generate valid ROP chains

            # For now, we'll simulate chain generation
            self._simulate_chain_generation()

            self.logger.info(f"Generated {len(self.chains)} ROP chains")
            return True

        except Exception as e:
            self.logger.error(f"Error generating chains: {e}")
            return False

    def _add_default_targets(self):
        """Add default license-related target functions"""
        # Common license check functions
        self.add_target_function('check_license', None, 'License check function')
        self.add_target_function('validate_key', None, 'License key validation function')
        self.add_target_function('is_activated', None, 'Activation check function')

        # Common security functions
        self.add_target_function('memcmp', None, 'Memory comparison function')
        self.add_target_function('strcmp', None, 'String comparison function')

    def _simulate_gadget_finding(self):
        """Simulate finding ROP gadgets in the binary"""

        # Common gadget types
        gadget_types = [
            'pop_reg',
            'mov_reg_reg',
            'add_reg_reg',
            'xor_reg_reg',
            'jmp_reg',
            'call_reg',
            'ret'
        ]

        # Registers for x86_64
        registers_x86_64 = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']

        # Registers for x86
        registers_x86 = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp', 'esp']

        # Choose registers based on architecture
        if self.arch == 'x86_64':
            registers = registers_x86_64
        else:
            registers = registers_x86

        # Number of gadgets to generate
        num_gadgets = random.randint(50, 200)

        # Generate gadgets with various properties based on position
        gadgets_by_type = {gadget_type: [] for gadget_type in gadget_types}
        gadget_registry = {}  # To track all gadgets by ID

        # Track gadget statistics
        gadget_stats = {
            "by_type": {gtype: 0 for gtype in gadget_types},
            "by_region": {"low": 0, "mid": 0, "high": 0},
            "by_complexity": {"simple": 0, "medium": 0, "complex": 0}
        }

        for i in range(num_gadgets):
            # Use i to influence gadget address - later gadgets tend to be higher in memory
            base_addr = 0x1000 + (i * 0x1000)  # Space gadgets out by 0x1000 bytes
            rand_offset = random.randint(0, 0xFF8)  # Random offset within each 0x1000 block
            address = f"0x{(base_addr + rand_offset):x}"

            # Choose gadget type - make useful gadgets appear more frequently in first half
            if i < num_gadgets // 2:
                # First half gets more useful gadgets (pop/mov)
                gadget_type = random.choice(gadget_types[:3] + [gadget_types[-1]])  # pop, mov, add, ret
                region = "low"
            else:
                # Second half gets more complex gadgets
                gadget_type = random.choice(gadget_types)
                region = "high" if i > (num_gadgets * 0.75) else "mid"

            # Create ID for cross-referencing in chain generation
            gadget_id = f"g{i:03d}"

            # Update statistics
            gadget_stats["by_type"][gadget_type] += 1
            gadget_stats["by_region"][region] += 1

            # Pre-create gadget object
            gadget = {
                "id": gadget_id,
                "address": address,
                "type": gadget_type,
                "region": region,
                "position": i,  # Track original position for chain analysis
                "complexity": 0  # Will be set below
            }

            # Gadget instruction
            if gadget_type == 'pop_reg':
                reg = random.choice(registers)
                instruction = f"pop {reg} ; ret"
                gadget["complexity"] = 1
                gadget["affects_reg"] = reg
                gadget_stats["by_complexity"]["simple"] += 1
            elif gadget_type == 'mov_reg_reg':
                reg1 = random.choice(registers)
                reg2 = random.choice(registers)
                instruction = f"mov {reg1}, {reg2} ; ret"
                gadget["complexity"] = 2
                gadget["src_reg"] = reg2
                gadget["dst_reg"] = reg1
                gadget_stats["by_complexity"]["medium"] += 1
            elif gadget_type == 'add_reg_reg':
                reg1 = random.choice(registers)
                reg2 = random.choice(registers)
                instruction = f"add {reg1}, {reg2} ; ret"
                gadget["complexity"] = 2
                gadget["modified_reg"] = reg1
                gadget["by_reg"] = reg2
                gadget_stats["by_complexity"]["medium"] += 1
            elif gadget_type == 'xor_reg_reg':
                reg1 = random.choice(registers)
                reg2 = random.choice(registers)
                instruction = f"xor {reg1}, {reg2} ; ret"
                gadget["complexity"] = 2
                gadget["modified_reg"] = reg1
                gadget["by_reg"] = reg2
                gadget_stats["by_complexity"]["medium"] += 1
            elif gadget_type == 'jmp_reg':
                reg = random.choice(registers)
                instruction = f"jmp {reg}"
                gadget["complexity"] = 3
                gadget["target_reg"] = reg
                gadget_stats["by_complexity"]["complex"] += 1
            elif gadget_type == 'call_reg':
                reg = random.choice(registers)
                instruction = f"call {reg}"
                gadget["complexity"] = 3
                gadget["target_reg"] = reg
                gadget_stats["by_complexity"]["complex"] += 1
            else:  # ret
                instruction = "ret"
                gadget["complexity"] = 1
                gadget_stats["by_complexity"]["simple"] += 1

            # Add to gadget registry for cross-referencing
            gadget_registry[gadget_id] = gadget

            # Also add to gadgets_by_type for efficient chain building
            gadgets_by_type[gadget_type].append(gadget_registry[gadget_id])

            # Gadget size
            size = len(instruction.split(' ; '))

            # Add gadget to main collection
            gadget_display = {
                'address': address,
                'instruction': instruction,
                'type': gadget_type,
                'size': size,
                'id': gadget_id
            }

            self.gadgets.append(gadget_display)

            # Log progress for large gadget sets
            if len(self.gadgets) % 50 == 0:
                self.logger.info(f"Generated {len(self.gadgets)} gadgets...")

    def _simulate_chain_generation(self):
        """Simulate generating ROP chains for target functions"""

        # Generate a chain for each target function
        for target in self.target_functions:
            # Chain gadgets
            chain_gadgets = []

            # Chain length
            chain_length = random.randint(3, min(10, self.max_chain_length))

            # Chain strategy - based on target function
            strategy = None
            if "execve" in target:
                strategy = "exec_shell"
            elif "system" in target:
                strategy = "command_execution"
            elif "mprotect" in target:
                strategy = "memory_permission"
            else:
                strategy = "generic"

            self.logger.info(f"Using chain strategy '{strategy}' for target '{target}'")

            # Generate chain with a specific structure based on position
            for i in range(chain_length):
                gadget = None

                # Pick gadgets based on position in chain
                if i == 0:  # First gadget: typically stack setup or register control
                    gadget_type = 'pop_reg'
                    candidates = [g for g in self.gadgets if g['type'] == gadget_type]
                    if candidates:
                        gadget = random.choice(candidates)

                elif i == chain_length - 1:  # Last gadget: often a jump or call
                    gadget_type = random.choice(['jmp_reg', 'call_reg', 'ret'])
                    candidates = [g for g in self.gadgets if g['type'] == gadget_type]
                    if candidates:
                        gadget = random.choice(candidates)

                elif i == chain_length // 2:  # Middle gadget: often arithmetic for stack pivoting
                    gadget_type = random.choice(['add_reg_reg', 'xor_reg_reg'])
                    candidates = [g for g in self.gadgets if g['type'] == gadget_type]
                    if candidates:
                        gadget = random.choice(candidates)

                # If no specific gadget was chosen, pick a random one that fits the strategy
                if not gadget:
                    if strategy == "exec_shell" and i < chain_length // 2:
                        # For shell execution, prioritize register setup
                        candidates = [g for g in self.gadgets if g['type'] in ['pop_reg', 'mov_reg_reg']]
                    elif strategy == "memory_permission" and i > chain_length // 2:
                        # For memory permission changes, prioritize memory operations
                        candidates = [g for g in self.gadgets if g['type'] in ['add_reg_reg', 'xor_reg_reg']]
                    else:
                        candidates = self.gadgets

                    if candidates:
                        gadget = random.choice(candidates)
                    else:
                        gadget = random.choice(self.gadgets)

                # Record positional info with the gadget for this chain
                gadget_copy = gadget.copy()
                gadget_copy['chain_position'] = i
                gadget_copy['chain_role'] = 'setup' if i == 0 else 'pivot' if i == chain_length // 2 else 'finalize' if i == chain_length - 1 else 'utility'

                # Add to chain
                chain_gadgets.append(gadget_copy)

            # Chain info
            chain = {
                'target': target,
