            self.setWindowIcon(QIcon("assets/icon.ico"))

        # Set minimum size
        self.setMinimumSize(800, 600)

        # Add intro page
        self.addPage(self.create_intro_page())

        # Add file selection page
        self.addPage(self.create_file_selection_page())

        # Add analysis options page
        self.addPage(self.create_analysis_options_page())

        # Add patching options page
        self.addPage(self.create_patching_options_page())

        # Add conclusion page
        self.addPage(self.create_conclusion_page())

        # Connect signals
        self.finished.connect(self.on_finished)

    def create_intro_page(self):
        """Create the introduction page"""
        page = QWizardPage()
        page.setTitle("Welcome to Intellicrack")
        page.setSubTitle("This wizard will guide you through analyzing and patching your first binary")

        layout = QVBoxLayout()

        # Add introduction text
        intro_text = QLabel(
            "Intellicrack helps you analyze and patch software protection and licensing mechanisms. "
            "This guided workflow will walk you through the basic steps:\n\n"
            "1. Selecting a binary file to analyze\n"
            "2. Configuring analysis options\n"
            "3. Reviewing analysis results\n"
            "4. Creating and applying patches\n\n"
            "You can cancel this wizard at any time and use the application manually."
        )
        intro_text.setWordWrap(True)
        layout.addWidget(intro_text)

        # Add image if available
        if os.path.exists("assets/splash.png"):
            image_label = QLabel()
            pixmap = QPixmap("assets/splash.png").scaled(400, 300, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            image_label.setPixmap(pixmap)
            image_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(image_label)

        # Add spacer
        layout.addItem(QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding))

        page.setLayout(layout)
        return page

    def create_file_selection_page(self):
        """Create the file selection page"""
        page = QWizardPage()
        page.setTitle("Select Binary File")
        page.setSubTitle("Choose the executable file you want to analyze")

        layout = QVBoxLayout()

        # File selection widgets
        file_group = QGroupBox("Binary File")
        file_layout = QVBoxLayout()

        # File path widgets
        path_layout = QHBoxLayout()
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("Select a binary file...")
        self.file_path_edit.setReadOnly(True)

        browse_button = QPushButton("Browse...")
        browse_button.clicked.connect(self.browse_file)

        path_layout.addWidget(self.file_path_edit)
        path_layout.addWidget(browse_button)
        file_layout.addLayout(path_layout)

        # File info widgets
        self.file_info_label = QLabel("No file selected")
        self.file_info_label.setWordWrap(True)
        file_layout.addWidget(self.file_info_label)

        file_group.setLayout(file_layout)
        layout.addWidget(file_group)

        # Add explanation
        hint_label = QLabel(
            "Tip: For best results, select an executable file that has licensing or protection mechanisms. "
            "Common examples include software trials, licensed applications, or games with anti-piracy protections."
        )
        hint_label.setWordWrap(True)
        hint_label.setStyleSheet("font-style: italic; color: #666;")
        layout.addWidget(hint_label)

        # Add spacer
        layout.addItem(QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # Register fields
        page.registerField("binary_path*", self.file_path_edit)

        page.setLayout(layout)
        return page

    def create_analysis_options_page(self):
        """Create the analysis options page"""
        page = QWizardPage()
        page.setTitle("Analysis Options")
        page.setSubTitle("Configure how you want to analyze the selected binary")

        layout = QVBoxLayout()

        # Analysis options
        options_group = QGroupBox("Analysis Types")
        options_layout = QVBoxLayout()

        self.static_analysis_cb = QCheckBox("Static Analysis")
        self.static_analysis_cb.setChecked(True)
        self.static_analysis_cb.setToolTip("Analyze the binary without executing it")

        self.dynamic_analysis_cb = QCheckBox("Dynamic Analysis")
        self.dynamic_analysis_cb.setChecked(True)
        self.dynamic_analysis_cb.setToolTip("Analyze the binary during execution")

        self.symbolic_execution_cb = QCheckBox("Symbolic Execution")
        self.symbolic_execution_cb.setToolTip("Use symbolic execution to explore multiple code paths")

        self.ml_analysis_cb = QCheckBox("ML-assisted Analysis")
        self.ml_analysis_cb.setToolTip("Use machine learning to identify potential vulnerabilities")

        options_layout.addWidget(self.static_analysis_cb)
        options_layout.addWidget(self.dynamic_analysis_cb)
        options_layout.addWidget(self.symbolic_execution_cb)
        options_layout.addWidget(self.ml_analysis_cb)

        options_group.setLayout(options_layout)
        layout.addWidget(options_group)

        # Advanced options
        advanced_group = QGroupBox("Advanced Options")
        advanced_layout = QFormLayout()

        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(10, 3600)
        self.timeout_spin.setValue(300)
        self.timeout_spin.setSuffix(" seconds")
        advanced_layout.addRow("Analysis Timeout:", self.timeout_spin)

        self.detect_protections_cb = QCheckBox("Detect Protections")
        self.detect_protections_cb.setChecked(True)
        advanced_layout.addRow("", self.detect_protections_cb)

        self.detect_vm_cb = QCheckBox("Detect VM/Debugging Evasions")
        self.detect_vm_cb.setChecked(True)
        advanced_layout.addRow("", self.detect_vm_cb)

        advanced_group.setLayout(advanced_layout)
        layout.addWidget(advanced_group)

        # Add spacer
        layout.addItem(QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # Register fields
        page.registerField("static_analysis", self.static_analysis_cb)
        page.registerField("dynamic_analysis", self.dynamic_analysis_cb)
        page.registerField("symbolic_execution", self.symbolic_execution_cb)
        page.registerField("ml_analysis", self.ml_analysis_cb)
        page.registerField("timeout", self.timeout_spin)
        page.registerField("detect_protections", self.detect_protections_cb)
        page.registerField("detect_vm", self.detect_vm_cb)

        page.setLayout(layout)
        return page

    def create_patching_options_page(self):
        """Create the patching options page"""
        page = QWizardPage()
        page.setTitle("Patching Options")
        page.setSubTitle("Configure how you want to patch the binary")

        layout = QVBoxLayout()

        # Patching options
        patching_group = QGroupBox("Patching Types")
        patching_layout = QVBoxLayout()

        self.auto_patch_cb = QCheckBox("Automatic Patching")
        self.auto_patch_cb.setChecked(True)
        self.auto_patch_cb.setToolTip("Attempt to automatically generate patches")

        self.interactive_patch_cb = QCheckBox("Interactive Patching")
        self.interactive_patch_cb.setToolTip("Interactively create and apply patches with guidance")

        self.function_hooking_cb = QCheckBox("Function Hooking")
        self.function_hooking_cb.setToolTip("Hook functions at runtime to modify behavior")

        self.memory_patching_cb = QCheckBox("Memory Patching")
        self.memory_patching_cb.setChecked(True)
        self.memory_patching_cb.setToolTip("Patch memory during execution")

        patching_layout.addWidget(self.auto_patch_cb)
        patching_layout.addWidget(self.interactive_patch_cb)
        patching_layout.addWidget(self.function_hooking_cb)
        patching_layout.addWidget(self.memory_patching_cb)

        patching_group.setLayout(patching_layout)
        layout.addWidget(patching_group)

        # Patch targets
        targets_group = QGroupBox("Patch Targets")
        targets_layout = QVBoxLayout()

        self.license_check_cb = QCheckBox("License Validation")
        self.license_check_cb.setChecked(True)

        self.time_limit_cb = QCheckBox("Time Limitations")
        self.time_limit_cb.setChecked(True)

        self.feature_unlock_cb = QCheckBox("Feature Unlocking")
        self.feature_unlock_cb.setChecked(True)

        self.anti_debug_cb = QCheckBox("Anti-debugging Measures")

        targets_layout.addWidget(self.license_check_cb)
        targets_layout.addWidget(self.time_limit_cb)
        targets_layout.addWidget(self.feature_unlock_cb)
        targets_layout.addWidget(self.anti_debug_cb)

        targets_group.setLayout(targets_layout)
        layout.addWidget(targets_group)

        # Add spacer
        layout.addItem(QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # Register fields
        page.registerField("auto_patch", self.auto_patch_cb)
        page.registerField("interactive_patch", self.interactive_patch_cb)
        page.registerField("function_hooking", self.function_hooking_cb)
        page.registerField("memory_patching", self.memory_patching_cb)
        page.registerField("license_check", self.license_check_cb)
        page.registerField("time_limit", self.time_limit_cb)
        page.registerField("feature_unlock", self.feature_unlock_cb)
        page.registerField("anti_debug", self.anti_debug_cb)

        page.setLayout(layout)
        return page

    def create_conclusion_page(self):
        """Create the conclusion page"""
        page = QWizardPage()
        page.setTitle("Ready to Start")
        page.setSubTitle("Your workflow has been configured and is ready to start")

        layout = QVBoxLayout()

        # Summary label
        summary_label = QLabel("Summary of your selections:")
        layout.addWidget(summary_label)

        # Summary text
        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        layout.addWidget(self.summary_text)

        # Connect page-shown signal to update summary
        page.initializePage = self.update_summary

        # Add final instructions
        instructions_label = QLabel(
            "Click 'Finish' to begin analyzing and patching the selected binary. "
            "The application will guide you through the rest of the process and "
            "show you the results of each step."
        )
        instructions_label.setWordWrap(True)
        layout.addWidget(instructions_label)

        page.setLayout(layout)
        return page

    def update_summary(self):
        """Update the summary text with the selected options"""
        binary_path = self.field("binary_path")

        summary = f"<h3>Selected File</h3>\n"
        summary += f"<p>{binary_path}</p>\n\n"

        summary += "<h3>Analysis Options</h3>\n<ul>\n"
        if self.field("static_analysis"):
            summary += "<li>Static Analysis</li>\n"
        if self.field("dynamic_analysis"):
            summary += "<li>Dynamic Analysis</li>\n"
        if self.field("symbolic_execution"):
            summary += "<li>Symbolic Execution</li>\n"
        if self.field("ml_analysis"):
            summary += "<li>ML-assisted Analysis</li>\n"
        summary += f"<li>Timeout: {self.field('timeout')} seconds</li>\n"
        if self.field("detect_protections"):
            summary += "<li>Detect Protections</li>\n"
        if self.field("detect_vm"):
            summary += "<li>Detect VM/Debugging Evasions</li>\n"
        summary += "</ul>\n\n"

        summary += "<h3>Patching Options</h3>\n<ul>\n"
        if self.field("auto_patch"):
            summary += "<li>Automatic Patching</li>\n"
        if self.field("interactive_patch"):
            summary += "<li>Interactive Patching</li>\n"
        if self.field("function_hooking"):
            summary += "<li>Function Hooking</li>\n"
        if self.field("memory_patching"):
            summary += "<li>Memory Patching</li>\n"
        summary += "</ul>\n\n"

        summary += "<h3>Patch Targets</h3>\n<ul>\n"
        if self.field("license_check"):
            summary += "<li>License Validation</li>\n"
        if self.field("time_limit"):
            summary += "<li>Time Limitations</li>\n"
        if self.field("feature_unlock"):
            summary += "<li>Feature Unlocking</li>\n"
        if self.field("anti_debug"):
            summary += "<li>Anti-debugging Measures</li>\n"
        summary += "</ul>"

        self.summary_text.setHtml(summary)

    def browse_file(self):
        """Browse for a binary file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Binary File",
            "",
            "Executable Files (*.exe *.dll *.so *.dylib);;All Files (*)"
        )

        if file_path:
            self.file_path_edit.setText(file_path)
            self.update_file_info(file_path)

    def update_file_info(self, file_path):
        """Update the file information label"""
        try:
            file_size = os.path.getsize(file_path)
            file_mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path))

            info_text = f"<b>File:</b> {os.path.basename(file_path)}<br>"
            info_text += f"<b>Size:</b> {self.format_size(file_size)}<br>"
            info_text += f"<b>Modified:</b> {file_mod_time.strftime('%Y-%m-%d %H:%M:%S')}<br>"

            # Try to get architecture info
            try:
                pe = pefile.PE(file_path)
                machine_type = pe.FILE_HEADER.Machine

                machine_types = {
                    0x014c: "x86 (32-bit)",
                    0x0200: "IA64",
                    0x8664: "x64 (64-bit)"
                }

                arch = machine_types.get(machine_type, f"Unknown ({hex(machine_type)})")
                info_text += f"<b>Architecture:</b> {arch}<br>"

                # Try to get timestamp
                try:
                    timestamp = pe.FILE_HEADER.TimeDateStamp
                    compile_time = datetime.datetime.fromtimestamp(timestamp)
                    info_text += f"<b>Compiled:</b> {compile_time.strftime('%Y-%m-%d %H:%M:%S')}<br>"
                except:
                    pass

            except:
                # If pefile fails, try a simpler approach
                if os.name == "nt":  # Windows
                    if "64" in file_path.lower() or "x64" in file_path.lower():
                        info_text += "<b>Architecture:</b> Likely x64 (based on filename)<br>"
                    elif "32" in file_path.lower() or "x86" in file_path.lower():
                        info_text += "<b>Architecture:</b> Likely x86 (based on filename)<br>"

            self.file_info_label.setText(info_text)

        except Exception as e:
            self.file_info_label.setText(f"Error getting file info: {str(e)}")

    def format_size(self, size_bytes):
        """Format a file size in bytes to a human-readable string"""
        if size_bytes < 1024:
            return f"{size_bytes} bytes"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.2f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.2f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"

    def on_finished(self, result):
        """Handle wizard completion"""
        if result == QDialog.Accepted:
            # Collect all the settings from the wizard fields
            settings = {
                "binary_path": self.field("binary_path"),
                "analysis": {
                    "static": self.field("static_analysis"),
                    "dynamic": self.field("dynamic_analysis"),
                    "symbolic": self.field("symbolic_execution"),
                    "ml": self.field("ml_analysis"),
                    "timeout": self.field("timeout"),
                    "detect_protections": self.field("detect_protections"),
                    "detect_vm": self.field("detect_vm")
                },
                "patching": {
                    "auto": self.field("auto_patch"),
                    "interactive": self.field("interactive_patch"),
                    "function_hooking": self.field("function_hooking"),
                    "memory_patching": self.field("memory_patching"),
                    "targets": {
                        "license_check": self.field("license_check"),
                        "time_limit": self.field("time_limit"),
                        "feature_unlock": self.field("feature_unlock"),
                        "anti_debug": self.field("anti_debug")
                    }
                }
            }

            # Apply settings to parent app if it exists
            if self.parent:
                # Set the binary path
                if os.path.exists(settings["binary_path"]):
                    self.parent.binary_path = settings["binary_path"]
                    self.parent.update_output.emit(log_message(f"[Wizard] Set binary path: {settings['binary_path']}"))

                    # Load the binary in the UI
                    self.parent.load_binary(settings["binary_path"])

                    # Configure analysis options
                    self.parent.update_output.emit(log_message("[Wizard] Configured analysis options"))

                    # Start analysis if auto-analyze is enabled
                    if settings["analysis"]["static"]:
                        self.parent.update_output.emit(log_message("[Wizard] Starting static analysis..."))
                        self.parent.run_static_analysis()

                    if settings["analysis"]["dynamic"]:
                        self.parent.update_output.emit(log_message("[Wizard] Starting dynamic analysis..."))
                        self.parent.run_dynamic_analysis()

                    # Switch to the Analysis tab
                    self.parent.switch_tab.emit(1)  # Assuming Analysis tab is index 1

                    # Record that the guided workflow has been completed
                    self.parent.update_output.emit(log_message("[Wizard] Guided workflow completed"))

                    # Show notification
                    QMessageBox.information(
                        self.parent,
                        "Guided Workflow",
                        "The guided workflow has been set up and started.\n"
                        "You can monitor the analysis progress in the output panel."
                    )

# -------------------------------
# Memory Optimization
# -------------------------------

class MemoryOptimizer:
    """
    Optimizes memory usage during analysis and patching operations.

    This class implements various memory optimization techniques:
    1. Memory usage monitoring
    2. Automatic garbage collection
    3. Memory-efficient data structures
    4. Incremental loading for large binaries
    5. Memory leak detection
    """

    def __init__(self, app_instance):
        """
        Initialize the memory optimizer.

        Args:
            app_instance: Reference to the main application instance
        """
        self.app = app_instance
        self.enabled = False
        self.threshold_percentage = 80  # Default threshold to start optimization (80% memory usage)
        self.last_usage_check = 0
        self.check_interval = 5  # Check every 5 seconds by default
        self.optimization_stats = {
            "collections_triggered": 0,
            "memory_saved": 0,
            "last_optimization_time": None,
            "peak_memory_usage": 0,
            "current_memory_usage": 0
        }
        self.optimization_techniques = {
            "garbage_collection": True,
            "memory_efficient_structures": True,
            "incremental_loading": True,
            "leak_detection": False  # Disabled by default as it can slow down processing
        }

    def enable(self):
        """Enable memory optimization."""
        self.enabled = True
        self.app.update_output.emit(log_message("[Memory] Memory optimization enabled"))

    def disable(self):
        """Disable memory optimization."""
        self.enabled = False
        self.app.update_output.emit(log_message("[Memory] Memory optimization disabled"))

    def configure(self, threshold=80, check_interval=5, techniques=None):
        """
        Configure the memory optimizer.

        Args:
            threshold: Memory usage percentage threshold to trigger optimization
            check_interval: Interval in seconds between memory checks
            techniques: Dictionary of optimization techniques to enable/disable
        """
        self.threshold_percentage = threshold
        self.check_interval = check_interval

        if techniques:
            self.optimization_techniques.update(techniques)

        self.app.update_output.emit(log_message(
            f"[Memory] Memory optimizer configured: threshold={threshold}%, "
            f"interval={check_interval}s, techniques={self.optimization_techniques}"))

    def get_current_memory_usage(self):
        """
        Get the current memory usage of the process.

        Returns:
            Tuple of (used_memory_bytes, total_memory_bytes, usage_percentage)
        """
        process = psutil.Process()
        memory_info = process.memory_info()
        used_memory = memory_info.rss

        # Get system memory
        system_memory = psutil.virtual_memory()
        total_memory = system_memory.total

        # Calculate percentage of system memory used by this process
        usage_percentage = (used_memory / total_memory) * 100

        self.optimization_stats["current_memory_usage"] = used_memory
        if used_memory > self.optimization_stats["peak_memory_usage"]:
            self.optimization_stats["peak_memory_usage"] = used_memory

        return (used_memory, total_memory, usage_percentage)

    def check_memory_usage(self):
        """
        Check current memory usage and trigger optimization if necessary.

        Returns:
            bool: True if optimization was triggered, False otherwise
        """
        if not self.enabled:
            return False

        # Check if it's time to check memory usage
        current_time = time.time()
        if current_time - self.last_usage_check < self.check_interval:
            return False

        self.last_usage_check = current_time

        # Get current memory usage
        _, _, usage_percentage = self.get_current_memory_usage()

        # Check if optimization is needed
        if usage_percentage > self.threshold_percentage:
            self.optimize_memory()
            return True

        return False

    def optimize_memory(self):
        """
        Run memory optimization techniques based on enabled settings.

        Returns:
            int: Estimated bytes saved by optimization
        """
        memory_before = self.optimization_stats["current_memory_usage"]
        techniques_used = []

        # Trigger garbage collection if enabled
        if self.optimization_techniques["garbage_collection"]:
            gc.collect()
            techniques_used.append("garbage_collection")

        # Use memory-efficient data structures if enabled
        if self.optimization_techniques["memory_efficient_structures"]:
            # This would typically involve replacing large data structures with more efficient ones
            # For this example, we'll just log it
            techniques_used.append("memory_efficient_structures")

        # Check for memory leaks if enabled
        if self.optimization_techniques["leak_detection"]:
            # This would typically involve tracking object creation and destruction
            # For this example, we'll just log it
            self.check_for_memory_leaks()
            techniques_used.append("leak_detection")

        # Get memory usage after optimization
        _, _, _ = self.get_current_memory_usage()
        memory_after = self.optimization_stats["current_memory_usage"]

        # Calculate memory saved
        memory_saved = max(0, memory_before - memory_after)
        self.optimization_stats["memory_saved"] += memory_saved
        self.optimization_stats["collections_triggered"] += 1
        self.optimization_stats["last_optimization_time"] = time.time()

        # Log optimization results
        self.app.update_output.emit(log_message(
            f"[Memory] Optimization completed: {memory_saved / (1024 * 1024):.2f} MB saved "
            f"using {', '.join(techniques_used)}"))

        return memory_saved

    def check_for_memory_leaks(self):
        """
        Check for potential memory leaks.

        This is a simplified version that looks for unexpected memory usage patterns.
        A real implementation would track object creation and destruction.
        """
        # Count objects tracked by garbage collector
        gc_objects = len(gc.get_objects())

        # Log potential memory leaks
        self.app.update_output.emit(log_message(
            f"[Memory] Leak detection: {gc_objects} objects tracked by garbage collector"))

    def get_optimization_stats(self):
        """
        Get memory optimization statistics.

        Returns:
            dict: Dictionary of optimization statistics
        """
        return self.optimization_stats

    def initialize_memory_optimizer(self):
        """Initialize memory optimizer for the application."""
        try:
            if CONFIG.get("memory_optimization_enabled", False):
                self.memory_optimizer = MemoryOptimizer(self)

                # Configure from saved settings
                techniques = {
                    "garbage_collection": CONFIG.get("memory_opt_gc", True),
                    "memory_efficient_structures": CONFIG.get("memory_opt_structures", True),
                    "incremental_loading": CONFIG.get("memory_opt_incremental", True),
                    "leak_detection": CONFIG.get("memory_opt_leak_detection", False)
                }

                self.memory_optimizer.configure(
                    threshold=CONFIG.get("memory_threshold", 80),
                    check_interval=CONFIG.get("memory_check_interval", 5),
                    techniques=techniques
                )

                self.memory_optimizer.enable()
                self.update_output.emit(log_message("[Memory] Memory optimizer initialized and enabled"))
        except Exception as e:
            self.update_output.emit(log_message(f"[Memory] Error initializing memory optimizer: {e}"))

def apply_performance_settings(self):
    """Apply performance optimization settings."""
    try:
        # Memory optimization settings
        memory_optimization_enabled = self.memory_opt_enable_cb.isChecked()
        memory_threshold = self.memory_threshold_spinbox.value()
        memory_interval = self.memory_interval_spinbox.value()

        # Save settings to config
        CONFIG["memory_optimization_enabled"] = memory_optimization_enabled
        CONFIG["memory_threshold"] = memory_threshold
        CONFIG["memory_check_interval"] = memory_interval
        CONFIG["memory_opt_gc"] = self.gc_enable_cb.isChecked()
        CONFIG["memory_opt_structures"] = self.mem_struct_enable_cb.isChecked()
        CONFIG["memory_opt_incremental"] = self.incremental_enable_cb.isChecked()
        CONFIG["memory_opt_leak_detection"] = self.leak_detect_enable_cb.isChecked()
        CONFIG["gpu_acceleration"] = self.gpu_enable_cb.isChecked()
        CONFIG["distributed_processing"] = self.distributed_enable_cb.isChecked()

        # Initialize or update memory optimizer
        if not hasattr(self, "memory_optimizer"):
            self.memory_optimizer = MemoryOptimizer(self)

        # Configure memory optimizer
        techniques = {
            "garbage_collection": self.gc_enable_cb.isChecked(),
            "memory_efficient_structures": self.mem_struct_enable_cb.isChecked(),
            "incremental_loading": self.incremental_enable_cb.isChecked(),
            "leak_detection": self.leak_detect_enable_cb.isChecked()
        }

        self.memory_optimizer.configure(
            threshold=memory_threshold,
            check_interval=memory_interval,
            techniques=techniques
        )

        # Enable or disable memory optimization
        if memory_optimization_enabled:
            self.memory_optimizer.enable()
        else:
            self.memory_optimizer.disable()

        # GPU acceleration
        if self.gpu_enable_cb.isChecked():
            self.update_output.emit(log_message("[Performance] GPU acceleration enabled"))
        else:
            self.update_output.emit(log_message("[Performance] GPU acceleration disabled"))

        # Distributed processing
        if self.distributed_enable_cb.isChecked():
            self.update_output.emit(log_message("[Performance] Distributed processing enabled"))
        else:
            self.update_output.emit(log_message("[Performance] Distributed processing disabled"))

        # Save to config file
        self.save_config()

        self.update_output.emit(log_message("[Performance] Performance settings applied successfully"))

        # Actually run the specialized functions to apply settings
        self.initialize_memory_optimizer()

        # Generate a performance report
        self.run_report_generation()

        # Apply settings using dedicated function
        self.apply_performance_settings()

        QMessageBox.information(self, "Settings Applied", "Performance optimization settings have been applied.")

    except Exception as e:
        self.update_output.emit(log_message(f"[Performance] Error applying performance settings: {e}"))
        QMessageBox.warning(self, "Error", f"Error applying performance settings: {e}")

    def run_report_generation(self, auto=False, report_format='pdf'):
        """Run report generation in a background thread.

        Args:
            auto: If True, use default filename without prompting
            report_format: Format for the report (pdf, html, or docx)
        """
        if not self.binary_path:
            QMessageBox.warning(self, "No Binary Selected", "Please select a binary file first.")
            return

        # Log start of report generation
        self.update_output.emit(log_message(f"[Reports] Starting {report_format.upper()} report generation..."))

        # Validate requested format
        if report_format not in ['pdf', 'html', 'docx']:
            self.update_output.emit(log_message(f"[Reports] Unsupported format: {report_format}, defaulting to PDF"))
            report_format = 'pdf'

        # Extension based on format
        extensions = {
            'pdf': '.pdf',
            'html': '.html',
            'docx': '.docx'
        }
        extension = extensions[report_format]

        if auto:
            # Use automatic filename based on binary and timestamp
            base_name = os.path.basename(self.binary_path)
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = f"reports/{base_name}_{timestamp}{extension}"

            # Ensure directory exists
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
        else:
            # Ask for save location
            output_path, _ = QFileDialog.getSaveFileName(
                self,
                f"Save {report_format.upper()} Report",
                f"reports/report{extension}",
            "PDF Files (*.pdf);;All Files (*)"
        )

        if not output_path:
            return

        # Ensure file has .pdf extension
        if not output_path.lower().endswith('.pdf'):
            output_path += '.pdf'

        self.update_output.emit(log_message("[Report] Starting PDF report generation..."))

        # Run in background thread
        threading.Thread(
            target=self._run_report_generation_thread,
            args=(output_path,)
        ).start()

    def _run_report_generation_thread(self, output_path):
        """Background thread for PDF report generation."""
        try:
            # Initialize report generator if not done yet
            if not hasattr(self, "report_generator"):
                self.report_generator = PDFReportGenerator(self)

            # Generate report
            report_path = self.report_generator.generate_report(output_path)

            if report_path:
                self.update_output.emit(log_message(f"[Report] PDF report generated successfully: {report_path}"))

                # Try to open the report
                try:
                    if os.name == 'nt':  # Windows
                        os.startfile(report_path)
                    elif os.name == 'posix':  # macOS, Linux
                        if sys.platform == 'darwin':  # macOS
                            subprocess.run(['open', report_path])
                        else:  # Linux
                            subprocess.run(['xdg-open', report_path])
                except Exception as e:
                    self.update_output.emit(log_message(f"[Report] Error opening report: {e}"))
            else:
                self.update_output.emit(log_message("[Report] Failed to generate PDF report"))

        except Exception as e:
            self.update_output.emit(log_message(f"[Report] Error generating report: {e}"))
            self.update_output.emit(log_message(traceback.format_exc()))

    def initialize_memory_optimizer(self):
        """Initialize memory optimizer for the application."""
        try:
            if CONFIG.get("memory_optimization_enabled", False):
                self.memory_optimizer = MemoryOptimizer(self)

                # Configure from saved settings
                techniques = {
                    "garbage_collection": CONFIG.get("memory_opt_gc", True),
                    "memory_efficient_structures": CONFIG.get("memory_opt_structures", True),
                    "incremental_loading": CONFIG.get("memory_opt_incremental", True),
                    "leak_detection": CONFIG.get("memory_opt_leak_detection", False)
                }

                self.memory_optimizer.configure(
                    threshold=CONFIG.get("memory_threshold", 80),
                    check_interval=CONFIG.get("memory_check_interval", 5),
                    techniques=techniques
                )

                self.memory_optimizer.enable()
                self.update_output.emit(log_message("[Memory] Memory optimizer initialized and enabled"))
        except Exception as e:
            self.update_output.emit(log_message(f"[Memory] Error initializing memory optimizer: {e}"))

    def apply_performance_settings(self):
        """Apply performance optimization settings."""
        try:
            # Memory optimization settings
            memory_optimization_enabled = self.memory_opt_enable_cb.isChecked()
            memory_threshold = self.memory_threshold_spinbox.value()
            memory_interval = self.memory_interval_spinbox.value()

            # Save settings to config
            CONFIG["memory_optimization_enabled"] = memory_optimization_enabled
            CONFIG["memory_threshold"] = memory_threshold
            CONFIG["memory_check_interval"] = memory_interval
            CONFIG["memory_opt_gc"] = self.gc_enable_cb.isChecked()
            CONFIG["memory_opt_structures"] = self.mem_struct_enable_cb.isChecked()
            CONFIG["memory_opt_incremental"] = self.incremental_enable_cb.isChecked()
            CONFIG["memory_opt_leak_detection"] = self.leak_detect_enable_cb.isChecked()
            CONFIG["gpu_acceleration"] = self.gpu_enable_cb.isChecked()
            CONFIG["distributed_processing"] = self.distributed_enable_cb.isChecked()

            # Initialize or update memory optimizer
            if not hasattr(self, "memory_optimizer"):
                self.memory_optimizer = MemoryOptimizer(self)

            # Configure memory optimizer
            techniques = {
                "garbage_collection": self.gc_enable_cb.isChecked(),
                "memory_efficient_structures": self.mem_struct_enable_cb.isChecked(),
                "incremental_loading": self.incremental_enable_cb.isChecked(),
                "leak_detection": self.leak_detect_enable_cb.isChecked()
            }

            self.memory_optimizer.configure(
                threshold=memory_threshold,
                check_interval=memory_interval,
                techniques=techniques
            )

            # Enable or disable memory optimization
            if memory_optimization_enabled:
                self.memory_optimizer.enable()
            else:
                self.memory_optimizer.disable()

            # GPU acceleration
            if self.gpu_enable_cb.isChecked():
                self.update_output.emit(log_message("[Performance] GPU acceleration enabled"))
            else:
                self.update_output.emit(log_message("[Performance] GPU acceleration disabled"))

            # Distributed processing
            if self.distributed_enable_cb.isChecked():
                self.update_output.emit(log_message("[Performance] Distributed processing enabled"))
            else:
                self.update_output.emit(log_message("[Performance] Distributed processing disabled"))

            # Save to config file
            self.save_config()

            self.update_output.emit(log_message("[Performance] Performance settings applied successfully"))
            QMessageBox.information(self, "Settings Applied", "Performance optimization settings have been applied.")

        except Exception as e:
            self.update_output.emit(log_message(f"[Performance] Error applying performance settings: {e}"))
            QMessageBox.warning(self, "Error", f"Error applying performance settings: {e}")

def run_plugin_in_sandbox(plugin_instance, method_name, *args, **kwargs):
    """
    Run a plugin method in a sandbox for security

    Args:
        plugin_instance: Plugin instance
        method_name: Method name to call
        *args: Arguments to pass to the method
        **kwargs: Keyword arguments to pass to the method

    Returns:
        list: Results from the plugin method
    """
    # Create a temporary file for communication
    temp_file = tempfile.NamedTemporaryFile(delete=False)
    temp_file.close()

    # Function to run in the sandbox process
    def sandbox_process():
        """
        Function to run in a sandboxed process with resource limits.

        Attempts to restrict CPU time and memory usage for the process.
        Logs a warning if resource limits cannot be applied.
        """
        try:
            # Try to import and use resource module for limiting resources
            try:
                import resource as res
                # Limit CPU time to 30 seconds
                res.setrlimit(res.RLIMIT_CPU, (30, 30))
                # Limit memory to 500MB
                res.setrlimit(res.RLIMIT_AS, (500 * 1024 * 1024, 500 * 1024 * 1024))
            except ImportError:
                logger.warning("Resource module not available - sandbox resource limits not applied")

            # Get the method to call
            method = getattr(plugin_instance, method_name)

            # Call the method
            results = method(*args, **kwargs)

            # Write results to temp file
            with open(temp_file.name, 'wb') as f:
                pickle.dump(results, f)

            return 0
        except Exception as e:
            # Write error to temp file
            with open(temp_file.name, 'wb') as f:
                pickle.dump([f"Error in sandbox: {e}"], f)
            return 1

    # Create and start the sandbox process
    process = multiprocessing.Process(target=sandbox_process)
    process.start()

    # Wait for the process to finish with configurable timeout
    timeout = CONFIG.get("plugin_timeout", 30)  # Get timeout from config, default 30 seconds
    start_time = time.time()

    while process.is_alive():
        if time.time() - start_time > timeout:
            # Process took too long, terminate it
            process.terminate()
