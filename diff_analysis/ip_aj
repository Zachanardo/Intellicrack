                         } catch(e){}
                     }
                }
            }
            // onLeave could check retval and lpNumberOfBytesWritten if needed
        });
    }

    // CloseHandle - Untrack file handles when closed
    var closeHandle = Module.findExportByName("kernel32.dll", "CloseHandle");
    if (closeHandle) {
        Interceptor.attach(closeHandle, {
            onEnter: function(args) {
                this.hFile = args[0].toUInt32();
                if (global._trackedFileHandles && global._trackedFileHandles[this.hFile]) {
                    logHook("[Filesystem] Closing license file handle 0x" + this.hFile.toString(16) + " ('" + global._trackedFileHandles[this.hFile].fileName + "')");
                    delete global._trackedFileHandles[this.hFile]; // Untrack
                }
            }
        });
    }
""")

    # Hardware ID hooks
    if "hardware_id" in hook_types:
        script_parts.append("""
    // ========== Hardware ID API Hooks ==========
    logHook("[Intellicrack] Setting up Hardware ID hooks");

    // GetVolumeInformationW - For volume serial
    var getVolumeInfoW = Module.findExportByName("kernel32.dll", "GetVolumeInformationW");
    if (getVolumeInfoW) {
        Interceptor.attach(getVolumeInfoW, {
            onEnter: function(args) {
                this.rootPathNamePtr = args[0];
                this.volumeSerialNumberPtr = args[5]; // lpVolumeSerialNumber
                var rootPath = "N/A";
                try { if(this.rootPathNamePtr && !this.rootPathNamePtr.isNull()) rootPath = this.rootPathNamePtr.readUtf16String(); } catch(e){}
                logHook("[Hardware ID] GetVolumeInformationW called for path: '" + rootPath + "'");
            },
            onLeave: function(retval) {
                // retval is BOOL
                if (retval.toInt32() !== 0 && this.volumeSerialNumberPtr && !this.volumeSerialNumberPtr.isNull()) {
                    var originalSerial = Memory.readUInt(this.volumeSerialNumberPtr);
                    var fakeSerial = 0xDEADBEEF; // Consistent fake serial
                    Memory.writeUInt(this.volumeSerialNumberPtr, fakeSerial);
                    logHook("[Hardware ID] Spoofed Volume Serial: Original=0x" + originalSerial.toString(16).toUpperCase() + ", New=0x" + fakeSerial.toString(16).toUpperCase());
                } else if (retval.toInt32() === 0) {
                     logHook("[Hardware ID] GetVolumeInformationW failed (Error: " + NativeFunction.getLastError() + ")");
                }
            }
        });
    }

    // GetAdaptersInfo - For MAC addresses
    var getAdaptersInfo = Module.findExportByName("iphlpapi.dll", "GetAdaptersInfo");
    if (getAdaptersInfo) {
        Interceptor.attach(getAdaptersInfo, {
            onEnter: function(args) {
                this.adapterInfoPtr = args[0]; // pAdapterInfo
                this.sizePtr = args[1]; // pOutBufLen
                logHook("[Hardware ID] GetAdaptersInfo called");
            },
            onLeave: function(retval) {
                // retval is DWORD (ERROR_SUCCESS = 0)
                if (retval.toInt32() === 0 && this.adapterInfoPtr && !this.adapterInfoPtr.isNull()) {
                    logHook("[Hardware ID] GetAdaptersInfo succeeded. Spoofing MAC addresses...");
                    var currentAdapter = this.adapterInfoPtr;
                    var count = 0;
                    var fakeMacBase = [0x00, 0x11, 0x22, 0x33, 0x44, 0x00]; // Base for fake MAC

                    try {
                        while (!currentAdapter.isNull()) {
                            // Structure offsets depend on architecture and definition, these are approximate for 32/64 bit
                            // Need IP_ADAPTER_INFO structure definition for accuracy
                            var addressLengthOffset = 268; // Approximate offset for AddressLength
                            var addressOffset = 272; // Approximate offset for Address
                            var MAX_ADAPTER_ADDRESS_LENGTH = 8; // Usually 8, MAC is 6

                            var addressLength = Memory.readUInt(currentAdapter.add(addressLengthOffset));
                            var addressPtr = currentAdapter.add(addressOffset);

                            if (addressLength === 6) { // Standard MAC length
                                var originalMac = Memory.readByteArray(addressPtr, addressLength);
                                var originalMacStr = Array.from(new Uint8Array(originalMac)).map(b => b.toString(16).padStart(2, '0')).join(':');

                                // Generate consistent fake MAC
                                var fakeMac = new Uint8Array(fakeMacBase);
                                fakeMac[5] = (0x10 + count) & 0xFF; // Ensure unique last byte per adapter
                                Memory.writeByteArray(addressPtr, fakeMac);
                                var fakeMacStr = Array.from(fakeMac).map(b => b.toString(16).padStart(2, '0')).join(':');

                                logHook("[Hardware ID] Spoofed MAC for adapter #" + count + ": Original=" + originalMacStr + ", New=" + fakeMacStr);
                                count++;
                            }

                            // Follow the linked list (Next pointer is usually the first member)
                            var nextAdapterPtr = Memory.readPointer(currentAdapter);
                            currentAdapter = nextAdapterPtr;
                        }
                         logHook("[Hardware ID] Finished spoofing " + count + " network adapters.");
                    } catch (e) {
                         logHook("[Hardware ID] Error while spoofing MAC addresses: " + e);
                    }
                } else if (retval.toInt32() !== 0 && retval.toInt32() !== 111 /*ERROR_BUFFER_OVERFLOW*/) {
                     logHook("[Hardware ID] GetAdaptersInfo failed with error code: " + retval.toInt32());
                }
            }
        });
    }

    // GetComputerNameW - For computer name
    var getComputerNameW = Module.findExportByName("kernel32.dll", "GetComputerNameW");
    if (getComputerNameW) {
        Interceptor.attach(getComputerNameW, {
            onEnter: function(args) {
                this.nameBufferPtr = args[0];
                this.sizePtr = args[1];
                logHook("[Hardware ID] GetComputerNameW called");
            },
            onLeave: function(retval) {
                // retval is BOOL
                if (retval.toInt32() !== 0 && this.nameBufferPtr && !this.nameBufferPtr.isNull()) {
                    var fakeName = "DESKTOP-INTEL"; // Consistent fake name
                    var maxSize = 0;
                    if (this.sizePtr && !this.sizePtr.isNull()) maxSize = Memory.readUInt(this.sizePtr);

                    logHook("[Hardware ID] Original buffer size: " + maxSize);
                    if (fakeName.length + 1 <= maxSize) { // +1 for null terminator
                        Memory.writeUtf16String(this.nameBufferPtr, fakeName);
                        Memory.writeUInt(this.sizePtr, fakeName.length); // Update size to new length
                        logHook("[Hardware ID] Spoofed computer name to: '" + fakeName + "'");
                    } else {
                         logHook("[Hardware ID] Buffer too small (" + maxSize + ") to spoof computer name.");
                    }
                }
            }
        });
    }

    // WMI / System Information Queries (Often used for fingerprinting)
    var coCreateInstance = Module.findExportByName("ole32.dll", "CoCreateInstance");
    if (coCreateInstance) {
        Interceptor.attach(coCreateInstance, {
            onEnter: function(args) {
                // rclsid (Reference to the CLSID)
                var clsidPtr = args[0];
                if (clsidPtr && !clsidPtr.isNull()) {
                     try {
                         var clsidBytes = clsidPtr.readByteArray(16); // CLSID is 16 bytes
                         var clsidStr = '{' + Array.from(new Uint8Array(clsidBytes)).map((b, i) => {
                             var s = b.toString(16).padStart(2, '0');
                             if ([3, 5, 7, 9].includes(i)) s += '-'; // Add hyphens
                             return s;
                         }).join('').toUpperCase() + '}';

                         // Check for known fingerprinting CLSIDs, e.g., WMI
                         if (clsidStr === '{4590F811-1D3A-11D0-891F-00AA004B2E24}') { // CLSID_WbemLocator
                            logHook("[Hardware ID] CoCreateInstance called for WbemLocator (WMI) - potential fingerprinting.");
                         }
                     } catch(e) {}
                 }
            }
        });
    }

    var getSystemInfo = Module.findExportByName("kernel32.dll", "GetSystemInfo");
    if (getSystemInfo) {
         Interceptor.attach(getSystemInfo, {
            onEnter: function(args) {
                 logHook("[Hardware ID] GetSystemInfo called - provides CPU info, etc.");
                 this.lpSystemInfo = args[0];
            },
            onLeave: function(retval) {
                // Could potentially modify dwNumberOfProcessors, dwProcessorType etc. in lpSystemInfo here
                // Example: Memory.writeUInt(this.lpSystemInfo.add(4), 4); // Force 4 processors
            }
         });
    }

    var getSystemFirmwareTable = Module.findExportByName("kernel32.dll", "GetSystemFirmwareTable");
     if (getSystemFirmwareTable) {
         Interceptor.attach(getSystemFirmwareTable, {
             onEnter: function(args) {
                 var firmwareTableProviderSignature = args[0].readUtf8String(4); // Read signature ('RSMB', 'FACP', etc.)
                 logHook("[Hardware ID] GetSystemFirmwareTable called for signature: " + firmwareTableProviderSignature + " - potential SMBIOS/ACPI fingerprinting.");
                 // Could potentially intercept and modify specific table requests/results
             }
         });
     }

""")

    # Time and date manipulation hooks
    if "time" in hook_types:
        script_parts.append("""
    // ========== Time/Date API Hooks ==========
    logHook("[Intellicrack] Setting up Time/Date hooks");

    // Consistent future date for spoofing
    var futureYear = 2099;
    var futureMonth = 12; // JavaScript Date months are 0-11, SYSTEMTIME is 1-12
    var futureDay = 31;

    // GetSystemTime
    var getSystemTime = Module.findExportByName("kernel32.dll", "GetSystemTime");
    if (getSystemTime) {
        Interceptor.attach(getSystemTime, {
            onEnter: function(args) {
                this.systemTimePtr = args[0]; // LPSYSTEMTIME
                logHook("[Time] GetSystemTime called");
            },
            onLeave: function(retval) { // SYSTEMTIME structure is filled by the function
                if (this.systemTimePtr && !this.systemTimePtr.isNull()) {
                    // Read original time for logging (optional)
                    // var originalYear = Memory.readU16(this.systemTimePtr.add(0));
                    // logHook("[Time] Original year from GetSystemTime: " + originalYear);

                    // Overwrite with future date
                    Memory.writeU16(this.systemTimePtr.add(0), futureYear); // wYear
                    Memory.writeU16(this.systemTimePtr.add(2), futureMonth); // wMonth
                    // Memory.writeU16(this.systemTimePtr.add(4), 5); // wDayOfWeek (optional, maybe skip)
                    Memory.writeU16(this.systemTimePtr.add(6), futureDay); // wDay
                    // Keep original time components (hour, min, sec, ms)
                    logHook("[Time] Spoofed GetSystemTime to: " + futureYear + "-" + futureMonth + "-" + futureDay);
                }
            }
        });
    }

    // GetLocalTime
    var getLocalTime = Module.findExportByName("kernel32.dll", "GetLocalTime");
    if (getLocalTime) {
        Interceptor.attach(getLocalTime, {
            onEnter: function(args) {
                this.localTimePtr = args[0]; // LPSYSTEMTIME
                logHook("[Time] GetLocalTime called");
            },
            onLeave: function(retval) { // SYSTEMTIME structure is filled by the function
                 if (this.localTimePtr && !this.localTimePtr.isNull()) {
                    Memory.writeU16(this.localTimePtr.add(0), futureYear); // wYear
                    Memory.writeU16(this.localTimePtr.add(2), futureMonth); // wMonth
                    Memory.writeU16(this.localTimePtr.add(6), futureDay); // wDay
                    logHook("[Time] Spoofed GetLocalTime to: " + futureYear + "-" + futureMonth + "-" + futureDay);
                }
            }
        });
    }

    // GetSystemTimeAsFileTime
    var getSystemTimeAsFileTime = Module.findExportByName("kernel32.dll", "GetSystemTimeAsFileTime");
    if (getSystemTimeAsFileTime) {
        Interceptor.attach(getSystemTimeAsFileTime, {
            onEnter: function(args) {
                this.fileTimePtr = args[0]; // LPFILETIME
                logHook("[Time] GetSystemTimeAsFileTime called");
            },
            onLeave: function(retval) { // FILETIME structure is filled by the function
                 if (this.fileTimePtr && !this.fileTimePtr.isNull()) {
                    // Create a FILETIME for the future date
                    // JS Date month is 0-indexed, day is 1-indexed. FILETIME is 100ns since 1601-01-01 UTC.
                    var futureDate = new Date(Date.UTC(futureYear, futureMonth - 1, futureDay));
                    var fileTime = futureDate.getTime() * 10000 + 116444736000000000; // Convert JS timestamp to FILETIME

                    // Split into low and high parts
                    var fileTimeLow = fileTime % 0x100000000;
                    var fileTimeHigh = Math.floor(fileTime / 0x100000000);

                    Memory.writeU32(this.fileTimePtr.add(0), fileTimeLow); // dwLowDateTime
                    Memory.writeU32(this.fileTimePtr.add(4), fileTimeHigh); // dwHighDateTime

                    logHook("[Time] Spoofed GetSystemTimeAsFileTime to future date (Low: 0x" + fileTimeLow.toString(16) + ", High: 0x" + fileTimeHigh.toString(16) + ")");
                }
            }
        });
    }

    // time() from C runtime (might be msvcrt.dll, ucrtbase.dll, etc.)
    // Need to find the correct CRT module used by the target
    ['msvcrt.dll', 'ucrtbase.dll'].forEach(function(crtModule) {
        var timeFunc = Module.findExportByName(crtModule, 'time');
        if (timeFunc) {
            logHook("[Time] Found time() in " + crtModule);
            Interceptor.replace(timeFunc, new NativeCallback(function(timer) {
                 // Return seconds since epoch for the future date
                 var futureDate = new Date(Date.UTC(futureYear, futureMonth - 1, futureDay));
                 var spoofedTime = Math.floor(futureDate.getTime() / 1000);

                 logHook("[Time] time() called - returning spoofed timestamp: " + spoofedTime);
                 // time() can take a pointer to store the result, handle if non-NULL
                 if (timer && !timer.isNull()) {
                     Memory.writeS32(timer, spoofedTime); // time_t is usually 32-bit signed, but can be 64-bit
                 }
                 return spoofedTime;
            }, 'int32', ['pointer'])); // Assuming time_t is int32, adjust if needed ('int64')
        }
    });
""")

    # Cryptography hooks
    if "cryptography" in hook_types:
        script_parts.append("""
    // ========== Cryptography API Hooks ==========
    logHook("[Intellicrack] Setting up Cryptography hooks");

    // CryptHashData - Often hashes license keys, hardware IDs etc.
    var cryptHashData = Module.findExportByName("advapi32.dll", "CryptHashData");
    if (cryptHashData) {
        Interceptor.attach(cryptHashData, {
            onEnter: function(args) {
                this.hHash = args[0]; // Handle to the hash object
                this.pbData = args[1]; // Data to be hashed
                this.dwDataLen = args[2].toInt32(); // Length of data
                // args[3] is dwFlags

                if (this.pbData && !this.pbData.isNull() && this.dwDataLen > 0) {
                    try {
                        var dataBytes = Memory.readByteArray(this.pbData, Math.min(this.dwDataLen, 64)); // Log first 64 bytes
                        var hexData = Array.from(new Uint8Array(dataBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                        var dataStr = "";
                        try { // Attempt to decode as UTF-8 for readability
                             dataStr = Memory.readUtf8String(this.pbData, this.dwDataLen);
                             // Sanitize non-printable chars for logging
                             dataStr = dataStr.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '.');
                        } catch(e) { dataStr = "(Binary Data)"; }

                        logHook("[Crypto] CryptHashData called: Len=" + this.dwDataLen +
                                ", Data (Hex): " + hexData + "..." +
                                ", Data (Str): " + dataStr.substring(0, 100) + "...");
                    } catch (e) {
                         logHook("[Crypto] CryptHashData called: Len=" + this.dwDataLen + " (Error reading data: " + e + ")");
                    }
                } else {
                    logHook("[Crypto] CryptHashData called with empty data.");
                }
            }
            // onLeave doesn't provide much useful info here, the hashing happens internally
        });
    }

    // CryptCreateHash - See what hashing algorithms are used
    var cryptCreateHash = Module.findExportByName("advapi32.dll", "CryptCreateHash");
    if (cryptCreateHash) {
        Interceptor.attach(cryptCreateHash, {
            onEnter: function(args) {
                this.hProv = args[0]; // CSP handle
                this.Algid = args[1].toInt32(); // Algorithm ID
                this.hKey = args[2]; // Optional key handle
                // args[3] dwFlags
                this.phHash = args[4]; // Pointer to receive hash handle

                // Decode ALG_ID (Common values)
                var algName = "Unknown/Custom (0x" + this.Algid.toString(16) + ")";
                var algMap = { 0x8001:"MD2", 0x8002:"MD4", 0x8003:"MD5", 0x8004:"SHA1", 0x800C:"SHA256", 0x800D:"SHA384", 0x800E:"SHA512"};
                if (algMap[this.Algid]) algName = algMap[this.Algid];

                logHook("[Crypto] CryptCreateHash called: Algorithm=" + algName);
            }
            // onLeave could log the created hash handle *this.phHash
        });
    }

    // CryptGenRandom - Often used in key generation or challenges
    var cryptGenRandom = Module.findExportByName("advapi32.dll", "CryptGenRandom");
    if (cryptGenRandom) {
        Interceptor.attach(cryptGenRandom, {
            onEnter: function(args) {
                this.hProv = args[0];
                this.dwLen = args[1].toInt32();
                this.pbBuffer = args[2];
                logHook("[Crypto] CryptGenRandom called requesting " + this.dwLen + " bytes.");
            },
            onLeave: function(retval) {
                // retval is BOOL
                if (retval.toInt32() !== 0 && this.pbBuffer && !this.pbBuffer.isNull() && this.dwLen > 0) {
                    var randomBytes = Memory.readByteArray(this.pbBuffer, Math.min(this.dwLen, 16));
                    var hexBytes = Array.from(new Uint8Array(randomBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                    logHook("[Crypto] CryptGenRandom generated: " + hexBytes + "... (Total " + this.dwLen + " bytes)");

                    // --- Potential Spoofing (Use with caution!) ---
                    // If predictable random numbers are needed for analysis/keygen:
                    /*
                    logHook("[Crypto] SPOOFING CryptGenRandom output with deterministic pattern!");
                    var fakeBuf = new Uint8Array(this.dwLen);
                    for (var i = 0; i < this.dwLen; i++) {
                        fakeBuf[i] = (i * 13 + 7) & 0xFF; // Simple deterministic pattern
                    }
                    Memory.writeByteArray(this.pbBuffer, fakeBuf);
                    */
                    // --- End Spoofing ---
                } else if (retval.toInt32() === 0) {
                    logHook("[Crypto] CryptGenRandom failed (Error: " + NativeFunction.getLastError() + ")");
                }
            }
        });
    }

    // CryptEncrypt / CryptDecrypt - Core encryption/decryption
    ['CryptEncrypt', 'CryptDecrypt'].forEach(function(funcName){
        var funcPtr = Module.findExportByName("advapi32.dll", funcName);
        if (funcPtr) {
             Interceptor.attach(funcPtr, {
                 onEnter: function(args) {
                     this.hKey = args[0];
                     this.hHash = args[1]; // Optional hash object handle
                     this.Final = args[2].toInt32(); // BOOL: TRUE if last block
                     // args[3] dwFlags
                     this.pbData = args[4]; // Data buffer (in/out)
                     this.pdwDataLen = args[5]; // Pointer to data length (in/out)
                     this.dwBufLen = args[6].toInt32(); // Size of buffer

                     this.isEncrypt = funcName === 'CryptEncrypt';
                     this.funcName = funcName;

                     var dataLen = 0;
                     if (this.pdwDataLen && !this.pdwDataLen.isNull()) dataLen = Memory.readUInt(this.pdwDataLen);

                     logHook("[Crypto] " + this.funcName + " called: DataLen=" + dataLen + ", BufLen=" + this.dwBufLen + ", Final=" + this.Final);

                     // Log input data preview
                     if (this.pbData && !this.pbData.isNull() && dataLen > 0) {
                         try {
                             var dataBytes = Memory.readByteArray(this.pbData, Math.min(dataLen, 32));
                             var hexData = Array.from(new Uint8Array(dataBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                             logHook("[Crypto]  Input Data (Hex): " + hexData + "...");
                         } catch (e) {}
                     }
                 },
                 onLeave: function(retval) {
                    // retval is BOOL
                    if (retval.toInt32() !== 0) {
                        var dataLen = 0;
                        if (this.pdwDataLen && !this.pdwDataLen.isNull()) dataLen = Memory.readUInt(this.pdwDataLen);

                        logHook("[Crypto] " + this.funcName + " succeeded. Output DataLen=" + dataLen);
                        // Log output data preview
                        if (this.pbData && !this.pbData.isNull() && dataLen > 0) {
                             try {
                                 var dataBytes = Memory.readByteArray(this.pbData, Math.min(dataLen, 32));
                                 var hexData = Array.from(new Uint8Array(dataBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                                 logHook("[Crypto]  Output Data (Hex): " + hexData + "...");
                             } catch (e) {}
                        }
                    } else {
                        logHook("[Crypto] " + this.funcName + " failed (Error: " + NativeFunction.getLastError() + ")");
                    }
                 }
             });
        }
    });

    // CertVerifyCertificateChainPolicy - Often used for signature verification
    var certVerifyPolicy = Module.findExportByName("crypt32.dll", "CertVerifyCertificateChainPolicy");
    if (certVerifyPolicy) {
        Interceptor.attach(certVerifyPolicy, {
            onEnter: function(args) {
                // Example: pszPolicyOID = args[0], pChainContext = args[1], pPolicyPara = args[2], pPolicyStatus = args[3]
                var policyOID = args[0].readUtf8String(); // e.g., "1.3.6.1.4.1.311.2.2.1" (CERT_CHAIN_POLICY_AUTHENTICODE)
                logHook("[Crypto] CertVerifyCertificateChainPolicy called for Policy OID: " + policyOID + " - potential signature verification.");
                this.pPolicyStatus = args[3]; // Pointer to CERT_CHAIN_POLICY_STATUS structure
            },
            onLeave: function(retval) {
                // retval is BOOL
                var originalStatus = 0;
                 if (this.pPolicyStatus && !this.pPolicyStatus.isNull()) {
                      // CERT_CHAIN_POLICY_STATUS has dwError at offset 0
                      originalStatus = Memory.readUInt(this.pPolicyStatus.add(0));
                 }

                if (retval.toInt32() === 0 || originalStatus !== 0) { // If original call failed
                    logHook("[Crypto] CertVerifyCertificateChainPolicy originally failed (Status: " + originalStatus + "). Forcing success...");
                    retval.replace(1); // Force TRUE return value
                    if (this.pPolicyStatus && !this.pPolicyStatus.isNull()) {
                         // Set dwError to 0 (ERROR_SUCCESS) in the status structure
                         Memory.writeUInt(this.pPolicyStatus.add(0), 0);
                    }
                    logHook("[Crypto] Forced certificate verification to succeed.");
                } else {
                    logHook("[Crypto] CertVerifyCertificateChainPolicy succeeded.");
                }
            }
        });
    }
""")

    # Anti-Debug hooks (Includes enhanced PEB/TEB patching)
    if "debugger" in hook_types:
        script_parts.append("""
    // ========== Anti-Debugging API Hooks ==========
    logHook("[Intellicrack] Setting up Anti-Debugging hooks");

    // IsDebuggerPresent
    var isDebuggerPresent = Module.findExportByName("kernel32.dll", "IsDebuggerPresent");
    if (isDebuggerPresent) {
        Interceptor.replace(isDebuggerPresent, new NativeCallback(function() {
            logHook("[Anti-Debug] IsDebuggerPresent called - returning FALSE");
            return 0; // FALSE
        }, 'uint', [])); // Return type is BOOL (uint)
        logHook("[Anti-Debug] Replaced IsDebuggerPresent");
    }

    // CheckRemoteDebuggerPresent
    var checkRemoteDebugger = Module.findExportByName("kernel32.dll", "CheckRemoteDebuggerPresent");
    if (checkRemoteDebugger) {
        Interceptor.attach(checkRemoteDebugger, {
            onEnter: function(args) {
                this.hProcess = args[0];
                this.pbDebuggerPresent = args[1]; // Pointer to BOOL
                logHook("[Anti-Debug] CheckRemoteDebuggerPresent called for handle: " + this.hProcess);
            },
            onLeave: function(retval) {
                // retval is BOOL
                if (this.pbDebuggerPresent && !this.pbDebuggerPresent.isNull()) {
                    var originalValue = Memory.readU8(this.pbDebuggerPresent);
                    Memory.writeU8(this.pbDebuggerPresent, 0); // Force FALSE
                    logHook("[Anti-Debug] Forced CheckRemoteDebuggerPresent output to FALSE (Original: " + originalValue + ")");
                }
                retval.replace(1); // Ensure the function call itself reports success (TRUE)
            }
        });
        logHook("[Anti-Debug] Hooked CheckRemoteDebuggerPresent");
    }

    // OutputDebugString - Often used to detect presence of debugger via timing or exceptions
    ['OutputDebugStringA', 'OutputDebugStringW'].forEach(function(funcName){
        var funcPtr = Module.findExportByName("kernel32.dll", funcName);
        if (funcPtr) {
             Interceptor.replace(funcPtr, new NativeCallback(function(lpOutputString) {
                 // Simply do nothing to prevent detection
                 var outStr = "N/A";
                  try {
                      if (lpOutputString && !lpOutputString.isNull()){
                          outStr = funcName.endsWith('W') ? lpOutputString.readUtf16String() : lpOutputString.readUtf8String();
                      }
                  } catch(e){}
                  logHook("[Anti-Debug] Suppressed call to " + funcName + " with string (preview): " + outStr.substring(0,50) + "...");
             }, 'void', ['pointer']));
             logHook("[Anti-Debug] Replaced " + funcName);
         }
    });

    // NtQueryInformationProcess / ZwQueryInformationProcess - Common way to query debug port, flags etc.
    ['ntdll.dll', 'win32u.dll'].forEach(function(dllName){ // Check multiple potential locations
        var ntQueryInformationProcess = Module.findExportByName(dllName, "NtQueryInformationProcess") || Module.findExportByName(dllName, "ZwQueryInformationProcess");
        if (ntQueryInformationProcess) {
            logHook("[Anti-Debug] Found NtQueryInformationProcess in " + dllName);
            Interceptor.attach(ntQueryInformationProcess, {
                onEnter: function(args) {
                    this.ProcessHandle = args[0];
                    this.ProcessInformationClass = args[1].toInt32();
                    this.ProcessInformation = args[2]; // Output buffer
                    this.ProcessInformationLength = args[3].toInt32();
                    this.ReturnLength = args[4]; // Optional output size

                    this.isRelevantClass = false;
                    var className = "Unknown (" + this.ProcessInformationClass + ")";

                    // Process information classes related to debugging
                    if (this.ProcessInformationClass === 0x07) { // ProcessDebugPort
                        className = "ProcessDebugPort";
                        this.isRelevantClass = true;
                    } else if (this.ProcessInformationClass === 0x1E) { // ProcessDebugObjectHandle
                         className = "ProcessDebugObjectHandle";
                         this.isRelevantClass = true;
                    } else if (this.ProcessInformationClass === 0x1F) { // ProcessDebugFlags
                         className = "ProcessDebugFlags";
                         this.isRelevantClass = true;
                    } else if (this.ProcessInformationClass === 0x23) { // ProcessBreakOnTermination
                         className = "ProcessBreakOnTermination";
                         this.isRelevantClass = true;
                    }

                    if (this.isRelevantClass) {
                        logHook("[Anti-Debug] NtQueryInformationProcess called for: " + className);
                    }
                },
                onLeave: function(retval) {
                    // retval is NTSTATUS (0 = success)
                    if (this.isRelevantClass && retval.toInt32() >= 0) { // If call succeeded and relevant class
                        if (this.ProcessInformation && !this.ProcessInformation.isNull()) {
                            if (this.ProcessInformationClass === 0x07) { // ProcessDebugPort
                                // If debug port is requested (usually non-zero if debugging), return 0
                                Memory.writePointer(this.ProcessInformation, ptr(0));
                                logHook("[Anti-Debug] Spoofed ProcessDebugPort result to 0");
                            } else if (this.ProcessInformationClass === 0x1E) { // ProcessDebugObjectHandle
                                // If handle is requested, return NULL handle
                                Memory.writePointer(this.ProcessInformation, ptr(0));
                                logHook("[Anti-Debug] Spoofed ProcessDebugObjectHandle result to NULL");
                            } else if (this.ProcessInformationClass === 0x1F) { // ProcessDebugFlags
                                // Debug flags are usually 0 when not debugging
                                Memory.writeUInt(this.ProcessInformation, 0);
                                logHook("[Anti-Debug] Spoofed ProcessDebugFlags result to 0");
                            } else if (this.ProcessInformationClass === 0x23) { // ProcessBreakOnTermination
                                // Prevent termination on debugger detach
                                Memory.writeUInt(this.ProcessInformation, 0);
                                logHook("[Anti-Debug] Spoofed ProcessBreakOnTermination result to 0");
                            }
                        }
                    }
                }
            });
             return; // Stop searching once found
         }
    });

    // Timing attacks - GetTickCount / QueryPerformanceCounter
    var getTickCount = Module.findExportByName("kernel32.dll", "GetTickCount");
    if (getTickCount) {
        var lastTickCount = 0;
        Interceptor.replace(getTickCount, new NativeCallback(function() {
            var now = Date.now(); // Use system time to get a base
            if (lastTickCount === 0) lastTickCount = now;
            // Return a consistently incrementing value based on real time but smoother
            var increment = (now - lastTickCount) > 0 ? (now - lastTickCount) : 10 + Math.floor(Math.random() * 10);
             if (increment > 1000) increment = 50 + Math.floor(Math.random() * 50); // Avoid huge jumps if paused
             lastTickCount += increment;

            //logHook("[Anti-Debug] GetTickCount called - returning smooth ticks: " + lastTickCount);
            return lastTickCount & 0xFFFFFFFF; // Tick count is DWORD
        }, 'uint32', []));
        logHook("[Anti-Debug] Replaced GetTickCount");
    }
    var queryPerfCounter = Module.findExportByName("kernel32.dll", "QueryPerformanceCounter");
    if (queryPerfCounter) {
         var lastPerfCounter = { low: 0, high: 0 };
         Interceptor.attach(queryPerfCounter, {
             onEnter: function(args) {
                 this.lpPerformanceCount = args[0]; // LARGE_INTEGER*
             },
             onLeave: function(retval) {
                 // retval is BOOL
                 if (retval.toInt32() !== 0 && this.lpPerformanceCount && !this.lpPerformanceCount.isNull()) {
                     // Similar to GetTickCount, provide smoothly increasing values
                     var now = Date.now(); // Base on real time
                     var increment = 10000 + Math.floor(Math.random() * 5000); // Smaller, more frequent increments

                     // Simulate adding increment to a 64-bit value (lastPerfCounter)
                     var currentLow = lastPerfCounter.low;
                     var currentHigh = lastPerfCounter.high;
                     var newLow = (currentLow + increment) >>> 0; // Ensure unsigned 32-bit wrap
                     var carry = (newLow < currentLow) ? 1 : 0;
                     var newHigh = (currentHigh + carry) >>> 0;

                     lastPerfCounter.low = newLow;
                     lastPerfCounter.high = newHigh;

                     Memory.writeU32(this.lpPerformanceCount.add(0), newLow); // LowPart
                     Memory.writeU32(this.lpPerformanceCount.add(4), newHigh); // HighPart
                     //logHook("[Anti-Debug] Spoofed QueryPerformanceCounter result");
                 }
             }
         });
         logHook("[Anti-Debug] Hooked QueryPerformanceCounter");
     }

    // ========== Enhanced Anti-Anti-Debugging ==========
    logHook("[Anti-Debug] Performing enhanced PEB/TEB checks...");
    try {
        // Get PEB address reliably
        var peb;
        if (Process.arch === 'ia32') {
            peb = ptr(Process.findModuleByName('ntdll.dll').base).add(Process.pageSize).readPointer(); // Simple heuristic, might need refinement
             // A more robust way for ia32 often involves reading FS:[0x30], which is tricky from JS.
             // Consider using NativeFunction to call GetCurrentPeb if needed.
             logHook("[Anti-Debug] Got PEB address (ia32 heuristic): " + peb);
        } else if (Process.arch === 'x64') {
             // Read from GS segment register - Frida provides direct access via Process.getCurrentThread()
             peb = Process.getCurrentThread().PEB;
             logHook("[Anti-Debug] Got PEB address (x64 GS): " + peb);
        } else {
             logHook("[Anti-Debug] Unsupported architecture for PEB access: " + Process.arch);
             peb = null;
        }

        if (peb) {
            // Patch PEB BeingDebugged (ensure consistency across architectures)
            var beingDebuggedOffset = 0x2; // Offset is 2 for both x86 and x64 PEB
            var currentVal = Memory.readU8(peb.add(beingDebuggedOffset));
            logHook("[Anti-Debug] PEB.BeingDebugged (Offset 0x2) original value: " + currentVal);
            if (currentVal !== 0) {
                try {
                    Memory.protect(peb.add(beingDebuggedOffset), 1, 'rw-'); // Ensure writable
                    Memory.writeU8(peb.add(beingDebuggedOffset), 0);
                    logHook("[Anti-Debug] Patched PEB.BeingDebugged flag to 0");
                } catch(e) { logHook("[Anti-Debug] Error patching PEB.BeingDebugged: " + e); }
            }

            // Patch PEB NtGlobalFlag (common check)
            var ntGlobalFlagOffset = Process.arch === 'ia32' ? 0x68 : 0xBC; // Offset varies by architecture
            var globalFlag = Memory.readUInt(peb.add(ntGlobalFlagOffset));
            logHook("[Anti-Debug] PEB.NtGlobalFlag (Offset 0x" + ntGlobalFlagOffset.toString(16) + ") original value: 0x" + globalFlag.toString(16));
            // Check for flags indicating debugger presence (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS -> 0x10 | 0x20 | 0x40 = 0x70)
            if ((globalFlag & 0x70) !== 0) {
                 try {
                     Memory.protect(peb.add(ntGlobalFlagOffset), 4, 'rw-'); // Ensure writable
                     Memory.writeUInt(peb.add(ntGlobalFlagOffset), globalFlag & ~0x70); // Clear the flags
                     logHook("[Anti-Debug] Cleared debugger flags (0x70) in PEB.NtGlobalFlag. New value: 0x" + (globalFlag & ~0x70).toString(16));
                 } catch(e) { logHook("[Anti-Debug] Error patching PEB.NtGlobalFlag: " + e); }
            }
        }
    } catch (e) {
        logHook("[Anti-Debug] Error during enhanced PEB/TEB patching: " + e);
    }
""")

    # Network license activation hooks
    if "network" in hook_types:
        script_parts.append("""
    // ========== Network API Hooks (License Activation) ==========
    logHook("[Intellicrack] Setting up Network hooks for license activation");

    // --- WinINet Hooks ---
    var internetConnectW = Module.findExportByName("wininet.dll", "InternetConnectW");
    if (internetConnectW) {
        Interceptor.attach(internetConnectW, {
            onEnter: function(args) {
                this.hInternet = args[0]; // Session handle
                this.serverNamePtr = args[1];
                this.serverPort = args[2].toInt32();
                // args[3-5] username, password, service
                this.dwFlags = args[6].toInt32();
                this.dwContext = args[7];

                this.serverName = "N/A";
                if (this.serverNamePtr && !this.serverNamePtr.isNull()) this.serverName = this.serverNamePtr.readUtf16String();

                logHook("[Network] InternetConnectW: Server='" + this.serverName + "', Port=" + this.serverPort + ", Flags=0x" + this.dwFlags.toString(16));
                // Store connection details for later use (if needed)
                if (!global._wininetConnections) global._wininetConnections = {};
                // We don't have the resulting handle yet, store context temporarily
                 this._tempConnInfo = { server: this.serverName, port: this.serverPort };
            },
            onLeave: function(retval) {
                var handle = retval.toUInt32(); // HINTERNET handle
                if (handle !== 0 && this._tempConnInfo) { // Success (handle is not NULL)
                    logHook("[Network] InternetConnectW succeeded. Handle=0x" + handle.toString(16));
                    global._wininetConnections[handle] = this._tempConnInfo; // Associate handle with info
                } else if (handle === 0) {
                    logHook("[Network] InternetConnectW failed (Error: " + NativeFunction.getLastError() + ")");
                }
                this._tempConnInfo = null;
            }
        });
    }

    var httpSendRequestW = Module.findExportByName("wininet.dll", "HttpSendRequestW");
    if (httpSendRequestW) {
        Interceptor.attach(httpSendRequestW, {
            onEnter: function(args) {
                this.hRequest = args[0]; // HINTERNET request handle
                this.headersPtr = args[1];
                this.headersLength = args[2].toInt32();
                this.optionalPtr = args[3]; // POST data
                this.optionalLength = args[4].toInt32();

                var headers = "N/A";
                if (this.headersPtr && !this.headersPtr.isNull()) headers = this.headersPtr.readUtf16String();
                logHook("[Network] HttpSendRequestW: Handle=0x" + this.hRequest.toUInt32().toString(16) + ", Headers='" + headers.substring(0, 100) + "...'");

                if (this.optionalPtr && !this.optionalPtr.isNull() && this.optionalLength > 0) {
                    try {
                        var postData = this.optionalPtr.readByteArray(Math.min(this.optionalLength, 256));
                        var hexData = Array.from(new Uint8Array(postData)).map(b => b.toString(16).padStart(2, '0')).join('');
                        var strData = "";
                        try { strData = this.optionalPtr.readUtf8String(this.optionalLength); strData = strData.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '.'); } catch(e){}
                        logHook("[Network]  POST Data (Len=" + this.optionalLength + "): " + hexData + "...");
                        if (strData) logHook("[Network]  POST Data (Str): " + strData.substring(0, 200) + "...");

                        // Store request handle for response interception
                        if (!global._trackedHttpRequests) global._trackedHttpRequests = {};
                        global._trackedHttpRequests[this.hRequest.toUInt32()] = { type: 'wininet' };

                    } catch (e) { logHook("[Network]  Error reading POST data: " + e); }
                }
            },
            onLeave: function(retval) {
                // retval is BOOL
                if (retval.toInt32() === 0) {
                     logHook("[Network] HttpSendRequestW failed (Error: " + NativeFunction.getLastError() + ")");
                } else {
                     logHook("[Network] HttpSendRequestW succeeded.");
                }
            }
        });
    }

     var internetReadFile = Module.findExportByName("wininet.dll", "InternetReadFile");
     if (internetReadFile) {
         Interceptor.attach(internetReadFile, {
             onEnter: function(args) {
                 this.hFile = args[0].toUInt32(); // HINTERNET handle from HttpOpenRequest/FtpOpenFile
                 this.lpBuffer = args[1];
                 this.dwNumberOfBytesToRead = args[2].toInt32();
                 this.lpdwNumberOfBytesRead = args[3]; // Output: number of bytes read

                 this.isLicenseRequest = global._trackedHttpRequests && global._trackedHttpRequests[this.hFile];
                 if (this.isLicenseRequest) {
                      logHook("[Network] InternetReadFile called for tracked HTTP request handle: 0x" + this.hFile.toString(16));
                 }
             },
             onLeave: function(retval) {
                 // retval is BOOL
                 if (this.isLicenseRequest && retval.toInt32() !== 0) {
                      var bytesRead = 0;
                      if(this.lpdwNumberOfBytesRead && !this.lpdwNumberOfBytesRead.isNull()) bytesRead = Memory.readUInt(this.lpdwNumberOfBytesRead);

                      logHook("[Network] Read " + bytesRead + " bytes for license request.");
                      if (bytesRead > 0 && this.lpBuffer && !this.lpBuffer.isNull()) {
                           try {
                                var responseData = this.lpBuffer.readByteArray(bytesRead);
                                var hexData = Array.from(new Uint8Array(responseData)).map(b => b.toString(16).padStart(2, '0')).join('');
                                var strData = "";
                                try { strData = this.lpBuffer.readUtf8String(bytesRead); strData = strData.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '.'); } catch(e){}

                                logHook("[Network]  Response Data (Hex): " + hexData.substring(0,128) + "...");
                                if (strData) logHook("[Network]  Response Data (Str): " + strData.substring(0, 200) + "...");

                                // --- Activation Response Spoofing ---
                                var errorKeywords = ["error", "fail", "invalid", "expired", "denied", "unauthorized"];
                                var containsError = errorKeywords.some(keyword => strData.toLowerCase().includes(keyword));

                                if (containsError) {
                                    logHook("[Network] License failure detected in response! Attempting to spoof success...");
                                    var successResponse = '{"status":"success","license":"valid","activated":true,"expires":"2099-12-31"}'; // Example JSON success
                                    // var successResponse = "<response><status>OK</status><license valid=\\"true\\"/></response>"; // Example XML

                                     if (successResponse.length <= this.dwNumberOfBytesToRead) {
                                         Memory.writeUtf8String(this.lpBuffer, successResponse);
                                         Memory.writeUInt(this.lpdwNumberOfBytesRead, successResponse.length); // Update bytes read count
                                         logHook("[Network]  SPOOFED response with success message.");
                                     } else {
                                         logHook("[Network]  Spoofing failed: Success message too long for buffer.");
                                     }
                                }
                                // --- End Spoofing ---
                           } catch(e) { logHook("[Network]  Error processing response data: " + e); }
                      }
                 } else if (this.isLicenseRequest && retval.toInt32() === 0) {
                      logHook("[Network] InternetReadFile failed for license request (Error: " + NativeFunction.getLastError() + ")");
                 }
             }
         });
     }

    // --- Winsock Hooks ---
    var connect = Module.findExportByName("ws2_32.dll", "connect");
    if (connect) {
        Interceptor.attach(connect, {
            onEnter: function(args) {
                this.socket = args[0];
                this.sockaddrPtr = args[1];
                // args[2] is namelen

                try {
                     // Read sockaddr structure (sa_family at offset 0)
                     var sa_family = Memory.readU16(this.sockaddrPtr);
                     var ip = "N/A";
                     var port = 0;

                     if (sa_family === 2) { // AF_INET (IPv4)
                         port = Memory.readU16(this.sockaddrPtr.add(2)); // sin_port (network byte order)
                         port = ((port & 0xFF) << 8) | ((port >> 8) & 0xFF); // ntohs
                         var addr = Memory.readU32(this.sockaddrPtr.add(4)); // sin_addr
                         ip = ((addr >> 0) & 0xFF) + "." + ((addr >> 8) & 0xFF) + "." + ((addr >> 16) & 0xFF) + "." + ((addr >> 24) & 0xFF);
                     } else if (sa_family === 23) { // AF_INET6 (IPv6)
                         port = Memory.readU16(this.sockaddrPtr.add(2)); // sin6_port (network byte order)
                         port = ((port & 0xFF) << 8) | ((port >> 8) & 0xFF); // ntohs
                         // sin6_addr is 16 bytes starting at offset 8
                         var addrBytes = Memory.readByteArray(this.sockaddrPtr.add(8), 16);
                         ip = Array.from(new Uint8Array(addrBytes)).map((b,i) => (i>0 && i%2===0 ? ':' : '') + b.toString(16).padStart(2,'0')).join('');
                     }

                     logHook("[Network] Winsock connect: Socket=" + this.socket + ", Family=" + sa_family + ", IP=" + ip + ", Port=" + port);

                     // Track socket if connecting to common web ports (potential activation)
                     if (port === 80 || port === 443) {
                          if (!global._trackedSockets) global._trackedSockets = {};
                          global._trackedSockets[this.socket.toString()] = { ip: ip, port: port };
                     }

                 } catch (e) { logHook("[Network] Winsock connect: Socket=" + this.socket + " (Error reading address: " + e + ")"); }
            }
            // onLeave: retval is 0 for success, SOCKET_ERROR (-1) for failure
        });
    }

    var send = Module.findExportByName("ws2_32.dll", "send");
    if (send) {
        Interceptor.attach(send, {
            onEnter: function(args) {
                this.socket = args[0];
                this.buffer = args[1];
                this.len = args[2].toInt32();
                // args[3] flags

                if (global._trackedSockets && global._trackedSockets[this.socket.toString()]) {
                     logHook("[Network] Winsock send on tracked socket: Socket=" + this.socket + ", Len=" + this.len);
                     if (this.buffer && !this.buffer.isNull() && this.len > 0) {
                         try {
                             var dataBytes = Memory.readByteArray(this.buffer, Math.min(this.len, 256));
                             var hexData = Array.from(new Uint8Array(dataBytes)).map(b => b.toString(16).padStart(2, '0')).join('');
                             var strData = "";
                             try { strData = Memory.readUtf8String(this.buffer, this.len).replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '.'); } catch(e){}
                             logHook("[Network]  Send Data (Hex): " + hexData + "...");
                             if (strData) logHook("[Network]  Send Data (Str): " + strData.substring(0, 200) + "...");

                             // Check if it looks like an HTTP request (potential activation)
                             if (strData.startsWith("GET ") || strData.startsWith("POST ") || strData.startsWith("PUT ")) {
                                 logHook("[Network]   Detected HTTP request over socket.");
                                 // Mark this socket for response interception if needed
                                 global._trackedSockets[this.socket.toString()].isHttpRequest = true;
                             }
                         } catch(e) { logHook("[Network]  Error reading send buffer: " + e); }
                     }
                }
            }
            // onLeave: retval is number of bytes sent or SOCKET_ERROR
        });
    }

     var recv = Module.findExportByName("ws2_32.dll", "recv");
     if (recv) {
         Interceptor.attach(recv, {
             onEnter: function(args) {
                 this.socket = args[0];
                 this.buffer = args[1];
                 this.len = args[2].toInt32(); // Max bytes to receive
                 // args[3] flags

                 this.isLicenseSocket = global._trackedSockets && global._trackedSockets[this.socket.toString()] && global._trackedSockets[this.socket.toString()].isHttpRequest;
                 if (this.isLicenseSocket) {
                     logHook("[Network] Winsock recv on tracked HTTP socket: Socket=" + this.socket + ", BufferLen=" + this.len);
                 }
             },
             onLeave: function(retval) {
                 var bytesRead = retval.toInt32();

                 if (this.isLicenseSocket && bytesRead > 0) {
                     logHook("[Network] Received " + bytesRead + " bytes for tracked socket.");
                     if (this.buffer && !this.buffer.isNull()) {
                         try {
                             var responseData = this.buffer.readByteArray(bytesRead);
                             var hexData = Array.from(new Uint8Array(responseData)).map(b => b.toString(16).padStart(2, '0')).join('');
                             var strData = "";
                             try { strData = this.buffer.readUtf8String(bytesRead).replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '.'); } catch(e){}

                             logHook("[Network]  Recv Data (Hex): " + hexData.substring(0,128) + "...");
                             if (strData) logHook("[Network]  Recv Data (Str): " + strData.substring(0, 200) + "...");

                              // --- Activation Response Spoofing (Winsock) ---
                             var errorKeywords = ["error", "fail", "invalid", "expired", "denied", "unauthorized"];
                             // Check for HTTP error status codes (4xx, 5xx) or error keywords in body
                             var isHttpError = strData.startsWith("HTTP/1.") && (strData.includes(" 40") || strData.includes(" 50")); // Basic check for 4xx/5xx
                             var containsError = errorKeywords.some(keyword => strData.toLowerCase().includes(keyword));

                              if (isHttpError || containsError) {
                                  logHook("[Network] License failure detected in socket response! Attempting to spoof success...");
                                  // Construct a minimal successful HTTP response
                                  var successResponse = "HTTP/1.1 200 OK\\r\\nContent-Type: application/json\\r\\nContent-Length: 30\\r\\n\\r\\n{\\"status\\":\\"success\\",\\"valid\\":true}";

                                   if (successResponse.length <= this.len) {
                                       Memory.writeUtf8String(this.buffer, successResponse);
                                       retval.replace(successResponse.length); // IMPORTANT: Change return value to length of spoofed data
                                       logHook("[Network]  SPOOFED Winsock response with success message.");
                                   } else {
                                       logHook("[Network]  Spoofing failed: Success message too long for buffer.");
                                   }
                              }
                              // --- End Spoofing ---

                         } catch(e) { logHook("[Network]  Error processing recv buffer: " + e); }
                     }
                 } else if (this.isLicenseSocket && bytesRead === 0) {
                     logHook("[Network] Winsock connection closed by peer for tracked socket.");
                 } else if (this.isLicenseSocket && bytesRead < 0) {
                      logHook("[Network] Winsock recv failed for tracked socket (Error: " + NativeFunction.getLastError() + ")"); // Winsock uses WSAGetLastError
                 }
             }
         });
     }

""")

    # Window notification hooks
    if "window" in hook_types:
        script_parts.append("""
    // ========== Window API Hooks (License Notifications) ==========
    logHook("[Intellicrack] Setting up Window message hooks");

    // MessageBoxW / MessageBoxA - Common for license errors/nags
    ['MessageBoxW', 'MessageBoxA'].forEach(function(funcName){
        var messageBoxPtr = Module.findExportByName("user32.dll", funcName);
        if (messageBoxPtr) {
            Interceptor.attach(messageBoxPtr, {
                onEnter: function(args) {
                    // HWND hWnd = args[0]; LPCSTR lpText = args[1]; LPCSTR lpCaption = args[2]; UINT uType = args[3];
                    this.hWnd = args[0];
                    this.textPtr = args[1];
                    this.captionPtr = args[2];
                    this.uType = args[3].toInt32();
