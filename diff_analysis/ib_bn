        primary_actions_layout = QHBoxLayout()
        primary_actions_layout.setSpacing(10)

        self.analyze_btn = QPushButton("Full Binary Analysis")
        self.analyze_btn.setStyleSheet(primary_btn_style)
        self.analyze_btn.setToolTip("Perform comprehensive analysis on the binary")
        self.analyze_btn.clicked.connect(self.run_analysis)
        primary_actions_layout.addWidget(self.analyze_btn)

        self.apply_patch_btn = QPushButton("Apply Patches")
        self.apply_patch_btn.setStyleSheet(primary_btn_style)
        self.apply_patch_btn.setToolTip("Apply all configured patches to the binary")
        self.apply_patch_btn.clicked.connect(self.apply_patch_plan)
        primary_actions_layout.addWidget(self.apply_patch_btn)

        primary_actions.setLayout(primary_actions_layout)
        button_container.addWidget(primary_actions)

        # Patching Tools Group (collapsible)
        patching_tools = QGroupBox("Patching Tools")
        patching_tools.setCheckable(True)
        patching_tools.setChecked(True)  # Expanded by default
        patching_tools_layout = QHBoxLayout()

        self.preview_btn = QPushButton("Preview Patches")
        self.preview_btn.setToolTip("Preview what changes will be made before applying")
        self.preview_btn.clicked.connect(self.preview_patch)
        patching_tools_layout.addWidget(self.preview_btn)

        self.visual_editor_btn = QPushButton("Visual Patch Editor")
        self.visual_editor_btn.setToolTip("Open the visual patch editor for manual patching")
        self.visual_editor_btn.clicked.connect(self.open_visual_patch_editor)
        patching_tools_layout.addWidget(self.visual_editor_btn)

        patching_tools.setLayout(patching_tools_layout)
        button_container.addWidget(patching_tools)

        # Advanced Tools Group (collapsible)
        advanced_tools = QGroupBox("Advanced Tools")
        advanced_tools.setCheckable(True)
        advanced_tools.setChecked(False)  # Collapsed by default
        advanced_tools_layout = QGridLayout()

        self.similarity_search_btn = QPushButton("Similarity Search")
        self.similarity_search_btn.setToolTip("Find similar code patterns across binaries")
        self.similarity_search_btn.clicked.connect(self.open_similarity_search)
        advanced_tools_layout.addWidget(self.similarity_search_btn, 0, 0)

        self.finetune_model_btn = QPushButton("Fine-tune Model")
        self.finetune_model_btn.setToolTip("Fine-tune the AI model for better results")
        self.finetune_model_btn.clicked.connect(self.open_model_finetuning)
        advanced_tools_layout.addWidget(self.finetune_model_btn, 0, 1)

        self.generate_report_btn = QPushButton("Generate PDF Report")
        self.generate_report_btn.setToolTip("Generate a comprehensive PDF report of all analysis results")
        self.generate_report_btn.clicked.connect(self.run_report_generation)
        advanced_tools_layout.addWidget(self.generate_report_btn, 1, 0, 1, 2)  # Span 2 columns

        advanced_tools.setLayout(advanced_tools_layout)
        button_container.addWidget(advanced_tools)

        # Row 2 (Dropdown for Deep Analysis and Network Tools)
        row2 = QHBoxLayout()

        # Add Network & License Tools section
        network_label = QLabel("Network Tools:")
        row2.addWidget(network_label)

        self.network_tools_combo = QComboBox()
        self.network_tools_combo.addItems([
            "Select Network Tool",
            "License Server Emulator",
            "SSL/TLS Interceptor",
            "Cloud Response Generator",
            "Protocol Fingerprinter",
            "Network Traffic Analyzer"
        ])
        row2.addWidget(self.network_tools_combo)

        self.launch_network_tool_btn = QPushButton("Launch Tool")
        self.launch_network_tool_btn.clicked.connect(self.launch_network_tool)
        row2.addWidget(self.launch_network_tool_btn)

        # Define the launch_network_tool method if it doesn't exist yet
        if not hasattr(IntellicrackApp, "launch_network_tool"):
            def launch_network_tool(self):
                """Launch the selected network tool."""
                tool = self.network_tools_combo.currentText()

                if tool == "Select Network Tool":
                    QMessageBox.information(self, "Select Tool", "Please select a network tool from the dropdown.")
                    return

                self.update_output.emit(log_message(f"[Network] Launching {tool}..."))

                if tool == "License Server Emulator":
                    self.launch_license_server_emulator()
                elif tool == "SSL/TLS Interceptor":
                    QMessageBox.information(self, "Coming Soon", "SSL/TLS Interceptor will be available in a future update.")
                elif tool == "Cloud Response Generator":
                    QMessageBox.information(self, "Coming Soon", "Cloud Response Generator will be available in a future update.")
                elif tool == "Protocol Fingerprinter":
                    QMessageBox.information(self, "Coming Soon", "Protocol Fingerprinter will be available in a future update.")
                elif tool == "Network Traffic Analyzer":
                    QMessageBox.information(self, "Coming Soon", "Network Traffic Analyzer will be available in a future update.")
                else:
                    self.update_output.emit(log_message(f"[Network] Tool '{tool}' not implemented yet."))

            # Add to IntellicrackApp
            IntellicrackApp.launch_network_tool = launch_network_tool

            # Define the license server emulator launcher
            def launch_license_server_emulator(self):
                """Launch the license server emulator dialog."""
                self.update_output.emit(log_message("[Network] Starting License Server Emulator..."))

                # Create dialog
                dialog = QDialog(self)
                dialog.setWindowTitle("License Server Emulator")
                dialog.setMinimumSize(500, 400)

                # Create layout
                layout = QVBoxLayout(dialog)

                # Server configuration
                config_group = QGroupBox("Server Configuration")
                config_layout = QFormLayout()

                # Protocol selection
                protocol_combo = QComboBox()
                protocol_combo.addItems([
                    "HTTP/HTTPS",
                    "TCP/Raw Socket",
                    "UDP",
                    "Custom Binary Protocol"
                ])
                config_layout.addRow("Protocol:", protocol_combo)

                # Port selection
                port_spinbox = QSpinBox()
                port_spinbox.setRange(1024, 65535)
                port_spinbox.setValue(1337)
                config_layout.addRow("Port:", port_spinbox)

                # Bind address
                bind_address_edit = QLineEdit("127.0.0.1")
                config_layout.addRow("Bind Address:", bind_address_edit)

                config_group.setLayout(config_layout)
                layout.addWidget(config_group)

                # Server status and logs
                status_group = QGroupBox("Server Status")
                status_layout = QVBoxLayout()

                status_label = QLabel("Server: Stopped")
                status_layout.addWidget(status_label)

                log_output = QTextEdit()
                log_output.setReadOnly(True)
                status_layout.addWidget(log_output)

                status_group.setLayout(status_layout)
                layout.addWidget(status_group)

                # Control buttons
                button_layout = QHBoxLayout()

                start_button = QPushButton("Start Server")
                stop_button = QPushButton("Stop Server")
                stop_button.setEnabled(False)

                button_layout.addWidget(start_button)
                button_layout.addWidget(stop_button)

                layout.addLayout(button_layout)

                # Create server instance
                server = NetworkLicenseServerEmulator()

                # Custom logger function
                def log_to_dialog(message):
                    """
                    Log a message to the dialog output and main application.

                    Appends the message to the log output, scrolls to bottom, and emits to main app.
                    """
                    log_output.append(f"[{time.strftime('%H:%M:%S')}] {message}")
                    # Scroll to bottom
                    log_output.verticalScrollBar().setValue(log_output.verticalScrollBar().maximum())
                    # Also log to main app
                    self.update_output.emit(log_message(message))

                # Override server's log function
                server.log = log_to_dialog

                # Connect start button
                def start_server():
                    """
                    Start the server with the selected protocol and port.

                    Updates the UI to reflect the running server state.
                    """
                    protocol = protocol_combo.currentText()
                    port = port_spinbox.value()
                    bind_address = bind_address_edit.text()

                    server.bind_address = bind_address
                    if server.start_server(port, protocol):
                        status_label.setText(f"Server: Running on {bind_address}:{port} ({protocol})")
                        start_button.setEnabled(False)
                        stop_button.setEnabled(True)
                        protocol_combo.setEnabled(False)
                        port_spinbox.setEnabled(False)
                        bind_address_edit.setEnabled(False)

                # Connect stop button
                def stop_server():
                    """
                    Stop the server and update the UI accordingly.

                    Disables the stop button and enables controls for a new start.
                    """
                    if server.stop_server():
                        status_label.setText("Server: Stopped")
                        start_button.setEnabled(True)
                        stop_button.setEnabled(False)
                        protocol_combo.setEnabled(True)
                        port_spinbox.setEnabled(True)
                        bind_address_edit.setEnabled(True)

                # Connect buttons
                start_button.clicked.connect(start_server)
                stop_button.clicked.connect(stop_server)

                # Show dialog
                dialog.setModal(True)
                dialog.exec_()

                # Make sure server is stopped when dialog is closed
                if hasattr(server, "running") and server.running:
                    server.stop_server()

            # Add license server emulator launcher to IntellicrackApp
            IntellicrackApp.launch_license_server_emulator = launch_license_server_emulator

            # We already defined launch_network_tool above, so no need to redefine it here

        # Define open_network_rules_manager method if it doesn't exist yet
        if not hasattr(IntellicrackApp, "open_network_rules_manager"):
            def open_network_rules_manager(self):
                """Open the network rules manager dialog."""
                QMessageBox.information(
                    self,
                    "Network Rules Manager",
                    "The Network Rules Manager allows you to create and manage rules for various network tools.\n\n"
                    "You can create rules for:\n"
                    "- License Server responses\n"
                    "- SSL/TLS interception\n"
                    "- Cloud service responses\n"
                    "- Protocol fingerprinting\n\n"
                    "This feature will be fully implemented in the next update."
                )

            # Add to IntellicrackApp
            IntellicrackApp.open_network_rules_manager = open_network_rules_manager

        # Add a button for creating/managing network & license tool rules
        self.network_rules_btn = QPushButton("Manage Rules")
        self.network_rules_btn.setToolTip("Create and manage rules for network and license tools")
        self.network_rules_btn.clicked.connect(self.open_network_rules_manager)
        row2.addWidget(self.network_rules_btn)

        self.deep_analysis_combo = QComboBox()
        self.deep_analysis_combo.addItems([
            "License Logic",
            "Runtime Monitoring",
            "CFG Structure",
            "Packing Detection",
            "Taint Analysis",
            "Symbolic Execution",
            "Concolic Execution",
            "ROP Chain Analysis",
            "Memory Optimization",
            "Incremental Analysis",
            "Distributed Processing",
            "GPU Acceleration"
        ])
        self.deep_analysis_combo.currentTextChanged.connect(self.handle_deep_analysis_mode)
        row2.addWidget(self.deep_analysis_combo)
        button_container.addLayout(row2)

        # Row 3 (Dropdown for Patch Modes)
        row3 = QHBoxLayout()
        self.patch_mode_combo = QComboBox()
        self.patch_mode_combo.addItems([
            "Auto Patch Agent",
            "AI-Based Patching",
            "Full Auto Mode",
            "Simulate Patch"
        ])
        self.patch_mode_combo.currentTextChanged.connect(self.handle_patch_mode_selection)
        row3.addWidget(self.patch_mode_combo)

        self.ghidra_combo = QComboBox()
        self.ghidra_combo.addItems(["Ghidra GUI Analysis", "Ghidra AI (Headless Mode)"])
        self.ghidra_combo.currentTextChanged.connect(self.handle_ghidra_analysis_mode)
        row3.addWidget(self.ghidra_combo)
        button_container.addLayout(row3)

        # Row 4
        row4 = QHBoxLayout()
        self.view_cfg_btn = QPushButton("View CFG")
        self.view_cfg_btn.clicked.connect(self.view_cfg)
        row4.addWidget(self.view_cfg_btn)

        self.external_tool_btn = QPushButton("Execute Custom Command")
        self.external_tool_btn.clicked.connect(self.run_external_command)
        row4.addWidget(self.external_tool_btn)
        button_container.addLayout(row4)

        # Row 5
        row5 = QHBoxLayout()
        self.protection_scan_btn = QPushButton("Scan for Protections")
        self.protection_scan_btn.clicked.connect(partial(run_comprehensive_protection_scan, self))
        row5.addWidget(self.protection_scan_btn)

        self.enhanced_protection_btn = QPushButton("Handle Advanced Protections")
        self.enhanced_protection_btn.clicked.connect(partial(run_enhanced_protection_scan, self))
        row5.addWidget(self.enhanced_protection_btn)

        self.memory_patching_btn = QPushButton("Configure Memory Patching")
        self.memory_patching_btn.clicked.connect(partial(setup_memory_patching, self))
        row5.addWidget(self.memory_patching_btn)
        button_container.addLayout(row5)

        # Row 6 - Advanced Analysis Features
        row6 = QHBoxLayout()

        self.incremental_analysis_btn = QPushButton("Incremental Analysis")
        self.incremental_analysis_btn.clicked.connect(partial(run_incremental_analysis, self))
        self.incremental_analysis_btn.setToolTip("Avoid reprocessing unchanged code sections")
        row6.addWidget(self.incremental_analysis_btn)

        self.memory_optimized_btn = QPushButton("Memory Optimized Analysis")
        self.memory_optimized_btn.clicked.connect(partial(run_memory_optimized_analysis, self))
        self.memory_optimized_btn.setToolTip("Optimize memory usage for large executables")
        row6.addWidget(self.memory_optimized_btn)

        self.taint_analysis_btn = QPushButton("Taint Analysis")
        self.taint_analysis_btn.clicked.connect(partial(run_taint_analysis, self))
        self.taint_analysis_btn.setToolTip("Track license check data flow")
        row6.addWidget(self.taint_analysis_btn)

        button_container.addLayout(row6)

        # Row 7 - More Advanced Analysis Features
        row7 = QHBoxLayout()

        self.symbolic_execution_btn = QPushButton("Symbolic Execution")
        self.symbolic_execution_btn.clicked.connect(partial(run_symbolic_execution, self))
        self.symbolic_execution_btn.setToolTip("Automatic vulnerability discovery")
        row7.addWidget(self.symbolic_execution_btn)

        self.concolic_execution_btn = QPushButton("Concolic Execution")
        self.concolic_execution_btn.clicked.connect(partial(run_concolic_execution, self))
        self.concolic_execution_btn.setToolTip("More precise path exploration")
        row7.addWidget(self.concolic_execution_btn)

        self.rop_chain_btn = QPushButton("ROP Chain Generator")
        self.rop_chain_btn.clicked.connect(partial(run_rop_chain_generator, self))
        self.rop_chain_btn.setToolTip("Generate ROP chains for complex bypasses")
        row7.addWidget(self.rop_chain_btn)

        button_container.addLayout(row7)

        # Row 8 - Distributed Processing and GPU Acceleration
        row8 = QHBoxLayout()

        self.distributed_processing_btn = QPushButton("Distributed Processing")
        self.distributed_processing_btn.clicked.connect(partial(run_distributed_processing, self))
        self.distributed_processing_btn.setToolTip("Process large binaries across multiple cores")
        row8.addWidget(self.distributed_processing_btn)

        self.gpu_accelerator_btn = QPushButton("GPU Acceleration")
        self.gpu_accelerator_btn.clicked.connect(partial(run_gpu_accelerator, self))
        self.gpu_accelerator_btn.setToolTip("Accelerate analysis tasks using GPU")
        row8.addWidget(self.gpu_accelerator_btn)

        self.pdf_report_btn = QPushButton("Generate PDF Report")
        self.pdf_report_btn.clicked.connect(partial(run_pdf_report_generator, self))
        self.pdf_report_btn.setToolTip("Generate comprehensive PDF report of findings")
        row8.addWidget(self.pdf_report_btn)

        button_container.addLayout(row8)

        # Row 6
        row6 = QHBoxLayout()
        self.api_hooking_btn = QPushButton("Comprehensive API Hooking")
        self.api_hooking_btn.clicked.connect(self.inject_comprehensive_api_hooks)
        row6.addWidget(self.api_hooking_btn)

        self.generate_launcher_btn = QPushButton("Generate Launcher Script")
        self.generate_launcher_btn.clicked.connect(partial(generate_launcher_script, self))
        row6.addWidget(self.generate_launcher_btn)

        self.cloud_hooker_btn = QPushButton("Hook Cloud Licensing")
        self.cloud_hooker_btn.clicked.connect(partial(run_cloud_license_hooker, self))
        row6.addWidget(self.cloud_hooker_btn)
        button_container.addLayout(row6)

        # Row 7 (Dropdown for Export/Import)
        row7 = QHBoxLayout()
        self.results_combo = QComboBox()
        self.results_combo.addItems([
            "Export Analysis Results",
            "Load Ghidra Results"
        ])
        self.results_combo.currentTextChanged.connect(self.handle_results_action)
        row7.addWidget(self.results_combo)
        button_container.addLayout(row7)

        analysis_layout.addLayout(button_container)
        analysis_group.setLayout(analysis_layout)

        # Add items to the analyze splitter
        analyze_splitter.addWidget(program_group)
        analyze_splitter.addWidget(analysis_group)

        results_group = QGroupBox("Analysis Results")
        results_layout = QVBoxLayout()
        self.analyze_results_widget = QTextEdit()
        self.analyze_results_widget.setReadOnly(True)
        results_layout.addWidget(self.analyze_results_widget)
        self.clear_analysis_results.connect(self.analyze_results_widget.clear)
        results_group.setLayout(results_layout)
        analyze_splitter.addWidget(results_group)

        analyze_splitter.setSizes([150, 300, 350])
        layout.addWidget(analyze_splitter)

        self.analyze_status = QLabel("Ready")
        layout.addWidget(self.analyze_status)

        self.analysis_tab.setLayout(layout)

    def setup_logs_tab(self):
        """Sets up the Live Logs tab with enhanced features."""
        # Create the logs_tab widget if it doesn't exist
        if not hasattr(self, 'logs_tab'):
            self.logs_tab = QWidget()

        layout = QVBoxLayout()

        # Add toolbar for log controls
        log_toolbar = QHBoxLayout()

        # Add filter
        log_toolbar.addWidget(QLabel("Filter:"))
        self.log_filter = QTextEdit()
        self.log_filter.setMaximumHeight(28)
        self.log_filter.setFixedWidth(200)
        log_toolbar.addWidget(self.log_filter)

        apply_filter_btn = QPushButton("Apply")
        apply_filter_btn.clicked.connect(self.apply_log_filter)
        log_toolbar.addWidget(apply_filter_btn)

        log_toolbar.addStretch()

        # Add clear button
        clear_logs_btn = QPushButton("Clear Logs")
        clear_logs_btn.clicked.connect(self.clear_logs)
        log_toolbar.addWidget(clear_logs_btn)

        # Add save logs button
        save_logs_btn = QPushButton("Save Logs")
        save_logs_btn.clicked.connect(self.save_logs)
        log_toolbar.addWidget(save_logs_btn)

        layout.addLayout(log_toolbar)

        # Add log output
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        layout.addWidget(self.log_output)

        self.logs_tab.setLayout(layout)

    def setup_settings_tab(self):
        """Sets up the Settings tab with organized sections including model setup, update tools, configuration, and stealth patchers."""
        # Create the settings_tab widget if it doesn't exist
        if not hasattr(self, 'settings_tab'):
            self.settings_tab = QWidget()

        layout = QVBoxLayout()

        # Splitter to divide settings into adjustable panels
        settings_splitter = QSplitter(Qt.Vertical)

        # --- AI Model Settings ---
        model_group = QGroupBox("AI Model Settings")
        model_layout = QVBoxLayout()

        # Import custom model
        import_layout = QHBoxLayout()
        import_layout.addWidget(QLabel("Selected Model Path:")) # Updated label text
        self.custom_model_path_label = QLabel("None")
        # Initialize label text from config on startup
        if self.selected_model_path and os.path.exists(self.selected_model_path):
            self.custom_model_path_label.setText(os.path.basename(self.selected_model_path))
        import_layout.addWidget(self.custom_model_path_label, 1)

        self.import_model_btn = QPushButton("Import Custom Model")
        self.import_model_btn.clicked.connect(self.import_custom_model)
        import_layout.addWidget(self.import_model_btn)
        model_layout.addLayout(import_layout)

        # Verify File Hash
        verify_layout = QHBoxLayout()
        verify_layout.addWidget(QLabel("Verify Imported Model:"))
        self.check_model_btn = QPushButton("Verify File Hash") # Renamed button text
        self.check_model_btn.clicked.connect(self.verify_hash) # Connected to renamed method
        verify_layout.addWidget(self.check_model_btn)
        model_layout.addLayout(verify_layout)

        # Add AI model fine-tuning button
        finetune_model_btn = QPushButton("AI Model Fine-Tuning & Training")
        finetune_model_btn.clicked.connect(self.open_model_finetuning)
        model_layout.addWidget(finetune_model_btn)

        # Add API repositories configuration button
        repo_config_btn = QPushButton("Configure API Model Repositories")
        repo_config_btn.clicked.connect(self.configure_api_repositories)
        model_layout.addWidget(repo_config_btn)

        model_group.setLayout(model_layout)


        # --- Configuration ---
        config_group = QGroupBox("Configuration")
        config_layout = QVBoxLayout()

        # Ghidra path
        ghidra_layout = QHBoxLayout()
        ghidra_layout.addWidget(QLabel("Ghidra Path:"))
        self.ghidra_path_edit = QTextEdit()
        self.ghidra_path_edit.setPlainText(CONFIG.get("ghidra_path", ""))
        self.ghidra_path_edit.setMaximumHeight(28)
        ghidra_layout.addWidget(self.ghidra_path_edit, 1)

        browse_ghidra_btn = QPushButton("Browse")
        browse_ghidra_btn.clicked.connect(self.browse_ghidra_path)
        ghidra_layout.addWidget(browse_ghidra_btn)
        config_layout.addLayout(ghidra_layout)

        # Runtime config checkboxes
        runtime_options_layout = QVBoxLayout()
        self.runtime_interception_cb = QCheckBox("Enable Runtime Interception")
        self.runtime_interception_cb.setChecked(
            CONFIG.get("runtime_interception", True))
        runtime_options_layout.addWidget(self.runtime_interception_cb)

        self.detect_protections_cb = QCheckBox(
            "Detect Protections Automatically")
        self.detect_protections_cb.setChecked(
            CONFIG.get("detect_protections", True))
        runtime_options_layout.addWidget(self.detect_protections_cb)

        self.enable_memory_patching_cb = QCheckBox("Enable Memory Patching")
        self.enable_memory_patching_cb.setChecked(
            CONFIG.get("enable_memory_patching", True))
        runtime_options_layout.addWidget(self.enable_memory_patching_cb)

        self.enable_plugin_sandbox_cb = QCheckBox("Enable Plugin Sandboxing")
        self.enable_plugin_sandbox_cb.setChecked(
            CONFIG.get("enable_plugin_sandbox", True))
        runtime_options_layout.addWidget(self.enable_plugin_sandbox_cb)

        self.enable_remote_plugins_cb = QCheckBox("Enable Remote Plugin Execution")
        self.enable_remote_plugins_cb.setChecked(
            CONFIG.get("enable_remote_plugins", False))
        runtime_options_layout.addWidget(self.enable_remote_plugins_cb)

        # Plugin timeout control
        timeout_layout = QHBoxLayout()
        timeout_layout.addWidget(QLabel("Plugin Timeout (seconds):"))
        self.plugin_timeout_spinbox = QSpinBox()
        self.plugin_timeout_spinbox.setRange(5, 600)
        self.plugin_timeout_spinbox.setValue(CONFIG.get("plugin_timeout", 60))
        self.plugin_timeout_spinbox.setToolTip("Maximum execution time allowed for plugins")
        timeout_layout.addWidget(self.plugin_timeout_spinbox)
        runtime_options_layout.addLayout(timeout_layout)

        config_layout.addLayout(runtime_options_layout)

        save_config_btn = QPushButton("Save Configuration")
        save_config_btn.clicked.connect(self.save_config)
        config_layout.addWidget(save_config_btn)

        config_group.setLayout(config_layout)

        # --- Performance Optimization ---
        # Create a scroll area to contain the Performance Optimization group
        performance_scroll = QScrollArea()
        performance_scroll.setWidgetResizable(True)
        performance_scroll.setFrameShape(QFrame.NoFrame)

        performance_group = QGroupBox("Performance Optimization")
        performance_layout = QVBoxLayout()

        # Memory Optimization
        memory_layout = QGridLayout()
        memory_layout.addWidget(QLabel("<b>Memory Optimization:</b>"), 0, 0, 1, 2)

        self.memory_opt_enable_cb = QCheckBox("Enable Memory Optimization")
        self.memory_opt_enable_cb.setChecked(CONFIG.get("memory_optimization_enabled", False))
        self.memory_opt_enable_cb.setToolTip("Monitor and optimize memory usage during analysis")
        memory_layout.addWidget(self.memory_opt_enable_cb, 1, 0, 1, 2)

        memory_layout.addWidget(QLabel("Memory Threshold (%):"), 2, 0)
        self.memory_threshold_spinbox = QSpinBox()
        self.memory_threshold_spinbox.setRange(50, 95)
        self.memory_threshold_spinbox.setValue(CONFIG.get("memory_threshold", 80))
        self.memory_threshold_spinbox.setToolTip("Memory usage percentage at which optimization is triggered")
        memory_layout.addWidget(self.memory_threshold_spinbox, 2, 1)

        memory_layout.addWidget(QLabel("Check Interval (seconds):"), 3, 0)
        self.memory_interval_spinbox = QSpinBox()
        self.memory_interval_spinbox.setRange(1, 60)
        self.memory_interval_spinbox.setValue(CONFIG.get("memory_check_interval", 5))
        memory_layout.addWidget(self.memory_interval_spinbox, 3, 1)

        # Memory Optimization Techniques
        memory_layout.addWidget(QLabel("Optimization Techniques:"), 4, 0, 1, 2)

        self.gc_enable_cb = QCheckBox("Garbage Collection")
        self.gc_enable_cb.setChecked(CONFIG.get("memory_opt_gc", True))
        memory_layout.addWidget(self.gc_enable_cb, 5, 0)

        self.mem_struct_enable_cb = QCheckBox("Memory-Efficient Structures")
        self.mem_struct_enable_cb.setChecked(CONFIG.get("memory_opt_structures", True))
        memory_layout.addWidget(self.mem_struct_enable_cb, 5, 1)

        self.incremental_enable_cb = QCheckBox("Incremental Loading")
        self.incremental_enable_cb.setChecked(CONFIG.get("memory_opt_incremental", True))
        memory_layout.addWidget(self.incremental_enable_cb, 6, 0)

        self.leak_detect_enable_cb = QCheckBox("Leak Detection")
        self.leak_detect_enable_cb.setChecked(CONFIG.get("memory_opt_leak_detection", False))
        memory_layout.addWidget(self.leak_detect_enable_cb, 6, 1)

        performance_layout.addLayout(memory_layout)

        # GPU Acceleration
        gpu_layout = QHBoxLayout()
        gpu_layout.addWidget(QLabel("<b>GPU Acceleration:</b>"))

        self.gpu_enable_cb = QCheckBox("Enable GPU Acceleration")
        self.gpu_enable_cb.setChecked(CONFIG.get("gpu_acceleration", False))
        self.gpu_enable_cb.setToolTip("Use GPU for analysis when available")
        gpu_layout.addWidget(self.gpu_enable_cb)

        performance_layout.addLayout(gpu_layout)

        # Distributed Processing
        distributed_layout = QHBoxLayout()
        distributed_layout.addWidget(QLabel("<b>Distributed Processing:</b>"))

        self.distributed_enable_cb = QCheckBox("Enable Distributed Processing")
        self.distributed_enable_cb.setChecked(CONFIG.get("distributed_processing", False))
        self.distributed_enable_cb.setToolTip("Distribute workload across multiple machines")
        distributed_layout.addWidget(self.distributed_enable_cb)

        performance_layout.addLayout(distributed_layout)

        # Apply performance settings button
        apply_perf_btn = QPushButton("Apply Performance Settings")
        apply_perf_btn.clicked.connect(self.apply_performance_settings)
        performance_layout.addWidget(apply_perf_btn)

        performance_group.setLayout(performance_layout)

        # Set the performance group as the widget for the scroll area
        performance_scroll.setWidget(performance_group)

        # Add UI appearance group (without dark mode option - now only in View menu)
        appearance_group = QGroupBox("UI Appearance")
        appearance_layout = QVBoxLayout()

        # UI scale slider
        scale_layout = QHBoxLayout()
        scale_layout.addWidget(QLabel("UI Scale:"))
        self.ui_scale_slider = QSlider(Qt.Horizontal)
        self.ui_scale_slider.setMinimum(80)
        self.ui_scale_slider.setMaximum(150)
        self.ui_scale_slider.setValue(100)
        self.ui_scale_slider.setTickPosition(QSlider.TicksBelow)
        self.ui_scale_slider.setTickInterval(10)
        scale_layout.addWidget(self.ui_scale_slider)

        self.scale_value_label = QLabel("100%")
        scale_layout.addWidget(self.scale_value_label)

        # Connect slider to label
        self.ui_scale_slider.valueChanged.connect(
            lambda value: self.scale_value_label.setText(f"{value}%"))

        appearance_layout.addLayout(scale_layout)

        # Note about dark mode
        appearance_layout.addWidget(QLabel("<i>Note: Dark Mode toggle is available in the View menu</i>"))

        # Font size controls
        font_layout = QHBoxLayout()
        font_layout.addWidget(QLabel("Font Size:"))
        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems(["Small", "Medium", "Large"])
        self.font_size_combo.setCurrentText("Medium")
        font_layout.addWidget(self.font_size_combo)
        appearance_layout.addLayout(font_layout)

        # Apply appearance settings button
        apply_appearance_btn = QPushButton("Apply Appearance Settings")
        apply_appearance_btn.clicked.connect(self.apply_appearance_settings)
        appearance_layout.addWidget(apply_appearance_btn)

        appearance_group.setLayout(appearance_layout)

        # Add all groups to splitter
        settings_splitter.addWidget(model_group)
        settings_splitter.addWidget(config_group)
        settings_splitter.addWidget(performance_scroll)  # Add the scroll area instead of just the group
        settings_splitter.addWidget(appearance_group)

        settings_splitter.setSizes([300, 200, 200])
        layout.addWidget(settings_splitter)

        self.settings_tab.setLayout(layout)

    def setup_patching_tab(self):
        """Sets up the Patching tab with patch creation, management and testing capabilities."""
        layout = QVBoxLayout()

        # Create tabbed interface for different patching sections
        patching_tabs = QTabWidget()

        # --- Patch Strategy Tab ---
        strategy_tab = QWidget()
        strategy_layout = QVBoxLayout()

        # Strategy selection group
        strategy_group = QGroupBox("Patch Strategy")
        strategy_inner_layout = QVBoxLayout()

        # Strategy radio buttons
        self.strategy_auto_radio = QRadioButton("Automatic Patching")
        self.strategy_auto_radio.setChecked(True)
        self.strategy_auto_radio.setToolTip("Let Intellicrack determine the best patching strategy")
        strategy_inner_layout.addWidget(self.strategy_auto_radio)

        self.strategy_targeted_radio = QRadioButton("Targeted Patching")
        self.strategy_targeted_radio.setToolTip("Focus patches on specific protections")
        strategy_inner_layout.addWidget(self.strategy_targeted_radio)

        self.strategy_custom_radio = QRadioButton("Custom Patching")
        self.strategy_custom_radio.setToolTip("Manual control over all patch options")
        strategy_inner_layout.addWidget(self.strategy_custom_radio)

        # Strategy options
        options_layout = QGridLayout()

        self.patch_stealth_cb = QCheckBox("Stealth Mode")
        self.patch_stealth_cb.setToolTip("Apply patches in a way that is harder to detect")
        options_layout.addWidget(self.patch_stealth_cb, 0, 0)

        self.patch_backup_cb = QCheckBox("Create Backups")
        self.patch_backup_cb.setChecked(True)
        self.patch_backup_cb.setToolTip("Create backup files before patching")
        options_layout.addWidget(self.patch_backup_cb, 0, 1)

        self.patch_certificate_cb = QCheckBox("Preserve Signatures")
        self.patch_certificate_cb.setChecked(True)
        self.patch_certificate_cb.setToolTip("Attempt to preserve digital signatures")
        options_layout.addWidget(self.patch_certificate_cb, 1, 0)

        self.patch_metadata_cb = QCheckBox("Update Metadata")
        self.patch_metadata_cb.setChecked(True)
        self.patch_metadata_cb.setToolTip("Update file metadata to match changes")
        options_layout.addWidget(self.patch_metadata_cb, 1, 1)

        strategy_inner_layout.addLayout(options_layout)

        # Target selection for targeted patching
        target_group = QGroupBox("Targeting Options")
        target_layout = QVBoxLayout()

        target_type_layout = QHBoxLayout()
        target_type_layout.addWidget(QLabel("Target Type:"))
        self.target_type_combo = QComboBox()
        self.target_type_combo.addItems(["License Checks", "Trial Limitations", "Feature Locks",
                                          "Network Validation", "Hardware Checks", "Custom"])
        self.target_type_combo.setEnabled(False)
        target_type_layout.addWidget(self.target_type_combo)

        # Connect radio button to enable/disable targeting options
        self.strategy_targeted_radio.toggled.connect(lambda checked: self.target_type_combo.setEnabled(checked))

        target_layout.addLayout(target_type_layout)
        target_group.setLayout(target_layout)
        strategy_inner_layout.addWidget(target_group)

        # Run buttons
        run_btn_layout = QHBoxLayout()
        run_patch_btn = QPushButton("Run Patching")
        run_patch_btn.clicked.connect(self.run_patching)
        run_btn_layout.addWidget(run_patch_btn)

        preview_btn = QPushButton("Preview Patches")
        preview_btn.clicked.connect(self.preview_patch)
        run_btn_layout.addWidget(preview_btn)

        strategy_inner_layout.addLayout(run_btn_layout)

        strategy_group.setLayout(strategy_inner_layout)
        strategy_layout.addWidget(strategy_group)
        strategy_tab.setLayout(strategy_layout)

        # --- Patch List Tab ---
        patch_list_tab = QWidget()
        patch_list_layout = QVBoxLayout()

        # Patches table
        self.patches_table = QTableWidget()
        self.patches_table.setColumnCount(5)
        self.patches_table.setHorizontalHeaderLabels(["ID", "Type", "Location", "Status", "Actions"])
        self.patches_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.patches_table.setSelectionBehavior(QTableWidget.SelectRows)
        patch_list_layout.addWidget(self.patches_table)

        # Control buttons
        patch_controls_layout = QHBoxLayout()
        refresh_patches_btn = QPushButton("Refresh List")
        refresh_patches_btn.clicked.connect(self.refresh_patch_list)
        patch_controls_layout.addWidget(refresh_patches_btn)

        apply_all_btn = QPushButton("Apply All")
        apply_all_btn.clicked.connect(self.apply_all_patches)
        patch_controls_layout.addWidget(apply_all_btn)

        revert_all_btn = QPushButton("Revert All")
        revert_all_btn.clicked.connect(self.revert_all_patches)
        patch_controls_layout.addWidget(revert_all_btn)

        export_patches_btn = QPushButton("Export Patches")
        export_patches_btn.clicked.connect(self.export_patches)
        patch_controls_layout.addWidget(export_patches_btn)

        patch_list_layout.addLayout(patch_controls_layout)
        patch_list_tab.setLayout(patch_list_layout)

        # --- Visual Editor Tab ---
        editor_tab = QWidget()
        editor_layout = QVBoxLayout()

        editor_placeholder = QLabel("Visual Patch Editor")
        editor_placeholder.setAlignment(Qt.AlignCenter)
        editor_placeholder.setStyleSheet("font-size: 18px; color: gray;")

        open_editor_btn = QPushButton("Open Visual Patch Editor")
        open_editor_btn.clicked.connect(self.open_visual_patch_editor)

        editor_layout.addWidget(editor_placeholder)
        editor_layout.addWidget(open_editor_btn)
        editor_tab.setLayout(editor_layout)

        # --- Testing Tab ---
        testing_tab = QWidget()
        testing_layout = QVBoxLayout()

        # Test environment selection
        env_group = QGroupBox("Test Environment")
        env_layout = QVBoxLayout()

        env_type_layout = QHBoxLayout()
        env_type_layout.addWidget(QLabel("Environment Type:"))
        self.env_type_combo = QComboBox()
        self.env_type_combo.addItems(["Emulated", "Sandboxed", "Virtual Machine", "Direct"])
        env_type_layout.addWidget(self.env_type_combo)

        env_layout.addLayout(env_type_layout)

        # Test options
        test_options_layout = QGridLayout()

        self.test_network_cb = QCheckBox("Emulate Network")
        test_options_layout.addWidget(self.test_network_cb, 0, 0)

        self.test_memory_cb = QCheckBox("Memory Analysis")
        test_options_layout.addWidget(self.test_memory_cb, 0, 1)

        self.test_api_cb = QCheckBox("API Monitoring")
        test_options_layout.addWidget(self.test_api_cb, 1, 0)

        self.test_coverage_cb = QCheckBox("Coverage Analysis")
        test_options_layout.addWidget(self.test_coverage_cb, 1, 1)

        env_layout.addLayout(test_options_layout)

        # Test run buttons
        test_run_layout = QHBoxLayout()
        run_test_btn = QPushButton("Run Test")
        run_test_btn.clicked.connect(self.run_patch_test)
        test_run_layout.addWidget(run_test_btn)

        verify_btn = QPushButton("Verify Results")
        verify_btn.clicked.connect(self.verify_patch_results)
        test_run_layout.addWidget(verify_btn)

        env_layout.addLayout(test_run_layout)
        env_group.setLayout(env_layout)
        testing_layout.addWidget(env_group)

        # Test results area
        results_group = QGroupBox("Test Results")
        results_layout = QVBoxLayout()

        self.test_results_text = QTextEdit()
        self.test_results_text.setReadOnly(True)
        results_layout.addWidget(self.test_results_text)

        results_group.setLayout(results_layout)
        testing_layout.addWidget(results_group)

        testing_tab.setLayout(testing_layout)

        # Add all tabs to patching tabs
        patching_tabs.addTab(strategy_tab, "Strategy")
        patching_tabs.addTab(patch_list_tab, "Patch List")
        patching_tabs.addTab(editor_tab, "Visual Editor")
        patching_tabs.addTab(testing_tab, "Testing")

        layout.addWidget(patching_tabs)
        self.patching_tab.setLayout(layout)

    def setup_network_tab(self):
        """Sets up the Network tab with network analysis, emulation and tools."""
        layout = QVBoxLayout()

        # Create tabbed interface for different network sections
        network_tabs = QTabWidget()

        # --- Traffic Analysis Tab ---
        traffic_tab = QWidget()
        traffic_layout = QVBoxLayout()

        # Network capture controls
        capture_group = QGroupBox("Network Capture")
        capture_layout = QVBoxLayout()

        interface_layout = QHBoxLayout()
        interface_layout.addWidget(QLabel("Network Interface:"))
        self.interface_combo = QComboBox()
        self.interface_combo.addItems(["All Interfaces", "eth0", "wlan0", "lo"])
        interface_layout.addWidget(self.interface_combo)

        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Capture Filter:"))
        self.filter_input = QLineEdit()
        self.filter_input.setPlaceholderText("port 80 or port 443")
        filter_layout.addWidget(self.filter_input)

        capture_buttons = QHBoxLayout()
        start_capture_btn = QPushButton("Start Capture")
        start_capture_btn.clicked.connect(self.start_network_capture)
        capture_buttons.addWidget(start_capture_btn)

        stop_capture_btn = QPushButton("Stop Capture")
        stop_capture_btn.clicked.connect(self.stop_network_capture)
        capture_buttons.addWidget(stop_capture_btn)

        clear_capture_btn = QPushButton("Clear Data")
        clear_capture_btn.clicked.connect(self.clear_network_capture)
        capture_buttons.addWidget(clear_capture_btn)

        capture_layout.addLayout(interface_layout)
        capture_layout.addLayout(filter_layout)
        capture_layout.addLayout(capture_buttons)
        capture_group.setLayout(capture_layout)
        traffic_layout.addWidget(capture_group)

        # Traffic display
        traffic_group = QGroupBox("Traffic Analysis")
        traffic_inner_layout = QVBoxLayout()

        self.traffic_table = QTableWidget()
        self.traffic_table.setColumnCount(6)
        self.traffic_table.setHorizontalHeaderLabels(["Time", "Source", "Destination", "Protocol", "Length", "Info"])
        self.traffic_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        traffic_inner_layout.addWidget(self.traffic_table)
