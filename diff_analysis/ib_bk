        list_toolbar.addWidget(duplicate_btn)

        left_layout.addLayout(list_toolbar)

        # Patch list with drag-drop support
        self.patch_list = QListWidget()
        self.patch_list.setDragDropMode(QAbstractItemView.InternalMove)
        self.patch_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.patch_list.currentItemChanged.connect(self.patch_selected)
        self.patch_list.model().rowsMoved.connect(self.patches_reordered)
        left_layout.addWidget(self.patch_list)

        splitter.addWidget(left_panel)

        # Right panel - Patch editor
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)

        # Patch details form
        form_layout = QFormLayout()

        self.address_edit = QLineEdit()
        self.address_edit.setPlaceholderText("e.g., 0x401000")
        form_layout.addRow("Address:", self.address_edit)

        self.bytes_edit = QLineEdit()
        self.bytes_edit.setPlaceholderText("e.g., 9090909090")
        form_layout.addRow("New Bytes:", self.bytes_edit)

        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(80)
        form_layout.addRow("Description:", self.description_edit)

        # Apply changes button
        update_btn = QPushButton("Update Patch")
        update_btn.clicked.connect(self.update_current_patch)
        form_layout.addRow("", update_btn)

        right_layout.addLayout(form_layout)

        # Disassembly view
        right_layout.addWidget(QLabel("<b>Disassembly Context:</b>"))

        self.disasm_view = QTextEdit()
        self.disasm_view.setReadOnly(True)
        self.disasm_view.setFont(QFont("Courier New", 10))
        right_layout.addWidget(self.disasm_view)

        # Byte preview
        right_layout.addWidget(QLabel("<b>Byte Preview:</b>"))

        byte_preview_layout = QHBoxLayout()

        self.original_bytes_view = QTextEdit()
        self.original_bytes_view.setReadOnly(True)
        self.original_bytes_view.setMaximumHeight(80)
        self.original_bytes_view.setFont(QFont("Courier New", 10))

        self.patched_bytes_view = QTextEdit()
        self.patched_bytes_view.setReadOnly(True)
        self.patched_bytes_view.setMaximumHeight(80)
        self.patched_bytes_view.setFont(QFont("Courier New", 10))

        byte_preview_layout.addWidget(QLabel("Original:"))
        byte_preview_layout.addWidget(self.original_bytes_view)
        byte_preview_layout.addWidget(QLabel("Patched:"))
        byte_preview_layout.addWidget(self.patched_bytes_view)

        right_layout.addLayout(byte_preview_layout)

        splitter.addWidget(right_panel)

        # Set initial sizes
        splitter.setSizes([300, 700])

        layout.addWidget(splitter)

        # Bottom buttons
        button_layout = QHBoxLayout()

        test_btn = QPushButton("Test Patches")
        test_btn.clicked.connect(self.test_patches)
        button_layout.addWidget(test_btn)

        button_layout.addStretch()

        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.accept)
        button_layout.addWidget(save_btn)

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)

        layout.addLayout(button_layout)

        # Status bar
        self.status_label = QLabel("Ready")
        layout.addWidget(self.status_label)

    def populate_patch_list(self):
        """Populate the patch list with current patches."""
        self.patch_list.clear()

        for i, patch in enumerate(self.patches):
            address = patch.get("address", 0)
            description = patch.get("description", "No description")

            item = QListWidgetItem(f"Patch {i+1}: 0x{address:X} - {description[:30]}")
            item.setData(Qt.UserRole, i)  # Store patch index
            self.patch_list.addItem(item)

        if self.patches:
            self.patch_list.setCurrentRow(0)

    def patch_selected(self, current, previous):
        """Handle patch selection in the list."""
        if not current:
            self.clear_patch_form()
            return

        index = current.data(Qt.UserRole)
        if index < 0 or index >= len(self.patches):
            return

        patch = self.patches[index]

        # Update form
        address = patch.get("address", 0)
        self.address_edit.setText(f"0x{address:X}")

        new_bytes = patch.get("new_bytes", b"")
        if isinstance(new_bytes, bytes):
            self.bytes_edit.setText(new_bytes.hex().upper())
        else:
            self.bytes_edit.setText(str(new_bytes))

        self.description_edit.setText(patch.get("description", ""))

        # Update disassembly view
        self.update_disassembly_view(address)

        # Update byte preview
        self.update_byte_preview(address, new_bytes)

    def clear_patch_form(self):
        """Clear the patch form."""
        self.address_edit.clear()
        self.bytes_edit.clear()
        self.description_edit.clear()
        self.disasm_view.clear()
        self.original_bytes_view.clear()
        self.patched_bytes_view.clear()

    def update_current_patch(self):
        """Update the currently selected patch with form values."""
        current_item = self.patch_list.currentItem()
        if not current_item:
            return

        index = current_item.data(Qt.UserRole)
        if index < 0 or index >= len(self.patches):
            return

        # Get form values
        address_text = self.address_edit.text().strip()
        bytes_text = self.bytes_edit.text().strip()
        description = self.description_edit.toPlainText().strip()

        # Validate address
        try:
            if address_text.startswith("0x"):
                address = int(address_text, 16)
            else:
                address = int(address_text)
        except ValueError:
            QMessageBox.warning(self, "Invalid Address", "Please enter a valid hexadecimal address.")
            return

        # Validate bytes
        try:
            if bytes_text:
                # Remove spaces if present
                bytes_text = bytes_text.replace(" ", "")
                new_bytes = bytes.fromhex(bytes_text)
            else:
                new_bytes = b""
        except ValueError:
            QMessageBox.warning(self, "Invalid Bytes", "Please enter valid hexadecimal bytes.")
            return

        # Update patch
        self.patches[index]["address"] = address
        self.patches[index]["new_bytes"] = new_bytes
        self.patches[index]["description"] = description

        # Update list item
        current_item.setText(f"Patch {index+1}: 0x{address:X} - {description[:30]}")

        # Update views
        self.update_disassembly_view(address)
        self.update_byte_preview(address, new_bytes)

        self.status_label.setText(f"Updated patch {index+1}")

    def update_disassembly_view(self, address):
        """Update the disassembly view for the given address."""
        try:
            # Check if we have cached disassembly
            if address in self.disassembly_cache:
                self.disasm_view.setText(self.disassembly_cache[address])
                return

            # Use capstone to disassemble
            pe = pefile.PE(self.binary_path)

            # Determine if 32 or 64 bit
            is_64bit = pe.FILE_HEADER.Machine == 0x8664
            mode = CS_MODE_64 if is_64bit else CS_MODE_32

            # Get section containing address
            section = None
            for s in pe.sections:
                if (s.VirtualAddress <= address - pe.OPTIONAL_HEADER.ImageBase <
                    s.VirtualAddress + s.Misc_VirtualSize):
                    section = s
                    break

            if not section:
                self.disasm_view.setText(f"Address 0x{address:X} not found in any section")
                return

            # Calculate file offset
            offset = address - pe.OPTIONAL_HEADER.ImageBase - section.VirtualAddress + section.PointerToRawData

            # Read bytes from file
            with open(self.binary_path, "rb") as f:
                f.seek(offset - 16)  # Read some bytes before
                code_data = f.read(64)  # Read some bytes after

            # Disassemble
            md = Cs(CS_ARCH_X86, mode)

            disasm_text = f"Disassembly around 0x{address:X}:\n\n"

            for i, insn in enumerate(md.disasm(code_data, address - 16)):
                if insn.address == address:
                    disasm_text += f"=> 0x{insn.address:X}: {insn.mnemonic} {insn.op_str}\n"
                else:
                    disasm_text += f"   0x{insn.address:X}: {insn.mnemonic} {insn.op_str}\n"

            # Cache the result
            self.disassembly_cache[address] = disasm_text

            self.disasm_view.setText(disasm_text)

        except Exception as e:
            self.disasm_view.setText(f"Error disassembling: {e}")

    def update_byte_preview(self, address, new_bytes):
        """Update the byte preview for the given address and new bytes."""
        try:
            pe = pefile.PE(self.binary_path)

            # Get section containing address
            section = None
            for s in pe.sections:
                if (s.VirtualAddress <= address - pe.OPTIONAL_HEADER.ImageBase <
                    s.VirtualAddress + s.Misc_VirtualSize):
                    section = s
                    break

            if not section:
                self.original_bytes_view.setText("Address not found in any section")
                self.patched_bytes_view.setText("Cannot preview patched bytes")
                return

            # Calculate file offset
            offset = address - pe.OPTIONAL_HEADER.ImageBase - section.VirtualAddress + section.PointerToRawData

            # Read original bytes
            with open(self.binary_path, "rb") as f:
                f.seek(offset)
                original_bytes = f.read(len(new_bytes))

            # Format original bytes
            original_hex = " ".join(f"{b:02X}" for b in original_bytes)
            self.original_bytes_view.setText(original_hex)

            # Format new bytes
            if isinstance(new_bytes, bytes):
                new_hex = " ".join(f"{b:02X}" for b in new_bytes)
                self.patched_bytes_view.setText(new_hex)
            else:
                self.patched_bytes_view.setText(str(new_bytes))

        except Exception as e:
            self.original_bytes_view.setText(f"Error: {e}")
            self.patched_bytes_view.setText(f"Error: {e}")

    def add_new_patch(self):
        """Add a new empty patch."""
        # Create a new patch with default values
        new_patch = {
            "address": 0,
            "new_bytes": b"",
            "description": "New patch"
        }

        # Add to patches list
        self.patches.append(new_patch)

        # Add to list widget
        index = len(self.patches) - 1
        item = QListWidgetItem(f"Patch {index+1}: 0x0 - New patch")
        item.setData(Qt.UserRole, index)
        self.patch_list.addItem(item)

        # Select the new item
        self.patch_list.setCurrentRow(index)

        self.status_label.setText("Added new patch")

    def remove_selected_patch(self):
        """Remove the selected patch."""
        current_item = self.patch_list.currentItem()
        if not current_item:
            return

        index = current_item.data(Qt.UserRole)
        if index < 0 or index >= len(self.patches):
            return

        # Confirm deletion
        response = QMessageBox.question(
            self,
            "Remove Patch",
            f"Are you sure you want to remove patch {index+1}?",
            QMessageBox.Yes | QMessageBox.No
        )

        if response == QMessageBox.No:
            return

        # Remove patch
        del self.patches[index]

        # Refresh list
        self.populate_patch_list()

        self.status_label.setText(f"Removed patch {index+1}")

    def duplicate_selected_patch(self):
        """Duplicate the selected patch."""
        current_item = self.patch_list.currentItem()
        if not current_item:
            return

        index = current_item.data(Qt.UserRole)
        if index < 0 or index >= len(self.patches):
            return

        # Copy patch
        new_patch = self.patches[index].copy()
        new_patch["description"] = f"Copy of {new_patch['description']}"

        # Add to patches list
        self.patches.append(new_patch)

        # Refresh list
        self.populate_patch_list()

        # Select the new item
        self.patch_list.setCurrentRow(len(self.patches) - 1)

        self.status_label.setText(f"Duplicated patch {index+1}")

    def patches_reordered(self, parent, start, end, dest, row):
        """Handle patches being reordered via drag and drop."""
        # Get the moved item
        moved_index = start
        new_index = row

        if new_index > moved_index:
            new_index -= 1

        # Reorder patches list
        patch = self.patches.pop(moved_index)
        self.patches.insert(new_index, patch)

        # Update data in list items
        for i in range(self.patch_list.count()):
            item = self.patch_list.item(i)
            item.setData(Qt.UserRole, i)

        self.status_label.setText(f"Reordered patches")

    def test_patches(self):
        """Test the current patches without applying them."""
        if not self.patches:
            QMessageBox.information(self, "No Patches", "No patches to test.")
            return

        # Run simulation in a background thread
        self.status_label.setText("Testing patches...")

        # Use QThread to avoid freezing the UI
        class SimulationThread(QThread):
            """
            QThread for running patch simulations in the background.

            Emits results via result_signal to avoid blocking the UI.
            """
            result_signal = pyqtSignal(list)

            def __init__(self, binary_path, patches):
                """
                Initialize a SimulationThread to perform patch simulation.

                Args:
                    binary_path (str): Path to the binary file to be patched
                    patches (list): List of patch definitions to apply and simulate
                """
                super().__init__()
                self.binary_path = binary_path
                self.patches = patches

            def run(self):
                """Execute patch simulation in a separate thread.

                Simulates applying patches to the binary and verifies the results.
                Emits results via signal when complete, including any errors encountered.
                """
                try:
                    results = simulate_patch_and_verify(self.binary_path, self.patches)
                    self.result_signal.emit(results)
                except Exception as e:
                    self.result_signal.emit([f"Error: {e}"])

        # Create and start thread
        self.sim_thread = SimulationThread(self.binary_path
, self.patches)
        self.sim_thread.result_signal.connect(self.show_simulation_results)
        self.sim_thread.start()

    def show_simulation_results(self, results):
        """Show simulation results."""
        # Create a dialog to show results
        dialog = QDialog(self)
        dialog.setWindowTitle("Patch Simulation Results")
        dialog.setMinimumSize(600, 400)

        layout = QVBoxLayout(dialog)

        result_text = QTextEdit()
        result_text.setReadOnly(True)
        result_text.setFont(QFont("Courier New", 10))
        result_text.setText("\n".join(results))

        layout.addWidget(result_text)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn)

        dialog.exec_()

        self.status_label.setText("Patch simulation complete")

class DashboardManager:
    """
    More Intuitive Dashboard with Project Statistics.

    This class manages the dashboard UI, providing a more intuitive interface with
    project statistics, recent activities, and quick access to common functions.
    """

    def __init__(self, app):
        """Initialize the dashboard manager with the main application instance"""
        self.app = app
        self.logger = logging.getLogger("IntellicrackLogger.Dashboard")
        self.stats = {}
        self.recent_activities = []
        self.max_recent_activities = 20

    def update_stats(self):
        """Update dashboard statistics"""
        print("DEBUG: update_stats method called")
        # Initialize stats dict if needed
        if not hasattr(self, 'stats'):
            print("DEBUG: Initializing stats dictionary")
            self.stats = {}

        # Continue with normal update logic
        self._update_binary_stats()
        self._update_patch_stats()
        self._update_analysis_stats()
        self._update_license_stats()
        self._update_advanced_analysis_stats()
        print(f"DEBUG: Stats dictionary now contains keys: {list(self.stats.keys())}")

    def _update_binary_stats(self):
        """Update binary statistics"""
        if hasattr(self, 'app') and hasattr(self.app, "binary_path") and self.app.binary_path:
            binary_size = os.path.getsize(self.app.binary_path)
            binary_name = os.path.basename(self.app.binary_path)

            self.stats["binary"] = {
                "name": binary_name,
                "path": self.app.binary_path,
                "size": binary_size,
                "size_formatted": self._format_size(binary_size),
                "last_modified": datetime.datetime.fromtimestamp(os.path.getmtime(self.app.binary_path)).strftime("%Y-%m-%d %H:%M:%S")
            }
        else:
            self.stats["binary"] = None

    def _update_patch_stats(self):
        """Update patch statistics"""
        if hasattr(self, 'app') and hasattr(self.app, "patches") and self.app.patches:
            self.stats["patches"] = {
                "count": len(self.app.patches),
                "applied": sum(1 for p in self.app.patches if p.get("applied", False)),
                "types": {}
            }

            # Count patch types
            for patch in self.app.patches:
                patch_type = patch.get("type", "unknown")
                self.stats["patches"]["types"][patch_type] = self.stats["patches"]["types"].get(patch_type, 0) + 1
        else:
            self.stats["patches"] = {
                "count": 0,
                "applied": 0,
                "types": {}
            }

    def _update_analysis_stats(self):
        """Update analysis statistics"""
        if hasattr(self, 'app') and hasattr(self.app, "analyze_results") and self.app.analyze_results:
            self.stats["analysis"] = {
                "count": len(self.app.analyze_results),
                "last_run": self.recent_activities[0]["timestamp"] if self.recent_activities else "Never"
            }
        else:
            self.stats["analysis"] = {
                "count": 0,
                "last_run": "Never"
            }

    def _update_license_stats(self):
        """Update license server statistics"""
        if hasattr(self, 'app') and hasattr(self.app, "license_server_instance") and self.app.license_server_instance:
            self.stats["license_server"] = {
                "running": self.app.license_server_instance.running,
                "port": self.app.license_server_instance.port
            }
        else:
            self.stats["license_server"] = {
                "running": False,
                "port": None
            }

    def _update_advanced_analysis_stats(self):
        """Update advanced analysis features statistics"""
        # Create advanced_analysis dictionary using attribute checks
        self.stats["advanced_analysis"] = {
            "taint_analysis": hasattr(self.app, "taint_analysis_engine") if hasattr(self, 'app') else True,
            "symbolic_execution": hasattr(self.app, "symbolic_execution_engine") if hasattr(self, 'app') else True,
            "concolic_execution": hasattr(self.app, "concolic_execution_engine") if hasattr(self, 'app') else True,
            "rop_chain_generator": hasattr(self.app, "rop_chain_generator") if hasattr(self, 'app') else True,
            "memory_optimized": hasattr(self.app, "memory_optimized_loader") if hasattr(self, 'app') else True,
            "incremental_analysis": hasattr(self.app, "incremental_analysis_manager") if hasattr(self, 'app') else True,
            "distributed_processing": hasattr(self.app, "distributed_processing_manager") if hasattr(self, 'app') else True,
            "gpu_acceleration": hasattr(self.app, "gpu_accelerator") if hasattr(self, 'app') else True,
            "pdf_report": hasattr(self.app, "pdf_report_generator") if hasattr(self, 'app') else True
        }

        # Count active features (only boolean values)
        self.stats["advanced_analysis"]["active_count"] = sum(1 for value in self.stats["advanced_analysis"].values()
                                                             if value and isinstance(value, bool))

    def update_statistics(self, stats_dict):
        """Update specific statistics with provided values.
        This method is used by extract_binary_info to update dashboard with binary information.
        """
        self.logger.info(f"Updating dashboard statistics: {stats_dict}")

        # Initialize stats dict if needed
        if not hasattr(self, 'stats'):
            self.stats = {}

        # Update the stats with the provided values
        for key, value in stats_dict.items():
            self.stats[key] = value

        # Call update_stats to refresh all statistics
        self.update_stats()

        self.logger.info("Updated dashboard statistics")

    def add_activity(self, activity_type, description):
        """Add an activity to the recent activities list"""
        activity = {
            "type": activity_type,
            "description": description,
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        self.recent_activities.insert(0, activity)

        # Limit the number of recent activities
        if len(self.recent_activities) > self.max_recent_activities:
            self.recent_activities = self.recent_activities[:self.max_recent_activities]

        self.logger.info(f"Added activity: {activity_type} - {description}")

    def get_stats(self):
        """Get dashboard statistics"""
        self.update_stats()
        return self.stats

    def get_recent_activities(self):
        """Get recent activities"""
        return self.recent_activities

    def _format_size(self, size_bytes):
        """Format size in bytes to human-readable format"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.2f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.2f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"

class IntellicrackApp(QMainWindow):
    """
    Main application window for Intellicrack - a comprehensive reverse engineering and security analysis framework.

    This class implements the primary user interface for the Intellicrack tool, providing access to various
    security analysis capabilities including binary analysis, memory forensics, network monitoring,
    API hooking, license bypass, and report generation.

    The application architecture is built on PyQt with support for multithreaded operations,
    allowing resource-intensive tasks to run in background threads while maintaining UI responsiveness.
    The class includes numerous signals for thread-safe communication between worker threads and the UI.

    Features:
        - Binary analysis and reverse engineering tools
        - Memory optimization and performance settings
        - Network analysis (packet capture, scanning, protocol analysis)
        - Report generation
        - API hooking and monitoring
        - License verification bypass capabilities
        - Assistant integration
    """
    update_output = pyqtSignal(str)
    update_status = pyqtSignal(str)
    update_analysis_results = pyqtSignal(str)
    clear_analysis_results = pyqtSignal()
    update_progress = pyqtSignal(int)
    update_assistant_status = pyqtSignal(str)
    update_chat_display = pyqtSignal(str)
    replace_chat_display_last = pyqtSignal(str, str)
    log_user_question = pyqtSignal(str, str)
    set_keygen_name = pyqtSignal(str)
    set_keygen_version = pyqtSignal(str)
    switch_tab = pyqtSignal(int)
    generate_key_signal = pyqtSignal()

    # Thread-safe slot for handling confirmation dialogs
    def thread_safe_confirmation(self, callback):
        """
        Thread-safe slot for executing UI operations from background threads.
        This method is called via QMetaObject.invokeMethod from background threads.

        Args:
            callback: A callable function to execute in the main thread
        """
        try:
            # Execute the callback in the main thread
            callback()
        except Exception as e:
            self.update_output.emit(log_message(f"[Thread-Safe UI] Error: {str(e)}"))
            logger.error(f"Error in thread_safe_confirmation: {str(e)}")
            logger.error(traceback.format_exc())

    def run_report_generation(self):
        """Run PDF report generation in a background thread."""
        # Call the standalone function with self as the app parameter
        run_report_generation(self)

    def launch_network_tool(self):
        """Launch the selected network tool."""
        try:
            tool_name = self.network_tool_combo.currentText()
            self.update_output.emit(f"Launching network tool: {tool_name}")

            if tool_name == "Packet Capture":
                self.start_packet_capture()
            elif tool_name == "Network Scanner":
                self.start_network_scan()
            elif tool_name == "Protocol Analyzer":
                self.start_protocol_analysis()
            else:
                self.update_output.emit(f"Unknown tool: {tool_name}")
        except Exception as e:
            self.update_output.emit(f"Error launching network tool: {str(e)}")
            logger.error(f"Network tool error: {str(e)}")

    def start_packet_capture(self):
        """Start packet capture tool."""
        self.update_output.emit("Starting packet capture...")
        # Implementation would go here

    def start_network_scan(self):
        """Start network scanning tool."""
        self.update_output.emit("Starting network scan...")
        # Implementation would go here

    def start_protocol_analysis(self):
        """Start protocol analysis tool."""
        self.update_output.emit("Starting protocol analysis...")
        # Implementation would go here

    def apply_performance_settings(self):
        """Apply performance optimization settings."""
        try:
            # Memory optimization settings
            memory_optimization_enabled = self.memory_opt_enable_cb.isChecked()
            memory_threshold = self.memory_threshold_spinbox.value()
            memory_interval = self.memory_interval_spinbox.value()

            # Save settings to config
            CONFIG["memory_optimization_enabled"] = memory_optimization_enabled
            CONFIG["memory_threshold"] = memory_threshold
            CONFIG["memory_check_interval"] = memory_interval
            CONFIG["memory_opt_gc"] = self.gc_enable_cb.isChecked()
            CONFIG["memory_opt_structures"] = self.mem_struct_enable_cb.isChecked()
            CONFIG["memory_opt_incremental"] = self.incremental_enable_cb.isChecked()

            # Update the memory optimizer if it exists
            if hasattr(self, 'memory_optimizer') and self.memory_optimizer:
                self.memory_optimizer.set_threshold(memory_threshold)
                self.memory_optimizer.set_check_interval(memory_interval)

            self.update_output.emit("Applied performance optimization settings")
            logger.info("Applied performance optimization settings")
        except Exception as e:
            self.update_output.emit(f"Error applying performance settings: {str(e)}")
            logger.error(f"Error in apply_performance_settings: {str(e)}")

    def __init__(self):
        """
        Initialize the main Intellicrack application window.

        Sets up the logger, model manager, and other core components.
        """
        super().__init__()

        # Initialize logger
        self.logger = logging.getLogger("IntellicrackLogger.Main")
        self.logger.info("IntellicrackApp constructor called. Initializing main application window.")

        # Initialize the ModelManager
        self.model_manager = ModelManager(CONFIG)

        # Initialize ML predictor
        try:
            # Enhanced diagnostics for ML model loading
            self.logger.info("Starting ML model initialization with diagnostics")

            # Create models directory if it doesn't exist
            os.makedirs("models", exist_ok=True)

            # First check CONFIG for custom model path
            model_found = False
            model_path = None
            model_path_debug_info = []

            # 1. Try CONFIG["ml_model_path"] first if it exists
            if "ml_model_path" in CONFIG and CONFIG["ml_model_path"]:
                config_path = CONFIG["ml_model_path"]
                model_path_debug_info.append(f"Checking CONFIG path: {config_path}")
                if os.path.exists(config_path):
                    model_path = config_path
                    model_found = True
                    model_path_debug_info.append(f"MODEL FOUND at CONFIG path: {config_path}")
                else:
                    model_path_debug_info.append(f"MODEL NOT FOUND at CONFIG path: {config_path}")
            else:
                model_path_debug_info.append("No CONFIG['ml_model_path'] set")

            # 2. Try default path using __file__ if not found in CONFIG
            if not model_found:
                default_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "models", "vuln_predict_model.joblib")
                model_path_debug_info.append(f"Checking default path: {default_path}")
                if os.path.exists(default_path):
                    model_path = default_path
                    model_found = True
                    model_path_debug_info.append(f"MODEL FOUND at default path: {default_path}")
                else:
                    model_path_debug_info.append(f"MODEL NOT FOUND at default path: {default_path}")

            # 3. Try alternate locations as fallbacks
            if not model_found:
                alternate_paths = [
                    os.path.join("models", "vuln_predict_model.joblib"),
                    os.path.join("..", "models", "vuln_predict_model.joblib"),
                    os.path.join(".", "models", "vuln_predict_model.joblib")
                ]

                for alt_path in alternate_paths:
                    abs_alt_path = os.path.abspath(alt_path)
                    model_path_debug_info.append(f"Checking alternate path: {abs_alt_path}")
                    if os.path.exists(abs_alt_path):
                        model_path = abs_alt_path
                        model_found = True
                        model_path_debug_info.append(f"MODEL FOUND at alternate path: {abs_alt_path}")
                        break
                    else:
                        model_path_debug_info.append(f"MODEL NOT FOUND at alternate path: {abs_alt_path}")

            # Log all the path information for diagnostic purposes
            for info in model_path_debug_info:
                self.logger.info(f"[ML Path Diagnostic] {info}")

            # If model was found in any location, initialize the predictor
            if model_found and model_path:
                try:
                    self.ml_predictor = MLVulnerabilityPredictor(model_path)
                    self.logger.info(f"ML predictor successfully initialized with model: {model_path}")

                    # Update CONFIG to remember this path for next time
                    CONFIG["ml_model_path"] = model_path
                    self.save_config()
                except Exception as e:
                    self.logger.error(f"Failed to initialize ML predictor despite finding model file: {e}")
                    self.logger.error(f"Exception details: {traceback.format_exc()}")
                    self.ml_predictor = None
            else:
                # Create a placeholder model file if no model was found anywhere
                default_model_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "models", "vuln_predict_model.joblib")
                self.logger.warning(f"ML model file not found in any location. Creating a placeholder model at: {default_model_path}")
                self._create_default_ml_model(default_model_path)
                try:
                    self.ml_predictor = MLVulnerabilityPredictor(default_model_path)
                    self.logger.info(f"ML predictor initialized with placeholder model: {default_model_path}")

                    # Update config with the new path
                    CONFIG["ml_model_path"] = default_model_path  # Use default_model_path which is defined above
                    self.save_config()
                except Exception as e:
                    self.logger.error(f"Failed to initialize ML predictor with placeholder model: {e}")
                    self.logger.error(f"Exception details: {traceback.format_exc()}")
                    self.ml_predictor = None
            self.logger.info("IntellicrackApp initialization complete.")
        except Exception as e:
            self.logger.error(f"Failed to initialize ML predictor: {e}")
            self.logger.error(f"Exception details: {traceback.format_exc()}")
            self.ml_predictor = None

        # Connect signals
        self.update_output.connect(self.append_output)
        self.update_status.connect(self.set_status_message)
        self.update_analysis_results.connect(self.append_analysis_results)
        # self.clear_analysis_results.connect(self.analyze_results.clear)
        self.update_progress.connect(self.set_progress_value)
        self.update_assistant_status.connect(self.set_assistant_status)
        self.update_chat_display.connect(self.append_chat_display)
        self.replace_chat_display_last.connect(self.replace_last_chat_message)
        self.log_user_question.connect(self.handle_log_user_question)
        self.set_keygen_name.connect(self.handle_set_keygen_name)
        self.set_keygen_version.connect(self.handle_set_keygen_version)
        self.switch_tab.connect(self.handle_switch_tab)
        self.generate_key_signal.connect(self.handle_generate_key)

        # Set up main window
        self.setWindowTitle("Intellicrack")
        self.setGeometry(100, 100, 1200, 800)

        # Try to load icon
        icon_path = "assets/icon.ico"
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        # Initialize important properties
        self.binary_path = None
        self.selected_model_path = CONFIG.get("selected_model_path", None) # Initialize from config
        if self.selected_model_path and os.path.exists(self.selected_model_path):
            # Update the label in settings if the path is valid
            if hasattr(self, 'custom_model_path_label'):
                self.custom_model_path_label.setText(os.path.basename(self.selected_model_path))
            self.update_output.emit(log_message(f"[AI Model] Loaded saved model path from config: {self.selected_model_path}"))
        else:
            self.selected_model_path = None # Ensure it's None if path is invalid or not set
            if hasattr(self, 'custom_model_path_label'):
                self.custom_model_path_label.setText("None")
            self.update_output.emit(log_message("[AI Model] No saved model path found or path is invalid."))


        self.chat_history = []
        self.frida_sessions = {}
        self.auto_patch_attempted = False
        self.potential_patches = []  # Initialize potential_patches
        self.recent_files = []  # Initialize recent files list

        # --- Initialize analyzer instance variables to None ---
        self.dynamic_analyzer = None
        self.ml_predictor = None
        self.analyze_results = []
        self.patches = []
        self.binary_info = None
        # --- End Initialization ---

        # Connect external function wrappers as instance methods using partial
        # These are global functions that take 'self' as their first argument
        # Only include functions that actually exist as global functions
        self.inject_comprehensive_api_hooks = partial(inject_comprehensive_api_hooks, self)
        self.run_custom_plugin = partial(run_custom_plugin, self)
        self.run_frida_plugin_from_file = partial(run_frida_plugin_from_file, self)
        self.run_ghidra_plugin_from_file = partial(run_ghidra_plugin_from_file, self)
        self.run_plugin = partial(run_plugin, self)

        # -------------------------------
        # Method Binding
        # -------------------------------
        # Bind all the standalone method definitions to the IntellicrackApp class
        # This allows them to be used as instance methods while keeping the code modular

        # Bind analysis-related methods
        self.__class__.run_selected_analysis = run_selected_analysis
        self.__class__.run_selected_patching = run_selected_patching
        self.__class__.run_memory_analysis = run_memory_analysis
        self.__class__.run_network_analysis = run_network_analysis

        # Bind patching-related methods
        self.__class__.run_patching = run_patching
        self.__class__.refresh_patch_list = refresh_patch_list
        self.__class__.apply_patch = apply_patch
        self.__class__.revert_patch = revert_patch
        self.__class__.edit_patch = edit_patch
        self.__class__.apply_all_patches = apply_all_patches
        self.__class__.revert_all_patches = revert_all_patches
        self.__class__.export_patches = export_patches
        self.__class__.run_patch_test = run_patch_test
        self.__class__.verify_patch_results = verify_patch_results

        # Bind network and license server methods
        self.__class__.start_network_capture = start_network_capture
        self.__class__.stop_network_capture = stop_network_capture
        self.__class__.clear_network_capture = clear_network_capture
        self.__class__.start_license_server = start_license_server
        self.__class__.stop_license_server = stop_license_server
        self.__class__.test_license_server = test_license_server
        self.__class__.launch_protocol_tool = launch_protocol_tool
        self.__class__.update_protocol_tool_description = update_protocol_tool_description

        # Bind report-related methods
        self.__class__.generate_report = generate_report
        self.__class__.view_report = view_report
        self.__class__.export_report = export_report
        self.__class__.delete_report = delete_report
        self.__class__.refresh_reports_list = refresh_reports_list
        self.__class__.import_report = import_report

        # Initialize analyzer instances
        self.dynamic_analyzer = None
        self.ml_predictor = None
        self.memory_optimized_loader = MemoryOptimizedBinaryLoader()
        self.symbolic_execution_engine = SymbolicExecutionEngine("")  # Empty string as placeholder, will be set later with set_binary
        self.taint_analysis_engine = TaintAnalysisEngine()
        self.concolic_execution_engine = ConcolicExecutionEngine("")  # Empty string as placeholder, will be set later with set_binary
        self.rop_chain_generator = ROPChainGenerator()
        self.distributed_processing_manager = DistributedProcessingManager()
        self.gpu_accelerator = GPUAccelerator()
        
        # Add TOOL_REGISTRY for hexview integration
        self.TOOL_REGISTRY = TOOL_REGISTRY.copy()
        
        # Initialize ghidra_path_edit to avoid attribute errors
        self.ghidra_path_edit = None
        
        # pylint: disable=no-value-for-parameter
        self.pdf_report_generator = PDFReportGenerator()

        # Create central widget and layout
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        self.main_layout = QVBoxLayout(self.central_widget)

        self.create_toolbar()

        self.main_splitter = QSplitter(Qt.Horizontal)
        self.main_layout.addWidget(self.main_splitter)

        self.tabs = QTabWidget()
