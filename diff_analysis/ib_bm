                    DWMWA_USE_IMMERSIVE_DARK_MODE = 20

                    # Get window handle
                    hwnd = int(self.winId())

                    # Set the attribute using the correct parameter types
                    windll.dwmapi.DwmSetWindowAttribute(
                        hwnd,
                        DWMWA_USE_IMMERSIVE_DARK_MODE,
                        byref(c_int(0)),  # 0 for light mode
                        sizeof(c_int)
                    )
                except Exception as e:
                    # If it fails, just log and continue
                    print(f"Could not set light title bar: {e}")

        elif theme_name == "dark":
            # Dark theme
            app = QApplication.instance()
            app.setStyle("Fusion")
            palette = QPalette()
            palette.setColor(QPalette.Window, QColor(53, 53, 53))
            palette.setColor(QPalette.WindowText, Qt.white)
            palette.setColor(QPalette.Base, QColor(25, 25, 25))
            palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
            palette.setColor(QPalette.ToolTipBase, Qt.white)
            palette.setColor(QPalette.ToolTipText, Qt.white)
            palette.setColor(QPalette.Text, Qt.white)
            palette.setColor(QPalette.Button, QColor(53, 53, 53))
            palette.setColor(QPalette.ButtonText, Qt.white)
            palette.setColor(QPalette.BrightText, Qt.red)
            palette.setColor(QPalette.Link, QColor(42, 130, 218))
            palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
            palette.setColor(QPalette.HighlightedText, Qt.black)
            app.setPalette(palette)

            # Apply dark title bar
            if os.name == 'nt':
                try:

                    # Define constants
                    DWMWA_USE_IMMERSIVE_DARK_MODE = 20

                    # Get window handle
                    hwnd = int(self.winId())

                    # Set the attribute using the correct parameter types
                    windll.dwmapi.DwmSetWindowAttribute(
                        hwnd,
                        DWMWA_USE_IMMERSIVE_DARK_MODE,
                        byref(c_int(1)),  # 1 for dark mode
                        sizeof(c_int)
                    )

                    # Also try the older attribute (Windows 10 before 1809)
                    try:
                        DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1 = 19
                        windll.dwmapi.DwmSetWindowAttribute(
                            hwnd,
                            DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1,
                            byref(c_int(1)),  # 1 for dark mode
                            sizeof(c_int)
                        )
                    except:
                        pass
                except Exception as e:
                    # If it fails, just log and continue
                    print(f"Could not set dark title bar: {e}")

            # Apply dark styling to the rest of the UI
            self.setStyleSheet("""
                QMainWindow {
                    background-color: #353535;
                    color: white;
                }
                QMenuBar {
                    background-color: #353535;
                    color: white;
                }
                QMenuBar::item {
                    background-color: #353535;
                    color: white;
                }
                QMenuBar::item:selected {
                    background-color: #2a82da;
                }
                QMenu {
                    background-color: #353535;
                    color: white;
                }
                QMenu::item:selected {
                    background-color: #2a82da;
                }
                QToolBar {
                    background-color: #353535;
                    color: white;
                    border: none;
                }
                QStatusBar {
                    background-color: #353535;
                    color: white;
                }
            """)

        elif theme_name == "hacker":
            # Hacker theme (green on black)
            app = QApplication.instance()
            app.setStyle("Fusion")
            palette = QPalette()
            palette.setColor(QPalette.Window, QColor(0, 0, 0))
            palette.setColor(QPalette.WindowText, QColor(0, 255, 0))

        # Save theme preference to config
        if hasattr(self, "config"):
            self.config["theme"] = theme_name
            self.save_config()

        # Update status bar with theme info
        self.statusBar().showMessage(f"Theme changed to {theme_name}")

    def toggle_dark_mode(self):
        """Toggle between light and dark mode"""
        if self.current_theme == "dark":
            self.apply_theme("light")
        else:
            self.apply_theme("dark")

    def toggle_dark_mode_from_checkbox(self, state):
        """Toggle dark mode based on checkbox state"""
        # This method is kept for backward compatibility but will no longer be used
        # as the dark mode checkbox has been removed from settings.
        # Dark mode is now only toggleable from the View menu.
        if state == Qt.Checked:
            self.apply_theme("dark")
        else:
            self.apply_theme("light")

    def show_documentation(self):
        """Show documentation dialog"""
        QMessageBox.information(self, "Documentation",
                               "The Intellicrack documentation can be accessed online at:\n"
                               "https://intellicrack.docs.example.com\n\n"
                               "Local documentation can be found in the docs/ folder of your installation directory.")

    def show_tutorials(self):
        """Show tutorials dialog"""
        tutorials = [
            "Getting Started with Intellicrack",
            "Binary Analysis Fundamentals",
            "Advanced Patching Techniques",
            "Using the Visual Patch Editor",
            "Creating Custom Plugins",
            "Working with Emulation Layers",
            "Network License Bypassing"
        ]

        tutorial_list = "\n".join([f"• {t}" for t in tutorials])

        QMessageBox.information(self, "Tutorials",
                               f"The following tutorials are available:\n\n{tutorial_list}\n\n"
                               "Access tutorials from our website at:\nhttps://intellicrack.tutorials.example.com")

    def apply_appearance_settings(self):
        """Apply UI appearance settings like scale and font size"""
        # Get scale value
        scale = self.ui_scale_slider.value()

        # Get font size
        font_size = self.font_size_combo.currentText()

        # Apply font size
        app = QApplication.instance()
        font = app.font()

        if font_size == "Small":
            font.setPointSize(8)
        elif font_size == "Medium":
            font.setPointSize(10)
        elif font_size == "Large":
            font.setPointSize(12)

        app.setFont(font)

        # Apply scale (would require more complex implementation in a real app)
        self.update_output.emit(log_message(f"[Settings] Applied UI scale: {scale}% and font size: {font_size}"))
        self.update_status.emit(f"Appearance settings updated")

        # Save settings to config
        if hasattr(self, "config"):
            self.config["ui_scale"] = scale
            self.config["font_size"] = font_size
            self.save_config()

    def show_about_dialog(self):
        """Show the about dialog"""

        QMessageBox.about(self, "About Intellicrack",
            "Intellicrack - Advanced Binary Analysis\n\n"
            "Version: 2.0\n"
            "© 2025 Intellicrack Team\n\n"
            "An advanced binary analysis and patching tool with AI capabilities."
        )

    def closeEvent(self, event):
        """Handle window close event."""
        # Save config including theme settings
        if hasattr(self, "config"):
            self.config["theme"] = self.current_theme
            self.save_config()

        # Clean up any resources
        cleanup_summary = []

        # Clean up Frida sessions and scripts
        if hasattr(self, "frida_sessions"):
            for session_name, (session, script) in self.frida_sessions.items():
                try:
                    # Unload the script first
                    if script:
                        script.unload()
                        self.logger.info(f"Unloaded Frida script for session: {session_name}")

                    # Then detach the session
                    session.detach()
                    self.logger.info(f"Detached Frida session: {session_name}")

                    # Add to cleanup summary
                    cleanup_summary.append(f"Cleaned up Frida session: {session_name}")
                except Exception as e:
                    self.logger.error(f"Error cleaning up Frida session {session_name}: {str(e)}")

            # Log summary of closed sessions
            if cleanup_summary:
                self.logger.info(f"Closed {len(cleanup_summary)} Frida sessions during application shutdown")

        # Save session state for next launch
        if hasattr(self, "config") and cleanup_summary:
            session_state = {
                "last_session": {
                    "closed_time": time.strftime('%Y-%m-%d %H:%M:%S'),
                    "sessions_closed": len(cleanup_summary)
                }
            }
            self.config["session_history"] = session_state
            self.save_config()

        event.accept()

    def clear_output(self):
        """Clears the output panel."""
        self.output.clear()
        self.statusBar().showMessage("Output cleared")

# --- Thread-Safe GUI Update Slots ---

    def set_status_message(self, text):
        """
        Safely updates the status bar or analysis status label from any thread.

        Thread-safe method to update UI status elements.

        Args:
            text: The status message text to display

        Returns:
            None
        """
        if hasattr(self, 'analyze_status'):
            self.analyze_status.setText(text)
        self.statusBar().showMessage(text[:100])  # Keep status bar concise

    def append_analysis_results(self, text):
        """
        Safely appends text to the analysis results view from any thread.

        Thread-safe method to update analysis results, including automatic scrolling.

        Args:
            text: The text to append to the results view

        Returns:
            None
        """
        if hasattr(self, 'analyze_results_widget') and self.analyze_results_widget is not None:
            # Append to the UI widget
            self.analyze_results_widget.append(text)
            # Optional: Scroll to bottom
            cursor = self.analyze_results_widget.textCursor()
            cursor.movePosition(cursor.End)
            self.analyze_results_widget.setTextCursor(cursor)

        # Also store in the list for programmatic access
        if hasattr(self, 'analyze_results'):
            # Make sure it's initialized as a list
            if not isinstance(self.analyze_results, list):
                self.analyze_results = []
            self.analyze_results.append(text)

    def set_progress_value(self, value):
        """
        Safely sets the progress bar value from any thread.

        Thread-safe method to update progress bar UI element.

        Args:
            value: Integer percentage value for the progress bar (0-100)

        Returns:
            None
        """
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setValue(value)

    def set_assistant_status(self, text):
        """Safely sets the assistant status label."""
        if hasattr(self, 'assistant_status'):
            self.assistant_status.setText(text)

    def append_chat_display(self, text):
        """
        Safely appends text to the chat display from any thread.

        Thread-safe method to update chat display with automatic scrolling.

        Args:
            text: The text message to append to the chat

        Returns:
            None
        """
        if hasattr(self, 'chat_display'):
            self.chat_display.append(text)
            # Optional: Scroll to bottom
            cursor = self.chat_display.textCursor()
            cursor.movePosition(cursor.End)
            self.chat_display.setTextCursor(cursor)

    def replace_last_chat_message(self, old_text, new_text):
        """
        Safely replaces the last message in the chat display from any thread.

        This method finds and replaces the last message matching old_text with new_text,
        typically used for updating status messages like "[thinking...]" with the
        actual response.

        Args:
            old_text: The text to find and replace
            new_text: The replacement text

        Returns:
            None
        """
        if hasattr(self, 'chat_display'):
            current_text = self.chat_display.toPlainText()
            # Be careful with replacement logic, ensure it targets the correct
            # text
            if current_text.endswith(old_text):
                new_display_text = current_text[:-len(old_text)] + new_text
                self.chat_display.setPlainText(new_display_text)
                # Optional: Scroll to bottom
                cursor = self.chat_display.textCursor()
                cursor.movePosition(cursor.End)
                self.chat_display.setTextCursor(cursor)
            else:
                # Fallback if the expected last text isn't found
                self.append_chat_display(new_text)

    def handle_log_user_question(self, title, message):
        """
        Handles logging user questions received via signal.

        This method safely logs user interaction requests from worker threads
        instead of showing blocking dialogs.

        Args:
            title: The dialog title
            message: The dialog message content

        Returns:
            None
        """
        # Log the question instead of showing a blocking dialog from worker
        # thread
        log_msg = f"[User Interaction Needed] Title: {title}\nMessage: {message}"
        self.update_output.emit(log_message(log_msg))
        # You could potentially show a non-modal notification here instead

    def handle_set_keygen_name(self, text):
        """
        Handles setting the keygen product name via signal.

        Thread-safe method to update keygen product name.

        Args:
            text: The product name text

        Returns:
            None
        """
        if hasattr(self, 'keygen_input_name'):
            self.keygen_input_name.setPlainText(text)

    def handle_set_keygen_version(self, text):
        """
        Handles setting the keygen version via signal.

        Thread-safe method to update keygen version.

        Args:
            text: The product version

        Returns:
            None
        """
        if hasattr(self, 'keygen_input_version'):
            self.keygen_input_version.setPlainText(text)

    def handle_switch_tab(self, index):
        """Handles switching the main tab view via signal."""
        if hasattr(self, 'tabs'):
            self.tabs.setCurrentIndex(index)

    def handle_generate_key(self):
        """Handles triggering key generation via signal."""
        # Call the original generate_key method safely in the main thread
        self.generate_key()
    # --- End Thread-Safe GUI Update Slots ---

    def load_binary(self, path=None):
        """
        Load a binary file for analysis.

        Args:
            path: Optional path to the binary file. If None, a file dialog will be shown.

        Returns:
            bool: True if binary was loaded successfully, False otherwise
        """
        # If no path provided, show file dialog
        if not path:
            path, _ = QFileDialog.getOpenFileName(
                self,
                "Select Binary File",
                "",
                "All Files (*)"
            )

            if not path:
                self.update_output.emit(log_message("[Load] Operation cancelled"))
                return False

        # Check if file exists
        if not os.path.exists(path):
            self.update_output.emit(log_message(f"[Load] Error: File not found: {path}"))
            return False

        # Store binary path
        self.binary_path = path

        # Extract binary information
        self.extract_binary_info(path)

        # Add to recent files list
        if path not in self.recent_files:
            self.recent_files.insert(0, path)
            # Keep only the 10 most recent files
            self.recent_files = self.recent_files[:10]

        # Add activity to dashboard
        if hasattr(self, "dashboard_manager"):
            self.dashboard_manager.add_activity("load", f"Loaded binary: {os.path.basename(path)}")

        # Ensure dashboard UI is explicitly refreshed with binary info and dashboard tab is shown
        if hasattr(self, "binary_info"):
            self._refresh_and_show_dashboard()

        # Update UI
        self.update_output.emit(log_message(f"[Load] Loaded binary: {path}"))
        self.statusBar().showMessage(f"Loaded: {os.path.basename(path)}")

        # Reset analysis results
        if hasattr(self, "analyze_results"):
            self.analyze_results = []

        # Reset patches
        if hasattr(self, "patches"):
            self.patches = []

        # Update window title
        self.setWindowTitle(f"Intellicrack - {os.path.basename(path)}")

        return True

    def setup_dashboard_tab(self):
        """Sets up the Dashboard tab with enhanced statistics and UI."""
        # Create the dashboard_tab widget if it doesn't exist
        if not hasattr(self, 'dashboard_tab'):
            self.dashboard_tab = QWidget()

        dashboard_layout = QVBoxLayout(self.dashboard_tab)

        # Welcome header
        header_layout = QHBoxLayout()

        # Logo/icon
        logo_label = QLabel()
        logo_pixmap = QPixmap("assets/icon_preview.png").scaled(64, 64, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        logo_label.setPixmap(logo_pixmap)
        header_layout.addWidget(logo_label)

        # Welcome text
        welcome_layout = QVBoxLayout()
        welcome_label = QLabel("Welcome to Intellicrack")
        welcome_label.setStyleSheet("font-size: 24px; font-weight: bold;")
        welcome_layout.addWidget(welcome_label)

        version_label = QLabel("Version 2.0")
        version_label.setStyleSheet("font-size: 12px; color: #666;")
        welcome_layout.addWidget(version_label)

        header_layout.addLayout(welcome_layout)
        header_layout.addStretch()

        # Enhanced Quick Actions with dropdown menus for related functions
        quick_actions_layout = QVBoxLayout()
        quick_actions_label = QLabel("Quick Actions")
        quick_actions_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        quick_actions_layout.addWidget(quick_actions_label)

        # Primary action buttons (more prominent)
        primary_actions_layout = QHBoxLayout()

        load_button = QPushButton("Load Binary")
        load_button.setIcon(QIcon.fromTheme("document-open"))
        load_button.setMinimumHeight(40)
        load_button.setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white;")
        load_button.clicked.connect(self.load_binary)
        primary_actions_layout.addWidget(load_button)

        analyze_button = QPushButton("Analyze Binary")
        analyze_button.setIcon(QIcon.fromTheme("system-search"))
        analyze_button.setMinimumHeight(40)
        analyze_button.setStyleSheet("font-weight: bold; background-color: #2196F3; color: white;")
        analyze_button.clicked.connect(lambda: self.tabs.setCurrentIndex(self.tabs.indexOf(self.analysis_tab)))
        primary_actions_layout.addWidget(analyze_button)

        quick_actions_layout.addLayout(primary_actions_layout)

        # Dropdown menu for Analysis options
        analysis_group_box = QGroupBox("Analysis Options")
        analysis_group_box.setCheckable(True)
        analysis_group_box.setChecked(False)  # Collapsed by default
        analysis_group_layout = QVBoxLayout()

        analysis_dropdown = QComboBox()
        analysis_dropdown.addItems(["Basic Analysis", "Deep Analysis", "Memory Analysis",
                                   "Network Analysis", "Custom Analysis"])
        analysis_dropdown.setCurrentIndex(0)
        analysis_group_layout.addWidget(analysis_dropdown)

        run_selected_analysis_btn = QPushButton("Run Selected Analysis")
        run_selected_analysis_btn.clicked.connect(lambda: self.run_selected_analysis(analysis_dropdown.currentText()))
        analysis_group_layout.addWidget(run_selected_analysis_btn)

        analysis_group_box.setLayout(analysis_group_layout)
        quick_actions_layout.addWidget(analysis_group_box)

        # Dropdown menu for Patching options
        patching_group_box = QGroupBox("Patching Options")
        patching_group_box.setCheckable(True)
        patching_group_box.setChecked(False)  # Collapsed by default
        patching_group_layout = QVBoxLayout()

        patching_dropdown = QComboBox()
        patching_dropdown.addItems(["Auto Patch", "Targeted Patch", "Manual Patch",
                                    "Visual Patch Editor", "Patch Testing"])
        patching_dropdown.setCurrentIndex(0)
        patching_group_layout.addWidget(patching_dropdown)

        run_selected_patching_btn = QPushButton("Run Selected Patch Operation")
        run_selected_patching_btn.clicked.connect(lambda: self.run_selected_patching(patching_dropdown.currentText()))
        patching_group_layout.addWidget(run_selected_patching_btn)

        patching_group_box.setLayout(patching_group_layout)
        quick_actions_layout.addWidget(patching_group_box)

        header_layout.addLayout(quick_actions_layout)

        dashboard_layout.addLayout(header_layout)

        # Main content - split into two columns
        content_layout = QHBoxLayout()

        # Left column - Statistics
        stats_layout = QVBoxLayout()

        # Binary info
        binary_group = QGroupBox("Binary Information")
        binary_layout = QVBoxLayout()
        binary_group.setLayout(binary_layout)

        # Binary Icon and Name Labels
        binary_icon_label = QLabel()
        binary_icon_label.setObjectName("dashboard_binary_icon_label") # Assign object name
        binary_icon_label.setFixedSize(64, 64)
        binary_icon_label.setAlignment(Qt.AlignCenter)
        binary_icon_label.setText("Icon") # Placeholder text
        binary_layout.addWidget(binary_icon_label)

        binary_name_label = QLabel("No binary loaded")
        binary_name_label.setObjectName("dashboard_binary_name_label") # Assign object name
        binary_name_label.setWordWrap(True)
        binary_name_label.setTextFormat(Qt.RichText)
        binary_layout.addWidget(binary_name_label)

        # Initial update (will be refreshed when binary is loaded)
        # self._update_dashboard_with_binary_info(self.binary_info if hasattr(self, 'binary_info') else None)

        stats_layout.addWidget(binary_group)

        # Patch statistics
        patch_group = QGroupBox("Patch Statistics")
        patch_layout = QVBoxLayout()
        patch_group.setLayout(patch_layout)

        # Ensure stats are updated
        if not hasattr(self, 'dashboard_manager') or not hasattr(self.dashboard_manager, 'stats'):
            self.dashboard_manager.update_stats()

        # Create a default stats structure if not available
        if 'patches' not in self.dashboard_manager.stats:
            self.dashboard_manager.stats['patches'] = {
                'count': 0,
                'applied': 0,
                'types': {}
            }

        patch_info = f"""
        <b>Total Patches:</b> {self.dashboard_manager.stats['patches']['count']}<br>
        <b>Applied Patches:</b> {self.dashboard_manager.stats['patches']['applied']}
        """

        if self.dashboard_manager.stats['patches']['types']:
            patch_info += "<br><b>Patch Types:</b><br>"
            for patch_type, count in self.dashboard_manager.stats['patches']['types'].items():
                patch_info += f"- {patch_type}: {count}<br>"

        patch_label = QLabel(patch_info)
        patch_label.setTextFormat(Qt.RichText)
        patch_layout.addWidget(patch_label)

        stats_layout.addWidget(patch_group)

        # License server status
        server_group = QGroupBox("License Server Status")
        server_layout = QVBoxLayout()
        server_group.setLayout(server_layout)

        # Create a default license server stats structure if not available
        if 'license_server' not in self.dashboard_manager.stats:
            self.dashboard_manager.stats['license_server'] = {
                'running': False,
                'port': 0
            }

        if self.dashboard_manager.stats['license_server']['running']:
            server_info = f"""
            <b>Status:</b> <span style="color: green;">Running</span><br>
            <b>Port:</b> {self.dashboard_manager.stats['license_server']['port']}
            """
        else:
            server_info = """
            <b>Status:</b> <span style="color: red;">Stopped</span>
            """

        server_label = QLabel(server_info)
        server_label.setTextFormat(Qt.RichText)
        server_layout.addWidget(server_label)

        # Add server control buttons
        server_buttons_layout = QHBoxLayout()

        start_server_button = QPushButton("Start Server")
        start_server_button.clicked.connect(lambda: run_network_license_server(self))
        server_buttons_layout.addWidget(start_server_button)

        stop_server_button = QPushButton("Stop Server")
        stop_server_button.clicked.connect(lambda: run_network_license_server(self) if hasattr(self, "license_server_instance") and self.license_server_instance else None)
        server_buttons_layout.addWidget(stop_server_button)

        server_layout.addLayout(server_buttons_layout)

        stats_layout.addWidget(server_group)

        # Advanced Analysis Features
        advanced_group = QGroupBox("Advanced Analysis Features")
        advanced_layout = QVBoxLayout()
        advanced_group.setLayout(advanced_layout)

        # Get advanced analysis stats
        advanced_stats = self.dashboard_manager.get_stats()["advanced_analysis"]
        active_count = advanced_stats["active_count"]

        advanced_info = f"""
        <b>Available Features:</b> {active_count} active<br>
        - Incremental Analysis: <span style="color: {'green' if advanced_stats['incremental_analysis'] else 'gray'}">{'Active' if advanced_stats['incremental_analysis'] else 'Inactive'}</span><br>
        - Memory Optimized Analysis: <span style="color: {'green' if advanced_stats['memory_optimized'] else 'gray'}">{'Active' if advanced_stats['memory_optimized'] else 'Inactive'}</span><br>
        - Taint Analysis: <span style="color: {'green' if advanced_stats['taint_analysis'] else 'gray'}">{'Active' if advanced_stats['taint_analysis'] else 'Inactive'}</span><br>
        - Symbolic Execution: <span style="color: {'green' if advanced_stats['symbolic_execution'] else 'gray'}">{'Active' if advanced_stats['symbolic_execution'] else 'Inactive'}</span><br>
        - Concolic Execution: <span style="color: {'green' if advanced_stats['concolic_execution'] else 'gray'}">{'Active' if advanced_stats['concolic_execution'] else 'Inactive'}</span><br>
        - ROP Chain Generator: <span style="color: {'green' if advanced_stats['rop_chain_generator'] else 'gray'}">{'Active' if advanced_stats['rop_chain_generator'] else 'Inactive'}</span><br>
        - Distributed Processing: <span style="color: {'green' if advanced_stats['distributed_processing'] else 'gray'}">{'Active' if advanced_stats['distributed_processing'] else 'Inactive'}</span><br>
        - GPU Acceleration: <span style="color: {'green' if advanced_stats['gpu_acceleration'] else 'gray'}">{'Active' if advanced_stats['gpu_acceleration'] else 'Inactive'}</span>
        """

        # Use QTextEdit instead of QLabel to enable scrolling
        advanced_text = QTextEdit()
        advanced_text.setHtml(advanced_info)
        advanced_text.setReadOnly(True)
        advanced_text.setMaximumHeight(150)  # Limit height but allow scrolling
        advanced_text.setFrameStyle(QFrame.NoFrame)  # Remove border to match label style
        advanced_text.setStyleSheet("background-color: transparent;")  # Transparent background
        advanced_layout.addWidget(advanced_text)

        # Add advanced analysis buttons
        advanced_buttons_layout = QHBoxLayout()

        advanced_analysis_button = QPushButton("Run Advanced Analysis")
        advanced_analysis_button.clicked.connect(lambda: self.tabs.setCurrentIndex(self.tabs.indexOf(self.analysis_tab)))
        advanced_buttons_layout.addWidget(advanced_analysis_button)

        generate_report_button = QPushButton("Generate PDF Report")
        generate_report_button.clicked.connect(partial(run_pdf_report_generator, self))
        advanced_buttons_layout.addWidget(generate_report_button)

        advanced_layout.addLayout(advanced_buttons_layout)

        stats_layout.addWidget(advanced_group)

        # Add stats layout to content
        content_layout.addLayout(stats_layout)

        # Right column - Recent activities
        activities_layout = QVBoxLayout()

        activities_group = QGroupBox("Recent Activities")
        activities_inner_layout = QVBoxLayout()
        activities_group.setLayout(activities_inner_layout)

        activities = self.dashboard_manager.get_recent_activities()

        if activities:
            activities_table = QTableWidget()
            activities_table.setColumnCount(3)
            activities_table.setHorizontalHeaderLabels(["Time", "Type", "Description"])
            activities_table.setRowCount(min(10, len(activities)))
            activities_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)

            for i, activity in enumerate(activities[:10]):  # Show up to 10 activities
                activities_table.setItem(i, 0, QTableWidgetItem(activity["timestamp"]))
                activities_table.setItem(i, 1, QTableWidgetItem(activity["type"]))
                activities_table.setItem(i, 2, QTableWidgetItem(activity["description"]))

            activities_inner_layout.addWidget(activities_table)
        else:
            no_activities_label = QLabel("No recent activities")
            activities_inner_layout.addWidget(no_activities_label)

        activities_layout.addWidget(activities_group)

        # Recent files
        recent_files_group = QGroupBox("Recent Files")
        recent_files_layout = QVBoxLayout()
        recent_files_group.setLayout(recent_files_layout)

        # Add recent files
        if hasattr(self, "recent_files") and self.recent_files:
            for file_path in self.recent_files[:5]:  # Show up to 5 recent files
                file_button = QPushButton(os.path.basename(file_path))
                file_button.setToolTip(file_path)
                file_button.clicked.connect(lambda checked, path=file_path: self.load_binary(path))
                recent_files_layout.addWidget(file_button)
        else:
            no_recent_label = QLabel("No recent files")
            recent_files_layout.addWidget(no_recent_label)

        activities_layout.addWidget(recent_files_group)

        # Add activities layout to content
        content_layout.addLayout(activities_layout)

        # Add content layout to dashboard
        dashboard_layout.addLayout(content_layout)

        # Add refresh button - Connect to update method
        refresh_button = QPushButton("Refresh Dashboard")
        refresh_button.clicked.connect(lambda: self._refresh_and_show_dashboard()) # Call new method that updates and shows dashboard
        dashboard_layout.addWidget(refresh_button)

    def setup_analysis_tab(self):
        """Sets up the Analysis tab with improved organization."""
        # Create the analysis_tab widget if it doesn't exist
        if not hasattr(self, 'analysis_tab'):
            self.analysis_tab = QWidget()

        layout = QVBoxLayout()

        # Use a splitter for resizable sections
        analyze_splitter = QSplitter(Qt.Vertical)

        # Program selection group
        program_group = QGroupBox("Program Selection")
        program_layout = QVBoxLayout()

        file_button_layout = QHBoxLayout()

        self.select_btn = QPushButton("Select a Program")
        self.select_btn.clicked.connect(self.select_program)
        file_button_layout.addWidget(self.select_btn)

        self.remove_btn = QPushButton("Remove Program")
        self.remove_btn.clicked.connect(self.remove_program)
        file_button_layout.addWidget(self.remove_btn)

        program_layout.addLayout(file_button_layout)

        # Program details frame
        self.program_frame = QFrame()
        self.program_frame.setFrameShape(QFrame.StyledPanel)
        self.program_layout = QHBoxLayout()

        self.program_icon = QLabel()
        self.program_icon.setFixedSize(64, 64)
        self.program_layout.addWidget(self.program_icon)

        self.program_info = QLabel("No program selected")
        self.program_layout.addWidget(self.program_info, 1)

        self.program_frame.setLayout(self.program_layout)
        program_layout.addWidget(self.program_frame)

        program_group.setLayout(program_layout)

        # Analysis Options Group with improved visual organization
        analysis_group = QGroupBox("Analysis Options")
        analysis_group.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #3498db; border-radius: 5px; margin-top: 1ex; } "
                                   "QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding: 0 5px; }")
        analysis_layout = QVBoxLayout()

        # Organize options in categories with expandable sections
        # Patching Options (Expandable)
        patching_options = QGroupBox("Patching Options")
        patching_options.setCheckable(True)
        patching_options.setChecked(True)  # Expanded by default
        patching_layout = QGridLayout()

        # Use a grid layout for better organization - 2 columns, multiple rows
        self.stealth_checkbox = QCheckBox("Enable Stealth Patching")
        self.stealth_checkbox.setToolTip("Make patches harder to detect")
        patching_layout.addWidget(self.stealth_checkbox, 0, 0)

        self.auto_patch_checkbox = QCheckBox("Auto Patch (Recommended)")
        self.auto_patch_checkbox.setStyleSheet("font-weight: bold; color: #27ae60;")
        self.auto_patch_checkbox.setToolTip("Automatically identify and apply optimal patches")
        self.auto_patch_checkbox.setChecked(True)
        patching_layout.addWidget(self.auto_patch_checkbox, 0, 1)

        self.heuristic_patch_checkbox = QCheckBox("Enable Heuristic Patching")
        self.heuristic_patch_checkbox.setToolTip("Use advanced algorithms to find complex protections")
        patching_layout.addWidget(self.heuristic_patch_checkbox, 1, 0)

        self.backup_checkbox = QCheckBox("Create Backups Before Patching")
        self.backup_checkbox.setChecked(True)
        self.backup_checkbox.setToolTip("Always keep original copies of modified files")
        patching_layout.addWidget(self.backup_checkbox, 1, 1)

        patching_options.setLayout(patching_layout)
        analysis_layout.addWidget(patching_options)

        # Runtime Options (Expandable)
        runtime_options = QGroupBox("Runtime Options")
        runtime_options.setCheckable(True)
        runtime_options.setChecked(False)  # Collapsed by default
        runtime_layout = QGridLayout()

        self.frida_checkbox = QCheckBox("Enable Frida Runtime Hooking")
        self.frida_checkbox.setToolTip("Use Frida for dynamic instrumentation")
        runtime_layout.addWidget(self.frida_checkbox, 0, 0)

        self.qiling_checkbox = QCheckBox("Enable Qiling Emulation Layer")
        self.qiling_checkbox.setToolTip("Use Qiling framework for emulation")
        runtime_layout.addWidget(self.qiling_checkbox, 0, 1)

        self.api_monitor_checkbox = QCheckBox("API Call Monitoring")
        self.api_monitor_checkbox.setToolTip("Monitor critical API calls during execution")
        runtime_layout.addWidget(self.api_monitor_checkbox, 1, 0)

        self.syscall_trace_checkbox = QCheckBox("System Call Tracing")
        self.syscall_trace_checkbox.setToolTip("Trace all system calls for deeper analysis")
        runtime_layout.addWidget(self.syscall_trace_checkbox, 1, 1)

        runtime_options.setLayout(runtime_layout)
        analysis_layout.addWidget(runtime_options)

        # Advanced Options (Expandable)
        advanced_options = QGroupBox("Advanced Options")
        advanced_options.setCheckable(True)
        advanced_options.setChecked(False)  # Collapsed by default
        advanced_layout = QVBoxLayout()

        # Create dropdown for analysis engine selection
        engine_layout = QHBoxLayout()
        engine_layout.addWidget(QLabel("Analysis Engine:"))
        self.engine_combo = QComboBox()
        self.engine_combo.addItems(["Standard", "Deep", "Hybrid", "Custom"])
        self.engine_combo.setCurrentIndex(0)
        self.engine_combo.setToolTip("Select the analysis engine to use")
        engine_layout.addWidget(self.engine_combo)
        advanced_layout.addLayout(engine_layout)

        # Create checkboxes for advanced features
        features_layout = QGridLayout()

        self.symbolic_checkbox = QCheckBox("Symbolic Execution")
        self.symbolic_checkbox.setToolTip("Use symbolic execution techniques")
        features_layout.addWidget(self.symbolic_checkbox, 0, 0)

        self.gpu_checkbox = QCheckBox("GPU Acceleration")
        self.gpu_checkbox.setToolTip("Use GPU for faster analysis")
        features_layout.addWidget(self.gpu_checkbox, 0, 1)

        self.distributed_checkbox = QCheckBox("Distributed Analysis")
        self.distributed_checkbox.setToolTip("Use multiple cores/machines")
        features_layout.addWidget(self.distributed_checkbox, 1, 0)

        self.ml_checkbox = QCheckBox("ML-assisted Analysis")
        self.ml_checkbox.setToolTip("Use machine learning models")
        features_layout.addWidget(self.ml_checkbox, 1, 1)

        advanced_layout.addLayout(features_layout)
        advanced_options.setLayout(advanced_layout)
        analysis_layout.addWidget(advanced_options)

        # Analysis depth slider
        depth_layout = QHBoxLayout()
        depth_layout.addWidget(QLabel("Analysis Depth:"))

        self.analysis_depth_slider = QSlider(Qt.Horizontal)
        self.analysis_depth_slider.setMinimum(10)
        self.analysis_depth_slider.setMaximum(100)
        self.analysis_depth_slider.setValue(50)
        self.analysis_depth_slider.setTickPosition(QSlider.TicksBelow)
        self.analysis_depth_slider.setTickInterval(10)
        depth_layout.addWidget(self.analysis_depth_slider)

        self.depth_value_label = QLabel("50")
        depth_layout.addWidget(self.depth_value_label)

        # Connect slider to label
        self.analysis_depth_slider.valueChanged.connect(
            lambda value: self.depth_value_label.setText(str(value)))

        analysis_layout.addLayout(depth_layout)

        # Configuration buttons
        config_buttons = QHBoxLayout()

        save_config_btn = QPushButton("Save Analysis Config")
        save_config_btn.setToolTip("Save current analysis options to a configuration file")
        save_config_btn.clicked.connect(self.save_analysis_config)
        config_buttons.addWidget(save_config_btn)

        load_config_btn = QPushButton("Load Analysis Config")
        load_config_btn.setToolTip("Load analysis options from a configuration file")
        load_config_btn.clicked.connect(self.load_analysis_config)
        config_buttons.addWidget(load_config_btn)

        # Add a dropdown for preset configurations
        self.config_preset_combo = QComboBox()
        self.config_preset_combo.addItems([
            "Default Configuration",
            "Maximum Security",
            "Performance Optimized",
            "Deep Analysis",
            "Basic Analysis"
        ])
        self.config_preset_combo.currentTextChanged.connect(self.apply_config_preset)
        config_buttons.addWidget(self.config_preset_combo)

        analysis_layout.addLayout(config_buttons)

        # Reorganized button grid with visual hierarchy
        button_container = QVBoxLayout()

        # Style common to all primary action buttons
        primary_btn_style = "QPushButton { font-weight: bold; background-color: #2196F3; color: white; min-height: 40px; }"

        # Primary Actions Group (most important actions)
        primary_actions = QGroupBox("Primary Actions")
        primary_actions.setStyleSheet("QGroupBox { font-weight: bold; }")
