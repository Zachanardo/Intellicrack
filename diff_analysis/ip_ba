            f"Self-Healing Code: {'Yes' if healing_found else 'No'}")
        app.update_analysis_results.emit(
            f"Self-Healing Code: {'Detected' if healing_found else 'Not Detected'}\n")
        obfuscation_results = detect_obfuscation(app)
        protection_results_text.extend(obfuscation_results)
        obfuscation_found = any(
            "OBFUSCATION ASSESSMENT: HIGH CONFIDENCE" in line for line in obfuscation_results)
        context.append(
            f"Heavy Obfuscation: {
                'Yes' if obfuscation_found else 'No'}")
        app.update_analysis_results.emit(
            f"Heavy Obfuscation: {
                'Detected' if obfuscation_found else 'Not Detected'}\n")

        # 1b: Advanced Vulnerability Scan
        app.update_output.emit(
            log_message("[AI Patching] Running advanced vulnerability scan..."))
        app.update_analysis_results.emit(
            "\n--- Advanced Vulnerability Scan ---\n")
        vulnerabilities = []
        exploit_strategies = []
        vulnerability_summary = "Advanced scan not run or no vulnerabilities found."
        try:
            vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(
                app.binary_path)
            if vulnerabilities:
                vulnerability_summary = f"Found {
                    len(vulnerabilities)} vulnerabilities (Types: {
                    ', '.join(
                        list(
                            set(
                                v['type'] for v in vulnerabilities)))})"
                app.update_analysis_results.emit(vulnerability_summary + "\n")
                for vuln in vulnerabilities[:3]:
                    app.update_analysis_results.emit(
                        f" - Type: {vuln['type']}, Risk: {vuln.get('risk', 'N/A')}\n")
                try:
                    exploit_strategies = AdvancedVulnerabilityEngine.generate_exploit_strategy(
                        vulnerabilities)
                    app.update_output.emit(
                        log_message(
                            f"[AI Patching] Generated {
                                len(exploit_strategies)} exploit strategies."))
                    app.update_analysis_results.emit(
                        f"\n--- Potential Exploit Strategies ---\n")
                    for strat in exploit_strategies[:3]:
                        app.update_analysis_results.emit(
                            f" - Strategy: {strat.get('strategy')}, Technique: {strat.get('technique')}\n")
                    context.append("\n--- Potential Exploit Strategies ---")
                    for strat in exploit_strategies[:3]:
                        context.append(
                            f"- Strategy: {strat.get('strategy')}, Technique: {strat.get('technique')}")
                except Exception as e_strat:
                    app.update_output.emit(
                        log_message(
                            f"[AI Patching] Error generating exploit strategies: {e_strat}"))
            else:
                app.update_analysis_results.emit(vulnerability_summary + "\n")
            context.append(
                f"\n--- Vulnerability Summary ---\n{vulnerability_summary}")
        except Exception as e_vuln:
            app.update_output.emit(
                log_message(
                    f"[AI Patching] Advanced vulnerability scan error: {e_vuln}"))
            context.append(
                "\n--- Vulnerability Summary ---\nError during vulnerability scan.")

        # 1c: Advanced Dynamic Analysis (for context)
        app.update_output.emit(log_message(
            "[AI Patching] Running advanced dynamic analysis (for context)..."))
        app.update_analysis_results.emit(
            "\n--- Advanced Dynamic Analysis (Context) ---\n")
        dynamic_analysis_summary = "Dynamic analysis skipped (analyzer not available)."
        try:
            if hasattr(app, 'dynamic_analyzer') and app.dynamic_analyzer:
                dynamic_results = app.dynamic_analyzer.run_comprehensive_analysis()
                frida_msgs = dynamic_results.get(
                    'frida_runtime_analysis', {}).get(
                    'messages', [])
                process_behavior = dynamic_results.get(
                    'process_behavior_analysis', {})
                connections = process_behavior.get('connections', [])
                summary_parts = []
                if frida_msgs:
                    summary_parts.append(f"{len(frida_msgs)} Frida messages")
                if connections:
                    summary_parts.append(
                        f"{len(connections)} network connections")
                if summary_parts:
                    dynamic_analysis_summary = ", ".join(summary_parts)
                else:
                    dynamic_analysis_summary = "No significant runtime events detected."
                app.update_output.emit(
                    log_message(
                        f"[Dynamic Analysis] Context Summary: {dynamic_analysis_summary}"))
                app.update_analysis_results.emit(
                    dynamic_analysis_summary + "\n")
            else:
                app.update_analysis_results.emit(
                    dynamic_analysis_summary + "\n")
            context.append(
                f"\n--- Dynamic Analysis Summary ---\n{dynamic_analysis_summary}")
        except Exception as e_dyn_ctx:
            err_msg = f"[AI Patching] Error during dynamic analysis context run: {e_dyn_ctx}"
            app.update_output.emit(log_message(err_msg))
            app.update_analysis_results.emit(err_msg + "\n")
            context.append(
                f"\n--- Dynamic Analysis Summary ---\nError during dynamic analysis.")

        # 1d: ML Vulnerability Prediction
        app.update_output.emit(
            log_message("[AI Patching] Running ML vulnerability prediction..."))
        app.update_analysis_results.emit(
            "\n--- ML Vulnerability Predictions ---\n")
        ml_prediction_summary = "ML prediction skipped (predictor not available/trained)."
        ml_predictions = []
        try:
            if hasattr(
                    app,
                    'ml_predictor') and app.ml_predictor and app.ml_predictor.model:
                ml_predictions = app.ml_predictor.predict_vulnerabilities(
                    app.binary_path)
                if ml_predictions:
                    ml_prediction_summary = f"ML predicts potential: {
                        ', '.join(
                            p['type'] for p in ml_predictions)}"
                    app.update_output.emit(
                        log_message(
                            f"[ML Predict] {ml_prediction_summary}"))
                    app.update_analysis_results.emit(
                        ml_prediction_summary + "\n")
                    for pred in ml_predictions:
                        pred_str = f"  Type: {
                            pred['type']}, Probability: {
                            pred['probability']:.2f}"
                        app.update_analysis_results.emit(pred_str + "\n")
                else:
                    ml_prediction_summary = "ML predictor returned no specific predictions."
                    app.update_output.emit(log_message(ml_prediction_summary))
                    app.update_analysis_results.emit(
                        ml_prediction_summary + "\n")
            else:
                app.update_analysis_results.emit(ml_prediction_summary + "\n")
            context.append(
                f"\n--- ML Prediction Summary ---\n{ml_prediction_summary}")
        except Exception as e_ml:
            err_msg = f"[AI Patching] Error running MLVulnerabilityPredictor: {e_ml}"
            app.update_output.emit(log_message(err_msg))
            app.update_analysis_results.emit(err_msg + "\n")
            context.append(
                f"\n--- ML Prediction Summary ---\nError during ML prediction.")

        # --- Step 2: Determine Approach ---
        app.update_output.emit(
            log_message("[AI Patching] Determining optimal approach..."))
        heavy_protection = commercial_found or healing_found or (
            integrity_found and obfuscation_found)
        app.update_output.emit(
            log_message(
                f"Overall Protection Level: {
                    'Heavy' if heavy_protection else 'Moderate/Low'}"))
        app.update_analysis_results.emit(
            f"\nOverall Protection Level: {
                'Heavy' if heavy_protection else 'Moderate/Low'}\n")

        # --- Step 3: Execute Strategy ---
        if heavy_protection:
            app.update_output.emit(log_message(
                "[AI Patching] Detected heavy protection. Setting up memory patching environment."))
            app.update_analysis_results.emit(
                "\n--- Action: Memory Patching Setup ---\nDue to heavy protection, memory patching is recommended.\n")
            setup_memory_patching(app)
        else:
            app.update_output.emit(log_message(
                "[AI Patching] Using standard patching approach with AI assistance."))
            app.update_analysis_results.emit(
                "\n--- Action: AI-Assisted Standard Patching ---\n")

            # 3b-1: Deep License Analysis (for standard patching context)
            app.update_output.emit(log_message(
                "[AI Patching] Running deep license analysis (for standard patching)..."))
            license_results = enhanced_deep_license_analysis(app.binary_path)
            if license_results:
                app.update_output.emit(
                    log_message(
                        f"[AI Patching] Found {
                            len(license_results)} potential license code regions."))
                app.update_analysis_results.emit(
                    f"Found {len(license_results)} license code regions (Deep Scan):\n")
                context.append(
                    "\n--- Deep License Regions (for AI patching) ---")
                for i, region in enumerate(license_results[:3]):
                    context.append(f"Region {i + 1} at 0x{region['start']:X}:")
                    context.append(
                        f"  Keywords: {
                            ', '.join(
                                region.get(
                                    'keywords',
                                    []))}")
                    if 'instructions' in region and region['instructions']:
                        context.append("  Instructions (Preview):")
                        for inst in region['instructions'][:5]:
                            context.append(f"    {inst}")
                    app.update_analysis_results.emit(
                        f" - Region {
                            i +
                            1}: 0x{
                            region['start']:X}, Keywords: {
                            ', '.join(
                                region.get(
                                    'keywords',
                                    []))}\n")
            else:
                app.update_output.emit(log_message(
                    "[AI Patching] No specific license code regions found by deep analysis."))
                app.update_analysis_results.emit(
                    "No license regions found by deep analysis.\n")
                context.append(
                    "\n--- Deep License Regions (for AI patching) ---\nNone found.")

            # 3b-2: Consult AI
            app.update_output.emit(
                log_message("[AI Patching] Consulting AI for optimal patch strategy..."))
            model = load_ai_model(app)
            if not model:
                app.update_output.emit(
                    log_message("[AI Patching] Error: Failed to load AI model."))
                app.analyze_status.setText("Error: Failed to load AI model")
                return

            ai_prompt = (
                "<s>[INST] <<SYS>>\n"
                # Added ML predictions to context description
                "You are Intellicrack's AI patching engine. Analyze the provided context (protections, vulnerabilities, dynamic behavior, strategies, license regions, ML predictions) "
                "and generate precise patch instructions (address, hex bytes, explanation) OR suggest a dynamic hooking strategy (using Frida) OR suggest a payload injection approach to bypass the license protection.\n"
                "Prioritize static patches (Address: 0x... NewBytes: ...) if feasible and safe (e.g., NOPping jumps, simple function returns). "
                "If static patching is too risky (due to protectors, self-healing, obfuscation), suggest a dynamic approach (Frida hooks, payload generation).\n"
                "Format static patches as: Address: 0x<address> NewBytes: <hex bytes> // <explanation>\n"
                "Format Frida hooks as: Hook: <API Name> Action: <Modify return value / Block call / etc.>\n"
                "Format Payload suggestion as: PayloadStrategy: <strategy_name e.g., license_bypass> Target: <Target Function/Offset>\n"
                "<<SYS>>\n\n"
                # Use the FULL context
                f"--- Analysis Context ---\n{''.join(context)}\n\n"
                "Generate the most effective and safest bypass plan based on the context.\n"
                "[/INST]"
            )

            response = model(
                ai_prompt,
                max_tokens=2048,
                temperature=0.7,
                top_p=0.95)
            ai_strategy_response = response["choices"][0]["text"].strip()

            app.update_output.emit(
                log_message("[AI Patching] Received AI strategy response."))
            app.update_analysis_results.emit("\n=== AI Bypass Strategy ===\n")
            app.update_analysis_results.emit(ai_strategy_response + "\n")

            # 3b-3: Parse and Execute AI Plan
            app.update_output.emit(
                log_message("[Patching] Parsing and executing AI plan..."))
            static_patches = parse_patch_instructions(ai_strategy_response)
            payload_suggestions = []
            hook_suggestions = []
            payload_match = re.search(
                r"PayloadStrategy:\s*(\w+)\s*Target:\s*(.*)",
                ai_strategy_response,
                re.IGNORECASE)
            if payload_match:
                payload_suggestions.append({
                    "PayloadStrategy": payload_match.group(1).strip(),
                    "Target": payload_match.group(2).strip()
                })
            # Add parsing for Hook: suggestions if needed

            action_taken = False
            if static_patches:
                action_taken = True
                app.update_output.emit(
                    log_message(
                        f"[AI Patching] AI suggested {
                            len(static_patches)} static patches. Applying..."))
                apply_parsed_patch_instructions_with_validation(
                    app, static_patches)
                app.potential_patches = static_patches

            elif payload_suggestions:
                action_taken = True
                app.update_output.emit(
                    log_message(
                        f"[AI Patching] AI suggested payload injection. Generating payload..."))
                payload_generated = False
                for suggestion in payload_suggestions:
                    strategy_name = suggestion.get("PayloadStrategy")
                    target_info = suggestion.get("Target")
                    matched_strategy = next(
                        (s for s in exploit_strategies if s.get('strategy') == strategy_name), None)
                    if not matched_strategy:
                        matched_strategy = {'strategy': strategy_name}
                    try:
                        payload_bytes = AdvancedPayloadGenerator.generate_license_bypass_payload(
                            matched_strategy)
                        if payload_bytes:
                            app.update_output.emit(
                                log_message(
                                    f"[AI Patching] Generated payload ({
                                        len(payload_bytes)} bytes) for strategy '{strategy_name}'"))
                            app.update_analysis_results.emit(
                                f"\n--- Generated Payload ---\nStrategy: {strategy_name}\nTarget: {target_info}\nBytes: {
                                    payload_bytes.hex().upper()}\n")
                            app.update_analysis_results.emit(
                                "Note: Automatic payload injection/testing requires further AdvancedDynamicAnalyzer implementation or manual steps.\n")
                            payload_generated = True
                            break
                        else:
                            app.update_output.emit(
                                log_message(
                                    f"[AI Patching] Failed to generate payload for strategy '{strategy_name}'"))
                    except Exception as e_payload:
                        app.update_output.emit(
                            log_message(
                                f"[AI Patching] Error during payload generation: {e_payload}"))
                if not payload_generated:
                    app.update_analysis_results.emit(
                        "Payload generation failed.\n")

            elif hook_suggestions:
                action_taken = True
                app.update_output.emit(
                    log_message(
                        f"[AI Patching] AI suggested {
                            len(hook_suggestions)} Frida hooks. Manual action needed."))
                app.update_analysis_results.emit(
                    "\n--- Frida Hook Suggestions ---\n")
                app.update_analysis_results.emit(
                    "AI recommended dynamic hooking. Use the Plugins tab or manually create a Frida script based on these suggestions:\n")
                for sugg in hook_suggestions:
                    app.update_analysis_results.emit(
                        f"- Hook: {sugg.get('Hook', 'N/A')}, Action: {sugg.get('Action', 'N/A')}\n")

            else:
                app.update_output.emit(log_message(
                    "[AI Patching] No specific actionable instructions parsed from AI response. Review strategy."))
                app.update_analysis_results.emit(
                    "AI strategy requires manual interpretation or refinement.\n")

        # --- Final Status Update ---
        if action_taken:
            app.update_output.emit(
                log_message("[AI Patching] Autonomous AI patching process complete - Actions taken."))
            app.analyze_status.setText("AI patching complete - Review applied changes")

            # Record successful patch operation in application history
            if not hasattr(app, 'patch_history'):
                app.patch_history = []

            app.patch_history.append({
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'binary': os.path.basename(app.binary_path),
                'action_type': 'static_patch' if static_patches else
                              'payload_injection' if payload_suggestions else
                              'hook_suggestion' if hook_suggestions else 'unknown'
            })
        else:
            app.update_output.emit(
                log_message("[AI Patching] Autonomous AI patching process complete - No actions taken."))
            app.analyze_status.setText("AI patching complete - Manual review needed")

    except Exception as e:
        # Global error handling for the thread
        app.update_output.emit(log_message(f"[AI Patching] Error: {e}"))
        app.update_output.emit(log_message(traceback.format_exc()))
        app.analyze_status.setText(f"Error: {str(e)}")


def run_advanced_ghidra_analysis(app):
    """
    Runs the AdvancedAnalysis.java Ghidra script on the current binary.

    Args:
        app: Application instance
    """
    if not app.binary_path:
        app.update_output.emit(log_message(
            "[Ghidra Analysis] No binary selected."))
        return

    app.update_output.emit(log_message(
        "[Ghidra Analysis] Starting advanced analysis with Ghidra..."))
    app.analyze_status.setText("Running Ghidra analysis...")

    # Get Ghidra path from config
    ghidra_path = CONFIG.get(
        "ghidra_path", r"C:\Program Files\Ghidra\ghidraRun.bat")

    app.update_output.emit(log_message(f"[Ghidra Analysis] Using Ghidra path: {ghidra_path}"))

    if not os.path.exists(ghidra_path):
        app.update_output.emit(log_message(
            f"[Ghidra Analysis] ERROR: Ghidra not found at {ghidra_path}"))
        app.update_output.emit(log_message(
            "[Ghidra Analysis] Please configure the correct path in Settings"))

        # Check for Ghidra in common locations
        common_locations = [
            r"C:\Program Files\Ghidra",
            r"C:\Ghidra",
            r"C:\Program Files (x86)\Ghidra",
            r"C:\Users\Public\Ghidra",
            os.path.join(os.path.expanduser("~"), "Ghidra")
        ]

        found_locations = []
        for location in common_locations:
            if os.path.exists(location):
                app.update_output.emit(log_message(f"[Ghidra Analysis] Found potential Ghidra installation at: {location}"))
                found_locations.append(location)

                # Check for ghidraRun.bat
                run_file = os.path.join(location, "ghidraRun.bat")
                if os.path.exists(run_file):
                    app.update_output.emit(log_message(f"[Ghidra Analysis] Found ghidraRun.bat at: {run_file}"))
                    app.update_output.emit(log_message(f"[Ghidra Analysis] To fix this error, go to Settings tab and set Ghidra path to: {run_file}"))

        if not found_locations:
            app.update_output.emit(log_message("[Ghidra Analysis] Could not find Ghidra in common locations. Please install Ghidra or set the correct path manually."))

        return

    # Make sure script directory exists
    if not os.path.exists("ghidra_scripts"):
        os.makedirs("ghidra_scripts")

    # Copy AdvancedAnalysis.java to ghidra_scripts folder
    script_source = os.path.join(
        "plugins", "ghidra_scripts", "AdvancedAnalysis.java")
    script_destination = os.path.join(
        "ghidra_scripts", "AdvancedAnalysis.java")

    if not os.path.exists(script_source):
        # Create the script if it doesn't exist
        app.update_output.emit(log_message(
            "[Ghidra Analysis] Creating AdvancedAnalysis.java script..."))
        with open(script_source, "w", encoding="utf-8") as f:
            f.write("""
        import ghidra.app.script.GhidraScript;
        import ghidra.program.model.listing.*;
        import ghidra.program.model.symbol.*;
        import ghidra.program.model.pcode.*;
        import ghidra.program.model.data.*;
        import ghidra.program.util.*;
        import ghidra.program.model.block.*;
        import ghidra.program.model.address.*;
        import ghidra.program.model.lang.*;
        import ghidra.program.model.mem.*;

        import ghidra.util.task.*;
        import ghidra.util.json.*;

        import java.util.*;
        import java.io.*;

        public class AdvancedAnalysis extends GhidraScript {

            private Map<Long, GhidraFunction> functions = new HashMap<>();
            private Map<Long, GhidraInstruction> instructions = new HashMap<>();
            private Map<Long, List<Long>> callGraph = new HashMap<>();
            private Map<Long, List<Long>> dataFlow = new HashMap<>(); // Track data flow
            private List<Long> potentialLicenseChecks = new ArrayList<>();
            private AddressSetView memoryRegionsOfInterest = new AddressSet();
            private JsonObject analysisResults = new JsonObject(); // For structured output
            private Map<Long, Integer> functionComplexity = new HashMap<>(); // Function complexity
            private Map<Long, List<Long>> stringReferences = new HashMap<>(); // Map of string addresses to referencing function addresses
            private Map<Long, List<Long>> xrefsToFunctions = new HashMap<>(); // Function cross-references
            private Map<Long, List<Long>> xrefsToStrings = new HashMap<>(); // String cross-references
            private Map<Long, String> functionPseudoCode = new HashMap<>(); // Function pseudo-code

            private static final String[] LICENSE_KEYWORDS = {
                "licens", "registr", "activ", "serial", "key", "trial",
                "valid", "expir", "auth", "dongle", "hwid"
            };

            private static final String[] CRYPTO_APIS = {
                "Crypt", "Cipher", "Encrypt", "Decrypt", "Hash", "Sign", "Verify",
                "AES", "RSA", "SHA"
            };

            private static final String[] ANTI_DEBUG_APIS = {
                "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString",
                "NtQueryInformationProcess", "ZwQueryInformationProcess"
            };

            private static final String[] NETWORK_APIS = {
                "connect", "send", "recv", "HttpSendRequest", "InternetConnect", "WinHttpConnect"
            };

            @Override
            public void run() throws Exception {
                println("Starting Advanced License Analysis...");

                // Pass 1: Foundational Analysis
                analyzeFunctions();
                analyzeInstructions();
                analyzeStrings();
                buildCallGraph();
                analyzeDataFlow();
                calculateFunctionComplexity();
                analyzeFunctionCrossReferences();
                analyzeStringCrossReferences();

                // Pass 2: AI-Assisted Contextualization
                if (!monitor.isCancelled()) {
                    findPotentialLicenseChecks();
                    decompileFunctionsOfInterest();
                }

                // Pass 3: Targeted Patching Strategy
                if (!monitor.isCancelled()) {
                    generatePatchingStrategy();
                }

                // Output results in JSON format
                outputResults();

                println("Advanced License Analysis completed.");
            }

            private void analyzeFunctions() throws Exception {
                println("Analyzing functions...");
                JsonArray funcArray = new JsonArray();
                FunctionManager functionManager = currentProgram.getFunctionManager();
                FunctionIterator functionsIter = functionManager.getFunctions(true);

                while (functionsIter.hasNext() && !monitor.isCancelled()) {
                    Function func = functionsIter.next();
                    long addr = func.getEntryPoint().getOffset();
                    String signature = func.getSignature().toString();
                    String name = func.getName();

                    functions.put(addr, new GhidraFunction(name, addr, signature, func.getBody().getNumAddresses()));

                    JsonObject funcObj = new JsonObject();
                    funcObj.put("name", name);
                    funcObj.put("address", Long.toHexString(addr));
                    funcObj.put("signature", signature);
                    funcObj.put("size", func.getBody().getNumAddresses());
                    funcArray.add(funcObj);
                }

                analysisResults.put("functions", funcArray);
                println("Analyzed " + functions.size() + " functions.");
            }

            private void analyzeInstructions() throws Exception {
                println("Analyzing instructions...");
                JsonArray instrArray = new JsonArray();
                Listing listing = currentProgram.getListing();
                InstructionIterator instructionsIter = listing.getInstructions(true);

                while (instructionsIter.hasNext() && !monitor.isCancelled()) {
                    Instruction instr = instructionsIter.next();
                    long addr = instr.getAddress().getOffset();
                    String mnemonic = instr.getMnemonicString();
                    String operands = instr.getOperandRepresentationString();

                    instructions.put(addr, new GhidraInstruction(addr, mnemonic, operands));

                    JsonObject instrObj = new JsonObject();
                    instrObj.put("address", Long.toHexString(addr));
                    instrObj.put("mnemonic", mnemonic);
                    instrObj.put("operands", operands);
                    instrArray.add(instrObj);
                }

                analysisResults.put("instructions", instrArray);
                println("Analyzed " + instructions.size() + " instructions.");
            }

            private void analyzeStrings() throws Exception {
                println("Analyzing strings...");
                JsonArray stringArray = new JsonArray();
                stringReferences = new HashMap<>(); // Initialize string references
                xrefsToStrings = new HashMap<>(); // Initialize string cross-references

                SymbolTable symbolTable = currentProgram.getSymbolTable();
                SymbolIterator symbols = symbolTable.getSymbolIterator();

                while (symbols.hasNext() && !monitor.isCancelled()) {
                    Symbol symbol = symbols.next();
                    if (symbol.getSymbolType() == SymbolType.LABEL) {
                        String name = symbol.getName().toLowerCase();
                        for (String keyword : LICENSE_KEYWORDS) {
                            if (name.contains(keyword)) {
                                memoryRegionsOfInterest.add(symbol.getAddress());
                                JsonObject stringObj = new JsonObject();
                                stringObj.put("address", symbol.getAddress().toString());
                                stringObj.put("string", symbol.getName());
                                stringArray.add(stringObj);
                                println("Found license-related string: " + symbol.getName() + " at " + symbol.getAddress());

                                // Track functions referencing this string
                                List<Long> referencingFunctions = new ArrayList<>();
                                ReferenceIterator references = getReferencesTo(symbol.getAddress());
                                while (references.hasNext()) {
                                    Reference ref = references.next();
                                    Function func = getFunctionContaining(ref.getFromAddress());
                                    if (func != null) {
                                        referencingFunctions.add(func.getEntryPoint().getOffset());
                                    }
                                }
                                stringReferences.put(symbol.getAddress().getOffset(), referencingFunctions);

                                // Track strings referenced by this string
                                List<Long> referencedStringAddrs = new ArrayList<>();
                                ReferenceIterator refIter = getReferencesTo(symbol.getAddress());
                                while (refIter.hasNext()) {
                                    Reference ref = refIter.next();
                                    if (ref.getType() == RefType.DATA) { // Assuming string references are data references
                                        referencedStringAddrs.add(ref.getFromAddress().getOffset());
                                    }
                                }
                                xrefsToStrings.put(symbol.getAddress().getOffset(), referencedStringAddrs);

                                break;
                            }
                        }
                    }
                }
                analysisResults.put("strings", stringArray);
                analysisResults.put("stringReferences", stringReferences);
                analysisResults.put("xrefsToStrings", xrefsToStrings);
            }

            private void buildCallGraph() throws Exception {
                println("Building function call graph...");
                callGraph = new HashMap<>();

                for (GhidraFunction func : functions.values()) {
                    callGraph.put(func.address, new ArrayList<>());
                }

                for (GhidraFunction func : functions.values()) {
                    Function calledFunc = getFunctionAt(toAddr(func.address));
                    if (calledFunc != null) {
                        for (Reference ref : getReferencesTo(calledFunc.getEntryPoint())) {
                            if (ref.getType() == RefType.CALL || ref.getType() == RefType.UNCONDITIONAL_CALL) {
                                Function callingFunc = getFunctionContaining(ref.getFromAddress());
                                if (callingFunc != null) {
                                    callGraph.get(callingFunc.getEntryPoint().getOffset()).add(func.address);
                                }
                            }
                        }
                    }
                }
                analysisResults.put("callGraph", callGraph);
                println("Built function call graph.");
            }

            private void analyzeDataFlow() throws Exception {
                println("Analyzing data flow...");
                dataFlow = new HashMap<>();

                for (GhidraFunction func : functions.values()) {
                    dataFlow.put(func.address, new ArrayList<>());
                    Function currentFunction = getFunctionAt(toAddr(func.address));
                    if (currentFunction != null) {
                        InstructionIterator instructions = getInstructions(currentFunction.getBody(), true);
                        while (instructions.hasNext() && !monitor.isCancelled()) {
                            Instruction instr = instructions.next();
                            for (int i = 0; i < instr.getNumOperands(); i++) {
                                if (instr.getOperandType(i) == OperandType.REGISTER || instr.getOperandType(i) == OperandType.ADDRESS) {
                                    RegisterOrMemorySlot slot = instr.getRegisterOrMemorySlot(i);
                                    if (slot != null) {
                                        // Track data flow related to this register/memory slot
                                        // This is still a simplified example; real data flow analysis is very complex
                                        dataFlow.get(func.address).add(instr.getAddress().getOffset());
                                    }
                                }
                            }
                        }
                    }
                }
                analysisResults.put("dataFlow", dataFlow);
                println("Analyzed data flow.");
            }

            private void calculateFunctionComplexity() throws Exception {
                println("Calculating function complexity...");
                functionComplexity = new HashMap<>();

                for (GhidraFunction func : functions.values()) {
                    Function currentFunction = getFunctionAt(toAddr(func.address));
                    if (currentFunction != null) {
                        int complexity = 0;
                        // Example: More sophisticated complexity metrics
                        complexity += currentFunction.getBody().getNumAddresses();
                        complexity += currentFunction.getInstructionIterator().hasNext() ? 10 : 0; // Check if it has instructions
                        complexity += currentFunction.getBasicBlocks().size() * 5; // Number of basic blocks
                        complexity += currentFunction.getCallFixups().size() * 2; // Number of call fixups
                        functionComplexity.put(func.address, complexity);
                    }
                }
                analysisResults.put("functionComplexity", functionComplexity);
                println("Calculated function complexity.");
            }

            private void analyzeFunctionCrossReferences() throws Exception {
                println("Analyzing function cross-references...");
                xrefsToFunctions = new HashMap<>();

                for (GhidraFunction func : functions.values()) {
                    xrefsToFunctions.put(func.address, new ArrayList<>());
                }

                for (GhidraFunction func : functions.values()) {
                    Function currentFunction = getFunctionAt(toAddr(func.address));
                    if (currentFunction != null) {
                        ReferenceIterator references = getReferencesTo(currentFunction.getEntryPoint());
                        while (references.hasNext() && !monitor.isCancelled()) {
                            Reference ref = references.next();
                            if (ref.getType() == RefType.CALL || ref.getType() == RefType.UNCONDITIONAL_CALL) {
                                Function callingFunc = getFunctionContaining(ref.getFromAddress());
                                if (callingFunc != null) {
                                    xrefsToFunctions.get(func.address).add(callingFunc.getEntryPoint().getOffset());
                                }
                            }
                        }
                    }
                }
                analysisResults.put("xrefsToFunctions", xrefsToFunctions);
                println("Analyzed function cross-references.");
            }

            private void analyzeStringCrossReferences() throws Exception {
                println("Analyzing string cross-references...");
                xrefsToStrings = new HashMap<>();

                SymbolTable symbolTable = currentProgram.getSymbolTable();
                SymbolIterator symbols = symbolTable.getSymbolIterator();

                while (symbols.hasNext() && !monitor.isCancelled()) {
                    Symbol symbol = symbols.next();
                    if (symbol.getSymbolType() == SymbolType.LABEL) {
                        String name = symbol.getName().toLowerCase();
                        for (String keyword : LICENSE_KEYWORDS) {
                            if (name.contains(keyword)) {
                                List<Long> referencedStringAddrs = new ArrayList<>();
                                ReferenceIterator refIter = getReferencesTo(symbol.getAddress());
                                while (refIter.hasNext()) {
                                    Reference ref = refIter.next();
                                    if (ref.getType() == RefType.DATA) { // Assuming string references are data references
                                        referencedStringAddrs.add(ref.getFromAddress().getOffset());
                                    }
                                }
                                xrefsToStrings.put(symbol.getAddress().getOffset(), referencedStringAddrs);
                                break;
                            }
                        }
                    }
                }
                analysisResults.put("xrefsToStrings", xrefsToStrings);
                println("Analyzed string cross-references.");
            }

            private void findPotentialLicenseChecks() throws Exception {
                println("Identifying potential license checks...");
                JsonArray checkCandidates = new JsonArray();

                for (GhidraFunction func : functions.values()) {
                    if (isLikelyLicenseFunction(func)) {
                        potentialLicenseChecks.add(func.address);
                        memoryRegionsOfInterest.add(toAddr(func.address));
                        println("Potential license check function: " + func.name + " at 0x" + Long.toHexString(func.address));

                        JsonObject checkObj = new JsonObject();
                        checkObj.put("address", Long.toHexString(func.address));
                        checkObj.put("name", func.name);
                        checkObj.put("size", func.size);
                        checkObj.put("complexity", functionComplexity.get(func.address));
                        checkObj.put("callers", xrefsToFunctions.get(func.address));
                        checkObj.put("xrefsToStrings", xrefsToStrings.get(func.address)); // Add string cross-references
                        checkCandidates.add(checkObj);
                    }
                }
                analysisResults.put("checkCandidates", checkCandidates);
                println("Found " + potentialLicenseChecks.size() + " potential license check functions.");
            }

            private boolean isLikelyLicenseFunction(GhidraFunction func) {
                if (func.name.toLowerCase().contains("license") ||
                    func.name.toLowerCase().contains("serial") ||
                    func.name.toLowerCase().contains("key") ||
                    func.name.toLowerCase().contains("auth") ||
                    func.name.toLowerCase().contains("valid")) {
                    return true;
                }

                // Check if the function calls any crypto or anti-debug APIs
                for (Long calleeAddr : callGraph.get(func.address)) {
                    GhidraFunction callee = functions.get(calleeAddr);
                    if (callee != null) {
                        for (String cryptoApi : CRYPTO_APIS) {
                            if (callee.name.contains(cryptoApi)) {
                                return true;
                            }
                        }
                        for (String antiDebugApi : ANTI_DEBUG_APIS) {
                            if (callee.name.contains(antiDebugApi)) {
                                return true;
                            }
                        }
                    }
                }

                // Check if the function references any license-related strings
                if (stringReferences.containsKey(func.address)) {
                    return true;
                }

                // Check if the function has a complex control flow or is large
                if (func.size > 1000 || func.size < 100) { // More sophisticated complexity check would be better
                    return true;
                }

                // Check if the function is called by many other functions (often a utility function)
                int callerCount = 0;
                if (xrefsToFunctions.containsKey(func.address)) {
                    callerCount = xrefsToFunctions.get(func.address).size();
                }
                if (callerCount > 20) { // Arbitrary threshold
                    return false; // Less likely to be a core license check
                }

                return false;
            }

            private AddressSetView getFunctionBody(Address functionAddress) {
                Function function = getFunctionAt(functionAddress);
                if (function != null) {
                    return function.getBody();
                }
                return null;
            }

            private void decompileFunctionsOfInterest() throws Exception {
                println("Decompiling functions of interest...");
                JsonArray decompiledFunctions = new JsonArray();

                DecompileOptions options = new DecompileOptions();
                DecompInterface decompiler = new DecompInterface();
                decompiler.openProgram(currentProgram);

                for (long funcAddr : potentialLicenseChecks) {
                    Function func = getFunctionAt(toAddr(funcAddr));
                    if (func != null && !monitor.isCancelled()) {
                        DecompileResults results = decompiler.decompileFunction(toAddr(funcAddr), options, monitor);
                        if (results.decompileCompleted()) {
                            String pseudoCode = results.getDecompiledFunction().getSourceCode();
                            functionPseudoCode.put(funcAddr, pseudoCode);
                            println("  Decompiled " + func.getName() + " at 0x" + Long.toHexString(funcAddr));

                            JsonObject decompiledFuncObj = new JsonObject();
                            decompiledFuncObj.put("address", Long.toHexString(funcAddr));
                            decompiledFuncObj.put("name", func.getName());
                            decompiledFuncObj.put("pseudoCode", pseudoCode);
                            decompiledFunctions.add(decompiledFuncObj);
                        } else {
                            println("Decompile failed for " + func.getName() + " at 0x" + Long.toHexString(funcAddr));
                        }
                    }
                }

                decompiler.closeProgram();
                analysisResults.put("decompiledFunctions", decompiledFunctions);
                println("Decompilation complete.");
            }

            private void generatePatchingStrategy() throws Exception {
                println("Generating patching strategy...");
                JsonArray patchCandidates = new JsonArray();

                // Example: More sophisticated strategy - Analyze decompiled code and CFG
                for (long funcAddr : potentialLicenseChecks) {
                    Function func = getFunctionAt(toAddr(funcAddr));
                    if (func != null && functionPseudoCode.containsKey(funcAddr)) {
                        String pseudoCode = functionPseudoCode.get(funcAddr);
                        // Simple pattern matching for license checks (improve with AI)
                        if (pseudoCode.contains("strcmp") || pseudoCode.contains("memcmp") || pseudoCode.contains("strncmp")) {
                            println("  Potential license check function: " + func.getName() + " at 0x" + Long.toHexString(funcAddr));

                            // Get CFG for the function
                            FunctionGraph functionGraph = new FunctionGraph(currentProgram, toAddr(funcAddr), monitor);
                            Iterator<Block> blocks = functionGraph.getBlocks(true).iterator();

                            while (blocks.hasNext() && !monitor.isCancelled()) {
                                Block block = blocks.next();
                                InstructionIterator instructions = block.getInstructions();
                                while (instructions.hasNext()) {
                                    Instruction instr = instructions.next();
                                    if (instr.getMnemonicString().startsWith("J") && !instr.getMnemonicString().equals("JMP")) {
                                        println("    Potential patch location: " + instr.getAddress());

                                        JsonObject patchObj = new JsonObject();
                                        patchObj.put("address", instr.getAddress().toString());
                                        patchObj.put("newBytes", "9090"); // Example: NOP
                                        patchObj.put("description", "Bypass license check");
                                        patchCandidates.add(patchObj);
                                    }
                                }
                            }
                        }
                    }
                }

                analysisResults.put("patchCandidates", patchCandidates);
                println("Patching strategy generation complete.");
            }

            private void outputResults() throws Exception {
                File outputFile = new File(System.getProperty("user.dir"), "analysis_results.json");
                PrintWriter writer = new PrintWriter(new FileWriter(outputFile));
                writer.println(analysisResults.toString(4)); // Indent for readability
                writer.close();
                println("Analysis results written to: " + outputFile.getAbsolutePath());
            }

            // --- Data Structures ---

            static class GhidraFunction {
                String name;
                long address;
                String signature;
                int size;

                public GhidraFunction(String name, long address, String signature, int size) {
                    this.name = name;
                    this.address = address;
                    this.signature = signature;
                    this.size = size;
                }
            }

            static class GhidraInstruction {
                long address;
                String mnemonic;
                String operands;

                public GhidraInstruction(long address, String mnemonic, String operands) {
                    this.address = address;
                    this.mnemonic = mnemonic;
                    this.operands = operands;
                }
            }
        }
""")

    try:
        shutil.copy(script_source, script_destination)
    except Exception as e:
        app.update_output.emit(log_message(
            f"[Ghidra Analysis] Error copying script: {e}"))
        return

    # Create a temporary directory for the Ghidra project
    temp_dir = tempfile.mkdtemp(prefix="intellicrack_ghidra_")
    project_name = "temp_project"

    # Build the command
    cmd = [
        ghidra_path.replace("ghidraRun.bat", "support/analyzeHeadless.bat"),
        temp_dir,
        project_name,
        "-import", app.binary_path,
        "-scriptPath", os.path.abspath("ghidra_scripts"),
        "-postScript", "AdvancedAnalysis.java",
        "-overwrite"
    ]

    app.update_output.emit(log_message(
        "[Ghidra Analysis] Running headless analyzer..."))
    app.update_output.emit(log_message(
        f"[Ghidra Analysis] Command: {' '.join(cmd)}"))

    # Run Ghidra in a background thread
    threading.Thread(target=lambda: _run_ghidra_thread(
        app, cmd, temp_dir)).start()


def _run_ghidra_thread(app, cmd, temp_dir):
    """
    Background thread for Ghidra execution with improved error handling.
    """
    try:
        # Run Ghidra
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
