        Load protocol fingerprints for identifying license check protocols.
        """
        # Common license server protocols
        self.protocol_fingerprints = {
            'flexlm': {
                'patterns': [
                    b'VENDOR_STRING',
                    b'FEATURE',
                    b'INCREMENT',
                    b'SERVER_HOSTID',
                    b'SIGN='
                ],
                'ports': [27000, 27001, 1101]
            },
            'hasp': {
                'patterns': [
                    b'hasp',
                    b'HASP',
                    b'sentinel',
                    b'SENTINEL'
                ],
                'ports': [1947]
            },
            'adobe': {
                'patterns': [
                    b'adobe',
                    b'ADOBE',
                    b'lcsap',
                    b'LCSAP'
                ],
                'ports': [443, 8080]
            },
            'autodesk': {
                'patterns': [
                    b'adsk',
                    b'ADSK',
                    b'autodesk',
                    b'AUTODESK'
                ],
                'ports': [2080, 443]
            },
            'microsoft': {
                'patterns': [
                    b'msft',
                    b'MSFT',
                    b'microsoft',
                    b'MICROSOFT',
                    b'kms',
                    b'KMS'
                ],
                'ports': [1688, 443]
            }
        }

    def _load_response_templates(self):
        """
        Load response templates for various license server protocols.
        """
        # FlexLM response template
        self.response_templates['flexlm'] = {
            'license_ok': (
                b"SERVER this_host ANY 27000\n"
                b"VENDOR vendor\n"
                b"FEATURE product vendor 1.0 permanent uncounted HOSTID=ANY SIGN=VALID\n"
            )
        }

        # HASP response template
        self.response_templates['hasp'] = {
            'license_ok': (
                b'{"status":"OK","key":"VALID","expiration":"permanent","features":["all"]}'
            )
        }

        # Adobe response template
        self.response_templates['adobe'] = {
            'license_ok': (
                b'{"status":"SUCCESS","message":"License is valid","expiry":"never","serial":"1234-5678-9012-3456-7890"}'
            )
        }

        # Autodesk response template
        self.response_templates['autodesk'] = {
            'license_ok': (
                b'{"status":"success","license":{"status":"ACTIVATED","type":"PERMANENT"}}'
            )
        }

        # Microsoft KMS response template
        self.response_templates['microsoft'] = {
            'license_ok': (
                b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
            )
        }

    def start(self):
        """
        Start the network license server emulator.

        Returns:
            bool: True if started successfully, False otherwise
        """
        try:
            # Start DNS server if enabled
            if self.config['dns_redirect']:
                self._start_dns_server()

            # Start SSL interceptor if enabled
            if self.config['ssl_intercept']:
                self._start_ssl_interceptor()

            # Start traffic recorder if enabled
            if self.config['record_traffic']:
                self._start_traffic_recorder()

            # Start TCP servers on configured ports
            for port in self.config['listen_ports']:
                self._start_tcp_server(port)

            self.logger.info(f"Network License Server Emulator started on ports: {self.config['listen_ports']}")
            return True

        except Exception as e:
            self.logger.error(f"Error starting Network License Server Emulator: {e}")
            self.logger.error(traceback.format_exc())
            self.stop()
            return False

    def stop(self):
        """
        Stop the network license server emulator.

        Returns:
            bool: True if stopped successfully, False otherwise
        """
        try:
            # Stop all TCP servers
            for server in self.servers:
                server.shutdown()
                server.server_close()

            # Stop DNS server if running
            if self.dns_server:
                self.dns_server.shutdown()

            # Stop SSL interceptor if running
            if self.ssl_interceptor:
                self.ssl_interceptor.stop()

            # Stop traffic recorder if running
            if self.traffic_recorder:
                self.traffic_recorder.stop()

            self.logger.info("Network License Server Emulator stopped")
            return True

        except Exception as e:
            self.logger.error(f"Error stopping Network License Server Emulator: {e}")
            return False

    def _start_tcp_server(self, port):
        """
        Start a TCP server on the specified port.

        Args:
            port: Port number to listen on

        Returns:
            socketserver.TCPServer: Server instance
        """

        class LicenseRequestHandler(socketserver.BaseRequestHandler):
            """
            Request handler for license server emulator.
            """
            def handle(self):
                """
                Handle incoming license verification requests from client applications.

                This method is called by the socketserver framework whenever a client connects
                to the license server emulator. It processes incoming license requests by:
                1. Receiving data from the client
                2. Logging the request details
                3. Identifying the license protocol from the request data
                4. Generating an appropriate response based on the protocol
                5. Adding configured delays to simulate network conditions
                6. Sending the response back to the client

                The method interfaces with the parent emulator instance to access configuration
                settings and utilize helper methods for protocol identification and response generation.
                """
                # Get reference to parent emulator
                emulator = self.server.emulator

                try:
                    # Receive data
                    data = self.request.recv(4096)

                    if data:
                        # Log received data
                        emulator.logger.info(f"Received data on port {self.server.server_address[1]} from {self.client_address[0]}")

                        # Identify protocol
                        protocol = emulator._identify_protocol(data, self.server.server_address[1])

                        # Generate response
                        if emulator.config['auto_respond']:
                            response = emulator._generate_response(protocol, data)

                            # Add delay if configured
                            if emulator.config['response_delay'] > 0:
                                time.sleep(emulator.config['response_delay'])

                            # Send response
                            self.request.sendall(response)

                            # Log response
                            emulator.logger.info(f"Sent {len(response)} bytes response for {protocol} protocol")

                except Exception as e:
                    emulator.logger.error(f"Error handling request: {e}")

        # Create server
        server = socketserver.ThreadingTCPServer((self.config['listen_ip'], port), LicenseRequestHandler)

        # Store reference to emulator
        server.emulator = self

        # Start server in a separate thread
        server_thread = threading.Thread(target=server.serve_forever)
        server_thread.daemon = True
        server_thread.start()

        # Store server instance
        self.servers.append(server)

        self.logger.info(f"TCP server started on port {port}")
        return server

    def _identify_protocol(self, data, port):
        """
        Identify the license server protocol from the request data.

        Args:
            data: Request data
            port: Port number the request was received on

        Returns:
            str: Protocol name, or 'unknown' if not identified
        """
        # Check each protocol fingerprint
        for protocol, fingerprint in self.protocol_fingerprints.items():
            # Check if port matches
            if port in fingerprint['ports']:
                # Higher probability of this protocol
                probability = 0.5
            else:
                probability = 0.0

            # Check for pattern matches
            for pattern in fingerprint['patterns']:
                if pattern in data:
                    probability += 0.1

            if probability >= 0.5:
                return protocol

        # Default to unknown protocol
        return 'unknown'

    def _generate_response(self, protocol, request_data):
        """
        Generate a response for the identified protocol.

        Args:
            protocol: Protocol name
            request_data: Request data

        Returns:
            bytes: Response data
        """
        # Check if we have a template for this protocol
        if protocol in self.response_templates:
            # Use license_ok template by default
            if 'license_ok' in self.response_templates[protocol]:
                return self.response_templates[protocol]['license_ok']

        # Default response for unknown protocols
        return b'{"status":"OK","license":"valid"}'

    def _start_dns_server(self):
        """
        Start a DNS server for redirecting license server hostnames.
        """
        self.logger.info("DNS server functionality would be implemented here")
        return None

    def _start_ssl_interceptor(self):
        """
        Start an SSL interceptor for HTTPS license verification.
        """
        self.logger.info("SSL interceptor functionality would be implemented here")
        return None

    def _start_traffic_recorder(self):
        """
        Start a traffic recorder for license communications.
        """
        self.logger.info("Traffic recorder functionality would be implemented here")
        return None

def run_network_license_emulator(app):
    """
    Run the network license server emulator.

    Args:
        app: Application instance
    """
    app.update_output.emit(log_message("[Network] Starting network license server emulator..."))

    # Create emulator
    emulator = NetworkLicenseServerEmulator()

    # Ask for ports
    ports_str, ok = QInputDialog.getText(
        app,
        "License Server Ports",
        "Enter comma-separated list of ports to listen on:",
        QLineEdit.Normal,
        "1111,1234,1337,8080,8888,27000,27001"
    )

    if ok:
        # Parse ports
        try:
            ports = [int(port.strip()) for port in ports_str.split(',')]
            emulator.config['listen_ports'] = ports
        except ValueError:
            app.update_output.emit(log_message("[Network] Invalid port numbers, using defaults"))
    else:
        app.update_output.emit(log_message("[Network] Cancelled"))
        return

    # Start emulator
    if emulator.start():
        app.update_output.emit(log_message("[Network] Network license server emulator started"))
        app.update_output.emit(log_message(f"[Network] Listening on ports: {emulator.config['listen_ports']}"))

        # Store emulator instance in app
        app.license_emulator = emulator

        # Add to analyze results
        if not hasattr(app, "analyze_results"):
            app.analyze_results = []

        app.analyze_results.append("\n=== NETWORK LICENSE SERVER EMULATOR ===")
        app.analyze_results.append(f"Listening on ports: {emulator.config['listen_ports']}")
        app.analyze_results.append("\nSupported protocols:")
        for protocol in emulator.protocol_fingerprints.keys():
            app.analyze_results.append(f"- {protocol.upper()}")

        app.analyze_results.append("\nTo use the emulator:")
        app.analyze_results.append("1. Configure the application to use localhost as the license server")
        app.analyze_results.append("2. Or redirect license server hostnames to localhost using hosts file")
        app.analyze_results.append("3. The emulator will automatically respond to license checks with valid responses")
    else:
        app.update_output.emit(log_message("[Network] Failed to start network license server emulator"))

    # -------------------------------
    # Multi-Format Binary Support
    # -------------------------------

class MultiFormatBinaryAnalyzer:
    """
    Support for analyzing multiple executable formats (PE, ELF, Mach-O).

    This system extends Intellicrack's capabilities beyond Windows PE files
    to include Linux ELF binaries, macOS Mach-O binaries, and other formats.
    """

    def __init__(self):
        """
        Initialize the multi-format binary analyzer.
        """
        self.logger = logging.getLogger(__name__)

        # Check for required dependencies
        self.lief_available = False
        self.pyelftools_available = False
        self.macholib_available = False

        self._check_available_backends()

    def _check_available_backends(self):
        """
        Check which binary analysis backends are available.
        """
        # Check for LIEF (supports PE, ELF, Mach-O)
        try:
            self.lief_available = True
            self.logger.info("LIEF multi-format binary analysis available")
        except ImportError:
            self.logger.info("LIEF multi-format binary analysis not available")

        # Check for pyelftools (specialized ELF analysis)
        try:
            self.pyelftools_available = True
            self.logger.info("pyelftools ELF analysis available")
        except ImportError:
            self.logger.info("pyelftools ELF analysis not available")

        # Check for macholib (specialized Mach-O analysis)
        try:
            self.macholib_available = True
            self.logger.info("macholib Mach-O analysis available")
        except ImportError:
            self.logger.info("macholib Mach-O analysis not available")

    def identify_format(self, binary_path):
        """
        Identify the format of a binary file.

        Args:
            binary_path: Path to the binary file

        Returns:
            str: Format of the binary ('PE', 'ELF', 'MACHO', 'UNKNOWN')
        """
        try:
            with open(binary_path, 'rb') as f:
                magic = f.read(4)

                # Check for PE format (MZ header)
                if magic.startswith(b'MZ'):
                    return 'PE'

                # Check for ELF format
                if magic.startswith(b'\x7fELF'):
                    return 'ELF'

                # Check for Mach-O format (32-bit or 64-bit)
                if magic in [b'\xfe\xed\xfa\xce', b'\xfe\xed\xfa\xcf', b'\xce\xfa\xed\xfe', b'\xcf\xfa\xed\xfe']:
                    return 'MACHO'

                # Check for Java class file
                if magic.startswith(b'\xca\xfe\xba\xbe'):
                    return 'CLASS'

                # Check for .NET assembly (PE file with specific characteristics)
                if magic.startswith(b'MZ'):
                    # Need to check for .NET metadata
                    f.seek(0x3c)
                    pe_offset = int.from_bytes(f.read(4), byteorder='little')
                    f.seek(pe_offset + 0x18)
                    magic = f.read(2)
                    if magic in [b'\x0b\x01', b'\x07\x01']:  # 32-bit or 64-bit
                        # Check for CLI header
                        f.seek(pe_offset + 0x18 + 0x60)
                        cli_header = f.read(8)
                        if any(cli_header):
                            return 'DOTNET'

                return 'UNKNOWN'

        except Exception as e:
            self.logger.error(f"Error identifying binary format: {e}")
            return 'UNKNOWN'

    def analyze_binary(self, binary_path):
        """
        Analyze a binary file of any supported format.

        Args:
            binary_path: Path to the binary file

        Returns:
            dict: Analysis results
        """
        # Identify format
        binary_format = self.identify_format(binary_path)

        # Choose appropriate analysis method
        if binary_format == 'PE':
            return self.analyze_pe(binary_path)
        elif binary_format == 'ELF':
            return self.analyze_elf(binary_path)
        elif binary_format == 'MACHO':
            return self.analyze_macho(binary_path)
        elif binary_format == 'DOTNET':
            return self.analyze_dotnet(binary_path)
        elif binary_format == 'CLASS':
            return self.analyze_java(binary_path)
        else:
            return {
                'format': 'UNKNOWN',
                'error': 'Unsupported binary format'
            }

    def analyze_pe(self, binary_path):
        """
        Analyze a PE (Windows) binary.

        Args:
            binary_path: Path to the binary file

        Returns:
            dict: Analysis results
        """
        try:

            pe = pefile.PE(binary_path)

            # Basic information
            info = {
                'format': 'PE',
                'machine': get_machine_type(pe.FILE_HEADER.Machine),
                'timestamp': get_pe_timestamp(pe.FILE_HEADER.TimeDateStamp),
                'subsystem': pe.OPTIONAL_HEADER.Subsystem,
                'characteristics': get_characteristics(pe.FILE_HEADER.Characteristics),
                'sections': [],
                'imports': [],
                'exports': []
            }

            # Section information
            for section in pe.sections:
                section_name = section.Name.decode('utf-8', 'ignore').strip('\x00')
                section_info = {
                    'name': section_name,
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'characteristics': hex(section.Characteristics),
                    'entropy': calculate_entropy(section.get_data())
                }
                info['sections'].append(section_info)

            # Import information
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', 'ignore')
                    imports = []

                    for imp in entry.imports:
                        if imp.name:
                            import_name = imp.name.decode('utf-8', 'ignore')
                            imports.append(import_name)

                    info['imports'].append({
                        'dll': dll_name,
                        'functions': imports
                    })

            # Export information
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        export_name = exp.name.decode('utf-8', 'ignore')
                        info['exports'].append({
                            'name': export_name,
                            'address': hex(exp.address)
                        })

            return info

        except Exception as e:
            self.logger.error(f"Error analyzing PE binary: {e}")
            return {
                'format': 'PE',
                'error': str(e)
            }

    def analyze_elf(self, binary_path):
        """
        Analyze an ELF (Linux) binary.

        Args:
            binary_path: Path to the binary file

        Returns:
            dict: Analysis results
        """
        if not self.lief_available and not self.pyelftools_available:
            return {
                'format': 'ELF',
                'error': 'No ELF analysis backend available'
            }

        try:
            # Use LIEF if available
            if self.lief_available:

                # pylint: disable=no-member
                binary = lief.parse(binary_path)

                # Basic information
                info = {
                    'format': 'ELF',
                    'machine': binary.header.machine_type.name,
                    'class': '64-bit' if binary.header.identity_class.name == 'CLASS64' else '32-bit',
                    'type': binary.header.file_type.name,
                    'entry_point': hex(binary.header.entrypoint),
                    'sections': [],
                    'symbols': [],
                    'dynamic': []
                }

                # Section information
                for section in binary.sections:
                    section_info = {
                        'name': section.name,
                        'type': section.type.name if hasattr(section.type, 'name') else str(section.type),
                        'address': hex(section.virtual_address),
                        'size': section.size
                    }

                    # Calculate entropy if section has content
                    if section.content and section.size > 0:
                        section_info['entropy'] = calculate_entropy(bytes(section.content))

                    info['sections'].append(section_info)

                # Symbol information
                for symbol in binary.symbols:
                    if symbol.name:
                        symbol_info = {
                            'name': symbol.name,
                            'type': symbol.type.name if hasattr(symbol.type, 'name') else str(symbol.type),
                            'value': hex(symbol.value),
                            'size': symbol.size
                        }
                        info['symbols'].append(symbol_info)

                return info

            # Use pyelftools if LIEF not available
            elif self.pyelftools_available:

                with open(binary_path, 'rb') as f:
                    elf = ELFFile(f)

                    # Basic information
                    info = {
                        'format': 'ELF',
                        'machine': elf.header['e_machine'],
                        'class': elf.header['e_ident']['EI_CLASS'],
                        'type': elf.header['e_type'],
                        'entry_point': hex(elf.header['e_entry']),
                        'sections': [],
                        'symbols': []
                    }

                    # Section information
                    for section in elf.iter_sections():
                        section_info = {
                            'name': section.name,
                            'type': section['sh_type'],
                            'address': hex(section['sh_addr']),
                            'size': section['sh_size']
                        }

                        info['sections'].append(section_info)

                    return info

        except Exception as e:
            self.logger.error(f"Error analyzing ELF binary: {e}")
            return {
                'format': 'ELF',
                'error': str(e)
            }

    def analyze_macho(self, binary_path):
        """
        Analyze a Mach-O (macOS) binary.

        Args:
            binary_path: Path to the binary file

        Returns:
            dict: Analysis results
        """
        if not self.lief_available and not self.macholib_available:
            return {
                'format': 'MACHO',
                'error': 'No Mach-O analysis backend available'
            }

        try:
            # Use LIEF if available
            if self.lief_available:

                # pylint: disable=no-member
                binary = lief.parse(binary_path)

                # Basic information
                info = {
                    'format': 'MACHO',
                    'headers': [],
                    'segments': [],
                    'symbols': [],
                    'libraries': []
                }

                # Header information
                header_info = {
                    'magic': hex(binary.magic),
                    'cpu_type': binary.header.cpu_type.name if hasattr(binary.header.cpu_type, 'name') else str(binary.header.cpu_type),
                    'file_type': binary.header.file_type.name if hasattr(binary.header.file_type, 'name') else str(binary.header.file_type)
                }
                info['headers'].append(header_info)

                # Segment information
                for segment in binary.segments:
                    segment_info = {
                        'name': segment.name,
                        'address': hex(segment.virtual_address),
                        'size': segment.virtual_size,
                        'sections': []
                    }

                    # Section information
                    for section in segment.sections:
                        section_info = {
                            'name': section.name,
                            'address': hex(section.virtual_address),
                            'size': section.size
                        }

                        segment_info['sections'].append(section_info)

                    info['segments'].append(segment_info)

                return info

            # Use macholib if LIEF not available
            elif self.macholib_available:

                macho = MachO(binary_path)

                # Basic information
                info = {
                    'format': 'MACHO',
                    'headers': [],
                    'segments': [],
                    'libraries': []
                }

                # Process each header
                for header in macho.headers:
                    header_info = {
                        'magic': hex(header.MH_MAGIC),
                        'cpu_type': header.header.cputype,
                        'cpu_subtype': header.header.cpusubtype,
                        'filetype': header.header.filetype
                    }
                    info['headers'].append(header_info)

                return info

        except Exception as e:
            self.logger.error(f"Error analyzing Mach-O binary: {e}")
            return {
                'format': 'MACHO',
                'error': str(e)
            }

def run_multi_format_analysis(app):
    """
    Run analysis on a binary of any supported format.

    Args:
        app: Application instance
    """
    if not app.binary_path:
        app.update_output.emit(log_message("[Multi-Format] No binary selected."))
        return

    app.update_output.emit(log_message("[Multi-Format] Starting multi-format binary analysis..."))

    # Create multi-format analyzer
    analyzer = MultiFormatBinaryAnalyzer()

    # Identify format
    binary_format = analyzer.identify_format(app.binary_path)
    app.update_output.emit(log_message(f"[Multi-Format] Detected format: {binary_format}"))

    # Run analysis
    app.update_output.emit(log_message(f"[Multi-Format] Analyzing {binary_format} binary..."))
    results = analyzer.analyze_binary(app.binary_path)

    # Check for error
    if 'error' in results:
        app.update_output.emit(log_message(f"[Multi-Format] Error: {results['error']}"))
        return

    # Display results
    app.update_output.emit(log_message(f"[Multi-Format] Analysis completed for {binary_format} binary"))

    # Add to analyze results
    if not hasattr(app, "analyze_results"):
        app.analyze_results = []

    app.analyze_results.append(f"\n=== MULTI-FORMAT BINARY ANALYSIS ({binary_format}) ===")

    # Format-specific information
    if binary_format == 'PE':
        app.analyze_results.append(f"Machine: {results['machine']}")
        app.analyze_results.append(f"Timestamp: {results['timestamp']}")
        app.analyze_results.append(f"Characteristics: {results['characteristics']}")

        app.analyze_results.append("\nSections:")
        for section in results['sections']:
            entropy_str = f", Entropy: {section['entropy']:.2f}" if 'entropy' in section else ""
            app.analyze_results.append(f"  {section['name']} - VA: {section['virtual_address']}, Size: {section['virtual_size']}{entropy_str}")

        app.analyze_results.append("\nImports:")
        for imp in results['imports']:
            app.analyze_results.append(f"  {imp['dll']} - {len(imp['functions'])} functions")

        app.analyze_results.append("\nExports:")
        for exp in results['exports'][:10]:  # Limit to first 10
            app.analyze_results.append(f"  {exp['name']} - {exp['address']}")

    elif binary_format == 'ELF':
        app.analyze_results.append(f"Machine: {results['machine']}")
        app.analyze_results.append(f"Class: {results['class']}")
        app.analyze_results.append(f"Type: {results['type']}")
        app.analyze_results.append(f"Entry Point: {results['entry_point']}")

        app.analyze_results.append("\nSections:")
        for section in results['sections']:
            entropy_str = f", Entropy: {section['entropy']:.2f}" if 'entropy' in section else ""
            app.analyze_results.append(f"  {section['name']} - Addr: {section['address']}, Size: {section['size']}{entropy_str}")

        app.analyze_results.append("\nSymbols:")
        for symbol in results['symbols'][:10]:  # Limit to first 10
            app.analyze_results.append(f"  {symbol['name']} - {symbol['value']}")

    elif binary_format == 'MACHO':
        app.analyze_results.append(f"CPU Type: {results['headers'][0]['cpu_type']}")
        app.analyze_results.append(f"File Type: {results['headers'][0]['filetype']}")

        app.analyze_results.append("\nSegments:")
        for segment in results['segments']:
            app.analyze_results.append(f"  {segment['name']} - Addr: {segment['address']}, Size: {segment['size']}")

            app.analyze_results.append("  Sections:")
            for section in segment['sections']:
                app.analyze_results.append(f"    {section['name']} - Addr: {section['address']}, Size: {section['size']}")

    # Add recommendations based on format
    app.analyze_results.append("\nRecommendations:")
    if binary_format == 'PE':
        app.analyze_results.append("- Use standard Windows PE analysis techniques")
        app.analyze_results.append("- Check for high-entropy sections that may indicate packing or encryption")
    elif binary_format == 'ELF':
        app.analyze_results.append("- Use specialized ELF analysis tools for deeper inspection")
        app.analyze_results.append("- Consider using dynamic analysis with Linux-specific tools")
    elif binary_format == 'MACHO':
        app.analyze_results.append("- Use macOS-specific analysis tools for deeper inspection")
        app.analyze_results.append("- Check for code signing and entitlements")

    # -------------------------------
    # PDF Report Generation System
    # -------------------------------

class PDFReportGenerator:
    """
    PDF report generator for comprehensive analysis findings.

    This system generates professional PDF reports with detailed analysis results,
    including visualizations, code snippets, and recommendations.

    This combines the functionality of the original PDFReportGenerator with the enhanced
    features of the application-specific implementation.
    """

    def __init__(self, output_dir="reports", app_instance=None):
        """
        Initialize the PDF report generator.

        Args:
            output_dir: Directory to save generated reports
            app_instance: Reference to the main application instance (optional)
        """
        self.output_dir = output_dir
        self.app = app_instance
        self.logger = logging.getLogger(__name__)
        self.sections = []  # Store report sections

        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)

        # Check for required dependencies
        self.reportlab_available = False
        self.matplotlib_available = False
        self.pdfkit_available = False

        # Basic report metadata
        self.title = "Intellicrack Security Analysis Report"
        self.author = "Intellicrack Security Team"
        self.company = "Intellicrack Security"
        self.logo_path = os.path.join(os.getcwd(), "assets", "icon.ico")

        # Default configuration
        self.report_config = {
            "company_name": "Intellicrack Security",
            "logo_path": os.path.join(os.getcwd(), "assets", "icon.ico"),
            "include_timestamps": True,
            "include_charts": True,
            "include_code_snippets": True,
            "include_recommendations": True,
            "color_scheme": "professional",  # professional, dark, or light
            "page_size": "letter"  # letter, a4, legal
        }

        self._check_available_backends()

    def _check_available_backends(self):
        """
        Check which PDF generation backends are available.
        """
        # Check for ReportLab
        try:
            self.reportlab_available = True
            self.logger.info("ReportLab PDF generation available")
        except ImportError:
            self.logger.info("ReportLab PDF generation not available")

        # Check for Matplotlib
        try:
            self.matplotlib_available = True
            self.logger.info("Matplotlib visualization available")
        except ImportError:
            self.logger.info("Matplotlib visualization not available")

        # Check for PDFKit
        try:
            self.pdfkit_available = True
            self.logger.info("PDFKit HTML-to-PDF conversion available")
        except ImportError:
            self.logger.info("PDFKit HTML-to-PDF conversion not available")

    def add_section(self, section_title, content=None):
        """
        Add a new section to the report.

        Args:
            section_title (str): Title of the section
            content (str, optional): Content text for the section
        """
        section = {
            "title": section_title,
            "content": content or "",
            "subsections": []
        }
        self.sections.append(section)
        return len(self.sections) - 1  # Return section index

    def add_subsection(self, section_index, title, content=None):
        """
        Add a subsection to an existing section.

        Args:
            section_index (int): Index of the parent section
            title (str): Title of the subsection
            content (str, optional): Content text for the subsection
        """
        if 0 <= section_index < len(self.sections):
            subsection = {
                "title": title,
                "content": content or ""
            }
            self.sections[section_index]["subsections"].append(subsection)
        else:
            self.logger.error(f"Invalid section index: {section_index}")

    def generate_report(self, binary_path=None, analysis_results=None, report_type="comprehensive", output_path=None, report_format='pdf'):
        """
        Generate a PDF report for the analysis results.

        Args:
            binary_path: Path to the analyzed binary (can be obtained from app_instance if None)
            analysis_results: Dictionary of analysis results (can be obtained from app_instance if None)
            report_type: Type of report to generate ("comprehensive", "vulnerability", or "license")
            output_path: Path to save the PDF report (optional)
            report_format: Format of the report ('pdf' or 'html')

        Returns:
            str: Path to the generated report
        """
        if report_format == 'pdf' and not self.reportlab_available:
            self.logger.warning("ReportLab not available. Cannot generate PDF report.")
            report_format = 'html'  # Fallback to HTML
            self.logger.info("Falling back to HTML format.")

        # Try to get binary_path from app if not provided
        if binary_path is None and self.app and hasattr(self.app, 'binary_path'):
