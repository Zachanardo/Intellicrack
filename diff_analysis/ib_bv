"""
        except Exception as e:
            section += f"""
            <h3>Binary Information</h3>
            <p>Error retrieving file information: {str(e)}</p>
"""

    # Add analysis results summary
    section += """
            <h3>Analysis Summary</h3>
"""

    if hasattr(self, 'analyze_results') and self.analyze_results:
        # Group results by category
        categories = {
            "License Detection": [],
            "Protection Mechanisms": [],
            "Memory Analysis": [],
            "Network Analysis": [],
            "Static Analysis": [],
            "General": []
        }

        for result in self.analyze_results:
            result_str = str(result)

            # Categorize based on content
            if "license" in result_str.lower():
                categories["License Detection"].append(result_str)
            elif any(x in result_str.lower() for x in ["protect", "obfuscation", "packing", "anti-debug"]):
                categories["Protection Mechanisms"].append(result_str)
            elif "memory" in result_str.lower():
                categories["Memory Analysis"].append(result_str)
            elif any(x in result_str.lower() for x in ["network", "traffic", "connection", "http", "dns"]):
                categories["Network Analysis"].append(result_str)
            elif any(x in result_str.lower() for x in ["static", "function", "string", "import", "export"]):
                categories["Static Analysis"].append(result_str)
            else:
                categories["General"].append(result_str)

        # Add each category to the report
        for category, items in categories.items():
            if items:
                section += f"""
            <h4>{category}</h4>
            <ul>
"""
                for item in items[:10]:  # First 10 items in each category
                    section += f"                <li>{item}</li>\n"

                # Add a note if there are more items
                if len(items) > 10:
                    section += f"                <li>... and {len(items) - 10} more items</li>\n"

                section += "            </ul>\n"
    else:
        section += """
            <p>No analysis results available.</p>
"""

    # Close the section
    section += """
        </div>
"""

    return section

def _format_memory_analysis_for_text(self):
    """Format memory analysis results for text reports"""
    text = ""

    if hasattr(self, 'memory_analysis_results') and self.memory_analysis_results:
        results = self.memory_analysis_results

        # Overall summary
        text += "Memory Overview:\n"
        text += f"- Total Allocated Memory: {results.get('total_allocated', 0):,} bytes\n"
        text += f"- Peak Memory Usage: {results.get('peak_usage', 0):,} bytes\n"
        text += f"- Heap Allocations: {results.get('heap_allocs', 0):,}\n"
        text += f"- Memory Leaks Detected: {results.get('leaks_count', 0)}\n"
        text += f"- Suspicious Allocations: {results.get('suspicious_allocs', 0)}\n\n"

        # Memory leaks
        if results.get('leaks', []):
            text += "Memory Leaks:\n"
            text += "--------------------------------------\n"
            for i, leak in enumerate(results.get('leaks', [])[:10]):
                text += f"{i+1}. Address: 0x{leak.get('address', 0):X}\n"
                text += f"   Size: {leak.get('size', 0):,} bytes\n"
                text += f"   Allocation: {leak.get('allocation_point', 'Unknown')}\n"
                text += f"   Lifetime: {leak.get('lifetime', 0)} ms\n"
                text += "--------------------------------------\n"

            if len(results.get('leaks', [])) > 10:
                text += f"... and {len(results.get('leaks', [])) - 10} more leaks\n\n"

        # Memory regions
        if results.get('regions', []):
            text += "Memory Regions:\n"
            text += "--------------------------------------\n"
            for i, region in enumerate(results.get('regions', [])[:15]):
                text += f"{i+1}. {region.get('name', 'Unknown')}\n"
                text += f"   Start: 0x{region.get('start_addr', 0):X}\n"
                text += f"   Size: {region.get('size', 0):,} bytes\n"
                text += f"   Permissions: {region.get('permissions', 'Unknown')}\n"
                text += f"   Type: {region.get('type', 'Unknown')}\n"
                text += "--------------------------------------\n"

            if len(results.get('regions', [])) > 15:
                text += f"... and {len(results.get('regions', [])) - 15} more regions\n\n"
    else:
        text += "No detailed memory analysis results available.\n\n"

    return text

def _format_network_analysis_for_text(self):
    """Format network analysis results for text reports"""
    text = ""

    if hasattr(self, 'traffic_recorder') and self.traffic_recorder:
        traffic_summary = self.traffic_recorder.get_traffic_summary()

        if traffic_summary:
            # Summary metrics
            text += "Network Traffic Summary:\n"
            text += f"- Total Packets: {traffic_summary.get('total_packets', 0):,}\n"
            text += f"- Total Data: {traffic_summary.get('total_bytes', 0):,} bytes\n"
            text += f"- Duration: {traffic_summary.get('duration_seconds', 0):.2f} seconds\n"
            text += f"- Avg Packet Size: {traffic_summary.get('avg_packet_size', 0):.2f} bytes\n"
            text += f"- Suspicious Connections: {len(traffic_summary.get('suspicious', []))}\n\n"

            # Protocol breakdown
            if 'protocols' in traffic_summary and traffic_summary['protocols']:
                text += "Protocol Breakdown:\n"
                text += "--------------------------------------\n"

                protocols = traffic_summary['protocols']
                total_packets = sum(protocols.values())

                for protocol, count in protocols.items():
                    percentage = (count / total_packets * 100) if total_packets > 0 else 0
                    text += f"{protocol}: {count:,} packets ({percentage:.2f}%)\n"

                text += "--------------------------------------\n\n"

            # Top destinations
            if 'destinations' in traffic_summary and traffic_summary['destinations']:
                text += "Top Destinations:\n"
                text += "--------------------------------------\n"

                # Sort by packet count
                destinations = sorted(
                    traffic_summary['destinations'].items(),
                    key=lambda x: x[1],
                    reverse=True
                )[:10]

                for dest, count in destinations:
                    # Get data size if available
                    data_size = traffic_summary.get('data_by_dest', {}).get(dest, 0)
                    data_str = f"{data_size:,} bytes" if data_size else "Unknown"

                    text += f"{dest}: {count:,} packets, {data_str}\n"

                text += "--------------------------------------\n\n"

            # License servers
            if 'license_servers' in traffic_summary and traffic_summary['license_servers']:
                text += "Detected License Servers:\n"
                text += "--------------------------------------\n"

                for server in traffic_summary['license_servers']:
                    text += f"Server: {server.get('address', 'Unknown')}\n"
                    text += f"Port: {server.get('port', 'Unknown')}\n"
                    text += f"Protocol: {server.get('protocol', 'Unknown')}\n"
                    text += f"Confidence: {server.get('confidence', 0)}%\n"
                    text += "--------------------------------------\n"
        else:
            text += "No network traffic summary available.\n\n"
    else:
        text += "No network traffic analysis results available.\n\n"

    return text

def _format_patching_results_for_text(self):
    """Format patching results for text reports"""
    text = ""

    # Get patches from the table if available
    patches = []
    if hasattr(self, 'patches_table') and self.patches_table:
        for row in range(self.patches_table.rowCount()):
            patch = {
                "id": self.patches_table.item(row, 0).text() if self.patches_table.item(row, 0) else "",
                "type": self.patches_table.item(row, 1).text() if self.patches_table.item(row, 1) else "",
                "address": self.patches_table.item(row, 2).text() if self.patches_table.item(row, 2) else "",
                "status": self.patches_table.item(row, 3).text() if self.patches_table.item(row, 3) else "",
                "description": self.patches_table.item(row, 4).text() if self.patches_table.item(row, 4) else ""
            }
            patches.append(patch)

    if patches:
        # Patching summary
        applied_count = sum(1 for p in patches if p["status"] == "Applied")

        text += "Patching Summary:\n"
        text += f"- Total Patches: {len(patches)}\n"
        text += f"- Applied Patches: {applied_count}\n"
        text += f"- Pending Patches: {len(patches) - applied_count}\n\n"

        # Patch details
        text += "Patch Details:\n"
        text += "--------------------------------------\n"

        for patch in patches:
            text += f"ID: {patch['id']}\n"
            text += f"Type: {patch['type']}\n"
            text += f"Address: {patch['address']}\n"
            text += f"Status: {patch['status']}\n"
            text += f"Description: {patch['description']}\n"
            text += "--------------------------------------\n"
    else:
        text += "No patching results available.\n\n"

    return text

# -------------------------------
# Entry Point
# -------------------------------

def launch():
    """Starts the application with an optional splash screen."""
    app_instance = QApplication(sys.argv)

    # Show splash screen
    splash = SplashScreen()
    splash.show()
    app_instance.processEvents()

    # Initialize main window in background
    time.sleep(1)  # Short delay for splash visibility

    window = IntellicrackApp()
    window.show()
    splash.close()

    sys.exit(app_instance.exec_())

if __name__ == "__main__":
    try:
        launch()
    except Exception as e:
        error_message = f"Startup failed: {e}"
        print(error_message)
        print(f"Error type: {type(e).__name__}")
        print(f"Traceback:\n{traceback.format_exc()}")

        # Create error log file
        with open("intellicrack_error.log", "w") as f:
            f.write(f"Error: {e}\n")
            f.write(f"Error type: {type(e).__name__}\n")
            f.write(f"Traceback:\n{traceback.format_exc()}")

# pylint: enable=line-too-long