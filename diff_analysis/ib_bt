                                         "Select Deep Analysis Type:", options, 0, False)
        if ok and option:
            self.handle_deep_analysis_mode(option)
    elif analysis_type == "Memory Analysis":
        self.run_memory_analysis()
    elif analysis_type == "Network Analysis":
        self.run_network_analysis()
    elif analysis_type == "Custom Analysis":
        self.tabs.setCurrentIndex(self.tabs.indexOf(self.analysis_tab))

def run_selected_patching(self, patch_type=None):
    """Run the selected patch operation from the dropdown menu

    Args:
        patch_type: Optional string specifying the patch type.
                   If None, gets the current selection from dropdown.
    """
    # Use provided patch_type or get it from the dropdown
    if patch_type is None:
        patch_type = self.patching_dropdown.currentText()
    self.update_output.emit(log_message(f"[Patching] Running {patch_type}..."))

    if patch_type == "Auto Patch":
        run_automated_patch_agent(self)
    elif patch_type == "Targeted Patch":
        # Show a submenu for targeting options
        options = ["License Checks", "Trial Limitations", "Feature Locks",
                   "Network Validation", "Hardware Checks"]
        target, ok = QInputDialog.getItem(self, "Targeted Patch",
                                         "Select Target Type:", options, 0, False)
        if ok and target:
            self.tabs.setCurrentIndex(self.tabs.indexOf(self.patching_tab))
            self.strategy_targeted_radio.setChecked(True)
            index = self.target_type_combo.findText(target)
            if index >= 0:
                self.target_type_combo.setCurrentIndex(index)
    elif patch_type == "Manual Patch":
        self.preview_patch()
    elif patch_type == "Visual Patch Editor":
        self.open_visual_patch_editor()
    elif patch_type == "Patch Testing":
        self.tabs.setCurrentIndex(self.tabs.indexOf(self.patching_tab))
        patching_tabs = self.patching_tab.findChild(QTabWidget)
        if patching_tabs:
            # Find and switch to the Testing tab
            for i in range(patching_tabs.count()):
                if patching_tabs.tabText(i) == "Testing":
                    patching_tabs.setCurrentIndex(i)
                    break

def run_memory_analysis(self):
    """
    Run comprehensive memory analysis on the target application.

    Analyzes memory usage patterns, detects potential leaks, and identifies
    memory-related vulnerabilities in the target application. Uses a combination
    of static and dynamic analysis techniques.
    """
    if not self.binary_path:
        QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
        return

    self.update_output.emit(log_message("[Memory Analysis] Starting comprehensive memory analysis..."))

    try:
        # Gather basic process information first
        if hasattr(self, 'dynamic_analyzer') and self.dynamic_analyzer:
            pid = self.dynamic_analyzer.get_target_pid()
            if not pid:
                # If not running, try to launch the process
                self.update_output.emit(log_message("[Memory Analysis] Target not running. Attempting to launch..."))
                pid = self.dynamic_analyzer.launch_target()

            if pid:
                # Get process object
                process = psutil.Process(pid)

                # Basic memory info
                mem_info = process.memory_info()
                self.update_output.emit(log_message(f"[Memory Analysis] PID: {pid}"))
                self.update_output.emit(log_message(f"[Memory Analysis] RSS: {mem_info.rss / (1024*1024):.2f} MB"))
                self.update_output.emit(log_message(f"[Memory Analysis] VMS: {mem_info.vms / (1024*1024):.2f} MB"))

                # Memory maps
                self.update_output.emit(log_message("[Memory Analysis] Analyzing memory maps..."))
                memory_maps = process.memory_maps()

                # Extract and categorize mapped regions
                executable_regions = []
                writable_regions = []
                suspicious_regions = []

                total_mapped = 0
                total_private = 0

                for region in memory_maps:
                    size = int(region.rss) if hasattr(region, 'rss') else 0
                    total_mapped += size

                    if 'p' in region.path.lower():  # Private memory
                        total_private += size

                    # Check for executable and writable regions (potential security issue)
                    if 'x' in region.perms and 'w' in region.perms:
                        suspicious_regions.append(region)

                    if 'x' in region.perms:
                        executable_regions.append(region)

                    if 'w' in region.perms:
                        writable_regions.append(region)

                # Report memory statistics
                self.update_output.emit(log_message(f"[Memory Analysis] Total mapped memory: {total_mapped / (1024*1024):.2f} MB"))
                self.update_output.emit(log_message(f"[Memory Analysis] Private memory: {total_private / (1024*1024):.2f} MB"))
                self.update_output.emit(log_message(f"[Memory Analysis] Executable regions: {len(executable_regions)}"))
                self.update_output.emit(log_message(f"[Memory Analysis] Writable regions: {len(writable_regions)}"))

                # Security warning for suspicious memory protections
                if suspicious_regions:
                    self.update_output.emit(log_message(f"[Memory Analysis] WARNING: Found {len(suspicious_regions)} memory regions that are both writable and executable"))
                    for region in suspicious_regions[:5]:  # Show first 5 only
                        self.update_output.emit(log_message(f"[Memory Analysis] Suspicious region: {region.addr} ({region.perms}) - {region.path}"))

                    self.analyze_results.append("\n=== MEMORY SECURITY ANALYSIS ===")
                    self.analyze_results.append(f"Found {len(suspicious_regions)} memory regions with RWX permissions (security risk)")
                    self.analyze_results.append("These regions could be used for shellcode execution or code injection attacks")

                # Memory usage over time (sample for a short period)
                self.update_output.emit(log_message("[Memory Analysis] Sampling memory usage over time..."))
                memory_samples = []

                for _ in range(5):  # Sample 5 times with 1-second intervals
                    try:
                        memory_samples.append(process.memory_info().rss)
                        time.sleep(1)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        self.update_output.emit(log_message("[Memory Analysis] Process terminated during sampling"))
                        break

                # Check for memory growth
                if len(memory_samples) >= 2:
                    growth = memory_samples[-1] - memory_samples[0]
                    if growth > 0:
                        growth_rate = growth / (1024 * 1024)  # Convert to MB
                        self.update_output.emit(log_message(f"[Memory Analysis] Memory growth detected: {growth_rate:.2f} MB over {len(memory_samples)} seconds"))

                        if growth_rate > 5:  # Threshold for significant growth (5MB in a few seconds)
                            self.update_output.emit(log_message("[Memory Analysis] WARNING: Significant memory growth detected - possible memory leak"))
                            self.analyze_results.append("Detected significant memory growth rate - potential memory leak")

                # Heap analysis using memory_profiler if available
                try:
                    self.update_output.emit(log_message("[Memory Analysis] Detailed heap analysis available"))
                except ImportError:
                    self.update_output.emit(log_message("[Memory Analysis] memory_profiler not available for detailed heap analysis"))

                # Check for memory fragmentation
                if hasattr(process, 'memory_full_info'):
                    full_info = process.memory_full_info()
                    if hasattr(full_info, 'uss') and hasattr(full_info, 'pss'):
                        self.update_output.emit(log_message(f"[Memory Analysis] Unique Set Size: {full_info.uss / (1024*1024):.2f} MB"))
                        self.update_output.emit(log_message(f"[Memory Analysis] Proportional Set Size: {full_info.pss / (1024*1024):.2f} MB"))

                        # Fragmentation estimate
                        if full_info.rss > 0:
                            fragmentation = 1.0 - (full_info.uss / full_info.rss)
                            self.update_output.emit(log_message(f"[Memory Analysis] Memory fragmentation estimate: {fragmentation:.2%}"))

                            if fragmentation > 0.3:  # Over 30% fragmentation
                                self.update_output.emit(log_message("[Memory Analysis] WARNING: High memory fragmentation detected"))
                                self.analyze_results.append("High memory fragmentation detected - could impact performance")

                # Attach Frida for deeper memory inspection if available
                if hasattr(self, 'dynamic_analyzer') and hasattr(self.dynamic_analyzer, 'attach_memory_script'):
                    self.update_output.emit(log_message("[Memory Analysis] Attaching Frida for memory allocation tracking..."))
                    try:
                        # This would inject a Frida script to monitor memory allocations
                        self.dynamic_analyzer.attach_memory_script(pid)
                        self.update_output.emit(log_message("[Memory Analysis] Memory tracking script attached successfully"))
                    except Exception as e:
                        self.update_output.emit(log_message(f"[Memory Analysis] Error attaching memory script: {str(e)}"))

                # Summary
                self.analyze_results.append("\n=== MEMORY ANALYSIS SUMMARY ===")
                self.analyze_results.append(f"Process ID: {pid}")
                self.analyze_results.append(f"Total memory usage: {mem_info.rss / (1024*1024):.2f} MB")
                self.analyze_results.append(f"Virtual memory size: {mem_info.vms / (1024*1024):.2f} MB")
                self.analyze_results.append(f"Executable memory regions: {len(executable_regions)}")
                self.analyze_results.append(f"Writable memory regions: {len(writable_regions)}")
                self.analyze_results.append(f"RWX memory regions: {len(suspicious_regions)}")

                self.update_output.emit(log_message("[Memory Analysis] Memory analysis completed successfully"))
            else:
                self.update_output.emit(log_message("[Memory Analysis] Error: Could not get target process ID"))
        else:
            # Static analysis fallback
            self.update_output.emit(log_message("[Memory Analysis] Dynamic analyzer not available. Performing static memory analysis..."))

            # Analyze PE file section memory characteristics
            try:
                pe = pefile.PE(self.binary_path)

                self.update_output.emit(log_message("[Memory Analysis] Analyzing memory characteristics from PE headers..."))

                # Check for suspicious section permissions
                suspicious_sections = []
                for section in pe.sections:
                    section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')

                    # Check if section is both writable and executable (security risk)
                    if (section.Characteristics & 0x20000000) and (section.Characteristics & 0x80000000):
                        suspicious_sections.append(section_name)
                        self.update_output.emit(log_message(f"[Memory Analysis] WARNING: Section {section_name} is both writable and executable"))

                if suspicious_sections:
                    self.analyze_results.append("\n=== MEMORY SECURITY ANALYSIS (STATIC) ===")
                    self.analyze_results.append(f"Found {len(suspicious_sections)} PE sections with RWX permissions (security risk)")
                    self.analyze_results.append("Sections: " + ", ".join(suspicious_sections))
                    self.analyze_results.append("These sections could be used for shellcode execution or code injection attacks")

                # Analyze stack security
                has_stack_protection = False
                if hasattr(pe, 'OPTIONAL_HEADER') and hasattr(pe.OPTIONAL_HEADER, 'DllCharacteristics'):
                    if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100:  # IMAGE_DLLCHARACTERISTICS_NX_COMPAT
                        has_stack_protection = True
                        self.update_output.emit(log_message("[Memory Analysis] Binary has DEP/NX protection enabled"))

                    if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0400:  # IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
                        self.update_output.emit(log_message("[Memory Analysis] Binary has ASLR support enabled"))

                if not has_stack_protection:
                    self.update_output.emit(log_message("[Memory Analysis] WARNING: Binary does not have DEP/NX protection"))
                    self.analyze_results.append("Binary does not have DEP/NX protection - stack executable (security risk)")

                # Estimate memory usage based on section sizes
                estimated_memory = sum(section.Misc_VirtualSize for section in pe.sections)
                self.update_output.emit(log_message(f"[Memory Analysis] Estimated memory usage: {estimated_memory / (1024*1024):.2f} MB"))

                # Check for memory-related imports
                memory_apis = ['HeapAlloc', 'VirtualAlloc', 'malloc', 'GlobalAlloc', 'LocalAlloc', 'CoTaskMemAlloc']
                detected_apis = []

                if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        for imp in entry.imports:
                            if imp.name:
                                func_name = imp.name.decode('utf-8', errors='ignore')
                                if any(api in func_name for api in memory_apis):
                                    detected_apis.append(func_name)

                if detected_apis:
                    self.update_output.emit(log_message(f"[Memory Analysis] Detected {len(detected_apis)} memory allocation APIs"))
                    for api in detected_apis[:5]:  # Show first 5
                        self.update_output.emit(log_message(f"[Memory Analysis] Memory API: {api}"))

                # Summary for static analysis
                self.analyze_results.append("\n=== STATIC MEMORY ANALYSIS SUMMARY ===")
                self.analyze_results.append(f"Estimated memory footprint: {estimated_memory / (1024*1024):.2f} MB")
                self.analyze_results.append(f"Memory allocation APIs detected: {len(detected_apis)}")
                self.analyze_results.append(f"DEP/NX Protection: {'Enabled' if has_stack_protection else 'Disabled'}")

                self.update_output.emit(log_message("[Memory Analysis] Static memory analysis completed"))

            except Exception as e:
                self.update_output.emit(log_message(f"[Memory Analysis] Error during static analysis: {str(e)}"))

    except Exception as e:
        self.update_output.emit(log_message(f"[Memory Analysis] Error during memory analysis: {str(e)}"))
        self.update_output.emit(log_message(f"[Memory Analysis] Traceback: {traceback.format_exc()}"))

def run_network_analysis(self):
    """
    Run comprehensive network analysis on the target application.

    Monitors network traffic, identifies protocols in use, detects potential security
    issues, and analyzes network-related API calls made by the application. Works with
    both active processes and static binaries.
    """
    if not self.binary_path:
        QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
        return

    self.update_output.emit(log_message("[Network Analysis] Starting comprehensive network analysis..."))

    try:
        # First check if we already have network capture data
        has_existing_data = False
        if hasattr(self, 'traffic_samples') and self.traffic_samples:
            has_existing_data = True
            sample_count = len(self.traffic_samples)
            self.update_output.emit(log_message(f"[Network Analysis] Using {sample_count} existing traffic samples"))

        if not has_existing_data:
            # Start capturing if we don't have data and analyzer is available
            if hasattr(self, 'start_network_capture'):
                self.update_output.emit(log_message("[Network Analysis] No existing data found. Starting network capture..."))
                capture_result = self.start_network_capture()

                if capture_result:
                    self.update_output.emit(log_message("[Network Analysis] Network capture started successfully"))
                    self.update_output.emit(log_message("[Network Analysis] Waiting for traffic (10 seconds)..."))

                    # Wait a short time to collect some traffic
                    time.sleep(10)
                else:
                    self.update_output.emit(log_message("[Network Analysis] Failed to start network capture"))

        # Static analysis of network capabilities
        self.update_output.emit(log_message("[Network Analysis] Analyzing network capabilities from binary..."))

        # Define common networking and protocol APIs
        network_apis = {
            'basic': ['socket', 'connect', 'bind', 'listen', 'accept', 'send', 'recv', 'recvfrom'],
            'http': ['HttpOpenRequest', 'InternetConnect', 'WinHttpConnect', 'curl_easy', 'libcurl'],
            'ssl': ['SSL_connect', 'SSL_read', 'SSL_write', 'SslCreateContext', 'CryptAcquireContext'],
            'dns': ['gethostbyname', 'DnsQuery', 'getaddrinfo', 'WSAGetLastError'],
            'udp': ['sendto', 'recvfrom', 'UdpConnectClient'],
            'license': ['LicenseCheck', 'VerifyLicense', 'Activate', 'Register']
        }

        detected_apis = {category: [] for category in network_apis}

        try:
            # Load binary for static analysis
            pe = pefile.PE(self.binary_path)

            # Analyze imports for network-related APIs
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', errors='ignore').lower()

                    # Check if this DLL is network-related
                    network_dlls = ['ws2_32.dll', 'wsock32.dll', 'wininet.dll', 'winhttp.dll', 'urlmon.dll', 'cryptui.dll']
                    is_network_dll = any(net_dll in dll_name for net_dll in network_dlls)

                    if is_network_dll:
                        self.update_output.emit(log_message(f"[Network Analysis] Found networking DLL: {dll_name}"))

                    # Check imported functions
                    for imp in entry.imports:
                        if not imp.name:
                            continue

                        func_name = imp.name.decode('utf-8', errors='ignore')

                        # Check each category of network APIs
                        for category, apis in network_apis.items():
                            if any(api.lower() in func_name.lower() for api in apis):
                                detected_apis[category].append(func_name)

                                # Log first few detections in each category
                                if len(detected_apis[category]) <= 3:
                                    self.update_output.emit(log_message(f"[Network Analysis] Found {category} API: {func_name}"))

            # Summarize static findings
            self.analyze_results.append("\n=== NETWORK CAPABILITY ANALYSIS ===")

            for category, apis in detected_apis.items():
                if apis:
                    self.analyze_results.append(f"{category.upper()} APIs: {len(apis)}")
                    # List first few APIs detected in each category
                    for api in apis[:5]:
                        self.analyze_results.append(f"  - {api}")

            # Security assessment
            security_issues = []

            # Check for insecure communication
            has_ssl = bool(detected_apis['ssl'])
            has_network = bool(detected_apis['basic']) or bool(detected_apis['http'])

            if has_network and not has_ssl:
                issue = "Application uses network APIs without SSL/TLS - potentially insecure communication"
                security_issues.append(issue)
                self.update_output.emit(log_message(f"[Network Analysis] WARNING: {issue}"))

            # String analysis for URLs and IP addresses
            self.update_output.emit(log_message("[Network Analysis] Searching for embedded URLs and IP addresses..."))

            with open(self.binary_path, 'rb') as f:
                binary_data = f.read()

                # URL pattern
                # Fixed regex pattern with raw string to avoid escape sequence warning
                url_pattern = re.compile(br'https?://[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+(?:/[^\s]*)?')
                urls = url_pattern.findall(binary_data)

                # IP address pattern
                # Fixed regex pattern with raw string to avoid escape sequence warning
                ip_pattern = re.compile(br'(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)')
                ips = ip_pattern.findall(binary_data)

                if urls:
                    unique_urls = set(url.decode('utf-8', errors='ignore') for url in urls)
                    self.update_output.emit(log_message(f"[Network Analysis] Found {len(unique_urls)} embedded URLs"))

                    self.analyze_results.append("\n=== EMBEDDED URLs ===")
                    for url in list(unique_urls)[:10]:  # Show first 10
                        self.analyze_results.append(url)

                    # Check for hardcoded credentials in URLs
                    auth_urls = [url for url in unique_urls if '@' in url]
                    if auth_urls:
                        issue = "Found URLs with embedded credentials - security risk"
                        security_issues.append(issue)
                        self.update_output.emit(log_message(f"[Network Analysis] WARNING: {issue}"))

                if ips:
                    unique_ips = set(ip.decode('utf-8', errors='ignore') for ip in ips)
                    self.update_output.emit(log_message(f"[Network Analysis] Found {len(unique_ips)} embedded IP addresses"))

                    self.analyze_results.append("\n=== EMBEDDED IP ADDRESSES ===")
                    for ip in list(unique_ips)[:10]:  # Show first 10
                        self.analyze_results.append(ip)

                    # Check for private IPs
                    private_ips = [ip for ip in unique_ips if ip.startswith(('10.', '192.168.', '172.16.', '172.17.', '172.18.'))]
                    if private_ips:
                        self.update_output.emit(log_message(f"[Network Analysis] Found {len(private_ips)} private IP addresses hardcoded"))

        except Exception as e:
            self.update_output.emit(log_message(f"[Network Analysis] Error during static analysis: {str(e)}"))

        # Dynamic analysis results if available
        if hasattr(self, 'traffic_recorder') and self.traffic_recorder:
            traffic_summary = self.traffic_recorder.get_traffic_summary()

            if traffic_summary:
                self.update_output.emit(log_message("[Network Analysis] Analyzing captured network traffic..."))

                # Process traffic summary
                total_packets = traffic_summary.get('total_packets', 0)
                protocols = traffic_summary.get('protocols', {})
                destinations = traffic_summary.get('destinations', {})

                self.update_output.emit(log_message(f"[Network Analysis] Captured {total_packets} packets"))

                # Protocol breakdown
                if protocols:
                    self.analyze_results.append("\n=== PROTOCOL ANALYSIS ===")
                    for protocol, count in sorted(protocols.items(), key=lambda x: x[1], reverse=True):
                        percentage = (count / total_packets) * 100 if total_packets > 0 else 0
                        self.analyze_results.append(f"{protocol}: {count} packets ({percentage:.1f}%)")
                        self.update_output.emit(log_message(f"[Network Analysis] Protocol: {protocol} - {count} packets"))

                # Destination breakdown
                if destinations:
                    self.analyze_results.append("\n=== CONNECTION DESTINATIONS ===")
                    for dest, count in sorted(destinations.items(), key=lambda x: x[1], reverse=True)[:10]:
                        self.analyze_results.append(f"{dest}: {count} packets")

                # Security assessment from traffic
                if protocols.get('HTTP', 0) > 0 and protocols.get('HTTPS', 0) == 0:
                    issue = "Application uses insecure HTTP without HTTPS"
                    security_issues.append(issue)
                    self.update_output.emit(log_message(f"[Network Analysis] WARNING: {issue}"))

                # DNS analysis
                if hasattr(self.traffic_recorder, 'get_dns_queries'):
                    dns_queries = self.traffic_recorder.get_dns_queries()
                    if dns_queries:
                        self.analyze_results.append("\n=== DNS QUERIES ===")
                        for query in dns_queries[:10]:  # Show first 10
                            self.analyze_results.append(query)
            else:
                self.update_output.emit(log_message("[Network Analysis] No traffic capture data available"))

        # Live process connections if possible
        if hasattr(self, 'dynamic_analyzer') and self.dynamic_analyzer:
            pid = self.dynamic_analyzer.get_target_pid()
            if pid:
                try:
                    process = psutil.Process(pid)
                    connections = process.connections()

                    if connections:
                        self.update_output.emit(log_message(f"[Network Analysis] Found {len(connections)} active connections"))

                        # Analyze connections
                        self.analyze_results.append("\n=== ACTIVE NETWORK CONNECTIONS ===")

                        for conn in connections:
                            status = conn.status if hasattr(conn, 'status') else 'UNKNOWN'
                            family = 'IPv4' if conn.family == socket.AF_INET else 'IPv6' if conn.family == socket.AF_INET6 else 'UNIX' if conn.family == socket.AF_UNIX else 'UNKNOWN'

                            if conn.laddr:
                                local = f"{conn.laddr[0]}:{conn.laddr[1]}" if len(conn.laddr) >= 2 else str(conn.laddr)
                            else:
                                local = "N/A"

                            if hasattr(conn, 'raddr') and conn.raddr:
                                remote = f"{conn.raddr[0]}:{conn.raddr[1]}" if len(conn.raddr) >= 2 else str(conn.raddr)
                            else:
                                remote = "N/A"

                            conn_info = f"{family} {conn.type} {status}: {local} -> {remote}"
                            self.analyze_results.append(conn_info)

                            # Log first few connections
                            if len(self.analyze_results) < 15:  # Limit logging
                                self.update_output.emit(log_message(f"[Network Analysis] Connection: {conn_info}"))
                    else:
                        self.update_output.emit(log_message("[Network Analysis] No active network connections found"))
                except Exception as e:
                    self.update_output.emit(log_message(f"[Network Analysis] Error checking connections: {str(e)}"))

        # Summarize security issues
        if security_issues:
            self.analyze_results.append("\n=== NETWORK SECURITY ISSUES ===")
            for issue in security_issues:
                self.analyze_results.append(f"⚠️ {issue}")

        # Final summary
        self.update_output.emit(log_message("[Network Analysis] Network analysis completed successfully"))

        categories_found = sum(1 for apis in detected_apis.values() if apis)
        self.update_output.emit(log_message(f"[Network Analysis] Found {categories_found} network API categories in use"))

        # Check if we need to stop a running capture
        if not has_existing_data and hasattr(self, 'stop_network_capture'):
            self.stop_network_capture()

    except Exception as e:
        self.update_output.emit(log_message(f"[Network Analysis] Error during network analysis: {str(e)}"))
        self.update_output.emit(log_message(f"[Network Analysis] Traceback: {traceback.format_exc()}"))

# -------------------------------
# Helper Methods for New Tabs
# -------------------------------

# Patching tab helpers
def run_patching(self):
    """Run the patching process based on selected strategy"""
    strategy = "Automatic"
    if self.strategy_targeted_radio.isChecked():
        strategy = "Targeted"
        target_type = self.target_type_combo.currentText()
        self.update_output.emit(log_message(f"[Patching] Running {strategy} patching targeting {target_type}..."))
    elif self.strategy_custom_radio.isChecked():
        strategy = "Custom"
        self.update_output.emit(log_message(f"[Patching] Running {strategy} patching..."))
    else:
        self.update_output.emit(log_message(f"[Patching] Running {strategy} patching..."))

    # Additional patching options
    options = []
    if self.patch_stealth_cb.isChecked():
        options.append("Stealth Mode")
    if self.patch_backup_cb.isChecked():
        options.append("Create Backups")
    if self.patch_certificate_cb.isChecked():
        options.append("Preserve Signatures")
    if self.patch_metadata_cb.isChecked():
        options.append("Update Metadata")

    if options:
        self.update_output.emit(log_message(f"[Patching] Options: {', '.join(options)}"))

    # Perform the actual patching
    self.update_output.emit(log_message(f"[Patching] Starting patching process with {strategy} strategy..."))

    try:
        # Create backup first if requested
        if "Create Backups" in options:
            backup_path = f"{self.binary_path}.bak"
            self.update_output.emit(log_message(f"[Patching] Creating backup at {backup_path}"))
            shutil.copy2(self.binary_path, backup_path)

        # Different patching strategies
        if strategy == "Deep Analysis":
            result = self._apply_deep_analysis_patches()
        elif strategy == "Manual Patch":
            result = self._apply_manual_patches()
        elif strategy == "Memory Patching":
            result = self._apply_memory_patches()
        elif strategy == "Import Patching":
            result = self._apply_import_patches()
        else:
            result = {"success": False, "error": f"Unknown strategy: {strategy}"}

        # Handle the result
        if result.get("success"):
            self.update_output.emit(log_message(f"[Patching] Successfully applied {result.get('count', 0)} patches"))
            QMessageBox.information(self, "Patching Complete",
                                   f"Successfully applied {result.get('count', 0)} patches to the binary.\n\n"
                                   f"Details: {result.get('message', '')}")

            # Update the patch list
            self.refresh_patch_list()

            # Add to the analysis results
            self.analyze_results.append(f"\n=== PATCHING RESULTS ===")
            self.analyze_results.append(f"Strategy: {strategy}")
            self.analyze_results.append(f"Patches applied: {result.get('count', 0)}")
            for detail in result.get('details', []):
                self.analyze_results.append(f"  - {detail}")

        else:
            error_msg = result.get("error", "Unknown error")
            self.update_output.emit(log_message(f"[Patching] Error: {error_msg}"))
            QMessageBox.warning(self, "Patching Failed",
                               f"Failed to apply patches: {error_msg}\n\n"
                               f"See the logs for more details.")

    except Exception as e:
        self.update_output.emit(log_message(f"[Patching] Exception during patching: {str(e)}"))
        self.update_output.emit(log_message(traceback.format_exc()))
        QMessageBox.critical(self, "Patching Error",
                            f"An exception occurred during patching:\n{str(e)}")

def refresh_patch_list(self):
    """Refresh the list of patches"""
    self.update_output.emit(log_message("[Patching] Refreshing patch list..."))

    # Clear existing data
    self.patches_table.setRowCount(0)

    # Add sample data
    sample_patches = [
        ("P001", "License Check", "0x00402E10", "Ready", ""),
        ("P002", "Trial Expiration", "0x00403F50", "Applied", ""),
        ("P003", "Network Validation", "0x00404820", "Ready", ""),
        ("P004", "Hardware Check", "0x00405A10", "Failed", "")
    ]

    self.patches_table.setRowCount(len(sample_patches))

    for i, (patch_id, patch_type, location, status, _) in enumerate(sample_patches):
        self.patches_table.setItem(i, 0, QTableWidgetItem(patch_id))
        self.patches_table.setItem(i, 1, QTableWidgetItem(patch_type))
        self.patches_table.setItem(i, 2, QTableWidgetItem(location))
        self.patches_table.setItem(i, 3, QTableWidgetItem(status))

        actions_widget = QWidget()
        actions_layout = QHBoxLayout(actions_widget)
        actions_layout.setContentsMargins(0, 0, 0, 0)

        apply_btn = QPushButton("Apply")
        apply_btn.setFixedWidth(60)
        apply_btn.clicked.connect(lambda checked, row=i: self.apply_patch(row))

        revert_btn = QPushButton("Revert")
        revert_btn.setFixedWidth(60)
        revert_btn.clicked.connect(lambda checked, row=i: self.revert_patch(row))

        edit_btn = QPushButton("Edit")
        edit_btn.setFixedWidth(60)
        edit_btn.clicked.connect(lambda checked, row=i: self.edit_patch(row))

        actions_layout.addWidget(apply_btn)
        actions_layout.addWidget(revert_btn)
        actions_layout.addWidget(edit_btn)

        self.patches_table.setCellWidget(i, 4, actions_widget)

def apply_patch(self, row):
    """Apply a single patch"""
    patch_id = self.patches_table.item(row, 0).text()
    patch_type = self.patches_table.item(row, 1).text()
    self.update_output.emit(log_message(f"[Patching] Applying patch {patch_id} ({patch_type})..."))
    self.patches_table.setItem(row, 3, QTableWidgetItem("Applied"))

def revert_patch(self, row):
    """Revert a single patch"""
    patch_id = self.patches_table.item(row, 0).text()
    self.update_output.emit(log_message(f"[Patching] Reverting patch {patch_id}..."))
    self.patches_table.setItem(row, 3, QTableWidgetItem("Ready"))

def edit_patch(self, row):
    """Edit a single patch"""
    patch_id = self.patches_table.item(row, 0).text()
    self.update_output.emit(log_message(f"[Patching] Editing patch {patch_id}..."))
    QMessageBox.information(self, "Edit Patch", f"Editing patch {patch_id} would open the editor")

def apply_all_patches(self):
    """Apply all patches in the list"""
    self.update_output.emit(log_message("[Patching] Applying all patches..."))

    for row in range(self.patches_table.rowCount()):
        self.patches_table.setItem(row, 3, QTableWidgetItem("Applied"))

    QMessageBox.information(self, "Apply All Patches", "All patches have been applied")

def revert_all_patches(self):
    """Revert all patches in the list"""
    self.update_output.emit(log_message("[Patching] Reverting all patches..."))

    for row in range(self.patches_table.rowCount()):
        self.patches_table.setItem(row, 3, QTableWidgetItem("Ready"))

    QMessageBox.information(self, "Revert All Patches", "All patches have been reverted")

def export_patches(self):
    """Export patches to a file"""
    self.update_output.emit(log_message("[Patching] Exporting patches..."))
    QMessageBox.information(self, "Export Patches", "Patches would be exported to a file")

def run_patch_test(self):
    """Run tests for the applied patches"""
    env_type = self.env_type_combo.currentText()
    self.update_output.emit(log_message(f"[Patching] Running patch tests in {env_type} environment..."))

    options = []
    if self.test_network_cb.isChecked():
        options.append("Network Emulation")
    if self.test_memory_cb.isChecked():
        options.append("Memory Analysis")
    if self.test_api_cb.isChecked():
        options.append("API Monitoring")
    if self.test_coverage_cb.isChecked():
        options.append("Coverage Analysis")

    if options:
        self.update_output.emit(log_message(f"[Testing] Options: {', '.join(options)}"))

    # Show test results
    self.test_results_text.clear()
    self.test_results_text.append("==== Patch Test Results ====\n")
    self.test_results_text.append(f"Environment: {env_type}\n")
    self.test_results_text.append(f"Options: {', '.join(options) if options else 'None'}\n")
    self.test_results_text.append("\nTest 1: License Check Bypass... PASSED")
    self.test_results_text.append("Test 2: Trial Restriction Removal... PASSED")
    self.test_results_text.append("Test 3: Network Validation Bypass... PASSED")
    self.test_results_text.append("Test 4: Hardware Check Modification... FAILED")
    self.test_results_text.append("\nOverall Result: 3/4 tests passed (75%)")

def verify_patch_results(self):
    """Verify the results of patch testing"""
    self.update_output.emit(log_message("[Patching] Verifying patch results..."))

    # Add more detail to test results
    self.test_results_text.append("\n\n==== Detailed Verification ====")
    self.test_results_text.append("\nLicense Check Bypass:")
    self.test_results_text.append("- Original behavior: Application exits with error code 0xE001")
    self.test_results_text.append("- Patched behavior: Application continues normal execution")
    self.test_results_text.append("- Verification method: Process exit code monitoring")

    self.test_results_text.append("\nHardware Check Modification:")
    self.test_results_text.append("- Original behavior: Application checks CPU ID at 0x00405A10")
    self.test_results_text.append("- Patched behavior: Check still occurs but with modified comparison")
    self.test_results_text.append("- Verification method: Memory tracing")
    self.test_results_text.append("- Failure reason: The patch modifies the comparison but hardware ID is checked in multiple locations")

    QMessageBox.information(self, "Verification", "Verification process complete.")

# Network tab helpers
def start_network_capture(self):
    """Start capturing network traffic"""
    interface = self.interface_combo.currentText()
    filter_text = self.filter_input.text()

    self.update_output.emit(log_message(f"[Network] Starting capture on {interface} with filter: {filter_text if filter_text else 'none'}"))

    # Clear existing data
    self.traffic_table.setRowCount(0)

    # Add sample data
    sample_traffic = [
        ("12:34:56", "192.168.1.2", "93.184.216.34", "TCP", "74", "SYN"),
        ("12:34:57", "93.184.216.34", "192.168.1.2", "TCP", "74", "SYN, ACK"),
        ("12:34:57", "192.168.1.2", "93.184.216.34", "TCP", "66", "ACK"),
        ("12:34:58", "192.168.1.2", "93.184.216.34", "HTTP", "128", "GET /index.html"),
        ("12:34:59", "93.184.216.34", "192.168.1.2", "HTTP", "1024", "200 OK")
    ]

    self.traffic_table.setRowCount(len(sample_traffic))

    for i, (timestamp, src, dst, proto, length, info) in enumerate(sample_traffic):
        self.traffic_table.setItem(i, 0, QTableWidgetItem(timestamp))
        self.traffic_table.setItem(i, 1, QTableWidgetItem(src))
        self.traffic_table.setItem(i, 2, QTableWidgetItem(dst))
        self.traffic_table.setItem(i, 3, QTableWidgetItem(proto))
        self.traffic_table.setItem(i, 4, QTableWidgetItem(length))
        self.traffic_table.setItem(i, 5, QTableWidgetItem(info))

def stop_network_capture(self):
    """Stop capturing network traffic"""
    self.update_output.emit(log_message("[Network] Stopping capture"))
    QMessageBox.information(self, "Network Capture", "Network capture stopped")

def clear_network_capture(self):
    """Clear captured network data"""
    self.update_output.emit(log_message("[Network] Clearing capture data"))
    self.traffic_table.setRowCount(0)

def start_license_server(self):
    """Start the license server emulation"""
    address = self.server_addr_input.text()
    port = self.server_port_input.text()
    protocol = self.server_protocol_combo.currentText()
    response_type = self.server_response_combo.currentText()

    self.update_output.emit(log_message(f"[Server] Starting license server on {address}:{port} ({protocol})"))

    # Show server logs
    self.server_logs_text.clear()
    self.server_logs_text.append(f"[INFO] Server starting on {address}:{port}")
    self.server_logs_text.append(f"[INFO] Protocol: {protocol}")
    self.server_logs_text.append(f"[INFO] Response type: {response_type}")
    self.server_logs_text.append("[INFO] Server ready to accept connections")

    QMessageBox.information(self, "License Server", f"License server started on {address}:{port}")

def stop_license_server(self):
    """Stop the license server emulation"""
    self.update_output.emit(log_message("[Server] Stopping license server"))

    # Show server logs
    self.server_logs_text.append("[INFO] Server shutdown initiated")
    self.server_logs_text.append("[INFO] Active connections closed")
    self.server_logs_text.append("[INFO] Server stopped")

    QMessageBox.information(self, "License Server", "License server stopped")

def test_license_server(self):
    """Test the license server emulation"""
    self.update_output.emit(log_message("[Server] Testing license server"))

    # Show server logs
    self.server_logs_text.append("[TEST] Testing server connectivity...")
    self.server_logs_text.append("[TEST] Sending test request...")
    self.server_logs_text.append("[INFO] Received connection from 127.0.0.1:45678")
    self.server_logs_text.append("[INFO] Request received: GET /validate?key=TEST-KEY")
    self.server_logs_text.append("[INFO] Sending response: 200 OK")
    self.server_logs_text.append("[TEST] Test successful!")

    QMessageBox.information(self, "Server Test", "License server test successful")

def launch_protocol_tool(self):
    """Launch the selected protocol tool"""
    tool = self.protocol_tool_combo.currentText()
    self.update_output.emit(log_message(f"[Network] Launching {tool}"))

    QMessageBox.information(self, "Protocol Tool", f"Launching {tool}")

    # Add to recent tools
    self.recent_tools_list.insertItem(0, f"{tool} (just now)")

def update_protocol_tool_description(self, tool):
    """Update the description for the selected protocol tool"""
    descriptions = {
        "SSL/TLS Interceptor": "Intercepts and decrypts SSL/TLS traffic for analysis. Supports certificate generation and man-in-the-middle capabilities.",
        "Protocol Analyzer": "Analyzes communication protocols to identify patterns and structures. Useful for reverse engineering proprietary protocols.",
        "API Request Builder": "Build and send custom API requests to test endpoints and authentication. Supports various authentication methods.",
        "Authentication Fuzzer": "Tests authentication mechanisms by generating various inputs to identify weaknesses and bypasses."
    }

    self.tool_description_label.setText(descriptions.get(tool, "No description available"))

# Reports tab helpers
def generate_report(self):
    """Generate a report based on selected options"""
    template = self.report_template_combo.currentText()
    report_format = self.report_format_combo.currentText()

    options = []
    if self.include_binary_info_cb.isChecked():
        options.append("Binary Information")
    if self.include_patches_cb.isChecked():
        options.append("Patch Details")
    if self.include_graphs_cb.isChecked():
        options.append("Graphs & Charts")
    if self.include_network_cb.isChecked():
        options.append("Network Analysis")

    self.update_output.emit(log_message(f"[Reports] Generating {template} in {format} format"))
    if options:
        self.update_output.emit(log_message(f"[Reports] Including: {', '.join(options)}"))

    # Add to the reports table
    current_time = datetime.datetime.now().strftime("%Y-%m-%d")
    new_row = self.reports_table.rowCount()
    self.reports_table.setRowCount(new_row + 1)

    report_name = f"Report_{current_time}_{template.replace(' ', '_')}"
    self.reports_table.setItem(new_row, 0, QTableWidgetItem(report_name))
    self.reports_table.setItem(new_row, 1, QTableWidgetItem(current_time))
    self.reports_table.setItem(new_row, 2, QTableWidgetItem(format))

    actions_widget = QWidget()
    actions_layout = QHBoxLayout(actions_widget)
    actions_layout.setContentsMargins(0, 0, 0, 0)

    view_btn = QPushButton("View")
    view_btn.setFixedWidth(60)
    view_btn.clicked.connect(lambda _, r=new_row: self.view_report(r))

    export_btn = QPushButton("Export")
    export_btn.setFixedWidth(60)
    export_btn.clicked.connect(lambda _, r=new_row: self.export_report(r))

    delete_btn = QPushButton("Delete")
    delete_btn.setFixedWidth(60)
    delete_btn.clicked.connect(lambda _, r=new_row: self.delete_report(r))

    actions_layout.addWidget(view_btn)
    actions_layout.addWidget(export_btn)
    actions_layout.addWidget(delete_btn)

    self.reports_table.setCellWidget(new_row, 3, actions_widget)

    QMessageBox.information(self, "Report Generation", f"Report '{report_name}' generated successfully")

def view_report(self, row):
    """View a generated report in an appropriate viewer based on format"""
    report_name = self.reports_table.item(row, 0).text()
    report_type = self.reports_table.item(row, 1).text()
    report_format = self.reports_table.item(row, 2).text()

    self.update_output.emit(log_message(f"[Reports] Viewing report: {report_name} ({report_format})"))

    # Get report path
    reports_dir = os.path.join(os.getcwd(), "reports")
    if not os.path.exists(reports_dir):
        os.makedirs(reports_dir)

    # Sanitize filename
    safe_name = ''.join(c for c in report_name if c.isalnum() or c in (' ', '.', '_', '-')).replace(' ', '_')
    report_path = os.path.join(reports_dir, f"{safe_name}.{report_format.lower()}")

    try:
        # Check if report exists
        if not os.path.exists(report_path):
            # Generate the report file if it doesn't exist
            self.update_output.emit(log_message(f"[Reports] Report file not found. Generating: {report_path}"))

            # Generate report based on type and format
            if report_format.lower() == "html":
                self._generate_html_report(report_name, report_type, report_path)
            elif report_format.lower() == "pdf":
                self._generate_pdf_report(report_name, report_type, report_path)
            else:
                self._generate_text_report(report_name, report_type, report_path)

        # Open the report based on its format
        if report_format.lower() == "html":
            # Create a QWebEngineView to display HTML reports
            try:
                # Create a new window for the report
                self.report_viewer = QDialog(self)
                self.report_viewer.setWindowTitle(f"Report: {report_name}")
                self.report_viewer.resize(900, 700)

                # Create layout
                layout = QVBoxLayout(self.report_viewer)

                # Create web view
                web_view = QWebEngineView()
                web_view.load(QUrl.fromLocalFile(report_path))

                # Create toolbar with actions
                toolbar = QHBoxLayout()

                # Add zoom controls
                zoom_in_btn = QPushButton("Zoom In")
                zoom_out_btn = QPushButton("Zoom Out")
                zoom_in_btn.clicked.connect(lambda: web_view.setZoomFactor(web_view.zoomFactor() + 0.1))
                zoom_out_btn.clicked.connect(lambda: web_view.setZoomFactor(web_view.zoomFactor() - 0.1))

                # Add print button
                print_btn = QPushButton("Print")
                print_btn.clicked.connect(web_view.page().print)

                # Add external browser button
                browser_btn = QPushButton("Open in Browser")
                browser_btn.clicked.connect(lambda: webbrowser.open(f"file://{report_path}"))

                # Add to toolbar
                toolbar.addWidget(zoom_in_btn)
                toolbar.addWidget(zoom_out_btn)
                toolbar.addWidget(print_btn)
                toolbar.addWidget(browser_btn)

                # Add to layout
                layout.addLayout(toolbar)
                layout.addWidget(web_view)

                # Show the report viewer
                self.report_viewer.show()

            except ImportError:
                # Fall back to system browser if Qt WebEngine is not available
                self.update_output.emit(log_message("[Reports] QWebEngineView not available, opening in system browser"))
                webbrowser.open(f"file://{report_path}")

        elif report_format.lower() == "pdf":
            # Try to use a PDF viewer if available, otherwise open with system default
            try:
                # Create viewer dialog
                self.report_viewer = QDialog(self)
                self.report_viewer.setWindowTitle(f"PDF Report: {report_name}")
                self.report_viewer.resize(900, 700)

                # Create layout
                layout = QVBoxLayout(self.report_viewer)

                # Check if PyQt5 PDF modules are available
                if 'HAS_PDF_SUPPORT' in globals() and HAS_PDF_SUPPORT:
                    # Create PDF viewer
