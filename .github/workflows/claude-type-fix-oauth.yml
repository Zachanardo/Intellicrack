name: Claude Type Error Auto-Fix (OAuth + API Key)

on:
  workflow_dispatch:
    inputs:
      max_errors:
        description: 'Maximum errors to process per run'
        required: false
        default: '50'
      checker:
        description: 'Type checker to use'
        required: false
        default: 'mypy'
        type: choice
        options:
          - mypy
          - pyright
      create_pr:
        description: 'Create PR instead of direct commit'
        required: false
        default: 'true'
        type: boolean

  push:
    branches:
      - main
    paths:
      - 'src/**/*.py'
      - 'intellicrack/**/*.py'

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: type-fix-${{ github.ref }}
  cancel-in-progress: false

jobs:
  fix-type-errors:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Pixi environment
        uses: prefix-dev/setup-pixi@v0.8.1
        with:
          pixi-version: latest
          cache: true

      - name: Determine authentication method
        id: auth
        run: |
          if [ -n "${{ secrets.CLAUDE_ACCESS_TOKEN }}" ]; then
            echo "auth_method=oauth" >> $GITHUB_OUTPUT
            echo "‚úÖ Using Claude OAuth authentication (FREE for Max/Pro subscribers)"
          elif [ -n "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            echo "auth_method=api_key" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using Anthropic API key authentication (pay-per-token)"
          else
            echo "‚ùå No authentication method available!"
            echo "Please set either CLAUDE_ACCESS_TOKEN (OAuth) or ANTHROPIC_API_KEY secrets"
            exit 1
          fi

      - name: Install Python dependencies
        run: |
          pip install anthropic requests

      - name: Create working branch
        if: inputs.create_pr != 'false'
        run: |
          BRANCH_NAME="automated-type-fixes-$(date +%Y%m%d-%H%M%S)"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          git checkout -b "$BRANCH_NAME"

      - name: Run type checker and collect errors
        id: type_check
        run: |
          echo "Running ${{ github.event.inputs.checker || 'mypy' }} type checking..."

          if [ "${{ github.event.inputs.checker || 'mypy' }}" = "mypy" ]; then
            pixi run python -m mypy intellicrack/ --show-column-numbers --show-error-codes --no-error-summary 2>&1 | tee type_errors.txt || true
          else
            pixi run pyright intellicrack/ --outputjson 2>&1 | tee type_errors.txt || true
          fi

          ERROR_COUNT=$(grep -c "error:" type_errors.txt || echo "0")
          echo "error_count=$ERROR_COUNT" >> $GITHUB_OUTPUT

          if [ "$ERROR_COUNT" -eq "0" ]; then
            echo "‚úÖ No type errors found!"
            exit 0
          fi

          echo "Found $ERROR_COUNT type errors"

      - name: Fix type errors with Claude (OAuth or API Key)
        if: steps.type_check.outputs.error_count != '0'
        env:
          AUTH_METHOD: ${{ steps.auth.outputs.auth_method }}
          CLAUDE_ACCESS_TOKEN: ${{ secrets.CLAUDE_ACCESS_TOKEN }}
          CLAUDE_REFRESH_TOKEN: ${{ secrets.CLAUDE_REFRESH_TOKEN }}
          CLAUDE_EXPIRES_AT: ${{ secrets.CLAUDE_EXPIRES_AT }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          MAX_ERRORS: ${{ github.event.inputs.max_errors || '50' }}
        run: |
          python << 'PYTHON_SCRIPT'
          import os
          import json
          import re
          import time
          from pathlib import Path
          from datetime import datetime

          def get_oauth_client():
              """Get Anthropic client using OAuth tokens."""
              import anthropic

              access_token = os.environ["CLAUDE_ACCESS_TOKEN"]
              refresh_token = os.environ["CLAUDE_REFRESH_TOKEN"]
              expires_at = int(os.environ["CLAUDE_EXPIRES_AT"])

              current_time = int(time.time())

              if current_time >= expires_at:
                  print("üîÑ OAuth token expired, refreshing...")
                  import requests

                  response = requests.post(
                      "https://api.anthropic.com/v1/oauth/token",
                      json={
                          "grant_type": "refresh_token",
                          "refresh_token": refresh_token,
                      },
                      headers={"Content-Type": "application/json"}
                  )

                  if response.status_code == 200:
                      tokens = response.json()
                      access_token = tokens["access_token"]

                      with open(os.environ['GITHUB_ENV'], 'a') as f:
                          f.write(f"CLAUDE_ACCESS_TOKEN={access_token}\n")
                          f.write(f"CLAUDE_EXPIRES_AT={tokens['expires_at']}\n")

                      print("‚úÖ Token refreshed successfully")
                  else:
                      print(f"‚ùå Token refresh failed: {response.text}")
                      raise Exception("OAuth token refresh failed")

              return anthropic.Anthropic(
                  api_key=access_token,
                  base_url="https://api.anthropic.com"
              )

          def get_api_key_client():
              """Get Anthropic client using API key."""
              import anthropic
              return anthropic.Anthropic(api_key=os.environ["ANTHROPIC_API_KEY"])

          auth_method = os.environ["AUTH_METHOD"]

          if auth_method == "oauth":
              print("üîê Authenticating with Claude OAuth (FREE for Max/Pro subscribers)")
              client = get_oauth_client()
          else:
              print("üîê Authenticating with Anthropic API key (pay-per-token)")
              client = get_api_key_client()

          max_errors = int(os.environ.get("MAX_ERRORS", "50"))

          with open("type_errors.txt", "r") as f:
              all_errors = [line.strip() for line in f if "error:" in line.lower()]

          errors_to_process = all_errors[:max_errors]

          print(f"üìä Processing {len(errors_to_process)} of {len(all_errors)} total errors")

          prompt = f"""Fix the following type errors in the Intellicrack Python codebase.

For each error:
1. Read the relevant file
2. Understand the context and existing code patterns
3. Apply the MINIMAL fix needed (add type hints, fix incorrect types, etc.)
4. Use proper type hints with modern Python 3.12+ syntax
5. Use TYPE_CHECKING imports for forward references to avoid circular imports
6. Ensure the fix follows existing code style

CRITICAL RULES - FOLLOW STRICTLY:
- Add proper type hints using typing module or modern syntax (list[str], dict[str, int])
- Fix actual type mismatches with correct types
- NEVER use # type: ignore, # noqa, # pragma, or any disable comments
- FORBIDDEN: Any form of error suppression (type: ignore, mypy: ignore, pyright: ignore)
- REQUIRED: Add actual type hints - function signatures, variable annotations, return types
- Use TYPE_CHECKING for imports only needed for type checking
- Maintain existing functionality - DO NOT change logic
- Follow project conventions and existing patterns
- If you cannot fix an error properly, skip it - DO NOT suppress it

Type errors to fix:

{chr(10).join(errors_to_process)}

Provide your fixes in this EXACT format for each file:

FILE: path/to/file.py
OPERATION: edit
OLD:
```python
# exact old code that needs fixing (including surrounding context)
```
NEW:
```python
# exact new code with type fix applied
```
---

You can provide multiple edits for the same file. Make sure OLD code matches EXACTLY what's in the file."""

          print("üì§ Sending errors to Claude...")

          try:
              message = client.messages.create(
                  model="claude-sonnet-4-5-20250929",
                  max_tokens=16000,
                  temperature=0,
                  system="""You are a Python type checking expert. Fix type errors by:
1. Adding proper type hints with correct imports from typing module
2. Fixing type mismatches with correct types
3. Using modern Python 3.12+ syntax (list[str], dict[str, Any], etc.)
4. Using TYPE_CHECKING imports to avoid circular dependencies
5. Being minimally invasive - only change what's necessary

ABSOLUTE PROHIBITIONS:
- NEVER use # type: ignore comments
- NEVER use # mypy: ignore comments
- NEVER use # pyright: ignore comments
- NEVER use # noqa comments for type errors
- NEVER suppress errors - FIX them with proper type hints

If you cannot properly fix an error, skip it. Do not suppress it.

Output edits in the exact format requested.""",
                  messages=[{"role": "user", "content": prompt}]
              )

              response_text = message.content[0].text

              with open("claude_response.txt", "w") as f:
                  f.write(response_text)

              tokens_used = message.usage.input_tokens + message.usage.output_tokens

              print(f"‚úÖ Claude response received")
              print(f"üìä Tokens used: {tokens_used} (input: {message.usage.input_tokens}, output: {message.usage.output_tokens})")

              with open(os.environ['GITHUB_STEP_SUMMARY'], 'a') as f:
                  f.write(f"## Authentication Method\n")
                  f.write(f"**{auth_method.upper()}** - ")
                  if auth_method == "oauth":
                      f.write("FREE (Claude Max/Pro subscription)\n\n")
                  else:
                      cost_estimate = (tokens_used / 1_000_000) * 3.00  # ~$3 per million tokens
                      f.write(f"Pay-per-token (~${cost_estimate:.4f} this run)\n\n")
                  f.write(f"**Tokens used:** {tokens_used:,}\n\n")

          except Exception as e:
              print(f"‚ùå Error communicating with Claude: {e}")
              raise

          PYTHON_SCRIPT

      - name: Apply fixes from Claude
        if: steps.type_check.outputs.error_count != '0'
        id: apply_fixes
        run: |
          python << 'PYTHON_SCRIPT'
          import re
          from pathlib import Path

          with open("claude_response.txt", "r") as f:
              response = f.read()

          edit_pattern = re.compile(
              r'FILE:\s*(.+?)\n'
              r'OPERATION:\s*(\w+)\n'
              r'OLD:\s*\n```python\n(.*?)\n```\s*\n'
              r'NEW:\s*\n```python\n(.*?)\n```',
              re.DOTALL | re.MULTILINE
          )

          edits = edit_pattern.findall(response)

          if not edits:
              print("‚ö†Ô∏è  No structured edits found in Claude's response")
              print("Response preview:")
              print(response[:1000])
              exit(0)

          print(f"Found {len(edits)} edit operations")

          applied_count = 0
          failed_count = 0

          for file_path, operation, old_code, new_code in edits:
              file_path = file_path.strip()
              old_code = old_code.strip()
              new_code = new_code.strip()

              print(f"\n{'='*60}")
              print(f"Applying {operation} to {file_path}")

              try:
                  path = Path(file_path)

                  if not path.exists():
                      print(f"  ‚ö†Ô∏è  WARNING: File not found: {file_path}")
                      failed_count += 1
                      continue

                  content = path.read_text(encoding='utf-8')

                  if old_code not in content:
                      print(f"  ‚ö†Ô∏è  WARNING: Old code not found in {file_path}")
                      print(f"  Looking for:\n{old_code[:200]}")
                      failed_count += 1
                      continue

                  new_content = content.replace(old_code, new_code, 1)
                  path.write_text(new_content, encoding='utf-8')

                  print(f"  ‚úÖ SUCCESS: Applied edit to {file_path}")
                  applied_count += 1

              except Exception as e:
                  print(f"  ‚ùå ERROR: Failed to apply edit to {file_path}: {e}")
                  failed_count += 1

          print(f"\n{'='*60}")
          print(f"Summary:")
          print(f"  ‚úÖ Applied: {applied_count}")
          print(f"  ‚ùå Failed: {failed_count}")
          print(f"{'='*60}")

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"applied_count={applied_count}\n")
              f.write(f"failed_count={failed_count}\n")

          PYTHON_SCRIPT

      - name: Validate fixes (Syntax)
        if: steps.apply_fixes.outputs.applied_count != '0'
        run: |
          echo "üîç Validating Python syntax..."
          find intellicrack -name "*.py" -exec pixi run python -m py_compile {} \; || {
            echo "‚ùå Syntax errors found! Rolling back..."
            git checkout .
            exit 1
          }
          echo "‚úÖ All files have valid Python syntax"

      - name: Validate fixes (Type checking)
        if: steps.apply_fixes.outputs.applied_count != '0'
        id: verify
        run: |
          echo "üîç Re-running type checker to verify fixes..."

          if [ "${{ github.event.inputs.checker || 'mypy' }}" = "mypy" ]; then
            pixi run python -m mypy intellicrack/ --no-error-summary 2>&1 | tee verification_results.txt || true
          else
            pixi run pyright intellicrack/ 2>&1 | tee verification_results.txt || true
          fi

          NEW_ERROR_COUNT=$(grep -c "error:" verification_results.txt || echo "0")
          ORIGINAL_COUNT="${{ steps.type_check.outputs.error_count }}"
          FIXED_COUNT=$((ORIGINAL_COUNT - NEW_ERROR_COUNT))

          echo "fixed_count=$FIXED_COUNT" >> $GITHUB_OUTPUT
          echo "remaining_count=$NEW_ERROR_COUNT" >> $GITHUB_OUTPUT

          echo "üìä Results:"
          echo "  Original errors: $ORIGINAL_COUNT"
          echo "  Fixed: $FIXED_COUNT"
          echo "  Remaining: $NEW_ERROR_COUNT"

          if [ "$NEW_ERROR_COUNT" -gt "$ORIGINAL_COUNT" ]; then
            echo "‚ùå ERROR: Fixes introduced MORE errors! Rolling back..."
            git checkout .
            exit 1
          fi

      - name: Validate fixes (Linting)
        if: steps.apply_fixes.outputs.applied_count != '0'
        run: |
          echo "üîç Running ruff linter..."
          pixi run ruff check intellicrack/ --fix || {
            echo "‚ö†Ô∏è  Linting issues found - auto-fixing..."
          }
          echo "‚úÖ Linting validation complete"

      - name: Run tests (if available)
        if: steps.apply_fixes.outputs.applied_count != '0'
        continue-on-error: true
        run: |
          echo "üß™ Running test suite..."
          pixi run pytest tests/ -x --tb=short || {
            echo "‚ö†Ô∏è  Some tests failed - review required"
          }

      - name: Commit changes
        if: steps.apply_fixes.outputs.applied_count != '0'
        run: |
          git config user.name "claude-type-fixer[bot]"
          git config user.email "claude-type-fixer[bot]@users.noreply.github.com"

          git add -A

          cat > commit_message.txt << EOF
          fix: Auto-fix ${{ steps.verify.outputs.fixed_count }} type errors with Claude

          Fixed ${{ steps.verify.outputs.fixed_count }} type errors using Claude AI
          Remaining errors: ${{ steps.verify.outputs.remaining_count }}

          Type checker: ${{ github.event.inputs.checker || 'mypy' }}
          Authentication: ${{ steps.auth.outputs.auth_method }}
          Files modified: $(git diff --cached --name-only | wc -l)

          ü§ñ Generated with Claude Sonnet 4.5
          Co-Authored-By: Claude <noreply@anthropic.com>
          EOF

          git commit -F commit_message.txt

      - name: Create Pull Request
        if: steps.apply_fixes.outputs.applied_count != '0' && (inputs.create_pr != 'false' && github.event_name != 'schedule')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push origin "$BRANCH_NAME"

          cat > pr_body.md << EOF
          ## ü§ñ Automated Type Error Fixes

          This PR contains automated fixes for Python type errors detected by ${{ github.event.inputs.checker || 'mypy' }}.

          ### Summary
          - **Original errors**: ${{ steps.type_check.outputs.error_count }}
          - **Fixed**: ${{ steps.verify.outputs.fixed_count }}
          - **Remaining**: ${{ steps.verify.outputs.remaining_count }}
          - **Files modified**: $(git diff origin/main --name-only | wc -l)

          ### Authentication
          - **Method**: ${{ steps.auth.outputs.auth_method }}
          ${{ steps.auth.outputs.auth_method == 'oauth' && '- **Cost**: FREE (Claude Max/Pro subscription)' || '- **Cost**: Pay-per-token' }}

          ### Validation
          - ‚úÖ Python syntax validation passed
          - ‚úÖ Type checker re-run passed
          - ‚úÖ Linting validation passed
          - ${{ steps.test.outcome == 'success' && '‚úÖ' || '‚ö†Ô∏è' }} Test suite status

          ### Review Checklist
          - [ ] Type fixes are correct and minimal
          - [ ] No functional changes introduced
          - [ ] Imports are properly organized
          - [ ] Code style is consistent

          ---
          ü§ñ Generated with Claude Sonnet 4.5
          Co-Authored-By: Claude <noreply@anthropic.com>
          EOF

          gh pr create \
            --title "fix: Auto-fix ${{ steps.verify.outputs.fixed_count }} type errors" \
            --body-file pr_body.md \
            --label "automated" \
            --label "type-fixes"

      - name: Push directly to main (scheduled runs only)
        if: steps.apply_fixes.outputs.applied_count != '0' && github.event_name == 'schedule'
        run: |
          git push origin main

      - name: Create summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ü§ñ Type Error Auto-Fix Summary

          ## Results
          | Metric | Value |
          |--------|-------|
          | Original errors | ${{ steps.type_check.outputs.error_count || '0' }} |
          | Fixed | ${{ steps.verify.outputs.fixed_count || '0' }} |
          | Remaining | ${{ steps.verify.outputs.remaining_count || steps.type_check.outputs.error_count || '0' }} |
          | Applied edits | ${{ steps.apply_fixes.outputs.applied_count || '0' }} |
          | Failed edits | ${{ steps.apply_fixes.outputs.failed_count || '0' }} |

          ## Configuration
          - **Type Checker**: \`${{ github.event.inputs.checker || 'mypy' }}\`
          - **Max Errors**: ${{ github.event.inputs.max_errors || '50' }}
          - **Authentication**: ${{ steps.auth.outputs.auth_method || 'N/A' }}

          ## Status
          ${{ steps.apply_fixes.outputs.applied_count != '0' && '‚úÖ Fixes applied successfully' || '‚ö†Ô∏è No fixes applied' }}
          EOF

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: type-fix-results-${{ github.run_id }}
          path: |
            type_errors.txt
            claude_response.txt
            verification_results.txt
          retention-days: 7
