#!/usr/bin/env python3
"""
Comprehensive integration tests for all exploitation capabilities.

Tests the full exploitation workflow including payload generation, C2 infrastructure,
post-exploitation, vulnerability research, and AI orchestration.
"""

import logging
import os
import sys
import tempfile
import time
import unittest
from unittest.mock import MagicMock

# Add project root to path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

# Set up test environment
os.environ['INTELLICRACK_TEST_MODE'] = '1'

class TestExploitationIntegration(unittest.TestCase):
    """Test suite for exploitation framework integration."""

    @classmethod
    def setUpClass(cls):
        """Set up test environment."""
        cls.test_dir = tempfile.mkdtemp()

        # Configure logging for tests
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        # Create test binary file
        cls.test_binary = os.path.join(cls.test_dir, 'test_binary.exe')
        with open(cls.test_binary, 'wb') as f:
            f.write(b'MZ\x90\x00' + b'A' * 1000)  # Mock PE header + data

    def setUp(self):
        """Set up each test."""
        self.target_info = {
            'binary_path': self.test_binary,
            'target_path': self.test_binary,
            'platform': 'windows',
            'architecture': 'x64',
            'network_config': {
                'lhost': '127.0.0.1',
                'lport': 4444
            }
        }

    def test_payload_engine_initialization(self):
        """Test payload engine initialization and basic functionality."""
        try:
            from intellicrack.core.exploitation.payload_engine import PayloadEngine
            from intellicrack.core.exploitation.payload_types import Architecture, PayloadType

            engine = PayloadEngine()
            self.assertIsNotNone(engine)

            # Test payload generation
            result = engine.generate_payload(
                payload_type=PayloadType.REVERSE_SHELL,
                architecture=Architecture.X64,
                target_info=self.target_info,
                options={'lhost': '127.0.0.1', 'lport': 4444}
            )

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("‚úì Payload engine initialization and generation test passed")

        except ImportError as e:
            self.skipTest(f"Payload engine not available: {e}")
        except Exception as e:
            self.fail(f"Payload engine test failed: {e}")

    def test_c2_manager_functionality(self):
        """Test C2 infrastructure manager."""
        try:
            from intellicrack.core.c2.c2_manager import C2Manager

            c2_manager = C2Manager()
            self.assertIsNotNone(c2_manager)

            # Test server configuration
            config = {
                'protocol': 'tcp',
                'port': 4445,  # Different port to avoid conflicts
                'interface': '127.0.0.1'
            }

            result = c2_manager.start_server(config)
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)

            # Stop server if started
            if result.get('success'):
                c2_manager.stop_server()

            print("‚úì C2 manager functionality test passed")

        except ImportError as e:
            self.skipTest(f"C2 manager not available: {e}")
        except Exception as e:
            self.fail(f"C2 manager test failed: {e}")

    def test_persistence_manager(self):
        """Test persistence manager functionality."""
        try:
            from intellicrack.core.exploitation.persistence_manager import PersistenceManager

            manager = PersistenceManager()
            self.assertIsNotNone(manager)

            # Test Windows persistence (simulation)
            result = manager.establish_persistence(
                platform='windows',
                method='auto',
                payload_path='/tmp/test_payload'
            )

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("‚úì Persistence manager test passed")

        except ImportError as e:
            self.skipTest(f"Persistence manager not available: {e}")
        except Exception as e:
            self.fail(f"Persistence manager test failed: {e}")

    def test_privilege_escalation_manager(self):
        """Test privilege escalation functionality."""
        try:
            from intellicrack.core.exploitation.privilege_escalation import (
                PrivilegeEscalationManager,
            )

            manager = PrivilegeEscalationManager()
            self.assertIsNotNone(manager)

            # Test privilege escalation detection
            result = manager.escalate_privileges(platform='windows')

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("‚úì Privilege escalation manager test passed")

        except ImportError as e:
            self.skipTest(f"Privilege escalation manager not available: {e}")
        except Exception as e:
            self.fail(f"Privilege escalation test failed: {e}")

    def test_lateral_movement_manager(self):
        """Test lateral movement capabilities."""
        try:
            from intellicrack.core.exploitation.lateral_movement import LateralMovementManager

            manager = LateralMovementManager()
            self.assertIsNotNone(manager)

            # Test target discovery
            result = manager.discover_targets()

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            self.assertIn('targets', result)
            print("‚úì Lateral movement manager test passed")

        except ImportError as e:
            self.skipTest(f"Lateral movement manager not available: {e}")
        except Exception as e:
            self.fail(f"Lateral movement test failed: {e}")

    def test_vulnerability_research_manager(self):
        """Test vulnerability research framework."""
        try:
            from intellicrack.core.vulnerability_research.research_manager import (
                CampaignType,
                ResearchManager,
            )

            manager = ResearchManager()
            self.assertIsNotNone(manager)

            # Test campaign creation
            campaign = manager.create_campaign(
                name="test_campaign",
                campaign_type=CampaignType.STATIC_ANALYSIS,
                targets=[self.test_binary]
            )

            self.assertIsInstance(campaign, dict)
            self.assertIn('campaign_id', campaign)
            print("‚úì Vulnerability research manager test passed")

        except ImportError as e:
            self.skipTest(f"Research manager not available: {e}")
        except Exception as e:
            self.fail(f"Research manager test failed: {e}")

    def test_vulnerability_research_ai_integration(self):
        """Test AI integration for vulnerability research."""
        try:
            from intellicrack.ai.vulnerability_research_integration import VulnerabilityResearchAI

            ai_integration = VulnerabilityResearchAI()
            self.assertIsNotNone(ai_integration)

            # Test AI analysis
            result = ai_integration.analyze_target_with_ai(self.test_binary)

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("‚úì Vulnerability research AI integration test passed")

        except ImportError as e:
            self.skipTest(f"AI integration not available: {e}")
        except Exception as e:
            self.fail(f"AI integration test failed: {e}")

    def test_exploitation_orchestrator(self):
        """Test the main exploitation orchestrator."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator

            orchestrator = ExploitationOrchestrator()
            self.assertIsNotNone(orchestrator)

            # Test orchestrator status
            status = orchestrator.get_orchestrator_status()

            self.assertIsInstance(status, dict)
            self.assertIn('components_status', status)
            print("‚úì Exploitation orchestrator test passed")

        except ImportError as e:
            self.skipTest(f"Exploitation orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Exploitation orchestrator test failed: {e}")

    def test_full_exploitation_workflow_simulation(self):
        """Test complete exploitation workflow in simulation mode."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator

            orchestrator = ExploitationOrchestrator()

            # Mock AI model for testing
            mock_ai = MagicMock()
            orchestrator.ai_model = mock_ai

            # Configure for fast testing
            config = {
                'simulation_mode': True,
                'quick_test': True
            }

            # Run orchestrated exploitation
            result = orchestrator.orchestrate_full_exploitation(
                target_info=self.target_info,
                orchestration_config=config
            )

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            self.assertIn('campaign_id', result)
            self.assertIn('phases', result)
            self.assertIn('timeline', result)

            # Verify phases were executed
            phases = result['phases']
            self.assertIn('intelligence', phases)
            self.assertIn('payload', phases)

            print("‚úì Full exploitation workflow simulation test passed")

        except ImportError as e:
            self.skipTest(f"Orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Full workflow test failed: {e}")    
    def test_ui_integration(self):
        """Test UI integration for exploitation features."""
        try:
            from intellicrack.ui.exploitation_handlers import (
                establish_persistence,
                generate_advanced_payload,
                run_ai_orchestrated_campaign,
                run_full_automated_exploitation,
                start_c2_server,
            )

            # Mock UI components for testing
            mock_ui = MagicMock()
            mock_ui.payload_type_combo.currentText.return_value = "Reverse Shell"
            mock_ui.arch_combo.currentText.return_value = "x64"
            mock_ui.encoding_combo.currentText.return_value = "Polymorphic"
            mock_ui.evasion_combo.currentText.return_value = "medium"
            mock_ui.lhost_edit.text.return_value = "127.0.0.1"
            mock_ui.lport_edit.text.return_value = "4444"
            mock_ui.exploit_output = MagicMock()
            mock_ui.exploit_output.append = MagicMock()

            # Test payload generation handler
            generate_advanced_payload(mock_ui)
            mock_ui.exploit_output.append.assert_called()

            print("‚úì UI integration test passed")

        except ImportError as e:
            self.skipTest(f"UI handlers not available: {e}")
        except Exception as e:
            self.fail(f"UI integration test failed: {e}")

    def test_cli_integration(self):
        """Test CLI integration for exploitation features."""
        try:
            from click.testing import CliRunner

            from intellicrack.cli.cli import cli

            runner = CliRunner()

            # Test basic CLI functionality
            result = runner.invoke(cli, ['--help'])
            self.assertEqual(result.exit_code, 0)
            self.assertIn('Intellicrack', result.output)

            print("‚úì CLI integration test passed")

        except ImportError as e:
            self.skipTest(f"CLI not available: {e}")
        except Exception as e:
            self.fail(f"CLI integration test failed: {e}")

    def test_component_error_handling(self):
        """Test error handling in exploitation components."""
        try:
            from intellicrack.core.exploitation.payload_engine import PayloadEngine
            from intellicrack.core.exploitation.payload_types import Architecture, PayloadType

            engine = PayloadEngine()

            # Test with invalid configuration
            result = engine.generate_payload(
                payload_type=PayloadType.REVERSE_SHELL,
                architecture=Architecture.X64,
                target_info={},  # Empty target info
                options={}  # Empty options
            )

            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            # Should handle gracefully even with minimal input

            print("‚úì Component error handling test passed")

        except ImportError as e:
            self.skipTest(f"Components not available: {e}")
        except Exception as e:
            self.fail(f"Error handling test failed: {e}")

    def test_concurrent_operations(self):
        """Test concurrent exploitation operations."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator

            orchestrator = ExploitationOrchestrator()

            # Test multiple campaign tracking
            campaign1_config = self.target_info.copy()
            campaign1_config['campaign_name'] = 'test_campaign_1'

            campaign2_config = self.target_info.copy()
            campaign2_config['campaign_name'] = 'test_campaign_2'

            # Start campaigns (in simulation mode they complete quickly)
            def run_campaign(config):
                return orchestrator.orchestrate_full_exploitation(
                    config, {'simulation_mode': True, 'quick_test': True}
                )

            # Run campaigns concurrently
            import threading
            results = []

            def campaign_worker(config):
                result = run_campaign(config)
                results.append(result)

            thread1 = threading.Thread(target=campaign_worker, args=(campaign1_config,))
            thread2 = threading.Thread(target=campaign_worker, args=(campaign2_config,))

            thread1.start()
            thread2.start()

            thread1.join(timeout=30)
            thread2.join(timeout=30)

            self.assertEqual(len(results), 2)
            print("‚úì Concurrent operations test passed")

        except ImportError as e:
            self.skipTest(f"Orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Concurrent operations test failed: {e}")

    def test_memory_management(self):
        """Test memory usage during exploitation operations."""
        try:
            import gc

            import psutil

            # Get initial memory usage
            process = psutil.Process()
            initial_memory = process.memory_info().rss

            # Run memory-intensive operations
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator

            orchestrator = ExploitationOrchestrator()

            # Run multiple campaigns
            for i in range(5):
                config = self.target_info.copy()
                config['campaign_name'] = f'memory_test_{i}'

                result = orchestrator.orchestrate_full_exploitation(
                    config, {'simulation_mode': True, 'quick_test': True}
                )

                # Force garbage collection
                gc.collect()

            # Check memory usage hasn't grown excessively
            final_memory = process.memory_info().rss
            memory_growth = (final_memory - initial_memory) / (1024 * 1024)  # MB

            # Allow reasonable memory growth (less than 100MB for test operations)
            self.assertLess(memory_growth, 100, 
                          f"Memory growth too high: {memory_growth:.2f}MB")

            print(f"‚úì Memory management test passed (growth: {memory_growth:.2f}MB)")

        except ImportError:
            self.skipTest("psutil not available for memory testing")
        except Exception as e:
            self.fail(f"Memory management test failed: {e}")

    def test_performance_benchmarks(self):
        """Test performance benchmarks for key operations."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator

            orchestrator = ExploitationOrchestrator()

            # Benchmark orchestrated exploitation
            start_time = time.time()

            result = orchestrator.orchestrate_full_exploitation(
                self.target_info,
                {'simulation_mode': True, 'quick_test': True}
            )

            end_time = time.time()
            execution_time = end_time - start_time

            # Should complete within reasonable time (less than 30 seconds for simulation)
            self.assertLess(execution_time, 30,
                          f"Execution took too long: {execution_time:.2f}s")

            print(f"‚úì Performance benchmark passed (execution: {execution_time:.2f}s)")

        except ImportError as e:
            self.skipTest(f"Performance test components not available: {e}")
        except Exception as e:
            self.fail(f"Performance benchmark failed: {e}")

    @classmethod
    def tearDownClass(cls):
        """Clean up test environment."""
        import shutil
        try:
            shutil.rmtree(cls.test_dir)
        except Exception:
            pass

        # Reset environment
        if 'INTELLICRACK_TEST_MODE' in os.environ:
            del os.environ['INTELLICRACK_TEST_MODE']


class TestExploitationComponents(unittest.TestCase):
    """Focused tests for individual exploitation components."""

    def test_shellcode_generator(self):
        """Test shellcode generation capabilities."""
        try:
            from intellicrack.core.exploitation.payload_types import Architecture
            from intellicrack.core.exploitation.shellcode_generator import ShellcodeGenerator

            generator = ShellcodeGenerator()

            # Test basic shellcode generation
            shellcode = generator.generate_reverse_shell_shellcode(
                architecture=Architecture.X64,
                lhost='127.0.0.1',
                lport=4444
            )

            self.assertIsInstance(shellcode, bytes)
            self.assertGreater(len(shellcode), 0)

            print("‚úì Shellcode generator test passed")

        except ImportError as e:
            self.skipTest(f"Shellcode generator not available: {e}")
        except Exception as e:
            self.fail(f"Shellcode generator test failed: {e}")

    def test_evasion_techniques(self):
        """Test anti-analysis and evasion techniques."""
        try:
            from intellicrack.core.anti_analysis import AntiAnalysisEngine

            engine = AntiAnalysisEngine()

            # Test VM detection
            vm_result = engine.detect_virtual_environment()
            self.assertIsInstance(vm_result, dict)

            # Test debugger detection
            debug_result = engine.detect_debugger()
            self.assertIsInstance(debug_result, dict)

            print("‚úì Evasion techniques test passed")

        except ImportError as e:
            self.skipTest(f"Evasion components not available: {e}")
        except Exception as e:
            self.fail(f"Evasion techniques test failed: {e}")

    def test_mitigation_bypasses(self):
        """Test exploit mitigation bypass techniques."""
        try:
            from intellicrack.core.exploitation.bypass_engine import BypassEngine

            engine = BypassEngine()

            # Test bypass capability detection
            capabilities = engine.analyze_bypass_capabilities({
                'aslr_enabled': True,
                'dep_enabled': True,
                'cfi_enabled': True
            })

            self.assertIsInstance(capabilities, dict)
            self.assertIn('bypasses_available', capabilities)

            print("‚úì Mitigation bypasses test passed")

        except ImportError as e:
            self.skipTest(f"Mitigation bypass components not available: {e}")
        except Exception as e:
            self.fail(f"Mitigation bypasses test failed: {e}")


def run_validation_suite():
    """Run comprehensive validation of all exploitation capabilities."""
    print("="*70)
    print("INTELLICRACK EXPLOITATION FRAMEWORK VALIDATION SUITE")
    print("="*70)

    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()

    # Add test classes
    suite.addTests(loader.loadTestsFromTestCase(TestExploitationIntegration))
    suite.addTests(loader.loadTestsFromTestCase(TestExploitationComponents))

    # Run tests with detailed output
    runner = unittest.TextTestRunner(
        verbosity=2,
        stream=sys.stdout,
        descriptions=True
    )

    print(f"\nStarting validation at {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("-"*70)

    result = runner.run(suite)

    print("-"*70)
    print(f"Validation completed at {time.strftime('%Y-%m-%d %H:%M:%S')}")

    # Summary
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    skipped = len(result.skipped) if hasattr(result, 'skipped') else 0
    successful = total_tests - failures - errors - skipped

    print("\nVALIDATION SUMMARY:")
    print(f"  Total Tests: {total_tests}")
    print(f"  Successful: {successful}")
    print(f"  Failures: {failures}")
    print(f"  Errors: {errors}")
    print(f"  Skipped: {skipped}")

    success_rate = (successful / total_tests * 100) if total_tests > 0 else 0
    print(f"  Success Rate: {success_rate:.1f}%")

    if success_rate >= 80:
        print("\nüéâ EXPLOITATION FRAMEWORK VALIDATION: PASSED")
        print("   All critical components are functioning correctly!")
    else:
        print("\n‚ö†Ô∏è  EXPLOITATION FRAMEWORK VALIDATION: NEEDS ATTENTION")
        print("   Some components require fixes before production use.")

    print("="*70)

    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_validation_suite()
    sys.exit(0 if success else 1)
