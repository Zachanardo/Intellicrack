#!/usr/bin/env python3
"""
Comprehensive integration tests for all exploitation capabilities.

Tests the full exploitation workflow including payload generation, C2 infrastructure,
post-exploitation, vulnerability research, and AI orchestration.
"""

import os
import sys
import time
import logging
import unittest
import tempfile
import threading
from unittest.mock import MagicMock, patch

# Add project root to path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

# Set up test environment
os.environ['INTELLICRACK_TEST_MODE'] = '1'

class TestExploitationIntegration(unittest.TestCase):
    """Test suite for exploitation framework integration."""
    
    @classmethod
    def setUpClass(cls):
        """Set up test environment."""
        cls.test_dir = tempfile.mkdtemp()
        
        # Configure logging for tests
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Create test binary file
        cls.test_binary = os.path.join(cls.test_dir, 'test_binary.exe')
        with open(cls.test_binary, 'wb') as f:
            f.write(b'MZ\x90\x00' + b'A' * 1000)  # Mock PE header + data
    
    def setUp(self):
        """Set up each test."""
        self.target_info = {
            'binary_path': self.test_binary,
            'target_path': self.test_binary,
            'platform': 'windows',
            'architecture': 'x64',
            'network_config': {
                'lhost': '127.0.0.1',
                'lport': 4444
            }
        }
    
    def test_payload_engine_initialization(self):
        """Test payload engine initialization and basic functionality."""
        try:
            from intellicrack.core.payload_generation.payload_engine import PayloadEngine
            from intellicrack.core.payload_generation.payload_types import PayloadType, Architecture
            
            engine = PayloadEngine()
            self.assertIsNotNone(engine)
            
            # Test payload generation
            result = engine.generate_payload(
                payload_type=PayloadType.REVERSE_SHELL,
                architecture=Architecture.X64,
                target_info=self.target_info,
                options={'lhost': '127.0.0.1', 'lport': 4444}
            )
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("✓ Payload engine initialization and generation test passed")
            
        except ImportError as e:
            self.skipTest(f"Payload engine not available: {e}")
        except Exception as e:
            self.fail(f"Payload engine test failed: {e}")
    
    def test_c2_manager_functionality(self):
        """Test C2 infrastructure manager."""
        try:
            from intellicrack.core.c2_infrastructure.c2_manager import C2Manager
            
            c2_manager = C2Manager()
            self.assertIsNotNone(c2_manager)
            
            # Test server configuration
            config = {
                'protocol': 'tcp',
                'port': 4445,  # Different port to avoid conflicts
                'interface': '127.0.0.1'
            }
            
            result = c2_manager.start_server(config)
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            
            # Stop server if started
            if result.get('success'):
                c2_manager.stop_server()
            
            print("✓ C2 manager functionality test passed")
            
        except ImportError as e:
            self.skipTest(f"C2 manager not available: {e}")
        except Exception as e:
            self.fail(f"C2 manager test failed: {e}")
    
    def test_persistence_manager(self):
        """Test persistence manager functionality."""
        try:
            from intellicrack.core.post_exploitation.persistence_manager import PersistenceManager
            
            manager = PersistenceManager()
            self.assertIsNotNone(manager)
            
            # Test Windows persistence (simulation)
            result = manager.establish_persistence(
                platform='windows',
                method='auto',
                payload_path='/tmp/test_payload'
            )
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("✓ Persistence manager test passed")
            
        except ImportError as e:
            self.skipTest(f"Persistence manager not available: {e}")
        except Exception as e:
            self.fail(f"Persistence manager test failed: {e}")
    
    def test_privilege_escalation_manager(self):
        """Test privilege escalation functionality."""
        try:
            from intellicrack.core.post_exploitation.privilege_escalation import PrivilegeEscalationManager
            
            manager = PrivilegeEscalationManager()
            self.assertIsNotNone(manager)
            
            # Test privilege escalation detection
            result = manager.escalate_privileges(platform='windows')
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("✓ Privilege escalation manager test passed")
            
        except ImportError as e:
            self.skipTest(f"Privilege escalation manager not available: {e}")
        except Exception as e:
            self.fail(f"Privilege escalation test failed: {e}")
    
    def test_lateral_movement_manager(self):
        """Test lateral movement capabilities."""
        try:
            from intellicrack.core.post_exploitation.lateral_movement import LateralMovementManager
            
            manager = LateralMovementManager()
            self.assertIsNotNone(manager)
            
            # Test target discovery
            result = manager.discover_targets()
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            self.assertIn('targets', result)
            print("✓ Lateral movement manager test passed")
            
        except ImportError as e:
            self.skipTest(f"Lateral movement manager not available: {e}")
        except Exception as e:
            self.fail(f"Lateral movement test failed: {e}")
    
    def test_vulnerability_research_manager(self):
        """Test vulnerability research framework."""
        try:
            from intellicrack.core.vulnerability_research.research_manager import ResearchManager, CampaignType
            
            manager = ResearchManager()
            self.assertIsNotNone(manager)
            
            # Test campaign creation
            campaign = manager.create_campaign(
                name="test_campaign",
                campaign_type=CampaignType.STATIC_ANALYSIS,
                targets=[self.test_binary]
            )
            
            self.assertIsInstance(campaign, dict)
            self.assertIn('campaign_id', campaign)
            print("✓ Vulnerability research manager test passed")
            
        except ImportError as e:
            self.skipTest(f"Research manager not available: {e}")
        except Exception as e:
            self.fail(f"Research manager test failed: {e}")
    
    def test_ml_adaptation_engine(self):
        """Test ML adaptation engine functionality."""
        try:
            from intellicrack.core.vulnerability_research.ml_adaptation_engine import MLAdaptationEngine
            
            engine = MLAdaptationEngine()
            self.assertIsNotNone(engine)
            
            # Test adaptation strategy
            result = engine.adapt_exploitation_strategy(
                target_info=self.target_info,
                previous_attempts=[],
                strategy='exploit_optimization'
            )
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("✓ ML adaptation engine test passed")
            
        except ImportError as e:
            self.skipTest(f"ML adaptation engine not available: {e}")
        except Exception as e:
            self.fail(f"ML adaptation engine test failed: {e}")
    
    def test_vulnerability_research_ai_integration(self):
        """Test AI integration for vulnerability research."""
        try:
            from intellicrack.ai.vulnerability_research_integration import VulnerabilityResearchAI
            
            ai_integration = VulnerabilityResearchAI()
            self.assertIsNotNone(ai_integration)
            
            # Test AI analysis
            result = ai_integration.analyze_target_with_ai(self.test_binary)
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            print("✓ Vulnerability research AI integration test passed")
            
        except ImportError as e:
            self.skipTest(f"AI integration not available: {e}")
        except Exception as e:
            self.fail(f"AI integration test failed: {e}")
    
    def test_exploitation_orchestrator(self):
        """Test the main exploitation orchestrator."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator
            
            orchestrator = ExploitationOrchestrator()
            self.assertIsNotNone(orchestrator)
            
            # Test orchestrator status
            status = orchestrator.get_orchestrator_status()
            
            self.assertIsInstance(status, dict)
            self.assertIn('components_status', status)
            print("✓ Exploitation orchestrator test passed")
            
        except ImportError as e:
            self.skipTest(f"Exploitation orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Exploitation orchestrator test failed: {e}")
    
    def test_full_exploitation_workflow_simulation(self):
        """Test complete exploitation workflow in simulation mode."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator
            
            orchestrator = ExploitationOrchestrator()
            
            # Mock AI model for testing
            mock_ai = MagicMock()
            orchestrator.ai_model = mock_ai
            
            # Configure for fast testing
            config = {
                'simulation_mode': True,
                'quick_test': True
            }
            
            # Run orchestrated exploitation
            result = orchestrator.orchestrate_full_exploitation(
                target_info=self.target_info,
                orchestration_config=config
            )
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            self.assertIn('campaign_id', result)
            self.assertIn('phases', result)
            self.assertIn('timeline', result)
            
            # Verify phases were executed
            phases = result['phases']
            self.assertIn('intelligence', phases)
            self.assertIn('payload', phases)
            
            print("✓ Full exploitation workflow simulation test passed")
            
        except ImportError as e:
            self.skipTest(f"Orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Full workflow test failed: {e}")    
    def test_ui_integration(self):
        """Test UI integration for exploitation features."""
        try:
            from intellicrack.ui.exploitation_handlers import (
                generate_advanced_payload, start_c2_server, establish_persistence,
                run_full_automated_exploitation, run_ai_orchestrated_campaign
            )
            
            # Mock UI components for testing
            mock_ui = MagicMock()
            mock_ui.payload_type_combo.currentText.return_value = "Reverse Shell"
            mock_ui.arch_combo.currentText.return_value = "x64"
            mock_ui.encoding_combo.currentText.return_value = "Polymorphic"
            mock_ui.evasion_combo.currentText.return_value = "medium"
            mock_ui.lhost_edit.text.return_value = "127.0.0.1"
            mock_ui.lport_edit.text.return_value = "4444"
            mock_ui.exploit_output = MagicMock()
            mock_ui.exploit_output.append = MagicMock()
            
            # Test payload generation handler
            generate_advanced_payload(mock_ui)
            mock_ui.exploit_output.append.assert_called()
            
            print("✓ UI integration test passed")
            
        except ImportError as e:
            self.skipTest(f"UI handlers not available: {e}")
        except Exception as e:
            self.fail(f"UI integration test failed: {e}")
    
    def test_cli_integration(self):
        """Test CLI integration for exploitation features."""
        try:
            from intellicrack.cli.cli import cli
            from click.testing import CliRunner
            
            runner = CliRunner()
            
            # Test basic CLI functionality
            result = runner.invoke(cli, ['--help'])
            self.assertEqual(result.exit_code, 0)
            self.assertIn('Intellicrack', result.output)
            
            print("✓ CLI integration test passed")
            
        except ImportError as e:
            self.skipTest(f"CLI not available: {e}")
        except Exception as e:
            self.fail(f"CLI integration test failed: {e}")
    
    def test_component_error_handling(self):
        """Test error handling in exploitation components."""
        try:
            from intellicrack.core.payload_generation.payload_engine import PayloadEngine
            from intellicrack.core.payload_generation.payload_types import PayloadType, Architecture
            
            engine = PayloadEngine()
            
            # Test with invalid configuration
            result = engine.generate_payload(
                payload_type=PayloadType.REVERSE_SHELL,
                architecture=Architecture.X64,
                target_info={},  # Empty target info
                options={}  # Empty options
            )
            
            self.assertIsInstance(result, dict)
            self.assertIn('success', result)
            # Should handle gracefully even with minimal input
            
            print("✓ Component error handling test passed")
            
        except ImportError as e:
            self.skipTest(f"Components not available: {e}")
        except Exception as e:
            self.fail(f"Error handling test failed: {e}")
    
    def test_concurrent_operations(self):
        """Test concurrent exploitation operations."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator
            
            orchestrator = ExploitationOrchestrator()
            
            # Test multiple campaign tracking
            campaign1_config = self.target_info.copy()
            campaign1_config['campaign_name'] = 'test_campaign_1'
            
            campaign2_config = self.target_info.copy()
            campaign2_config['campaign_name'] = 'test_campaign_2'
            
            # Start campaigns (in simulation mode they complete quickly)
            def run_campaign(config):
                return orchestrator.orchestrate_full_exploitation(
                    config, {'simulation_mode': True, 'quick_test': True}
                )
            
            # Run campaigns concurrently
            import threading
            results = []
            
            def campaign_worker(config):
                result = run_campaign(config)
                results.append(result)
            
            thread1 = threading.Thread(target=campaign_worker, args=(campaign1_config,))
            thread2 = threading.Thread(target=campaign_worker, args=(campaign2_config,))
            
            thread1.start()
            thread2.start()
            
            thread1.join(timeout=30)
            thread2.join(timeout=30)
            
            self.assertEqual(len(results), 2)
            print("✓ Concurrent operations test passed")
            
        except ImportError as e:
            self.skipTest(f"Orchestrator not available: {e}")
        except Exception as e:
            self.fail(f"Concurrent operations test failed: {e}")
    
    def test_memory_management(self):
        """Test memory usage during exploitation operations."""
        try:
            import psutil
            import gc
            
            # Get initial memory usage
            process = psutil.Process()
            initial_memory = process.memory_info().rss
            
            # Run memory-intensive operations
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator
            
            orchestrator = ExploitationOrchestrator()
            
            # Run multiple campaigns
            for i in range(5):
                config = self.target_info.copy()
                config['campaign_name'] = f'memory_test_{i}'
                
                result = orchestrator.orchestrate_full_exploitation(
                    config, {'simulation_mode': True, 'quick_test': True}
                )
                
                # Force garbage collection
                gc.collect()
            
            # Check memory usage hasn't grown excessively
            final_memory = process.memory_info().rss
            memory_growth = (final_memory - initial_memory) / (1024 * 1024)  # MB
            
            # Allow reasonable memory growth (less than 100MB for test operations)
            self.assertLess(memory_growth, 100, 
                          f"Memory growth too high: {memory_growth:.2f}MB")
            
            print(f"✓ Memory management test passed (growth: {memory_growth:.2f}MB)")
            
        except ImportError:
            self.skipTest("psutil not available for memory testing")
        except Exception as e:
            self.fail(f"Memory management test failed: {e}")
    
    def test_performance_benchmarks(self):
        """Test performance benchmarks for key operations."""
        try:
            from intellicrack.ai.exploitation_orchestrator import ExploitationOrchestrator
            
            orchestrator = ExploitationOrchestrator()
            
            # Benchmark orchestrated exploitation
            start_time = time.time()
            
            result = orchestrator.orchestrate_full_exploitation(
                self.target_info,
                {'simulation_mode': True, 'quick_test': True}
            )
            
            end_time = time.time()
            execution_time = end_time - start_time
            
            # Should complete within reasonable time (less than 30 seconds for simulation)
            self.assertLess(execution_time, 30,
                          f"Execution took too long: {execution_time:.2f}s")
            
            print(f"✓ Performance benchmark passed (execution: {execution_time:.2f}s)")
            
        except ImportError as e:
            self.skipTest(f"Performance test components not available: {e}")
        except Exception as e:
            self.fail(f"Performance benchmark failed: {e}")
    
    @classmethod
    def tearDownClass(cls):
        """Clean up test environment."""
        import shutil
        try:
            shutil.rmtree(cls.test_dir)
        except Exception:
            pass
        
        # Reset environment
        if 'INTELLICRACK_TEST_MODE' in os.environ:
            del os.environ['INTELLICRACK_TEST_MODE']


class TestExploitationComponents(unittest.TestCase):
    """Focused tests for individual exploitation components."""
    
    def test_shellcode_generator(self):
        """Test shellcode generation capabilities."""
        try:
            from intellicrack.core.payload_generation.shellcode_generator import ShellcodeGenerator
            from intellicrack.core.payload_generation.payload_types import Architecture
            
            generator = ShellcodeGenerator()
            
            # Test basic shellcode generation
            shellcode = generator.generate_reverse_shell_shellcode(
                architecture=Architecture.X64,
                lhost='127.0.0.1',
                lport=4444
            )
            
            self.assertIsInstance(shellcode, bytes)
            self.assertGreater(len(shellcode), 0)
            
            print("✓ Shellcode generator test passed")
            
        except ImportError as e:
            self.skipTest(f"Shellcode generator not available: {e}")
        except Exception as e:
            self.fail(f"Shellcode generator test failed: {e}")
    
    def test_evasion_techniques(self):
        """Test anti-analysis and evasion techniques."""
        try:
            from intellicrack.core.evasion.anti_analysis import AntiAnalysisEngine
            
            engine = AntiAnalysisEngine()
            
            # Test VM detection
            vm_result = engine.detect_virtual_environment()
            self.assertIsInstance(vm_result, dict)
            
            # Test debugger detection
            debug_result = engine.detect_debugger()
            self.assertIsInstance(debug_result, dict)
            
            print("✓ Evasion techniques test passed")
            
        except ImportError as e:
            self.skipTest(f"Evasion components not available: {e}")
        except Exception as e:
            self.fail(f"Evasion techniques test failed: {e}")
    
    def test_mitigation_bypasses(self):
        """Test exploit mitigation bypass techniques."""
        try:
            from intellicrack.core.mitigation_bypass.bypass_engine import BypassEngine
            
            engine = BypassEngine()
            
            # Test bypass capability detection
            capabilities = engine.analyze_bypass_capabilities({
                'aslr_enabled': True,
                'dep_enabled': True,
                'cfi_enabled': True
            })
            
            self.assertIsInstance(capabilities, dict)
            self.assertIn('bypasses_available', capabilities)
            
            print("✓ Mitigation bypasses test passed")
            
        except ImportError as e:
            self.skipTest(f"Mitigation bypass components not available: {e}")
        except Exception as e:
            self.fail(f"Mitigation bypasses test failed: {e}")


def run_validation_suite():
    """Run comprehensive validation of all exploitation capabilities."""
    print("="*70)
    print("INTELLICRACK EXPLOITATION FRAMEWORK VALIDATION SUITE")
    print("="*70)
    
    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Add test classes
    suite.addTests(loader.loadTestsFromTestCase(TestExploitationIntegration))
    suite.addTests(loader.loadTestsFromTestCase(TestExploitationComponents))
    
    # Run tests with detailed output
    runner = unittest.TextTestRunner(
        verbosity=2,
        stream=sys.stdout,
        descriptions=True
    )
    
    print(f"\nStarting validation at {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("-"*70)
    
    result = runner.run(suite)
    
    print("-"*70)
    print(f"Validation completed at {time.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Summary
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    skipped = len(result.skipped) if hasattr(result, 'skipped') else 0
    successful = total_tests - failures - errors - skipped
    
    print(f"\nVALIDATION SUMMARY:")
    print(f"  Total Tests: {total_tests}")
    print(f"  Successful: {successful}")
    print(f"  Failures: {failures}")
    print(f"  Errors: {errors}")
    print(f"  Skipped: {skipped}")
    
    success_rate = (successful / total_tests * 100) if total_tests > 0 else 0
    print(f"  Success Rate: {success_rate:.1f}%")
    
    if success_rate >= 80:
        print("\n🎉 EXPLOITATION FRAMEWORK VALIDATION: PASSED")
        print("   All critical components are functioning correctly!")
    else:
        print("\n⚠️  EXPLOITATION FRAMEWORK VALIDATION: NEEDS ATTENTION")
        print("   Some components require fixes before production use.")
    
    print("="*70)
    
    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_validation_suite()
    sys.exit(0 if success else 1)