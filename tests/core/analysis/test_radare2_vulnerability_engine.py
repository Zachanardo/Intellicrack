"""
Comprehensive tests for radare2_vulnerability_engine.py module.

Tests cover:
- R2VulnerabilityEngine class initialization and analysis
- Buffer overflow vulnerability detection
- Format string vulnerability detection
- Integer overflow vulnerability detection
- Memory corruption detection (UAF, double-free)
- Race condition detection
- Privilege escalation detection
- Code injection detection
- Path traversal detection
- Information disclosure detection
- Cryptographic weakness detection
- License bypass vulnerability detection
- CVE pattern matching
- Exploit payload generation (buffer overflow, format string)
- Modern protection analysis (CET, CFI)
- Hardware protection analysis (TPM, dongles)
- Commercial license system analysis
- Automated patch generation
- Severity assessment and remediation
"""

import json
import logging
import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.analysis.radare2_vulnerability_engine import (
    R2VulnerabilityEngine,
    analyze_binary_vulnerabilities,
)

try:
    import r2pipe

    R2PIPE_AVAILABLE = True
except ImportError:
    R2PIPE_AVAILABLE = False

try:
    from pwn import asm, context, cyclic, p32, p64

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False

SKIP_R2_TESTS = not R2PIPE_AVAILABLE
SKIP_PWNTOOL_TESTS = not PWNTOOLS_AVAILABLE


@pytest.fixture(scope="module")
def vulnerable_buffer_overflow_binary() -> Path:
    """Provide path to buffer overflow vulnerable binary."""
    fixture_path = Path("D:/Intellicrack/tests/fixtures/vulnerable_samples/buffer_overflow_0.exe")
    if fixture_path.exists():
        return fixture_path
    return Path("D:/Intellicrack/tests/fixtures/binaries/pe/legitimate/notepadpp.exe")


@pytest.fixture(scope="module")
def format_string_vulnerable_binary() -> Path:
    """Provide path to format string vulnerable binary."""
    fixture_path = Path("D:/Intellicrack/tests/fixtures/vulnerable_samples/format_string_0.exe")
    if fixture_path.exists():
        return fixture_path
    return Path("D:/Intellicrack/tests/fixtures/binaries/pe/legitimate/7zip.exe")


@pytest.fixture(scope="module")
def integer_overflow_vulnerable_binary() -> Path:
    """Provide path to integer overflow vulnerable binary."""
    fixture_path = Path("D:/Intellicrack/tests/fixtures/vulnerable_samples/integer_overflow_0.exe")
    if fixture_path.exists():
        return fixture_path
    return Path("D:/Intellicrack/tests/fixtures/binaries/pe/legitimate/vlc.exe")


@pytest.fixture(scope="module")
def protected_binary_with_license() -> Path:
    """Provide path to binary with license protection."""
    fixture_path = Path("D:/Intellicrack/tests/fixtures/binaries/pe/protected/enterprise_license_check.exe")
    if fixture_path.exists():
        return fixture_path
    return Path("D:/Intellicrack/tests/fixtures/full_protected_software/Beyond_Compare_Full.exe")


@pytest.fixture(scope="module")
def commercial_license_binary() -> Path:
    """Provide path to binary with commercial license system."""
    flexlm_path = Path("D:/Intellicrack/tests/fixtures/binaries/pe/protected/flexlm_license_protected.exe")
    if flexlm_path.exists():
        return flexlm_path
    return Path("D:/Intellicrack/tests/fixtures/full_protected_software/Resource_Hacker_Full.exe")


@pytest.fixture(scope="module")
def dongle_protected_binary() -> Path:
    """Provide path to dongle-protected binary."""
    dongle_path = Path("D:/Intellicrack/tests/fixtures/binaries/pe/protected/dongle_protected_app.exe")
    if dongle_path.exists():
        return dongle_path
    return Path("D:/Intellicrack/tests/fixtures/binaries/pe/protected/hasp_sentinel_protected.exe")


@pytest.fixture(scope="module")
def vmprotect_protected_binary() -> Path:
    """Provide path to VMProtect-protected binary."""
    return Path("D:/Intellicrack/tests/fixtures/binaries/protected/vmprotect_protected.exe")


@pytest.fixture(scope="module")
def themida_protected_binary() -> Path:
    """Provide path to Themida-protected binary."""
    return Path("D:/Intellicrack/tests/fixtures/binaries/protected/themida_protected.exe")


class TestR2VulnerabilityEngineInitialization:
    """Test R2VulnerabilityEngine initialization and setup."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_initialization_with_valid_binary(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Vulnerability engine initializes successfully with valid binary."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert engine.binary_path == str(vulnerable_buffer_overflow_binary)
        assert engine.decompiler is not None
        assert engine.esil_engine is not None
        assert engine.string_analyzer is not None
        assert engine.import_analyzer is not None
        assert engine.tpm_bypass is not None
        assert engine.dongle_emulator is not None
        assert engine.commercial_license_analyzer is not None
        assert isinstance(engine.vulnerability_patterns, dict)
        assert "buffer_overflow" in engine.vulnerability_patterns
        assert "format_string" in engine.vulnerability_patterns
        assert "integer_overflow" in engine.vulnerability_patterns

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_initialization_with_custom_radare2_path(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Vulnerability engine accepts custom radare2 path."""
        custom_r2_path = "C:/Program Files/radare2/bin/radare2.exe"
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary), radare2_path=custom_r2_path)

        assert engine.radare2_path == custom_r2_path

    def test_vulnerability_patterns_loaded_correctly(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Vulnerability pattern database contains required patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        patterns = engine.vulnerability_patterns

        assert "buffer_overflow" in patterns
        assert "functions" in patterns["buffer_overflow"]
        assert "strcpy" in patterns["buffer_overflow"]["functions"]
        assert "sprintf" in patterns["buffer_overflow"]["functions"]
        assert patterns["buffer_overflow"]["severity"] == "high"

        assert "format_string" in patterns
        assert "printf" in patterns["format_string"]["functions"]
        assert patterns["format_string"]["severity"] == "high"

        assert "integer_overflow" in patterns
        assert "malloc" in patterns["integer_overflow"]["functions"]

    def test_lazy_protocol_fingerprinter_loading(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Protocol fingerprinter is lazily loaded to avoid circular imports."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert engine._protocol_fingerprinter is None
        fingerprinter = engine.protocol_fingerprinter
        assert fingerprinter is not None
        assert engine._protocol_fingerprinter is not None


class TestBufferOverflowDetection:
    """Test buffer overflow vulnerability detection capabilities."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_buffer_overflows_finds_vulnerabilities(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow detection identifies vulnerable functions."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "buffer_overflows" in results
        assert isinstance(results["buffer_overflows"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_buffer_overflow_results_contain_required_fields(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow results include all required analysis fields."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        if results["buffer_overflows"]:
            vuln = results["buffer_overflows"][0]
            assert "function" in vuln
            assert "dangerous_function" in vuln
            assert "severity" in vuln
            assert vuln["severity"] in ["low", "medium", "high", "critical"]
            assert "exploitable" in vuln
            assert isinstance(vuln["exploitable"], bool)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_assess_exploitability_logic(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Exploitability assessment correctly evaluates patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        patterns_exploitable = [
            {"line_number": 10, "vulnerable_call": "strcpy(dest, src)", "missing_bounds_check": True},
            {"line_number": 15, "vulnerable_call": "sprintf(buf, fmt)", "missing_bounds_check": True},
        ]
        assert engine._assess_exploitability(patterns_exploitable) is True

        patterns_not_exploitable = [
            {"line_number": 10, "vulnerable_call": "strcpy(dest, src)", "missing_bounds_check": False}
        ]
        assert engine._assess_exploitability(patterns_not_exploitable) is False

        assert engine._assess_exploitability([]) is False

    def test_suggest_buffer_overflow_fix_provides_alternatives(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow fix suggestions provide safe alternatives."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert "strncpy" in engine._suggest_buffer_overflow_fix("strcpy")
        assert "strncat" in engine._suggest_buffer_overflow_fix("strcat")
        assert "snprintf" in engine._suggest_buffer_overflow_fix("sprintf")
        assert "fgets" in engine._suggest_buffer_overflow_fix("gets")
        assert "bounds checking" in engine._suggest_buffer_overflow_fix("unknown_func")


class TestFormatStringVulnerabilityDetection:
    """Test format string vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_format_string_bugs_finds_vulnerabilities(self, format_string_vulnerable_binary: Path) -> None:
        """Format string detection identifies vulnerable printf/fprintf calls."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))
        results = engine.analyze_vulnerabilities()

        assert "format_string_bugs" in results
        assert isinstance(results["format_string_bugs"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_format_string_results_structure(self, format_string_vulnerable_binary: Path) -> None:
        """Format string results contain proper analysis data."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))
        results = engine.analyze_vulnerabilities()

        if results["format_string_bugs"]:
            vuln = results["format_string_bugs"][0]
            assert "function" in vuln
            assert "format_function" in vuln
            assert "severity" in vuln
            assert vuln["severity"] in ["medium", "high", "critical"]

    def test_is_format_string_vulnerable_logic(self, format_string_vulnerable_binary: Path) -> None:
        """Format string vulnerability check validates correct patterns."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))

        assert engine._is_format_string_vulnerable('printf(user_input)') is True
        assert engine._is_format_string_vulnerable('fprintf(stderr, buf)') is True
        assert engine._is_format_string_vulnerable('printf("%s", user_input)') is False
        assert engine._is_format_string_vulnerable('printf("constant string")') is False

    def test_suggest_format_string_fix_provides_guidance(self, format_string_vulnerable_binary: Path) -> None:
        """Format string fix suggestions include proper format specifiers."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))

        fix = engine._suggest_format_string_fix("printf")
        assert "%s" in fix
        assert "printf" in fix


class TestIntegerOverflowDetection:
    """Test integer overflow vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_integer_overflows_finds_vulnerabilities(self, integer_overflow_vulnerable_binary: Path) -> None:
        """Integer overflow detection identifies multiplication before allocation."""
        engine = R2VulnerabilityEngine(str(integer_overflow_vulnerable_binary))
        results = engine.analyze_vulnerabilities()

        assert "integer_overflows" in results
        assert isinstance(results["integer_overflows"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_integer_overflow_results_include_r2_analysis(self, integer_overflow_vulnerable_binary: Path) -> None:
        """Integer overflow results include radare2 analysis data."""
        engine = R2VulnerabilityEngine(str(integer_overflow_vulnerable_binary))
        results = engine.analyze_vulnerabilities()

        if results["integer_overflows"]:
            vuln = results["integer_overflows"][0]
            assert "r2_analysis" in vuln
            assert "has_multiplication" in vuln["r2_analysis"]
            assert "has_overflow_protection" in vuln["r2_analysis"]
            assert isinstance(vuln["r2_analysis"]["has_multiplication"], bool)

    def test_could_integer_overflow_pattern_matching(self, integer_overflow_vulnerable_binary: Path) -> None:
        """Integer overflow pattern detection identifies risky multiplication."""
        engine = R2VulnerabilityEngine(str(integer_overflow_vulnerable_binary))

        assert engine._could_integer_overflow("malloc(size * count)") is True
        assert engine._could_integer_overflow("calloc(num, size * 2)") is True
        assert engine._could_integer_overflow("malloc(size)") is False
        assert engine._could_integer_overflow("malloc(check_size(a * b))") is False


class TestMemoryCorruptionDetection:
    """Test use-after-free and double-free detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_memory_corruption_finds_uaf(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Memory corruption detection identifies use-after-free patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "use_after_free" in results
        assert isinstance(results["use_after_free"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_memory_corruption_finds_double_free(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Memory corruption detection identifies double-free patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "double_free" in results
        assert isinstance(results["double_free"], list)

    def test_same_memory_region_comparison(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Memory region comparison correctly identifies same addresses."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        access1 = {"address": "0x12345678", "instruction": "free"}
        access2 = {"address": "0x12345678", "instruction": "mov"}
        access3 = {"address": "0x87654321", "instruction": "mov"}

        assert engine._same_memory_region(access1, access2) is True
        assert engine._same_memory_region(access1, access3) is False

    def test_detect_double_free_pattern_logic(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Double-free pattern detection identifies repeated free calls."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        memory_accesses = [
            {"instruction": "free(ptr)", "address": "0x1000"},
            {"instruction": "mov rax, rbx", "address": "0x2000"},
            {"instruction": "free(ptr)", "address": "0x1000"},
        ]

        double_frees = engine._detect_double_free_pattern(memory_accesses)
        assert len(double_frees) == 1
        assert double_frees[0]["address"] == "0x1000"
        assert double_frees[0]["severity"] == "high"


class TestRaceConditionDetection:
    """Test race condition vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_race_conditions_finds_threading_issues(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Race condition detection identifies unsynchronized threading."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "race_conditions" in results
        assert isinstance(results["race_conditions"], list)

    def test_has_unsynchronized_access_logic(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Unsynchronized access detection validates threading patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        code_with_race = "global_var = value; CreateThread(thread_func, NULL, 0, NULL);"
        assert engine._has_unsynchronized_access(code_with_race) is True

        code_with_sync = "mutex_lock(&lock); global_var = value; mutex_unlock(&lock);"
        assert engine._has_unsynchronized_access(code_with_sync) is False

        code_no_shared = "local_var = value; return local_var;"
        assert engine._has_unsynchronized_access(code_no_shared) is False


class TestPrivilegeEscalationDetection:
    """Test privilege escalation vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_privilege_escalation_finds_priv_apis(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Privilege escalation detection identifies privilege manipulation APIs."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "privilege_escalation" in results
        assert isinstance(results["privilege_escalation"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_privilege_escalation_results_include_r2_analysis(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Privilege escalation results include comprehensive analysis."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        if results["privilege_escalation"]:
            for vuln in results["privilege_escalation"]:
                if "r2_analysis" in vuln:
                    assert "setuid_calls" in vuln["r2_analysis"]
                    assert "token_apis" in vuln["r2_analysis"]
                    assert isinstance(vuln["r2_analysis"]["setuid_calls"], bool)


class TestCodeInjectionDetection:
    """Test code injection vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_code_injection_finds_injection_apis(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Code injection detection identifies process injection APIs."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "code_injection" in results
        assert isinstance(results["code_injection"], list)

    def test_identify_injection_method_classification(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Injection method identification classifies techniques correctly."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert "memory allocation" in engine._identify_injection_method("VirtualAllocEx").lower()
        assert "writing" in engine._identify_injection_method("WriteProcessMemory").lower()
        assert "thread" in engine._identify_injection_method("CreateRemoteThread").lower()
        assert "hook" in engine._identify_injection_method("SetWindowsHookEx").lower()


class TestPathTraversalDetection:
    """Test path traversal vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_path_traversal_finds_traversal_strings(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Path traversal detection identifies directory traversal patterns."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "path_traversal" in results
        assert isinstance(results["path_traversal"], list)


class TestInformationDisclosureDetection:
    """Test information disclosure vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_information_disclosure_finds_sensitive_strings(
        self, vulnerable_buffer_overflow_binary: Path
    ) -> None:
        """Information disclosure detection identifies sensitive debug strings."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "information_disclosure" in results
        assert isinstance(results["information_disclosure"], list)


class TestCryptographicWeaknessDetection:
    """Test cryptographic weakness detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_crypto_weaknesses_finds_weak_algorithms(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Cryptographic weakness detection identifies weak crypto APIs."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "cryptographic_weaknesses" in results
        assert isinstance(results["cryptographic_weaknesses"], list)

    def test_get_crypto_alternative_recommendations(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Crypto alternative recommendations provide secure algorithms."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert "AES" in engine._get_crypto_alternative("des")
        assert "SHA-256" in engine._get_crypto_alternative("md5")
        assert "SHA-256" in engine._get_crypto_alternative("sha1")
        assert "AES" in engine._get_crypto_alternative("rc4")


class TestLicenseBypassDetection:
    """Test license bypass vulnerability detection."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_detect_license_bypass_vulns_finds_license_functions(self, protected_binary_with_license: Path) -> None:
        """License bypass detection identifies patchable license checks."""
        if not protected_binary_with_license.exists():
            pytest.skip("Protected binary not available")

        engine = R2VulnerabilityEngine(str(protected_binary_with_license))
        results = engine.analyze_vulnerabilities()

        assert "license_bypass_vulnerabilities" in results
        assert isinstance(results["license_bypass_vulnerabilities"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_license_bypass_results_include_r2_analysis(self, protected_binary_with_license: Path) -> None:
        """License bypass results include radare2 patchable jump analysis."""
        if not protected_binary_with_license.exists():
            pytest.skip("Protected binary not available")

        engine = R2VulnerabilityEngine(str(protected_binary_with_license))
        results = engine.analyze_vulnerabilities()

        if results["license_bypass_vulnerabilities"]:
            vuln = results["license_bypass_vulnerabilities"][0]
            assert "r2_analysis" in vuln
            assert "patchable_jumps" in vuln["r2_analysis"]
            assert isinstance(vuln["r2_analysis"]["patchable_jumps"], list)

    def test_analyze_license_bypass_methods_identification(self, protected_binary_with_license: Path) -> None:
        """License bypass method analysis identifies patching techniques."""
        engine = R2VulnerabilityEngine(str(protected_binary_with_license))

        decompiled_data = {"license_patterns": [{"type": "license_validation", "line": 10}]}
        methods = engine._analyze_license_bypass_methods(decompiled_data)

        assert isinstance(methods, list)
        assert len(methods) > 0
        assert any("NOP" in method or "return" in method or "jump" in method for method in methods)

    def test_assess_bypass_difficulty_classification(self, protected_binary_with_license: Path) -> None:
        """Bypass difficulty assessment correctly classifies complexity."""
        engine = R2VulnerabilityEngine(str(protected_binary_with_license))

        assert engine._assess_bypass_difficulty(["method1"]) == "easy"
        assert engine._assess_bypass_difficulty(["method1", "method2"]) == "easy"
        assert engine._assess_bypass_difficulty(["m1", "m2", "m3"]) == "medium"
        assert engine._assess_bypass_difficulty(["m1", "m2", "m3", "m4", "m5"]) == "hard"

    def test_generate_license_patches_creates_nop_patches(self, protected_binary_with_license: Path) -> None:
        """License patch generation creates NOP patches for validation."""
        engine = R2VulnerabilityEngine(str(protected_binary_with_license))

        decompiled_data = {"license_patterns": [{"type": "license_validation", "line_number": 42}]}
        patches = engine._generate_license_patches(decompiled_data)

        assert isinstance(patches, list)
        if patches:
            patch = patches[0]
            assert patch["type"] == "nop_patch"
            assert patch["assembly_patch"] == b"\x90" * 5


class TestCVEPatternMatching:
    """Test CVE vulnerability pattern matching."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_match_cve_patterns_identifies_known_vulns(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """CVE pattern matching identifies known vulnerability signatures."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "cve_matches" in results
        assert isinstance(results["cve_matches"], list)

    def test_matches_cve_pattern_logic(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """CVE pattern matching validates vulnerability signatures."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        vuln_log4j = {"function": {"name": "log4j_process"}}
        cve_log4j = {"pattern": "log4j", "description": "Log4Shell"}
        assert engine._matches_cve_pattern(vuln_log4j, cve_log4j) is True

        vuln_other = {"function": {"name": "safe_function"}}
        assert engine._matches_cve_pattern(vuln_other, cve_log4j) is False


class TestExploitGeneration:
    """Test automated exploit payload generation."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_generate_exploits_creates_payloads(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Exploit generation creates functional payloads for vulnerabilities."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "exploit_generation" in results
        assert isinstance(results["exploit_generation"], dict)

    @pytest.mark.skipif(SKIP_PWNTOOL_TESTS, reason="pwntools not available")
    def test_generate_bof_payload_creates_real_shellcode(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow payload generation creates actual shellcode."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        vuln = {
            "function": {"name": "vulnerable_func"},
            "offset": 256,
            "exploitable": True,
        }

        payload = engine._generate_bof_payload(vuln)

        assert payload["type"] == "stack_overflow"
        assert payload["target_function"] == "vulnerable_func"
        assert "complete_payload" in payload
        assert isinstance(payload["complete_payload"], bytes)
        assert len(payload["complete_payload"]) > 0
        assert "shellcode" in payload
        assert "nop_sled" in payload
        assert payload["architecture"] in ["x86", "x64"]

    def test_generate_bof_payload_without_pwntools(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow payload generation works without pwntools."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        vuln = {
            "function": {"name": "test_func"},
            "offset": 128,
            "exploitable": True,
        }

        payload = engine._generate_bof_payload(vuln)

        assert payload["type"] == "stack_overflow"
        assert "complete_payload" in payload
        assert isinstance(payload["complete_payload"], bytes)

    @pytest.mark.skipif(SKIP_PWNTOOL_TESTS, reason="pwntools not available")
    def test_generate_format_string_payload_creates_real_exploit(
        self, format_string_vulnerable_binary: Path
    ) -> None:
        """Format string payload generation creates functional exploits."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))

        vuln = {
            "function": {"name": "printf_wrapper"},
            "offset": 64,
        }

        payload = engine._generate_format_string_payload(vuln)

        assert payload["type"] == "format_string"
        assert payload["target_function"] == "printf_wrapper"
        assert "payload" in payload
        assert isinstance(payload["payload"], bytes)
        assert b"%n" in payload["payload"] or b"%x" in payload["payload"]
        assert "technique" in payload
        assert "target_address" in payload

    def test_detect_architecture_from_binary(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Architecture detection correctly identifies x86 vs x64."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        arch = engine._detect_architecture()
        assert arch in ["x86", "x64"]

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_deploy_exploit_with_buffer_overflow_method(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Exploit deployment executes buffer overflow payloads."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        exploit_data = {
            "complete_payload": b"A" * 256 + b"\x90" * 32,
            "target_binary": str(vulnerable_buffer_overflow_binary),
        }

        result = engine.deploy_exploit(exploit_data, deployment_method="buffer_overflow")

        assert "deployment_method" in result
        assert result["deployment_method"] == "buffer_overflow"
        assert "payload_size" in result

    def test_get_buffer_overflow_deployment_info(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow deployment info contains required fields."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        target_info = {
            "binary_path": str(vulnerable_buffer_overflow_binary),
            "vulnerable_function": "test_func",
            "buffer_offset": 256,
        }

        info = engine._get_buffer_overflow_deployment_info(target_info)

        assert info["method"] == "direct_overflow"
        assert info["deployment_ready"] is True
        assert "deployment_function" in info

    def test_get_format_string_deployment_info(self, format_string_vulnerable_binary: Path) -> None:
        """Format string deployment info contains required fields."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))

        target_info = {
            "binary_path": str(format_string_vulnerable_binary),
            "vulnerable_function": "printf_func",
        }

        info = engine._get_format_string_deployment_info(target_info)

        assert info["method"] == "format_string_exploit"
        assert info["deployment_ready"] is True


class TestSeverityAssessment:
    """Test vulnerability severity assessment and scoring."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_assess_vulnerability_severity_calculates_scores(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Severity assessment calculates risk scores correctly."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "severity_assessment" in results
        assessment = results["severity_assessment"]
        assert "severity_distribution" in assessment
        assert "total_vulnerabilities" in assessment
        assert "risk_score" in assessment
        assert "overall_rating" in assessment

    def test_calculate_overall_rating_logic(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Overall rating calculation correctly classifies risk levels."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert engine._calculate_overall_rating(100, 15) == "critical"
        assert engine._calculate_overall_rating(50, 10) == "critical"
        assert engine._calculate_overall_rating(25, 6) == "high"
        assert engine._calculate_overall_rating(15, 3) == "medium"
        assert engine._calculate_overall_rating(5, 1) == "low"


class TestRemediationSuggestions:
    """Test automated remediation suggestion generation."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_generate_remediation_suggestions_provides_fixes(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Remediation suggestions provide actionable security fixes."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "remediation_suggestions" in results
        suggestions = results["remediation_suggestions"]
        assert isinstance(suggestions, dict)

    def test_remediation_suggestions_for_buffer_overflow(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow remediation includes safe function alternatives."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        vulns = {"buffer_overflows": [{"severity": "high"}]}
        suggestions = engine._generate_remediation_suggestions(vulns)

        assert "buffer_overflow" in suggestions
        assert any("strncpy" in s or "snprintf" in s for s in suggestions["buffer_overflow"])


class TestAutomatedPatchGeneration:
    """Test automated binary patch generation."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_generate_automated_patches_creates_patches(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Automated patch generation creates binary patches."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "automated_patches" in results
        assert isinstance(results["automated_patches"], list)

    def test_generate_buffer_overflow_patch_structure(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Buffer overflow patch contains replacement function info."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        vuln = {
            "function": {"name": "test_func"},
            "dangerous_function": "strcpy",
        }

        patch = engine._generate_buffer_overflow_patch(vuln)

        assert patch["vulnerability_type"] == "buffer_overflow"
        assert patch["patch_type"] == "function_replacement"
        assert patch["original_function"] == "strcpy"

    def test_generate_format_string_patch_structure(self, format_string_vulnerable_binary: Path) -> None:
        """Format string patch contains fix description."""
        engine = R2VulnerabilityEngine(str(format_string_vulnerable_binary))

        vuln = {"function": {"name": "printf_func"}}
        patch = engine._generate_format_string_patch(vuln)

        assert patch["vulnerability_type"] == "format_string"
        assert patch["patch_type"] == "format_string_fix"

    def test_get_safe_alternative_for_dangerous_functions(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Safe alternative lookup provides secure function replacements."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        assert engine._get_safe_alternative("strcpy") == "strncpy"
        assert engine._get_safe_alternative("strcat") == "strncat"
        assert engine._get_safe_alternative("sprintf") == "snprintf"
        assert engine._get_safe_alternative("gets") == "fgets"


class TestModernProtectionAnalysis:
    """Test CET and CFI protection analysis."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_modern_protections_detects_cet_cfi(self, vmprotect_protected_binary: Path) -> None:
        """Modern protection analysis identifies CET and CFI features."""
        if not vmprotect_protected_binary.exists():
            pytest.skip("VMProtect binary not available")

        engine = R2VulnerabilityEngine(str(vmprotect_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert "modern_protections" in results
        protections = results["modern_protections"]
        assert "cet_enabled" in protections
        assert "cfi_enabled" in protections
        assert isinstance(protections["cet_enabled"], bool)
        assert isinstance(protections["cfi_enabled"], bool)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_cet_bypass_opportunities_when_cet_present(self, vmprotect_protected_binary: Path) -> None:
        """CET bypass analysis identifies bypass techniques when CET detected."""
        if not vmprotect_protected_binary.exists():
            pytest.skip("VMProtect binary not available")

        engine = R2VulnerabilityEngine(str(vmprotect_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert "cet_bypass_analysis" in results
        cet_analysis = results["cet_bypass_analysis"]
        assert "cet_present" in cet_analysis
        assert "bypass_needed" in cet_analysis

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_cfi_bypass_opportunities_when_cfi_present(self, vmprotect_protected_binary: Path) -> None:
        """CFI bypass analysis identifies ROP/JOP gadget opportunities."""
        if not vmprotect_protected_binary.exists():
            pytest.skip("VMProtect binary not available")

        engine = R2VulnerabilityEngine(str(vmprotect_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert "cfi_bypass_analysis" in results
        cfi_analysis = results["cfi_bypass_analysis"]
        assert "cfi_present" in cfi_analysis
        assert "bypass_needed" in cfi_analysis


class TestHardwareProtectionAnalysis:
    """Test TPM and dongle protection detection and bypass."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_hardware_protections_detects_tpm(self, protected_binary_with_license: Path) -> None:
        """Hardware protection analysis detects TPM usage."""
        if not protected_binary_with_license.exists():
            pytest.skip("Protected binary not available")

        engine = R2VulnerabilityEngine(str(protected_binary_with_license))
        results = engine.analyze_vulnerabilities()

        assert "hardware_protection_analysis" in results
        hw_analysis = results["hardware_protection_analysis"]
        assert "tpm_detected" in hw_analysis
        assert "dongles_detected" in hw_analysis
        assert isinstance(hw_analysis["tpm_detected"], bool)
        assert isinstance(hw_analysis["dongles_detected"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_dongle_bypass_opportunities(self, dongle_protected_binary: Path) -> None:
        """Dongle bypass analysis identifies emulation strategies."""
        if not dongle_protected_binary.exists():
            pytest.skip("Dongle-protected binary not available")

        engine = R2VulnerabilityEngine(str(dongle_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert "dongle_bypass_analysis" in results
        dongle_analysis = results["dongle_bypass_analysis"]
        assert "dongles_present" in dongle_analysis
        assert "bypass_needed" in dongle_analysis

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_tpm_bypass_opportunities(self, protected_binary_with_license: Path) -> None:
        """TPM bypass analysis identifies API hooking opportunities."""
        if not protected_binary_with_license.exists():
            pytest.skip("Protected binary not available")

        engine = R2VulnerabilityEngine(str(protected_binary_with_license))
        results = engine.analyze_vulnerabilities()

        assert "tpm_bypass_analysis" in results
        tpm_analysis = results["tpm_bypass_analysis"]
        assert "tpm_present" in tpm_analysis


class TestCommercialLicenseAnalysis:
    """Test commercial license system detection and bypass."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_commercial_licenses_detects_systems(self, commercial_license_binary: Path) -> None:
        """Commercial license analysis detects FlexLM, HASP, CodeMeter."""
        if not commercial_license_binary.exists():
            pytest.skip("Commercial license binary not available")

        engine = R2VulnerabilityEngine(str(commercial_license_binary))
        results = engine.analyze_vulnerabilities()

        assert "commercial_license_analysis" in results
        license_analysis = results["commercial_license_analysis"]
        assert "detected_systems" in license_analysis
        assert "bypass_strategies" in license_analysis
        assert isinstance(license_analysis["detected_systems"], list)

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_commercial_license_analysis_includes_exploitation_opportunities(
        self, commercial_license_binary: Path
    ) -> None:
        """Commercial license analysis provides exploitation methods."""
        if not commercial_license_binary.exists():
            pytest.skip("Commercial license binary not available")

        engine = R2VulnerabilityEngine(str(commercial_license_binary))
        results = engine.analyze_vulnerabilities()

        license_analysis = results["commercial_license_analysis"]
        assert "exploitation_opportunities" in license_analysis
        assert isinstance(license_analysis["exploitation_opportunities"], list)


class TestVulnerabilitySummary:
    """Test vulnerability summary generation."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_create_vulnerability_summary_aggregates_results(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Vulnerability summary aggregates all analysis results."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert "vulnerability_summary" in results
        summary = results["vulnerability_summary"]
        assert "total_vulnerabilities" in summary
        assert "critical_count" in summary
        assert "high_count" in summary
        assert "medium_count" in summary
        assert "low_count" in summary
        assert "overall_risk" in summary
        assert summary["overall_risk"] in ["low", "medium", "high", "critical"]


class TestESILTraceParser:
    """Test ESIL trace parsing for memory operation analysis."""

    def test_parse_esil_trace_extracts_memory_accesses(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """ESIL trace parser extracts memory access operations."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        esil_trace = """
        0x1000: mov rax, [rbx]
        0x1003: add rcx, 5
        0x1006: mov [rsi], rdx
        """

        result = engine._parse_esil_trace(esil_trace)

        assert "memory_accesses" in result
        assert "register_operations" in result
        assert len(result["memory_accesses"]) >= 0
        assert len(result["register_operations"]) >= 0

    def test_parse_esil_trace_handles_empty_input(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """ESIL trace parser handles empty or invalid input."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        result = engine._parse_esil_trace("")
        assert result == {"memory_accesses": [], "register_operations": []}

        result = engine._parse_esil_trace(None)
        assert result == {"memory_accesses": [], "register_operations": []}


class TestModuleLevelFunction:
    """Test module-level convenience function."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analyze_binary_vulnerabilities_function(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Module-level analyze function performs complete analysis."""
        results = analyze_binary_vulnerabilities(str(vulnerable_buffer_overflow_binary))

        assert isinstance(results, dict)
        assert "binary_path" in results
        assert results["binary_path"] == str(vulnerable_buffer_overflow_binary)
        assert "vulnerability_summary" in results
        assert "buffer_overflows" in results
        assert "format_string_bugs" in results


class TestComprehensiveAnalysisWorkflow:
    """Test complete end-to-end vulnerability analysis workflow."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_complete_vulnerability_analysis_workflow(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Complete vulnerability analysis workflow produces all required outputs."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        required_keys = [
            "binary_path",
            "vulnerability_summary",
            "buffer_overflows",
            "format_string_bugs",
            "integer_overflows",
            "use_after_free",
            "double_free",
            "race_conditions",
            "privilege_escalation",
            "code_injection",
            "path_traversal",
            "information_disclosure",
            "cryptographic_weaknesses",
            "license_bypass_vulnerabilities",
            "cve_matches",
            "exploit_generation",
            "severity_assessment",
            "remediation_suggestions",
            "automated_patches",
            "modern_protections",
            "cet_bypass_analysis",
            "cfi_bypass_analysis",
            "hardware_protection_analysis",
            "tpm_bypass_analysis",
            "dongle_bypass_analysis",
            "commercial_license_analysis",
        ]

        for key in required_keys:
            assert key in results, f"Missing required key: {key}"

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_find_vulnerabilities_api_compatibility(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """find_vulnerabilities method provides API compatibility."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.find_vulnerabilities()

        assert isinstance(results, dict)
        assert "vulnerability_summary" in results


class TestRealWorldBinaryAnalysis:
    """Test analysis on real-world protected binaries."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_vmprotect_binary_analysis(self, vmprotect_protected_binary: Path) -> None:
        """VMProtect-protected binary analysis produces results."""
        if not vmprotect_protected_binary.exists():
            pytest.skip("VMProtect binary not available")

        engine = R2VulnerabilityEngine(str(vmprotect_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert results is not None
        assert "vulnerability_summary" in results

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_themida_binary_analysis(self, themida_protected_binary: Path) -> None:
        """Themida-protected binary analysis produces results."""
        if not themida_protected_binary.exists():
            pytest.skip("Themida binary not available")

        engine = R2VulnerabilityEngine(str(themida_protected_binary))
        results = engine.analyze_vulnerabilities()

        assert results is not None
        assert "vulnerability_summary" in results


class TestErrorHandling:
    """Test error handling and edge cases."""

    def test_initialization_with_nonexistent_binary(self) -> None:
        """Engine handles nonexistent binary paths gracefully."""
        engine = R2VulnerabilityEngine("D:/nonexistent/binary.exe")
        assert engine.binary_path == "D:/nonexistent/binary.exe"

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analysis_with_corrupted_binary_handles_errors(self, tmp_path: Path) -> None:
        """Analysis handles corrupted binary files gracefully."""
        corrupted_binary = tmp_path / "corrupted.exe"
        corrupted_binary.write_bytes(b"MZ" + b"\x00" * 100)

        engine = R2VulnerabilityEngine(str(corrupted_binary))
        results = engine.analyze_vulnerabilities()

        assert "error" in results or "vulnerability_summary" in results


class TestPerformanceCharacteristics:
    """Test performance characteristics and optimization."""

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_analysis_completes_within_reasonable_time(self, vulnerable_buffer_overflow_binary: Path) -> None:
        """Vulnerability analysis completes within reasonable timeframe."""
        import time

        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))

        start_time = time.time()
        results = engine.analyze_vulnerabilities()
        elapsed_time = time.time() - start_time

        assert results is not None
        assert elapsed_time < 300

    @pytest.mark.skipif(SKIP_R2_TESTS, reason="radare2/r2pipe not available")
    def test_function_analysis_limits_prevent_excessive_processing(
        self, vulnerable_buffer_overflow_binary: Path
    ) -> None:
        """Function analysis limits prevent excessive processing time."""
        engine = R2VulnerabilityEngine(str(vulnerable_buffer_overflow_binary))
        results = engine.analyze_vulnerabilities()

        assert results is not None
