"""
Unit tests for the VulnerabilityDetectionEngine class.

Tests the vulnerability detection and analysis functionality
of the Intellicrack framework.
"""

import unittest
import tempfile
import os
from unittest.mock import Mock, patch, MagicMock

# Try to import the module under test
try:
    from intellicrack.core.analysis.vulnerability_engine import VulnerabilityDetectionEngine
except ImportError:
    VulnerabilityDetectionEngine = None


class TestVulnerabilityDetectionEngine(unittest.TestCase):
    """Test cases for VulnerabilityDetectionEngine."""

    def setUp(self):
        """Set up test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.test_binary = os.path.join(self.temp_dir, "test_binary")

        # Create a dummy test binary
        with open(self.test_binary, 'wb') as f:
            f.write(b'\x7fELF' + b'\x00' * 100)  # Minimal ELF header

        if VulnerabilityDetectionEngine:
            self.engine = VulnerabilityDetectionEngine(self.test_binary)

    def tearDown(self):
        """Clean up test fixtures."""
        if os.path.exists(self.test_binary):
            os.remove(self.test_binary)
        if os.path.exists(self.temp_dir):
            os.rmdir(self.temp_dir)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_initialization(self):
        """Test engine initialization."""
        self.assertIsNotNone(self.engine)
        self.assertEqual(self.engine.binary_path, self.test_binary)
        self.assertIsInstance(self.engine.vulnerabilities, list)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_detect_buffer_overflow(self):
        """Test buffer overflow detection."""
        # Mock dangerous functions
        self.engine.binary_info = {
            'imports': ['strcpy', 'gets', 'sprintf'],
            'functions': ['main', 'vulnerable_func']
        }

        # Run detection
        vulns = self.engine.detect_buffer_overflow()

        # Verify
        self.assertIsInstance(vulns, list)
        self.assertGreater(len(vulns), 0)

        # Check that dangerous functions were detected
        vuln_types = [v.get('type') for v in vulns]
        self.assertIn('buffer_overflow', vuln_types)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_detect_format_string(self):
        """Test format string vulnerability detection."""
        # Mock format string functions
        self.engine.binary_info = {
            'imports': ['printf', 'sprintf', 'fprintf'],
            'strings': ['%s%s%s%s', 'user input: %s']
        }

        # Run detection
        vulns = self.engine.detect_format_string()

        # Verify
        self.assertIsInstance(vulns, list)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_detect_integer_overflow(self):
        """Test integer overflow detection."""
        # Mock arithmetic operations
        self.engine.binary_info = {
            'functions': ['calculate_size', 'allocate_buffer'],
            'assembly': ['add', 'mul', 'imul']
        }

        # Run detection
        vulns = self.engine.detect_integer_overflow()

        # Verify
        self.assertIsInstance(vulns, list)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    @patch('intellicrack.core.analysis.vulnerability_engine.r2pipe')
    def test_analyze_with_radare2(self, mock_r2pipe):
        """Test analysis using radare2."""
        # Mock r2pipe
        mock_r2 = MagicMock()
        mock_r2.cmd.return_value = '{"imports": ["strcpy"], "functions": ["main"]}'
        mock_r2pipe.open.return_value = mock_r2

        # Run analysis
        self.engine.analyze_with_radare2()

        # Verify
        mock_r2pipe.open.assert_called_once_with(self.test_binary)
        self.assertIsNotNone(self.engine.r2_analysis)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_generate_vulnerability_report(self):
        """Test vulnerability report generation."""
        # Add some vulnerabilities
        self.engine.vulnerabilities = [
            {
                'type': 'buffer_overflow',
                'severity': 'high',
                'location': '0x401000',
                'description': 'Unsafe strcpy usage'
            },
            {
                'type': 'format_string',
                'severity': 'medium',
                'location': '0x401100',
                'description': 'Uncontrolled format string'
            }
        ]

        # Generate report
        report = self.engine.generate_report()

        # Verify
        self.assertIn('summary', report)
        self.assertIn('vulnerabilities', report)
        self.assertEqual(report['summary']['total'], 2)
        self.assertEqual(report['summary']['high_severity'], 1)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_export_to_json(self):
        """Test exporting results to JSON."""
        # Add test data
        self.engine.vulnerabilities = [{'type': 'test', 'severity': 'low'}]

        # Export
        json_file = os.path.join(self.temp_dir, "vulns.json")
        result = self.engine.export_to_json(json_file)

        # Verify
        self.assertTrue(result)
        self.assertTrue(os.path.exists(json_file))

        # Cleanup
        if os.path.exists(json_file):
            os.remove(json_file)

    @unittest.skipIf(VulnerabilityDetectionEngine is None, "VulnerabilityDetectionEngine not available")
    def test_run_full_analysis(self):
        """Test running full vulnerability analysis."""
        # Mock all detection methods
        self.engine.detect_buffer_overflow = Mock(return_value=[{'type': 'buffer_overflow'}])
        self.engine.detect_format_string = Mock(return_value=[])
        self.engine.detect_integer_overflow = Mock(return_value=[{'type': 'integer_overflow'}])

        # Run full analysis
        results = self.engine.run_full_analysis()

        # Verify
        self.assertEqual(len(results), 2)
        self.engine.detect_buffer_overflow.assert_called_once()
        self.engine.detect_format_string.assert_called_once()
        self.engine.detect_integer_overflow.assert_called_once()


if __name__ == '__main__':
    unittest.main()