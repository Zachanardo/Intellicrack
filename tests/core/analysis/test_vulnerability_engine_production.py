"""Production tests for vulnerability_engine module.

This module tests the AdvancedVulnerabilityEngine which provides comprehensive
vulnerability scanning for PE binaries including import table analysis, section
analysis, cryptographic weakness detection, and licensing vulnerability identification.

Copyright (C) 2025 Zachary Flint
"""

import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.analysis.vulnerability_engine import AdvancedVulnerabilityEngine, PEFILE_AVAILABLE


def create_pe_with_imports(
    path: Path,
    imports: list[tuple[str, list[str]]],
) -> Path:
    """Create PE binary with specific imports.

    Args:
        path: Path where PE will be created
        imports: List of (dll_name, [function_names])

    Returns:
        Path to created PE
    """
    dos_header = bytearray(64)
    dos_header[:2] = b"MZ"
    dos_header[60:64] = struct.pack("<I", 64)

    pe_signature = b"PE\x00\x00"

    file_header = struct.pack(
        "<HHIIIHH",
        0x014C,
        1,
        0x60000000,
        0,
        0,
        224,
        0x0102,
    )

    optional_header = struct.pack(
        "<HHBBIIIIIHHHHHHIIIIHHIIIIIIII",
        0x010B, 0, 0, 0x1000, 0, 0, 0x1000, 0x1000, 0x1000,
        0x400000, 0x1000, 0x200, 0, 0, 0, 0, 4, 0, 0,
        0x3000, 0x200, 0, 3, 0,
        0x100000, 0x1000, 0x100000, 0x1000, 0, 16,
    )

    data_directories = b"\x00" * (16 * 8)

    section_name = b".text\x00\x00\x00"
    section_header = section_name + struct.pack(
        "<IIIIHHI",
        0x1000, 0x1000, 0x200, 0x200, 0, 0, 0, 0, 0xE0000020,
    )

    pe_content = dos_header + pe_signature + file_header + optional_header + data_directories + section_header
    pe_content = pe_content.ljust(0x200, b"\x00")

    section_data = bytearray(b"\x90" * 0x200)

    for dll_name, functions in imports:
        section_data.extend(dll_name.encode() + b"\x00")
        for func in functions:
            section_data.extend(func.encode() + b"\x00")

    pe_content += bytes(section_data)

    path.write_bytes(pe_content)
    return path


def create_pe_with_sections(
    path: Path,
    sections: list[tuple[str, bytes, int]],
) -> Path:
    """Create PE binary with specific sections.

    Args:
        path: Path where PE will be created
        sections: List of (name, data, characteristics)

    Returns:
        Path to created PE
    """
    dos_header = bytearray(64)
    dos_header[:2] = b"MZ"
    dos_header[60:64] = struct.pack("<I", 64)

    pe_signature = b"PE\x00\x00"

    num_sections = len(sections)

    file_header = struct.pack(
        "<HHIIIHH",
        0x014C,
        num_sections,
        0x60000000,
        0,
        0,
        224,
        0x0102,
    )

    optional_header = struct.pack(
        "<HHBBIIIIIHHHHHHIIIIHHIIIIIIII",
        0x010B, 0, 0, 0x1000, 0, 0, 0x1000, 0x1000, 0x1000,
        0x400000, 0x1000, 0x200, 0, 0, 0, 0, 4, 0, 0,
        0x3000, 0x200, 0, 3, 0,
        0x100000, 0x1000, 0x100000, 0x1000, 0, 16,
    )

    data_directories = b"\x00" * (16 * 8)

    section_headers = b""
    for idx, (name, data, characteristics) in enumerate(sections):
        section_name = name[:8].ljust(8, "\x00").encode("utf-8")
        virtual_size = len(data)
        virtual_address = 0x1000 * (idx + 1)
        size_of_raw_data = (len(data) + 0x1FF) & ~0x1FF
        pointer_to_raw_data = 0x200 + (idx * 0x200)

        section_header = section_name + struct.pack(
            "<IIIIHHI",
            virtual_size,
            virtual_address,
            size_of_raw_data,
            pointer_to_raw_data,
            0, 0, 0, 0,
            characteristics,
        )
        section_headers += section_header

    pe_content = dos_header + pe_signature + file_header + optional_header + data_directories + section_headers
    pe_content = pe_content.ljust(0x200, b"\x00")

    for section_name, section_data, _ in sections:
        aligned_data = section_data.ljust((len(section_data) + 0x1FF) & ~0x1FF, b"\x00")
        pe_content += aligned_data

    path.write_bytes(pe_content)
    return path


@pytest.fixture
def basic_pe(tmp_path: Path) -> Path:
    """Create basic PE binary."""
    binary_path = tmp_path / "basic.exe"
    return create_pe_with_sections(
        binary_path,
        [(".text", b"\x90" * 256, 0x60000020)],
    )


@pytest.fixture
def dangerous_imports_pe(tmp_path: Path) -> Path:
    """Create PE with dangerous imports."""
    binary_path = tmp_path / "dangerous.exe"
    return create_pe_with_imports(
        binary_path,
        [
            ("kernel32.dll", ["VirtualAlloc", "CreateProcess", "WriteProcessMemory"]),
            ("advapi32.dll", ["CryptEncrypt", "CryptDecrypt"]),
            ("ws2_32.dll", ["connect", "send", "recv"]),
        ],
    )


@pytest.fixture
def high_entropy_pe(tmp_path: Path) -> Path:
    """Create PE with high entropy section."""
    import random
    random.seed(42)
    high_entropy_data = bytes(random.randint(0, 255) for _ in range(512))

    binary_path = tmp_path / "high_entropy.exe"
    return create_pe_with_sections(
        binary_path,
        [(".packed", high_entropy_data, 0x60000020)],
    )


@pytest.fixture
def vulnerable_permissions_pe(tmp_path: Path) -> Path:
    """Create PE with executable and writable section."""
    binary_path = tmp_path / "vuln_perms.exe"
    return create_pe_with_sections(
        binary_path,
        [(".text", b"\x90" * 256, 0xE0000020)],
    )


@pytest.fixture
def licensing_strings_pe(tmp_path: Path) -> Path:
    """Create PE with licensing-related strings."""
    binary_path = tmp_path / "licensing.exe"

    data = b"License key validation\x00"
    data += b"Serial number check\x00"
    data += b"Trial expired message\x00"
    data += b"MD5 hash: 5d41402abc4b2a76b9719d911017c592\x00"

    return create_pe_with_sections(
        binary_path,
        [(".data", data, 0x40000040)],
    )


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestVulnerabilityEngineBasicScanning:
    """Test basic vulnerability scanning functionality."""

    def test_scan_basic_binary(self, basic_pe: Path) -> None:
        """AdvancedVulnerabilityEngine scans basic PE successfully."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(basic_pe))

        assert isinstance(vulnerabilities, list)

    def test_scan_nonexistent_file(self) -> None:
        """AdvancedVulnerabilityEngine handles nonexistent file gracefully."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary("/nonexistent/file.exe")

        assert isinstance(vulnerabilities, list)
        assert len(vulnerabilities) == 0

    def test_scan_returns_list(self, basic_pe: Path) -> None:
        """Scan always returns list of vulnerabilities."""
        result = AdvancedVulnerabilityEngine.scan_binary(str(basic_pe))

        assert isinstance(result, list)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestImportTableAnalysis:
    """Test import table vulnerability detection."""

    def test_detect_dangerous_imports(self, dangerous_imports_pe: Path) -> None:
        """AdvancedVulnerabilityEngine detects dangerous imports."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(dangerous_imports_pe))

        if import_vulns := [
            v for v in vulnerabilities if v.get("type") == "import_vulnerability"
        ]:
            assert any(v.get("risk_category") in ["memory_manipulation", "system_execution", "crypto_weakness", "network_risk"] for v in import_vulns)

    def test_categorize_memory_manipulation(self, dangerous_imports_pe: Path) -> None:
        """Engine categorizes memory manipulation imports correctly."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(dangerous_imports_pe))

        if memory_vulns := [
            v
            for v in vulnerabilities
            if v.get("risk_category") == "memory_manipulation"
        ]:
            assert any("virtualalloc" in v.get("function", "").lower() or "writeprocessmemory" in v.get("function", "").lower() for v in memory_vulns)

    def test_categorize_crypto_weakness(self, dangerous_imports_pe: Path) -> None:
        """Engine categorizes crypto-related imports."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(dangerous_imports_pe))

        if crypto_vulns := [
            v
            for v in vulnerabilities
            if v.get("risk_category") == "crypto_weakness"
        ]:
            assert any("crypt" in v.get("function", "").lower() for v in crypto_vulns)

    def test_categorize_network_risk(self, dangerous_imports_pe: Path) -> None:
        """Engine categorizes network-related imports."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(dangerous_imports_pe))

        if network_vulns := [
            v for v in vulnerabilities if v.get("risk_category") == "network_risk"
        ]:
            assert any(v.get("function", "").lower() in ["connect", "send", "recv"] for v in network_vulns)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestSectionAnalysis:
    """Test section-level vulnerability detection."""

    def test_detect_high_entropy_section(self, high_entropy_pe: Path) -> None:
        """AdvancedVulnerabilityEngine detects high entropy sections."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(high_entropy_pe))

        if entropy_vulns := [
            v for v in vulnerabilities if v.get("type") == "high_entropy_section"
        ]:
            assert any(v.get("entropy", 0) > 7.0 for v in entropy_vulns)
            assert any("Obfuscation" in v.get("risk", "") or "Packing" in v.get("risk", "") for v in entropy_vulns)

    def test_detect_vulnerable_permissions(self, vulnerable_permissions_pe: Path) -> None:
        """AdvancedVulnerabilityEngine detects executable and writable sections."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(vulnerable_permissions_pe))

        if perm_vulns := [
            v
            for v in vulnerabilities
            if v.get("type") == "section_permission_vulnerability"
        ]:
            assert any("Executable and Writable" in v.get("risk", "") for v in perm_vulns)

    def test_section_vulnerability_contains_name(self, high_entropy_pe: Path) -> None:
        """Section vulnerabilities include section name."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(high_entropy_pe))

        if section_vulns := [
            v
            for v in vulnerabilities
            if v.get("type")
            in ["high_entropy_section", "section_permission_vulnerability"]
        ]:
            assert all("section_name" in v for v in section_vulns)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestExportTableAnalysis:
    """Test export table vulnerability detection."""

    def test_export_analysis_on_dll(self, tmp_path: Path) -> None:
        """AdvancedVulnerabilityEngine analyzes DLL exports."""
        dll_path = tmp_path / "library.dll"

        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 64)

        pe_signature = b"PE\x00\x00"

        file_header = struct.pack(
            "<HHIIIHH",
            0x014C, 1, 0x60000000, 0, 0, 224, 0x2102,
        )

        optional_header = struct.pack(
            "<HHBBIIIIIHHHHHHIIIIHHIIIIIIII",
            0x010B, 0, 0, 0x1000, 0, 0, 0x1000, 0x1000, 0x1000,
            0x400000, 0x1000, 0x200, 0, 0, 0, 0, 4, 0, 0,
            0x3000, 0x200, 0, 3, 0,
            0x100000, 0x1000, 0x100000, 0x1000, 0, 16,
        )

        data_directories = b"\x00" * (16 * 8)

        section_name = b".text\x00\x00\x00"
        section_header = section_name + struct.pack(
            "<IIIIHHI",
            0x1000, 0x1000, 0x200, 0x200, 0, 0, 0, 0, 0xE0000020,
        )

        pe_content = (
            dos_header + pe_signature + file_header + optional_header +
            data_directories + section_header
        )
        pe_content = pe_content.ljust(0x200, b"\x00")
        pe_content += b"\x90" * 0x200

        dll_path.write_bytes(pe_content)

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(dll_path))

        assert isinstance(vulnerabilities, list)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestCryptoWeaknessDetection:
    """Test cryptographic weakness detection."""

    def test_detect_weak_crypto_patterns(self, licensing_strings_pe: Path) -> None:
        """AdvancedVulnerabilityEngine detects weak cryptographic patterns."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(licensing_strings_pe))

        if crypto_vulns := [
            v for v in vulnerabilities if v.get("type") == "crypto_weakness"
        ]:
            assert any("MD5" in str(v.get("algorithm", "")) or "weak" in str(v.get("risk", "")).lower() for v in crypto_vulns)

    def test_detect_hardcoded_hashes(self, licensing_strings_pe: Path) -> None:
        """Engine detects hardcoded hash values."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(licensing_strings_pe))

        if hash_vulns := [
            v
            for v in vulnerabilities
            if "hash" in str(v.get("type", "")).lower()
            or "hash" in str(v.get("algorithm", "")).lower()
        ]:
            assert hash_vulns


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestLicensingWeaknessDetection:
    """Test licensing vulnerability detection."""

    def test_detect_licensing_weaknesses(self, licensing_strings_pe: Path) -> None:
        """AdvancedVulnerabilityEngine detects licensing-related vulnerabilities."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(licensing_strings_pe))

        if licensing_vulns := [
            v for v in vulnerabilities if v.get("type") == "licensing_weakness"
        ]:
            assert any("license" in str(v.get("pattern", "")).lower() or "serial" in str(v.get("pattern", "")).lower() for v in licensing_vulns)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestComprehensiveScanning:
    """Test comprehensive multi-check scanning."""

    def test_comprehensive_scan_executes_all_checks(self, basic_pe: Path) -> None:
        """AdvancedVulnerabilityEngine runs all vulnerability checks."""
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(basic_pe))

        assert isinstance(vulnerabilities, list)

    def test_scan_aggregates_multiple_vulnerability_types(self, tmp_path: Path) -> None:
        """Scan aggregates results from all analysis methods."""
        import random
        random.seed(123)

        complex_binary = tmp_path / "complex.exe"

        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 64)

        pe_signature = b"PE\x00\x00"

        file_header = struct.pack(
            "<HHIIIHH",
            0x014C, 2, 0x60000000, 0, 0, 224, 0x0102,
        )

        optional_header = struct.pack(
            "<HHBBIIIIIHHHHHHIIIIHHIIIIIIII",
            0x010B, 0, 0, 0x1000, 0, 0, 0x1000, 0x1000, 0x1000,
            0x400000, 0x1000, 0x200, 0, 0, 0, 0, 4, 0, 0,
            0x4000, 0x200, 0, 3, 0,
            0x100000, 0x1000, 0x100000, 0x1000, 0, 16,
        )

        data_directories = b"\x00" * (16 * 8)

        section1_name = b".text\x00\x00\x00"
        section1_header = section1_name + struct.pack(
            "<IIIIHHI",
            0x1000, 0x1000, 0x200, 0x200, 0, 0, 0, 0, 0xE0000020,
        )

        high_entropy_data = bytes(random.randint(0, 255) for _ in range(512))
        section2_name = b".packed\x00"
        section2_header = section2_name + struct.pack(
            "<IIIIHHI",
            0x200, 0x2000, 0x200, 0x400, 0, 0, 0, 0, 0x60000020,
        )

        pe_content = (
            dos_header + pe_signature + file_header + optional_header +
            data_directories + section1_header + section2_header
        )
        pe_content = pe_content.ljust(0x200, b"\x00")
        pe_content += b"\x90" * 0x200
        pe_content += high_entropy_data

        complex_binary.write_bytes(pe_content)

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(complex_binary))

        assert isinstance(vulnerabilities, list)
        vulnerability_types = {v.get("type") for v in vulnerabilities}


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestErrorHandling:
    """Test error handling in vulnerability scanning."""

    def test_scan_corrupted_pe(self, tmp_path: Path) -> None:
        """AdvancedVulnerabilityEngine handles corrupted PE gracefully."""
        corrupted_path = tmp_path / "corrupted.exe"
        corrupted_path.write_bytes(b"MZ\x00\x00" + b"\xff" * 100)

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(corrupted_path))

        assert isinstance(vulnerabilities, list)

    def test_scan_empty_file(self, tmp_path: Path) -> None:
        """AdvancedVulnerabilityEngine handles empty file."""
        empty_path = tmp_path / "empty.exe"
        empty_path.write_bytes(b"")

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(empty_path))

        assert isinstance(vulnerabilities, list)
        assert len(vulnerabilities) == 0

    def test_scan_non_pe_file(self, tmp_path: Path) -> None:
        """AdvancedVulnerabilityEngine handles non-PE file."""
        text_path = tmp_path / "text.txt"
        text_path.write_text("This is not a PE file")

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(text_path))

        assert isinstance(vulnerabilities, list)
        assert len(vulnerabilities) == 0


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestPerformance:
    """Test vulnerability scanning performance."""

    def test_scan_completes_within_time_limit(self, basic_pe: Path) -> None:
        """Vulnerability scan completes within reasonable time."""
        import time

        start = time.time()
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(basic_pe))
        duration = time.time() - start

        assert isinstance(vulnerabilities, list)
        assert duration < 30.0

    def test_scan_large_binary_performance(self, tmp_path: Path) -> None:
        """Scan handles larger binaries efficiently."""
        large_binary = tmp_path / "large.exe"

        import random
        random.seed(456)

        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 64)

        pe_signature = b"PE\x00\x00"

        file_header = struct.pack(
            "<HHIIIHH",
            0x014C, 1, 0x60000000, 0, 0, 224, 0x0102,
        )

        optional_header = struct.pack(
            "<HHBBIIIIIHHHHHHIIIIHHIIIIIIII",
            0x010B, 0, 0, 0x1000, 0, 0, 0x1000, 0x1000, 0x1000,
            0x400000, 0x1000, 0x200, 0, 0, 0, 0, 4, 0, 0,
            0x3000, 0x200, 0, 3, 0,
            0x100000, 0x1000, 0x100000, 0x1000, 0, 16,
        )

        data_directories = b"\x00" * (16 * 8)

        section_name = b".text\x00\x00\x00"
        section_header = section_name + struct.pack(
            "<IIIIHHI",
            0x1000, 0x1000, 0x1000, 0x200, 0, 0, 0, 0, 0xE0000020,
        )

        pe_content = dos_header + pe_signature + file_header + optional_header + data_directories + section_header
        pe_content = pe_content.ljust(0x200, b"\x00")
        pe_content += bytes(random.randint(0, 255) for _ in range(4096))

        large_binary.write_bytes(pe_content)

        import time
        start = time.time()
        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(large_binary))
        duration = time.time() - start

        assert isinstance(vulnerabilities, list)
        assert duration < 60.0


class TestPefileNotAvailable:
    """Test behavior when pefile is not available."""

    @pytest.mark.skipif(PEFILE_AVAILABLE, reason="pefile is available")
    def test_scan_without_pefile(self, tmp_path: Path) -> None:
        """AdvancedVulnerabilityEngine handles missing pefile gracefully."""
        binary_path = tmp_path / "test.exe"
        binary_path.write_bytes(b"MZ" + b"\x00" * 100)

        vulnerabilities = AdvancedVulnerabilityEngine.scan_binary(str(binary_path))

        assert isinstance(vulnerabilities, list)
        assert len(vulnerabilities) == 0
