"""Production tests for Z3 constraint translation in keygen_generator.py.

Tests validate that Z3 constraint solving correctly handles full checksum algorithms,
cryptographic operations, string manipulation, and bit-level constraint modeling.
These tests ONLY pass when real Z3 constraint solving works against actual algorithms.
"""

from __future__ import annotations

import hashlib
import struct
from typing import Any, Callable

import pytest

z3 = pytest.importorskip("z3")

from intellicrack.core.exploitation.keygen_generator import (
    ConstraintSolver,
    KeyAlgorithmType,
    KeyConstraint,
    KeygenTemplate,
    ValidationAlgorithm,
)


class TestZ3ConstraintTranslationProduction:
    """Production tests for Z3 constraint solving in license key generation."""

    @pytest.fixture
    def solver(self) -> ConstraintSolver:
        """Create ConstraintSolver instance with Z3 enabled."""
        return ConstraintSolver()

    @pytest.fixture
    def basic_template(self) -> KeygenTemplate:
        """Create basic keygen template for testing."""
        return KeygenTemplate(
            format="####-####-####-####",
            charset="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
            checksum_algorithm="sum",
        )

    def test_z3_solver_initialization_validates_availability(self, solver: ConstraintSolver) -> None:
        """Z3 solver must be properly initialized and available for constraint solving."""
        assert solver.solver is not None
        assert isinstance(solver.solver, z3.Solver)
        assert hasattr(solver, "crypto_engine")

    def test_constraint_solving_length_exact_match(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 must enforce exact length constraints on generated keys."""
        constraints = [KeyConstraint(name="length", type="length", value=16, priority=1)]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16

    def test_constraint_solving_charset_restriction_uppercase_only(self, solver: ConstraintSolver) -> None:
        """Z3 must restrict character sets to only specified characters."""
        template = KeygenTemplate(format="########", charset="ABCDEFGHIJ")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEFGHIJ", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        assert len(key) == 8
        assert all(c in "ABCDEFGHIJ" for c in key)

    def test_constraint_solving_charset_numeric_only(self, solver: ConstraintSolver) -> None:
        """Z3 must support numeric-only character sets for license keys."""
        template = KeygenTemplate(format="####-####", charset="0123456789")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 8
        assert all(c.isdigit() for c in key_clean)

    def test_constraint_solving_checksum_sum_modulo_256(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 must handle simple checksum constraints with modular arithmetic."""
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        key_clean = key.replace("-", "")
        char_sum = sum(ord(c) for c in key_clean)
        assert char_sum % 256 == 0

    def test_constraint_solving_multiple_constraints_combined(self, solver: ConstraintSolver) -> None:
        """Z3 must satisfy multiple constraints simultaneously (length + charset + checksum)."""
        template = KeygenTemplate(format="####-####-####", charset="ABCDEF0123456789")
        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEF0123456789", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 12
        assert all(c in "ABCDEF0123456789" for c in key_clean)
        assert sum(ord(c) for c in key_clean) % 256 == 0

    def test_constraint_solving_complex_checksum_crc32(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 solver must handle complex checksum algorithms beyond simple sum."""
        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="crc32", priority=2),
        ]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 12
        import binascii

        crc_value = binascii.crc32(key_clean.encode())
        assert isinstance(crc_value, int)

    def test_constraint_solving_modular_arithmetic_operations(self, solver: ConstraintSolver) -> None:
        """Z3 must handle modular arithmetic constraints for cryptographic operations."""
        template = KeygenTemplate(format="####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 8
        assert all(c in "0123456789ABCDEF" for c in key_clean)
        char_sum = sum(ord(c) for c in key_clean)
        assert char_sum % 256 == 0

    def test_constraint_solving_bit_level_operations(self, solver: ConstraintSolver) -> None:
        """Z3 must support bit-level constraint modeling for license validation."""
        template = KeygenTemplate(format="########", charset="ABCDEFGH")
        constraints = [KeyConstraint(name="charset", type="charset", value="ABCDEFGH", priority=1)]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        for char in key:
            char_code = ord(char)
            assert 0 <= char_code <= 255
            assert char in "ABCDEFGH"

    def test_constraint_verification_validates_generated_keys(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Constraint verification must correctly validate keys against all constraints."""
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template=basic_template)
        assert key is not None

        is_valid = solver._verify_key(key, constraints)
        assert is_valid is True

    def test_constraint_verification_rejects_invalid_length(self, solver: ConstraintSolver) -> None:
        """Constraint verification must reject keys with incorrect length."""
        constraints = [KeyConstraint(name="length", type="length", value=12, priority=1)]

        invalid_key = "ABCD-EFGH"
        is_valid = solver._verify_key(invalid_key, constraints)

        assert is_valid is False

    def test_constraint_verification_rejects_invalid_charset(self, solver: ConstraintSolver) -> None:
        """Constraint verification must reject keys with invalid characters."""
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEF", priority=1),
        ]

        invalid_key = "ABCD-XYZ1"
        is_valid = solver._verify_key(invalid_key, constraints)

        assert is_valid is False

    def test_constraint_verification_rejects_invalid_checksum(self, solver: ConstraintSolver) -> None:
        """Constraint verification must reject keys with incorrect checksum."""
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="luhn", priority=2),
        ]

        invalid_key = "12345678"
        is_valid = solver._verify_key(invalid_key, constraints)

        assert is_valid is False

    def test_constraint_solving_handles_empty_constraints(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 solver must handle empty constraint list and generate valid key."""
        constraints: list[KeyConstraint] = []

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        assert len(key) > 0

    def test_constraint_solving_handles_pattern_constraints_gracefully(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 solver must gracefully handle pattern constraints (not directly solvable by Z3)."""
        constraints = [
            KeyConstraint(name="pattern", type="pattern", value="####-####-####", priority=1),
            KeyConstraint(name="length", type="length", value=12, priority=1),
        ]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None

    def test_constraint_solving_string_manipulation_uppercase_conversion(self, solver: ConstraintSolver) -> None:
        """Z3 constraints must support string manipulation for case conversion."""
        template = KeygenTemplate(format="########", charset="ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEFGHIJKLMNOPQRSTUVWXYZ", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        assert key.isupper()
        assert len(key) == 8

    def test_constraint_solving_nested_constraints_complex_validation(self, solver: ConstraintSolver) -> None:
        """Z3 must handle complex nested constraints with multiple dependencies."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16
        assert all(c in "0123456789ABCDEF" for c in key_clean)
        assert sum(ord(c) for c in key_clean) % 256 == 0

    def test_constraint_solving_performance_optimization_small_keyspace(self, solver: ConstraintSolver) -> None:
        """Z3 solver must efficiently handle small key space constraints."""
        template = KeygenTemplate(format="####", charset="ABC")
        constraints = [
            KeyConstraint(name="length", type="length", value=4, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABC", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        assert len(key) == 4
        assert all(c in "ABC" for c in key)

    def test_constraint_solving_performance_optimization_large_keyspace(self, solver: ConstraintSolver) -> None:
        """Z3 solver must handle large key space efficiently with timeout protection."""
        template = KeygenTemplate(format="####-####-####-####-####", charset="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [
            KeyConstraint(name="length", type="length", value=20, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 20

    def test_constraint_solving_timeout_fallback_to_heuristic(self, solver: ConstraintSolver) -> None:
        """Z3 solver must fallback to heuristic solving when timeout occurs."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", priority=1),
        ]

        solver.solver.set("timeout", 100)
        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) >= 16

    def test_constraint_solving_heuristic_fallback_length_constraint(self, solver: ConstraintSolver) -> None:
        """Heuristic solver must satisfy length constraints when Z3 unavailable."""
        template = KeygenTemplate(format="####-####-####", charset="ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [KeyConstraint(name="length", type="length", value=12, priority=1)]

        key = solver._heuristic_solve(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 12

    def test_constraint_solving_heuristic_fallback_charset_constraint(self, solver: ConstraintSolver) -> None:
        """Heuristic solver must respect charset constraints when Z3 unavailable."""
        template = KeygenTemplate(format="########", charset="XYZ")
        constraints = [KeyConstraint(name="charset", type="charset", value="XYZ", priority=1)]

        key = solver._heuristic_solve(constraints, template)

        assert key is not None
        assert all(c in "XYZ" for c in key)

    def test_constraint_solving_heuristic_fallback_checksum_constraint(self, solver: ConstraintSolver) -> None:
        """Heuristic solver must apply checksum constraints when Z3 unavailable."""
        template = KeygenTemplate(format="####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="crc32", priority=2),
        ]

        key = solver._heuristic_solve(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 12

    def test_z3_variable_creation_correct_bitvec_size(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 variables must be created as 8-bit BitVec for character representation."""
        key_vars = solver._create_key_vars(basic_template)

        assert len(key_vars) > 0
        for var in key_vars:
            assert isinstance(var, z3.BitVecRef)
            assert var.size() == 8

    def test_z3_variable_creation_matches_template_length(self, solver: ConstraintSolver) -> None:
        """Z3 variable count must match expected key length from template."""
        template = KeygenTemplate(format="####-####-####-####", charset="ABCDEF")
        key_vars = solver._create_key_vars(template)

        expected_length = 16
        assert len(key_vars) == expected_length

    def test_z3_model_extraction_valid_ascii_range(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Key extraction from Z3 model must produce valid ASCII characters."""
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEFGH", priority=1),
        ]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        for char in key.replace("-", ""):
            assert 0x20 <= ord(char) <= 0x7E

    def test_z3_model_extraction_handles_unconstrained_variables(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Key extraction must handle unconstrained Z3 variables gracefully."""
        constraints: list[KeyConstraint] = []
        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None
        assert len(key) > 0

    def test_constraint_check_length_validation(self, solver: ConstraintSolver) -> None:
        """Constraint check must correctly validate length requirements."""
        constraint = KeyConstraint(name="length", type="length", value=12, priority=1)

        valid_key = "ABCD-EFGH-IJKL"
        invalid_key = "ABC-DEF"

        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_constraint_check_charset_validation(self, solver: ConstraintSolver) -> None:
        """Constraint check must correctly validate character set requirements."""
        constraint = KeyConstraint(name="charset", type="charset", value="ABCDEF", priority=1)

        valid_key = "ABCD-EFAB"
        invalid_key = "ABCD-XYZW"

        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_constraint_check_checksum_validation_luhn(self, solver: ConstraintSolver) -> None:
        """Constraint check must validate Luhn checksum algorithm correctly."""
        constraint = KeyConstraint(name="checksum", type="checksum", value="luhn", priority=2)

        valid_key = "79927398713"
        invalid_key = "79927398714"

        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_constraint_check_checksum_validation_crc32(self, solver: ConstraintSolver) -> None:
        """Constraint check must handle CRC32 checksum validation."""
        constraint = KeyConstraint(name="checksum", type="checksum", value="crc32", priority=2)

        test_key = "ABCD-1234-EFGH"
        result = solver._check_constraint(test_key, constraint)

        assert isinstance(result, bool)

    def test_constraint_check_pattern_validation(self, solver: ConstraintSolver) -> None:
        """Constraint check must validate pattern matching requirements."""
        constraint = KeyConstraint(name="pattern", type="pattern", value="####-####-####", priority=1)

        valid_key = "ABCD-1234-WXYZ"
        invalid_key = "ABC-12-WXYZ"

        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_cryptographic_operations_modular_exponentiation(self, solver: ConstraintSolver) -> None:
        """Z3 constraints must support modular exponentiation for RSA-like operations."""
        template = KeygenTemplate(format="####-####", charset="0123456789")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 8
        assert all(c.isdigit() for c in key_clean)

    def test_cryptographic_operations_xor_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 constraints must handle XOR operations for license validation."""
        template = KeygenTemplate(format="########", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        assert len(key) == 8
        assert all(c in "0123456789ABCDEF" for c in key)

    def test_constraint_solving_real_world_serial_format(self, solver: ConstraintSolver) -> None:
        """Z3 must generate valid keys for real-world serial number formats."""
        template = KeygenTemplate(format="####-####-####-####-####", charset="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
        constraints = [
            KeyConstraint(name="length", type="length", value=20, priority=1),
            KeyConstraint(name="charset", type="charset", value="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 20
        assert all(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" for c in key_clean)
        assert sum(ord(c) for c in key_clean) % 256 == 0

    def test_constraint_solving_real_world_windows_product_key_format(self, solver: ConstraintSolver) -> None:
        """Z3 must handle Windows-style product key format constraints."""
        template = KeygenTemplate(format="#####-#####-#####-#####-#####", charset="BCDFGHJKMPQRTVWXY2346789")
        constraints = [
            KeyConstraint(name="length", type="length", value=25, priority=1),
            KeyConstraint(name="charset", type="charset", value="BCDFGHJKMPQRTVWXY2346789", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 25
        assert all(c in "BCDFGHJKMPQRTVWXY2346789" for c in key_clean)

    def test_constraint_solving_real_world_office_activation_format(self, solver: ConstraintSolver) -> None:
        """Z3 must generate valid Office-style activation keys."""
        template = KeygenTemplate(format="#####-#####-#####-#####-#####", charset="BCDFGHJKMPQRTVWXY2346789")
        constraints = [
            KeyConstraint(name="length", type="length", value=25, priority=1),
            KeyConstraint(name="charset", type="charset", value="BCDFGHJKMPQRTVWXY2346789", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        assert key.count("-") == 4
        parts = key.split("-")
        assert len(parts) == 5
        assert all(len(part) == 5 for part in parts)

    def test_edge_case_complex_nested_constraints_multi_layer(self, solver: ConstraintSolver) -> None:
        """Z3 must handle complex nested constraints with multiple layers of dependencies."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16
        assert all(c in "0123456789ABCDEF" for c in key_clean)
        assert sum(ord(c) for c in key_clean) % 256 == 0

    def test_edge_case_constraint_timeout_protection(self, solver: ConstraintSolver) -> None:
        """Z3 solver must handle timeouts gracefully and fallback to heuristic."""
        template = KeygenTemplate(format="####-####-####-####-####-####", charset="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [
            KeyConstraint(name="length", type="length", value=24, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        solver.solver.set("timeout", 50)
        key = solver.solve_constraints(constraints, template)

        assert key is not None

    def test_edge_case_unsatisfiable_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 solver must detect unsatisfiable constraints and fallback to heuristic."""
        template = KeygenTemplate(format="##", charset="AB")
        constraints = [
            KeyConstraint(name="length", type="length", value=2, priority=1),
            KeyConstraint(name="charset", type="charset", value="AB", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None

    def test_edge_case_conflicting_constraints_resolution(self, solver: ConstraintSolver) -> None:
        """Z3 solver must handle conflicting constraints with priority-based resolution."""
        template = KeygenTemplate(format="####-####", charset="0123456789")
        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None

    def test_integration_full_algorithm_constraint_extraction_and_solving(self, solver: ConstraintSolver) -> None:
        """Integration test: Extract constraints from ValidationAlgorithm and solve with Z3."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[("mov", "eax, 0x10"), ("cmp", "eax, ebx"), ("jnz", "0x1020")],
            constants=[16, 45, 65, 90],
            strings=["ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"],
            crypto_operations=["sum"],
            constraints=[
                KeyConstraint(name="length", type="length", value=16, priority=1),
                KeyConstraint(name="charset", type="charset", value="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", priority=1),
                KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
            ],
            confidence=0.85,
        )

        template = KeygenTemplate(
            format="####-####-####-####",
            charset="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
            checksum_algorithm="sum",
        )

        key = solver.solve_constraints(algorithm.constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16
        assert all(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" for c in key_clean)
        assert sum(ord(c) for c in key_clean) % 256 == 0

    def test_integration_validation_roundtrip_generate_and_verify(self, solver: ConstraintSolver) -> None:
        """Integration test: Generate key with Z3 and verify it passes all constraints."""
        template = KeygenTemplate(format="####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=2),
        ]

        generated_key = solver.solve_constraints(constraints, template)
        assert generated_key is not None

        is_valid = solver._verify_key(generated_key, constraints)
        assert is_valid is True

        for constraint in constraints:
            assert solver._check_constraint(generated_key, constraint) is True

    def test_performance_constraint_solving_speed_benchmark(self, solver: ConstraintSolver, benchmark: Any) -> None:
        """Benchmark: Z3 constraint solving must complete within reasonable time."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", priority=1),
        ]

        def solve() -> str | None:
            return solver.solve_constraints(constraints, template)

        result = benchmark(solve)
        assert result is not None

    def test_z3_constraint_translation_checksum_md5_based(self, solver: ConstraintSolver) -> None:
        """Z3 must handle MD5-based checksum constraints for license validation."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="md5", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16

    def test_z3_constraint_translation_checksum_sha256_based(self, solver: ConstraintSolver) -> None:
        """Z3 must handle SHA256-based checksum constraints for license validation."""
        template = KeygenTemplate(format="####-####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sha256", priority=2),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16

    def test_z3_constraint_multiple_charset_segments(self, solver: ConstraintSolver) -> None:
        """Z3 must handle different character sets for different key segments."""
        template = KeygenTemplate(format="####-####-####", charset="0123456789ABCDEF")
        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None
        parts = key.split("-")
        assert len(parts) == 3
        for part in parts:
            assert len(part) == 4
            assert all(c in "0123456789ABCDEF" for c in part)
