"""Production tests for RSAKeyValidator - validates real RSA signature verification.

These tests verify RSAKeyValidator can extract RSA public keys from binaries and
perform actual cryptographic signature verification against commercial software
licensing protections. All tests use real cryptographic operations with the
cryptography library (pycryptodome equivalent functionality).

Tests validate against Windows system DLLs containing embedded RSA keys and
user-provided protected binaries in tests/test_binaries/ directory.
"""

from __future__ import annotations

import struct
import tempfile
from pathlib import Path
from typing import Any, Generator

import pytest

try:
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding, rsa
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from cryptography.x509 import CertificateBuilder
    from cryptography.x509.oid import NameOID

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    CRYPTOGRAPHY_AVAILABLE = False

from intellicrack.core.exploitation.keygen_generator import (
    KeyAlgorithmType,
    RSAKeyValidator,
    RSAPaddingScheme,
    RSAPublicKeyInfo,
    ValidationAlgorithm,
)

WINDOWS_SYSTEM_DLLS: dict[str, Path] = {
    "crypt32": Path(r"C:\Windows\System32\crypt32.dll"),
    "ncrypt": Path(r"C:\Windows\System32\ncrypt.dll"),
    "bcrypt": Path(r"C:\Windows\System32\bcrypt.dll"),
}

TEST_BINARIES_DIR = Path(__file__).parent.parent.parent / "test_binaries"


def is_windows_dll_available(dll_name: str) -> bool:
    """Check if Windows system DLL exists."""
    dll_path = WINDOWS_SYSTEM_DLLS.get(dll_name)
    return dll_path is not None and dll_path.exists()


@pytest.fixture
def temp_binary_with_rsa_pem() -> Generator[Path, None, None]:
    """Create temporary binary with embedded PEM RSA public key."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_key = private_key.public_key()

    pem_data = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding_before = b"\x00" * 256
        padding_after = b"\xFF" * 256
        f.write(padding_before + pem_data + padding_after)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_with_rsa_der() -> Generator[Path, None, None]:
    """Create temporary binary with embedded DER RSA public key."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_key = private_key.public_key()

    der_data = public_key.public_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding_before = b"\x00" * 128
        padding_after = b"\xCC" * 128
        f.write(padding_before + der_data + padding_after)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_with_x509_cert() -> Generator[Path, None, None]:
    """Create temporary binary with embedded X.509 certificate containing RSA key."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    from datetime import datetime, timedelta, timezone

    from cryptography import x509

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )

    subject = issuer = x509.Name(
        [
            x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Test Software"),
            x509.NameAttribute(NameOID.COMMON_NAME, "license.example.com"),
        ]
    )

    cert = (
        CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(private_key.public_key())
        .serial_number(1000)
        .not_valid_before(datetime.now(timezone.utc))
        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=365))
        .sign(private_key, hashes.SHA256(), default_backend())
    )

    pem_cert = cert.public_bytes(serialization.Encoding.PEM)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding_before = b"\x90" * 200
        padding_after = b"\xAA" * 200
        f.write(padding_before + pem_cert + padding_after)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_with_raw_modulus() -> Generator[Path, None, None]:
    """Create temporary binary with raw RSA modulus and exponent."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_numbers = private_key.public_key().public_numbers()

    modulus_bytes = public_numbers.n.to_bytes(256, byteorder="big")
    exponent_bytes = struct.pack(">I", public_numbers.e)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding = b"\x00" * 100
        f.write(padding + modulus_bytes + padding + exponent_bytes + padding)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_with_cryptoapi_key() -> Generator[Path, None, None]:
    """Create temporary binary with Windows CryptoAPI RSA public key structure."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_numbers = private_key.public_key().public_numbers()

    magic = b"RSA1"
    bitlen = struct.pack("<I", 2048)
    pubexp = struct.pack("<I", public_numbers.e)
    modulus_bytes_le = public_numbers.n.to_bytes(256, byteorder="little")

    cryptoapi_blob = magic + bitlen + pubexp + modulus_bytes_le

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding_before = b"\x00" * 64
        padding_after = b"\xFF" * 64
        f.write(padding_before + cryptoapi_blob + padding_after)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_with_signed_license() -> Generator[tuple[Path, str, bytes], None, None]:
    """Create binary with RSA key and generate signed license key.

    Returns:
        Tuple of (binary_path, signed_license_key, signature_bytes)
    """
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_key = private_key.public_key()

    pem_data = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    license_message = b"LICENSE-KEY-12345-ABCDE-67890"
    signature = private_key.sign(
        license_message, padding.PKCS1v15(), hashes.SHA256()
    )

    license_with_sig = license_message + signature

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        padding_before = b"\x00" * 128
        f.write(padding_before + pem_data)
        temp_path = Path(f.name)

    yield temp_path, license_with_sig.hex().upper(), signature

    temp_path.unlink(missing_ok=True)


class TestRSAKeyValidatorInitialization:
    """Test RSAKeyValidator initialization and setup."""

    def test_validator_initializes_with_valid_binary(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Validator initializes successfully with valid binary path."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))

        assert validator.binary_path == temp_binary_with_rsa_pem
        assert validator.extracted_keys == []
        assert validator.signature_info is None

    def test_validator_initializes_with_windows_dll(self) -> None:
        """Validator initializes with real Windows system DLL."""
        if not is_windows_dll_available("crypt32"):
            pytest.skip("crypt32.dll not available")

        validator = RSAKeyValidator(str(WINDOWS_SYSTEM_DLLS["crypt32"]))
        assert validator.binary_path.exists()

    def test_validator_has_common_exponents_defined(self) -> None:
        """Validator has standard RSA exponents for detection."""
        assert 3 in RSAKeyValidator.COMMON_EXPONENTS
        assert 65537 in RSAKeyValidator.COMMON_EXPONENTS
        assert 17 in RSAKeyValidator.COMMON_EXPONENTS

    def test_validator_has_known_weak_moduli(self) -> None:
        """Validator has database of known weak RSA moduli."""
        assert len(RSAKeyValidator.KNOWN_WEAK_MODULI) > 0
        for modulus in RSAKeyValidator.KNOWN_WEAK_MODULI:
            assert isinstance(modulus, int)
            assert modulus > 0

    def test_validator_has_test_key_patterns(self) -> None:
        """Validator can detect test/demo keys by pattern."""
        assert len(RSAKeyValidator.TEST_KEY_PATTERNS) > 0
        assert b"test" in RSAKeyValidator.TEST_KEY_PATTERNS
        assert b"demo" in RSAKeyValidator.TEST_KEY_PATTERNS
        assert b"example" in RSAKeyValidator.TEST_KEY_PATTERNS


class TestRSAKeyExtractionFromPEM:
    """Test extraction of RSA public keys from PEM format in binaries."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_pem_rsa_key_from_binary(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Extracts valid RSA public key from PEM-encoded data in binary."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "Failed to extract PEM RSA key from binary"

        key = keys[0]
        assert isinstance(key, RSAPublicKeyInfo)
        assert key.format_type == "PEM"
        assert key.key_size == 2048
        assert key.exponent == 65537
        assert key.modulus > 0

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_pem_key_has_valid_modulus_size(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Extracted PEM key has modulus matching declared key size."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        modulus_bit_length = key.modulus.bit_length()
        assert (
            modulus_bit_length >= key.key_size - 8
        ), f"Modulus {modulus_bit_length} bits, expected ~{key.key_size} bits"
        assert modulus_bit_length <= key.key_size

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_pem_key_has_pem_format_string(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Extracted PEM key includes PEM format representation."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert key.pem_format is not None
        assert "-----BEGIN PUBLIC KEY-----" in key.pem_format
        assert "-----END PUBLIC KEY-----" in key.pem_format

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_pem_key_has_valid_address(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Extracted PEM key has valid offset address in binary."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        binary_size = temp_binary_with_rsa_pem.stat().st_size
        assert key.address >= 0
        assert key.address < binary_size


class TestRSAKeyExtractionFromDER:
    """Test extraction of RSA public keys from DER format in binaries."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_der_rsa_key_from_binary(
        self, temp_binary_with_rsa_der: Path
    ) -> None:
        """Extracts valid RSA public key from DER-encoded data in binary."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_der))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "Failed to extract DER RSA key from binary"

        key = keys[0]
        assert isinstance(key, RSAPublicKeyInfo)
        assert key.format_type == "DER"
        assert key.key_size == 2048
        assert key.exponent == 65537

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_der_key_has_der_format_bytes(
        self, temp_binary_with_rsa_der: Path
    ) -> None:
        """Extracted DER key includes DER format binary representation."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_der))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert key.der_format is not None
        assert isinstance(key.der_format, bytes)
        assert len(key.der_format) > 0

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_der_key_has_pem_conversion(
        self, temp_binary_with_rsa_der: Path
    ) -> None:
        """Extracted DER key can be converted to PEM format."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_der))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert key.pem_format is not None
        assert "-----BEGIN PUBLIC KEY-----" in key.pem_format


class TestRSAKeyExtractionFromX509:
    """Test extraction of RSA keys from X.509 certificates in binaries."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_rsa_key_from_x509_certificate(
        self, temp_binary_with_x509_cert: Path
    ) -> None:
        """Extracts RSA public key from embedded X.509 certificate."""
        validator = RSAKeyValidator(str(temp_binary_with_x509_cert))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "Failed to extract RSA key from X.509 certificate"

        key = keys[0]
        assert isinstance(key, RSAPublicKeyInfo)
        assert "X509" in key.format_type
        assert key.key_size == 2048
        assert key.source == "x509_certificate"

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_x509_key_has_valid_parameters(
        self, temp_binary_with_x509_cert: Path
    ) -> None:
        """Extracted X.509 key has valid RSA parameters."""
        validator = RSAKeyValidator(str(temp_binary_with_x509_cert))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert key.exponent > 0
        assert key.modulus > 0
        assert key.key_size in [1024, 2048, 3072, 4096]


class TestRSAKeyExtractionFromRawComponents:
    """Test extraction of RSA keys from raw modulus/exponent in binaries."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_rsa_key_from_raw_modulus_exponent(
        self, temp_binary_with_raw_modulus: Path
    ) -> None:
        """Extracts RSA public key from raw modulus and exponent bytes."""
        validator = RSAKeyValidator(str(temp_binary_with_raw_modulus))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "Failed to extract RSA key from raw components"

        key = keys[0]
        assert isinstance(key, RSAPublicKeyInfo)
        assert key.format_type == "RAW"
        assert key.source == "raw_modulus_exponent"

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_raw_key_validates_modulus_size(
        self, temp_binary_with_raw_modulus: Path
    ) -> None:
        """Extracted raw key modulus matches expected bit size."""
        validator = RSAKeyValidator(str(temp_binary_with_raw_modulus))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        modulus_bits = key.modulus.bit_length()
        assert modulus_bits >= key.key_size - 8
        assert modulus_bits <= key.key_size


class TestRSAKeyExtractionFromCryptoAPI:
    """Test extraction of RSA keys from Windows CryptoAPI structures."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_rsa_key_from_cryptoapi_structure(
        self, temp_binary_with_cryptoapi_key: Path
    ) -> None:
        """Extracts RSA public key from Windows CryptoAPI PUBLICKEYSTRUC."""
        validator = RSAKeyValidator(str(temp_binary_with_cryptoapi_key))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "Failed to extract RSA key from CryptoAPI structure"

        key = keys[0]
        assert isinstance(key, RSAPublicKeyInfo)
        assert key.format_type == "CRYPTOAPI"
        assert key.source == "windows_cryptoapi"

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extracted_cryptoapi_key_has_correct_exponent(
        self, temp_binary_with_cryptoapi_key: Path
    ) -> None:
        """Extracted CryptoAPI key has correct public exponent."""
        validator = RSAKeyValidator(str(temp_binary_with_cryptoapi_key))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert key.exponent == 65537


class TestRSAKeyWeaknessDetection:
    """Test detection of weak or test RSA keys."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_detects_small_key_size_as_weak(self) -> None:
        """Detects RSA keys smaller than 1024 bits as weak."""
        key_info = RSAPublicKeyInfo(
            modulus=0x1234567890ABCDEF,
            exponent=65537,
            key_size=512,
            address=0x1000,
            format_type="RAW",
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        is_weak, reason = validator._check_key_weakness(key_info)

        assert is_weak is True
        assert reason is not None and "too small" in reason.lower()

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_detects_low_exponent_as_weak(self) -> None:
        """Detects RSA keys with exponent < 3 as weak."""
        key_info = RSAPublicKeyInfo(
            modulus=2**2047, exponent=1, key_size=2048, address=0x2000, format_type="RAW"
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        is_weak, reason = validator._check_key_weakness(key_info)

        assert is_weak is True
        assert reason is not None and "exponent" in reason.lower()

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_detects_known_weak_modulus(self) -> None:
        """Detects known weak moduli from database."""
        weak_modulus = list(RSAKeyValidator.KNOWN_WEAK_MODULI)[0]
        key_info = RSAPublicKeyInfo(
            modulus=weak_modulus,
            exponent=65537,
            key_size=2048,
            address=0x3000,
            format_type="RAW",
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        is_weak, reason = validator._check_key_weakness(key_info)

        assert is_weak is True
        assert reason is not None
        assert "weak" in reason.lower() or "test" in reason.lower()

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_strong_key_not_flagged_as_weak(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Strong production RSA keys are not flagged as weak."""
        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        assert (
            key.is_weak is False
        ), f"Strong key incorrectly flagged as weak: {key.weakness_reason}"


class TestRSAPaddingSchemeDetection:
    """Test detection of RSA padding schemes from validation algorithms."""

    def test_detect_pkcs1_v1_5_padding(self) -> None:
        """Detects PKCS#1 v1.5 padding scheme from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x5000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "RSA_PKCS1_PADDING"],
            crypto_operations=["RSA_VERIFY"],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        padding_scheme = validator.detect_padding_scheme(algorithm)

        assert padding_scheme == RSAPaddingScheme.PKCS1_V1_5

    def test_detect_pss_padding(self) -> None:
        """Detects RSA-PSS padding scheme from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x6000,
            instructions=[],
            constants=[],
            strings=["RSASSA-PSS", "PSS_PADDING"],
            crypto_operations=["RSA_PSS_VERIFY"],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        padding_scheme = validator.detect_padding_scheme(algorithm)

        assert padding_scheme == RSAPaddingScheme.PSS

    def test_detect_oaep_padding(self) -> None:
        """Detects OAEP padding scheme from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x7000,
            instructions=[],
            constants=[],
            strings=["OAEP", "RSA_OAEP_PADDING"],
            crypto_operations=["RSA_OAEP"],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        padding_scheme = validator.detect_padding_scheme(algorithm)

        assert padding_scheme == RSAPaddingScheme.OAEP

    def test_defaults_to_pkcs1_v1_5_when_unknown(self) -> None:
        """Defaults to PKCS#1 v1.5 when padding cannot be determined."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x8000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        padding_scheme = validator.detect_padding_scheme(algorithm)

        assert padding_scheme == RSAPaddingScheme.PKCS1_V1_5


class TestHashAlgorithmDetection:
    """Test detection of hash algorithms from validation algorithms."""

    def test_detect_sha256_hash(self) -> None:
        """Detects SHA-256 hash algorithm from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x9000,
            instructions=[],
            constants=[],
            strings=["SHA256", "SHA-256"],
            crypto_operations=["HASH_SHA256"],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        hash_alg = validator.detect_hash_algorithm(algorithm)

        assert hash_alg == "SHA256"

    def test_detect_sha512_hash(self) -> None:
        """Detects SHA-512 hash algorithm from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xA000,
            instructions=[],
            constants=[],
            strings=["SHA512"],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        hash_alg = validator.detect_hash_algorithm(algorithm)

        assert hash_alg == "SHA512"

    def test_detect_sha1_hash(self) -> None:
        """Detects SHA-1 hash algorithm from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xB000,
            instructions=[],
            constants=[],
            strings=["SHA1", "SHA-1"],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        hash_alg = validator.detect_hash_algorithm(algorithm)

        assert hash_alg == "SHA1"

    def test_detect_md5_hash(self) -> None:
        """Detects MD5 hash algorithm from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xC000,
            instructions=[],
            constants=[],
            strings=["MD5"],
            crypto_operations=["MD5_HASH"],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        hash_alg = validator.detect_hash_algorithm(algorithm)

        assert hash_alg == "MD5"

    def test_defaults_to_sha256_when_unknown(self) -> None:
        """Defaults to SHA-256 when hash algorithm cannot be determined."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xD000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(Path(__file__)))
        hash_alg = validator.detect_hash_algorithm(algorithm)

        assert hash_alg == "SHA256"


class TestRSASignatureVerification:
    """Test actual RSA signature verification with extracted keys."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_validate_correctly_signed_license_key(
        self, temp_binary_with_signed_license: tuple[Path, str, bytes]
    ) -> None:
        """Validates license key with correct RSA signature."""
        binary_path, signed_license, _ = temp_binary_with_signed_license

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xE000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_VERIFY"],
        )

        validator = RSAKeyValidator(str(binary_path))
        result = validator.validate_license_key(signed_license, algorithm)

        assert result is True, "Failed to validate correctly signed license key"

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_reject_incorrectly_signed_license_key(
        self, temp_binary_with_signed_license: tuple[Path, str, bytes]
    ) -> None:
        """Rejects license key with invalid RSA signature."""
        binary_path, _, _ = temp_binary_with_signed_license

        invalid_license = "INVALID-LICENSE-KEY-WRONG-SIGNATURE"

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xF000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_VERIFY"],
        )

        validator = RSAKeyValidator(str(binary_path))
        result = validator.validate_license_key(invalid_license, algorithm)

        assert result is False, "Incorrectly validated license key with bad signature"

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_signature_verification_with_pss_padding(self) -> None:
        """Verifies RSA signature with PSS padding scheme."""
        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_data = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        message = b"LICENSE-PSS-TEST-KEY"
        signature = private_key.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256(),
        )

        license_with_sig = message + signature

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 128 + pem_data)
            temp_path = Path(f.name)

        try:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x10000,
                instructions=[],
                constants=[],
                strings=["PSS", "SHA256"],
                crypto_operations=["RSA_PSS_VERIFY"],
            )

            validator = RSAKeyValidator(str(temp_path))
            result = validator.validate_license_key(
                license_with_sig.hex().upper(), algorithm
            )

            assert result is True, "Failed to verify PSS-padded signature"
        finally:
            temp_path.unlink(missing_ok=True)


class TestRSAModulusSizeValidation:
    """Test validation of RSA key modulus sizes (1024/2048/4096 bits)."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    @pytest.mark.parametrize("key_size", [1024, 2048, 3072, 4096])
    def test_extract_keys_of_various_modulus_sizes(self, key_size: int) -> None:
        """Extracts and validates RSA keys of different modulus sizes."""
        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=key_size, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_data = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 64 + pem_data)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) > 0, f"Failed to extract {key_size}-bit RSA key"
            assert keys[0].key_size == key_size
            assert keys[0].modulus.bit_length() >= key_size - 8
            assert keys[0].modulus.bit_length() <= key_size
        finally:
            temp_path.unlink(missing_ok=True)


class TestRSAExtractionFromTestBinaries:
    """Test RSA key extraction from user-provided test binaries."""

    def test_extract_rsa_keys_from_vmprotect_binaries(self) -> None:
        """Extracts RSA keys from VMProtect-protected binaries in test_binaries/."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        vmprotect_dir = TEST_BINARIES_DIR / "vmprotect"
        if not vmprotect_dir.exists():
            pytest.skip("No vmprotect test binaries available")

        vmprotect_binaries = list(vmprotect_dir.glob("*.exe")) + list(
            vmprotect_dir.glob("*.dll")
        )
        if not vmprotect_binaries:
            pytest.skip("No VMProtect binaries found")

        for binary_path in vmprotect_binaries:
            validator = RSAKeyValidator(str(binary_path))
            keys = validator.extract_rsa_keys()

            if len(keys) > 0:
                for key in keys:
                    assert key.key_size in [1024, 2048, 3072, 4096]
                    assert key.exponent > 0
                    assert key.modulus > 0

    def test_extract_rsa_keys_from_themida_binaries(self) -> None:
        """Extracts RSA keys from Themida-protected binaries in test_binaries/."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        themida_dir = TEST_BINARIES_DIR / "themida"
        if not themida_dir.exists():
            pytest.skip("No themida test binaries available")

        themida_binaries = list(themida_dir.rglob("*.exe")) + list(
            themida_dir.rglob("*.dll")
        )
        if not themida_binaries:
            pytest.skip("No Themida binaries found")

        for binary_path in themida_binaries:
            validator = RSAKeyValidator(str(binary_path))
            keys = validator.extract_rsa_keys()

            if len(keys) > 0:
                for key in keys:
                    assert key.key_size in [1024, 2048, 3072, 4096]
                    assert key.modulus > 0

    def test_extract_rsa_keys_from_any_test_binary(self) -> None:
        """Extracts RSA keys from any .exe or .dll in test_binaries/."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries/ directory not found")

        all_binaries = list(TEST_BINARIES_DIR.rglob("*.exe")) + list(
            TEST_BINARIES_DIR.rglob("*.dll")
        )

        if not all_binaries:
            pytest.skip("No test binaries available")

        extraction_results = []
        for binary_path in all_binaries:
            validator = RSAKeyValidator(str(binary_path))
            keys = validator.extract_rsa_keys()
            extraction_results.append((binary_path.name, len(keys)))

        assert len(extraction_results) > 0


class TestRSAExtractionFromWindowsDLLs:
    """Test RSA key extraction from real Windows system DLLs."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_rsa_keys_from_crypt32_dll(self) -> None:
        """Extracts RSA keys from Windows crypt32.dll (certificate functions)."""
        if not is_windows_dll_available("crypt32"):
            pytest.skip("crypt32.dll not available")

        validator = RSAKeyValidator(str(WINDOWS_SYSTEM_DLLS["crypt32"]))
        keys = validator.extract_rsa_keys()

        if len(keys) > 0:
            for key in keys:
                assert isinstance(key, RSAPublicKeyInfo)
                assert key.key_size in [1024, 2048, 3072, 4096]
                assert key.modulus > 0
                assert key.exponent > 0

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_rsa_keys_from_ncrypt_dll(self) -> None:
        """Extracts RSA keys from Windows ncrypt.dll (CNG provider)."""
        if not is_windows_dll_available("ncrypt"):
            pytest.skip("ncrypt.dll not available")

        validator = RSAKeyValidator(str(WINDOWS_SYSTEM_DLLS["ncrypt"]))
        keys = validator.extract_rsa_keys()

        if len(keys) > 0:
            for key in keys:
                assert key.key_size in [1024, 2048, 3072, 4096]


class TestEdgeCases:
    """Test edge cases in RSA key extraction and validation."""

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_from_binary_with_no_rsa_keys(self) -> None:
        """Returns empty list when binary contains no RSA keys."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 1024)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert keys == []
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_from_corrupted_pem_data(self) -> None:
        """Handles corrupted PEM data gracefully."""
        corrupted_pem = b"-----BEGIN PUBLIC KEY-----\nINVALID_BASE64_DATA\n-----END PUBLIC KEY-----"

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 64 + corrupted_pem)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert isinstance(keys, list)
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_validate_without_extracted_keys(self) -> None:
        """Returns False when validating with no extracted keys."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 512)
            temp_path = Path(f.name)

        try:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
            )

            validator = RSAKeyValidator(str(temp_path))
            result = validator.validate_license_key("TEST-KEY", algorithm)

            assert result is False
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_validate_with_non_hex_license_key(
        self, temp_binary_with_rsa_pem: Path
    ) -> None:
        """Handles non-hexadecimal license keys correctly."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x2000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(temp_binary_with_rsa_pem))
        result = validator.validate_license_key("ABCD-1234-WXYZ", algorithm)

        assert isinstance(result, bool)

    @pytest.mark.skipif(
        not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required"
    )
    def test_extract_multiple_keys_from_same_binary(self) -> None:
        """Extracts multiple RSA keys when binary contains several."""
        key1 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        key2 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        pem1 = key1.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        pem2 = key2.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100 + pem1 + b"\xFF" * 100 + pem2 + b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) >= 2, "Failed to extract multiple RSA keys"
        finally:
            temp_path.unlink(missing_ok=True)
