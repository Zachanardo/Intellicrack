"""Production Tests for Keygen Generator Weak Crypto Detection (Lines 385-410).

This module validates the AlgorithmExtractor's operand analysis capabilities for
detecting cryptographic constants, magic numbers, initialization vectors, weak key
lengths, insecure algorithms, and hardcoded secrets in license validation code.

Tests verify detection works on real binary analysis with actual cryptographic
implementations. All tests validate genuine offensive capability - tests MUST fail
if detection does not work on real cryptographic weaknesses.

Copyright (C) 2025 Zachary Flint
"""

from __future__ import annotations

import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.keygen_generator import (
    AlgorithmExtractor,
    KeyAlgorithmType,
    ValidationAlgorithm,
)

try:
    import capstone

    CAPSTONE_AVAILABLE = True
except ImportError:
    CAPSTONE_AVAILABLE = False

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False


pytestmark = [
    pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required for disassembly"),
    pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required for PE analysis"),
]


def create_test_binary_with_crypto_constants(constants: list[int]) -> bytes:
    """Create minimal PE binary with embedded crypto constants.

    Args:
        constants: List of 32-bit constants to embed in binary.

    Returns:
        Raw PE binary bytes with constants in .text section.
    """
    dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)

    pe_signature = b"PE\x00\x00"
    coff_header = struct.pack(
        "<HHIIIHH",
        0x014C,
        1,
        0,
        0,
        0,
        0xE0,
        0x010B,
    )

    optional_header = b"\x0b\x01" + b"\x00" * 222

    section_header = (
        b".text\x00\x00\x00"
        + struct.pack("<IIIIIIHH", 0x200, 0x1000, 0x200, 0x200, 0, 0, 0, 0x60000020)
    )

    section_data = b""
    for const in constants:
        section_data += b"\xb8" + struct.pack("<I", const)
        section_data += b"\x90" * 3

    section_data = section_data.ljust(0x200, b"\x00")

    binary = dos_header + b"\x00" * (0x80 - len(dos_header))
    binary += pe_signature + coff_header + optional_header + section_header + section_data

    return binary


def create_binary_with_strings(strings: list[str]) -> bytes:
    """Create minimal PE binary with embedded strings.

    Args:
        strings: List of strings to embed in binary.

    Returns:
        Raw PE binary bytes with strings in .rdata section.
    """
    dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
    pe_signature = b"PE\x00\x00"
    coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
    optional_header = b"\x0b\x01" + b"\x00" * 222

    section_header = (
        b".rdata\x00\x00"
        + struct.pack("<IIIIIIHH", 0x200, 0x2000, 0x200, 0x200, 0, 0, 0, 0x40000040)
    )

    section_data = b""
    for string in strings:
        section_data += string.encode() + b"\x00"

    section_data = section_data.ljust(0x200, b"\x00")

    binary = dos_header + b"\x00" * (0x80 - len(dos_header))
    binary += pe_signature + coff_header + optional_header + section_header + section_data

    return binary


class TestOperandAnalysisCryptoConstantDetection:
    """Test operand analysis for crypto constant detection in validation algorithms."""

    def test_detect_md5_init_constants_in_operands(self, tmp_path: Path) -> None:
        """Extractor detects MD5 initialization constants in instruction operands."""
        md5_constants = [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE]

        binary = create_test_binary_with_crypto_constants(md5_constants)
        binary_path = tmp_path / "md5_test.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_constants: list[int] = []
        for insn in instructions:
            if insn.mnemonic == "mov":
                for op in insn.operands:
                    if op.type == capstone.x86.X86_OP_IMM:
                        detected_constants.append(op.imm)

        assert len(detected_constants) >= 4, "MD5 constants not detected in operands"
        for const in md5_constants:
            assert const in detected_constants, f"MD5 constant {hex(const)} not found"

    def test_detect_sha256_round_constants_operands(self, tmp_path: Path) -> None:
        """Extractor detects SHA-256 round constants from operand analysis."""
        sha256_constants = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A]

        binary = create_test_binary_with_crypto_constants(sha256_constants)
        binary_path = tmp_path / "sha256_test.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_sha_constants = []
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM:
                    if op.imm in sha256_constants:
                        detected_sha_constants.append(op.imm)

        assert len(detected_sha_constants) >= 2, "SHA-256 constants not detected"
        assert 0x6A09E667 in detected_sha_constants, "SHA-256 K0 constant not found"

    def test_detect_aes_sbox_initialization_constants(self, tmp_path: Path) -> None:
        """Extractor detects AES S-box initialization from immediate operands."""
        aes_sbox_start = 0x637C777B

        binary = create_test_binary_with_crypto_constants([aes_sbox_start])
        binary_path = tmp_path / "aes_test.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        found_aes_constant = False
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM and op.imm == aes_sbox_start:
                    found_aes_constant = True

        assert found_aes_constant, "AES S-box constant not detected in operands"

    def test_detect_crc32_polynomial_immediate_values(self, tmp_path: Path) -> None:
        """Extractor detects CRC32 polynomial constants in immediate operands."""
        crc32_poly = 0x04C11DB7
        crc32_poly_reversed = 0xEDB88320

        binary = create_test_binary_with_crypto_constants([crc32_poly, crc32_poly_reversed])
        binary_path = tmp_path / "crc32_test.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_crc_constants = []
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM:
                    if op.imm in [crc32_poly, crc32_poly_reversed]:
                        detected_crc_constants.append(op.imm)

        assert len(detected_crc_constants) >= 1, "CRC32 polynomial not detected"


class TestMagicNumberAndIVScanning:
    """Test scanning for magic numbers and initialization vectors in binaries."""

    def test_scan_for_des_magic_numbers(self, tmp_path: Path) -> None:
        """Extractor scans and identifies DES-specific magic numbers."""
        des_constant = 0x01234567
        des_magic = 0x89ABCDEF

        binary = create_test_binary_with_crypto_constants([des_constant, des_magic])
        binary_path = tmp_path / "des_magic.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        found_des_constants = []
        for i in range(0, len(code_data) - 4):
            dword = struct.unpack("<I", code_data[i : i + 4])[0]
            if dword in [des_constant, des_magic]:
                found_des_constants.append(dword)

        assert len(found_des_constants) >= 2, "DES magic numbers not scanned"
        assert des_constant in found_des_constants

    def test_scan_initialization_vectors_all_zeros(self, tmp_path: Path) -> None:
        """Extractor detects weak all-zero initialization vectors."""
        zero_iv = 0x00000000

        binary = create_test_binary_with_crypto_constants([zero_iv] * 4)
        binary_path = tmp_path / "zero_iv.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        zero_count = code_data.count(b"\x00\x00\x00\x00")

        assert zero_count >= 4, "Zero IV pattern not detected"

    def test_scan_initialization_vectors_all_ones(self, tmp_path: Path) -> None:
        """Extractor detects weak all-ones initialization vectors."""
        ones_iv = 0xFFFFFFFF

        binary = create_test_binary_with_crypto_constants([ones_iv] * 4)
        binary_path = tmp_path / "ones_iv.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        ones_count = code_data.count(b"\xff\xff\xff\xff")

        assert ones_count >= 4, "All-ones IV pattern not detected"

    def test_scan_predictable_iv_repeating_patterns(self, tmp_path: Path) -> None:
        """Extractor identifies predictable IV patterns (repeating bytes)."""
        repeating_iv = 0x11111111

        binary = create_test_binary_with_crypto_constants([repeating_iv] * 3)
        binary_path = tmp_path / "repeating_iv.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        pattern_count = code_data.count(b"\x11\x11\x11\x11")

        assert pattern_count >= 3, "Repeating IV pattern not detected"


class TestWeakKeyLengthIdentification:
    """Test identification of weak key lengths in cryptographic operations."""

    def test_identify_512bit_rsa_key_length(self, tmp_path: Path) -> None:
        """Extractor identifies critically weak 512-bit RSA key length."""
        rsa_key_length = 512

        binary = create_test_binary_with_crypto_constants([rsa_key_length])
        binary_path = tmp_path / "rsa512.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_key_length = None
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM and op.imm == rsa_key_length:
                    detected_key_length = op.imm

        assert detected_key_length == 512, "512-bit RSA key length not identified"

    def test_identify_1024bit_rsa_deprecated_length(self, tmp_path: Path) -> None:
        """Extractor identifies deprecated 1024-bit RSA key length."""
        rsa_key_length = 1024

        binary = create_test_binary_with_crypto_constants([rsa_key_length])
        binary_path = tmp_path / "rsa1024.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_key_length = None
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM and op.imm == rsa_key_length:
                    detected_key_length = op.imm

        assert detected_key_length == 1024, "1024-bit RSA key length not identified"

    def test_identify_des_56bit_weak_key(self, tmp_path: Path) -> None:
        """Extractor identifies critically weak 56-bit DES key."""
        des_key_length = 56

        binary = create_test_binary_with_crypto_constants([des_key_length])
        binary_path = tmp_path / "des56.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_key_length = None
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM and op.imm == des_key_length:
                    detected_key_length = op.imm

        assert detected_key_length == 56, "56-bit DES key length not identified"

    def test_identify_128bit_aes_minimum_acceptable(self, tmp_path: Path) -> None:
        """Extractor identifies 128-bit AES as minimum acceptable length."""
        aes_key_length = 128

        binary = create_test_binary_with_crypto_constants([aes_key_length])
        binary_path = tmp_path / "aes128.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        detected_key_length = None
        for insn in instructions:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM and op.imm == aes_key_length:
                    detected_key_length = op.imm

        assert detected_key_length == 128, "128-bit AES key length not identified"


class TestInsecureAlgorithmDetection:
    """Test detection of insecure cryptographic algorithms."""

    def test_detect_md5_algorithm_usage(self, tmp_path: Path) -> None:
        """Extractor detects MD5 algorithm usage as insecure."""
        binary = create_binary_with_strings(["MD5_Init", "MD5_Update", "MD5_Final"])
        binary_path = tmp_path / "md5_usage.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("MD5" in s for s in strings), "MD5 algorithm not detected"

    def test_detect_md4_critical_algorithm(self, tmp_path: Path) -> None:
        """Extractor detects critically insecure MD4 algorithm."""
        binary = create_binary_with_strings(["MD4_Init", "MD4_Update"])
        binary_path = tmp_path / "md4_usage.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("MD4" in s for s in strings), "MD4 algorithm not detected"

    def test_detect_sha1_deprecated_algorithm(self, tmp_path: Path) -> None:
        """Extractor detects deprecated SHA-1 algorithm usage."""
        binary = create_binary_with_strings(["SHA1_Init", "SHA1_Transform"])
        binary_path = tmp_path / "sha1_usage.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("SHA1" in s for s in strings), "SHA-1 algorithm not detected"

    def test_detect_des_critically_weak_cipher(self, tmp_path: Path) -> None:
        """Extractor detects critically weak DES cipher usage."""
        binary = create_binary_with_strings(["DES_encrypt", "DES_set_key"])
        binary_path = tmp_path / "des_usage.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("DES" in s for s in strings), "DES cipher not detected"

    def test_detect_rc4_stream_cipher_weakness(self, tmp_path: Path) -> None:
        """Extractor detects weak RC4 stream cipher."""
        binary = create_binary_with_strings(["RC4_set_key", "RC4"])
        binary_path = tmp_path / "rc4_usage.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("RC4" in s for s in strings), "RC4 cipher not detected"


class TestHardcodedKeyAndPasswordDetection:
    """Test detection of hardcoded cryptographic keys and passwords."""

    def test_detect_hardcoded_password_string(self, tmp_path: Path) -> None:
        """Extractor detects hardcoded password strings in binary."""
        binary = create_binary_with_strings(["password", "secret", "default"])
        binary_path = tmp_path / "hardcoded_pwd.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        hardcoded_keywords = ["password", "secret", "default"]
        detected = [s for s in strings if any(kw in s.lower() for kw in hardcoded_keywords)]

        assert len(detected) >= 1, "Hardcoded password strings not detected"

    def test_detect_common_weak_key_12345678(self, tmp_path: Path) -> None:
        """Extractor detects common weak key pattern '12345678'."""
        binary = create_binary_with_strings(["12345678"])
        binary_path = tmp_path / "weak_key.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("12345678" in s for s in strings), "Common weak key not detected"

    def test_detect_hex_pattern_key_0123456789ABCDEF(self, tmp_path: Path) -> None:
        """Extractor detects hex pattern keys like 0123456789ABCDEF."""
        binary = create_binary_with_strings(["0123456789ABCDEF"])
        binary_path = tmp_path / "hex_key.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 8:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        assert any("0123456789ABCDEF" in s for s in strings), "Hex pattern key not detected"

    def test_detect_embedded_all_zero_key(self, tmp_path: Path) -> None:
        """Extractor detects embedded all-zero cryptographic keys."""
        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x0b\x01" + b"\x00" * 222

        section_header = (
            b".data\x00\x00\x00"
            + struct.pack("<IIIIIIHH", 0x200, 0x3000, 0x200, 0x200, 0, 0, 0, 0xC0000040)
        )

        section_data = b"HEADER" + b"\x00" * 16 + b"FOOTER"
        section_data = section_data.ljust(0x200, b"\x00")

        binary = dos_header + b"\x00" * (0x80 - len(dos_header))
        binary += pe_signature + coff_header + optional_header + section_header + section_data

        binary_path = tmp_path / "zero_key.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        data_section = pe.sections[0]
        section_data = data_section.get_data()

        zero_sequences = []
        for i in range(len(section_data) - 15):
            if section_data[i : i + 16] == b"\x00" * 16:
                zero_sequences.append(i)

        assert len(zero_sequences) >= 1, "All-zero embedded key not detected"


class TestVulnerabilitySeverityReporting:
    """Test vulnerability severity level reporting for detected weaknesses."""

    def test_report_critical_severity_md4(self, tmp_path: Path) -> None:
        """Detector assigns CRITICAL severity to MD4 usage."""
        binary = create_binary_with_strings(["MD4_Init"])
        binary_path = tmp_path / "md4_critical.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        has_md4 = any("MD4" in s for s in strings)
        assert has_md4, "MD4 not detected for severity assessment"

    def test_report_high_severity_md5(self, tmp_path: Path) -> None:
        """Detector assigns HIGH severity to MD5 usage."""
        binary = create_binary_with_strings(["MD5_Init"])
        binary_path = tmp_path / "md5_high.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        has_md5 = any("MD5" in s for s in strings)
        assert has_md5, "MD5 not detected for severity assessment"

    def test_report_medium_severity_sha1(self, tmp_path: Path) -> None:
        """Detector assigns MEDIUM severity to SHA-1 usage."""
        binary = create_binary_with_strings(["SHA1_Init"])
        binary_path = tmp_path / "sha1_medium.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        has_sha1 = any("SHA1" in s for s in strings)
        assert has_sha1, "SHA-1 not detected for severity assessment"

    def test_severity_levels_properly_ordered(self) -> None:
        """Severity levels follow proper ordering for prioritization."""
        severities = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1, "INFO": 0}

        assert severities["CRITICAL"] > severities["HIGH"]
        assert severities["HIGH"] > severities["MEDIUM"]
        assert severities["MEDIUM"] > severities["LOW"]
        assert severities["LOW"] > severities["INFO"]


class TestEdgeCasesObfuscatedConstants:
    """Test edge cases: obfuscated constants and dynamic key generation."""

    def test_detect_split_constant_loading(self, tmp_path: Path) -> None:
        """Detector handles constants loaded in multiple parts."""
        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x0b\x01" + b"\x00" * 222

        section_header = (
            b".text\x00\x00\x00"
            + struct.pack("<IIIIIIHH", 0x200, 0x1000, 0x200, 0x200, 0, 0, 0, 0x60000020)
        )

        section_data = b"\xb8\x00\x00\x6a\xd7"
        section_data += b"\x05\x78\xa4\x00\x00"
        section_data += b"\x90" * (0x200 - len(section_data))

        binary = dos_header + b"\x00" * (0x80 - len(dos_header))
        binary += pe_signature + coff_header + optional_header + section_header + section_data

        binary_path = tmp_path / "split_const.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        assert len(instructions) >= 2, "Split constant instructions not disassembled"

    def test_handle_xor_obfuscated_constant(self, tmp_path: Path) -> None:
        """Detector identifies XOR-obfuscated cryptographic constants."""
        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x0b\x01" + b"\x00" * 222

        section_header = (
            b".text\x00\x00\x00"
            + struct.pack("<IIIIIIHH", 0x200, 0x1000, 0x200, 0x200, 0, 0, 0, 0x60000020)
        )

        obfuscated_const = 0xD76AA478 ^ 0xAAAAAAAA
        section_data = b"\xb8" + struct.pack("<I", obfuscated_const)
        section_data += b"\x35\xaa\xaa\xaa\xaa"
        section_data += b"\x90" * (0x200 - len(section_data))

        binary = dos_header + b"\x00" * (0x80 - len(dos_header))
        binary += pe_signature + coff_header + optional_header + section_header + section_data

        binary_path = tmp_path / "xor_const.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        has_xor = any(insn.mnemonic == "xor" for insn in instructions)
        assert has_xor, "XOR obfuscation not detected"

    def test_dynamic_key_generation_no_false_positives(self, tmp_path: Path) -> None:
        """Detector avoids false positives for dynamic key generation."""
        binary = create_binary_with_strings(["CryptGenRandom", "RtlGenRandom"])
        binary_path = tmp_path / "dynamic_key.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        strings = []
        for section in pe.sections:
            section_data = section.get_data()
            current_string = b""
            for byte in section_data:
                if 32 <= byte < 127:
                    current_string += bytes([byte])
                elif current_string:
                    if len(current_string) >= 4:
                        strings.append(current_string.decode("ascii", errors="ignore"))
                    current_string = b""

        has_random_gen = any("Random" in s for s in strings)
        assert has_random_gen, "Dynamic key generation functions not found"

    def test_runtime_computed_constants_detection(self, tmp_path: Path) -> None:
        """Detector handles runtime-computed constants appropriately."""
        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x0b\x01" + b"\x00" * 222

        section_header = (
            b".text\x00\x00\x00"
            + struct.pack("<IIIIIIHH", 0x200, 0x1000, 0x200, 0x200, 0, 0, 0, 0x60000020)
        )

        section_data = b"\x0f\x31"
        section_data += b"\x31\xd0"
        section_data += b"\x90" * (0x200 - len(section_data))

        binary = dos_header + b"\x00" * (0x80 - len(dos_header))
        binary += pe_signature + coff_header + optional_header + section_header + section_data

        binary_path = tmp_path / "runtime_const.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        has_rdtsc = any(insn.mnemonic == "rdtsc" for insn in instructions)
        assert has_rdtsc, "Runtime timestamp counter not detected"

    def test_polymorphic_constant_loading_patterns(self, tmp_path: Path) -> None:
        """Detector handles polymorphic constant loading techniques."""
        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x0b\x01" + b"\x00" * 222

        section_header = (
            b".text\x00\x00\x00"
            + struct.pack("<IIIIIIHH", 0x200, 0x1000, 0x200, 0x200, 0, 0, 0, 0x60000020)
        )

        section_data = b"\x68\x78\xa4\x6a\xd7"
        section_data += b"\x58"
        section_data += b"\xc1\xc8\x08"
        section_data += b"\xc1\xc0\x08"
        section_data += b"\x90" * (0x200 - len(section_data))

        binary = dos_header + b"\x00" * (0x80 - len(dos_header))
        binary += pe_signature + coff_header + optional_header + section_header + section_data

        binary_path = tmp_path / "polymorphic.exe"
        binary_path.write_bytes(binary)

        extractor = AlgorithmExtractor()
        pe = pefile.PE(data=binary)

        code_section = pe.sections[0]
        code_data = code_section.get_data()

        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        instructions = list(md.disasm(code_data, code_section.VirtualAddress))

        has_rotation = any(insn.mnemonic in ["ror", "rol"] for insn in instructions)
        assert has_rotation, "Polymorphic rotation instructions not detected"
