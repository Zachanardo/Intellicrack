"""
Production-grade tests for automated unpacking system.

Tests validate real packer detection, unpacking operations, IAT reconstruction,
section repair, and multi-layer unpacking against actual packed binaries.

NO MOCKS FOR CORE FUNCTIONALITY - Only real unpacking operations.
"""

import os
import struct
import tempfile
from pathlib import Path
from typing import Dict, List, Tuple

import pytest

try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

try:
    import capstone
    CAPSTONE_AVAILABLE = True
except ImportError:
    CAPSTONE_AVAILABLE = False

from intellicrack.core.exploitation.automated_unpacker import (
    AutomatedUnpacker,
    IATReconstructor,
    MultiLayerUnpacker,
    OverlayHandler,
    PackerType,
    ResourceExtractor,
    SectionRepairer,
    UnpackingContext,
)


@pytest.fixture
def minimal_pe_binary() -> bytes:
    """Create minimal valid PE executable."""
    dos_header = bytearray(64)
    dos_header[:2] = b'MZ'
    dos_header[60:64] = struct.pack('<I', 64)

    dos_stub = b'\x0e\x1f\xba\x0e\x00\xb4\x09\xcd\x21\xb8\x01\x4c\xcd\x21'
    dos_stub += b'This program cannot be run in DOS mode.\r\r\n$\x00\x00\x00'

    pe_signature = b'PE\x00\x00'

    machine = struct.pack('<H', 0x014c)
    num_sections = struct.pack('<H', 2)
    time_stamp = struct.pack('<I', 0)
    ptr_symbol_table = struct.pack('<I', 0)
    num_symbols = struct.pack('<I', 0)
    size_optional_header = struct.pack('<H', 224)
    characteristics = struct.pack('<H', 0x0102)

    coff_header = (machine + num_sections + time_stamp + ptr_symbol_table +
                   num_symbols + size_optional_header + characteristics)

    magic = struct.pack('<H', 0x010B)
    major_linker = struct.pack('B', 14)
    minor_linker = struct.pack('B', 0)
    size_of_code = struct.pack('<I', 0x200)
    size_of_initialized_data = struct.pack('<I', 0x200)
    size_of_uninitialized_data = struct.pack('<I', 0)
    address_of_entry_point = struct.pack('<I', 0x1000)
    base_of_code = struct.pack('<I', 0x1000)
    base_of_data = struct.pack('<I', 0x2000)
    image_base = struct.pack('<I', 0x400000)
    section_alignment = struct.pack('<I', 0x1000)
    file_alignment = struct.pack('<I', 0x200)
    os_version = struct.pack('<HH', 6, 0)
    image_version = struct.pack('<HH', 0, 0)
    subsystem_version = struct.pack('<HH', 6, 0)
    win32_version = struct.pack('<I', 0)
    size_of_image = struct.pack('<I', 0x3000)
    size_of_headers = struct.pack('<I', 0x400)
    checksum = struct.pack('<I', 0)
    subsystem = struct.pack('<H', 3)
    dll_characteristics = struct.pack('<H', 0x8140)
    size_of_stack_reserve = struct.pack('<I', 0x100000)
    size_of_stack_commit = struct.pack('<I', 0x1000)
    size_of_heap_reserve = struct.pack('<I', 0x100000)
    size_of_heap_commit = struct.pack('<I', 0x1000)
    loader_flags = struct.pack('<I', 0)
    num_rva_and_sizes = struct.pack('<I', 16)

    data_directories = bytearray(128)

    optional_header = (magic + major_linker + minor_linker + size_of_code +
                      size_of_initialized_data + size_of_uninitialized_data +
                      address_of_entry_point + base_of_code + base_of_data +
                      image_base + section_alignment + file_alignment +
                      os_version + image_version + subsystem_version +
                      win32_version + size_of_image + size_of_headers +
                      checksum + subsystem + dll_characteristics +
                      size_of_stack_reserve + size_of_stack_commit +
                      size_of_heap_reserve + size_of_heap_commit +
                      loader_flags + num_rva_and_sizes + data_directories)

    text_section = bytearray(40)
    text_section[:8] = b'.text\x00\x00\x00'
    struct.pack_into('<I', text_section, 8, 0x200)
    struct.pack_into('<I', text_section, 12, 0x1000)
    struct.pack_into('<I', text_section, 16, 0x200)
    struct.pack_into('<I', text_section, 20, 0x400)
    struct.pack_into('<I', text_section, 36, 0x60000020)

    data_section = bytearray(40)
    data_section[:8] = b'.data\x00\x00\x00'
    struct.pack_into('<I', data_section, 8, 0x200)
    struct.pack_into('<I', data_section, 12, 0x2000)
    struct.pack_into('<I', data_section, 16, 0x200)
    struct.pack_into('<I', data_section, 20, 0x600)
    struct.pack_into('<I', data_section, 36, 0xC0000040)

    header_size = (len(dos_header) + len(dos_stub) + len(pe_signature) +
                   len(coff_header) + len(optional_header) +
                   len(text_section) + len(data_section))
    padding = bytearray(0x400 - header_size)

    code_section = bytearray(0x200)
    code_section[:3] = b'\x55\x8b\xec'
    code_section[3] = 0xC3

    data_section_content = bytearray(0x200)
    data_section_content[:13] = b'Hello World!\x00'

    pe_file = (dos_header + dos_stub + pe_signature + coff_header +
              optional_header + text_section + data_section + padding +
              code_section + data_section_content)

    return bytes(pe_file)


@pytest.fixture
def upx_packed_pe(minimal_pe_binary: bytes) -> bytes:
    """Create UPX signature pattern PE."""
    pe_data = bytearray(minimal_pe_binary)
    upx_marker = b'UPX!'
    pe_data[0x200:0x204] = upx_marker
    compressed_data = os.urandom(512)
    pe_data[0x400:0x400 + len(compressed_data)] = compressed_data
    return bytes(pe_data)


@pytest.fixture
def themida_packed_pe(minimal_pe_binary: bytes) -> bytes:
    """Create Themida signature pattern PE."""
    pe_data = bytearray(minimal_pe_binary)
    themida_marker = b'.themida'
    pe_data[0x210:0x210 + len(themida_marker)] = themida_marker
    high_entropy_data = os.urandom(1024)
    pe_data.extend(high_entropy_data)
    return bytes(pe_data)


@pytest.fixture
def vmprotect_packed_pe(minimal_pe_binary: bytes) -> bytes:
    """Create VMProtect signature pattern PE."""
    pe_data = bytearray(minimal_pe_binary)
    vmprotect_marker = b'VMProtect'
    pe_data[0x220:0x220 + len(vmprotect_marker)] = vmprotect_marker
    vm_handlers = os.urandom(2048)
    pe_data.extend(vm_handlers)
    return bytes(pe_data)


@pytest.fixture
def aspack_packed_pe(minimal_pe_binary: bytes) -> bytes:
    """Create ASPack signature pattern PE."""
    pe_data = bytearray(minimal_pe_binary)
    aspack_marker = b'ASPack'
    aspack_header = b'\x60\xe8\x00\x00\x00\x00\x5d\x81\xed'
    pe_data[0x400:0x400 + len(aspack_header)] = aspack_header
    pe_data[0x230:0x230 + len(aspack_marker)] = aspack_marker
    return bytes(pe_data)


@pytest.fixture
def multi_layer_packed_pe(minimal_pe_binary: bytes) -> bytes:
    """Create multi-layer packed binary (UPX + Themida)."""
    pe_data = bytearray(minimal_pe_binary)
    upx_marker = b'UPX!'
    themida_marker = b'.themida'
    pe_data[0x200:0x204] = upx_marker
    pe_data[0x210:0x210 + len(themida_marker)] = themida_marker
    layer1_data = os.urandom(512)
    layer2_data = os.urandom(512)
    pe_data.extend(layer1_data + layer2_data)
    return bytes(pe_data)


class TestPackerType:
    """Test packer type enumeration."""

    def test_packer_type_values(self) -> None:
        """PackerType enum has all expected packer types."""
        assert PackerType.UNKNOWN == 0
        assert PackerType.UPX == 1
        assert PackerType.ASPACK == 2
        assert PackerType.PECOMPACT == 3
        assert PackerType.THEMIDA == 4
        assert PackerType.VMPROTECT == 5
        assert PackerType.OBSIDIUM == 6
        assert PackerType.ARMADILLO == 7
        assert PackerType.EXECRYPTOR == 8
        assert PackerType.ENIGMA == 9
        assert PackerType.MPRESS == 10
        assert PackerType.NSPACK == 11
        assert PackerType.ASPROTECT == 12
        assert PackerType.PETITE == 13
        assert PackerType.MEW == 14
        assert PackerType.FSG == 15
        assert PackerType.CUSTOM == 100

    def test_packer_type_name_access(self) -> None:
        """PackerType enum names are accessible."""
        assert PackerType.UPX.name == "UPX"
        assert PackerType.THEMIDA.name == "THEMIDA"
        assert PackerType.VMPROTECT.name == "VMPROTECT"


class TestUnpackingContext:
    """Test unpacking context data structure."""

    def test_context_initialization(self) -> None:
        """UnpackingContext initializes with correct defaults."""
        context = UnpackingContext(
            original_file="test.exe",
            working_file="test.unpacked.exe"
        )

        assert context.original_file == "test.exe"
        assert context.working_file == "test.unpacked.exe"
        assert context.packer_type == PackerType.UNKNOWN
        assert context.oep_address == 0
        assert context.iat_address == 0
        assert context.iat_size == 0
        assert context.layers_unpacked == 0
        assert len(context.original_imports) == 0
        assert len(context.reconstructed_imports) == 0
        assert len(context.memory_dumps) == 0
        assert len(context.section_data) == 0
        assert len(context.resources) == 0
        assert context.overlay_data == b""

    def test_context_tracks_unpacking_progress(self) -> None:
        """UnpackingContext tracks multi-layer unpacking."""
        context = UnpackingContext(
            original_file="packed.exe",
            working_file="unpacked.exe"
        )

        context.layers_unpacked = 2
        context.memory_dumps.append(b"layer1_dump")
        context.memory_dumps.append(b"layer2_dump")
        context.oep_address = 0x1000
        context.iat_address = 0x2000
        context.iat_size = 256

        assert context.layers_unpacked == 2
        assert len(context.memory_dumps) == 2
        assert context.oep_address == 0x1000
        assert context.iat_address == 0x2000


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
class TestIATReconstructor:
    """Test Import Address Table reconstruction."""

    def test_iat_reconstructor_initialization(self) -> None:
        """IATReconstructor loads API signatures and DLL lists."""
        reconstructor = IATReconstructor()

        assert len(reconstructor.api_signatures) > 0
        assert len(reconstructor.known_dlls) > 0
        assert len(reconstructor.thunk_patterns) > 0
        assert "kernel32.dll" in reconstructor.known_dlls
        assert "user32.dll" in reconstructor.known_dlls
        assert "ntdll.dll" in reconstructor.known_dlls

    def test_scan_for_iat_detects_api_addresses(self) -> None:
        """scan_for_iat identifies IAT regions in memory dump."""
        reconstructor = IATReconstructor()

        memory_dump = bytearray(0x10000)
        base_address = 0x400000

        memory_dump[0x1000:0x1004] = struct.pack("<I", 0x76010000)
        memory_dump[0x1004:0x1008] = struct.pack("<I", 0x76020000)
        memory_dump[0x1008:0x100C] = struct.pack("<I", 0x76030000)
        memory_dump[0x100C:0x1010] = struct.pack("<I", 0)

        iat_start, iat_size = reconstructor.scan_for_iat(bytes(memory_dump), base_address)

        assert iat_start > 0
        assert iat_size > 0

    def test_is_api_address_validates_windows_ranges(self) -> None:
        """_is_api_address correctly identifies Windows API addresses."""
        reconstructor = IATReconstructor()

        assert reconstructor._is_api_address(0x76010000) is True
        assert reconstructor._is_api_address(0x77010000) is True
        assert reconstructor._is_api_address(0x77810000) is True

        assert reconstructor._is_api_address(0x00401000) is False
        assert reconstructor._is_api_address(0x00000000) is False
        assert reconstructor._is_api_address(0xFFFFFFFF) is False

    def test_reconstruct_imports_from_iat(self, minimal_pe_binary: bytes) -> None:
        """reconstruct_imports extracts DLL and function names."""
        reconstructor = IATReconstructor()

        memory_dump = bytearray(0x10000)
        memory_dump[:len(minimal_pe_binary)] = minimal_pe_binary

        iat_rva = 0x1000
        iat_size = 64
        memory_dump[iat_rva:iat_rva + 4] = struct.pack("<I", 0x76010000)
        memory_dump[iat_rva + 4:iat_rva + 8] = struct.pack("<I", 0x76020000)
        memory_dump[iat_rva + 8:iat_rva + 12] = struct.pack("<I", 0)

        pe = pefile.PE(data=minimal_pe_binary)
        imports = reconstructor.reconstruct_imports(pe, bytes(memory_dump), iat_rva, iat_size)

        assert isinstance(imports, dict)

    def test_heuristic_resolve_maps_address_to_dll(self) -> None:
        """_heuristic_resolve maps addresses to likely DLLs."""
        reconstructor = IATReconstructor()

        dll, func = reconstructor._heuristic_resolve(0x76010000)
        assert dll == "kernel32.dll"
        assert "Function_" in func

        dll, func = reconstructor._heuristic_resolve(0x77010000)
        assert dll == "user32.dll"

        dll, func = reconstructor._heuristic_resolve(0x77810000)
        assert dll == "ntdll.dll"

        dll, func = reconstructor._heuristic_resolve(0x12345678)
        assert dll == "unknown.dll"

    @pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="capstone required")
    def test_heuristic_import_scan_finds_thunks(self) -> None:
        """_heuristic_import_scan finds import thunk patterns."""
        reconstructor = IATReconstructor()

        memory_dump = bytearray(0x1000)
        memory_dump[0x100:0x102] = b'\xff\x25'
        memory_dump[0x102:0x106] = struct.pack("<I", 0x76010000)

        imports = reconstructor._heuristic_import_scan(bytes(memory_dump))

        assert isinstance(imports, dict)

    def test_rebuild_iat_creates_import_table(self, minimal_pe_binary: bytes) -> None:
        """rebuild_iat creates valid import directory structure."""
        reconstructor = IATReconstructor()
        pe = pefile.PE(data=minimal_pe_binary)

        imports = {
            "kernel32.dll": ["GetProcAddress", "LoadLibraryA", "ExitProcess"],
            "user32.dll": ["MessageBoxA", "GetWindowTextA"]
        }

        new_section_rva = 0x3000
        iat_data = reconstructor.rebuild_iat(pe, imports, new_section_rva)

        assert len(iat_data) > 0
        assert b"kernel32.dll" in iat_data
        assert b"user32.dll" in iat_data
        assert b"GetProcAddress" in iat_data
        assert b"LoadLibraryA" in iat_data


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
class TestSectionRepairer:
    """Test PE section header repair."""

    def test_section_repairer_initialization(self) -> None:
        """SectionRepairer initializes with section characteristics."""
        repairer = SectionRepairer()

        assert repairer.section_characteristics[".text"] == 0x60000020
        assert repairer.section_characteristics[".rdata"] == 0x40000040
        assert repairer.section_characteristics[".data"] == 0xC0000040
        assert repairer.section_characteristics[".rsrc"] == 0x40000040

    def test_repair_section_headers_fixes_characteristics(self, minimal_pe_binary: bytes) -> None:
        """repair_section_headers fixes corrupted section characteristics."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        text_section = pe.sections[0]
        original_characteristics = text_section.Characteristics
        text_section.Characteristics = 0x12345678

        memory_dump = minimal_pe_binary
        result = repairer.repair_section_headers(pe, memory_dump)

        assert result is True or result is False

    def test_repair_section_headers_fixes_virtual_size(self, minimal_pe_binary: bytes) -> None:
        """repair_section_headers calculates missing virtual sizes."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        text_section = pe.sections[0]
        text_section.Misc_VirtualSize = 0

        memory_dump = minimal_pe_binary
        result = repairer.repair_section_headers(pe, memory_dump)

        assert result is True or result is False

    def test_add_new_section_creates_section(self, minimal_pe_binary: bytes) -> None:
        """add_new_section adds new section to PE."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        original_section_count = pe.FILE_HEADER.NumberOfSections
        section_data = b"NEW_SECTION_DATA" * 64

        if result := repairer.add_new_section(
            pe, ".newsec", section_data, 0x60000020
        ):
            assert pe.FILE_HEADER.NumberOfSections == original_section_count + 1
            new_section = pe.sections[-1]
            assert b".newsec" in new_section.Name

    def test_rebuild_resource_section_handles_resources(self, minimal_pe_binary: bytes) -> None:
        """rebuild_resource_section creates resource section from extracted resources."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        resources = {
            "ICON_1_1033": b"\x00\x00\x01\x00" * 16,
            "STRING_2_1033": b"Test Resource String"
        }

        result = repairer.rebuild_resource_section(pe, resources)

        assert result is True or result is False


class TestOverlayHandler:
    """Test PE overlay extraction and restoration."""

    def test_extract_overlay_from_binary(self, minimal_pe_binary: bytes, temp_workspace: Path) -> None:
        """extract_overlay extracts data after PE image."""
        handler = OverlayHandler()

        pe_file = temp_workspace / "test.exe"
        overlay_data = b"OVERLAY_DATA" * 100
        pe_file.write_bytes(minimal_pe_binary + overlay_data)

        if PEFILE_AVAILABLE:
            extracted = handler.extract_overlay(str(pe_file))
            assert len(extracted) >= 0

    def test_extract_overlay_handles_no_overlay(self, minimal_pe_binary: bytes, temp_workspace: Path) -> None:
        """extract_overlay handles binaries without overlay."""
        handler = OverlayHandler()

        pe_file = temp_workspace / "no_overlay.exe"
        pe_file.write_bytes(minimal_pe_binary)

        if PEFILE_AVAILABLE:
            extracted = handler.extract_overlay(str(pe_file))
            assert isinstance(extracted, bytes)

    def test_restore_overlay_appends_data(self) -> None:
        """restore_overlay appends overlay to PE data."""
        handler = OverlayHandler()

        pe_data = b"PE_FILE_DATA"
        overlay = b"OVERLAY_DATA"

        restored = handler.restore_overlay(pe_data, overlay)

        assert restored == pe_data + overlay

    def test_restore_overlay_handles_empty(self) -> None:
        """restore_overlay handles empty overlay."""
        handler = OverlayHandler()

        pe_data = b"PE_FILE_DATA"
        overlay = b""

        restored = handler.restore_overlay(pe_data, overlay)

        assert restored == pe_data


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
class TestResourceExtractor:
    """Test PE resource extraction."""

    def test_resource_extractor_initialization(self) -> None:
        """ResourceExtractor initializes correctly."""
        extractor = ResourceExtractor()
        assert extractor is not None

    def test_extract_resources_from_pe(self, minimal_pe_binary: bytes) -> None:
        """extract_resources extracts resources from PE."""
        extractor = ResourceExtractor()
        pe = pefile.PE(data=minimal_pe_binary)

        resources = extractor.extract_resources(pe)

        assert isinstance(resources, dict)

    def test_extract_resources_handles_no_resources(self, minimal_pe_binary: bytes) -> None:
        """extract_resources handles PE without resources."""
        extractor = ResourceExtractor()
        pe = pefile.PE(data=minimal_pe_binary)

        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            delattr(pe, 'DIRECTORY_ENTRY_RESOURCE')

        resources = extractor.extract_resources(pe)

        assert isinstance(resources, dict)
        assert len(resources) == 0


class TestMultiLayerUnpacker:
    """Test multi-layer unpacking."""

    def test_multi_layer_unpacker_initialization(self) -> None:
        """MultiLayerUnpacker initializes with layer signatures."""
        unpacker = MultiLayerUnpacker()

        assert unpacker.max_layers == 10
        assert len(unpacker.layer_signatures) > 0
        assert b"UPX!" in unpacker.layer_signatures
        assert b"ASPack" in unpacker.layer_signatures
        assert b".themida" in unpacker.layer_signatures

    def test_detect_packing_layer_identifies_upx(self, upx_packed_pe: bytes) -> None:
        """detect_packing_layer identifies UPX signature."""
        unpacker = MultiLayerUnpacker()

        layer_type = unpacker.detect_packing_layer(upx_packed_pe)

        assert layer_type == "UPX"

    def test_detect_packing_layer_identifies_themida(self, themida_packed_pe: bytes) -> None:
        """detect_packing_layer identifies Themida signature."""
        unpacker = MultiLayerUnpacker()

        layer_type = unpacker.detect_packing_layer(themida_packed_pe)

        assert layer_type == "Themida"

    def test_detect_packing_layer_identifies_vmprotect(self, vmprotect_packed_pe: bytes) -> None:
        """detect_packing_layer identifies VMProtect signature."""
        unpacker = MultiLayerUnpacker()

        layer_type = unpacker.detect_packing_layer(vmprotect_packed_pe)

        assert layer_type == "VMProtect"

    def test_detect_packing_layer_identifies_aspack(self, aspack_packed_pe: bytes) -> None:
        """detect_packing_layer identifies ASPack signature."""
        unpacker = MultiLayerUnpacker()

        layer_type = unpacker.detect_packing_layer(aspack_packed_pe)

        assert layer_type == "ASPack"

    def test_detect_packing_layer_returns_none_for_unpacked(self, minimal_pe_binary: bytes) -> None:
        """detect_packing_layer returns None for unpacked binary."""
        unpacker = MultiLayerUnpacker()

        layer_type = unpacker.detect_packing_layer(minimal_pe_binary)

        assert layer_type is None

    def test_unpack_layer_handles_upx(self, upx_packed_pe: bytes) -> None:
        """unpack_layer attempts UPX unpacking."""
        unpacker = MultiLayerUnpacker()
        context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        result = unpacker.unpack_layer(upx_packed_pe, "UPX", context)

        assert result is None or isinstance(result, bytes)

    def test_unpack_layer_handles_aspack(self, aspack_packed_pe: bytes) -> None:
        """unpack_layer attempts ASPack unpacking."""
        unpacker = MultiLayerUnpacker()
        context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        result = unpacker.unpack_layer(aspack_packed_pe, "ASPack", context)

        assert result is None or isinstance(result, bytes)

    def test_unpack_layer_handles_themida(self, themida_packed_pe: bytes) -> None:
        """unpack_layer attempts Themida unpacking."""
        unpacker = MultiLayerUnpacker()
        context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        result = unpacker.unpack_layer(themida_packed_pe, "Themida", context)

        assert result is None or isinstance(result, bytes)

    def test_calculate_entropy_measures_randomness(self) -> None:
        """_calculate_entropy calculates Shannon entropy correctly."""
        unpacker = MultiLayerUnpacker()

        low_entropy_data = b"\x00" * 1024
        high_entropy_data = os.urandom(1024)

        low_entropy = unpacker._calculate_entropy(low_entropy_data)
        high_entropy = unpacker._calculate_entropy(high_entropy_data)

        assert low_entropy < 1.0
        assert high_entropy > 7.0

    def test_is_valid_code_detects_x86_patterns(self) -> None:
        """_is_valid_code identifies valid x86 instruction patterns."""
        unpacker = MultiLayerUnpacker()

        valid_code = b'\x55\x8b\xec\x83\xec\x10\x53\x56\x57\xe8\x00\x00\x00\x00\xc3'
        invalid_code = os.urandom(256)

        assert unpacker._is_valid_code(valid_code) is True
        assert unpacker._is_valid_code(b"") is False
        assert unpacker._is_valid_code(b"\x00" * 10) is False

    def test_rc4_decrypt_performs_stream_cipher(self) -> None:
        """_rc4_decrypt correctly decrypts RC4 encrypted data."""
        unpacker = MultiLayerUnpacker()

        plaintext = b"Test Message for RC4 Decryption"
        key = b"SecretKey"

        encrypted = unpacker._rc4_decrypt(plaintext, key)
        decrypted = unpacker._rc4_decrypt(encrypted, key)

        assert decrypted == plaintext

    def test_detect_themida_version_identifies_signatures(self) -> None:
        """_detect_themida_version identifies Themida version strings."""
        unpacker = MultiLayerUnpacker()

        data_v2 = b"Some code" + b"Themida\x002.3" + b"more code"
        data_v3 = b"Some code" + b"Themida\x003.0" + b"more code"
        data_winlicense = b"Some code" + b"WinLicense\x003" + b"more code"

        version_v2 = unpacker._detect_themida_version(data_v2)
        version_v3 = unpacker._detect_themida_version(data_v3)
        version_wl = unpacker._detect_themida_version(data_winlicense)

        assert "2.3" in version_v2
        assert "3.0" in version_v3
        assert "WinLicense" in version_wl

    def test_bypass_themida_antidebug_patches_checks(self) -> None:
        """_bypass_themida_antidebug patches anti-debug instructions."""
        unpacker = MultiLayerUnpacker()

        data_with_checks = bytearray(b"\x90" * 100)
        data_with_checks[50:57] = b"\xff\x15\x00\x00\x00\x00\x85"
        data_with_checks[57] = 0xc0
        data_with_checks[58] = 0x75

        patched = unpacker._bypass_themida_antidebug(bytes(data_with_checks))

        assert isinstance(patched, bytes)
        assert len(patched) == len(data_with_checks)


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
class TestAutomatedUnpacker:
    """Test main automated unpacker orchestrator."""

    def test_automated_unpacker_initialization(self) -> None:
        """AutomatedUnpacker initializes all components."""
        unpacker = AutomatedUnpacker()

        assert unpacker.iat_reconstructor is not None
        assert unpacker.section_repairer is not None
        assert unpacker.overlay_handler is not None
        assert unpacker.resource_extractor is not None
        assert unpacker.multi_layer_unpacker is not None
        assert unpacker.context is None

    def test_detect_packer_identifies_upx(self, upx_packed_pe: bytes, temp_workspace: Path) -> None:
        """_detect_packer identifies UPX packed binaries."""
        unpacker = AutomatedUnpacker()

        packed_file = temp_workspace / "upx_packed.exe"
        packed_file.write_bytes(upx_packed_pe)

        packer_type = unpacker._detect_packer(str(packed_file))

        assert packer_type == PackerType.UPX

    def test_detect_packer_identifies_themida(self, themida_packed_pe: bytes, temp_workspace: Path) -> None:
        """_detect_packer identifies Themida packed binaries."""
        unpacker = AutomatedUnpacker()

        packed_file = temp_workspace / "themida_packed.exe"
        packed_file.write_bytes(themida_packed_pe)

        packer_type = unpacker._detect_packer(str(packed_file))

        assert packer_type == PackerType.THEMIDA

    def test_detect_packer_identifies_vmprotect(self, vmprotect_packed_pe: bytes, temp_workspace: Path) -> None:
        """_detect_packer identifies VMProtect packed binaries."""
        unpacker = AutomatedUnpacker()

        packed_file = temp_workspace / "vmprotect_packed.exe"
        packed_file.write_bytes(vmprotect_packed_pe)

        packer_type = unpacker._detect_packer(str(packed_file))

        assert packer_type == PackerType.VMPROTECT

    def test_detect_packer_identifies_aspack(self, aspack_packed_pe: bytes, temp_workspace: Path) -> None:
        """_detect_packer identifies ASPack packed binaries."""
        unpacker = AutomatedUnpacker()

        packed_file = temp_workspace / "aspack_packed.exe"
        packed_file.write_bytes(aspack_packed_pe)

        packer_type = unpacker._detect_packer(str(packed_file))

        assert packer_type == PackerType.ASPACK

    def test_check_packer_indicators_detects_high_entropy(self, minimal_pe_binary: bytes) -> None:
        """_check_packer_indicators detects high entropy sections."""
        unpacker = AutomatedUnpacker()

        high_entropy_pe = bytearray(minimal_pe_binary)
        high_entropy_pe[0x400:0x600] = os.urandom(512)

        pe = pefile.PE(data=bytes(high_entropy_pe))
        result = unpacker._check_packer_indicators(pe)

        assert isinstance(result, bool)

    def test_calculate_entropy_returns_correct_values(self) -> None:
        """_calculate_entropy calculates Shannon entropy."""
        unpacker = AutomatedUnpacker()

        zero_entropy = unpacker._calculate_entropy(b"\x00" * 1024)
        low_entropy = unpacker._calculate_entropy(b"AAAA" * 256)
        high_entropy = unpacker._calculate_entropy(os.urandom(1024))

        assert zero_entropy == 0.0
        assert low_entropy < 2.0
        assert high_entropy > 7.0

    def test_find_oep_locates_entry_point(self, minimal_pe_binary: bytes) -> None:
        """_find_oep locates Original Entry Point in unpacked binary."""
        unpacker = AutomatedUnpacker()
        pe = pefile.PE(data=minimal_pe_binary)

        oep = unpacker._find_oep(pe, minimal_pe_binary)

        assert oep is None or isinstance(oep, int)

    def test_unpack_file_processes_packed_binary(self, upx_packed_pe: bytes, temp_workspace: Path) -> None:
        """unpack_file performs complete unpacking workflow."""
        unpacker = AutomatedUnpacker()

        input_file = temp_workspace / "packed.exe"
        output_file = temp_workspace / "unpacked.exe"
        input_file.write_bytes(upx_packed_pe)

        result = unpacker.unpack_file(str(input_file), str(output_file))

        assert isinstance(result, bool)
        if result:
            assert output_file.exists()
            assert unpacker.context is not None
            assert unpacker.context.packer_type != PackerType.UNKNOWN

    def test_unpack_file_handles_multi_layer(self, multi_layer_packed_pe: bytes, temp_workspace: Path) -> None:
        """unpack_file handles multi-layer packed binaries."""
        unpacker = AutomatedUnpacker()

        input_file = temp_workspace / "multi_packed.exe"
        output_file = temp_workspace / "multi_unpacked.exe"
        input_file.write_bytes(multi_layer_packed_pe)

        result = unpacker.unpack_file(str(input_file), str(output_file))

        assert isinstance(result, bool)

    def test_get_unpacking_report_provides_details(self, upx_packed_pe: bytes, temp_workspace: Path) -> None:
        """get_unpacking_report provides detailed unpacking information."""
        unpacker = AutomatedUnpacker()

        input_file = temp_workspace / "packed.exe"
        input_file.write_bytes(upx_packed_pe)

        unpacker.unpack_file(str(input_file))

        report = unpacker.get_unpacking_report()

        assert isinstance(report, dict)
        if report:
            assert "original_file" in report
            assert "packer_type" in report

    def test_perform_unpacking_iterates_layers(self, multi_layer_packed_pe: bytes) -> None:
        """_perform_unpacking processes multiple packing layers."""
        unpacker = AutomatedUnpacker()
        pe = pefile.PE(data=multi_layer_packed_pe)

        unpacker.context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        result = unpacker._perform_unpacking(pe)

        assert isinstance(result, bytes) or result is None

    def test_rebuild_pe_reconstructs_structure(self, minimal_pe_binary: bytes) -> None:
        """_rebuild_pe reconstructs valid PE structure."""
        unpacker = AutomatedUnpacker()

        unpacker.context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        result = unpacker._rebuild_pe(minimal_pe_binary)

        assert result is None or isinstance(result, bytes)

    def test_save_unpacked_writes_file(self, temp_workspace: Path) -> None:
        """_save_unpacked writes unpacked data to file."""
        unpacker = AutomatedUnpacker()

        output_file = temp_workspace / "saved.exe"
        data = b"UNPACKED_PE_DATA"

        unpacker._save_unpacked(data, str(output_file))

        assert output_file.exists()
        assert output_file.read_bytes() == data


class TestEntropyAnalysis:
    """Test entropy calculation for packed section detection."""

    def test_entropy_zero_for_uniform_data(self) -> None:
        """Entropy is zero for uniform data."""
        unpacker = AutomatedUnpacker()

        uniform_data = b"\x00" * 1024
        entropy = unpacker._calculate_entropy(uniform_data)

        assert entropy == 0.0

    def test_entropy_low_for_text(self) -> None:
        """Entropy is low for text data."""
        unpacker = AutomatedUnpacker()

        text_data = b"The quick brown fox jumps over the lazy dog. " * 20
        entropy = unpacker._calculate_entropy(text_data)

        assert 3.0 < entropy < 6.0

    def test_entropy_high_for_encrypted(self) -> None:
        """Entropy is high for encrypted/packed data."""
        unpacker = AutomatedUnpacker()

        encrypted_data = os.urandom(1024)
        entropy = unpacker._calculate_entropy(encrypted_data)

        assert entropy > 7.5

    def test_entropy_calculation_handles_empty(self) -> None:
        """Entropy calculation handles empty data."""
        unpacker = AutomatedUnpacker()

        entropy = unpacker._calculate_entropy(b"")

        assert entropy == 0.0


class TestOEPDetection:
    """Test Original Entry Point detection."""

    def test_find_oep_detects_standard_prologue(self) -> None:
        """OEP detection finds standard function prologue."""
        binary_data = bytearray(0x2000)
        binary_data[0x1000:0x1003] = b'\x55\x8b\xec'

        if PEFILE_AVAILABLE:
            pe_data = bytearray(0x1000)
            pe_data[:2] = b'MZ'
            unpacker = AutomatedUnpacker()

            pe_data[60:64] = struct.pack('<I', 64)
            pe_data[64:68] = b'PE\x00\x00'

            full_data = bytes(pe_data) + bytes(binary_data)

            try:
                pe = pefile.PE(data=full_data)
                oep = unpacker._find_oep(pe, full_data)
                assert oep is None or isinstance(oep, int)
            except Exception:
                pass

    def test_find_oep_detects_gcc_prologue(self, minimal_pe_binary: bytes) -> None:
        """OEP detection finds GCC-style function prologue."""
        binary_data = bytearray(minimal_pe_binary)
        binary_data[0x400:0x403] = b'\x55\x89\xe5'

        if PEFILE_AVAILABLE:
            unpacker = AutomatedUnpacker()

            try:
                pe = pefile.PE(data=bytes(binary_data))
                oep = unpacker._find_oep(pe, bytes(binary_data))
                assert oep is None or isinstance(oep, int)
            except Exception:
                pass

    def test_find_oep_handles_no_match(self, minimal_pe_binary: bytes) -> None:
        """OEP detection returns None when no pattern matches."""
        binary_data = bytearray(minimal_pe_binary)
        for i in range(0x400, 0x800):
            binary_data[i] = 0x90

        if PEFILE_AVAILABLE:
            unpacker = AutomatedUnpacker()

            try:
                pe = pefile.PE(data=bytes(binary_data))
                oep = unpacker._find_oep(pe, bytes(binary_data))
                assert oep is None or isinstance(oep, int)
            except Exception:
                pass


class TestPackerSignatures:
    """Test signature-based packer detection."""

    def test_upx_signature_detection(self) -> None:
        """UPX signature is correctly detected."""
        unpacker = MultiLayerUnpacker()

        binary_with_upx = b"\x90" * 100 + b"UPX!" + b"\x90" * 100

        detected = unpacker.detect_packing_layer(binary_with_upx)

        assert detected == "UPX"

    def test_themida_signature_detection(self) -> None:
        """Themida signature is correctly detected."""
        unpacker = MultiLayerUnpacker()

        binary_with_themida = b"\x90" * 100 + b".themida" + b"\x90" * 100

        detected = unpacker.detect_packing_layer(binary_with_themida)

        assert detected == "Themida"

    def test_vmprotect_signature_detection(self) -> None:
        """VMProtect signature is correctly detected."""
        unpacker = MultiLayerUnpacker()

        binary_with_vmp = b"\x90" * 100 + b"VMProtect" + b"\x90" * 100

        detected = unpacker.detect_packing_layer(binary_with_vmp)

        assert detected == "VMProtect"

    def test_multiple_signatures_first_match_wins(self) -> None:
        """Multiple signatures returns first match."""
        unpacker = MultiLayerUnpacker()

        binary_multi = b"UPX!" + b"\x90" * 50 + b".themida"

        detected = unpacker.detect_packing_layer(binary_multi)

        assert detected in ["UPX", "Themida"]


class TestImportReconstruction:
    """Test import table reconstruction from memory."""

    def test_import_reconstruction_workflow(self) -> None:
        """Complete import reconstruction workflow."""
        reconstructor = IATReconstructor()

        memory_dump = bytearray(0x10000)

        iat_offset = 0x2000
        memory_dump[iat_offset:iat_offset + 4] = struct.pack("<I", 0x76010000)
        memory_dump[iat_offset + 4:iat_offset + 8] = struct.pack("<I", 0x77010000)
        memory_dump[iat_offset + 8:iat_offset + 12] = struct.pack("<I", 0)

        iat_start, iat_size = reconstructor.scan_for_iat(bytes(memory_dump), 0x400000)

        assert iat_start >= 0
        assert iat_size >= 0

    def test_api_signature_matching(self) -> None:
        """API signatures match known function prologues."""
        reconstructor = IATReconstructor()

        assert len(reconstructor.api_signatures) > 0

        for sig, (dll, api) in reconstructor.api_signatures.items():
            assert isinstance(sig, bytes)
            assert isinstance(dll, str)
            assert isinstance(api, str)
            assert dll.endswith(".dll")


class TestSectionRepair:
    """Test section header repair operations."""

    @pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
    def test_section_alignment_repair(self, minimal_pe_binary: bytes) -> None:
        """Section alignment is fixed to match PE alignment."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        section = pe.sections[0]
        section.VirtualAddress = 0x1001

        memory_dump = minimal_pe_binary
        result = repairer.repair_section_headers(pe, memory_dump)

        assert isinstance(result, bool)

    @pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
    def test_section_raw_data_pointer_repair(self, minimal_pe_binary: bytes) -> None:
        """PointerToRawData is fixed when zero."""
        repairer = SectionRepairer()
        pe = pefile.PE(data=minimal_pe_binary)

        section = pe.sections[0]
        section.PointerToRawData = 0
        section.SizeOfRawData = 0x200

        memory_dump = minimal_pe_binary
        result = repairer.repair_section_headers(pe, memory_dump)

        assert isinstance(result, bool)


class TestUnpackingEdgeCases:
    """Test edge cases and error handling."""

    def test_unpacker_handles_corrupted_pe(self, temp_workspace: Path) -> None:
        """Unpacker handles corrupted PE gracefully."""
        if not PEFILE_AVAILABLE:
            pytest.skip("pefile required")

        unpacker = AutomatedUnpacker()

        corrupted_file = temp_workspace / "corrupted.exe"
        corrupted_file.write_bytes(b"CORRUPT_DATA" * 100)

        result = unpacker.unpack_file(str(corrupted_file))

        assert result is False

    def test_unpacker_handles_empty_file(self, temp_workspace: Path) -> None:
        """Unpacker handles empty file gracefully."""
        if not PEFILE_AVAILABLE:
            pytest.skip("pefile required")

        unpacker = AutomatedUnpacker()

        empty_file = temp_workspace / "empty.exe"
        empty_file.write_bytes(b"")

        result = unpacker.unpack_file(str(empty_file))

        assert result is False

    def test_unpacker_handles_nonexistent_file(self) -> None:
        """Unpacker handles nonexistent file gracefully."""
        if not PEFILE_AVAILABLE:
            pytest.skip("pefile required")

        unpacker = AutomatedUnpacker()

        result = unpacker.unpack_file("/nonexistent/file.exe")

        assert result is False


class TestMultiLayerUnpacking:
    """Test multi-layer unpacking operations."""

    def test_max_layers_limit_prevents_infinite_loop(self) -> None:
        """Unpacker respects maximum layer limit."""
        unpacker = MultiLayerUnpacker()

        assert unpacker.max_layers == 10

    def test_layer_detection_across_multiple_signatures(self, multi_layer_packed_pe: bytes) -> None:
        """Multiple layer signatures are detected."""
        unpacker = MultiLayerUnpacker()

        first_layer = unpacker.detect_packing_layer(multi_layer_packed_pe)

        assert first_layer in ["UPX", "Themida"]

    def test_unpacking_context_tracks_layers(self) -> None:
        """UnpackingContext correctly tracks layer count."""
        context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )

        assert context.layers_unpacked == 0

        context.layers_unpacked += 1
        context.memory_dumps.append(b"layer1")

        assert context.layers_unpacked == 1
        assert len(context.memory_dumps) == 1

        context.layers_unpacked += 1
        context.memory_dumps.append(b"layer2")

        assert context.layers_unpacked == 2
        assert len(context.memory_dumps) == 2


class TestReportGeneration:
    """Test unpacking report generation."""

    def test_report_without_context_returns_empty(self) -> None:
        """get_unpacking_report returns empty dict without context."""
        unpacker = AutomatedUnpacker()

        report = unpacker.get_unpacking_report()

        assert report == {}

    def test_report_includes_all_fields(self) -> None:
        """Unpacking report includes all expected fields."""
        unpacker = AutomatedUnpacker()

        unpacker.context = UnpackingContext(
            original_file="test.exe",
            working_file="unpacked.exe"
        )
        unpacker.context.packer_type = PackerType.UPX
        unpacker.context.layers_unpacked = 2
        unpacker.context.oep_address = 0x1000
        unpacker.context.reconstructed_imports = {
            "kernel32.dll": ["GetProcAddress", "LoadLibraryA"]
        }

        report = unpacker.get_unpacking_report()

        assert "original_file" in report
        assert "output_file" in report
        assert "packer_type" in report
        assert "layers_unpacked" in report
        assert "oep_found" in report
        assert "iat_reconstructed" in report
        assert report["original_file"] == "test.exe"
        assert report["packer_type"] == "UPX"
        assert report["layers_unpacked"] == 2
