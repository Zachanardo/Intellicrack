"""
Unit tests for Bypass Engine with REAL mitigation bypass techniques.
Tests REAL ASLR, DEP, and CFI bypass generation.
NO MOCKS - ALL TESTS GENERATE REAL BYPASS CODE FOR ANALYSIS.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any
import pytest
import struct
from pathlib import Path

if TYPE_CHECKING:
    from intellicrack.core.exploitation.bypass_engine import BypassEngine

try:
    from intellicrack.core.exploitation.bypass_engine import BypassEngine
    from intellicrack.core.exploitation.aslr_bypass import ASLRBypass
    from intellicrack.core.exploitation.dep_bypass import DEPBypass
    from intellicrack.core.exploitation.cet_bypass import CETBypass
    MODULE_AVAILABLE = True
except ImportError:
    BypassEngine = None  # type: ignore[assignment,misc]
    ASLRBypass = None
    DEPBypass = None
    CETBypass = None
    MODULE_AVAILABLE = False

try:
    from tests.base_test import BaseIntellicrackTest
except ImportError:
    BaseIntellicrackTest = object  # type: ignore[assignment,misc]

pytestmark = pytest.mark.skipif(not MODULE_AVAILABLE, reason="Module not available")


class TestBypassEngine(BaseIntellicrackTest):
    """Test bypass engine with REAL mitigation bypass techniques."""

    engine: BypassEngine
    test_binary: str

    @pytest.fixture(autouse=True)
    def setup(self, real_pe_binary: str) -> None:
        """Set up test with bypass engine and real binary."""
        self.engine = BypassEngine()
        self.test_binary = real_pe_binary

    def test_aslr_bypass_generation_real(self) -> None:
        """Test REAL ASLR bypass technique generation."""
        aslr_analysis = self.engine.analyze_aslr_mitigations(self.test_binary)  # type: ignore[attr-defined]

        bypass_config: dict[str, str | int] = {
            'technique': 'info_leak',
            'target_binary': self.test_binary,
            'leak_method': 'partial_overwrite',
            'architecture': 'x64'
        }

        bypass_result = self.engine.generate_aslr_bypass(bypass_config)  # type: ignore[attr-defined]

        self.assert_real_output(bypass_result)
        assert 'bypass_code' in bypass_result
        assert 'technique_details' in bypass_result
        assert 'success_probability' in bypass_result

        bypass_code = bypass_result['bypass_code']
        assert isinstance(bypass_code, (bytes, str))
        assert len(bypass_code) > 0

        technique_details = bypass_result['technique_details']
        assert isinstance(technique_details, dict)
        assert 'method' in technique_details
        assert 'requirements' in technique_details
        assert 'reliability' in technique_details

        prob_val = bypass_result['success_probability']
        assert isinstance(prob_val, (int, float))
        assert 0 <= prob_val <= 100

    def test_dep_bypass_rop_chain_real(self) -> None:
        """Test REAL DEP bypass using ROP chain generation."""
        rop_config: dict[str, str] = {
            'technique': 'rop_chain',
            'target_binary': self.test_binary,
            'objective': 'make_memory_executable',
            'payload_location': 'stack'
        }

        rop_result = self.engine.generate_dep_bypass(rop_config)  # type: ignore[attr-defined]

        self.assert_real_output(rop_result)
        assert 'rop_chain' in rop_result
        assert 'gadgets_used' in rop_result
        assert 'chain_length' in rop_result

        rop_chain = rop_result['rop_chain']
        assert isinstance(rop_chain, (list, bytes))

        if isinstance(rop_chain, list):
            assert len(rop_chain) > 0
            for gadget in rop_chain:
                assert isinstance(gadget, dict)
                assert 'address' in gadget
                assert 'instruction' in gadget

        gadgets_used = rop_result['gadgets_used']
        assert isinstance(gadgets_used, list)
        assert len(gadgets_used) > 0

        for gadget in gadgets_used:
            assert isinstance(gadget, dict)
            assert 'address' in gadget
            assert 'bytes' in gadget
            assert 'disasm' in gadget
            addr_val = gadget['address']
            assert isinstance(addr_val, int)
            assert addr_val > 0

    def test_cfi_bypass_generation_real(self) -> None:
        """Test REAL Control Flow Integrity bypass generation."""
        cfi_config: dict[str, str] = {
            'technique': 'indirect_call_hijack',
            'target_binary': self.test_binary,
            'cfi_type': 'intel_cet',
            'bypass_method': 'shadow_stack_corruption'
        }

        cfi_result = self.engine.generate_cfi_bypass(cfi_config)  # type: ignore[attr-defined]

        self.assert_real_output(cfi_result)
        assert 'bypass_technique' in cfi_result
        assert 'implementation' in cfi_result
        assert 'requirements' in cfi_result

        implementation = cfi_result['implementation']
        assert isinstance(implementation, dict)
        assert 'payload' in implementation
        assert 'setup_code' in implementation
        assert 'trigger_conditions' in implementation

    def test_stack_canary_bypass_real(self) -> None:
        """Test REAL stack canary bypass techniques."""
        canary_config: dict[str, str] = {
            'technique': 'canary_bruteforce',
            'target_binary': self.test_binary,
            'canary_type': 'gs_cookie',
            'architecture': 'x64'
        }

        canary_result = self.engine.generate_canary_bypass(canary_config)  # type: ignore[attr-defined]

        self.assert_real_output(canary_result)
        assert 'bypass_method' in canary_result
        assert 'exploit_code' in canary_result
        assert 'time_complexity' in canary_result

        exploit_code = canary_result['exploit_code']
        assert isinstance(exploit_code, (bytes, str))
        assert len(exploit_code) > 0

        time_complexity = canary_result['time_complexity']
        assert isinstance(time_complexity, (int, float))
        assert time_complexity > 0

    def test_heap_spray_technique_real(self) -> None:
        """Test REAL heap spray technique generation."""
        spray_config: dict[str, str | int] = {
            'technique': 'heap_spray',
            'target_heap': 'process_heap',
            'spray_size': 0x10000,
            'nop_sled_size': 0x1000,
            'payload_offset': 0x8000
        }

        spray_result = self.engine.generate_heap_spray(spray_config)  # type: ignore[attr-defined]

        self.assert_real_output(spray_result)
        assert 'spray_data' in spray_result
        assert 'allocation_strategy' in spray_result
        assert 'success_rate' in spray_result

        spray_data = spray_result['spray_data']
        assert isinstance(spray_data, (bytes, bytearray))
        spray_size = spray_config['spray_size']
        assert isinstance(spray_size, int)
        assert len(spray_data) == spray_size

        nop_sled_size = spray_config['nop_sled_size']
        assert isinstance(nop_sled_size, int)
        nop_section = spray_data[:nop_sled_size]

        nop_count = nop_section.count(0x90)
        assert nop_count > len(nop_section) * 0.8

    def test_return_oriented_programming_real(self) -> None:
        """Test REAL Return-Oriented Programming chain construction."""
        gadget_search = self.engine.find_rop_gadgets(self.test_binary)  # type: ignore[attr-defined]

        self.assert_real_output(gadget_search)
        assert 'gadgets' in gadget_search
        assert 'total_found' in gadget_search

        gadgets = gadget_search['gadgets']
        assert isinstance(gadgets, list)
        assert len(gadgets) > 0

        rop_objective: dict[str, Any] = {
            'goal': 'call_function',
            'function': 'VirtualProtect',
            'parameters': [
                {'type': 'address', 'value': 'stack_location'},
                {'type': 'size', 'value': 0x1000},
                {'type': 'protection', 'value': 0x40},
                {'type': 'old_protect', 'value': 'stack_temp'}
            ]
        }

        chain_result = self.engine.build_rop_chain(gadgets, rop_objective)  # type: ignore[attr-defined]

        self.assert_real_output(chain_result)
        assert 'chain' in chain_result
        assert 'gadgets_used' in chain_result
        assert 'chain_reliability' in chain_result

        chain = chain_result['chain']
        assert isinstance(chain, list)
        assert len(chain) > 0

        for link in chain:
            assert isinstance(link, dict)
            assert 'address' in link
            assert 'purpose' in link
            addr_val = link['address']
            assert isinstance(addr_val, int)
            assert addr_val > 0

    def test_jop_chain_generation_real(self) -> None:
        """Test REAL Jump-Oriented Programming chain generation."""
        jop_search = self.engine.find_jop_gadgets(self.test_binary)  # type: ignore[attr-defined]

        total_found = jop_search['total_found']
        assert isinstance(total_found, int)
        if total_found == 0:
            pytest.skip("No JOP gadgets found in test binary")

        self.assert_real_output(jop_search)
        assert 'dispatchers' in jop_search
        assert 'functional_gadgets' in jop_search

        dispatchers = jop_search['dispatchers']
        assert isinstance(dispatchers, list)
        assert len(dispatchers) > 0
        first_dispatcher = dispatchers[0]
        assert isinstance(first_dispatcher, dict)
        assert 'address' in first_dispatcher

        jop_objective: dict[str, Any] = {
            'goal': 'arbitrary_code_execution',
            'payload_location': 'heap',
            'dispatcher_address': first_dispatcher['address']
        }

        jop_result = self.engine.build_jop_chain(jop_search, jop_objective)  # type: ignore[attr-defined]

        self.assert_real_output(jop_result)
        assert 'jop_program' in jop_result
        assert 'dispatcher_used' in jop_result

    def test_format_string_exploit_real(self) -> None:
        """Test REAL format string exploit generation."""
        format_config: dict[str, str | int] = {
            'vulnerability_type': 'printf',
            'target_function': 'printf',
            'objective': 'arbitrary_write',
            'target_address': 0x08048000,
            'write_value': 0x41414141
        }

        format_result = self.engine.generate_format_string_exploit(format_config)  # type: ignore[attr-defined]

        self.assert_real_output(format_result)
        assert 'format_string' in format_result
        assert 'payload_breakdown' in format_result
        assert 'write_primitive' in format_result

        format_string = format_result['format_string']
        assert isinstance(format_string, str)
        assert '%' in format_string
        assert 'n' in format_string

    def test_integer_overflow_exploit_real(self) -> None:
        """Test REAL integer overflow exploit generation."""
        overflow_config: dict[str, str | int] = {
            'overflow_type': 'signed_integer',
            'target_variable': 'buffer_size',
            'overflow_value': 0x80000000,
            'exploitation_method': 'heap_corruption'
        }

        overflow_result = self.engine.generate_integer_overflow_exploit(overflow_config)  # type: ignore[attr-defined]

        self.assert_real_output(overflow_result)
        assert 'payload_values' in overflow_result
        assert 'overflow_calculation' in overflow_result
        assert 'exploitation_vector' in overflow_result

        calculation = overflow_result['overflow_calculation']
        assert isinstance(calculation, dict)
        assert 'original_value' in calculation
        assert 'overflow_value' in calculation
        assert 'result_value' in calculation

    def test_use_after_free_exploit_real(self) -> None:
        """Test REAL use-after-free exploit generation."""
        uaf_config: dict[str, str | int] = {
            'freed_object_size': 0x100,
            'object_type': 'vtable_object',
            'reallocation_strategy': 'heap_spray',
            'control_method': 'vtable_hijack'
        }

        uaf_result = self.engine.generate_uaf_exploit(uaf_config)  # type: ignore[attr-defined]

        self.assert_real_output(uaf_result)
        assert 'exploit_sequence' in uaf_result
        assert 'heap_manipulation' in uaf_result
        assert 'control_hijack' in uaf_result

        sequence = uaf_result['exploit_sequence']
        assert isinstance(sequence, dict)
        assert 'allocation_phase' in sequence
        assert 'free_phase' in sequence
        assert 'reallocation_phase' in sequence
        assert 'exploitation_phase' in sequence

    def test_bypass_technique_chaining_real(self) -> None:
        """Test REAL chaining of multiple bypass techniques."""
        chain_config: dict[str, Any] = {
            'techniques': [
                {'type': 'aslr_bypass', 'method': 'info_leak'},
                {'type': 'dep_bypass', 'method': 'rop_chain'},
                {'type': 'canary_bypass', 'method': 'overwrite'}
            ],
            'target_binary': self.test_binary,
            'objective': 'full_control'
        }

        chain_result = self.engine.chain_bypass_techniques(chain_config)  # type: ignore[attr-defined]

        self.assert_real_output(chain_result)
        assert 'exploit_chain' in chain_result
        assert 'chain_reliability' in chain_result
        assert 'execution_order' in chain_result

        exploit_chain = chain_result['exploit_chain']
        assert isinstance(exploit_chain, list)
        techniques = chain_config['techniques']
        assert isinstance(techniques, list)
        assert len(exploit_chain) == len(techniques)

        for i, step in enumerate(exploit_chain):
            assert isinstance(step, dict)
            assert 'step_number' in step
            assert 'technique' in step
            assert 'payload' in step
            step_num = step['step_number']
            assert isinstance(step_num, int)
            assert step_num == i + 1

    def test_bypass_reliability_analysis_real(self) -> None:
        """Test REAL bypass technique reliability analysis."""
        reliability_config: dict[str, Any] = {
            'techniques': ['aslr_bypass', 'dep_bypass', 'cfi_bypass'],
            'target_environment': {
                'os': 'windows_10',
                'architecture': 'x64',
                'patches': ['KB5000001', 'KB5000002'],
                'mitigations': ['ASLR', 'DEP', 'CFG', 'CET']
            }
        }

        reliability_result = self.engine.analyze_bypass_reliability(reliability_config)  # type: ignore[attr-defined]

        self.assert_real_output(reliability_result)
        assert 'technique_scores' in reliability_result
        assert 'overall_success_rate' in reliability_result
        assert 'risk_factors' in reliability_result

        technique_scores = reliability_result['technique_scores']
        assert isinstance(technique_scores, dict)
        for technique, score in technique_scores.items():
            assert isinstance(technique, str)
            assert isinstance(score, (int, float))
            assert 0 <= score <= 100

        overall_rate = reliability_result['overall_success_rate']
        assert isinstance(overall_rate, (int, float))
        assert 0 <= overall_rate <= 100

    def test_advanced_mitigation_bypass_real(self) -> None:
        """Test REAL advanced mitigation bypass techniques."""
        advanced_config: dict[str, Any] = {
            'mitigations': ['CET', 'IBT', 'SMEP', 'SMAP'],
            'bypass_methods': [
                'ret2dir',
                'physmap_spray',
                'kernel_rop',
                'exception_handler_corruption'
            ],
            'target_architecture': 'x64'
        }

        advanced_result = self.engine.generate_advanced_bypasses(advanced_config)  # type: ignore[attr-defined]

        self.assert_real_output(advanced_result)
        assert 'bypass_implementations' in advanced_result
        assert 'compatibility_matrix' in advanced_result
        assert 'success_rates' in advanced_result

        implementations = advanced_result['bypass_implementations']
        assert isinstance(implementations, list)
        assert len(implementations) > 0

        for impl in implementations:
            assert isinstance(impl, dict)
            assert 'mitigation_target' in impl
            assert 'bypass_code' in impl
            assert 'requirements' in impl
