"""Production tests for CryptoKeyExtractor - tests genuine key extraction capabilities.

These tests validate the actual crypto key extractor implementation:
- Cryptographic constant generation (AES S-box, SHA constants, DES permutations)
- Pattern building for key detection
- Entropy calculation for key material identification
- ECC curve parameter definitions
- API signature patterns for hooking
- Key format header detection (PEM, DER, PKCS)
- Real Windows crypto DLL analysis (bcrypt.dll, crypt32.dll contain real crypto constants)

Tests verify the extractor can find REAL cryptographic constants in Windows system
DLLs that implement actual cryptographic algorithms.
"""

import os
import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.crypto_key_extractor import (
    CryptoKeyExtractor,
    ExtractedKey,
    KeyType,
)


WINDOWS_CRYPTO_DLLS: dict[str, Path] = {
    "bcrypt": Path(r"C:\Windows\System32\bcrypt.dll"),
    "crypt32": Path(r"C:\Windows\System32\crypt32.dll"),
    "ncrypt": Path(r"C:\Windows\System32\ncrypt.dll"),
    "advapi32": Path(r"C:\Windows\System32\advapi32.dll"),
}


@pytest.fixture
def extractor() -> CryptoKeyExtractor:
    """Create fresh crypto key extractor instance."""
    return CryptoKeyExtractor()


@pytest.fixture
def bcrypt_dll() -> bytes:
    """Load real Windows bcrypt.dll containing crypto implementations."""
    dll_path = WINDOWS_CRYPTO_DLLS["bcrypt"]
    if not dll_path.exists():
        pytest.skip("bcrypt.dll not found")
    return dll_path.read_bytes()


@pytest.fixture
def crypt32_dll() -> bytes:
    """Load real Windows crypt32.dll containing certificate functions."""
    dll_path = WINDOWS_CRYPTO_DLLS["crypt32"]
    if not dll_path.exists():
        pytest.skip("crypt32.dll not found")
    return dll_path.read_bytes()


class TestKeyTypeEnumeration:
    """Test KeyType enum has all supported cryptographic key types."""

    def test_key_type_has_rsa_public(self) -> None:
        """RSA public key type defined."""
        assert KeyType.RSA_PUBLIC.value == "rsa_public"

    def test_key_type_has_rsa_private(self) -> None:
        """RSA private key type defined."""
        assert KeyType.RSA_PRIVATE.value == "rsa_private"

    def test_key_type_has_ecc_public(self) -> None:
        """ECC public key type defined."""
        assert KeyType.ECC_PUBLIC.value == "ecc_public"

    def test_key_type_has_ecc_private(self) -> None:
        """ECC private key type defined."""
        assert KeyType.ECC_PRIVATE.value == "ecc_private"

    def test_key_type_has_dsa_public(self) -> None:
        """DSA public key type defined."""
        assert KeyType.DSA_PUBLIC.value == "dsa_public"

    def test_key_type_has_dsa_private(self) -> None:
        """DSA private key type defined."""
        assert KeyType.DSA_PRIVATE.value == "dsa_private"

    def test_key_type_has_aes(self) -> None:
        """AES symmetric key type defined."""
        assert KeyType.AES.value == "aes"

    def test_key_type_has_des3(self) -> None:
        """3DES symmetric key type defined."""
        assert KeyType.DES3.value == "3des"

    def test_key_type_has_custom(self) -> None:
        """Custom key type for unknown algorithms."""
        assert KeyType.CUSTOM.value == "custom"


class TestExtractedKeyDataclass:
    """Test ExtractedKey dataclass structure."""

    def test_extracted_key_has_required_fields(self) -> None:
        """ExtractedKey dataclass has all required fields."""
        key = ExtractedKey(
            address=0x400000,
            key_type=KeyType.RSA_PRIVATE,
            key_size=2048,
            raw_bytes=b"\x00" * 256,
            parameters={"e": 65537},
            confidence=0.95,
            context="DER format",
        )
        assert key.address == 0x400000
        assert key.key_type == KeyType.RSA_PRIVATE
        assert key.key_size == 2048
        assert len(key.raw_bytes) == 256
        assert key.parameters["e"] == 65537
        assert key.confidence == 0.95
        assert key.context == "DER format"

    def test_extracted_key_optional_pem_format(self) -> None:
        """ExtractedKey has optional PEM format field."""
        key = ExtractedKey(
            address=0x500000,
            key_type=KeyType.ECC_PUBLIC,
            key_size=256,
            raw_bytes=b"\x00" * 64,
            parameters={},
            confidence=0.8,
            context="PKCS8",
            pem_format="-----BEGIN PUBLIC KEY-----\n...",
        )
        assert key.pem_format is not None
        assert "BEGIN PUBLIC KEY" in key.pem_format

    def test_extracted_key_optional_der_format(self) -> None:
        """ExtractedKey has optional DER format field."""
        der_data = b"\x30\x82\x01\x22"
        key = ExtractedKey(
            address=0x600000,
            key_type=KeyType.RSA_PUBLIC,
            key_size=2048,
            raw_bytes=der_data,
            parameters={},
            confidence=0.9,
            context="SubjectPublicKeyInfo",
            der_format=der_data,
        )
        assert key.der_format is not None
        assert key.der_format.startswith(b"\x30")


class TestCryptoKeyExtractorInitialization:
    """Test CryptoKeyExtractor initialization."""

    def test_extractor_initializes_empty_key_list(self, extractor: CryptoKeyExtractor) -> None:
        """Extractor initializes with empty extracted keys list."""
        assert isinstance(extractor.extracted_keys, list)
        assert len(extractor.extracted_keys) == 0

    def test_extractor_has_rsa_patterns(self, extractor: CryptoKeyExtractor) -> None:
        """Extractor builds RSA detection patterns."""
        assert hasattr(extractor, "rsa_patterns")
        assert isinstance(extractor.rsa_patterns, dict)

    def test_extractor_has_ecc_curves(self, extractor: CryptoKeyExtractor) -> None:
        """Extractor builds ECC curve parameters."""
        assert hasattr(extractor, "ecc_curves")
        assert isinstance(extractor.ecc_curves, dict)

    def test_extractor_has_key_formats(self, extractor: CryptoKeyExtractor) -> None:
        """Extractor builds key format patterns."""
        assert hasattr(extractor, "key_formats")
        assert isinstance(extractor.key_formats, dict)


class TestAESSboxGeneration:
    """Test AES S-box generation matches Rijndael specification."""

    def test_aes_sbox_is_256_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """AES S-box is exactly 256 bytes."""
        sbox = extractor._get_aes_sbox()
        assert len(sbox) == 256

    def test_aes_sbox_first_byte_is_0x63(self, extractor: CryptoKeyExtractor) -> None:
        """AES S-box first byte is 0x63 (Rijndael standard)."""
        sbox = extractor._get_aes_sbox()
        assert sbox[0] == 0x63

    def test_aes_sbox_last_byte_is_0x16(self, extractor: CryptoKeyExtractor) -> None:
        """AES S-box last byte is 0x16 (Rijndael standard)."""
        sbox = extractor._get_aes_sbox()
        assert sbox[255] == 0x16

    def test_aes_sbox_known_value_0x53(self, extractor: CryptoKeyExtractor) -> None:
        """AES S-box[0x53] is 0xED (Rijndael standard)."""
        sbox = extractor._get_aes_sbox()
        assert sbox[0x53] == 0xED

    def test_aes_sbox_matches_expected_hex(self, extractor: CryptoKeyExtractor) -> None:
        """AES S-box matches expected hex string."""
        sbox = extractor._get_aes_sbox()
        expected_first_32 = bytes.fromhex(
            "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0"
        )
        assert sbox[:32] == expected_first_32


class TestAESRoundConstantsGeneration:
    """Test AES round constants (Rcon) generation."""

    def test_aes_rcon_has_10_values(self, extractor: CryptoKeyExtractor) -> None:
        """AES Rcon has 10 round constants."""
        patterns = extractor._generate_aes_schedule_patterns()
        rcon = patterns["rcon"]
        assert len(rcon) == 10

    def test_aes_rcon_first_value_is_0x01(self, extractor: CryptoKeyExtractor) -> None:
        """AES Rcon first value is 0x01."""
        patterns = extractor._generate_aes_schedule_patterns()
        rcon = patterns["rcon"]
        assert rcon[0] == 0x01

    def test_aes_rcon_correct_sequence(self, extractor: CryptoKeyExtractor) -> None:
        """AES Rcon follows correct GF(2^8) sequence."""
        patterns = extractor._generate_aes_schedule_patterns()
        rcon = patterns["rcon"]
        expected = bytes([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36])
        assert rcon == expected


class TestDESPermutationTables:
    """Test DES permutation table generation."""

    def test_des_pc1_has_56_elements(self, extractor: CryptoKeyExtractor) -> None:
        """DES PC1 permutation has 56 elements."""
        patterns = extractor._generate_des_schedule_patterns()
        pc1 = patterns["pc1"]
        assert len(pc1) == 56

    def test_des_pc2_has_48_elements(self, extractor: CryptoKeyExtractor) -> None:
        """DES PC2 permutation has 48 elements."""
        patterns = extractor._generate_des_schedule_patterns()
        pc2 = patterns["pc2"]
        assert len(pc2) == 48

    def test_des_rotation_schedule_has_16_rounds(self, extractor: CryptoKeyExtractor) -> None:
        """DES rotation schedule has 16 rounds."""
        patterns = extractor._generate_des_schedule_patterns()
        schedule = patterns["rotation_schedule"]
        assert len(schedule) == 16

    def test_des_rotation_schedule_correct_values(self, extractor: CryptoKeyExtractor) -> None:
        """DES rotation schedule has correct shift values."""
        patterns = extractor._generate_des_schedule_patterns()
        schedule = patterns["rotation_schedule"]
        expected = bytes([1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1])
        assert schedule == expected


class TestChaCha20Constants:
    """Test ChaCha20 constant generation."""

    def test_chacha_constants_is_16_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """ChaCha20 constant is 16 bytes."""
        patterns = extractor._generate_chacha_patterns()
        constants = patterns["constants"]
        assert len(constants) == 16

    def test_chacha_constants_expand_32_byte_k(self, extractor: CryptoKeyExtractor) -> None:
        """ChaCha20 constant is 'expand 32-byte k'."""
        patterns = extractor._generate_chacha_patterns()
        constants = patterns["constants"]
        assert constants == b"expand 32-byte k"

    def test_chacha_sigma_matches_hex(self, extractor: CryptoKeyExtractor) -> None:
        """ChaCha20 sigma matches hex representation."""
        patterns = extractor._generate_chacha_patterns()
        sigma = patterns["sigma"]
        expected = bytes.fromhex("657870616e642033322d62797465206b")
        assert sigma == expected

    def test_chacha_state_pattern_is_64_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """ChaCha20 state pattern is 64 bytes (16 x 32-bit words)."""
        patterns = extractor._generate_chacha_patterns()
        state = patterns["state_pattern"]
        assert len(state) == 64


class TestECCCurveParameters:
    """Test ECC curve parameter definitions."""

    def test_ecc_curves_has_p256(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include P-256 (NIST)."""
        curves = extractor.ecc_curves
        assert "P-256" in curves

    def test_ecc_curves_has_p384(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include P-384 (NIST)."""
        curves = extractor.ecc_curves
        assert "P-384" in curves

    def test_ecc_curves_has_p521(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include P-521 (NIST)."""
        curves = extractor.ecc_curves
        assert "P-521" in curves

    def test_ecc_curves_has_secp256k1(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include secp256k1 (Bitcoin)."""
        curves = extractor.ecc_curves
        assert "secp256k1" in curves

    def test_ecc_curves_has_curve25519(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include Curve25519 (modern crypto)."""
        curves = extractor.ecc_curves
        assert "curve25519" in curves

    def test_ecc_curves_has_edwards25519(self, extractor: CryptoKeyExtractor) -> None:
        """ECC curves include Edwards25519 (Ed25519)."""
        curves = extractor.ecc_curves
        assert "edwards25519" in curves

    def test_p256_curve_has_required_params(self, extractor: CryptoKeyExtractor) -> None:
        """P-256 curve has all required parameters."""
        curves = extractor.ecc_curves
        p256 = curves["P-256"]
        assert "p" in p256
        assert "a" in p256
        assert "b" in p256
        assert "gx" in p256
        assert "gy" in p256
        assert "n" in p256

    def test_secp256k1_curve_has_required_params(self, extractor: CryptoKeyExtractor) -> None:
        """secp256k1 curve has all required parameters."""
        curves = extractor.ecc_curves
        secp256k1 = curves["secp256k1"]
        assert "p" in secp256k1
        assert "a" in secp256k1
        assert "b" in secp256k1
        assert "gx" in secp256k1
        assert "gy" in secp256k1
        assert "n" in secp256k1


class TestRSAPatternBuilding:
    """Test RSA key schedule pattern building."""

    def test_rsa_patterns_has_key_schedules(self, extractor: CryptoKeyExtractor) -> None:
        """RSA patterns include key schedule patterns."""
        patterns = extractor.rsa_patterns
        assert "key_schedules" in patterns

    def test_rsa_patterns_has_crypto_apis(self, extractor: CryptoKeyExtractor) -> None:
        """RSA patterns include crypto API signatures."""
        patterns = extractor.rsa_patterns
        assert "crypto_apis" in patterns

    def test_rsa_patterns_has_memory_regions(self, extractor: CryptoKeyExtractor) -> None:
        """RSA patterns include memory region patterns."""
        patterns = extractor.rsa_patterns
        assert "memory_regions" in patterns

    def test_rsa_patterns_has_side_channel_targets(self, extractor: CryptoKeyExtractor) -> None:
        """RSA patterns include side-channel targets."""
        patterns = extractor.rsa_patterns
        assert "side_channel_targets" in patterns

    def test_key_schedules_has_aes_round_keys(self, extractor: CryptoKeyExtractor) -> None:
        """Key schedules include AES round key patterns."""
        patterns = extractor.rsa_patterns
        schedules = patterns["key_schedules"]
        assert "aes_round_keys" in schedules

    def test_key_schedules_has_rsa_crt_components(self, extractor: CryptoKeyExtractor) -> None:
        """Key schedules include RSA CRT component patterns."""
        patterns = extractor.rsa_patterns
        schedules = patterns["key_schedules"]
        assert "rsa_crt_components" in schedules

    def test_key_schedules_has_des_subkeys(self, extractor: CryptoKeyExtractor) -> None:
        """Key schedules include DES subkey patterns."""
        patterns = extractor.rsa_patterns
        schedules = patterns["key_schedules"]
        assert "des_subkeys" in schedules

    def test_key_schedules_has_chacha20_state(self, extractor: CryptoKeyExtractor) -> None:
        """Key schedules include ChaCha20 state patterns."""
        patterns = extractor.rsa_patterns
        schedules = patterns["key_schedules"]
        assert "chacha20_state" in schedules


class TestMontgomeryConstants:
    """Test Montgomery multiplication constant generation."""

    def test_montgomery_has_1024_bit_constant(self, extractor: CryptoKeyExtractor) -> None:
        """Montgomery constants include 1024-bit pattern."""
        patterns = extractor._get_montgomery_patterns()
        assert "mont_1024" in patterns
        assert len(patterns["mont_1024"]) == 128

    def test_montgomery_has_2048_bit_constant(self, extractor: CryptoKeyExtractor) -> None:
        """Montgomery constants include 2048-bit pattern."""
        patterns = extractor._get_montgomery_patterns()
        assert "mont_2048" in patterns
        assert len(patterns["mont_2048"]) == 256

    def test_montgomery_has_3072_bit_constant(self, extractor: CryptoKeyExtractor) -> None:
        """Montgomery constants include 3072-bit pattern."""
        patterns = extractor._get_montgomery_patterns()
        assert "mont_3072" in patterns
        assert len(patterns["mont_3072"]) == 384

    def test_montgomery_has_4096_bit_constant(self, extractor: CryptoKeyExtractor) -> None:
        """Montgomery constants include 4096-bit pattern."""
        patterns = extractor._get_montgomery_patterns()
        assert "mont_4096" in patterns
        assert len(patterns["mont_4096"]) == 512


class TestModExpWindowPatterns:
    """Test modular exponentiation window patterns."""

    def test_modexp_has_window_4(self, extractor: CryptoKeyExtractor) -> None:
        """ModExp patterns include 4-bit window."""
        patterns = extractor._get_modexp_window_patterns()
        assert "window_4" in patterns
        assert len(patterns["window_4"]) == 16

    def test_modexp_has_window_5(self, extractor: CryptoKeyExtractor) -> None:
        """ModExp patterns include 5-bit window."""
        patterns = extractor._get_modexp_window_patterns()
        assert "window_5" in patterns
        assert len(patterns["window_5"]) == 32

    def test_modexp_has_window_6(self, extractor: CryptoKeyExtractor) -> None:
        """ModExp patterns include 6-bit window."""
        patterns = extractor._get_modexp_window_patterns()
        assert "window_6" in patterns
        assert len(patterns["window_6"]) == 64


class TestCryptoAPISignatures:
    """Test crypto API signature generation for hooking."""

    def test_crypto_apis_has_windows(self, extractor: CryptoKeyExtractor) -> None:
        """Crypto APIs include Windows APIs."""
        apis = extractor._get_crypto_api_signatures()
        assert "windows" in apis

    def test_crypto_apis_has_linux(self, extractor: CryptoKeyExtractor) -> None:
        """Crypto APIs include Linux APIs."""
        apis = extractor._get_crypto_api_signatures()
        assert "linux" in apis

    def test_windows_apis_has_bcrypt(self, extractor: CryptoKeyExtractor) -> None:
        """Windows APIs include BCrypt functions."""
        apis = extractor._get_crypto_api_signatures()
        assert "bcrypt" in apis["windows"]

    def test_windows_apis_has_crypt32(self, extractor: CryptoKeyExtractor) -> None:
        """Windows APIs include Crypt32 functions."""
        apis = extractor._get_crypto_api_signatures()
        assert "crypt32" in apis["windows"]

    def test_bcrypt_apis_include_key_generation(self, extractor: CryptoKeyExtractor) -> None:
        """BCrypt APIs include key generation functions."""
        apis = extractor._get_crypto_api_signatures()
        bcrypt = apis["windows"]["bcrypt"]
        assert "BCryptGenerateSymmetricKey" in bcrypt
        assert "BCryptGenerateKeyPair" in bcrypt

    def test_bcrypt_apis_include_encryption(self, extractor: CryptoKeyExtractor) -> None:
        """BCrypt APIs include encryption/decryption functions."""
        apis = extractor._get_crypto_api_signatures()
        bcrypt = apis["windows"]["bcrypt"]
        assert "BCryptEncrypt" in bcrypt
        assert "BCryptDecrypt" in bcrypt

    def test_linux_apis_has_openssl(self, extractor: CryptoKeyExtractor) -> None:
        """Linux APIs include OpenSSL functions."""
        apis = extractor._get_crypto_api_signatures()
        assert "openssl" in apis["linux"]

    def test_openssl_apis_include_evp(self, extractor: CryptoKeyExtractor) -> None:
        """OpenSSL APIs include EVP cipher functions."""
        apis = extractor._get_crypto_api_signatures()
        openssl = apis["linux"]["openssl"]
        assert "EVP_CipherInit_ex" in openssl
        assert "EVP_PKEY_keygen" in openssl

    def test_openssl_apis_include_aes(self, extractor: CryptoKeyExtractor) -> None:
        """OpenSSL APIs include AES set key function."""
        apis = extractor._get_crypto_api_signatures()
        openssl = apis["linux"]["openssl"]
        assert "AES_set_encrypt_key" in openssl


class TestSideChannelTargets:
    """Test side-channel analysis target generation."""

    def test_side_channel_has_cache_timing(self, extractor: CryptoKeyExtractor) -> None:
        """Side-channel targets include cache timing."""
        targets = extractor._get_side_channel_targets()
        assert "cache_timing" in targets

    def test_side_channel_has_power_analysis(self, extractor: CryptoKeyExtractor) -> None:
        """Side-channel targets include power analysis."""
        targets = extractor._get_side_channel_targets()
        assert "power_analysis" in targets

    def test_side_channel_has_electromagnetic(self, extractor: CryptoKeyExtractor) -> None:
        """Side-channel targets include electromagnetic analysis."""
        targets = extractor._get_side_channel_targets()
        assert "electromagnetic" in targets

    def test_cache_timing_has_aes_tables(self, extractor: CryptoKeyExtractor) -> None:
        """Cache timing targets include AES table lookups."""
        targets = extractor._get_side_channel_targets()
        cache = targets["cache_timing"]
        assert "aes_table_lookups" in cache

    def test_cache_timing_has_rsa_operations(self, extractor: CryptoKeyExtractor) -> None:
        """Cache timing targets include RSA square-multiply."""
        targets = extractor._get_side_channel_targets()
        cache = targets["cache_timing"]
        assert "rsa_square_multiply" in cache

    def test_cache_timing_has_ecc_operations(self, extractor: CryptoKeyExtractor) -> None:
        """Cache timing targets include ECC point operations."""
        targets = extractor._get_side_channel_targets()
        cache = targets["cache_timing"]
        assert "ecc_point_operations" in cache


class TestPowerAnalysisPatterns:
    """Test power analysis pattern generation."""

    def test_power_patterns_has_hamming_weights(self, extractor: CryptoKeyExtractor) -> None:
        """Power patterns include Hamming weight table."""
        patterns = extractor._get_power_patterns()
        assert "hamming_weights" in patterns

    def test_hamming_weights_has_256_entries(self, extractor: CryptoKeyExtractor) -> None:
        """Hamming weight table has 256 entries (one per byte)."""
        patterns = extractor._get_power_patterns()
        weights = patterns["hamming_weights"]
        assert len(weights) == 256

    def test_hamming_weight_0x00_is_0(self, extractor: CryptoKeyExtractor) -> None:
        """Hamming weight of 0x00 is 0."""
        patterns = extractor._get_power_patterns()
        weights = patterns["hamming_weights"]
        assert weights[0] == 0

    def test_hamming_weight_0xff_is_8(self, extractor: CryptoKeyExtractor) -> None:
        """Hamming weight of 0xFF is 8."""
        patterns = extractor._get_power_patterns()
        weights = patterns["hamming_weights"]
        assert weights[255] == 8

    def test_hamming_weight_0x0f_is_4(self, extractor: CryptoKeyExtractor) -> None:
        """Hamming weight of 0x0F is 4."""
        patterns = extractor._get_power_patterns()
        weights = patterns["hamming_weights"]
        assert weights[0x0F] == 4

    def test_hamming_weight_0x01_is_1(self, extractor: CryptoKeyExtractor) -> None:
        """Hamming weight of 0x01 is 1."""
        patterns = extractor._get_power_patterns()
        weights = patterns["hamming_weights"]
        assert weights[0x01] == 1


class TestEntropyCalculation:
    """Test entropy calculation for key material identification."""

    def test_entropy_zero_for_null_data(self, extractor: CryptoKeyExtractor) -> None:
        """Entropy is zero for all-null data."""
        null_data = b"\x00" * 256
        entropy = extractor._calculate_entropy(null_data)
        assert entropy == 0.0

    def test_entropy_zero_for_repeated_byte(self, extractor: CryptoKeyExtractor) -> None:
        """Entropy is zero for single repeated byte."""
        repeated = b"\xAA" * 256
        entropy = extractor._calculate_entropy(repeated)
        assert entropy == 0.0

    def test_entropy_high_for_random_data(self, extractor: CryptoKeyExtractor) -> None:
        """Entropy is high for random data."""
        random_data = os.urandom(256)
        entropy = extractor._calculate_entropy(random_data)
        assert entropy > 7.0
        assert entropy <= 8.0

    def test_entropy_maximum_for_uniform_distribution(self, extractor: CryptoKeyExtractor) -> None:
        """Entropy is maximum (8.0) for uniform byte distribution."""
        uniform = bytes(range(256))
        entropy = extractor._calculate_entropy(uniform)
        assert entropy > 7.9

    def test_entropy_moderate_for_structured_data(self, extractor: CryptoKeyExtractor) -> None:
        """Entropy is moderate for structured data."""
        structured = b"ABCD" * 64
        entropy = extractor._calculate_entropy(structured)
        assert 1.0 < entropy < 3.0


class TestKeyExpansionPatterns:
    """Test key expansion pattern generation."""

    def test_aes_128_expansion_generates_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """AES-128 key expansion generates byte pattern."""
        expanded = extractor._generate_key_expansion_pattern(16, 11)
        assert isinstance(expanded, bytes)
        assert len(expanded) >= 16

    def test_aes_192_expansion_generates_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """AES-192 key expansion generates byte pattern."""
        expanded = extractor._generate_key_expansion_pattern(24, 13)
        assert isinstance(expanded, bytes)
        assert len(expanded) >= 24

    def test_aes_256_expansion_generates_bytes(self, extractor: CryptoKeyExtractor) -> None:
        """AES-256 key expansion generates byte pattern."""
        expanded = extractor._generate_key_expansion_pattern(32, 15)
        assert isinstance(expanded, bytes)
        assert len(expanded) >= 32


class TestRealBinaryAnalysis:
    """Test analysis of real Windows crypto DLLs."""

    def test_bcrypt_contains_aes_sbox(self, extractor: CryptoKeyExtractor, bcrypt_dll: bytes) -> None:
        """bcrypt.dll contains AES S-box constant."""
        aes_sbox = extractor._get_aes_sbox()
        found = aes_sbox[:32] in bcrypt_dll or aes_sbox[32:64] in bcrypt_dll
        assert found or bcrypt_dll

    def test_extract_from_memory_returns_list(self, extractor: CryptoKeyExtractor, bcrypt_dll: bytes) -> None:
        """extract_from_memory returns list of extracted keys."""
        result = extractor.extract_from_memory(bcrypt_dll[:65536], base_address=0x180000000)
        assert isinstance(result, list)

    def test_extract_from_binary_returns_list(self, extractor: CryptoKeyExtractor) -> None:
        """extract_from_binary returns list of extracted keys."""
        if WINDOWS_CRYPTO_DLLS["bcrypt"].exists():
            result = extractor.extract_from_binary(str(WINDOWS_CRYPTO_DLLS["bcrypt"]))
            assert isinstance(result, list)


class TestRSAPublicExponentDetection:
    """Test RSA public exponent (65537) detection."""

    def test_rsa_exponent_65537_little_endian(self, extractor: CryptoKeyExtractor) -> None:
        """RSA exponent 65537 in little-endian format."""
        e = 65537
        e_bytes_le = struct.pack("<I", e)
        assert e_bytes_le == b"\x01\x00\x01\x00"

    def test_rsa_exponent_65537_big_endian(self, extractor: CryptoKeyExtractor) -> None:
        """RSA exponent 65537 in big-endian format."""
        e = 65537
        e_bytes_be = struct.pack(">I", e)
        assert e_bytes_be == b"\x00\x01\x00\x01"

    def test_rsa_exponent_detected_in_binary(self, extractor: CryptoKeyExtractor) -> None:
        """RSA exponent 65537 can be found in binary data."""
        e = 65537
        e_bytes = struct.pack("<I", e)
        binary_data = b"\x00" * 100 + e_bytes + b"\x00" * 100
        assert e_bytes in binary_data


class TestEMSignaturePatterns:
    """Test electromagnetic emission signature patterns."""

    def test_em_signatures_has_aes_round(self, extractor: CryptoKeyExtractor) -> None:
        """EM signatures include AES round pattern."""
        targets = extractor._get_side_channel_targets()
        em = targets["electromagnetic"]
        em_sigs = em["em_signatures"]
        assert "aes_round" in em_sigs

    def test_em_signatures_has_rsa_multiplication(self, extractor: CryptoKeyExtractor) -> None:
        """EM signatures include RSA multiplication pattern."""
        targets = extractor._get_side_channel_targets()
        em = targets["electromagnetic"]
        em_sigs = em["em_signatures"]
        assert "rsa_multiplication" in em_sigs

    def test_em_signatures_has_ecc_scalar(self, extractor: CryptoKeyExtractor) -> None:
        """EM signatures include ECC scalar multiplication pattern."""
        targets = extractor._get_side_channel_targets()
        em = targets["electromagnetic"]
        em_sigs = em["em_signatures"]
        assert "ecc_scalar" in em_sigs


class TestBitTransitionPatterns:
    """Test bit transition pattern calculation."""

    def test_bit_transitions_calculated(self, extractor: CryptoKeyExtractor) -> None:
        """Bit transitions are calculated."""
        transitions = extractor._calculate_bit_transitions()
        assert isinstance(transitions, list)
        assert len(transitions) == 1000


class TestKeyExport:
    """Test key export functionality."""

    def test_export_keys_method_exists(self, extractor: CryptoKeyExtractor) -> None:
        """export_keys method exists on extractor."""
        assert hasattr(extractor, "export_keys")
        assert callable(extractor.export_keys)


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
