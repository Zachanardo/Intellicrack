"""Production-ready scope validation tests for BypassEngine.

Validates that BypassEngine contains ONLY license bypass functionality and NO
shell-related payloads, network exploitation capabilities, or other scope violations.
These tests ensure Intellicrack remains focused exclusively on software licensing
cracking and does not contain general-purpose exploitation code.

CRITICAL: These tests MUST FAIL if any of the following are detected:
- REVERSE_SHELL, BIND_SHELL, or similar shell payload types
- Network exploitation capabilities (reverse connections, bind listeners)
- System exploitation features unrelated to license bypass
- Malware creation functionality
- Remote code execution capabilities

All tests use real code scanning and validation - NO mocks, NO stubs.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import ast
import inspect
import re
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.bypass_engine import BypassEngine, PayloadType


class TestPayloadTypeEnumScopeValidation:
    """Validate PayloadType enum contains ONLY license bypass types."""

    def test_payload_type_enum_has_no_shell_payloads(self) -> None:
        """PayloadType enum does NOT contain REVERSE_SHELL or BIND_SHELL."""
        payload_types = [member.name for member in PayloadType]

        assert "REVERSE_SHELL" not in payload_types
        assert "BIND_SHELL" not in payload_types
        assert "STAGED_SHELL" not in payload_types
        assert "METERPRETER" not in payload_types
        assert "CMD_SHELL" not in payload_types
        assert "POWERSHELL_SHELL" not in payload_types

    def test_payload_type_enum_has_no_network_exploitation(self) -> None:
        """PayloadType enum does NOT contain network exploitation types."""
        payload_types = [member.name for member in PayloadType]

        assert "CONNECT_BACK" not in payload_types
        assert "REVERSE_TCP" not in payload_types
        assert "REVERSE_HTTP" not in payload_types
        assert "REVERSE_HTTPS" not in payload_types
        assert "BIND_TCP" not in payload_types
        assert "NETWORK_PIVOT" not in payload_types

    def test_payload_type_enum_has_no_malware_capabilities(self) -> None:
        """PayloadType enum does NOT contain malware creation types."""
        payload_types = [member.name for member in PayloadType]

        assert "BACKDOOR" not in payload_types
        assert "TROJAN" not in payload_types
        assert "ROOTKIT" not in payload_types
        assert "KEYLOGGER" not in payload_types
        assert "RANSOMWARE" not in payload_types
        assert "BOTNET" not in payload_types

    def test_payload_type_enum_has_no_data_exfiltration(self) -> None:
        """PayloadType enum does NOT contain data exfiltration types."""
        payload_types = [member.name for member in PayloadType]

        assert "DATA_EXFIL" not in payload_types
        assert "CREDENTIAL_DUMP" not in payload_types
        assert "PASSWORD_STEALER" not in payload_types
        assert "FILE_UPLOAD" not in payload_types
        assert "SCREENSHOT_CAPTURE" not in payload_types

    def test_payload_type_enum_contains_only_license_types(self) -> None:
        """PayloadType enum contains ONLY legitimate license bypass types."""
        payload_types = [member.name for member in PayloadType]

        expected_license_types = {
            "LICENSE_CHECK_BYPASS",
            "TRIAL_EXTENSION",
            "ACTIVATION_BYPASS",
            "SERIAL_VALIDATION_BYPASS",
            "HARDWARE_ID_SPOOF",
        }

        actual_types = set(payload_types)
        assert actual_types == expected_license_types

    def test_payload_type_enum_has_exactly_five_members(self) -> None:
        """PayloadType enum has exactly 5 license-related members, no more."""
        payload_types = list(PayloadType)
        assert len(payload_types) == 5

    def test_payload_type_values_are_license_focused(self) -> None:
        """PayloadType values reference license/trial/activation/serial/hardware."""
        for member in PayloadType:
            value = member.value.lower()
            license_keywords = ["license", "trial", "activation", "serial", "hardware"]
            assert any(keyword in value for keyword in license_keywords)


class TestPayloadTypeEnumDocumentationValidation:
    """Validate PayloadType enum documentation enforces scope."""

    def test_payload_type_docstring_forbids_malware(self) -> None:
        """PayloadType docstring explicitly states NO malware capabilities."""
        docstring = PayloadType.__doc__
        assert docstring is not None
        assert "NO malware" in docstring or "no malware" in docstring.lower()

    def test_payload_type_docstring_forbids_shell_payloads(self) -> None:
        """PayloadType docstring explicitly states NO shell payloads."""
        docstring = PayloadType.__doc__
        assert docstring is not None
        assert "NO" in docstring and "shell" in docstring.lower()

    def test_payload_type_docstring_emphasizes_licensing_focus(self) -> None:
        """PayloadType docstring emphasizes licensing-only focus."""
        docstring = PayloadType.__doc__
        assert docstring is not None
        license_terms = ["license", "licensing", "trial", "activation"]
        assert any(term in docstring.lower() for term in license_terms)

    def test_payload_type_docstring_states_exclusive_scope(self) -> None:
        """PayloadType docstring uses EXCLUSIVELY or SOLELY to enforce scope."""
        docstring = PayloadType.__doc__
        assert docstring is not None
        scope_enforcement = ["EXCLUSIVELY", "SOLELY", "exclusive", "only"]
        assert any(term in docstring for term in scope_enforcement)


class TestBypassEngineClassScopeValidation:
    """Validate BypassEngine class documentation enforces scope."""

    def test_bypass_engine_docstring_forbids_malware(self) -> None:
        """BypassEngine docstring explicitly forbids malware generation."""
        docstring = BypassEngine.__doc__
        assert docstring is not None
        assert "NOT" in docstring and "malware" in docstring.lower()

    def test_bypass_engine_docstring_forbids_shell_code(self) -> None:
        """BypassEngine docstring explicitly forbids shell code generation."""
        docstring = BypassEngine.__doc__
        assert docstring is not None
        assert "NOT" in docstring and ("shell" in docstring.lower() or "Shell" in docstring)

    def test_bypass_engine_docstring_forbids_system_exploits(self) -> None:
        """BypassEngine docstring explicitly forbids system exploits."""
        docstring = BypassEngine.__doc__
        assert docstring is not None
        assert "NOT" in docstring and "exploit" in docstring.lower()

    def test_bypass_engine_docstring_forbids_network_attacks(self) -> None:
        """BypassEngine docstring explicitly forbids network attack code."""
        docstring = BypassEngine.__doc__
        assert docstring is not None
        assert "NOT" in docstring and "network attack" in docstring.lower()

    def test_bypass_engine_docstring_states_licensing_exclusive(self) -> None:
        """BypassEngine docstring states EXCLUSIVELY for licensing."""
        docstring = BypassEngine.__doc__
        assert docstring is not None
        assert "EXCLUSIVELY" in docstring and "licensing" in docstring.lower()


class TestBypassEngineMethodScopeValidation:
    """Validate BypassEngine methods only generate license bypass payloads."""

    def test_generate_payload_returns_only_license_payload_types(self) -> None:
        """generate_payload only returns license-related payload types."""
        engine = BypassEngine()

        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info={
                    "os_type": "windows",
                    "os_version": "10",
                    "architecture": "x64",
                    "protections": [],
                    "av_products": [],
                    "network_config": {},
                    "process_info": {},
                },
            )

            assert result["payload_type"] in [
                "license_check_bypass",
                "trial_extension",
                "activation_bypass",
                "serial_validation_bypass",
                "hardware_id_spoof",
            ]

    def test_generate_payload_rejects_shell_payload_string_input(self) -> None:
        """generate_payload defaults to license bypass when given invalid shell type."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        result = engine.generate_payload(
            payload_type="reverse_shell",
            architecture="x64",
            target_info=target_info,
        )

        assert result["payload_type"] == "license_check_bypass"

    def test_generate_payload_has_no_network_configuration_usage(self) -> None:
        """generate_payload does NOT use lhost/lport for reverse connections."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={
                "lhost": "attacker.example.com",
                "lport": 4444,
            },
        )

        payload = result["payload"]
        assert b"attacker.example.com" not in payload
        assert 4444 not in [payload[i] | (payload[i + 1] << 8) for i in range(len(payload) - 1)]


class TestBypassEngineSourceCodeValidation:
    """Validate bypass_engine.py source code contains no scope violations."""

    @pytest.fixture
    def bypass_engine_source_path(self) -> Path:
        """Get path to bypass_engine.py source file."""
        module_file = inspect.getfile(BypassEngine)
        return Path(module_file)

    @pytest.fixture
    def bypass_engine_source(self, bypass_engine_source_path: Path) -> str:
        """Read bypass_engine.py source code."""
        return bypass_engine_source_path.read_text(encoding="utf-8")

    def test_source_has_no_reverse_shell_references(self, bypass_engine_source: str) -> None:
        """Source code has NO references to REVERSE_SHELL."""
        assert "REVERSE_SHELL" not in bypass_engine_source
        assert "reverse_shell" not in bypass_engine_source.lower()

    def test_source_has_no_bind_shell_references(self, bypass_engine_source: str) -> None:
        """Source code has NO references to BIND_SHELL."""
        assert "BIND_SHELL" not in bypass_engine_source
        assert "bind_shell" not in bypass_engine_source.lower()

    def test_source_has_no_connect_back_references(self, bypass_engine_source: str) -> None:
        """Source code has NO references to connect-back functionality."""
        connect_back_patterns = [
            "connect_back",
            "connectback",
            "reverse_tcp",
            "reverse_http",
            "bind_tcp",
        ]
        source_lower = bypass_engine_source.lower()
        for pattern in connect_back_patterns:
            assert pattern not in source_lower

    def test_source_has_no_socket_connection_code(self, bypass_engine_source: str) -> None:
        """Source code has NO socket connection code for reverse shells."""
        socket_patterns = [
            re.compile(r"socket\.connect\(", re.IGNORECASE),
            re.compile(r"socket\.bind\(", re.IGNORECASE),
            re.compile(r"socket\.listen\(", re.IGNORECASE),
            re.compile(r"socket\.accept\(", re.IGNORECASE),
        ]

        for pattern in socket_patterns:
            matches = pattern.findall(bypass_engine_source)
            assert len(matches) == 0

    def test_source_has_no_payload_encoding_for_evasion_beyond_license(
        self, bypass_engine_source: str
    ) -> None:
        """Source code encoding features are for license bypass, not general exploitation."""
        if "encoding" in bypass_engine_source.lower():
            assert "base64" in bypass_engine_source or "xor" in bypass_engine_source

    def test_source_has_no_backdoor_references(self, bypass_engine_source: str) -> None:
        """Source code has NO references to backdoor functionality."""
        backdoor_terms = ["backdoor", "trojan", "rootkit", "botnet", "c2", "command_and_control"]
        source_lower = bypass_engine_source.lower()
        for term in backdoor_terms:
            assert term not in source_lower

    def test_source_has_no_credential_dumping(self, bypass_engine_source: str) -> None:
        """Source code has NO credential dumping functionality."""
        cred_terms = ["mimikatz", "lsass", "sam_dump", "hashdump", "credential_dump"]
        source_lower = bypass_engine_source.lower()
        for term in cred_terms:
            assert term not in source_lower

    def test_source_has_no_persistence_mechanisms(self, bypass_engine_source: str) -> None:
        """Source code has NO persistence mechanisms unrelated to licensing."""
        persistence_terms = [
            "startup_folder",
            "autorun",
            "scheduled_task",
            "service_install",
            "registry_run_key",
        ]
        source_lower = bypass_engine_source.lower()
        for term in persistence_terms:
            if term in source_lower:
                assert False, f"Found persistence mechanism: {term}"


class TestPayloadGeneratorMappingScopeValidation:
    """Validate payload generator mappings contain only license bypass functions."""

    def test_payload_generators_dict_has_only_license_types(self) -> None:
        """Internal payload_generators dict maps only to license bypass types."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info=target_info,
            )

            generated_type = result["payload_type"]
            assert generated_type in [
                "license_check_bypass",
                "trial_extension",
                "activation_bypass",
                "serial_validation_bypass",
                "hardware_id_spoof",
            ]

    def test_no_shell_payload_generator_methods_exist(self) -> None:
        """BypassEngine has NO _generate_reverse_shell or similar methods."""
        engine = BypassEngine()
        method_names = [method for method in dir(engine) if not method.startswith("__")]

        shell_method_patterns = [
            "_generate_reverse_shell",
            "_generate_bind_shell",
            "_generate_meterpreter",
            "_generate_cmd_shell",
            "_generate_connect_back",
        ]

        for pattern in shell_method_patterns:
            assert pattern not in method_names


class TestPayloadContentValidation:
    """Validate generated payloads contain NO network exploitation code."""

    def test_license_bypass_payload_contains_no_socket_operations(self) -> None:
        """License bypass payload contains NO socket operations."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        payload = result["payload"]
        ws2_32_socket_syscalls = [
            b"ws2_32",
            b"WS2_32",
            b"WSASocket",
            b"socket",
            b"connect",
            b"bind",
            b"listen",
            b"accept",
        ]

        for syscall in ws2_32_socket_syscalls:
            assert syscall not in payload

    def test_trial_extension_payload_contains_no_network_code(self) -> None:
        """Trial extension payload contains NO network communication code."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.TRIAL_EXTENSION,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        payload = result["payload"]
        network_indicators = [b"http://", b"https://", b"tcp://", b"127.0.0.1", b"0.0.0.0"]

        for indicator in network_indicators:
            assert indicator not in payload

    def test_activation_bypass_payload_is_local_only(self) -> None:
        """Activation bypass payload performs only local operations."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.ACTIVATION_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        payload = result["payload"]
        assert len(payload) < 1024
        assert b"\xc3" in payload

    def test_serial_validation_bypass_contains_no_exfiltration(self) -> None:
        """Serial validation bypass contains NO data exfiltration code."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.SERIAL_VALIDATION_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        payload = result["payload"]
        exfil_apis = [
            b"CreateFile",
            b"WriteFile",
            b"HttpSendRequest",
            b"InternetConnect",
            b"send",
            b"sendto",
        ]

        for api in exfil_apis:
            assert api not in payload

    def test_hardware_id_spoof_is_local_substitution(self) -> None:
        """Hardware ID spoof performs local data substitution only."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.HARDWARE_ID_SPOOF,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"spoofed_hwid": b"TEST-HWID-12345"},
        )

        payload = result["payload"]
        assert b"TEST-HWID-12345" in payload or b"TEST-HWID-12345"[:8] in payload


class TestOutputFormatScopeValidation:
    """Validate output formats don't enable general exploitation."""

    def test_powershell_output_contains_no_download_cradle(self) -> None:
        """PowerShell output format contains NO download cradle code."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"output_format": "powershell"},
        )

        payload_str = result["payload"].decode("utf-8", errors="ignore")
        download_patterns = [
            "Invoke-WebRequest",
            "IWR",
            "DownloadString",
            "DownloadFile",
            "WebClient",
            "Net.WebClient",
        ]

        for pattern in download_patterns:
            assert pattern not in payload_str

    def test_python_output_contains_no_shell_execution(self) -> None:
        """Python output format contains NO shell execution code."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"output_format": "python"},
        )

        payload_str = result["payload"].decode("utf-8", errors="ignore")
        shell_patterns = ["subprocess", "os.system", "os.popen", "exec", "eval"]

        for pattern in shell_patterns:
            assert pattern not in payload_str

    def test_exe_wrapper_contains_only_payload_code(self) -> None:
        """EXE wrapper contains only the license bypass payload code."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"output_format": "exe"},
        )

        payload = result["payload"]
        assert payload[:2] == b"MZ"
        assert b"PE\x00\x00" in payload


class TestEncodingSchemeScopeValidation:
    """Validate encoding schemes are for obfuscation, not evasion of defensive tools."""

    def test_encoding_schemes_are_simple_transformations(self) -> None:
        """Encoding schemes are simple transformations for license bypass."""
        engine = BypassEngine()

        base_result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        encoded_result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"encoding_schemes": ["xor"]},
        )

        assert len(encoded_result["payload"]) == len(base_result["payload"])

    def test_base64_encoding_available_for_transport(self) -> None:
        """Base64 encoding is available for safe transport/storage."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"encoding_schemes": ["base64"]},
        )

        import base64

        try:
            decoded = base64.b64decode(result["payload"])
            assert len(decoded) > 0
        except Exception:
            pytest.fail("Base64 encoding produced invalid output")


class TestArchitectureSupportScopeValidation:
    """Validate all architectures generate only license bypass code."""

    @pytest.mark.parametrize("architecture", ["x64", "x86", "arm64", "arm"])
    def test_architecture_generates_license_bypass_only(self, architecture: str) -> None:
        """Each architecture generates only license bypass payloads."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture=architecture,
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": architecture,
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        assert result["payload_type"] == "license_check_bypass"
        assert result["architecture"] in ["x64", "x86", "arm64", "arm"]

    @pytest.mark.parametrize("architecture", ["x64", "x86", "arm64", "arm"])
    def test_architecture_payload_is_position_independent(self, architecture: str) -> None:
        """Generated payloads are simple return value modifications."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture=architecture,
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": architecture,
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
            options={"preserve_stack": False},
        )

        payload = result["payload"]
        assert len(payload) < 100


class TestMetadataScopeValidation:
    """Validate payload metadata doesn't leak exploitation details."""

    def test_metadata_describes_license_bypass_only(self) -> None:
        """Payload metadata describes license bypass functionality only."""
        engine = BypassEngine()

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info={
                "os_type": "windows",
                "os_version": "10",
                "architecture": "x64",
                "protections": [],
                "av_products": [],
                "network_config": {},
                "process_info": {},
            },
        )

        metadata = result["metadata"]
        assert "encoding_applied" in metadata
        assert "output_format" in metadata
        assert "target_os" in metadata

        assert "lhost" not in metadata
        assert "lport" not in metadata
        assert "callback" not in metadata

    def test_payload_type_field_is_license_related(self) -> None:
        """Payload type field in result is always license-related."""
        engine = BypassEngine()

        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info={
                    "os_type": "windows",
                    "os_version": "10",
                    "architecture": "x64",
                    "protections": [],
                    "av_products": [],
                    "network_config": {},
                    "process_info": {},
                },
            )

            payload_type_str = result["payload_type"]
            license_keywords = ["license", "trial", "activation", "serial", "hardware"]
            assert any(keyword in payload_type_str for keyword in license_keywords)


class TestBypassEngineMethodDocstringScopeValidation:
    """Validate method docstrings emphasize license bypass scope."""

    def test_generate_payload_docstring_emphasizes_license_bypass(self) -> None:
        """generate_payload docstring emphasizes license bypass purpose."""
        docstring = BypassEngine.generate_payload.__doc__
        assert docstring is not None
        assert "license" in docstring.lower() or "licensing" in docstring.lower()

    def test_private_generator_methods_are_license_focused(self) -> None:
        """All private _generate_* methods have license-focused names."""
        engine = BypassEngine()
        private_methods = [
            method
            for method in dir(engine)
            if method.startswith("_generate_") and callable(getattr(engine, method))
        ]

        license_terms = [
            "license",
            "trial",
            "activation",
            "serial",
            "hardware",
            "hwid",
            "x64",
            "x86",
            "arm",
        ]

        for method_name in private_methods:
            method_lower = method_name.lower()
            assert any(
                term in method_lower for term in license_terms
            ), f"Method {method_name} not clearly license-focused"


class TestNoNetworkListenerCapabilities:
    """Validate BypassEngine has NO network listener capabilities."""

    def test_no_bind_port_functionality(self) -> None:
        """BypassEngine has NO functionality to bind to network ports."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        result = engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=target_info,
            options={"lport": 8080},
        )

        payload = result["payload"]
        port_bytes = 8080 .to_bytes(2, byteorder="little")
        assert port_bytes not in payload

    def test_no_listener_socket_creation(self) -> None:
        """BypassEngine does NOT create listener sockets."""
        source_path = Path(inspect.getfile(BypassEngine))
        source = source_path.read_text(encoding="utf-8")

        listener_patterns = [
            "socket.bind",
            "socket.listen",
            "socket.accept",
            "bind(",
            "listen(",
            "accept(",
        ]

        for pattern in listener_patterns:
            assert pattern not in source


class TestNoRemoteCodeExecutionCapabilities:
    """Validate BypassEngine has NO remote code execution capabilities."""

    def test_no_command_execution_over_network(self) -> None:
        """BypassEngine does NOT execute commands received over network."""
        source_path = Path(inspect.getfile(BypassEngine))
        source = source_path.read_text(encoding="utf-8")

        rce_patterns = [
            "subprocess.run",
            "os.system",
            "os.popen",
            "eval(",
            "exec(",
            "CreateProcess",
            "ShellExecute",
        ]

        for pattern in rce_patterns:
            assert pattern not in source

    def test_generated_payloads_have_no_process_creation(self) -> None:
        """Generated payloads do NOT contain process creation code."""
        engine = BypassEngine()

        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info={
                    "os_type": "windows",
                    "os_version": "10",
                    "architecture": "x64",
                    "protections": [],
                    "av_products": [],
                    "network_config": {},
                    "process_info": {},
                },
            )

            payload = result["payload"]
            process_apis = [b"CreateProcess", b"ShellExecute", b"WinExec", b"system"]

            for api in process_apis:
                assert api not in payload


class TestCompleteScopeComplianceIntegration:
    """Integration tests validating complete scope compliance."""

    def test_complete_bypass_workflow_is_license_focused(self) -> None:
        """Complete bypass generation workflow focuses only on license bypass."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        results = []
        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type, architecture="x64", target_info=target_info
            )
            results.append(result)

        assert len(results) == 5

        for result in results:
            assert result["payload_type"] in [
                "license_check_bypass",
                "trial_extension",
                "activation_bypass",
                "serial_validation_bypass",
                "hardware_id_spoof",
            ]
            assert isinstance(result["payload"], bytes)
            assert result["size"] > 0

    def test_all_payload_types_produce_local_only_code(self) -> None:
        """All payload types produce code for local license manipulation only."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        for payload_type in PayloadType:
            result = engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info=target_info,
                options={"preserve_stack": True},
            )

            payload = result["payload"]

            network_indicators = [
                b"socket",
                b"connect",
                b"bind",
                b"listen",
                b"http",
                b"https",
                b"tcp",
            ]

            for indicator in network_indicators:
                assert indicator not in payload.lower()

    def test_bypass_engine_exports_only_safe_classes(self) -> None:
        """bypass_engine module exports only BypassEngine and PayloadType."""
        from intellicrack.core.exploitation import bypass_engine

        assert hasattr(bypass_engine, "__all__")
        exported = bypass_engine.__all__
        assert set(exported) == {"BypassEngine", "PayloadType"}


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
