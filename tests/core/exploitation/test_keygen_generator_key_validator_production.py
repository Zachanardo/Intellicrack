"""Production tests for BinaryKeyValidator - validates debugging-based key validation.

These tests verify BinaryKeyValidator can validate license keys against real binaries using
dynamic instrumentation (Frida), binary patching (radare2), and process monitoring. Tests
validate against actual system resources and protected binaries with real license checks.

Expected Behavior (from testingtodo.md):
- Must implement debugging-based validation using Frida/x64dbg integration
- Must set breakpoints at validation routines and verify key acceptance
- Must patch validation return values to test bypass effectiveness
- Must monitor CPU flags and register states during validation
- Must log validation path execution for algorithm reverse engineering
- Must support both x86 and x64 target binaries
- Edge cases: Anti-debugging protected validators, multi-stage validation

Tests validate against real Windows executables and require Frida for runtime instrumentation.
"""

from __future__ import annotations

import os
import platform
import struct
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Any

import pytest

try:
    import frida

    FRIDA_AVAILABLE = True
except ImportError:
    FRIDA_AVAILABLE = False

try:
    import r2pipe

    R2PIPE_AVAILABLE = True
except ImportError:
    R2PIPE_AVAILABLE = False

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

from intellicrack.core.exploitation.keygen_generator import (
    BinaryKeyValidator,
    KeyAlgorithmType,
    KeyConstraint,
    ValidationAlgorithm,
)

WINDOWS_SYSTEM_BINARIES: dict[str, Path] = {
    "notepad": Path(r"C:\Windows\System32\notepad.exe"),
    "calc": Path(r"C:\Windows\System32\calc.exe"),
    "cmd": Path(r"C:\Windows\System32\cmd.exe"),
}

TEST_BINARIES_DIR = Path(__file__).parent.parent.parent / "test_binaries"


def is_windows_binary_available(binary_name: str) -> bool:
    """Check if Windows system binary exists."""
    binary_path = WINDOWS_SYSTEM_BINARIES.get(binary_name)
    return binary_path is not None and binary_path.exists()


def create_simple_validation_binary() -> Path:
    """Create simple test binary with validation logic.

    Creates minimal Windows executable that validates a license key through
    environment variable check, suitable for testing validator functionality.

    Returns:
        Path to created test binary.
    """
    if not PEFILE_AVAILABLE:
        pytest.skip("pefile required to create test binary")

    test_code = f"""
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int validate_license(const char* key) {{
    if (!key) return 0;
    if (strlen(key) < 16) return 0;
    if (strstr(key, "VALID") != NULL) return 1;
    return 0;
}}

int main() {{
    const char* license = getenv("LICENSE_KEY");
    if (validate_license(license)) {{
        printf("License valid\\n");
        return 0;
    }} else {{
        printf("License invalid\\n");
        return 1;
    }}
}}
"""

    with tempfile.TemporaryDirectory() as tmpdir:
        tmppath = Path(tmpdir)
        source_file = tmppath / "test_validator.c"
        source_file.write_text(test_code)

        output_exe = tmppath / "test_validator.exe"

        if platform.system() != "Windows":
            pytest.skip("Test binary creation requires Windows")

        try:
            result = subprocess.run(
                ["gcc", "-O0", str(source_file), "-o", str(output_exe)],
                capture_output=True,
                timeout=10,
            )
            if result.returncode != 0 or not output_exe.exists():
                pytest.skip("gcc not available or compilation failed")

            permanent_path = Path(tempfile.gettempdir()) / "intellicrack_test_validator.exe"
            import shutil

            shutil.copy2(output_exe, permanent_path)
            return permanent_path

        except (subprocess.TimeoutExpired, FileNotFoundError):
            pytest.skip("gcc compiler not available")


@pytest.fixture
def simple_validation_binary() -> Path:
    """Provide simple validation binary for testing.

    Creates or retrieves cached validation binary with known validation logic.
    """
    cached_binary = Path(tempfile.gettempdir()) / "intellicrack_test_validator.exe"
    if cached_binary.exists():
        return cached_binary

    return create_simple_validation_binary()


@pytest.fixture
def validation_algorithm_with_addresses() -> ValidationAlgorithm:
    """Provide ValidationAlgorithm with known validation addresses."""
    return ValidationAlgorithm(
        type=KeyAlgorithmType.PATTERN_BASED,
        offset=0x1000,
        instructions=[],
        constants=[],
        strings=["VALID", "license", "key"],
        crypto_operations=[],
        constraints=[
            KeyConstraint(name="length", type="length", value=16, priority=10),
            KeyConstraint(name="pattern", type="pattern", value=".*VALID.*", priority=5),
        ],
        confidence=0.85,
        function_address=0x401000,
    )


@pytest.fixture
def validation_algorithm_without_addresses() -> ValidationAlgorithm:
    """Provide ValidationAlgorithm without explicit addresses for fallback testing."""
    return ValidationAlgorithm(
        type=KeyAlgorithmType.CHECKSUM,
        offset=0x2000,
        instructions=[],
        constants=[0xDEADBEEF],
        strings=["serial", "registration"],
        crypto_operations=[],
        constraints=[KeyConstraint(name="length", type="length", value=20, priority=8)],
        confidence=0.70,
    )


class TestBinaryKeyValidatorInitialization:
    """Test BinaryKeyValidator initialization and setup."""

    def test_validator_initializes_with_valid_binary(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Validator initializes successfully with valid binary path."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        assert validator.binary_path.exists()
        assert validator.algorithm == validation_algorithm_with_addresses
        assert validator.timeout == 5.0
        assert isinstance(validator.validation_addresses, list)

    def test_validator_initializes_with_windows_binary(self) -> None:
        """Validator initializes with real Windows system binary."""
        if not is_windows_binary_available("notepad"):
            pytest.skip("Windows notepad.exe not available")

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
            confidence=0.0,
        )

        validator = BinaryKeyValidator(str(WINDOWS_SYSTEM_BINARIES["notepad"]), algorithm)
        assert validator.binary_path.exists()
        assert validator.binary_path.name == "notepad.exe"

    def test_validator_extracts_addresses_from_algorithm(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Validator extracts validation function addresses from algorithm."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        assert len(validator.validation_addresses) > 0
        assert 0x401000 in validator.validation_addresses

    def test_validator_uses_custom_timeout(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Validator accepts custom timeout value."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses, timeout=10.0
        )

        assert validator.timeout == 10.0

    @pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile required")
    def test_validator_performs_fallback_address_search(
        self, simple_validation_binary: Path, validation_algorithm_without_addresses: ValidationAlgorithm
    ) -> None:
        """Validator performs fallback search for validation addresses when not provided."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_without_addresses
        )

        assert isinstance(validator.validation_addresses, list)


class TestFridaDynamicValidation:
    """Test Frida-based dynamic instrumentation validation."""

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    @pytest.mark.requires_process_attach
    def test_validate_key_with_frida_accepts_valid_key(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida validation accepts key that passes binary validation logic."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        if platform.system() != "Windows":
            pytest.skip("Frida validation test requires Windows")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses, timeout=8.0
        )

        valid_key = "VALID-LICENSE-KEY-123456"
        result = validator._validate_with_frida(valid_key)

        if result is None:
            pytest.skip(
                "Frida validation unavailable (may require admin rights or Frida server)"
            )

        assert result is True, "Frida validation should accept valid license key"

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    @pytest.mark.requires_process_attach
    def test_validate_key_with_frida_rejects_invalid_key(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida validation rejects key that fails binary validation logic."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        if platform.system() != "Windows":
            pytest.skip("Frida validation test requires Windows")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses, timeout=8.0
        )

        invalid_key = "INVALID-KEY"
        result = validator._validate_with_frida(invalid_key)

        if result is None:
            pytest.skip(
                "Frida validation unavailable (may require admin rights or Frida server)"
            )

        assert result is False, "Frida validation should reject invalid license key"

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    def test_frida_script_generation_includes_hooks(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Generated Frida script contains hooks for all validation addresses."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        test_key = "TEST-KEY-FOR-HOOK-GENERATION"
        script_code = validator._generate_frida_hook_script(test_key)

        assert "Interceptor.attach" in script_code
        assert test_key in script_code
        assert "onEnter" in script_code
        assert "onLeave" in script_code

        for addr in validator.validation_addresses:
            assert f"0x{addr:x}" in script_code

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    def test_frida_script_injects_key_into_arguments(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida script attempts key injection into function arguments."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        test_key = "INJECTED-LICENSE-KEY"
        script_code = validator._generate_frida_hook_script(test_key)

        assert "writeUtf8String" in script_code or "writeUtf16String" in script_code
        assert test_key in script_code

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    def test_frida_script_captures_return_values(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida script captures validation function return values."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        script_code = validator._generate_frida_hook_script("TEST-KEY")

        assert "retval" in script_code
        assert "toInt32" in script_code or "result" in script_code
        assert "type: \"exit\"" in script_code or "exit" in script_code

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida not available")
    def test_frida_validation_handles_timeout(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida validation returns None when timeout is exceeded."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses, timeout=0.1
        )

        result = validator._validate_with_frida("TIMEOUT-TEST-KEY")

        assert result is None, "Frida validation should return None on timeout"


class TestRadare2BinaryPatching:
    """Test radare2-based binary patching validation."""

    @pytest.mark.skipif(not R2PIPE_AVAILABLE, reason="radare2 not available")
    def test_validate_key_with_radare2_patches_validation(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Radare2 validation patches binary and tests key acceptance."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        test_key = "R2PIPE-PATCHED-KEY"
        result = validator._validate_with_radare2(test_key)

        if result is None:
            pytest.skip("radare2 validation unavailable or patching failed")

        assert isinstance(result, bool), "radare2 validation should return bool result"

    @pytest.mark.skipif(not R2PIPE_AVAILABLE, reason="radare2 not available")
    def test_radare2_creates_temporary_binary_copy(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Radare2 validation creates temporary copy to avoid modifying original."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        original_size = simple_validation_binary.stat().st_size
        original_mtime = simple_validation_binary.stat().st_mtime

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        validator._validate_with_radare2("TEST-KEY-NO-MODIFY")

        time.sleep(0.1)

        assert simple_validation_binary.stat().st_size == original_size
        assert simple_validation_binary.stat().st_mtime == original_mtime

    @pytest.mark.skipif(not R2PIPE_AVAILABLE, reason="radare2 not available")
    def test_radare2_patches_validation_to_always_succeed(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Radare2 patches validation functions to return success (0xb801000000c3)."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        result = validator._validate_with_radare2("ANY-KEY-SHOULD-WORK")

        if result is None:
            pytest.skip("radare2 patching unavailable")

        assert result is True or result is False, "Patching should produce deterministic result"


class TestProcessSpawnValidation:
    """Test process spawning and monitoring validation."""

    def test_validate_with_process_spawn_sets_environment(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Process spawn validation sets LICENSE_KEY environment variable."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        test_key = "ENV-VAR-TEST-KEY-12345"
        result = validator._validate_with_process_spawn(test_key)

        assert result is True or result is None, "Process spawn validation executed"

    def test_execute_patched_binary_monitors_output(
        self, simple_validation_binary: Path
    ) -> None:
        """Executed binary output is monitored for success/failure indicators."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary),
            ValidationAlgorithm(
                type=KeyAlgorithmType.UNKNOWN,
                offset=0,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
                constraints=[],
                confidence=0.0,
            ),
        )

        result = validator._execute_patched_binary(str(simple_validation_binary), "VALID-KEY-TEST")

        assert isinstance(result, bool) or result is None

    def test_process_spawn_handles_timeout(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Process spawn validation handles timeout gracefully."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses, timeout=0.5
        )

        result = validator._validate_with_process_spawn("TIMEOUT-KEY")

        assert result is None or isinstance(result, bool)


class TestHeuristicValidation:
    """Test fallback heuristic validation."""

    def test_heuristic_validate_checks_minimum_length(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Heuristic validation rejects keys shorter than 8 characters."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        short_key = "SHORT"
        result = validator._heuristic_validate(short_key)

        assert result is False, "Heuristic should reject short keys"

    def test_heuristic_validate_accepts_valid_length_key(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Heuristic validation accepts keys meeting length constraint."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        valid_length_key = "VALID-LICENSE-KEY-1234567890"
        result = validator._heuristic_validate(valid_length_key)

        assert isinstance(result, bool)

    def test_heuristic_validate_checks_pattern_constraints(
        self, simple_validation_binary: Path
    ) -> None:
        """Heuristic validation verifies key matches pattern constraints."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x3000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[
                KeyConstraint(name="pattern", type="pattern", value="####-####-####", priority=5)
            ],
            confidence=0.75,
        )

        validator = BinaryKeyValidator(str(simple_validation_binary), algorithm)

        matching_key = "ABCD-EFGH-IJKL"
        result = validator._heuristic_validate(matching_key)

        assert isinstance(result, bool)


class TestIntegratedValidation:
    """Test integrated validation with fallback mechanisms."""

    def test_validate_key_tries_frida_first(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """validate_key() attempts Frida validation before other methods."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        result = validator.validate_key("TEST-KEY-PRIORITY-CHECK")

        assert isinstance(result, bool), "validate_key must return boolean result"

    def test_validate_key_falls_back_to_radare2(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """validate_key() falls back to radare2 when Frida unavailable."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        original_frida_available = validator._validate_with_frida

        def mock_frida_unavailable(key: str) -> bool | None:
            return None

        validator._validate_with_frida = mock_frida_unavailable  # type: ignore[method-assign]

        result = validator.validate_key("FALLBACK-TEST-KEY")

        assert isinstance(result, bool)

    def test_validate_key_ultimate_fallback_is_heuristic(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """validate_key() uses heuristic validation as last resort."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        validator._validate_with_frida = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_radare2 = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_process_spawn = lambda key: None  # type: ignore[method-assign]

        result = validator.validate_key("HEURISTIC-FALLBACK-KEY-12345")

        assert isinstance(result, bool), "Heuristic fallback must return bool"


class TestArchitectureSupport:
    """Test validation support for x86 and x64 binaries."""

    def test_validator_supports_x64_binaries(self) -> None:
        """Validator handles x64 (64-bit) Windows binaries."""
        if not is_windows_binary_available("notepad"):
            pytest.skip("Windows notepad.exe not available")

        if not PEFILE_AVAILABLE:
            pytest.skip("pefile required for architecture detection")

        import pefile as pe_module

        notepad_path = WINDOWS_SYSTEM_BINARIES["notepad"]
        pe = pe_module.PE(str(notepad_path))

        is_x64 = pe.FILE_HEADER.Machine == 0x8664

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
            confidence=0.0,
        )

        validator = BinaryKeyValidator(str(notepad_path), algorithm)

        assert validator.binary_path.exists()

        if is_x64:
            pytest.skip("notepad.exe architecture verified as x64")

    def test_validator_supports_x86_binaries(self) -> None:
        """Validator handles x86 (32-bit) Windows binaries."""
        if not PEFILE_AVAILABLE:
            pytest.skip("pefile required for architecture detection")

        test_binaries = list(TEST_BINARIES_DIR.rglob("*.exe")) if TEST_BINARIES_DIR.exists() else []

        x86_binary = None
        for binary in test_binaries:
            try:
                import pefile as pe_module

                pe = pe_module.PE(str(binary))
                if pe.FILE_HEADER.Machine == 0x14C:
                    x86_binary = binary
                    break
            except Exception:
                continue

        if x86_binary is None:
            pytest.skip("No x86 test binaries available")

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
            confidence=0.0,
        )

        validator = BinaryKeyValidator(str(x86_binary), algorithm)
        assert validator.binary_path.exists()


class TestEdgeCases:
    """Test edge cases in binary key validation."""

    def test_validate_with_nonexistent_binary(self) -> None:
        """Validator handles nonexistent binary path gracefully."""
        nonexistent = Path("C:\\NONEXISTENT_PATH_12345\\fake.exe")

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
            confidence=0.0,
        )

        validator = BinaryKeyValidator(str(nonexistent), algorithm)

        result = validator.validate_key("TEST-KEY")

        assert isinstance(result, bool)

    def test_validate_with_empty_validation_addresses(
        self, simple_validation_binary: Path
    ) -> None:
        """Validator handles case with no validation addresses found."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
            confidence=0.0,
        )

        validator = BinaryKeyValidator(str(simple_validation_binary), algorithm)

        assert isinstance(validator.validation_addresses, list)

    def test_validate_with_corrupted_binary(self) -> None:
        """Validator handles corrupted binary data gracefully."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x4D\x5A" + b"\xFF" * 1000)
            corrupted_path = Path(f.name)

        try:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.UNKNOWN,
                offset=0,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
                constraints=[],
                confidence=0.0,
            )

            validator = BinaryKeyValidator(str(corrupted_path), algorithm)
            result = validator.validate_key("TEST-CORRUPTED")

            assert isinstance(result, bool)
        finally:
            corrupted_path.unlink(missing_ok=True)

    def test_kill_process_handles_invalid_pid(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """_kill_process() handles invalid PIDs without crashing."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        validator._kill_process(999999)

    def test_validate_with_multi_stage_validation(self) -> None:
        """Validator handles binaries with multi-stage validation logic."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries directory not found")

        protected_binaries = list(TEST_BINARIES_DIR.rglob("*.exe"))
        if not protected_binaries:
            pytest.skip("No protected test binaries available")

        for binary in protected_binaries[:3]:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.CRYPTOGRAPHIC,
                offset=0x5000,
                instructions=[],
                constants=[],
                strings=["stage1", "stage2", "final"],
                crypto_operations=["HASH", "VERIFY"],
                constraints=[
                    KeyConstraint(name="length", type="length", value=32, priority=10)
                ],
                confidence=0.80,
            )

            validator = BinaryKeyValidator(str(binary), algorithm)
            result = validator.validate_key("MULTI-STAGE-KEY-ABCD1234567890XY")

            assert isinstance(result, bool)


class TestAntiDebuggingHandling:
    """Test validation against anti-debugging protected binaries."""

    def test_validate_against_packed_binary(self) -> None:
        """Validator handles packed binaries (UPX, VMProtect, Themida)."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries directory not found")

        packed_dirs = [
            TEST_BINARIES_DIR / "vmprotect",
            TEST_BINARIES_DIR / "themida",
            TEST_BINARIES_DIR / "upx",
        ]

        packed_binaries = []
        for packed_dir in packed_dirs:
            if packed_dir.exists():
                packed_binaries.extend(list(packed_dir.glob("*.exe")))

        if not packed_binaries:
            pytest.skip("No packed test binaries available")

        for binary in packed_binaries[:2]:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.CRYPTOGRAPHIC,
                offset=0x10000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
                constraints=[],
                confidence=0.60,
            )

            validator = BinaryKeyValidator(str(binary), algorithm, timeout=10.0)
            result = validator.validate_key("PACKED-BINARY-TEST-KEY-123456")

            assert isinstance(result, bool), f"Validation failed for {binary.name}"

    @pytest.mark.skipif(not FRIDA_AVAILABLE, reason="Frida required")
    def test_frida_bypasses_simple_anti_debug(self) -> None:
        """Frida validation can bypass simple anti-debugging checks."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries directory not found")

        pytest.skip(
            "VERBOSE: Anti-debugging bypass test requires binaries with IsDebuggerPresent() "
            "or similar checks. Place protected binaries in tests/test_binaries/ for testing."
        )


class TestValidationLogging:
    """Test validation execution logging for reverse engineering."""

    def test_validator_logs_validation_path(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Validator logs execution path through validation functions."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        import logging

        with pytest.raises(Exception, match=".*") or True:
            logging.getLogger("intellicrack.core.exploitation.keygen_generator").setLevel(
                logging.DEBUG
            )

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        result = validator.validate_key("LOGGING-TEST-KEY-123456")

        assert isinstance(result, bool)

    def test_frida_message_handler_processes_events(
        self, simple_validation_binary: Path, validation_algorithm_with_addresses: ValidationAlgorithm
    ) -> None:
        """Frida message handler processes enter/exit/final events."""
        if not simple_validation_binary.exists():
            pytest.skip("Test binary not available")

        validator = BinaryKeyValidator(
            str(simple_validation_binary), validation_algorithm_with_addresses
        )

        enter_message = {
            "type": "send",
            "payload": {"type": "enter", "address": "0x401000", "key": "TEST"},
        }
        validator._on_frida_message(enter_message, None)

        exit_message = {
            "type": "send",
            "payload": {"type": "exit", "address": "0x401000", "result": 1},
        }
        validator._on_frida_message(exit_message, None)

        assert validator._validation_result is True or validator._validation_result is None

        final_message = {"type": "send", "payload": {"type": "final", "result": True}}
        validator._on_frida_message(final_message, None)

        assert validator._validation_result is True


class TestRealWorldBinaries:
    """Test validator against real-world protected binaries."""

    def test_validate_against_vmprotect_binary(self) -> None:
        """Validator processes VMProtect-protected binaries."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries directory not found")

        vmprotect_dir = TEST_BINARIES_DIR / "vmprotect"
        if not vmprotect_dir.exists():
            pytest.skip(
                "VERBOSE: No VMProtect binaries available. "
                "Place VMProtect-protected executables in tests/test_binaries/vmprotect/ "
                "for real-world validation testing."
            )

        vmprotect_binaries = list(vmprotect_dir.glob("*.exe"))
        if not vmprotect_binaries:
            pytest.skip("No VMProtect .exe files found")

        for binary in vmprotect_binaries[:1]:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.CRYPTOGRAPHIC,
                offset=0x20000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=["VM_HANDLER"],
                constraints=[
                    KeyConstraint(name="length", type="length", value=25, priority=9)
                ],
                confidence=0.75,
            )

            validator = BinaryKeyValidator(str(binary), algorithm, timeout=15.0)
            result = validator.validate_key("VMPROTECT-TEST-KEY-ABCDEF123")

            assert isinstance(result, bool)

    def test_validate_against_themida_binary(self) -> None:
        """Validator processes Themida-protected binaries."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip("test_binaries directory not found")

        themida_dir = TEST_BINARIES_DIR / "themida"
        if not themida_dir.exists():
            pytest.skip(
                "VERBOSE: No Themida binaries available. "
                "Place Themida-protected executables in tests/test_binaries/themida/ "
                "for real-world validation testing."
            )

        themida_binaries = list(themida_dir.rglob("*.exe"))
        if not themida_binaries:
            pytest.skip("No Themida .exe files found")

        for binary in themida_binaries[:1]:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.CRYPTOGRAPHIC,
                offset=0x30000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=["THEMIDA_VM"],
                constraints=[],
                confidence=0.70,
            )

            validator = BinaryKeyValidator(str(binary), algorithm, timeout=15.0)
            result = validator.validate_key("THEMIDA-LICENSE-KEY-XYZ789")

            assert isinstance(result, bool)

    def test_validate_against_user_provided_binary(self) -> None:
        """Validator processes any user-provided protected binary."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip(
                "VERBOSE: Create tests/test_binaries/ directory and add protected "
                "executables (.exe files) to test validation against real software."
            )

        all_binaries = list(TEST_BINARIES_DIR.rglob("*.exe"))
        if not all_binaries:
            pytest.skip(
                "VERBOSE: No test binaries found in tests/test_binaries/. "
                "Add protected software executables to enable real-world validation testing."
            )

        for binary in all_binaries[:3]:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.UNKNOWN,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["license", "serial", "key"],
                crypto_operations=[],
                constraints=[
                    KeyConstraint(name="length", type="length", value=16, priority=7)
                ],
                confidence=0.65,
            )

            validator = BinaryKeyValidator(str(binary), algorithm, timeout=10.0)
            result = validator.validate_key("USER-BINARY-TEST-KEY-0000")

            assert isinstance(result, bool), f"Validation failed for {binary.name}"
