"""Comprehensive production-ready tests for SymbolicExecutionEngine.

Validates actual symbolic execution, constraint solving, and path exploration capabilities
for real binary analysis. Tests verify genuine symbolic state management, vulnerability
discovery, and exploit generation on real compiled binaries.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import os
import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.analysis.symbolic_executor import SymbolicExecutionEngine

NOTEPAD_PATH = r"C:\WINDOWS\notepad.exe"
CALC_PATH = r"C:\WINDOWS\system32\calc.exe"
CMD_PATH = r"C:\WINDOWS\system32\cmd.exe"


def is_windows_binary_available(binary_path: str) -> bool:
    """Check if Windows system binary is available for testing."""
    return os.path.exists(binary_path) and os.path.isfile(binary_path)


@pytest.fixture
def notepad_binary() -> str:
    """Provide path to Windows notepad.exe for testing."""
    if not is_windows_binary_available(NOTEPAD_PATH):
        pytest.skip("Windows notepad.exe not available for testing")
    return NOTEPAD_PATH


@pytest.fixture
def calc_binary() -> str:
    """Provide path to Windows calc.exe for testing."""
    if not is_windows_binary_available(CALC_PATH):
        pytest.skip("Windows calc.exe not available for testing")
    return CALC_PATH


@pytest.fixture
def cmd_binary() -> str:
    """Provide path to Windows cmd.exe for testing."""
    if not is_windows_binary_available(CMD_PATH):
        pytest.skip("Windows cmd.exe not available for testing")
    return CMD_PATH


@pytest.fixture
def minimal_pe_binary() -> str:
    """Create minimal valid PE binary for basic testing."""
    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 128)

        pe_header = bytearray(248)
        pe_header[:4] = b"PE\x00\x00"
        pe_header[4:6] = struct.pack("<H", 0x8664)
        pe_header[6:8] = struct.pack("<H", 1)
        pe_header[20:22] = struct.pack("<H", 0xF0)
        pe_header[22:24] = struct.pack("<H", 0x020B)
        pe_header[24:28] = struct.pack("<I", 0x1000)

        section_header = bytearray(40)
        section_header[:8] = b".text\x00\x00\x00"
        section_header[8:12] = struct.pack("<I", 0x1000)
        section_header[12:16] = struct.pack("<I", 0x1000)
        section_header[16:20] = struct.pack("<I", 0x200)
        section_header[20:24] = struct.pack("<I", 0x200)
        section_header[36:40] = struct.pack("<I", 0x60000020)

        code_section = bytearray(512)
        code_section[:3] = b"\x48\x31\xC0"
        code_section[3:4] = b"\xC3"

        f.write(dos_header)
        f.write(bytearray(64))
        f.write(pe_header)
        f.write(section_header)
        f.write(code_section)

        temp_path = f.name

    yield temp_path

    try:
        os.unlink(temp_path)
    except Exception:
        pass


@pytest.fixture
def vulnerable_test_binary() -> str:
    """Create test binary with vulnerable patterns for detection."""
    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 128)

        pe_header = bytearray(248)
        pe_header[:4] = b"PE\x00\x00"
        pe_header[4:6] = struct.pack("<H", 0x8664)
        pe_header[6:8] = struct.pack("<H", 1)
        pe_header[20:22] = struct.pack("<H", 0xF0)
        pe_header[22:24] = struct.pack("<H", 0x020B)

        section_header = bytearray(40)
        section_header[:8] = b".text\x00\x00\x00"
        section_header[8:12] = struct.pack("<I", 0x1000)
        section_header[12:16] = struct.pack("<I", 0x1000)
        section_header[16:20] = struct.pack("<I", 0x800)
        section_header[20:24] = struct.pack("<I", 0x200)
        section_header[36:40] = struct.pack("<I", 0x60000020)

        code_section = bytearray(2048)
        code_section[:10] = b"\x48\x83\xEC\x20\x48\x8D\x4C\x24\x08"
        code_section[10:20] = b"strcpy\x00\x00\x00\x00"
        code_section[20:30] = b"memcpy\x00\x00\x00\x00"
        code_section[30:50] = b"\x48\x89\xCE\x48\x89\xD7\xF3\xA4"
        code_section[50:60] = b"sprintf\x00\x00"
        code_section[60:80] = b"\xFF\xE0\x48\x01\xC8\x48\x83\xC0\x10"
        code_section[80:100] = b"system\x00\x00"
        code_section[100:120] = b"exec\x00\x00\x00\x00"
        code_section[120:140] = b"\x48\x8B\x00\x48\x8B\x40\x08"
        code_section[140:160] = b"\x48\x31\xC0\xC3"

        f.write(dos_header)
        f.write(bytearray(64))
        f.write(pe_header)
        f.write(section_header)
        f.write(code_section)

        temp_path = f.name

    yield temp_path

    try:
        os.unlink(temp_path)
    except Exception:
        pass


class TestSymbolicExecutionEngineInitialization:
    """Test SymbolicExecutionEngine initialization and configuration."""

    def test_symbolic_engine_initializes_with_valid_binary(self, notepad_binary: str) -> None:
        """SymbolicExecutionEngine initializes successfully with real Windows binary."""
        engine = SymbolicExecutionEngine(
            binary_path=notepad_binary,
            max_paths=50,
            timeout=60,
            memory_limit=2048
        )

        assert engine is not None
        assert engine.binary_path == notepad_binary
        assert engine.max_paths == 50
        assert engine.timeout == 60
        assert engine.memory_limit == 2048 * 1024 * 1024
        assert engine.logger is not None
        assert isinstance(engine.states, list)
        assert isinstance(engine.completed_paths, list)
        assert isinstance(engine.crashed_states, list)
        assert isinstance(engine.discovered_vulnerabilities, list)

    def test_symbolic_engine_initializes_with_minimal_pe(self, minimal_pe_binary: str) -> None:
        """SymbolicExecutionEngine initializes with minimal PE binary."""
        engine = SymbolicExecutionEngine(
            binary_path=minimal_pe_binary,
            max_paths=10,
            timeout=30
        )

        assert engine.binary_path == minimal_pe_binary
        assert os.path.exists(engine.binary_path)
        assert engine.max_paths == 10
        assert engine.timeout == 30
        assert engine.memory_limit == 4096 * 1024 * 1024

    def test_symbolic_engine_rejects_nonexistent_binary(self) -> None:
        """SymbolicExecutionEngine raises FileNotFoundError for nonexistent binary."""
        fake_path = "C:\\nonexistent\\fake_binary.exe"

        with pytest.raises(FileNotFoundError) as exc_info:
            SymbolicExecutionEngine(binary_path=fake_path, max_paths=10, timeout=30)

        assert "Binary file not found" in str(exc_info.value)
        assert fake_path in str(exc_info.value)

    def test_symbolic_engine_has_correct_default_parameters(self, calc_binary: str) -> None:
        """SymbolicExecutionEngine uses correct default parameters."""
        engine = SymbolicExecutionEngine(binary_path=calc_binary)

        assert engine.max_paths == 100
        assert engine.timeout == 300
        assert engine.memory_limit == 4096 * 1024 * 1024

    def test_symbolic_engine_initializes_empty_state_containers(self, notepad_binary: str) -> None:
        """SymbolicExecutionEngine initializes empty containers for execution tracking."""
        engine = SymbolicExecutionEngine(binary_path=notepad_binary, max_paths=10)

        assert len(engine.states) == 0
        assert len(engine.completed_paths) == 0
        assert len(engine.crashed_states) == 0
        assert len(engine.timed_out_states) == 0
        assert len(engine.discovered_vulnerabilities) == 0
        assert len(engine.path_constraints) == 0


class TestSymbolicVulnerabilityDiscovery:
    """Test symbolic execution vulnerability discovery capabilities."""

    def test_discover_vulnerabilities_returns_list(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities returns list of vulnerability dictionaries."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "format_string"]
        )

        assert isinstance(vulnerabilities, list)
        for vuln in vulnerabilities:
            assert isinstance(vuln, dict)
            assert "type" in vuln
            assert "severity" in vuln

    def test_discover_vulnerabilities_with_buffer_overflow_detection(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities detects buffer overflow patterns in binary."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=30,
            timeout=90
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(vulnerabilities, list)

        buffer_overflow_vulns = [v for v in vulnerabilities if v.get("type") == "buffer_overflow"]

    def test_discover_vulnerabilities_with_format_string_detection(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities detects format string vulnerabilities."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["format_string"]
        )

        assert isinstance(vulnerabilities, list)

        format_string_vulns = [v for v in vulnerabilities if v.get("type") == "format_string"]

    def test_discover_vulnerabilities_with_multiple_types(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities can search for multiple vulnerability types simultaneously."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=25,
            timeout=90
        )

        vuln_types = ["buffer_overflow", "format_string", "integer_overflow", "command_injection"]
        vulnerabilities = engine.discover_vulnerabilities(vulnerability_types=vuln_types)

        assert isinstance(vulnerabilities, list)

        found_types = {v.get("type") for v in vulnerabilities}
        assert all(vtype in vuln_types or vtype in ["memory_leak", "null_pointer"] for vtype in found_types)

    def test_discover_vulnerabilities_returns_severity_levels(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities assigns severity levels to found vulnerabilities."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "use_after_free"]
        )

        valid_severities = {"low", "medium", "high", "critical"}
        for vuln in vulnerabilities:
            assert "severity" in vuln
            assert vuln["severity"] in valid_severities

    def test_discover_vulnerabilities_includes_location_information(self, vulnerable_test_binary: str) -> None:
        """discover_vulnerabilities includes address/location for each vulnerability."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=15,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "format_string"]
        )

        for vuln in vulnerabilities:
            assert "address" in vuln or "location" in vuln or "offset" in vuln

    def test_discover_vulnerabilities_on_real_windows_binary(self, notepad_binary: str) -> None:
        """discover_vulnerabilities analyzes real Windows system binary."""
        engine = SymbolicExecutionEngine(
            binary_path=notepad_binary,
            max_paths=50,
            timeout=120
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "integer_overflow"]
        )

        assert isinstance(vulnerabilities, list)

    def test_discover_vulnerabilities_respects_timeout(self, notepad_binary: str) -> None:
        """discover_vulnerabilities respects timeout parameter and terminates."""
        engine = SymbolicExecutionEngine(
            binary_path=notepad_binary,
            max_paths=100,
            timeout=10
        )

        import time
        start_time = time.time()

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        elapsed = time.time() - start_time

        assert isinstance(vulnerabilities, list)
        assert elapsed < 20


class TestSymbolicPathExploration:
    """Test symbolic execution path exploration capabilities."""

    def test_explore_from_specific_address(self, vulnerable_test_binary: str) -> None:
        """explore_from explores execution paths from specific start address."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        result = engine.explore_from(
            start_address=0x1000,
            max_depth=10,
            find_addresses=[],
            avoid_addresses=[]
        )

        assert isinstance(result, dict)
        assert "paths" in result or "states" in result or "coverage" in result

    def test_explore_from_discovers_multiple_paths(self, vulnerable_test_binary: str) -> None:
        """explore_from discovers multiple execution paths from start point."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=30,
            timeout=90
        )

        result = engine.explore_from(
            start_address=0x1000,
            max_depth=15
        )

        assert isinstance(result, dict)

        if "paths" in result:
            paths = result["paths"]
            assert isinstance(paths, list)

    def test_explore_from_respects_max_depth(self, vulnerable_test_binary: str) -> None:
        """explore_from respects maximum exploration depth parameter."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        max_depth = 5
        result = engine.explore_from(
            start_address=0x1000,
            max_depth=max_depth
        )

        assert isinstance(result, dict)

        if "paths" in result and result["paths"]:
            for path in result["paths"]:
                if isinstance(path, list):
                    assert len(path) <= max_depth + 5

    def test_explore_from_with_find_addresses(self, vulnerable_test_binary: str) -> None:
        """explore_from can target specific addresses to reach."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=25,
            timeout=90
        )

        target_addresses = [0x1100, 0x1200]
        result = engine.explore_from(
            start_address=0x1000,
            max_depth=20,
            find_addresses=target_addresses
        )

        assert isinstance(result, dict)

    def test_explore_from_with_avoid_addresses(self, vulnerable_test_binary: str) -> None:
        """explore_from avoids specified addresses during exploration."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        avoid_addresses = [0x1050, 0x1100]
        result = engine.explore_from(
            start_address=0x1000,
            max_depth=15,
            avoid_addresses=avoid_addresses
        )

        assert isinstance(result, dict)

        if "paths" in result:
            for path in result["paths"]:
                if isinstance(path, list):
                    for addr in path:
                        if isinstance(addr, int):
                            assert addr not in avoid_addresses

    def test_explore_from_extracts_constraints(self, vulnerable_test_binary: str) -> None:
        """explore_from extracts path constraints during exploration."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=15,
            timeout=60
        )

        result = engine.explore_from(
            start_address=0x1000,
            max_depth=10
        )

        assert isinstance(result, dict)

        if "constraints" in result:
            assert isinstance(result["constraints"], list)

    def test_explore_from_identifies_vulnerabilities_in_paths(self, vulnerable_test_binary: str) -> None:
        """explore_from identifies vulnerabilities discovered during path exploration."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=25,
            timeout=90
        )

        result = engine.explore_from(
            start_address=0x1000,
            max_depth=15,
            check_vulnerabilities=True
        )

        assert isinstance(result, dict)

        if "vulnerabilities" in result:
            vulnerabilities = result["vulnerabilities"]
            assert isinstance(vulnerabilities, list)

            for vuln in vulnerabilities:
                assert isinstance(vuln, dict)
                assert "type" in vuln


class TestSymbolicExploitGeneration:
    """Test symbolic execution exploit generation capabilities."""

    def test_generate_exploit_for_buffer_overflow(self, vulnerable_test_binary: str) -> None:
        """generate_exploit creates exploit payload for buffer overflow vulnerability."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        if vulnerabilities := engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        ):
            if buffer_overflow_vuln := next(
                (v for v in vulnerabilities if v.get("type") == "buffer_overflow"),
                None,
            ):
                exploit = engine.generate_exploit(buffer_overflow_vuln)

                assert isinstance(exploit, dict)
                assert "payload" in exploit or "exploit_type" in exploit
                assert "success" in exploit or "status" in exploit or "payload" in exploit

    def test_generate_exploit_for_format_string(self, vulnerable_test_binary: str) -> None:
        """generate_exploit creates exploit for format string vulnerability."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        if vulnerabilities := engine.discover_vulnerabilities(
            vulnerability_types=["format_string"]
        ):
            if format_vuln := next(
                (v for v in vulnerabilities if v.get("type") == "format_string"),
                None,
            ):
                exploit = engine.generate_exploit(format_vuln)

                assert isinstance(exploit, dict)
                assert "payload" in exploit or "exploit_type" in exploit

    def test_generate_exploit_for_use_after_free(self, vulnerable_test_binary: str) -> None:
        """generate_exploit creates heap exploit for use-after-free vulnerability."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        if vulnerabilities := engine.discover_vulnerabilities(
            vulnerability_types=["use_after_free"]
        ):
            if uaf_vuln := next(
                (v for v in vulnerabilities if v.get("type") == "use_after_free"),
                None,
            ):
                exploit = engine.generate_exploit(uaf_vuln)

                assert isinstance(exploit, dict)
                assert "payload" in exploit or "exploit_type" in exploit or "strategy" in exploit

    def test_generate_exploit_returns_payload_bytes(self, vulnerable_test_binary: str) -> None:
        """generate_exploit returns actual exploit payload bytes."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        if vulnerabilities := engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "format_string"]
        ):
            exploit = engine.generate_exploit(vulnerabilities[0])

            assert isinstance(exploit, dict)

            if "payload" in exploit:
                payload = exploit["payload"]
                assert isinstance(payload, (bytes, bytearray, str))

    def test_generate_exploit_includes_reliability_estimate(self, vulnerable_test_binary: str) -> None:
        """generate_exploit includes reliability/success probability estimate."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        if vulnerabilities := engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        ):
            exploit = engine.generate_exploit(vulnerabilities[0])

            assert isinstance(exploit, dict)

            reliability_keys = ["reliability", "success_probability", "confidence"]
            has_reliability = any(key in exploit for key in reliability_keys)

            if has_reliability:
                for key in reliability_keys:
                    if key in exploit:
                        value = exploit[key]
                        assert isinstance(value, (int, float))
                        if isinstance(value, float):
                            assert 0.0 <= value <= 1.0


class TestSymbolicConstraintSolving:
    """Test symbolic execution constraint solving capabilities."""

    def test_symbolic_state_tracks_constraints(self, vulnerable_test_binary: str) -> None:
        """Symbolic execution tracks path constraints during exploration."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(engine.path_constraints, list)

    def test_constraint_solving_for_license_validation_bypass(self, vulnerable_test_binary: str) -> None:
        """Symbolic execution can extract constraints for bypassing validation."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=30,
            timeout=90
        )

        result = engine.explore_from(
            start_address=0x1000,
            max_depth=20
        )

        assert isinstance(result, dict)

        if "constraints" in result and result["constraints"]:
            constraints = result["constraints"]
            assert isinstance(constraints, list)
            assert len(constraints) > 0


class TestSymbolicMemoryModeling:
    """Test symbolic memory state modeling capabilities."""

    def test_symbolic_engine_tracks_memory_states(self, vulnerable_test_binary: str) -> None:
        """Symbolic engine maintains memory state during execution."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "use_after_free"]
        )

        assert isinstance(vulnerabilities, list)

    def test_symbolic_engine_detects_heap_operations(self, vulnerable_test_binary: str) -> None:
        """Symbolic engine tracks heap allocations and frees."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["use_after_free", "double_free"]
        )

        assert isinstance(vulnerabilities, list)

        heap_vulns = [
            v for v in vulnerabilities
            if v.get("type") in ["use_after_free", "double_free", "heap_overflow"]
        ]
        assert isinstance(heap_vulns, list)


class TestSymbolicExecutionEdgeCases:
    """Test symbolic execution engine edge cases and error handling."""

    def test_symbolic_engine_handles_empty_binary_gracefully(self) -> None:
        """Symbolic engine handles empty or invalid binary files."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"")
            temp_path = f.name

        try:
            engine = SymbolicExecutionEngine(
                binary_path=temp_path,
                max_paths=10,
                timeout=30
            )

            vulnerabilities = engine.discover_vulnerabilities(
                vulnerability_types=["buffer_overflow"]
            )

            assert isinstance(vulnerabilities, list)

        finally:
            try:
                os.unlink(temp_path)
            except Exception:
                pass

    def test_symbolic_engine_handles_corrupted_pe_header(self) -> None:
        """Symbolic engine handles corrupted PE headers without crashing."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"MZ" + b"\x00" * 100 + b"PE\x00\x00" + b"\xFF" * 200)
            temp_path = f.name

        try:
            engine = SymbolicExecutionEngine(
                binary_path=temp_path,
                max_paths=10,
                timeout=30
            )

            vulnerabilities = engine.discover_vulnerabilities(
                vulnerability_types=["buffer_overflow"]
            )

            assert isinstance(vulnerabilities, list)

        finally:
            try:
                os.unlink(temp_path)
            except Exception:
                pass

    def test_symbolic_engine_handles_very_small_max_paths(self, minimal_pe_binary: str) -> None:
        """Symbolic engine handles very small max_paths parameter."""
        engine = SymbolicExecutionEngine(
            binary_path=minimal_pe_binary,
            max_paths=1,
            timeout=30
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(vulnerabilities, list)
        assert engine.max_paths == 1

    def test_symbolic_engine_handles_very_small_timeout(self, minimal_pe_binary: str) -> None:
        """Symbolic engine handles very small timeout parameter."""
        engine = SymbolicExecutionEngine(
            binary_path=minimal_pe_binary,
            max_paths=10,
            timeout=1
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(vulnerabilities, list)
        assert engine.timeout == 1

    def test_symbolic_engine_handles_empty_vulnerability_types(self, minimal_pe_binary: str) -> None:
        """Symbolic engine handles empty vulnerability types list."""
        engine = SymbolicExecutionEngine(
            binary_path=minimal_pe_binary,
            max_paths=10,
            timeout=30
        )

        vulnerabilities = engine.discover_vulnerabilities(vulnerability_types=[])

        assert isinstance(vulnerabilities, list)


class TestSymbolicExecutionRealWorldBinaries:
    """Test symbolic execution on real Windows system binaries."""

    def test_symbolic_analysis_notepad_returns_results(self, notepad_binary: str) -> None:
        """Symbolic analysis of notepad.exe completes and returns results."""
        engine = SymbolicExecutionEngine(
            binary_path=notepad_binary,
            max_paths=30,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow", "integer_overflow"]
        )

        assert isinstance(vulnerabilities, list)
        assert engine.binary_path == notepad_binary

    def test_symbolic_analysis_calc_returns_results(self, calc_binary: str) -> None:
        """Symbolic analysis of calc.exe completes and returns results."""
        engine = SymbolicExecutionEngine(
            binary_path=calc_binary,
            max_paths=30,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(vulnerabilities, list)
        assert engine.binary_path == calc_binary

    def test_symbolic_analysis_cmd_returns_results(self, cmd_binary: str) -> None:
        """Symbolic analysis of cmd.exe completes and returns results."""
        engine = SymbolicExecutionEngine(
            binary_path=cmd_binary,
            max_paths=25,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["command_injection", "buffer_overflow"]
        )

        assert isinstance(vulnerabilities, list)
        assert engine.binary_path == cmd_binary


class TestSymbolicExecutionIntegration:
    """Test symbolic execution integration with other components."""

    def test_symbolic_engine_coverage_tracking(self, vulnerable_test_binary: str) -> None:
        """Symbolic engine tracks code coverage during exploration."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(engine.coverage_data, dict)

    def test_symbolic_engine_maintains_execution_history(self, vulnerable_test_binary: str) -> None:
        """Symbolic engine maintains history of explored states."""
        engine = SymbolicExecutionEngine(
            binary_path=vulnerable_test_binary,
            max_paths=20,
            timeout=60
        )

        vulnerabilities = engine.discover_vulnerabilities(
            vulnerability_types=["buffer_overflow"]
        )

        assert isinstance(engine.completed_paths, list)
        assert isinstance(engine.crashed_states, list)

    def test_symbolic_engine_provides_angr_availability_flag(self, minimal_pe_binary: str) -> None:
        """Symbolic engine indicates whether angr is available."""
        engine = SymbolicExecutionEngine(
            binary_path=minimal_pe_binary,
            max_paths=10,
            timeout=30
        )

        assert hasattr(engine, "angr_available")
        assert isinstance(engine.angr_available, bool)
