"""Production tests for bypass_engine.py scope cleanup validation.

This module contains comprehensive tests that verify the complete removal of all
shell-related payload types and network exploitation capabilities from bypass_engine.py.

Tests MUST FAIL if any of the following are detected:
- REVERSE_SHELL or BIND_SHELL payload types in PayloadType enum
- Any shell-related generation methods or references
- Network exploitation capabilities beyond license server interaction
- Any code paths that could be used for general exploitation (non-licensing)

Copyright (C) 2025 Zachary Flint
Licensed under GNU GPL v3.0
"""

import ast
import inspect
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.bypass_engine import BypassEngine, PayloadType


class TestPayloadTypeScopeCleanup:
    """Validate PayloadType enum contains ONLY license bypass types."""

    def test_payload_type_enum_contains_no_shell_types(self) -> None:
        """PayloadType enum must NOT contain REVERSE_SHELL or BIND_SHELL."""
        enum_values = [pt.value for pt in PayloadType]
        enum_names = [pt.name for pt in PayloadType]

        assert "REVERSE_SHELL" not in enum_names, "REVERSE_SHELL found in PayloadType enum - SCOPE VIOLATION"
        assert "BIND_SHELL" not in enum_names, "BIND_SHELL found in PayloadType enum - SCOPE VIOLATION"
        assert "reverse_shell" not in enum_values, "reverse_shell value found in PayloadType enum - SCOPE VIOLATION"
        assert "bind_shell" not in enum_values, "bind_shell value found in PayloadType enum - SCOPE VIOLATION"

    def test_payload_type_enum_only_contains_license_bypass_types(self) -> None:
        """PayloadType enum must contain ONLY legitimate license bypass types."""
        expected_types = {
            "LICENSE_CHECK_BYPASS",
            "TRIAL_EXTENSION",
            "ACTIVATION_BYPASS",
            "SERIAL_VALIDATION_BYPASS",
            "HARDWARE_ID_SPOOF",
        }

        actual_names = {pt.name for pt in PayloadType}

        assert actual_names == expected_types, f"Unexpected payload types found: {actual_names - expected_types}"

    def test_payload_type_enum_values_match_expected_format(self) -> None:
        """PayloadType enum values must use snake_case license bypass naming."""
        expected_values = {
            "license_check_bypass",
            "trial_extension",
            "activation_bypass",
            "serial_validation_bypass",
            "hardware_id_spoof",
        }

        actual_values = {pt.value for pt in PayloadType}

        assert actual_values == expected_values, f"Unexpected payload type values: {actual_values - expected_values}"

    def test_payload_type_count_matches_expected(self) -> None:
        """PayloadType enum must contain exactly 5 license bypass types."""
        assert len(PayloadType) == 5, f"Expected 5 PayloadType members, found {len(PayloadType)}"

    def test_no_network_exploitation_payload_types(self) -> None:
        """PayloadType enum must NOT contain network exploitation types."""
        forbidden_keywords = [
            "shell",
            "reverse",
            "bind",
            "connect",
            "listener",
            "backdoor",
            "remote_exec",
            "command_execution",
            "rce",
        ]

        enum_names_lower = [pt.name.lower() for pt in PayloadType]
        enum_values_lower = [pt.value.lower() for pt in PayloadType]

        for keyword in forbidden_keywords:
            for name in enum_names_lower:
                assert keyword not in name, f"Forbidden keyword '{keyword}' found in PayloadType name: {name}"
            for value in enum_values_lower:
                assert keyword not in value, f"Forbidden keyword '{keyword}' found in PayloadType value: {value}"


class TestBypassEngineMethodScopeCleanup:
    """Validate BypassEngine class contains NO shell-related methods."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    def test_no_shell_generator_methods(self, engine: BypassEngine) -> None:
        """BypassEngine must NOT have reverse_shell or bind_shell generator methods."""
        method_names = [method for method in dir(engine) if not method.startswith("_")]

        forbidden_methods = [
            "generate_reverse_shell",
            "generate_bind_shell",
            "create_reverse_shell",
            "create_bind_shell",
            "_generate_reverse_shell",
            "_generate_bind_shell",
        ]

        for forbidden in forbidden_methods:
            assert forbidden not in method_names, f"Forbidden method '{forbidden}' found in BypassEngine"

    def test_no_private_shell_generator_methods(self, engine: BypassEngine) -> None:
        """BypassEngine must NOT have private shell generator methods."""
        all_methods = [method for method in dir(engine)]

        forbidden_patterns = ["reverse_shell", "bind_shell", "shell_code", "shellcode_gen"]

        for method_name in all_methods:
            for pattern in forbidden_patterns:
                if pattern in method_name.lower() and "license" not in method_name.lower():
                    pytest.fail(f"Suspicious method name containing '{pattern}': {method_name}")

    def test_generate_payload_rejects_shell_types(self, engine: BypassEngine) -> None:
        """generate_payload() must reject string names containing 'shell' keywords."""
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

        forbidden_strings = ["REVERSE_SHELL", "BIND_SHELL", "reverse_shell", "bind_shell", "shell"]

        for forbidden in forbidden_strings:
            result = engine.generate_payload(forbidden, "x64", target_info)

            assert result["payload_type"] == "license_check_bypass", (
                f"Engine accepted forbidden payload type '{forbidden}' " f"and generated: {result['payload_type']}"
            )

    def test_only_license_bypass_generators_exist(self, engine: BypassEngine) -> None:
        """BypassEngine must have generator methods ONLY for license bypass types."""
        expected_generators = {
            "_generate_license_check_bypass",
            "_generate_trial_extension",
            "_generate_activation_bypass",
            "_generate_serial_validation_bypass",
            "_generate_hardware_id_spoof",
        }

        actual_generators = {method for method in dir(engine) if method.startswith("_generate_") and callable(getattr(engine, method))}

        arch_specific_generators = {
            method for method in actual_generators if any(arch in method for arch in ["_x64_", "_x86_", "_arm64_", "_arm_"])
        }

        core_generators = actual_generators - arch_specific_generators

        assert core_generators == expected_generators, f"Unexpected generator methods: {core_generators - expected_generators}"


class TestBypassEngineSourceCodeCleanup:
    """Validate source code contains NO shell-related strings or references."""

    @pytest.fixture
    def source_path(self) -> Path:
        """Provide path to bypass_engine.py source file."""
        module_file = inspect.getfile(BypassEngine)
        return Path(module_file)

    @pytest.fixture
    def source_code(self, source_path: Path) -> str:
        """Read bypass_engine.py source code."""
        return source_path.read_text(encoding="utf-8")

    @pytest.fixture
    def ast_tree(self, source_code: str) -> ast.Module:
        """Parse source code into AST."""
        return ast.parse(source_code)

    def test_source_contains_no_reverse_shell_strings(self, source_code: str) -> None:
        """Source code must NOT contain 'REVERSE_SHELL' or 'reverse_shell' strings."""
        lines = source_code.split("\n")

        for line_num, line in enumerate(lines, 1):
            if "#" in line:
                code_part = line[: line.index("#")]
            else:
                code_part = line

            assert "REVERSE_SHELL" not in code_part, f"Found 'REVERSE_SHELL' at line {line_num}: {line.strip()}"
            assert "reverse_shell" not in code_part, f"Found 'reverse_shell' at line {line_num}: {line.strip()}"

    def test_source_contains_no_bind_shell_strings(self, source_code: str) -> None:
        """Source code must NOT contain 'BIND_SHELL' or 'bind_shell' strings."""
        lines = source_code.split("\n")

        for line_num, line in enumerate(lines, 1):
            if "#" in line:
                code_part = line[: line.index("#")]
            else:
                code_part = line

            assert "BIND_SHELL" not in code_part, f"Found 'BIND_SHELL' at line {line_num}: {line.strip()}"
            assert "bind_shell" not in code_part, f"Found 'bind_shell' at line {line_num}: {line.strip()}"

    def test_source_contains_no_netcat_references(self, source_code: str) -> None:
        """Source code must NOT contain netcat or nc references."""
        forbidden_terms = ["netcat", "/bin/nc", "nc -", "ncat"]

        lines = source_code.split("\n")
        for line_num, line in enumerate(lines, 1):
            if "#" in line:
                code_part = line[: line.index("#")]
            else:
                code_part = line

            for term in forbidden_terms:
                assert term not in code_part.lower(), f"Found forbidden term '{term}' at line {line_num}: {line.strip()}"

    def test_source_contains_no_socket_connect_calls(self, source_code: str) -> None:
        """Source code must NOT contain socket.connect() for reverse shell purposes."""
        forbidden_patterns = ["socket.connect(", "sock.connect(", "s.connect("]

        lines = source_code.split("\n")
        for line_num, line in enumerate(lines, 1):
            if "#" in line:
                code_part = line[: line.index("#")]
            else:
                code_part = line

            for pattern in forbidden_patterns:
                if pattern in code_part:
                    if "license" in code_part.lower() or "server" in code_part.lower():
                        continue
                    pytest.fail(f"Suspicious socket.connect() at line {line_num}: {line.strip()}")

    def test_ast_contains_no_shell_enum_members(self, ast_tree: ast.Module) -> None:
        """AST must NOT contain REVERSE_SHELL or BIND_SHELL enum assignments."""
        for node in ast.walk(ast_tree):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        if target.id in {"REVERSE_SHELL", "BIND_SHELL"}:
                            pytest.fail(f"Found forbidden enum member assignment: {target.id}")

    def test_ast_contains_no_shell_function_definitions(self, ast_tree: ast.Module) -> None:
        """AST must NOT contain function definitions with 'shell' in name."""
        forbidden_patterns = ["reverse_shell", "bind_shell", "create_shell", "gen_shell"]

        for node in ast.walk(ast_tree):
            if isinstance(node, ast.FunctionDef):
                for pattern in forbidden_patterns:
                    if pattern in node.name.lower():
                        pytest.fail(f"Found forbidden function definition: {node.name}")


class TestBypassEnginePayloadGeneration:
    """Validate payload generation produces ONLY license bypass payloads."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    @pytest.fixture
    def target_info(self) -> dict[str, Any]:
        """Provide standard target information for payload generation."""
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": ["aslr", "dep"],
            "av_products": ["Windows Defender"],
            "network_config": {"interface": "eth0"},
            "process_info": {"pid": 1234, "name": "target.exe"},
        }

    @pytest.mark.parametrize(
        "payload_type",
        [
            PayloadType.LICENSE_CHECK_BYPASS,
            PayloadType.TRIAL_EXTENSION,
            PayloadType.ACTIVATION_BYPASS,
            PayloadType.SERIAL_VALIDATION_BYPASS,
            PayloadType.HARDWARE_ID_SPOOF,
        ],
    )
    def test_generate_payload_produces_valid_output(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
        payload_type: PayloadType,
    ) -> None:
        """generate_payload() must produce valid output for all license bypass types."""
        result = engine.generate_payload(payload_type, "x64", target_info)

        assert "payload" in result, f"Missing 'payload' key for {payload_type.value}"
        assert "size" in result, f"Missing 'size' key for {payload_type.value}"
        assert "architecture" in result, f"Missing 'architecture' key for {payload_type.value}"
        assert "payload_type" in result, f"Missing 'payload_type' key for {payload_type.value}"

        assert isinstance(result["payload"], bytes), f"Payload is not bytes for {payload_type.value}"
        assert result["size"] > 0, f"Payload size is zero for {payload_type.value}"
        assert result["payload_type"] == payload_type.value, f"Payload type mismatch for {payload_type.value}"

    @pytest.mark.parametrize("arch", ["x64", "x86", "arm64", "arm"])
    def test_generated_payloads_contain_no_network_operations(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
        arch: str,
    ) -> None:
        """Generated payloads must NOT contain network operation shellcode."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, arch, target_info)

        payload = result["payload"]

        forbidden_syscall_patterns = {
            "x64": [
                b"\x0f\x05",
            ],
            "x86": [
                b"\xcd\x80",
            ],
            "arm64": [
                b"\x01\x00\x00\xd4",
            ],
            "arm": [
                b"\x00\x00\x00\xef",
            ],
        }

        if arch in forbidden_syscall_patterns:
            for pattern in forbidden_syscall_patterns[arch]:
                if pattern in payload:
                    disasm_hint = f"Syscall instruction {pattern.hex()} found in {arch} payload"
                    if len(payload) > 100:
                        pytest.fail(f"{disasm_hint} - possible network operations in large payload")

    def test_license_check_bypass_returns_success_value(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """LICENSE_CHECK_BYPASS payload must set return value to 1 (success)."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, "x64", target_info, {"return_value": 1})

        payload = result["payload"]

        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in payload or b"\xb8\x01\x00\x00\x00" in payload, (
            "x64 payload does not contain 'mov rax, 1' or 'mov eax, 1' instruction"
        )

    def test_trial_extension_returns_maximum_value(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """TRIAL_EXTENSION payload must set return value to maximum positive integer."""
        result = engine.generate_payload(PayloadType.TRIAL_EXTENSION, "x64", target_info)

        payload = result["payload"]

        assert b"\xff\xff\xff\x7f" in payload, "x64 payload does not contain maximum positive integer (0x7FFFFFFF)"

    def test_hardware_id_spoof_contains_spoofed_data(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """HARDWARE_ID_SPOOF payload must contain embedded spoofed hardware ID data."""
        spoofed_hwid = b"\xDE\xAD\xBE\xEF" * 4
        result = engine.generate_payload(
            PayloadType.HARDWARE_ID_SPOOF,
            "x64",
            target_info,
            {"spoofed_hwid": spoofed_hwid},
        )

        payload = result["payload"]

        assert spoofed_hwid in payload, "Spoofed hardware ID not found in payload"


class TestBypassEngineDocstringCompliance:
    """Validate docstrings explicitly state licensing-only scope."""

    @pytest.fixture
    def source_path(self) -> Path:
        """Provide path to bypass_engine.py source file."""
        module_file = inspect.getfile(BypassEngine)
        return Path(module_file)

    @pytest.fixture
    def source_code(self, source_path: Path) -> str:
        """Read bypass_engine.py source code."""
        return source_path.read_text(encoding="utf-8")

    def test_module_docstring_specifies_licensing_scope(self, source_code: str) -> None:
        """Module docstring must explicitly state licensing-only scope."""
        ast_tree = ast.parse(source_code)
        module_docstring = ast.get_docstring(ast_tree)

        assert module_docstring is not None, "Module docstring is missing"

        required_keywords = ["license", "bypass"]
        for keyword in required_keywords:
            assert keyword.lower() in module_docstring.lower(), f"Module docstring missing '{keyword}' keyword"

    def test_payload_type_enum_docstring_excludes_malware(self, source_code: str) -> None:
        """PayloadType enum docstring must explicitly exclude malware capabilities."""
        ast_tree = ast.parse(source_code)

        for node in ast.walk(ast_tree):
            if isinstance(node, ast.ClassDef) and node.name == "PayloadType":
                docstring = ast.get_docstring(node)
                assert docstring is not None, "PayloadType docstring is missing"

                forbidden_terms = ["shell", "malware", "exploit", "backdoor"]
                for term in forbidden_terms:
                    if term in docstring.lower() and "no" not in docstring.lower():
                        pytest.fail(f"PayloadType docstring contains '{term}' without explicit exclusion")

                assert "license" in docstring.lower() or "licensing" in docstring.lower(), (
                    "PayloadType docstring does not mention licensing"
                )

    def test_bypass_engine_class_docstring_specifies_scope(self, source_code: str) -> None:
        """BypassEngine class docstring must specify licensing-only scope."""
        ast_tree = ast.parse(source_code)

        for node in ast.walk(ast_tree):
            if isinstance(node, ast.ClassDef) and node.name == "BypassEngine":
                docstring = ast.get_docstring(node)
                assert docstring is not None, "BypassEngine docstring is missing"

                assert "license" in docstring.lower() or "licensing" in docstring.lower(), (
                    "BypassEngine docstring does not mention licensing scope"
                )

                assert "scope" in docstring.lower() or "exclusively" in docstring.lower(), (
                    "BypassEngine docstring does not explicitly state scope limitations"
                )


class TestBypassEngineNetworkCapabilityRestrictions:
    """Validate NO network exploitation capabilities exist."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    @pytest.fixture
    def target_info(self) -> dict[str, Any]:
        """Provide target information with network config."""
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {"interface": "eth0", "ip": "192.168.1.100"},
            "process_info": {},
        }

    def test_generate_payload_ignores_lhost_option(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """generate_payload() must ignore lhost option (no reverse shells)."""
        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            {"lhost": "192.168.1.50", "lport": 4444},
        )

        payload = result["payload"]

        ip_bytes = b"\xc0\xa8\x01\x32"
        assert ip_bytes not in payload, "Payload contains encoded IP address - possible reverse shell"

        port_bytes = b"\x11\x5c"
        assert port_bytes not in payload, "Payload contains encoded port 4444 - possible reverse shell"

    def test_generate_payload_ignores_lport_option(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """generate_payload() must ignore lport option (no bind shells)."""
        common_ports = [4444, 8080, 31337, 1337, 12345]

        for port in common_ports:
            result = engine.generate_payload(
                PayloadType.LICENSE_CHECK_BYPASS,
                "x64",
                target_info,
                {"lport": port},
            )

            payload = result["payload"]

            port_bytes_be = port.to_bytes(2, "big")
            port_bytes_le = port.to_bytes(2, "little")

            assert port_bytes_be not in payload and port_bytes_le not in payload, (
                f"Payload contains encoded port {port} - possible bind shell"
            )

    def test_no_socket_related_methods(self, engine: BypassEngine) -> None:
        """BypassEngine must NOT have socket-related helper methods."""
        forbidden_methods = [
            "create_socket",
            "connect_socket",
            "bind_socket",
            "listen_socket",
            "accept_connection",
            "send_data",
            "receive_data",
        ]

        all_methods = [method for method in dir(engine)]

        for forbidden in forbidden_methods:
            assert forbidden not in all_methods, f"Forbidden network method '{forbidden}' found in BypassEngine"


class TestBypassEngineRegressionPrevention:
    """Prevent regression by validating removed functionality stays removed."""

    @pytest.fixture
    def source_path(self) -> Path:
        """Provide path to bypass_engine.py source file."""
        module_file = inspect.getfile(BypassEngine)
        return Path(module_file)

    @pytest.fixture
    def source_code(self, source_path: Path) -> str:
        """Read bypass_engine.py source code."""
        return source_path.read_text(encoding="utf-8")

    def test_no_commented_out_shell_code(self, source_code: str) -> None:
        """Source must NOT contain commented-out shell-related code."""
        lines = source_code.split("\n")

        for line_num, line in enumerate(lines, 1):
            stripped = line.strip()
            if stripped.startswith("#") and not stripped.startswith('"""') and not stripped.startswith("'''"):
                comment = stripped.lstrip("#").strip()

                forbidden_in_comments = ["REVERSE_SHELL", "BIND_SHELL", "reverse_shell", "bind_shell"]

                for forbidden in forbidden_in_comments:
                    assert forbidden not in comment, (
                        f"Commented-out shell code found at line {line_num}: {line.strip()} "
                        f"- remove completely, do not comment out"
                    )

    def test_payload_generators_dict_has_no_shell_entries(self, source_code: str) -> None:
        """payload_generators dict must NOT contain shell-related entries."""
        ast_tree = ast.parse(source_code)

        for node in ast.walk(ast_tree):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id == "payload_generators":
                        if isinstance(node.value, ast.Dict):
                            for key in node.value.keys:
                                if isinstance(key, ast.Attribute):
                                    attr_name = key.attr
                                    assert attr_name not in {"REVERSE_SHELL", "BIND_SHELL"}, (
                                        f"payload_generators dict contains forbidden key: {attr_name}"
                                    )

    def test_line_count_within_expected_range(self, source_code: str) -> None:
        """Source file line count must be within expected range after cleanup."""
        lines = source_code.split("\n")
        line_count = len(lines)

        min_expected_lines = 500
        max_expected_lines = 700

        assert min_expected_lines <= line_count <= max_expected_lines, (
            f"Line count {line_count} outside expected range {min_expected_lines}-{max_expected_lines}. "
            f"Verify no shell-related code has been re-added or legitimate code removed."
        )

    def test_import_statements_do_not_include_socket(self, source_code: str) -> None:
        """Import statements must NOT include socket module."""
        ast_tree = ast.parse(source_code)

        for node in ast.walk(ast_tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    assert alias.name != "socket", "Found 'import socket' - potential network exploitation capability"

            if isinstance(node, ast.ImportFrom):
                assert node.module != "socket", "Found 'from socket import' - potential network exploitation capability"


class TestBypassEngineEdgeCaseHandling:
    """Validate edge cases and error handling for scope compliance."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    @pytest.fixture
    def target_info(self) -> dict[str, Any]:
        """Provide minimal target information."""
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

    def test_unknown_payload_type_defaults_to_license_bypass(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """Unknown payload type strings must default to LICENSE_CHECK_BYPASS."""
        unknown_types = ["UNKNOWN_TYPE", "INVALID", "MALWARE", "EXPLOIT", "PWNED"]

        for unknown in unknown_types:
            result = engine.generate_payload(unknown, "x64", target_info)

            assert result["payload_type"] == "license_check_bypass", (
                f"Unknown type '{unknown}' did not default to license_check_bypass, got: {result['payload_type']}"
            )

    def test_case_insensitive_payload_type_string_handling(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """Payload type strings must be case-insensitive and map correctly."""
        test_cases = [
            ("license_check_bypass", "license_check_bypass"),
            ("LICENSE_CHECK_BYPASS", "license_check_bypass"),
            ("LiCeNsE_ChEcK_ByPaSs", "license_check_bypass"),
        ]

        for input_type, expected_type in test_cases:
            result = engine.generate_payload(input_type, "x64", target_info)

            assert result["payload_type"] == expected_type, (
                f"Input '{input_type}' did not map to '{expected_type}', got: {result['payload_type']}"
            )

    def test_empty_options_dict_does_not_crash(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """generate_payload() must handle empty options dict gracefully."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, "x64", target_info, options={})

        assert "payload" in result
        assert isinstance(result["payload"], bytes)
        assert len(result["payload"]) > 0

    def test_none_options_defaults_to_empty_dict(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """generate_payload() must handle None options by defaulting to empty dict."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, "x64", target_info, options=None)

        assert "payload" in result
        assert isinstance(result["payload"], bytes)
        assert len(result["payload"]) > 0


class TestBypassEngineArchitectureSupport:
    """Validate architecture-specific payloads contain NO network code."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    @pytest.fixture
    def target_info(self) -> dict[str, Any]:
        """Provide minimal target information."""
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

    @pytest.mark.parametrize(
        "arch,expected_arch",
        [
            ("x64", "x64"),
            ("x86_64", "x86_64"),
            ("amd64", "amd64"),
            ("x86", "x86"),
            ("i386", "i386"),
            ("i686", "i686"),
            ("arm64", "arm64"),
            ("aarch64", "aarch64"),
            ("arm", "arm"),
            ("armv7", "armv7"),
        ],
    )
    def test_all_architectures_generate_license_bypass_only(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
        arch: str,
        expected_arch: str,
    ) -> None:
        """All supported architectures must generate license bypass payloads only."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, arch, target_info)

        assert result["payload_type"] == "license_check_bypass"
        assert result["architecture"] == expected_arch
        assert isinstance(result["payload"], bytes)
        assert len(result["payload"]) > 0

    @pytest.mark.parametrize("arch", ["x64", "x86", "arm64", "arm"])
    def test_architecture_payloads_are_position_independent(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
        arch: str,
    ) -> None:
        """Generated payloads must be position-independent (no absolute addresses)."""
        result = engine.generate_payload(PayloadType.LICENSE_CHECK_BYPASS, arch, target_info)

        payload = result["payload"]

        if arch in {"x64", "x86_64", "amd64"}:
            absolute_call_pattern = b"\xe8"
            if absolute_call_pattern in payload:
                call_indices = [i for i in range(len(payload)) if payload[i : i + 1] == absolute_call_pattern]
                for idx in call_indices:
                    if idx + 5 <= len(payload):
                        offset = int.from_bytes(payload[idx + 1 : idx + 5], "little", signed=True)
                        if offset > 0x10000 or offset < -0x10000:
                            pytest.fail(f"Large absolute call offset {offset:#x} at index {idx} in {arch} payload")


class TestBypassEngineOutputFormatCleanup:
    """Validate output formatting does not introduce shell code."""

    @pytest.fixture
    def engine(self) -> BypassEngine:
        """Provide BypassEngine instance for testing."""
        return BypassEngine()

    @pytest.fixture
    def target_info(self) -> dict[str, Any]:
        """Provide minimal target information."""
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

    @pytest.mark.parametrize("output_format", ["c", "python", "powershell", "exe", "dll", "raw"])
    def test_output_formats_produce_license_bypass_only(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
        output_format: str,
    ) -> None:
        """All output formats must produce license bypass payloads only."""
        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            {"output_format": output_format},
        )

        assert result["payload_type"] == "license_check_bypass"
        assert result["metadata"]["output_format"] == output_format

    def test_c_format_does_not_contain_socket_headers(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """C format output must NOT contain socket-related headers."""
        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            {"output_format": "c"},
        )

        payload_str = result["payload"].decode("utf-8")

        forbidden_headers = ["#include <sys/socket.h>", "#include <netinet/in.h>", "#include <winsock2.h>"]

        for header in forbidden_headers:
            assert header not in payload_str, f"C format output contains forbidden header: {header}"

    def test_python_format_does_not_contain_socket_imports(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """Python format output must NOT contain socket imports."""
        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            {"output_format": "python"},
        )

        payload_str = result["payload"].decode("utf-8")

        forbidden_imports = ["import socket", "from socket import"]

        for imp in forbidden_imports:
            assert imp not in payload_str, f"Python format output contains forbidden import: {imp}"

    def test_powershell_format_does_not_contain_reverse_shell(
        self,
        engine: BypassEngine,
        target_info: dict[str, Any],
    ) -> None:
        """PowerShell format output must NOT contain reverse shell code."""
        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            {"output_format": "powershell"},
        )

        payload_str = result["payload"].decode("utf-8")

        forbidden_cmdlets = [
            "New-Object System.Net.Sockets.TcpClient",
            "System.Net.Sockets.TCPClient",
            "New-Object Net.Sockets.TcpListener",
            "Start-Process cmd.exe",
        ]

        for cmdlet in forbidden_cmdlets:
            assert cmdlet not in payload_str, f"PowerShell format output contains forbidden cmdlet: {cmdlet}"
