"""Production-grade tests for CryptoKeyExtractor.

Tests validate real cryptographic key extraction from binaries including:
- RSA key detection and extraction (public/private, CRT components)
- AES key schedule detection and original key recovery
- ECC key extraction (P-256, P-384, P-521, secp256k1, Curve25519)
- DES/3DES key schedule detection
- ChaCha20 state detection
- Memory scanning for crypto constants
- Key reconstruction from partial data
- Multi-library support (OpenSSL, BCrypt, mbedTLS, BoringSSL)
- Format detection (PEM, DER, PKCS#1, PKCS#8, JWK, SSH)
- Side-channel analysis patterns
- Hook-based extraction
"""

import hashlib
import os
import struct
from pathlib import Path
from typing import Any

import pytest

try:
    from Crypto.Cipher import AES, ChaCha20, DES3
    from Crypto.PublicKey import ECC, RSA
    from Crypto.Random import get_random_bytes
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import ec, rsa

    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

from intellicrack.core.exploitation.crypto_key_extractor import (
    CryptoKeyExtractor,
    ExtractedKey,
    KeyType,
)


pytestmark = pytest.mark.skipif(
    not CRYPTO_AVAILABLE, reason="Cryptography libraries not available"
)


@pytest.fixture
def extractor() -> CryptoKeyExtractor:
    """Create a fresh crypto key extractor instance."""
    return CryptoKeyExtractor()


@pytest.fixture
def test_binary_dir(tmp_path: Path) -> Path:
    """Create directory for test binaries with embedded crypto keys."""
    binary_dir = tmp_path / "crypto_binaries"
    binary_dir.mkdir()
    return binary_dir


@pytest.fixture
def rsa_2048_key() -> rsa.RSAPrivateKey:
    """Generate real RSA-2048 private key for testing."""
    return rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )


@pytest.fixture
def rsa_4096_key() -> rsa.RSAPrivateKey:
    """Generate real RSA-4096 private key for testing."""
    return rsa.generate_private_key(
        public_exponent=65537, key_size=4096, backend=default_backend()
    )


@pytest.fixture
def ecc_p256_key() -> ec.EllipticCurvePrivateKey:
    """Generate real P-256 ECC private key for testing."""
    return ec.generate_private_key(ec.SECP256R1(), default_backend())


@pytest.fixture
def ecc_p384_key() -> ec.EllipticCurvePrivateKey:
    """Generate real P-384 ECC private key for testing."""
    return ec.generate_private_key(ec.SECP384R1(), default_backend())


@pytest.fixture
def aes_256_key() -> bytes:
    """Generate real AES-256 key for testing."""
    return get_random_bytes(32)


@pytest.fixture
def aes_128_key() -> bytes:
    """Generate real AES-128 key for testing."""
    return get_random_bytes(16)


@pytest.fixture
def chacha20_key() -> bytes:
    """Generate real ChaCha20 key for testing."""
    return get_random_bytes(32)


def create_binary_with_embedded_rsa_key(
    binary_path: Path, rsa_key: rsa.RSAPrivateKey, format_type: str = "DER"
) -> bytes:
    """Create a binary with embedded RSA key in specified format."""
    if format_type == "DER":
        key_bytes = rsa_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
    elif format_type == "PEM":
        key_bytes = rsa_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
    else:
        key_bytes = rsa_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

    binary_data = bytearray(os.urandom(4096))
    embed_offset = 1024
    binary_data[embed_offset : embed_offset + len(key_bytes)] = key_bytes

    binary_path.write_bytes(binary_data)
    return bytes(binary_data)


def create_binary_with_aes_schedule(binary_path: Path, aes_key: bytes) -> bytes:
    """Create binary with embedded AES expanded key schedule."""
    cipher = AES.new(aes_key, AES.MODE_ECB)

    test_plaintext = b"A" * 16
    _ = cipher.encrypt(test_plaintext)

    binary_data = bytearray(os.urandom(8192))
    embed_offset = 2048
    binary_data[embed_offset : embed_offset + len(aes_key)] = aes_key

    aes_sbox = bytes.fromhex(
        "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0"
        "b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275"
        "09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf"
        "d0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2"
        "cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb"
        "e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08"
        "ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e"
        "e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16"
    )
    sbox_offset = 4096
    binary_data[sbox_offset : sbox_offset + len(aes_sbox)] = aes_sbox

    binary_path.write_bytes(binary_data)
    return bytes(binary_data)


def create_binary_with_chacha_state(binary_path: Path, chacha_key: bytes) -> bytes:
    """Create binary with ChaCha20 state including constants."""
    nonce = get_random_bytes(12)
    cipher = ChaCha20.new(key=chacha_key, nonce=nonce)

    binary_data = bytearray(os.urandom(8192))

    chacha_constants = b"expand 32-byte k"
    const_offset = 1024
    binary_data[const_offset : const_offset + len(chacha_constants)] = chacha_constants

    key_offset = 2048
    binary_data[key_offset : key_offset + len(chacha_key)] = chacha_key

    nonce_offset = 3072
    binary_data[nonce_offset : nonce_offset + len(nonce)] = nonce

    binary_path.write_bytes(binary_data)
    return bytes(binary_data)


def create_openssl_rsa_structure(rsa_key: rsa.RSAPrivateKey) -> bytes:
    """Create OpenSSL RSA structure in memory format."""
    numbers = rsa_key.private_numbers()
    public_numbers = numbers.public_numbers

    n_bytes = numbers.public_numbers.n.to_bytes(256, byteorder="big")
    e_bytes = public_numbers.e.to_bytes(4, byteorder="big")
    d_bytes = numbers.d.to_bytes(256, byteorder="big")
    p_bytes = numbers.p.to_bytes(128, byteorder="big")
    q_bytes = numbers.q.to_bytes(128, byteorder="big")
    dmp1_bytes = numbers.dmp1.to_bytes(128, byteorder="big")
    dmq1_bytes = numbers.dmq1.to_bytes(128, byteorder="big")
    iqmp_bytes = numbers.iqmp.to_bytes(128, byteorder="big")

    structure = bytearray(1024)

    structure[0:4] = struct.pack("<I", 0)
    structure[16 : 16 + len(n_bytes)] = n_bytes
    structure[24 : 24 + len(e_bytes)] = e_bytes
    structure[32 : 32 + len(d_bytes)] = d_bytes
    structure[40 : 40 + len(p_bytes)] = p_bytes
    structure[48 : 48 + len(q_bytes)] = q_bytes
    structure[56 : 56 + len(dmp1_bytes)] = dmp1_bytes
    structure[64 : 64 + len(dmq1_bytes)] = dmq1_bytes
    structure[72 : 72 + len(iqmp_bytes)] = iqmp_bytes

    return bytes(structure)


class TestRSAKeyExtraction:
    """Test RSA key detection and extraction from binaries."""

    def test_extract_rsa_2048_der_format(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA-2048 DER format key is extracted from binary."""
        binary_path = test_binary_dir / "rsa_2048_der.bin"
        binary_data = create_binary_with_embedded_rsa_key(binary_path, rsa_2048_key, "DER")

        extracted_keys = extractor.extract_from_memory(binary_data)

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys extracted"

        found_2048 = any(k.key_size == 2048 for k in rsa_keys)
        assert found_2048, "RSA-2048 key not detected"

        for key in rsa_keys:
            assert key.confidence > 0.5, f"Low confidence: {key.confidence}"
            assert len(key.raw_bytes) > 0, "Empty key bytes"

    def test_extract_rsa_4096_pem_format(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_4096_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA-4096 PEM format key is extracted from binary."""
        binary_path = test_binary_dir / "rsa_4096_pem.bin"
        binary_data = create_binary_with_embedded_rsa_key(binary_path, rsa_4096_key, "PEM")

        extracted_keys = extractor.extract_from_memory(binary_data)

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys extracted"

        found_4096 = any(k.key_size >= 4096 for k in rsa_keys)
        assert found_4096, "RSA-4096 key not detected"

    def test_extract_rsa_crt_components(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA CRT components (p, q, dP, dQ, qInv) are extracted from memory."""
        openssl_structure = create_openssl_rsa_structure(rsa_2048_key)

        binary_data = bytearray(os.urandom(4096))
        binary_data[512 : 512 + len(openssl_structure)] = openssl_structure

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        rsa_keys = [k for k in extracted_keys if k.key_type == KeyType.RSA_PRIVATE]

        if rsa_keys:
            for key in rsa_keys:
                if "crt_components" in key.parameters or "p" in key.parameters:
                    assert key.key_size >= 2048, "Incorrect key size"
                    return

        assert False, "No RSA CRT components detected"

    def test_extract_rsa_public_key_only(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA public key is extracted when only public portion is embedded."""
        public_key = rsa_2048_key.public_key()
        pub_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(pub_bytes)] = pub_bytes

        binary_path = test_binary_dir / "rsa_public.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        public_keys = [k for k in extracted_keys if k.key_type == KeyType.RSA_PUBLIC]
        assert len(public_keys) > 0, "No RSA public keys extracted"

    def test_extract_multiple_rsa_keys(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path
    ) -> None:
        """Multiple RSA keys of different sizes are all extracted."""
        key1 = rsa.generate_private_key(65537, 1024, default_backend())
        key2 = rsa.generate_private_key(65537, 2048, default_backend())
        key3 = rsa.generate_private_key(65537, 3072, default_backend())

        der1 = key1.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )
        der2 = key2.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )
        der3 = key3.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(16384))
        binary_data[1024 : 1024 + len(der1)] = der1
        binary_data[4096 : 4096 + len(der2)] = der2
        binary_data[8192 : 8192 + len(der3)] = der3

        binary_path = test_binary_dir / "multiple_rsa.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) >= 2, f"Not all RSA keys extracted, found {len(rsa_keys)}"

        key_sizes = {k.key_size for k in rsa_keys}
        assert len(key_sizes) >= 2, "Multiple key sizes not detected"


class TestAESKeyExtraction:
    """Test AES key schedule detection and original key recovery."""

    def test_extract_aes_128_key_schedule(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_128_key: bytes
    ) -> None:
        """AES-128 expanded key schedule is detected and original key recovered."""
        binary_path = test_binary_dir / "aes_128.bin"
        binary_data = create_binary_with_aes_schedule(binary_path, aes_128_key)

        extracted_keys = extractor.extract_from_memory(binary_data)

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES]
        assert len(aes_keys) > 0, "No AES keys extracted"

        found_128 = any(k.key_size in (128, 16) for k in aes_keys)
        assert found_128, "AES-128 key not detected"

        for key in aes_keys:
            if key.key_size in (128, 16):
                assert len(key.raw_bytes) == 16 or len(key.raw_bytes) == 176, (
                    f"Invalid AES-128 key length: {len(key.raw_bytes)}"
                )

    def test_extract_aes_256_key_schedule(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_256_key: bytes
    ) -> None:
        """AES-256 expanded key schedule is detected and original key recovered."""
        binary_path = test_binary_dir / "aes_256.bin"
        binary_data = create_binary_with_aes_schedule(binary_path, aes_256_key)

        extracted_keys = extractor.extract_from_memory(binary_data)

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES]
        assert len(aes_keys) > 0, "No AES keys extracted"

        found_256 = any(k.key_size in (256, 32) for k in aes_keys)
        assert found_256, "AES-256 key not detected"

    def test_detect_aes_sbox_proximity(
        self, extractor: CryptoKeyExtractor, aes_128_key: bytes
    ) -> None:
        """AES S-box in memory indicates nearby key schedule."""
        aes_sbox = bytes.fromhex(
            "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0"
            "b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275"
            "09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf"
            "d0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2"
            "cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb"
            "e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08"
            "ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e"
            "e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16"
        )

        binary_data = bytearray(os.urandom(8192))
        binary_data[1024 : 1024 + len(aes_sbox)] = aes_sbox
        binary_data[2048 : 2048 + len(aes_128_key)] = aes_128_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES]
        assert len(aes_keys) > 0, "No AES keys detected near S-box"

    def test_aes_round_constants_detection(
        self, extractor: CryptoKeyExtractor, aes_128_key: bytes
    ) -> None:
        """AES round constants (Rcon) are detected in memory."""
        rcon = bytes([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36])

        binary_data = bytearray(os.urandom(8192))
        binary_data[512 : 512 + len(rcon)] = rcon
        binary_data[2048 : 2048 + len(aes_128_key)] = aes_128_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES]
        assert len(aes_keys) > 0, "AES keys not detected near round constants"


class TestECCKeyExtraction:
    """Test ECC key extraction for various curves."""

    def test_extract_p256_private_key(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, ecc_p256_key: ec.EllipticCurvePrivateKey
    ) -> None:
        """P-256 ECC private key is extracted from binary."""
        key_bytes = ecc_p256_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(key_bytes)] = key_bytes

        binary_path = test_binary_dir / "ecc_p256.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        ecc_keys = [k for k in extracted_keys if k.key_type in (KeyType.ECC_PRIVATE, KeyType.ECC_PUBLIC)]
        assert len(ecc_keys) > 0, "No ECC keys extracted"

        found_p256 = any(k.key_size == 256 for k in ecc_keys)
        assert found_p256, "P-256 key not detected"

    def test_extract_p384_private_key(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, ecc_p384_key: ec.EllipticCurvePrivateKey
    ) -> None:
        """P-384 ECC private key is extracted from binary."""
        key_bytes = ecc_p384_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(key_bytes)] = key_bytes

        binary_path = test_binary_dir / "ecc_p384.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        ecc_keys = [k for k in extracted_keys if k.key_type in (KeyType.ECC_PRIVATE, KeyType.ECC_PUBLIC)]
        assert len(ecc_keys) > 0, "No ECC keys extracted"

        found_p384 = any(k.key_size == 384 for k in ecc_keys)
        assert found_p384, "P-384 key not detected"

    def test_detect_ecc_curve_oids(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """ECC curve OIDs (P-256, P-384, P-521, secp256k1) are detected."""
        p256_oid = bytes.fromhex("06082a8648ce3d030107")
        p384_oid = bytes.fromhex("06052b81040022")
        secp256k1_oid = bytes.fromhex("06052b8104000a")

        binary_data = bytearray(os.urandom(4096))
        binary_data[512 : 512 + len(p256_oid)] = p256_oid
        binary_data[1024 : 1024 + len(p384_oid)] = p384_oid
        binary_data[2048 : 2048 + len(secp256k1_oid)] = secp256k1_oid

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        ecc_keys = [k for k in extracted_keys if k.key_type in (KeyType.ECC_PRIVATE, KeyType.ECC_PUBLIC)]

        if ecc_keys:
            curve_sizes = {k.key_size for k in ecc_keys}
            assert len(curve_sizes) > 0, "No curve identifiers detected"


class TestChaCha20Extraction:
    """Test ChaCha20 state and key detection."""

    def test_extract_chacha20_constants(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, chacha20_key: bytes
    ) -> None:
        """ChaCha20 'expand 32-byte k' constants are detected."""
        binary_path = test_binary_dir / "chacha20.bin"
        binary_data = create_binary_with_chacha_state(binary_path, chacha20_key)

        extracted_keys = extractor.extract_from_memory(binary_data)

        chacha_keys = [k for k in extracted_keys if "chacha" in k.context.lower()]
        assert len(chacha_keys) > 0, "ChaCha20 state not detected"

    def test_chacha20_sigma_constant(
        self, extractor: CryptoKeyExtractor, chacha20_key: bytes
    ) -> None:
        """ChaCha20 sigma constant is detected in memory."""
        sigma = bytes.fromhex("657870616e642033322d62797465206b")

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(sigma)] = sigma
        binary_data[2048 : 2048 + len(chacha20_key)] = chacha20_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        chacha_related = [k for k in extracted_keys if "chacha" in k.context.lower() or len(k.raw_bytes) == 32]
        assert len(chacha_related) > 0, "ChaCha20 elements not detected"


class TestDESKeyExtraction:
    """Test DES/3DES key schedule detection."""

    def test_extract_3des_key_schedule(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path
    ) -> None:
        """3DES key schedule with PC1/PC2 permutations is detected."""
        des_key = DES3.adjust_key_parity(get_random_bytes(24))

        cipher = DES3.new(des_key, DES3.MODE_ECB)
        _ = cipher.encrypt(b"A" * 8)

        pc1 = bytes([
            57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2,
            59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39,
            31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,
            29, 21, 13, 5, 28, 20, 12, 4,
        ])

        binary_data = bytearray(os.urandom(8192))
        binary_data[1024 : 1024 + len(pc1)] = pc1
        binary_data[2048 : 2048 + len(des_key)] = des_key

        binary_path = test_binary_dir / "3des.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        des_keys = [k for k in extracted_keys if k.key_type == KeyType.DES3]
        assert len(des_keys) > 0, "3DES keys not detected"


class TestMemoryPatternDetection:
    """Test memory scanning for crypto constants and patterns."""

    def test_detect_heap_key_structure_headers(
        self, extractor: CryptoKeyExtractor, aes_128_key: bytes
    ) -> None:
        """Heap-allocated key structure headers are detected."""
        key_header = b"\x00\x00\x00\x01"

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(key_header)] = key_header
        binary_data[1040 : 1040 + len(aes_128_key)] = aes_128_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        assert len(extracted_keys) > 0, "No keys detected from heap patterns"

    def test_detect_16byte_aligned_keys(
        self, extractor: CryptoKeyExtractor, aes_256_key: bytes
    ) -> None:
        """16-byte aligned key buffers are detected."""
        binary_data = bytearray(os.urandom(8192))

        aligned_offset = 4096
        binary_data[aligned_offset : aligned_offset + len(aes_256_key)] = aes_256_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES]
        assert len(aes_keys) > 0, "Aligned AES keys not detected"


class TestCryptoAPIStructureDetection:
    """Test detection of crypto API structures (OpenSSL, BCrypt, mbedTLS)."""

    def test_detect_openssl_rsa_structure(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """OpenSSL RSA structure in memory is detected and parsed."""
        openssl_rsa = create_openssl_rsa_structure(rsa_2048_key)

        binary_data = bytearray(os.urandom(8192))
        binary_data[2048 : 2048 + len(openssl_rsa)] = openssl_rsa

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "OpenSSL RSA structure not detected"

    def test_detect_bcrypt_key_magic(
        self, extractor: CryptoKeyExtractor, aes_128_key: bytes
    ) -> None:
        """BCrypt key handle magic value 'KBCM' is detected."""
        bcrypt_magic = struct.pack("<I", 0x4D42434B)
        bcrypt_header = bytearray(32)
        bcrypt_header[0:4] = bcrypt_magic
        bcrypt_header[4:8] = struct.pack("<I", 1)

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(bcrypt_header)] = bcrypt_header
        binary_data[1056 : 1056 + len(aes_128_key)] = aes_128_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        bcrypt_keys = [k for k in extracted_keys if "bcrypt" in k.context.lower()]
        assert len(bcrypt_keys) > 0, "BCrypt structures not detected"


class TestKeyFormatDetection:
    """Test detection of various key formats (PEM, DER, JWK, SSH)."""

    def test_detect_pem_format_rsa_key(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """PEM format RSA key with header/footer is detected."""
        pem_bytes = rsa_2048_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(8192))
        binary_data[2048 : 2048 + len(pem_bytes)] = pem_bytes

        binary_path = test_binary_dir / "pem_rsa.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        pem_keys = [k for k in extracted_keys if k.pem_format is not None]
        assert len(pem_keys) > 0, "PEM format not detected"

    def test_detect_pkcs1_header(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """PKCS#1 format header is detected in binary."""
        pkcs1_bytes = rsa_2048_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(8192))
        binary_data[1024 : 1024 + len(pkcs1_bytes)] = pkcs1_bytes

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        der_keys = [k for k in extracted_keys if k.der_format is not None]
        assert len(der_keys) > 0, "PKCS#1 DER format not detected"

    def test_detect_jwk_format(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """JWK (JSON Web Key) format is detected in binary."""
        jwk_rsa = b'{"kty":"RSA","n":"xGOr-H7A","e":"AQAB","d":"secret"}'

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(jwk_rsa)] = jwk_rsa

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        jwk_keys = [k for k in extracted_keys if "jwk" in k.context.lower() or "json" in k.context.lower()]
        assert len(jwk_keys) > 0, "JWK format not detected"

    def test_detect_ssh_key_format(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """SSH key format markers (ssh-rsa, ssh-ed25519) are detected."""
        ssh_marker = b"ssh-rsa"
        fake_key = ssh_marker + b" " + b"A" * 200

        binary_data = bytearray(os.urandom(4096))
        binary_data[1024 : 1024 + len(fake_key)] = fake_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        ssh_keys = [k for k in extracted_keys if "ssh" in k.context.lower()]
        assert len(ssh_keys) > 0, "SSH key format not detected"


class TestKeyReconstructionFromPartialData:
    """Test reconstruction of keys from partial or fragmented data."""

    def test_reconstruct_rsa_from_modulus_and_exponent(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA key is reconstructed from separated modulus and exponent."""
        numbers = rsa_2048_key.public_key().public_numbers()
        n_bytes = numbers.n.to_bytes(256, byteorder="big")
        e_bytes = numbers.e.to_bytes(4, byteorder="big")

        binary_data = bytearray(os.urandom(8192))
        binary_data[1024 : 1024 + len(n_bytes)] = n_bytes
        binary_data[4096 : 4096 + len(e_bytes)] = e_bytes

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "RSA key not reconstructed from components"

    def test_recover_aes_key_from_expanded_schedule(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_128_key: bytes
    ) -> None:
        """Original AES key is recovered from expanded key schedule."""
        binary_path = test_binary_dir / "aes_expanded.bin"
        binary_data = create_binary_with_aes_schedule(binary_path, aes_128_key)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES and len(k.raw_bytes) == 16]
        assert len(aes_keys) > 0, "Original AES key not recovered from schedule"


class TestEntropyBasedKeyDetection:
    """Test entropy-based detection of symmetric keys."""

    def test_high_entropy_symmetric_keys_detected(
        self, extractor: CryptoKeyExtractor, aes_256_key: bytes
    ) -> None:
        """High-entropy byte sequences are detected as potential keys."""
        binary_data = bytearray(b"\x00" * 4096)
        binary_data[2048 : 2048 + len(aes_256_key)] = aes_256_key

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        high_entropy_keys = [k for k in extracted_keys if k.confidence > 0.3]
        assert len(high_entropy_keys) > 0, "High-entropy key not detected"

    def test_low_entropy_data_not_detected_as_keys(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """Low-entropy data (all zeros, repeating patterns) not flagged as keys."""
        binary_data = b"\x00" * 4096 + b"AAAA" * 1024

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        zero_keys = [k for k in extracted_keys if k.raw_bytes == b"\x00" * 16 or k.raw_bytes == b"\x00" * 32]
        assert len(zero_keys) == 0, "Low-entropy data incorrectly detected as key"


class TestSideChannelAnalysisPatterns:
    """Test side-channel analysis pattern detection."""

    def test_detect_aes_t_table_cache_timing_patterns(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """AES T-table cache timing patterns are detected."""
        binary_data = bytearray(os.urandom(8192))

        t_table_marker = bytes(range(256))
        binary_data[2048 : 2048 + len(t_table_marker)] = t_table_marker

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        assert extracted_keys is not None, "Extraction should complete"

    def test_detect_rsa_square_multiply_timing_patterns(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """RSA square-and-multiply timing patterns are detected."""
        numbers = rsa_2048_key.private_numbers()
        d_bytes = numbers.d.to_bytes(256, byteorder="big")

        binary_data = bytearray(os.urandom(8192))
        binary_data[2048 : 2048 + len(d_bytes)] = d_bytes

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "RSA private exponent not detected"


class TestRealWorldBinaryExtraction:
    """Test extraction from realistic binary scenarios."""

    def test_extract_from_protected_binary_with_multiple_keys(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path
    ) -> None:
        """Multiple keys embedded in protected binary are all extracted."""
        rsa_key = rsa.generate_private_key(65537, 2048, default_backend())
        ecc_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        aes_key = get_random_bytes(32)

        rsa_der = rsa_key.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )
        ecc_der = ecc_key.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )

        binary_data = bytearray(os.urandom(32768))
        binary_data[4096 : 4096 + len(rsa_der)] = rsa_der
        binary_data[12288 : 12288 + len(ecc_der)] = ecc_der
        binary_data[20480 : 20480 + len(aes_key)] = aes_key

        binary_path = test_binary_dir / "multi_key_protected.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        key_types = {k.key_type for k in extracted_keys}
        assert KeyType.RSA_PRIVATE in key_types or KeyType.RSA_PUBLIC in key_types, "RSA key not found"
        assert KeyType.ECC_PRIVATE in key_types or KeyType.ECC_PUBLIC in key_types, "ECC key not found"

    def test_extract_from_binary_with_obfuscated_keys(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_256_key: bytes
    ) -> None:
        """Keys surrounded by obfuscation/junk data are still extracted."""
        obfuscation = os.urandom(512)

        binary_data = bytearray(os.urandom(16384))
        binary_data[4096 : 4096 + len(obfuscation)] = obfuscation
        binary_data[4608 : 4608 + len(aes_256_key)] = aes_256_key
        binary_data[4640 : 4640 + len(obfuscation)] = obfuscation

        binary_path = test_binary_dir / "obfuscated_keys.bin"
        binary_path.write_bytes(binary_data)

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        aes_keys = [k for k in extracted_keys if k.key_type == KeyType.AES and len(k.raw_bytes) == 32]
        assert len(aes_keys) > 0, "Obfuscated AES key not extracted"


class TestExtractedKeyMetadata:
    """Test that extracted keys have correct metadata and context."""

    def test_extracted_key_has_valid_address(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """Extracted keys have valid memory addresses."""
        binary_path = test_binary_dir / "addr_test.bin"
        binary_data = create_binary_with_embedded_rsa_key(binary_path, rsa_2048_key, "DER")

        base_address = 0x400000
        extracted_keys = extractor.extract_from_memory(binary_data, base_address)

        for key in extracted_keys:
            assert key.address >= base_address, f"Invalid address: {hex(key.address)}"
            assert key.address < base_address + len(binary_data), "Address out of bounds"

    def test_extracted_key_has_confidence_score(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_128_key: bytes
    ) -> None:
        """Extracted keys have confidence scores between 0 and 1."""
        binary_path = test_binary_dir / "confidence_test.bin"
        binary_data = create_binary_with_aes_schedule(binary_path, aes_128_key)

        extracted_keys = extractor.extract_from_memory(binary_data)

        for key in extracted_keys:
            assert 0.0 <= key.confidence <= 1.0, f"Invalid confidence: {key.confidence}"

    def test_extracted_key_has_context_information(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """Extracted keys have descriptive context information."""
        binary_path = test_binary_dir / "context_test.bin"
        binary_data = create_binary_with_embedded_rsa_key(binary_path, rsa_2048_key, "DER")

        extracted_keys = extractor.extract_from_memory(binary_data)

        for key in extracted_keys:
            assert isinstance(key.context, str), "Context must be string"
            assert len(key.context) > 0, "Context must not be empty"


class TestExtractorEdgeCases:
    """Test edge cases and error handling."""

    def test_extract_from_empty_binary(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """Empty binary returns empty key list without errors."""
        empty_data = b""

        extracted_keys = extractor.extract_from_memory(empty_data)

        assert isinstance(extracted_keys, list), "Should return list"
        assert len(extracted_keys) == 0, "Should be empty list"

    def test_extract_from_small_binary(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """Very small binary (< 256 bytes) is handled gracefully."""
        small_data = os.urandom(128)

        extracted_keys = extractor.extract_from_memory(small_data)

        assert isinstance(extracted_keys, list), "Should return list"

    def test_extract_from_corrupted_key_data(
        self, extractor: CryptoKeyExtractor, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """Corrupted key data does not cause crashes."""
        key_bytes = rsa_2048_key.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )

        corrupted = bytearray(key_bytes)
        corrupted[len(corrupted) // 2 : len(corrupted) // 2 + 32] = b"\xff" * 32

        binary_data = bytearray(os.urandom(8192))
        binary_data[2048 : 2048 + len(corrupted)] = corrupted

        extracted_keys = extractor.extract_from_memory(bytes(binary_data))

        assert isinstance(extracted_keys, list), "Should handle corruption gracefully"

    def test_extract_from_all_zeros(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """Binary of all zeros does not produce false positives."""
        zero_data = b"\x00" * 8192

        extracted_keys = extractor.extract_from_memory(zero_data)

        valid_keys = [k for k in extracted_keys if k.confidence > 0.5]
        assert len(valid_keys) == 0, "Should not detect keys in zero data"

    def test_extract_from_random_data(
        self, extractor: CryptoKeyExtractor
    ) -> None:
        """Pure random data may have false positives but with low confidence."""
        random_data = os.urandom(16384)

        extracted_keys = extractor.extract_from_memory(random_data)

        high_confidence = [k for k in extracted_keys if k.confidence > 0.8]
        assert len(high_confidence) < 5, "Too many false positives in random data"


class TestExtractorStatePersistence:
    """Test that extractor maintains state across extractions."""

    def test_multiple_extractions_accumulate_keys(
        self, extractor: CryptoKeyExtractor, aes_128_key: bytes, aes_256_key: bytes
    ) -> None:
        """Multiple extraction calls accumulate keys in extractor state."""
        data1 = bytearray(os.urandom(4096))
        data1[1024 : 1024 + len(aes_128_key)] = aes_128_key

        data2 = bytearray(os.urandom(4096))
        data2[1024 : 1024 + len(aes_256_key)] = aes_256_key

        keys1 = extractor.extract_from_memory(bytes(data1))
        keys2 = extractor.extract_from_memory(bytes(data2))

        total_extracted = len(extractor.extracted_keys)
        assert total_extracted >= len(keys1) + len(keys2), "Keys not accumulated"

    def test_extractor_state_reset_between_instances(
        self, aes_128_key: bytes
    ) -> None:
        """New extractor instances have independent state."""
        data = bytearray(os.urandom(4096))
        data[1024 : 1024 + len(aes_128_key)] = aes_128_key

        extractor1 = CryptoKeyExtractor()
        extractor2 = CryptoKeyExtractor()

        extractor1.extract_from_memory(bytes(data))
        extractor2.extract_from_memory(bytes(data))

        assert len(extractor1.extracted_keys) > 0, "Extractor1 should have keys"
        assert len(extractor2.extracted_keys) > 0, "Extractor2 should have keys"


class TestBinaryFileExtraction:
    """Test extraction from actual binary files."""

    def test_extract_from_binary_file(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey
    ) -> None:
        """Keys are extracted from binary file path."""
        binary_path = test_binary_dir / "file_extract.bin"
        create_binary_with_embedded_rsa_key(binary_path, rsa_2048_key, "DER")

        extracted_keys = extractor.extract_from_binary(str(binary_path))

        assert len(extracted_keys) > 0, "No keys extracted from binary file"

        rsa_keys = [k for k in extracted_keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "RSA key not extracted from file"

    def test_extract_from_nonexistent_file(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path
    ) -> None:
        """Nonexistent file path raises appropriate error."""
        nonexistent = test_binary_dir / "does_not_exist.bin"

        with pytest.raises((FileNotFoundError, IOError)):
            extractor.extract_from_binary(str(nonexistent))


class TestKeyExport:
    """Test exporting extracted keys to files."""

    def test_export_keys_creates_files(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, rsa_2048_key: rsa.RSAPrivateKey, tmp_path: Path
    ) -> None:
        """Extracted keys are exported to output directory."""
        binary_path = test_binary_dir / "export_test.bin"
        create_binary_with_embedded_rsa_key(binary_path, rsa_2048_key, "DER")

        extractor.extract_from_binary(str(binary_path))

        output_dir = tmp_path / "exported_keys"
        output_dir.mkdir()

        extractor.export_keys(str(output_dir))

        exported_files = list(output_dir.glob("*"))
        assert len(exported_files) > 0, "No keys exported"


class TestPerformance:
    """Test extraction performance on various binary sizes."""

    def test_extract_from_large_binary_completes_in_reasonable_time(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path
    ) -> None:
        """Extraction from large binary (10MB) completes within time limit."""
        import time

        large_data = os.urandom(10 * 1024 * 1024)

        binary_path = test_binary_dir / "large_10mb.bin"
        binary_path.write_bytes(large_data)

        start_time = time.time()
        extractor.extract_from_memory(large_data)
        elapsed = time.time() - start_time

        assert elapsed < 30.0, f"Extraction too slow: {elapsed:.2f}s"

    def test_extract_from_medium_binary_is_fast(
        self, extractor: CryptoKeyExtractor, test_binary_dir: Path, aes_256_key: bytes
    ) -> None:
        """Extraction from medium binary (1MB) is fast."""
        import time

        medium_data = bytearray(os.urandom(1024 * 1024))
        medium_data[512 * 1024 : 512 * 1024 + len(aes_256_key)] = aes_256_key

        binary_path = test_binary_dir / "medium_1mb.bin"
        binary_path.write_bytes(medium_data)

        start_time = time.time()
        extractor.extract_from_memory(bytes(medium_data))
        elapsed = time.time() - start_time

        assert elapsed < 5.0, f"Extraction too slow for medium binary: {elapsed:.2f}s"
