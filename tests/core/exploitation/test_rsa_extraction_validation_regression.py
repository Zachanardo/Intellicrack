"""Regression tests for RSA key extraction and validation functionality.

This module contains comprehensive regression tests verifying that the RSA key
extraction and validation capabilities in RSAKeyValidator continue to work correctly.
These tests validate against real cryptographic operations and actual binary formats
to ensure no functionality is lost during refactoring or updates.

Target: intellicrack.core.exploitation.keygen_generator.py:1577-1599
  - extract_rsa_keys() method and all extraction sub-methods
  - RSA public key (n, e) extraction from target binaries
  - RSA signature verification against extracted keys
  - Key structure validation (modulus size 1024/2048/4096)
  - Padding scheme detection (RSA-PSS, PKCS#1 v1.5)
"""

from __future__ import annotations

import struct
import tempfile
from pathlib import Path

import pytest

try:
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding, rsa
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from cryptography.x509 import CertificateBuilder

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    CRYPTOGRAPHY_AVAILABLE = False

from intellicrack.core.exploitation.keygen_generator import (
    KeyAlgorithmType,
    RSAKeyValidator,
    RSAPaddingScheme,
    RSAPublicKeyInfo,
    ValidationAlgorithm,
)

TEST_BINARIES_DIR = Path(__file__).parent.parent.parent / "test_binaries"
WINDOWS_SYSTEM32 = Path(r"C:\Windows\System32")


@pytest.fixture
def temp_binary_pem_2048() -> Path:
    """Create temporary binary with 2048-bit RSA key in PEM format."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for key generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_key = private_key.public_key()

    pem_data = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\x00" * 256 + pem_data + b"\xFF" * 256)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_der_4096() -> Path:
    """Create temporary binary with 4096-bit RSA key in DER format."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for key generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=4096, backend=default_backend()
    )
    public_key = private_key.public_key()

    der_data = public_key.public_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    with tempfile.NamedTemporaryFile(delete=False, suffix=".dll") as f:
        f.write(b"\xCC" * 128 + der_data + b"\x90" * 128)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_x509_1024() -> Path:
    """Create temporary binary with 1024-bit RSA key in X.509 certificate."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for certificate generation")

    from datetime import datetime, timedelta, timezone

    from cryptography import x509
    from cryptography.x509.oid import NameOID

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=1024, backend=default_backend()
    )

    subject = issuer = x509.Name(
        [
            x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "TestSoftware Inc"),
            x509.NameAttribute(NameOID.COMMON_NAME, "license.test.local"),
        ]
    )

    cert = (
        CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(private_key.public_key())
        .serial_number(12345)
        .not_valid_before(datetime.now(timezone.utc))
        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=730))
        .sign(private_key, hashes.SHA256(), default_backend())
    )

    pem_cert = cert.public_bytes(serialization.Encoding.PEM)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\x90" * 200 + pem_cert + b"\xAA" * 200)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_raw_components_2048() -> Path:
    """Create temporary binary with raw RSA modulus and exponent (2048-bit)."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for key generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_numbers = private_key.public_key().public_numbers()

    modulus_bytes = public_numbers.n.to_bytes(256, byteorder="big")
    exponent_bytes = struct.pack(">I", public_numbers.e)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\x00" * 150 + modulus_bytes + b"\x00" * 100 + exponent_bytes + b"\xFF" * 150)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_cryptoapi_2048() -> Path:
    """Create temporary binary with Windows CryptoAPI RSA structure (2048-bit)."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for key generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_numbers = private_key.public_key().public_numbers()

    magic = b"RSA1"
    bitlen = struct.pack("<I", 2048)
    pubexp = struct.pack("<I", public_numbers.e)
    modulus_bytes_le = public_numbers.n.to_bytes(256, byteorder="little")

    cryptoapi_blob = magic + bitlen + pubexp + modulus_bytes_le

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\x00" * 80 + cryptoapi_blob + b"\xFF" * 80)
        temp_path = Path(f.name)

    yield temp_path
    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_signed_pkcs1_sha256() -> tuple[Path, bytes, bytes]:
    """Create binary with RSA key and PKCS#1 v1.5 SHA-256 signed message.

    Returns:
        Tuple of (binary_path, message, signature)
    """
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for signature generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend()
    )
    public_key = private_key.public_key()

    pem_data = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    message = b"PRODUCTKEY-ABCD1234-EFGH5678-IJKL9012"
    signature = private_key.sign(message, padding.PKCS1v15(), hashes.SHA256())

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\x00" * 128 + pem_data + b"\x00" * 128)
        temp_path = Path(f.name)

    yield temp_path, message, signature

    temp_path.unlink(missing_ok=True)


@pytest.fixture
def temp_binary_signed_pss_sha512() -> tuple[Path, bytes, bytes]:
    """Create binary with RSA key and RSA-PSS SHA-512 signed message.

    Returns:
        Tuple of (binary_path, message, signature)
    """
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required for signature generation")

    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=4096, backend=default_backend()
    )
    public_key = private_key.public_key()

    pem_data = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    message = b"SERIALNUMBER-9876543210-ZYXWVUTSRQPONMLKJIHGFEDCBA"
    signature = private_key.sign(
        message,
        padding.PSS(mgf=padding.MGF1(hashes.SHA512()), salt_length=padding.PSS.MAX_LENGTH),
        hashes.SHA512(),
    )

    with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
        f.write(b"\xFF" * 256 + pem_data + b"\x00" * 256)
        temp_path = Path(f.name)

    yield temp_path, message, signature

    temp_path.unlink(missing_ok=True)


class TestRegressionExtractRSAKeysMethod:
    """Regression tests for extract_rsa_keys() main method (lines 1572-1601)."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extract_rsa_keys_returns_list(self, temp_binary_pem_2048: Path) -> None:
        """extract_rsa_keys() returns list of RSAPublicKeyInfo objects."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        assert isinstance(keys, list)
        assert all(isinstance(k, RSAPublicKeyInfo) for k in keys)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extract_rsa_keys_caches_results(self, temp_binary_pem_2048: Path) -> None:
        """extract_rsa_keys() caches results on first call."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))

        keys1 = validator.extract_rsa_keys()
        keys2 = validator.extract_rsa_keys()

        assert keys1 is keys2, "Results not cached, returns different list objects"
        assert validator.extracted_keys == keys1

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extract_rsa_keys_calls_all_extraction_methods(
        self, temp_binary_pem_2048: Path
    ) -> None:
        """extract_rsa_keys() calls all extraction sub-methods."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0, "No keys extracted - extraction methods not called"
        assert any(k.format_type == "PEM" for k in keys), "PEM extraction not called"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extract_rsa_keys_checks_weakness_for_all_keys(
        self, temp_binary_pem_2048: Path
    ) -> None:
        """extract_rsa_keys() calls _check_key_weakness() for all keys (line 1597-1598)."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        for key in keys:
            assert isinstance(key.is_weak, bool), "Weakness not checked"
            if key.is_weak:
                assert key.weakness_reason is not None

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extract_rsa_keys_handles_empty_binary(self) -> None:
        """extract_rsa_keys() returns empty list for binary with no keys."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 2048)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert keys == []
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionPEMKeyExtraction:
    """Regression tests for _extract_pem_keys() method."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_standard_pem_public_key(self, temp_binary_pem_2048: Path) -> None:
        """Extracts RSA public key from '-----BEGIN PUBLIC KEY-----' PEM block."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        pem_keys = [k for k in keys if k.format_type == "PEM"]
        assert len(pem_keys) > 0, "Failed to extract PEM RSA public key"

        key = pem_keys[0]
        assert key.modulus > 0
        assert key.exponent == 65537
        assert key.key_size == 2048

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_rsa_specific_pem_format(self) -> None:
        """Extracts RSA key from '-----BEGIN RSA PUBLIC KEY-----' format."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography required")

        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_data = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x90" * 100 + pem_data + b"\x90" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) > 0, "Failed to extract RSA-specific PEM format"
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_pem_extraction_sets_correct_address(self, temp_binary_pem_2048: Path) -> None:
        """PEM extraction sets correct byte offset address in binary."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        pem_keys = [k for k in keys if k.format_type == "PEM"]
        assert len(pem_keys) > 0

        key = pem_keys[0]
        binary_data = temp_binary_pem_2048.read_bytes()
        assert key.address >= 0
        assert key.address < len(binary_data)

        marker = b"-----BEGIN PUBLIC KEY-----"
        assert marker in binary_data[key.address : key.address + 100]

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_pem_extraction_includes_pem_and_der_formats(
        self, temp_binary_pem_2048: Path
    ) -> None:
        """PEM extraction populates both pem_format and der_format fields."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        pem_keys = [k for k in keys if k.format_type == "PEM"]
        assert len(pem_keys) > 0

        key = pem_keys[0]
        assert key.pem_format is not None
        assert "-----BEGIN PUBLIC KEY-----" in key.pem_format
        assert "-----END PUBLIC KEY-----" in key.pem_format
        assert key.der_format is not None
        assert isinstance(key.der_format, bytes)


class TestRegressionDERKeyExtraction:
    """Regression tests for _extract_der_keys() method."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_der_encoded_rsa_key(self, temp_binary_der_4096: Path) -> None:
        """Extracts RSA public key from DER-encoded data."""
        validator = RSAKeyValidator(str(temp_binary_der_4096))
        keys = validator.extract_rsa_keys()

        der_keys = [k for k in keys if k.format_type == "DER"]
        assert len(der_keys) > 0, "Failed to extract DER RSA key"

        key = der_keys[0]
        assert key.key_size == 4096
        assert key.exponent == 65537
        assert key.modulus > 0

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_der_extraction_searches_by_oid(self, temp_binary_der_4096: Path) -> None:
        """DER extraction locates keys using RSA encryption OID."""
        validator = RSAKeyValidator(str(temp_binary_der_4096))
        binary_data = validator._load_binary_data()

        rsa_oid = bytes.fromhex("06092a864886f70d010101")
        assert rsa_oid in binary_data, "Test binary missing RSA OID"

        keys = validator.extract_rsa_keys()
        der_keys = [k for k in keys if k.format_type == "DER"]
        assert len(der_keys) > 0

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_der_extraction_includes_pem_conversion(self, temp_binary_der_4096: Path) -> None:
        """DER extraction converts key to PEM format."""
        validator = RSAKeyValidator(str(temp_binary_der_4096))
        keys = validator.extract_rsa_keys()

        der_keys = [k for k in keys if k.format_type == "DER"]
        assert len(der_keys) > 0

        key = der_keys[0]
        assert key.pem_format is not None
        assert "-----BEGIN PUBLIC KEY-----" in key.pem_format


class TestRegressionX509CertificateExtraction:
    """Regression tests for _extract_x509_certificates() method."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_rsa_key_from_x509_pem_cert(self, temp_binary_x509_1024: Path) -> None:
        """Extracts RSA key from PEM-encoded X.509 certificate."""
        validator = RSAKeyValidator(str(temp_binary_x509_1024))
        keys = validator.extract_rsa_keys()

        x509_keys = [k for k in keys if "X509" in k.format_type]
        assert len(x509_keys) > 0, "Failed to extract RSA key from X.509 certificate"

        key = x509_keys[0]
        assert key.key_size == 1024
        assert key.source == "x509_certificate"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_rsa_key_from_x509_der_cert(self) -> None:
        """Extracts RSA key from DER-encoded X.509 certificate."""
        from datetime import datetime, timedelta, timezone

        from cryptography import x509
        from cryptography.x509.oid import NameOID

        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        subject = issuer = x509.Name(
            [
                x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Test Corp"),
                x509.NameAttribute(NameOID.COMMON_NAME, "test.local"),
            ]
        )

        cert = (
            CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(private_key.public_key())
            .serial_number(99999)
            .not_valid_before(datetime.now(timezone.utc))
            .not_valid_after(datetime.now(timezone.utc) + timedelta(days=365))
            .sign(private_key, hashes.SHA256(), default_backend())
        )

        der_cert = cert.public_bytes(serialization.Encoding.DER)

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 200 + der_cert + b"\xFF" * 200)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            x509_keys = [k for k in keys if "X509" in k.format_type]
            assert len(x509_keys) > 0, "Failed to extract RSA key from DER X.509 cert"

            key = x509_keys[0]
            assert key.key_size == 2048
            assert key.source in ["x509_certificate", "x509_certificate_der"]
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionRawModulusExponentExtraction:
    """Regression tests for _extract_raw_modulus_exponent() method."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_raw_modulus_and_exponent(
        self, temp_binary_raw_components_2048: Path
    ) -> None:
        """Extracts RSA key from raw modulus and exponent bytes."""
        validator = RSAKeyValidator(str(temp_binary_raw_components_2048))
        keys = validator.extract_rsa_keys()

        raw_keys = [k for k in keys if k.format_type == "RAW"]
        assert len(raw_keys) > 0, "Failed to extract raw RSA modulus/exponent"

        key = raw_keys[0]
        assert key.key_size == 2048
        assert key.exponent == 65537
        assert key.source == "raw_modulus_exponent"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_raw_extraction_validates_modulus_size(
        self, temp_binary_raw_components_2048: Path
    ) -> None:
        """Raw extraction validates modulus matches key size."""
        validator = RSAKeyValidator(str(temp_binary_raw_components_2048))
        keys = validator.extract_rsa_keys()

        raw_keys = [k for k in keys if k.format_type == "RAW"]
        assert len(raw_keys) > 0

        key = raw_keys[0]
        modulus_bits = key.modulus.bit_length()
        assert modulus_bits >= key.key_size - 8
        assert modulus_bits <= key.key_size

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_raw_extraction_searches_common_exponents(
        self, temp_binary_raw_components_2048: Path
    ) -> None:
        """Raw extraction searches for common RSA exponents."""
        validator = RSAKeyValidator(str(temp_binary_raw_components_2048))
        keys = validator.extract_rsa_keys()

        raw_keys = [k for k in keys if k.format_type == "RAW"]
        assert len(raw_keys) > 0

        key = raw_keys[0]
        assert key.exponent in RSAKeyValidator.COMMON_EXPONENTS


class TestRegressionCryptoAPIKeyExtraction:
    """Regression tests for _extract_cryptoapi_keys() method."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_windows_cryptoapi_rsa_key(
        self, temp_binary_cryptoapi_2048: Path
    ) -> None:
        """Extracts RSA key from Windows CryptoAPI PUBLICKEYSTRUC."""
        validator = RSAKeyValidator(str(temp_binary_cryptoapi_2048))
        keys = validator.extract_rsa_keys()

        cryptoapi_keys = [k for k in keys if k.format_type == "CRYPTOAPI"]
        assert len(cryptoapi_keys) > 0, "Failed to extract CryptoAPI RSA key"

        key = cryptoapi_keys[0]
        assert key.key_size == 2048
        assert key.exponent == 65537
        assert key.source == "windows_cryptoapi"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_cryptoapi_extraction_handles_rsa1_magic(
        self, temp_binary_cryptoapi_2048: Path
    ) -> None:
        """CryptoAPI extraction recognizes RSA1 magic bytes."""
        binary_data = temp_binary_cryptoapi_2048.read_bytes()
        assert b"RSA1" in binary_data

        validator = RSAKeyValidator(str(temp_binary_cryptoapi_2048))
        keys = validator.extract_rsa_keys()

        cryptoapi_keys = [k for k in keys if k.format_type == "CRYPTOAPI"]
        assert len(cryptoapi_keys) > 0

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_cryptoapi_extraction_reverses_little_endian_modulus(
        self, temp_binary_cryptoapi_2048: Path
    ) -> None:
        """CryptoAPI extraction correctly handles little-endian modulus."""
        validator = RSAKeyValidator(str(temp_binary_cryptoapi_2048))
        keys = validator.extract_rsa_keys()

        cryptoapi_keys = [k for k in keys if k.format_type == "CRYPTOAPI"]
        assert len(cryptoapi_keys) > 0

        key = cryptoapi_keys[0]
        assert key.modulus > 0
        assert key.modulus.bit_length() >= key.key_size - 8


class TestRegressionKeyStructureValidation:
    """Regression tests for RSA key structure validation."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    @pytest.mark.parametrize("key_size", [1024, 2048, 4096])
    def test_validates_standard_key_sizes(self, key_size: int) -> None:
        """Validates RSA keys of standard sizes (1024/2048/4096 bits)."""
        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=key_size, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_data = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 64 + pem_data + b"\x00" * 64)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) > 0, f"Failed to extract {key_size}-bit key"
            assert keys[0].key_size == key_size
            assert keys[0].modulus.bit_length() >= key_size - 8
            assert keys[0].modulus.bit_length() <= key_size
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_validates_modulus_coprime_with_exponent(
        self, temp_binary_pem_2048: Path
    ) -> None:
        """Validates that GCD(n, e) = 1 (modulus and exponent are coprime)."""
        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        keys = validator.extract_rsa_keys()

        assert len(keys) > 0
        key = keys[0]

        gcd = validator._gcd(key.modulus, key.exponent)
        assert gcd == 1, f"Modulus and exponent not coprime: GCD = {gcd}"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_detects_weak_key_size(self) -> None:
        """Detects RSA keys with weak key sizes (< 1024 bits)."""
        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=512, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_data = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 50 + pem_data + b"\x00" * 50)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) > 0
            key = keys[0]
            assert key.is_weak is True
            assert "too small" in key.weakness_reason.lower()
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionPaddingSchemeDetection:
    """Regression tests for RSA padding scheme detection."""

    def test_detects_pkcs1_v1_5_padding_from_strings(self) -> None:
        """Detects PKCS#1 v1.5 padding from validation algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "RSA_PKCS1_PADDING"],
            crypto_operations=["RSA_verify"],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            padding_scheme = validator.detect_padding_scheme(algorithm)

            assert padding_scheme == RSAPaddingScheme.PKCS1_V1_5
        finally:
            temp_path.unlink(missing_ok=True)

    def test_detects_pss_padding_from_operations(self) -> None:
        """Detects RSA-PSS padding from crypto operations."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x2000,
            instructions=[],
            constants=[],
            strings=["RSASSA-PSS"],
            crypto_operations=["RSA_PSS_VERIFY", "MGF1"],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            padding_scheme = validator.detect_padding_scheme(algorithm)

            assert padding_scheme == RSAPaddingScheme.PSS
        finally:
            temp_path.unlink(missing_ok=True)

    def test_detects_oaep_padding(self) -> None:
        """Detects OAEP padding scheme."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x3000,
            instructions=[],
            constants=[],
            strings=["OAEP", "RSA_OAEP"],
            crypto_operations=[],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            padding_scheme = validator.detect_padding_scheme(algorithm)

            assert padding_scheme == RSAPaddingScheme.OAEP
        finally:
            temp_path.unlink(missing_ok=True)

    def test_defaults_to_pkcs1_v1_5_when_unknown(self) -> None:
        """Defaults to PKCS#1 v1.5 when padding cannot be determined."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x4000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            padding_scheme = validator.detect_padding_scheme(algorithm)

            assert padding_scheme == RSAPaddingScheme.PKCS1_V1_5
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionHashAlgorithmDetection:
    """Regression tests for hash algorithm detection."""

    @pytest.mark.parametrize(
        "hash_name,expected",
        [
            ("SHA512", "SHA512"),
            ("SHA-512", "SHA512"),
            ("SHA384", "SHA384"),
            ("SHA-384", "SHA384"),
            ("SHA256", "SHA256"),
            ("SHA-256", "SHA256"),
            ("SHA224", "SHA224"),
            ("SHA-224", "SHA224"),
            ("SHA1", "SHA1"),
            ("SHA-1", "SHA1"),
            ("MD5", "MD5"),
        ],
    )
    def test_detects_various_hash_algorithms(self, hash_name: str, expected: str) -> None:
        """Detects various hash algorithms from algorithm strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x5000,
            instructions=[],
            constants=[],
            strings=[hash_name],
            crypto_operations=[f"HASH_{hash_name}"],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            detected = validator.detect_hash_algorithm(algorithm)

            assert detected == expected
        finally:
            temp_path.unlink(missing_ok=True)

    def test_defaults_to_sha256_when_unknown(self) -> None:
        """Defaults to SHA-256 when hash algorithm cannot be determined."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x6000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            hash_alg = validator.detect_hash_algorithm(algorithm)

            assert hash_alg == "SHA256"
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionRSASignatureVerification:
    """Regression tests for RSA signature verification with extracted keys."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_verifies_valid_pkcs1_sha256_signature(
        self, temp_binary_signed_pkcs1_sha256: tuple[Path, bytes, bytes]
    ) -> None:
        """Verifies valid PKCS#1 v1.5 SHA-256 RSA signature."""
        binary_path, message, signature = temp_binary_signed_pkcs1_sha256

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x7000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_VERIFY"],
        )

        validator = RSAKeyValidator(str(binary_path))
        license_key = (message + signature).hex().upper()
        result = validator.validate_license_key(license_key, algorithm)

        assert result is True, "Failed to verify valid PKCS#1 v1.5 SHA-256 signature"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_rejects_invalid_signature(
        self, temp_binary_signed_pkcs1_sha256: tuple[Path, bytes, bytes]
    ) -> None:
        """Rejects invalid RSA signature."""
        binary_path, _, _ = temp_binary_signed_pkcs1_sha256

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x8000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_VERIFY"],
        )

        validator = RSAKeyValidator(str(binary_path))
        invalid_license = "INVALID-KEY-NO-SIGNATURE"
        result = validator.validate_license_key(invalid_license, algorithm)

        assert result is False, "Incorrectly validated invalid signature"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_verifies_valid_pss_sha512_signature(
        self, temp_binary_signed_pss_sha512: tuple[Path, bytes, bytes]
    ) -> None:
        """Verifies valid RSA-PSS SHA-512 signature."""
        binary_path, message, signature = temp_binary_signed_pss_sha512

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x9000,
            instructions=[],
            constants=[],
            strings=["PSS", "SHA512"],
            crypto_operations=["RSA_PSS_VERIFY"],
        )

        validator = RSAKeyValidator(str(binary_path))
        license_key = (message + signature).hex().upper()
        result = validator.validate_license_key(license_key, algorithm)

        assert result is True, "Failed to verify valid RSA-PSS SHA-512 signature"

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_signature_verification_fails_without_keys(self) -> None:
        """Signature verification fails when no keys extracted."""
        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 512)
            temp_path = Path(f.name)

        try:
            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0xA000,
                instructions=[],
                constants=[],
                strings=["PKCS1", "SHA256"],
                crypto_operations=[],
            )

            validator = RSAKeyValidator(str(temp_path))
            result = validator.validate_license_key("TEST-LICENSE-KEY", algorithm)

            assert result is False, "Should fail when no keys available"
        finally:
            temp_path.unlink(missing_ok=True)


class TestRegressionRealWorldBinaries:
    """Regression tests against real Windows system binaries and test binaries."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_keys_from_crypt32_dll(self) -> None:
        """Extracts RSA keys from Windows crypt32.dll if available."""
        crypt32_path = WINDOWS_SYSTEM32 / "crypt32.dll"
        if not crypt32_path.exists():
            pytest.skip(
                f"Windows crypt32.dll not found at {crypt32_path}. "
                "This test requires Windows system DLLs for real-world validation."
            )

        validator = RSAKeyValidator(str(crypt32_path))
        keys = validator.extract_rsa_keys()

        if len(keys) > 0:
            for key in keys:
                assert isinstance(key, RSAPublicKeyInfo)
                assert key.key_size in [1024, 2048, 3072, 4096]
                assert key.modulus > 0
                assert key.exponent > 0

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_keys_from_test_binaries(self) -> None:
        """Extracts RSA keys from test binaries in tests/test_binaries/."""
        if not TEST_BINARIES_DIR.exists():
            pytest.skip(
                f"Test binaries directory not found at {TEST_BINARIES_DIR}. "
                "Place protected commercial binaries (.exe, .dll) in tests/test_binaries/ "
                "for comprehensive validation testing."
            )

        all_binaries = list(TEST_BINARIES_DIR.rglob("*.exe")) + list(
            TEST_BINARIES_DIR.rglob("*.dll")
        )

        if not all_binaries:
            pytest.skip(
                "No test binaries (*.exe, *.dll) found in tests/test_binaries/. "
                "Add protected commercial software binaries for regression testing."
            )

        extraction_count = 0
        for binary_path in all_binaries:
            if binary_path.stat().st_size > 50 * 1024 * 1024:
                continue

            validator = RSAKeyValidator(str(binary_path))
            keys = validator.extract_rsa_keys()

            if len(keys) > 0:
                extraction_count += 1
                for key in keys:
                    assert key.key_size in [1024, 2048, 3072, 4096]
                    assert key.modulus > 0

        assert extraction_count >= 0


class TestRegressionEdgeCases:
    """Regression tests for edge cases and error handling."""

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_handles_corrupted_pem_data(self) -> None:
        """Handles corrupted PEM data without crashing."""
        corrupted_pem = b"-----BEGIN PUBLIC KEY-----\nCORRUPTED_DATA_NOT_BASE64\n-----END PUBLIC KEY-----"

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 100 + corrupted_pem + b"\x00" * 100)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert isinstance(keys, list)
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_handles_truncated_der_data(self) -> None:
        """Handles truncated DER data gracefully."""
        rsa_oid = bytes.fromhex("06092a864886f70d010101")
        truncated_der = rsa_oid + b"\x00" * 20

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\xFF" * 80 + truncated_der)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert isinstance(keys, list)
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_extracts_multiple_keys_from_same_binary(self) -> None:
        """Extracts multiple RSA keys when binary contains several."""
        key1 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        key2 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        pem1 = key1.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        pem2 = key2.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as f:
            f.write(b"\x00" * 150 + pem1 + b"\xFF" * 150 + pem2 + b"\x00" * 150)
            temp_path = Path(f.name)

        try:
            validator = RSAKeyValidator(str(temp_path))
            keys = validator.extract_rsa_keys()

            assert len(keys) >= 2, "Failed to extract multiple RSA keys from binary"
        finally:
            temp_path.unlink(missing_ok=True)

    @pytest.mark.skipif(not CRYPTOGRAPHY_AVAILABLE, reason="cryptography library required")
    def test_handles_non_hex_license_key_input(self, temp_binary_pem_2048: Path) -> None:
        """Handles non-hexadecimal license key strings."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0xB000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=[],
        )

        validator = RSAKeyValidator(str(temp_binary_pem_2048))
        result = validator.validate_license_key("ABCD-1234-EFGH-5678", algorithm)

        assert isinstance(result, bool)
