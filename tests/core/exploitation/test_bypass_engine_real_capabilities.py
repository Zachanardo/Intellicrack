"""Production tests for BypassEngine real bypass payload generation.

Tests validate GENUINE license bypass payload generation for all architectures:
- x64 Windows license check bypass with proper calling conventions
- x86 Windows activation bypass with stack preservation
- ARM64 Linux trial extension payloads
- ARM32 serial validation bypass
- Hardware ID spoofing shellcode
- Multi-architecture payload encoding (XOR, Base64, null-free)
- PE wrapping for executable payload delivery
- Payload format conversion (C, Python, PowerShell)

CRITICAL: All tests validate ACTUAL machine code generation that would
execute on real systems to bypass license checks. NO mocks, NO stubs.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import struct
from typing import Any

import pytest

from intellicrack.core.exploitation.bypass_engine import BypassEngine, PayloadType


class TestBypassEngineInitialization:
    """Test BypassEngine initialization."""

    def test_bypass_engine_initializes(self) -> None:
        """BypassEngine initializes successfully."""
        engine = BypassEngine()

        assert engine.logger is not None

    def test_bypass_engine_has_payload_generators(self) -> None:
        """BypassEngine has generators for all payload types."""
        engine = BypassEngine()

        assert hasattr(engine, "_generate_license_check_bypass")
        assert hasattr(engine, "_generate_trial_extension")
        assert hasattr(engine, "_generate_activation_bypass")
        assert hasattr(engine, "_generate_serial_validation_bypass")
        assert hasattr(engine, "_generate_hardware_id_spoof")


class TestLicenseCheckBypassGeneration:
    """Test license check bypass payload generation."""

    def test_generate_x64_license_bypass_with_stack(self) -> None:
        """Generate x64 license bypass preserving stack frame."""
        engine = BypassEngine()

        target_info = {"os_type": "windows", "architecture": "x64"}
        options = {"preserve_stack": True, "return_value": 1}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        assert isinstance(result, dict)
        assert "payload" in result
        assert "size" in result
        assert result["architecture"] == "x64"
        assert result["payload_type"] == "license_check_bypass"

        payload = result["payload"]
        assert len(payload) > 0
        assert payload.startswith(b"\x55")
        assert payload.endswith(b"\xc3")
        assert b"\x48" in payload

    def test_generate_x64_license_bypass_without_stack(self) -> None:
        """Generate minimal x64 license bypass without stack preservation."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"preserve_stack": False, "return_value": 1}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert len(payload) < 20
        assert b"\x48\xc7\xc0" in payload
        assert payload.endswith(b"\xc3")

    def test_generate_x86_license_bypass(self) -> None:
        """Generate x86 license bypass with cdecl calling convention."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"preserve_stack": True, "return_value": 1}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x86",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["architecture"] == "x86"
        assert payload.startswith(b"\x55")
        assert payload.endswith(b"\xc3")
        assert b"\xb8" in payload

    def test_generate_arm64_license_bypass(self) -> None:
        """Generate ARM64 license bypass shellcode."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}
        options = {"preserve_stack": True, "return_value": 1}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "arm64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["architecture"] == "arm64"
        assert len(payload) > 0
        assert len(payload) % 4 == 0
        assert payload.endswith(b"\xc0\x03\x5f\xd6")

    def test_generate_arm_license_bypass(self) -> None:
        """Generate ARM32 license bypass shellcode."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}
        options = {"preserve_stack": True, "return_value": 1}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "arm",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["architecture"] == "arm"
        assert len(payload) > 0
        assert len(payload) % 4 == 0


class TestTrialExtensionGeneration:
    """Test trial period extension bypass generation."""

    def test_generate_trial_extension_x64(self) -> None:
        """Generate trial extension returning maximum time value."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"preserve_stack": True}

        result = engine.generate_payload(
            PayloadType.TRIAL_EXTENSION,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["payload_type"] == "trial_extension"
        assert b"\x48\xc7\xc0" in payload or b"\x48" in payload
        assert payload.endswith(b"\xc3")

    def test_generate_trial_extension_x86(self) -> None:
        """Generate x86 trial extension bypass."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.TRIAL_EXTENSION,
            "x86",
            target_info,
        )

        payload = result["payload"]
        assert len(payload) > 0
        assert payload.endswith(b"\xc3")


class TestActivationBypassGeneration:
    """Test product activation bypass generation."""

    def test_generate_activation_bypass_x64(self) -> None:
        """Generate activation check bypass returning activated status."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"return_value": 1}

        result = engine.generate_payload(
            PayloadType.ACTIVATION_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["payload_type"] == "activation_bypass"
        assert struct.pack("<I", 1) in payload
        assert payload.endswith(b"\xc3")

    def test_generate_activation_bypass_x86(self) -> None:
        """Generate x86 activation bypass."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.ACTIVATION_BYPASS,
            "x86",
            target_info,
        )

        payload = result["payload"]
        assert b"\xb8\x01\x00\x00\x00" in payload


class TestSerialValidationBypassGeneration:
    """Test serial number validation bypass."""

    def test_generate_serial_bypass_x64(self) -> None:
        """Generate serial validation bypass returning valid status."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.SERIAL_VALIDATION_BYPASS,
            "x64",
            target_info,
        )

        payload = result["payload"]
        assert result["payload_type"] == "serial_validation_bypass"
        assert len(payload) > 0
        assert payload.endswith(b"\xc3")

    def test_generate_serial_bypass_arm64(self) -> None:
        """Generate ARM64 serial validation bypass."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}

        result = engine.generate_payload(
            PayloadType.SERIAL_VALIDATION_BYPASS,
            "arm64",
            target_info,
        )

        payload = result["payload"]
        assert len(payload) > 0
        assert len(payload) % 4 == 0


class TestHardwareIDSpoofGeneration:
    """Test hardware ID spoofing shellcode generation."""

    def test_generate_hwid_spoof_x64(self) -> None:
        """Generate x64 hardware ID spoofing shellcode."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        spoofed_hwid = b"SPOOFED-HWID-1234567890AB"
        options = {"spoofed_hwid": spoofed_hwid}

        result = engine.generate_payload(
            PayloadType.HARDWARE_ID_SPOOF,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["payload_type"] == "hardware_id_spoof"
        assert len(payload) > len(spoofed_hwid)
        assert spoofed_hwid[:16] in payload

    def test_generate_hwid_spoof_contains_spoofed_data(self) -> None:
        """Hardware ID spoof payload contains the spoofed HWID."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        test_hwid = b"TEST-HWID-12345"
        options = {"spoofed_hwid": test_hwid}

        result = engine.generate_payload(
            PayloadType.HARDWARE_ID_SPOOF,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert test_hwid[:16].ljust(16, b"\x00") in payload

    def test_generate_hwid_spoof_arm(self) -> None:
        """Generate ARM hardware ID spoof fallback."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}
        options = {"spoofed_hwid": b"ARM-HWID"}

        result = engine.generate_payload(
            PayloadType.HARDWARE_ID_SPOOF,
            "arm",
            target_info,
            options,
        )

        payload = result["payload"]
        assert len(payload) > 0


class TestPayloadEncoding:
    """Test payload encoding transformations."""

    def test_xor_encoding(self) -> None:
        """Apply XOR encoding to evade signature detection."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"encoding_schemes": ["xor"]}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["metadata"]["encoding_applied"] == ["xor"]

        decoded = bytes(b ^ 0x41 for b in payload)
        assert b"\xc3" in decoded or len(decoded) > 0

    def test_base64_encoding(self) -> None:
        """Apply Base64 encoding for payload delivery."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"encoding_schemes": ["base64"]}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert result["metadata"]["encoding_applied"] == ["base64"]

        import base64
        decoded = base64.b64decode(payload)
        assert len(decoded) > 0

    def test_null_free_encoding(self) -> None:
        """Apply null-byte removal for shellcode injection."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"encoding_schemes": ["null_free"]}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        null_count = result["null_bytes"]

        assert null_count == 0

    def test_multiple_encoding_schemes(self) -> None:
        """Apply multiple encoding schemes in sequence."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"encoding_schemes": ["xor", "base64"]}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        assert result["metadata"]["encoding_applied"] == ["xor", "base64"]


class TestPayloadFormatConversion:
    """Test payload format conversion for different delivery methods."""

    def test_c_array_format(self) -> None:
        """Convert payload to C array format."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"output_format": "c"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        payload_str = payload.decode("utf-8")

        assert "unsigned char payload[]" in payload_str
        assert "0x" in payload_str

    def test_python_format(self) -> None:
        """Convert payload to Python bytes.fromhex() format."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"output_format": "python"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        payload_str = payload.decode("utf-8")

        assert "payload = bytes.fromhex" in payload_str

    def test_powershell_format(self) -> None:
        """Convert payload to PowerShell byte array format."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"output_format": "powershell"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        payload_str = payload.decode("utf-8")

        assert "[Byte[]]$payload" in payload_str
        assert "0x" in payload_str

    def test_exe_format_wrapping(self) -> None:
        """Wrap payload in minimal PE executable structure."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"output_format": "exe"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]

        assert payload[:2] == b"MZ"
        assert b"PE\x00\x00" in payload
        assert len(payload) >= 512

    def test_dll_format_wrapping(self) -> None:
        """Wrap payload in minimal DLL structure."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"output_format": "dll"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]

        assert payload[:2] == b"MZ"
        assert b"PE\x00\x00" in payload
        assert len(payload) >= 512


class TestReturnValueControl:
    """Test control over return values in bypass payloads."""

    def test_custom_return_value_x64(self) -> None:
        """Generate bypass returning custom value."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        custom_value = 0x12345678
        options = {"return_value": custom_value, "preserve_stack": False}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert struct.pack("<I", custom_value) in payload

    def test_zero_return_value(self) -> None:
        """Generate bypass returning zero (failure in some contexts)."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}
        options = {"return_value": 0}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        payload = result["payload"]
        assert struct.pack("<I", 0) in payload


class TestBypassCapabilityAnalysis:
    """Test bypass capability analysis."""

    def test_analyze_bypass_capabilities(self) -> None:
        """Analyze available bypass methods for target."""
        engine = BypassEngine()

        target_info = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert "bypasses_available" in result
        assert "target_info" in result
        assert "bypass_count" in result
        assert isinstance(result["bypasses_available"], list)

    def test_get_available_bypasses(self) -> None:
        """Get list of all available bypass types."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()

        assert isinstance(bypasses, list)
        assert len(bypasses) > 0

    def test_get_bypass_info(self) -> None:
        """Get detailed information about specific bypass type."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()
        if len(bypasses) > 0:
            bypass_type = bypasses[0]
            info = engine.get_bypass_info(bypass_type)

            assert isinstance(info, dict)

    def test_get_recommended_bypasses(self) -> None:
        """Get recommended bypasses based on target and reliability."""
        engine = BypassEngine()

        target_info = {
            "aslr_enabled": True,
            "dep_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=6)

        assert isinstance(recommended, list)


class TestArchitectureSupport:
    """Test multi-architecture payload generation."""

    @pytest.mark.parametrize(
        "arch",
        ["x64", "x86_64", "amd64", "x86", "i386", "i686", "arm64", "aarch64", "arm", "armv7"],
    )
    def test_all_architectures_supported(self, arch: str) -> None:
        """All architectures generate valid payloads."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            arch,
            target_info,
        )

        payload = result["payload"]
        assert len(payload) > 0
        assert result["architecture"] in arch or arch in result["architecture"]

    def test_unknown_architecture_fallback(self) -> None:
        """Unknown architecture defaults to x64."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "unknown_arch",
            target_info,
        )

        payload = result["payload"]
        assert len(payload) > 0


class TestPayloadMetadata:
    """Test payload metadata tracking."""

    def test_payload_size_tracking(self) -> None:
        """Payload result includes accurate size information."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
        )

        assert result["size"] == len(result["payload"])

    def test_null_byte_counting(self) -> None:
        """Payload result tracks null byte count."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
        )

        expected_nulls = result["payload"].count(b"\x00")
        assert result["null_bytes"] == expected_nulls

    def test_metadata_includes_target_os(self) -> None:
        """Metadata includes target operating system."""
        engine = BypassEngine()

        target_info = {"os_type": "linux"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
        )

        assert result["metadata"]["target_os"] == "linux"


class TestCompleteBypassWorkflow:
    """Test complete bypass generation workflows."""

    def test_windows_x64_license_bypass_workflow(self) -> None:
        """Complete workflow for Windows x64 license bypass."""
        engine = BypassEngine()

        target_info = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": ["DEP", "ASLR"],
        }

        options = {
            "preserve_stack": True,
            "return_value": 1,
            "encoding_schemes": ["null_free"],
            "output_format": "exe",
        }

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            options,
        )

        assert result["payload"][:2] == b"MZ"
        assert result["null_bytes"] == 0
        assert result["metadata"]["output_format"] == "exe"

    def test_linux_arm64_trial_extension_workflow(self) -> None:
        """Complete workflow for Linux ARM64 trial extension."""
        engine = BypassEngine()

        target_info = {
            "os_type": "linux",
            "architecture": "arm64",
        }

        options = {
            "output_format": "c",
        }

        result = engine.generate_payload(
            PayloadType.TRIAL_EXTENSION,
            "arm64",
            target_info,
            options,
        )

        payload_str = result["payload"].decode("utf-8")
        assert "unsigned char payload[]" in payload_str


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_empty_target_info(self) -> None:
        """Engine handles empty target information."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
        )

        assert len(result["payload"]) > 0

    def test_none_options(self) -> None:
        """Engine handles None options parameter."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            PayloadType.LICENSE_CHECK_BYPASS,
            "x64",
            target_info,
            None,
        )

        assert len(result["payload"]) > 0

    def test_string_payload_type(self) -> None:
        """Engine handles string payload type."""
        engine = BypassEngine()

        target_info = {"os_type": "windows"}

        result = engine.generate_payload(
            "LICENSE_CHECK_BYPASS",
            "x64",
            target_info,
        )

        assert result["payload_type"] == "license_check_bypass"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
