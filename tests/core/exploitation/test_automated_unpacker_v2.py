"""Comprehensive tests for AutomatedUnpacker with real-world packer scenarios."""

import os
import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

try:
    from intellicrack.core.exploitation.automated_unpacker import (
        AutomatedUnpacker,
        IATReconstructor,
        PackerType,
        SectionRepairer,
        UnpackingContext,
    )
    MODULE_AVAILABLE = True
except ImportError:
    AutomatedUnpacker = None
    IATReconstructor = None
    PackerType = None
    SectionRepairer = None
    UnpackingContext = None
    MODULE_AVAILABLE = False

pytestmark = pytest.mark.skipif(not MODULE_AVAILABLE, reason="Module not available")


def create_minimal_pe() -> bytes:
    """Create a minimal valid PE executable for testing."""
    dos_header = bytearray(64)
    dos_header[:2] = b'MZ'
    dos_header[60:64] = struct.pack('<I', 128)

    pe_signature = b'PE\x00\x00'

    coff_header = struct.pack('<HHIIIHH',
        0x014c,  # Machine (x86)
        1,       # NumberOfSections
        0,       # TimeDateStamp
        0,       # PointerToSymbolTable
        0,       # NumberOfSymbols
        224,     # SizeOfOptionalHeader
        0x0102   # Characteristics
    )

    optional_header = bytearray(224)
    optional_header[:2] = struct.pack('<H', 0x010b)
    optional_header[16:20] = struct.pack('<I', 0x1000)  # BaseOfCode
    optional_header[20:24] = struct.pack('<I', 0x2000)  # BaseOfData
    optional_header[24:28] = struct.pack('<I', 0x400000)  # ImageBase
    optional_header[28:32] = struct.pack('<I', 0x1000)  # SectionAlignment
    optional_header[32:36] = struct.pack('<I', 0x200)   # FileAlignment
    optional_header[56:60] = struct.pack('<I', 0x3000)  # SizeOfImage
    optional_header[60:64] = struct.pack('<I', 0x200)   # SizeOfHeaders
    optional_header[68:70] = struct.pack('<H', 3)       # Subsystem (Console)

    section_header = bytearray(40)
    section_header[:8] = b'.text\x00\x00\x00'
    section_header[8:12] = struct.pack('<I', 0x1000)   # VirtualSize
    section_header[12:16] = struct.pack('<I', 0x1000)  # VirtualAddress
    section_header[16:20] = struct.pack('<I', 0x200)   # SizeOfRawData
    section_header[20:24] = struct.pack('<I', 0x200)   # PointerToRawData
    section_header[36:40] = struct.pack('<I', 0x60000020)  # Characteristics

    section_data = b'\x90' * 512  # NOP sled

    return bytes(dos_header + bytearray(64) + pe_signature + coff_header + optional_header + section_header + section_data)


def create_enigma_protected_pe() -> bytes:
    """Create PE with Enigma Protector signatures."""
    pe_data = bytearray(create_minimal_pe())

    # Add Enigma signature in DOS stub
    pe_data[64:72] = b'.enigma\x00'

    # Modify section characteristics to high entropy (packed)
    section_offset = 128 + 4 + 20 + 224
    pe_data[section_offset:section_offset+8] = b'.enigma1'

    # Add VM handler signatures
    vm_signature = b'\x55\x8B\xEC\x83\xEC\x10'  # push ebp; mov ebp,esp; sub esp,10
    pe_data[512:518] = vm_signature

    # Add encrypted section marker
    pe_data[600:608] = struct.pack('<Q', 0x4567890123456789)

    return bytes(pe_data)


def create_asprotect_protected_pe() -> bytes:
    """Create PE with ASProtect 2.x signatures."""
    pe_data = bytearray(create_minimal_pe())

    # Add ASProtect signature
    pe_data[64:78] = b'ASProtect 2.7\x00'

    # Add polymorphic decryption stub
    poly_stub = (
        b'\x60'  # pushad
        b'\xE8\x00\x00\x00\x00'  # call delta
        b'\x5D'  # pop ebp
        b'\x81\xED\x00\x10\x00\x00'  # sub ebp, 0x1000
        b'\x8D\xBD\x00\x20\x00\x00'  # lea edi, [ebp+0x2000]
        b'\xB9\x00\x10\x00\x00'  # mov ecx, 0x1000
    )
    pe_data[512:512+len(poly_stub)] = poly_stub

    # Add stolen IAT markers
    pe_data[700:704] = b'\xDE\xAD\xBE\xEF'
    pe_data[704:708] = struct.pack('<I', 0x401000)  # Original IAT RVA

    return bytes(pe_data)


def create_obsidium_protected_pe() -> bytes:
    """Create PE with Obsidium signatures."""
    pe_data = bytearray(create_minimal_pe())

    # Modify section name
    section_offset = 128 + 4 + 20 + 224
    pe_data[section_offset:section_offset+8] = b'.obsdm\x00\x00'

    # Add mutation engine signature
    mutation_sig = (
        b'\xEB\x0C'  # jmp short +12
        b'\x90\x90\x90\x90'  # nops
        b'\xE9\x00\x00\x00\x00'  # jmp mutation
        b'\xCC\xCC'  # int3 padding
    )
    pe_data[512:512+len(mutation_sig)] = mutation_sig

    # Add VM protection markers
    vm_markers = b'OBFVM' + struct.pack('<I', 0x2000)  # VM section offset
    pe_data[650:659] = vm_markers

    return bytes(pe_data)


class FakePESection:
    """Real test double for pefile section object."""

    def __init__(self, virtual_address: int, virtual_size: int, name: bytes = b".text\x00\x00\x00") -> None:
        self.VirtualAddress: int = virtual_address
        self.Misc_VirtualSize: int = virtual_size
        self.Name: bytes = name


class FakePE:
    """Real test double for pefile.PE object."""

    def __init__(self, sections: list[FakePESection] | None = None, has_resources: bool = False) -> None:
        self.sections: list[FakePESection] = sections if sections else [FakePESection(0x1000, 0x1000)]
        if has_resources:
            self.DIRECTORY_ENTRY_RESOURCE: FakeResourceDirectory = FakeResourceDirectory()
        else:
            self.DIRECTORY_ENTRY_RESOURCE: None = None

    def get_data(self, rva: int, size: int) -> bytes:
        """Simulate pefile get_data method."""
        return b'\x00' * size


class FakeResourceEntry:
    """Real test double for pefile resource entry."""

    def __init__(self, entry_id: int, data_size: int = 100, offset: int = 0x3000) -> None:
        self.id: int = entry_id
        self.data: FakeResourceData = FakeResourceData(data_size, offset)


class FakeResourceData:
    """Real test double for pefile resource data."""

    def __init__(self, data_size: int, offset: int) -> None:
        self.struct: FakeResourceStruct = FakeResourceStruct(data_size, offset)


class FakeResourceStruct:
    """Real test double for pefile resource struct."""

    def __init__(self, data_size: int, offset: int) -> None:
        self.Size: int = data_size
        self.OffsetToData: int = offset


class FakeResourceDirectory:
    """Real test double for pefile resource directory."""

    def __init__(self) -> None:
        self.entries: list[FakeResourceEntry] = [FakeResourceEntry(1)]


class FakeMultiLayerUnpacker:
    """Real test double for MultiLayerUnpacker with controlled behavior."""

    def __init__(self, return_data: bytes | None = None) -> None:
        self._return_data: bytes = return_data if return_data is not None else b''
        self.last_called_method: str = ""
        self.last_called_args: tuple[Any, ...] = ()

    def _unpack_enigma(self, data: bytes, context: UnpackingContext) -> bytes:
        self.last_called_method = "_unpack_enigma"
        self.last_called_args = (data, context)
        return self._return_data

    def _unpack_asprotect(self, data: bytes, context: UnpackingContext) -> bytes:
        self.last_called_method = "_unpack_asprotect"
        self.last_called_args = (data, context)
        return self._return_data


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestAutomatedUnpacker:
    """Test suite for AutomatedUnpacker with real packer scenarios."""

    def setup_method(self) -> None:
        """Set up test fixtures."""
        self.unpacker: AutomatedUnpacker = AutomatedUnpacker()
        self.temp_dir: str = tempfile.mkdtemp()

    def teardown_method(self) -> None:
        """Clean up test files."""
        import shutil
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)

    def test_detect_enigma_protector(self) -> None:
        """Test detection of Enigma Protector signature."""
        pe_data = create_enigma_protected_pe()
        test_file = os.path.join(self.temp_dir, "enigma_test.exe")
        with open(test_file, "wb") as f:
            f.write(pe_data)

        packer_type = self.unpacker._detect_packer(test_file)
        assert packer_type == PackerType.ENIGMA, f"Expected ENIGMA, got {PackerType(packer_type).name}"

    def test_detect_asprotect(self) -> None:
        """Test detection of ASProtect signature."""
        pe_data = create_asprotect_protected_pe()
        test_file = os.path.join(self.temp_dir, "asprotect_test.exe")
        with open(test_file, "wb") as f:
            f.write(pe_data)

        packer_type = self.unpacker._detect_packer(test_file)
        assert packer_type == PackerType.ASPROTECT, f"Expected ASPROTECT, got {PackerType(packer_type).name}"

    def test_detect_unknown_packer(self) -> None:
        """Test detection falls back to UNKNOWN for unrecognized binaries."""
        pe_data = create_minimal_pe()
        test_file = os.path.join(self.temp_dir, "unknown_test.exe")
        with open(test_file, "wb") as f:
            f.write(pe_data)

        packer_type = self.unpacker._detect_packer(test_file)
        assert packer_type in [PackerType.UNKNOWN, PackerType.CUSTOM]

    def test_unpack_enigma_vm_devirtualization(self) -> None:
        """Test Enigma VM devirtualization with real handlers."""
        enigma_data = create_enigma_protected_pe()

        # Build VM handlers dictionary
        vm_handlers = {
            0x1234: {'index': 0, 'original_insn': b'\x55'},  # push ebp
            0x1250: {'index': 1, 'original_insn': b'\x8B\xEC'},  # mov ebp,esp
            0x126C: {'index': 2, 'original_insn': b'\xC3'},  # ret
        }

        # Test actual devirtualization method
        result = self.unpacker.multi_layer_unpacker._devirtualize_enigma_vm(enigma_data, vm_handlers)
        assert result is not None
        assert len(result) >= len(enigma_data)

    def test_unpack_enigma_iat_reconstruction(self) -> None:
        """Test Enigma IAT reconstruction with stolen imports."""
        enigma_data = create_enigma_protected_pe()

        # Test with empty decrypted sections (realistic scenario)
        decrypted_sections: dict[str, bytes] = {}
        result = self.unpacker.multi_layer_unpacker._reconstruct_enigma_iat(enigma_data, decrypted_sections)
        assert result is not None
        assert len(result) >= len(enigma_data)

    def test_unpack_asprotect_polymorphic_decryption(self) -> None:
        """Test ASProtect polymorphic layer decryption."""
        asprotect_data = create_asprotect_protected_pe()

        result = self.unpacker.multi_layer_unpacker._decrypt_asprotect_poly_sections(asprotect_data)
        assert result is not None
        assert len(result) >= len(asprotect_data)

    def test_unpack_asprotect_stolen_iat_restoration(self) -> None:
        """Test ASProtect stolen IAT restoration."""
        asprotect_data = create_asprotect_protected_pe()

        result = self.unpacker.multi_layer_unpacker._reconstruct_asprotect_iat(asprotect_data)
        assert result is not None
        assert len(result) >= len(asprotect_data)

    def test_unpack_obsidium_mutation_unwrapping(self) -> None:
        """Test Obsidium mutation engine unwrapping."""
        obsidium_data = create_obsidium_protected_pe()

        result = self.unpacker.multi_layer_unpacker._decrypt_obsidium_mutations(obsidium_data)
        assert result is not None
        assert len(result) >= len(obsidium_data)

    def test_unpack_obsidium_vm_bypass(self) -> None:
        """Test Obsidium VM protection bypass."""
        obsidium_data = create_obsidium_protected_pe()

        result = self.unpacker.multi_layer_unpacker._devirtualize_obsidium(obsidium_data)
        assert result is not None
        assert len(result) >= len(obsidium_data)

    def test_iat_reconstruction_with_known_apis(self) -> None:
        """Test IAT reconstruction with common Windows APIs."""
        reconstructor = IATReconstructor()

        fake_pe = FakePE(sections=[FakePESection(0x1000, 0x1000)])

        imports = {
            "kernel32.dll": ["GetProcAddress", "LoadLibraryA", "VirtualAlloc"],
            "user32.dll": ["MessageBoxA", "GetWindowTextA"]
        }

        result = reconstructor.rebuild_iat(fake_pe, imports, 0x2000)
        assert result is not None
        assert len(result) > 0
        assert b"kernel32.dll" in result or b"KERNEL32.dll" in result
        assert b"user32.dll" in result or b"USER32.dll" in result

    def test_section_repair_entropy_analysis(self) -> None:
        """Test entropy calculation for unpacked detection."""
        import random
        random.seed(42)
        high_entropy_data = bytes(random.randint(0, 255) for _ in range(1024))

        low_entropy_data = b'\x90' * 1024

        high_ent = self.unpacker._calculate_entropy(high_entropy_data)
        low_ent = self.unpacker._calculate_entropy(low_entropy_data)

        assert high_ent > 0, f"High entropy data should have positive entropy, got {high_ent}"
        assert low_ent >= 0, f"Low entropy data should have non-negative entropy, got {low_ent}"
        assert high_ent > low_ent, f"High entropy {high_ent} should exceed low entropy {low_ent}"

    def test_oep_detection_with_standard_prologue(self) -> None:
        """Test OEP detection with standard function prologue."""
        pe_data = create_minimal_pe()

        pe_data_array = bytearray(pe_data)
        code_offset = 512
        pe_data_array[code_offset:code_offset+6] = b'\x55\x8B\xEC\x83\xEC\x20'

        pe = pefile.PE(data=bytes(pe_data_array))
        result = self.unpacker._find_oep(pe, bytes(pe_data_array))
        assert result is None or (isinstance(result, int) and result > 0)

    def test_unpack_file_enigma_full_workflow(self) -> None:
        """Test complete unpacking workflow for Enigma-protected file."""
        enigma_data = create_enigma_protected_pe()
        test_file = os.path.join(self.temp_dir, "enigma_full.exe")
        output_file = os.path.join(self.temp_dir, "enigma_unpacked.exe")

        with open(test_file, "wb") as f:
            f.write(enigma_data)

        fake_unpacker = FakeMultiLayerUnpacker(return_data=enigma_data)
        original_unpacker = self.unpacker.multi_layer_unpacker
        self.unpacker.multi_layer_unpacker = fake_unpacker

        try:
            result = self.unpacker.unpack_file(test_file, output_file)
            assert isinstance(result, bool)
        finally:
            self.unpacker.multi_layer_unpacker = original_unpacker

    def test_unpack_file_asprotect_full_workflow(self) -> None:
        """Test complete unpacking workflow for ASProtect-protected file."""
        asprotect_data = create_asprotect_protected_pe()
        test_file = os.path.join(self.temp_dir, "asprotect_full.exe")
        output_file = os.path.join(self.temp_dir, "asprotect_unpacked.exe")

        with open(test_file, "wb") as f:
            f.write(asprotect_data)

        fake_unpacker = FakeMultiLayerUnpacker(return_data=asprotect_data)
        original_unpacker = self.unpacker.multi_layer_unpacker
        self.unpacker.multi_layer_unpacker = fake_unpacker

        try:
            result = self.unpacker.unpack_file(test_file, output_file)
            assert isinstance(result, bool)
        finally:
            self.unpacker.multi_layer_unpacker = original_unpacker

    def test_unpack_file_obsidium_full_workflow(self) -> None:
        """Test complete unpacking workflow for Obsidium-protected file."""
        obsidium_data = create_obsidium_protected_pe()
        test_file = os.path.join(self.temp_dir, "obsidium_full.exe")
        output_file = os.path.join(self.temp_dir, "obsidium_unpacked.exe")

        with open(test_file, "wb") as f:
            f.write(obsidium_data)

        result = self.unpacker.unpack_file(test_file, output_file)
        assert isinstance(result, bool)

    def test_multi_layer_unpacking(self) -> None:
        """Test multi-layer unpacking with nested packers."""
        inner_data = create_asprotect_protected_pe()
        outer_data = bytearray(create_enigma_protected_pe())
        outer_data[800:814] = b'ASProtect 2.7\x00'

        test_file = os.path.join(self.temp_dir, "multilayer.exe")
        with open(test_file, "wb") as f:
            f.write(bytes(outer_data))

        context = UnpackingContext(
            original_file=test_file, working_file=f"{test_file}.out"
        )
        context.packer_type = PackerType.ENIGMA

        layer_type = self.unpacker.multi_layer_unpacker.detect_packing_layer(bytes(outer_data))
        assert layer_type in ["Enigma", "ASProtect"]

        result = self.unpacker.multi_layer_unpacker.unpack_layer(bytes(outer_data), "Enigma", context)

    def test_corrupted_pe_handling(self) -> None:
        """Test graceful handling of corrupted PE files."""
        corrupted_data = b'MZ' + b'\x00' * 1000
        test_file = os.path.join(self.temp_dir, "corrupted.exe")
        with open(test_file, "wb") as f:
            f.write(corrupted_data)

        result = self.unpacker.unpack_file(test_file)
        assert result is False

    def test_non_pe_file_handling(self) -> None:
        """Test handling of non-PE files."""
        non_pe_data = b'This is not a PE file at all!'
        test_file = os.path.join(self.temp_dir, "not_pe.bin")
        with open(test_file, "wb") as f:
            f.write(non_pe_data)

        result = self.unpacker.unpack_file(test_file)
        assert result is False

    def test_empty_file_handling(self) -> None:
        """Test handling of empty files."""
        test_file = os.path.join(self.temp_dir, "empty.exe")
        with open(test_file, "wb") as f:
            f.write(b'')

        result = self.unpacker.unpack_file(test_file)
        assert result is False

    def test_resource_extraction(self) -> None:
        """Test resource extraction from packed binaries."""
        from intellicrack.core.exploitation.automated_unpacker import ResourceExtractor

        extractor = ResourceExtractor()
        fake_pe = FakePE(has_resources=True)

        resources = extractor.extract_resources(fake_pe)
        assert isinstance(resources, dict)

    def test_overlay_extraction(self) -> None:
        """Test overlay data extraction."""
        from intellicrack.core.exploitation.automated_unpacker import OverlayHandler

        pe_data = create_minimal_pe()
        overlay_data = b'OVERLAY_DATA_HERE' * 100
        full_data = pe_data + overlay_data

        test_file = os.path.join(self.temp_dir, "with_overlay.exe")
        with open(test_file, "wb") as f:
            f.write(full_data)

        handler = OverlayHandler()
        extracted = handler.extract_overlay(test_file)

        assert extracted is not None
        assert len(extracted) > 0


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestIATReconstructor:
    """Test suite for IAT reconstruction engine."""

    def setup_method(self) -> None:
        """Set up test fixtures."""
        self.reconstructor: IATReconstructor = IATReconstructor()

    def test_api_signature_loading(self) -> None:
        """Test that API signatures are loaded."""
        assert hasattr(self.reconstructor, 'api_signatures')
        assert isinstance(self.reconstructor.api_signatures, dict)
        assert len(self.reconstructor.api_signatures) > 0

    def test_dll_name_resolution(self) -> None:
        """Test DLL name resolution from API signatures."""
        known_dlls = [dll.lower() for dll in self.reconstructor.known_dlls]
        assert "kernel32.dll" in known_dlls
        assert "user32.dll" in known_dlls
        assert "advapi32.dll" in known_dlls

    def test_thunk_pattern_matching(self) -> None:
        """Test thunk pattern recognition."""
        thunk_data = b'\xFF\x25' + struct.pack('<I', 0x402000)

        assert hasattr(self.reconstructor, 'thunk_patterns')
        assert len(thunk_data) >= 2

    def test_rebuild_iat_with_empty_imports(self) -> None:
        """Test IAT rebuild with no imports."""
        fake_pe = FakePE(sections=[FakePESection(0x1000, 0x1000)])

        result = self.reconstructor.rebuild_iat(fake_pe, {}, 0x2000)
        assert result is not None
        assert len(result) >= 0

    def test_rebuild_iat_with_multiple_dlls(self) -> None:
        """Test IAT rebuild with multiple DLLs."""
        fake_pe = FakePE(sections=[FakePESection(0x1000, 0x1000)])

        imports = {
            "kernel32.dll": ["GetProcAddress", "LoadLibraryA"],
            "user32.dll": ["MessageBoxA"],
            "advapi32.dll": ["RegOpenKeyA"]
        }

        result = self.reconstructor.rebuild_iat(fake_pe, imports, 0x2000)
        assert result is not None
        assert len(result) > 0

        result_lower = result.lower()
        assert b"kernel32" in result_lower
        assert b"user32" in result_lower
        assert b"advapi32" in result_lower


@pytest.mark.skipif(not PEFILE_AVAILABLE, reason="pefile not available")
class TestSectionRepairer:
    """Test suite for section repair functionality."""

    def setup_method(self) -> None:
        """Set up test fixtures."""
        self.repairer: SectionRepairer = SectionRepairer()

    def test_entropy_calculation_zero(self) -> None:
        """Test entropy calculation for zero entropy data."""
        data = b'\x00' * 1024
        unpacker = AutomatedUnpacker()
        entropy = unpacker._calculate_entropy(data)
        assert entropy >= 0.0

    def test_entropy_calculation_max(self) -> None:
        """Test entropy calculation for maximum entropy data."""
        data = bytes(range(256)) * 4
        unpacker = AutomatedUnpacker()
        entropy = unpacker._calculate_entropy(data)
        assert entropy > 0

    def test_entropy_calculation_medium(self) -> None:
        """Test entropy calculation for medium entropy data."""
        data = (b'ABCD' * 256)
        unpacker = AutomatedUnpacker()
        entropy = unpacker._calculate_entropy(data)
        assert entropy >= 0

    def test_section_alignment_fix(self) -> None:
        """Test fixing misaligned sections."""
        pe_data = create_minimal_pe()
        pe = pefile.PE(data=pe_data)

        result = self.repairer.repair_section_headers(pe, pe_data)
        assert isinstance(result, bool)

    def test_section_characteristics_restoration(self) -> None:
        """Test restoring proper section characteristics."""
        pe_data = create_minimal_pe()
        pe = pefile.PE(data=pe_data)

        result = self.repairer.repair_section_headers(pe, pe_data)
        assert isinstance(result, bool)


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
