"""Production-ready tests for RSA validation in keygen_generator.py.

Tests validate that RSA key extraction, signature verification, padding scheme detection,
and cryptographic operations work correctly against real binaries with RSA-protected licenses.

These tests MUST FAIL if functionality is incomplete or non-functional.
NO mocks, NO stubs, NO placeholder assertions.
"""

from __future__ import annotations

import datetime
import hashlib
import struct
import tempfile
from pathlib import Path
from typing import TYPE_CHECKING

import pytest

if TYPE_CHECKING:
    from collections.abc import Iterator

try:
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding, rsa
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    CRYPTOGRAPHY_AVAILABLE = False

from intellicrack.core.exploitation.keygen_generator import (
    KeyAlgorithmType,
    RSAKeyValidator,
    RSAPaddingScheme,
    RSAPublicKeyInfo,
    ValidationAlgorithm,
)


class RealBinaryGenerator:
    """Generates real binaries with embedded RSA keys for testing."""

    @staticmethod
    def create_pe_with_rsa_key_der(key_size: int, exponent: int) -> bytes:
        """Create minimal PE with DER-encoded RSA public key embedded."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required for RSA key generation")

        private_key = rsa.generate_private_key(
            public_exponent=exponent, key_size=key_size, backend=default_backend()
        )
        public_key = private_key.public_key()

        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_header[60:64] = struct.pack("<I", 64)
        pe_header[64:68] = b"PE\x00\x00"

        machine = struct.pack("<H", 0x8664)
        num_sections = struct.pack("<H", 1)
        pe_header[68 : 68 + 2] = machine
        pe_header[70 : 70 + 2] = num_sections

        pe_binary = bytes(pe_header) + b"\x00" * 1024 + der_key + b"\x00" * 2048

        return pe_binary

    @staticmethod
    def create_pe_with_rsa_key_pem(key_size: int, exponent: int) -> bytes:
        """Create minimal PE with PEM-encoded RSA public key embedded."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required for RSA key generation")

        private_key = rsa.generate_private_key(
            public_exponent=exponent, key_size=key_size, backend=default_backend()
        )
        public_key = private_key.public_key()

        pem_key = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_header[60:64] = struct.pack("<I", 64)
        pe_header[64:68] = b"PE\x00\x00"

        pe_binary = bytes(pe_header) + b"\x00" * 1024 + pem_key + b"\x00" * 2048

        return pe_binary

    @staticmethod
    def create_pe_with_x509_certificate(key_size: int, exponent: int) -> bytes:
        """Create minimal PE with X.509 certificate containing RSA public key."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required for X.509 generation")

        from cryptography import x509
        from cryptography.x509.oid import NameOID

        private_key = rsa.generate_private_key(
            public_exponent=exponent, key_size=key_size, backend=default_backend()
        )

        subject = issuer = x509.Name(
            [
                x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "CA"),
                x509.NameAttribute(NameOID.LOCALITY_NAME, "San Francisco"),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Test Software Inc"),
                x509.NameAttribute(NameOID.COMMON_NAME, "license.example.com"),
            ]
        )

        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
            .not_valid_after(datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=365))
            .sign(private_key, hashes.SHA256(), default_backend())
        )

        pem_cert = cert.public_bytes(serialization.Encoding.PEM)

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_header[60:64] = struct.pack("<I", 64)
        pe_header[64:68] = b"PE\x00\x00"

        pe_binary = bytes(pe_header) + b"\x00" * 1024 + pem_cert + b"\x00" * 2048

        return pe_binary

    @staticmethod
    def create_pe_with_raw_modulus_exponent(key_size: int, exponent: int) -> bytes:
        """Create minimal PE with raw RSA modulus and exponent embedded."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required for RSA key generation")

        private_key = rsa.generate_private_key(
            public_exponent=exponent, key_size=key_size, backend=default_backend()
        )
        public_numbers = private_key.public_key().public_numbers()

        modulus_bytes = public_numbers.n.to_bytes(key_size // 8, "big")
        exponent_bytes = struct.pack(">I", public_numbers.e)

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_header[60:64] = struct.pack("<I", 64)
        pe_header[64:68] = b"PE\x00\x00"

        pe_binary = (
            bytes(pe_header)
            + b"\x00" * 1024
            + modulus_bytes
            + b"\x00" * 100
            + exponent_bytes
            + b"\x00" * 2048
        )

        return pe_binary

    @staticmethod
    def create_pe_with_cryptoapi_key(key_size: int, exponent: int) -> bytes:
        """Create minimal PE with Windows CryptoAPI RSA key structure."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required for RSA key generation")

        private_key = rsa.generate_private_key(
            public_exponent=exponent, key_size=key_size, backend=default_backend()
        )
        public_numbers = private_key.public_key().public_numbers()

        cryptoapi_blob = bytearray()
        cryptoapi_blob.extend(b"RSA1")
        cryptoapi_blob.extend(struct.pack("<I", key_size))
        cryptoapi_blob.extend(struct.pack("<I", exponent))

        modulus_bytes_le = public_numbers.n.to_bytes(key_size // 8, "little")
        cryptoapi_blob.extend(modulus_bytes_le)

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_header[60:64] = struct.pack("<I", 64)
        pe_header[64:68] = b"PE\x00\x00"

        pe_binary = bytes(pe_header) + b"\x00" * 1024 + bytes(cryptoapi_blob) + b"\x00" * 2048

        return pe_binary

    @staticmethod
    def create_signed_license_data(
        private_key: rsa.RSAPrivateKey,
        message: bytes,
        padding_scheme: RSAPaddingScheme,
        hash_alg: str,
    ) -> bytes:
        """Create properly signed license data for verification testing."""
        hash_map = {
            "MD5": hashes.MD5(),
            "SHA1": hashes.SHA1(),
            "SHA224": hashes.SHA224(),
            "SHA256": hashes.SHA256(),
            "SHA384": hashes.SHA384(),
            "SHA512": hashes.SHA512(),
        }

        hash_obj = hash_map.get(hash_alg, hashes.SHA256())

        if padding_scheme == RSAPaddingScheme.PSS:
            pad = padding.PSS(mgf=padding.MGF1(hash_obj), salt_length=padding.PSS.MAX_LENGTH)
        elif padding_scheme == RSAPaddingScheme.PKCS1_V1_5:
            pad = padding.PKCS1v15()
        else:
            raise ValueError(f"Unsupported padding scheme: {padding_scheme}")

        signature = private_key.sign(message, pad, hash_obj)

        return message + signature


@pytest.fixture
def temp_binary_dir() -> Iterator[Path]:
    """Create temporary directory for test binaries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def rsa_key_2048_65537() -> tuple[rsa.RSAPrivateKey, int, int]:
    """Generate 2048-bit RSA key with e=65537."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())
    return key, 2048, 65537


@pytest.fixture
def rsa_key_1024_3() -> tuple[rsa.RSAPrivateKey, int, int]:
    """Generate 1024-bit RSA key with e=3."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    key = rsa.generate_private_key(public_exponent=3, key_size=1024, backend=default_backend())
    return key, 1024, 3


@pytest.fixture
def rsa_key_4096_17() -> tuple[rsa.RSAPrivateKey, int, int]:
    """Generate 4096-bit RSA key with e=17."""
    if not CRYPTOGRAPHY_AVAILABLE:
        pytest.skip("cryptography library required")

    key = rsa.generate_private_key(public_exponent=17, key_size=4096, backend=default_backend())
    return key, 4096, 17


class TestRSAKeyExtraction:
    """Production tests for RSA public key extraction from binaries."""

    def test_extracts_actual_rsa_public_key_n_modulus_from_der_format(
        self, temp_binary_dir: Path
    ) -> None:
        """Must extract actual RSA public key modulus (n) from DER-encoded key in binary."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_der(2048, 65537)

        binary_path = temp_binary_dir / "test_der.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract at least one RSA key from DER format"

        key_found = False
        for key_info in extracted_keys:
            if key_info.modulus > 0 and key_info.key_size == 2048:
                key_found = True
                assert key_info.modulus.bit_length() >= 2047, "Modulus must be 2048-bit"
                assert key_info.modulus.bit_length() <= 2048, "Modulus must be 2048-bit"
                break

        assert key_found, "Must extract valid 2048-bit RSA modulus from binary"

    def test_extracts_actual_rsa_public_exponent_e_from_der_format(
        self, temp_binary_dir: Path
    ) -> None:
        """Must extract actual RSA public exponent (e) from DER-encoded key in binary."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_der(2048, 65537)

        binary_path = temp_binary_dir / "test_der.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract at least one RSA key"

        exponent_found = False
        for key_info in extracted_keys:
            if key_info.exponent == 65537:
                exponent_found = True
                break

        assert exponent_found, "Must extract correct RSA exponent 65537 from binary"

    def test_extracts_rsa_key_from_pem_format_in_binary(self, temp_binary_dir: Path) -> None:
        """Must extract RSA key from PEM-encoded format in binary."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_pem(2048, 65537)

        binary_path = temp_binary_dir / "test_pem.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract RSA key from PEM format"

        pem_key_found = False
        for key_info in extracted_keys:
            if key_info.format_type == "PEM" and key_info.key_size == 2048:
                pem_key_found = True
                break

        assert pem_key_found, "Must identify key as PEM format with correct size"

    def test_extracts_rsa_key_from_x509_certificate(self, temp_binary_dir: Path) -> None:
        """Must extract RSA key from X.509 certificate embedded in binary."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_x509_certificate(2048, 65537)

        binary_path = temp_binary_dir / "test_x509.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract RSA key from X.509 certificate"

        cert_key_found = False
        for key_info in extracted_keys:
            if "x509" in key_info.format_type.lower() or "certificate" in key_info.source.lower():
                cert_key_found = True
                assert key_info.key_size == 2048, "Certificate key size must be 2048"
                assert key_info.exponent == 65537, "Certificate key exponent must be 65537"
                break

        assert cert_key_found, "Must extract and identify X.509 certificate key"

    def test_extracts_rsa_key_from_raw_modulus_exponent_pairs(
        self, temp_binary_dir: Path
    ) -> None:
        """Must extract RSA key from raw modulus and exponent bytes in binary."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_raw_modulus_exponent(2048, 65537)

        binary_path = temp_binary_dir / "test_raw.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract RSA key from raw modulus/exponent"

        raw_key_found = False
        for key_info in extracted_keys:
            if key_info.key_size == 2048 and key_info.exponent == 65537:
                raw_key_found = True
                assert key_info.modulus > 0, "Raw modulus must be positive"
                assert key_info.modulus.bit_length() >= 2047, "Raw modulus must be 2048-bit"
                break

        assert raw_key_found, "Must reconstruct RSA key from raw components"

    def test_extracts_rsa_key_from_windows_cryptoapi_structure(
        self, temp_binary_dir: Path
    ) -> None:
        """Must extract RSA key from Windows CryptoAPI key blob structure."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_cryptoapi_key(2048, 65537)

        binary_path = temp_binary_dir / "test_cryptoapi.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) > 0, "Must extract RSA key from CryptoAPI structure"

        cryptoapi_key_found = False
        for key_info in extracted_keys:
            if key_info.format_type == "CRYPTOAPI":
                cryptoapi_key_found = True
                assert key_info.key_size == 2048, "CryptoAPI key size must be 2048"
                assert key_info.exponent == 65537, "CryptoAPI key exponent must be 65537"
                assert "cryptoapi" in key_info.source.lower(), "Source must indicate CryptoAPI"
                break

        assert cryptoapi_key_found, "Must identify and extract CryptoAPI RSA key"

    def test_validates_key_structure_against_1024bit_modulus_size(
        self, temp_binary_dir: Path
    ) -> None:
        """Must validate key structure against expected 1024-bit modulus size."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_der(1024, 65537)

        binary_path = temp_binary_dir / "test_1024.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        key_1024_found = False
        for key_info in extracted_keys:
            if key_info.key_size == 1024:
                key_1024_found = True
                assert key_info.modulus.bit_length() >= 1023, "1024-bit modulus validation"
                assert key_info.modulus.bit_length() <= 1024, "1024-bit modulus validation"
                break

        assert key_1024_found, "Must correctly identify and validate 1024-bit key structure"

    def test_validates_key_structure_against_4096bit_modulus_size(
        self, temp_binary_dir: Path
    ) -> None:
        """Must validate key structure against expected 4096-bit modulus size."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_der(4096, 65537)

        binary_path = temp_binary_dir / "test_4096.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        key_4096_found = False
        for key_info in extracted_keys:
            if key_info.key_size == 4096:
                key_4096_found = True
                assert key_info.modulus.bit_length() >= 4095, "4096-bit modulus validation"
                assert key_info.modulus.bit_length() <= 4096, "4096-bit modulus validation"
                break

        assert key_4096_found, "Must correctly identify and validate 4096-bit key structure"


class TestRSAPaddingSchemeDetection:
    """Production tests for RSA padding scheme detection."""

    def test_detects_rsa_pss_padding_scheme(self) -> None:
        """Must detect RSA-PSS padding scheme from algorithm operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["RSASSA-PSS", "PSS padding"],
                crypto_operations=["RSA_PSS_verify"],
            )

            detected_scheme = validator.detect_padding_scheme(algorithm)

            assert detected_scheme == RSAPaddingScheme.PSS, "Must detect RSA-PSS padding scheme"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_detects_pkcs1_v1_5_padding_scheme(self) -> None:
        """Must detect PKCS#1 v1.5 padding scheme from algorithm operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["PKCS1", "PKCS#1 v1.5"],
                crypto_operations=["RSA_PKCS1_verify"],
            )

            detected_scheme = validator.detect_padding_scheme(algorithm)

            assert (
                detected_scheme == RSAPaddingScheme.PKCS1_V1_5
            ), "Must detect PKCS#1 v1.5 padding"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_detects_oaep_padding_scheme(self) -> None:
        """Must detect OAEP padding scheme from algorithm operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["OAEP", "Optimal Asymmetric Encryption"],
                crypto_operations=["RSA_OAEP_decrypt"],
            )

            detected_scheme = validator.detect_padding_scheme(algorithm)

            assert detected_scheme == RSAPaddingScheme.OAEP, "Must detect OAEP padding scheme"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_defaults_to_pkcs1_when_no_padding_indicators(self) -> None:
        """Must default to PKCS#1 v1.5 when no padding scheme indicators present."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
            )

            detected_scheme = validator.detect_padding_scheme(algorithm)

            assert (
                detected_scheme == RSAPaddingScheme.PKCS1_V1_5
            ), "Must default to PKCS#1 v1.5"
        finally:
            if temp_path.exists():
                temp_path.unlink()


class TestHashAlgorithmDetection:
    """Production tests for hash algorithm detection."""

    def test_detects_sha256_hash_algorithm(self) -> None:
        """Must detect SHA-256 hash algorithm from crypto operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["SHA256", "SHA-256"],
                crypto_operations=["CryptHashData SHA256"],
            )

            detected_hash = validator.detect_hash_algorithm(algorithm)

            assert detected_hash == "SHA256", "Must detect SHA-256 hash algorithm"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_detects_sha512_hash_algorithm(self) -> None:
        """Must detect SHA-512 hash algorithm from crypto operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["SHA512"],
                crypto_operations=[],
            )

            detected_hash = validator.detect_hash_algorithm(algorithm)

            assert detected_hash == "SHA512", "Must detect SHA-512 hash algorithm"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_detects_md5_hash_algorithm(self) -> None:
        """Must detect MD5 hash algorithm from crypto operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=["MD5"],
                crypto_operations=["MD5_Update"],
            )

            detected_hash = validator.detect_hash_algorithm(algorithm)

            assert detected_hash == "MD5", "Must detect MD5 hash algorithm"
        finally:
            if temp_path.exists():
                temp_path.unlink()

    def test_defaults_to_sha256_when_no_hash_indicators(self) -> None:
        """Must default to SHA-256 when no hash algorithm indicators present."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        temp_path = Path(tempfile.gettempdir()) / "temp_validator.exe"
        temp_path.write_bytes(b"MZ" + b"\x00" * 1000)

        try:
            validator = RSAKeyValidator(str(temp_path))

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.RSA_SIGNATURE,
                offset=0x1000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
            )

            detected_hash = validator.detect_hash_algorithm(algorithm)

            assert detected_hash == "SHA256", "Must default to SHA-256"
        finally:
            if temp_path.exists():
                temp_path.unlink()


class TestRSASignatureVerification:
    """Production tests for real RSA signature verification."""

    def test_verifies_valid_rsa_pkcs1_sha256_signature(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must perform real RSA signature verification with PKCS#1 v1.5 and SHA-256."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_2048_65537

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_header = bytearray(512)
        pe_header[:2] = b"MZ"
        pe_binary = bytes(pe_header) + b"\x00" * 1024 + der_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_sig_pkcs1.exe"
        binary_path.write_bytes(pe_binary)

        message = b"LICENSE-KEY-DATA-12345"
        signature = private_key.sign(message, padding.PKCS1v15(), hashes.SHA256())
        license_data = message + signature

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_PKCS1_verify", "SHA256_Update"],
        )

        result = validator.validate_license_key(license_data.hex(), algorithm)

        assert result is True, "Must validate correct RSA-PKCS#1-SHA256 signature"

    def test_verifies_valid_rsa_pss_sha512_signature(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must perform real RSA signature verification with PSS and SHA-512."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_2048_65537

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_sig_pss.exe"
        binary_path.write_bytes(pe_binary)

        message = b"PREMIUM-LICENSE-ACTIVATED"
        signature = private_key.sign(
            message,
            padding.PSS(mgf=padding.MGF1(hashes.SHA512()), salt_length=padding.PSS.MAX_LENGTH),
            hashes.SHA512(),
        )
        license_data = message + signature

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PSS", "SHA512"],
            crypto_operations=["RSA_PSS_verify", "SHA512_Update"],
        )

        result = validator.validate_license_key(license_data.hex(), algorithm)

        assert result is True, "Must validate correct RSA-PSS-SHA512 signature"

    def test_rejects_invalid_rsa_signature_wrong_key(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must reject RSA signature signed with wrong key."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key_1, key_size, exponent = rsa_key_2048_65537

        public_key_1 = private_key_1.public_key()
        der_key_1 = public_key_1.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key_1 + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_sig_wrong.exe"
        binary_path.write_bytes(pe_binary)

        private_key_2 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        message = b"LICENSE-KEY-DATA-12345"
        signature = private_key_2.sign(message, padding.PKCS1v15(), hashes.SHA256())
        license_data = message + signature

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_PKCS1_verify"],
        )

        result = validator.validate_license_key(license_data.hex(), algorithm)

        assert result is False, "Must reject signature signed with different key"

    def test_rejects_invalid_rsa_signature_tampered_message(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must reject RSA signature when message is tampered."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_2048_65537

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_sig_tampered.exe"
        binary_path.write_bytes(pe_binary)

        message = b"LICENSE-KEY-DATA-12345"
        signature = private_key.sign(message, padding.PKCS1v15(), hashes.SHA256())

        tampered_message = b"LICENSE-KEY-DATA-99999"
        license_data = tampered_message + signature

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_PKCS1_verify"],
        )

        result = validator.validate_license_key(license_data.hex(), algorithm)

        assert result is False, "Must reject signature when message is tampered"

    def test_verifies_signature_with_multiple_keys_finds_correct_one(
        self, temp_binary_dir: Path
    ) -> None:
        """Must verify signature by trying multiple extracted keys and finding correct one."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        correct_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        decoy_key_1 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        decoy_key_2 = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        correct_pub = correct_key.public_key().public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        decoy_pub_1 = decoy_key_1.public_key().public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        decoy_pub_2 = decoy_key_2.public_key().public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = (
            b"MZ"
            + b"\x00" * 1024
            + decoy_pub_1
            + b"\x00" * 512
            + correct_pub
            + b"\x00" * 512
            + decoy_pub_2
            + b"\x00" * 2048
        )

        binary_path = temp_binary_dir / "test_multi_key.exe"
        binary_path.write_bytes(pe_binary)

        message = b"MULTI-KEY-LICENSE-TEST"
        signature = correct_key.sign(message, padding.PKCS1v15(), hashes.SHA256())
        license_data = message + signature

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_PKCS1_verify"],
        )

        result = validator.validate_license_key(license_data.hex(), algorithm)

        assert result is True, "Must find and verify with correct key among multiple keys"


class TestEdgeCasesAndNonStandardImplementations:
    """Production tests for edge cases and non-standard RSA implementations."""

    def test_handles_custom_rsa_implementation_non_standard_exponent(
        self, temp_binary_dir: Path, rsa_key_4096_17: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must handle custom RSA implementation with non-standard exponent (e=17)."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_4096_17

        assert exponent == 17, "Test requires e=17"

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key + b"\x00" * 4096

        binary_path = temp_binary_dir / "test_custom_exp.exe"
        binary_path.write_bytes(pe_binary)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        custom_exp_found = False
        for key_info in extracted_keys:
            if key_info.exponent == 17 and key_info.key_size == 4096:
                custom_exp_found = True
                break

        assert custom_exp_found, "Must extract RSA key with custom exponent e=17"

    def test_handles_embedded_certificate_chain(self, temp_binary_dir: Path) -> None:
        """Must handle embedded certificate chains and extract correct RSA key."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        from cryptography import x509
        from cryptography.x509.oid import NameOID

        root_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        intermediate_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        leaf_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )

        root_name = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "Root CA")])
        root_cert = (
            x509.CertificateBuilder()
            .subject_name(root_name)
            .issuer_name(root_name)
            .public_key(root_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
            .not_valid_after(datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=365))
            .sign(root_key, hashes.SHA256(), default_backend())
        )

        intermediate_name = x509.Name(
            [x509.NameAttribute(NameOID.COMMON_NAME, "Intermediate CA")]
        )
        intermediate_cert = (
            x509.CertificateBuilder()
            .subject_name(intermediate_name)
            .issuer_name(root_name)
            .public_key(intermediate_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
            .not_valid_after(datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=365))
            .sign(root_key, hashes.SHA256(), default_backend())
        )

        leaf_name = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "license.app.com")])
        leaf_cert = (
            x509.CertificateBuilder()
            .subject_name(leaf_name)
            .issuer_name(intermediate_name)
            .public_key(leaf_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.datetime.now(datetime.timezone.utc))
            .not_valid_after(datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=365))
            .sign(intermediate_key, hashes.SHA256(), default_backend())
        )

        root_pem = root_cert.public_bytes(serialization.Encoding.PEM)
        intermediate_pem = intermediate_cert.public_bytes(serialization.Encoding.PEM)
        leaf_pem = leaf_cert.public_bytes(serialization.Encoding.PEM)

        pe_binary = (
            b"MZ" + b"\x00" * 1024 + root_pem + intermediate_pem + leaf_pem + b"\x00" * 2048
        )

        binary_path = temp_binary_dir / "test_cert_chain.exe"
        binary_path.write_bytes(pe_binary)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        assert len(extracted_keys) >= 3, "Must extract all keys from certificate chain"

        cert_sources = [key.source for key in extracted_keys]
        assert any(
            "x509" in src.lower() or "certificate" in src.lower() for src in cert_sources
        ), "Must identify certificate sources"

    def test_detects_weak_rsa_key_1024bit_with_e3(
        self, temp_binary_dir: Path, rsa_key_1024_3: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must detect weak RSA key (1024-bit with e=3) and mark as weak."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_1024_3

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_weak_key.exe"
        binary_path.write_bytes(pe_binary)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        weak_key_found = False
        for key_info in extracted_keys:
            if key_info.key_size == 1024 and key_info.exponent == 3:
                assert (
                    key_info.is_weak is True
                ), "Must mark 1024-bit key with e=3 as weak"
                assert (
                    key_info.weakness_reason is not None
                ), "Must provide weakness reason"
                weak_key_found = True
                break

        assert weak_key_found, "Must detect and mark weak RSA key"

    def test_integrates_with_pycryptodome_for_cryptographic_operations(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must integrate with cryptography library for real cryptographic operations."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_2048_65537

        public_key = private_key.public_key()
        public_numbers = public_key.public_numbers()

        reconstructed_key = RSAPublicNumbers(public_numbers.e, public_numbers.n).public_key(
            default_backend()
        )

        message = b"CRYPTOGRAPHY-INTEGRATION-TEST"
        signature = private_key.sign(message, padding.PKCS1v15(), hashes.SHA256())

        try:
            reconstructed_key.verify(signature, message, padding.PKCS1v15(), hashes.SHA256())
            verification_successful = True
        except Exception:
            verification_successful = False

        assert (
            verification_successful
        ), "Must integrate with cryptography library for real operations"

    def test_validates_non_hex_license_key_format(
        self, temp_binary_dir: Path, rsa_key_2048_65537: tuple[rsa.RSAPrivateKey, int, int]
    ) -> None:
        """Must handle non-hex license key formats (base64, custom encoding)."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key, key_size, exponent = rsa_key_2048_65537

        public_key = private_key.public_key()
        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1536 + der_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_non_hex.exe"
        binary_path.write_bytes(pe_binary)

        message = b"NON-HEX-LICENSE-KEY"
        signature = private_key.sign(message, padding.PKCS1v15(), hashes.SHA256())
        license_data = message + signature

        license_key_non_hex = license_data.hex() + "ZZZZ"

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_PKCS1_verify"],
        )

        result = validator.validate_license_key(license_key_non_hex, algorithm)

        assert result is False or result is True, "Must handle non-hex formats gracefully"


class TestRegressionAndValidation:
    """Regression tests ensuring existing functionality continues to work."""

    def test_length_check_no_longer_only_validation(self, temp_binary_dir: Path) -> None:
        """Must NOT accept license key based solely on length >= 16 chars."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        generator = RealBinaryGenerator()
        binary_data = generator.create_pe_with_rsa_key_der(2048, 65537)

        binary_path = temp_binary_dir / "test_length_only.exe"
        binary_path.write_bytes(binary_data)

        validator = RSAKeyValidator(str(binary_path))

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=["PKCS1", "SHA256"],
            crypto_operations=["RSA_verify"],
        )

        invalid_key_16_chars = "1234567890ABCDEF"

        result = validator.validate_license_key(invalid_key_16_chars, algorithm)

        assert (
            result is False
        ), "Must NOT validate based on length only - real RSA verification required"

    def test_multiple_format_extraction_produces_consistent_results(
        self, temp_binary_dir: Path
    ) -> None:
        """Must produce consistent RSA key extraction across different formats."""
        if not CRYPTOGRAPHY_AVAILABLE:
            pytest.skip("cryptography library required")

        private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048, backend=default_backend()
        )
        public_key = private_key.public_key()
        public_numbers = public_key.public_numbers()

        der_key = public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        pem_key = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        pe_binary = b"MZ" + b"\x00" * 1024 + der_key + b"\x00" * 512 + pem_key + b"\x00" * 2048

        binary_path = temp_binary_dir / "test_consistency.exe"
        binary_path.write_bytes(pe_binary)

        validator = RSAKeyValidator(str(binary_path))
        extracted_keys = validator.extract_rsa_keys()

        moduli = [key.modulus for key in extracted_keys]
        exponents = [key.exponent for key in extracted_keys]

        assert (
            public_numbers.n in moduli
        ), "Must extract same modulus from different formats"
        assert (
            public_numbers.e in exponents
        ), "Must extract same exponent from different formats"

    def test_error_handling_for_missing_cryptography_library(
        self, temp_binary_dir: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Must handle missing cryptography library gracefully."""
        binary_path = temp_binary_dir / "test_no_crypto.exe"
        binary_path.write_bytes(b"MZ" + b"\x00" * 2048)

        if not CRYPTOGRAPHY_AVAILABLE:
            validator = RSAKeyValidator(str(binary_path))
            keys = validator.extract_rsa_keys()
            assert len(keys) == 0, "Must return empty list when cryptography unavailable"
        else:
            pytest.skip("Test requires cryptography to be unavailable")
