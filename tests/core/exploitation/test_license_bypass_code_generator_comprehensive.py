"""Comprehensive production-ready tests for LicenseBypassCodeGenerator.

Validates actual license bypass code generation capabilities, assembly code correctness,
multi-architecture support, and proper calling convention implementation for defeating
real software licensing protections.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import struct
from typing import Any

import pytest

from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator


class TestLicenseBypassCodeGeneratorInitialization:
    """Test code generator initialization and configuration."""

    def test_generator_initializes_x86_64_windows(self) -> None:
        """Generator initializes with x86_64 Windows configuration."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert gen.architecture == "x86_64"
        assert gen.platform == "windows"
        assert len(gen.generated_patches) == 0
        assert "x86_64" in gen.calling_conventions

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert cc_info["shadow_space"] == 32
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_x86_64_linux(self) -> None:
        """Generator initializes with x86_64 Linux configuration."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")

        assert gen.architecture == "x86_64"
        assert gen.platform == "linux"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert cc_info["shadow_space"] == 0
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_x86_windows(self) -> None:
        """Generator initializes with x86 Windows configuration."""
        gen = LicenseBypassCodeGenerator("x86", "windows")

        assert gen.architecture == "x86"
        assert gen.platform == "windows"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["calling"] == "cdecl"
        assert cc_info["stack_align"] == 4

    def test_generator_initializes_arm64(self) -> None:
        """Generator initializes with ARM64 configuration."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")

        assert gen.architecture == "arm64"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_arm(self) -> None:
        """Generator initializes with ARM configuration."""
        gen = LicenseBypassCodeGenerator("arm", "linux")

        assert gen.architecture == "arm"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["r0", "r1", "r2", "r3"]
        assert cc_info["stack_align"] == 8


class TestLicenseCheckBypassGeneration:
    """Test license check bypass code generation for defeating license validation."""

    def test_x86_64_windows_license_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows license bypass generates correct stack-preserving code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "license_check_bypass"
        assert patches[0]["address"] == 0x401000
        assert patches[0]["preserve_stack"] is True

    def test_x86_64_linux_license_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux license bypass generates correct stack-preserving code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_64_license_bypass_without_stack_preservation(self) -> None:
        """x86_64 license bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert len(code) == 7
        assert code == b"\x48\x31\xc0\x48\xff\xc0\xc3"

    def test_x86_license_bypass_with_stack_preservation(self) -> None:
        """x86 license bypass generates correct stack frame code."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x89\xe5" in code
        assert b"\x31\xc0" in code
        assert b"\x40" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_license_bypass_without_stack_preservation(self) -> None:
        """x86 license bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert len(code) == 4
        assert code == b"\x31\xc0\x40\xc3"

    def test_arm64_license_bypass_generates_valid_code(self) -> None:
        """ARM64 license bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.startswith(b"\x20\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_license_bypass_generates_valid_code(self) -> None:
        """ARM license bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.startswith(b"\x01\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")

    def test_license_bypass_unsupported_architecture_raises_error(self) -> None:
        """License bypass for unsupported architecture raises ValueError."""
        gen = LicenseBypassCodeGenerator("mips", "linux")

        with pytest.raises(ValueError, match="Unsupported architecture: mips"):
            gen.generate_license_check_bypass(0x401000)


class TestTrialExtensionPatchGeneration:
    """Test trial period extension patch generation for defeating time-based licensing."""

    def test_x86_64_windows_trial_extension_with_stack_preservation(self) -> None:
        """x86_64 Windows trial extension generates correct code with stack preservation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x90" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "trial_extension"
        assert patches[0]["address"] == 0x402000

    def test_x86_64_linux_trial_extension_with_stack_preservation(self) -> None:
        """x86_64 Linux trial extension generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_trial_extension_without_stack_preservation(self) -> None:
        """x86 trial extension generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=False)

        assert b"\x31\xc0" in code
        assert b"\x90" in code
        assert code.endswith(b"\xc3")

    def test_arm64_trial_extension_generates_valid_code(self) -> None:
        """ARM64 trial extension generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert code.startswith(b"\x00\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_trial_extension_generates_valid_code(self) -> None:
        """ARM trial extension generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert code.startswith(b"\x00\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestActivationBypassGeneration:
    """Test activation bypass code generation for defeating product activation."""

    def test_x86_64_windows_activation_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows activation bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "activation_bypass"
        assert patches[0]["address"] == 0x403000

    def test_x86_64_linux_activation_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux activation bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_x86_activation_bypass_without_stack_preservation(self) -> None:
        """x86 activation bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=False)

        assert b"\xb8\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_arm64_activation_bypass_generates_valid_code(self) -> None:
        """ARM64 activation bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) == 8
        assert code.startswith(b"\x20\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_activation_bypass_generates_valid_code(self) -> None:
        """ARM activation bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) == 8
        assert code.startswith(b"\x01\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestSerialValidationBypassGeneration:
    """Test serial validation bypass generation for defeating serial number checks."""

    def test_x86_64_windows_serial_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows serial bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "serial_validation_bypass"

    def test_x86_64_linux_serial_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux serial bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert code.endswith(b"\xc3")

    def test_x86_serial_bypass_without_stack_preservation(self) -> None:
        """x86 serial bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=False)

        assert len(code) == 4
        assert code == b"\x31\xc0\x40\xc3"

    def test_arm64_serial_bypass_generates_valid_code(self) -> None:
        """ARM64 serial bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_serial_validation_bypass(0x404000)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_serial_bypass_generates_valid_code(self) -> None:
        """ARM serial bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_serial_validation_bypass(0x404000)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestHardwareIDSpoofGeneration:
    """Test hardware ID spoofing code generation for defeating hardware-locked licenses."""

    def test_x86_64_windows_hwid_spoof_with_stack_preservation(self) -> None:
        """x86_64 Windows HWID spoof generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        spoofed_hwid = b"SPOOF123"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xb8" in code
        assert spoofed_hwid in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "hardware_id_spoof"
        assert spoofed_hwid[:8].hex() in patches[0]["description"]

    def test_x86_64_linux_hwid_spoof_with_stack_preservation(self) -> None:
        """x86_64 Linux HWID spoof generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        spoofed_hwid = b"HWID5678"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\xb8" in code
        assert spoofed_hwid in code
        assert code.endswith(b"\xc3")

    def test_x86_hwid_spoof_with_short_hwid(self) -> None:
        """x86 HWID spoof pads short HWID values correctly."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        spoofed_hwid = b"AB"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=False)

        assert b"\xb8" in code
        assert len(code) >= 6

    def test_x86_hwid_spoof_with_long_hwid_truncates(self) -> None:
        """x86 HWID spoof truncates long HWID values to 4 bytes."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        spoofed_hwid = b"VERYLONGHWID123456"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=False)

        assert b"\xb8" in code
        assert b"VERY" in code
        assert b"LONG" not in code

    def test_arm64_hwid_spoof_generates_valid_code(self) -> None:
        """ARM64 HWID spoof generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        spoofed_hwid = b"ARM64HWD"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_hwid_spoof_generates_valid_code(self) -> None:
        """ARM HWID spoof generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        spoofed_hwid = b"ARMH"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestNOPPatchGeneration:
    """Test NOP patch generation for neutralizing protection code."""

    def test_x86_64_nop_patch_generates_correct_size(self) -> None:
        """x86_64 NOP patch generates exact size requested."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x90" * 16

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "nop_patch"
        assert patches[0]["size"] == 16

    def test_x86_nop_patch_generates_correct_size(self) -> None:
        """x86 NOP patch generates exact size requested."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_nop_patch(0x406000, 32)

        assert len(code) == 32
        assert code == b"\x90" * 32

    def test_arm64_nop_patch_generates_multiple_nops(self) -> None:
        """ARM64 NOP patch generates multiple 4-byte NOP instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x1f\x20\x03\xd5" * 4

    def test_arm_nop_patch_generates_multiple_nops(self) -> None:
        """ARM NOP patch generates multiple 4-byte NOP instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_nop_patch(0x406000, 12)

        assert len(code) == 12
        assert code == b"\x00\xf0\x20\xe3" * 3

    def test_nop_patch_single_byte(self) -> None:
        """NOP patch generates single NOP for x86/x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 1)

        assert len(code) == 1
        assert code == b"\x90"

    def test_nop_patch_large_size(self) -> None:
        """NOP patch handles large sizes correctly."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 256)

        assert len(code) == 256
        assert all(b == 0x90 for b in code)


class TestConditionalJumpPatchGeneration:
    """Test conditional jump patch generation for controlling license check flow."""

    def test_x86_64_always_jump_patch(self) -> None:
        """x86_64 always jump patch generates unconditional jump."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 1
        assert code == b"\xeb"

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "jump_patch"
        assert "always" in patches[0]["description"]

    def test_x86_64_never_jump_patch(self) -> None:
        """x86_64 never jump patch generates NOPs."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 2
        assert code == b"\x90\x90"

        patches = gen.get_generated_patches()
        assert "never" in patches[0]["description"]

    def test_x86_always_jump_patch(self) -> None:
        """x86 always jump patch generates unconditional jump."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert code == b"\xeb"

    def test_x86_never_jump_patch(self) -> None:
        """x86 never jump patch generates NOPs."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert code == b"\x90\x90"

    def test_arm64_always_jump_patch(self) -> None:
        """ARM64 always jump patch generates branch instruction."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 4
        assert code == b"\x00\x00\x00\x14"

    def test_arm64_never_jump_patch(self) -> None:
        """ARM64 never jump patch generates NOP."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 4
        assert code == b"\x1f\x20\x03\xd5"

    def test_arm_always_jump_patch(self) -> None:
        """ARM always jump patch generates branch instruction."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 4
        assert code == b"\x00\x00\x00\xea"

    def test_arm_never_jump_patch(self) -> None:
        """ARM never jump patch generates NOP."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 4
        assert code == b"\x00\xf0\x20\xe3"


class TestReturnValuePatchGeneration:
    """Test return value patch generation for forcing function return values."""

    def test_x86_64_windows_return_value_patch_returns_one(self) -> None:
        """x86_64 Windows return value patch forces return of 1."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 1, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xc7\xc0" in code
        assert struct.pack("<I", 1) in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "return_value_patch"
        assert "value to 1" in patches[0]["description"]

    def test_x86_64_return_value_patch_returns_custom_value(self) -> None:
        """x86_64 return value patch forces custom return value."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 0x12345678, preserve_stack=False)

        assert b"\x48\xc7\xc0" in code
        assert struct.pack("<I", 0x12345678) in code
        assert code.endswith(b"\xc3")

    def test_x86_return_value_patch_with_stack_preservation(self) -> None:
        """x86 return value patch preserves stack frame."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 42, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x89\xe5" in code
        assert b"\xb8" in code
        assert struct.pack("<I", 42) in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_return_value_patch_without_stack_preservation(self) -> None:
        """x86 return value patch generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 99, preserve_stack=False)

        assert b"\xb8" in code
        assert struct.pack("<I", 99) in code
        assert code.endswith(b"\xc3")

    def test_arm64_return_value_patch_generates_valid_code(self) -> None:
        """ARM64 return value patch generates valid instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_return_value_patch(0x408000, 1)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_return_value_patch_generates_valid_code(self) -> None:
        """ARM return value patch generates valid instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_return_value_patch(0x408000, 1)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")

    def test_return_value_patch_zero_value(self) -> None:
        """Return value patch handles zero return value."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 0, preserve_stack=False)

        assert struct.pack("<I", 0) in code

    def test_return_value_patch_negative_value(self) -> None:
        """Return value patch handles negative values as unsigned correctly."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 0xFFFFFFFF, preserve_stack=False)

        assert b"\xb8" in code
        assert struct.pack("<I", 0xFFFFFFFF) in code
        assert code.endswith(b"\xc3")


class TestPatchManagement:
    """Test patch tracking, export, and management functionality."""

    def test_get_generated_patches_returns_all_patches(self) -> None:
        """get_generated_patches returns all generated patches."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)
        gen.generate_activation_bypass(0x403000)

        patches = gen.get_generated_patches()
        assert len(patches) == 3
        assert patches[0]["type"] == "license_check_bypass"
        assert patches[1]["type"] == "trial_extension"
        assert patches[2]["type"] == "activation_bypass"

    def test_get_generated_patches_returns_copy(self) -> None:
        """get_generated_patches returns a copy to prevent external modification."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        patches1 = gen.get_generated_patches()
        patches2 = gen.get_generated_patches()

        assert patches1 is not patches2
        assert patches1 == patches2

    def test_clear_patches_removes_all_patches(self) -> None:
        """clear_patches removes all generated patches."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)
        assert len(gen.get_generated_patches()) == 2

        gen.clear_patches()
        assert len(gen.get_generated_patches()) == 0

    def test_export_patches_binary_format(self) -> None:
        """export_patches exports patches in binary format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("binary")

        assert export["architecture"] == "x86_64"
        assert export["platform"] == "windows"
        assert export["format"] == "binary"
        assert len(export["patches"]) == 1
        assert isinstance(export["patches"][0]["code"], bytes)

    def test_export_patches_hex_format(self) -> None:
        """export_patches exports patches in hex format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("hex")

        assert export["format"] == "hex"
        assert isinstance(export["patches"][0]["code"], str)
        assert export["patches"][0]["code"] == code.hex()

    def test_export_patches_asm_format(self) -> None:
        """export_patches exports patches in assembly format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("asm")

        assert export["format"] == "asm"
        assert isinstance(export["patches"][0]["code"], str)

    def test_patch_metadata_includes_all_fields(self) -> None:
        """Generated patches include all required metadata fields."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        patches = gen.get_generated_patches()
        patch = patches[0]

        assert "type" in patch
        assert "address" in patch
        assert "code" in patch
        assert "size" in patch
        assert "description" in patch
        assert "preserve_stack" in patch


class TestCallingConventionSupport:
    """Test proper calling convention implementation across platforms."""

    def test_windows_x86_64_calling_convention_parameters(self) -> None:
        """Windows x86_64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert cc_info["shadow_space"] == 32
        assert "rax" in cc_info["volatile_regs"]
        assert "rbx" in cc_info["nonvolatile_regs"]

    def test_linux_x86_64_calling_convention_parameters(self) -> None:
        """Linux x86_64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert cc_info["shadow_space"] == 0
        assert "rdi" in cc_info["volatile_regs"]
        assert "rbx" in cc_info["nonvolatile_regs"]

    def test_x86_calling_convention_cdecl(self) -> None:
        """x86 platforms use cdecl calling convention."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["calling"] == "cdecl"
        assert cc_info["cleanup"] == "caller"

    def test_arm64_calling_convention_parameters(self) -> None:
        """ARM64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]
        assert cc_info["stack_align"] == 16

    def test_arm_calling_convention_parameters(self) -> None:
        """ARM uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["r0", "r1", "r2", "r3"]
        assert cc_info["stack_align"] == 8


class TestMultiArchitectureCodeGeneration:
    """Test code generation consistency across multiple architectures."""

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("x86", "linux"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ])
    def test_all_architectures_generate_valid_license_bypass(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid license bypass code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) > 0
        assert isinstance(code, bytes)

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["size"] == len(code)

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ])
    def test_all_architectures_generate_valid_trial_extension(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid trial extension code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert isinstance(code, bytes)

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ])
    def test_all_architectures_generate_valid_activation_bypass(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid activation bypass code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) > 0
        assert isinstance(code, bytes)

    @pytest.mark.parametrize("arch", ["x86_64", "x86", "arm64", "arm"])
    def test_all_architectures_generate_valid_nop_patches(self, arch: str) -> None:
        """All supported architectures generate valid NOP patches."""
        gen = LicenseBypassCodeGenerator(arch, "linux")

        if arch in ("x86_64", "x86"):
            size = 16
        else:
            size = 16

        code = gen.generate_nop_patch(0x406000, size)
        assert len(code) == size


class TestCodeValidation:
    """Test validation of generated code correctness."""

    def test_x86_64_windows_stack_alignment_preserved(self) -> None:
        """x86_64 Windows code maintains 16-byte stack alignment."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert b"\x48\x83\xec\x28" in code
        assert b"\x48\x83\xc4\x28" in code

    def test_x86_64_linux_stack_frame_preserved(self) -> None:
        """x86_64 Linux code maintains proper stack frame."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x5d" in code

    def test_all_functions_return_properly(self) -> None:
        """All generated functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        code1 = gen.generate_license_check_bypass(0x401000)
        code2 = gen.generate_trial_extension_patch(0x402000)
        code3 = gen.generate_activation_bypass(0x403000)
        code4 = gen.generate_serial_validation_bypass(0x404000)

        assert code1.endswith(b"\xc3")
        assert code2.endswith(b"\xc3")
        assert code3.endswith(b"\xc3")
        assert code4.endswith(b"\xc3")

    def test_arm64_functions_end_with_return(self) -> None:
        """ARM64 functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")

        code = gen.generate_license_check_bypass(0x401000)
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_functions_end_with_return(self) -> None:
        """ARM functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("arm", "linux")

        code = gen.generate_license_check_bypass(0x401000)
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_zero_address_patch_generation(self) -> None:
        """Patches can be generated for address 0x0."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x0)

        assert len(code) > 0
        patches = gen.get_generated_patches()
        assert patches[0]["address"] == 0x0

    def test_high_address_patch_generation(self) -> None:
        """Patches can be generated for high memory addresses."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0xFFFFFFFF)

        assert len(code) > 0
        patches = gen.get_generated_patches()
        assert patches[0]["address"] == 0xFFFFFFFF

    def test_empty_hwid_spoof(self) -> None:
        """Hardware ID spoof handles empty HWID."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_hardware_id_spoof(0x405000, b"")

        assert len(code) > 0

    def test_single_byte_nop_patch(self) -> None:
        """NOP patch can generate single byte."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 1)

        assert len(code) == 1
        assert code == b"\x90"

    def test_multiple_patches_same_address(self) -> None:
        """Multiple patches can be generated for same address."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        code1 = gen.generate_license_check_bypass(0x401000)
        code2 = gen.generate_activation_bypass(0x401000)

        patches = gen.get_generated_patches()
        assert len(patches) == 2
        assert patches[0]["address"] == 0x401000
        assert patches[1]["address"] == 0x401000

    def test_unsupported_architecture_raises_error(self) -> None:
        """Unsupported architecture raises appropriate error."""
        gen = LicenseBypassCodeGenerator("powerpc", "linux")

        with pytest.raises(ValueError, match="Unsupported architecture"):
            gen.generate_license_check_bypass(0x401000)


class TestRealWorldScenarios:
    """Test real-world license cracking scenarios."""

    def test_complete_license_bypass_workflow(self) -> None:
        """Complete workflow for bypassing all license checks in application."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        license_check_patch = gen.generate_license_check_bypass(0x401000)
        serial_check_patch = gen.generate_serial_validation_bypass(0x402000)
        activation_patch = gen.generate_activation_bypass(0x403000)
        trial_patch = gen.generate_trial_extension_patch(0x404000)
        hwid_patch = gen.generate_hardware_id_spoof(0x405000, b"CRACKED1")

        assert all(len(p) > 0 for p in [license_check_patch, serial_check_patch, activation_patch, trial_patch, hwid_patch])

        patches = gen.get_generated_patches()
        assert len(patches) == 5

        exported = gen.export_patches("hex")
        assert len(exported["patches"]) == 5

    def test_multi_protection_layer_bypass(self) -> None:
        """Bypass multiple protection layers with different techniques."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_conditional_jump_patch(0x401000, always_jump=True)
        gen.generate_nop_patch(0x401050, 20)
        gen.generate_return_value_patch(0x402000, 1)
        gen.generate_license_check_bypass(0x403000)

        patches = gen.get_generated_patches()
        assert len(patches) == 4

        patch_types = [p["type"] for p in patches]
        assert "jump_patch" in patch_types
        assert "nop_patch" in patch_types
        assert "return_value_patch" in patch_types
        assert "license_check_bypass" in patch_types

    def test_trial_reset_full_workflow(self) -> None:
        """Complete trial reset bypass workflow."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        time_check_nop = gen.generate_nop_patch(0x401000, 16)
        trial_extension = gen.generate_trial_extension_patch(0x402000)
        expiry_return = gen.generate_return_value_patch(0x403000, 0)

        patches = gen.get_generated_patches()
        assert len(patches) == 3

        assert all(len(p["code"]) > 0 for p in patches)

    def test_hardware_locked_license_bypass(self) -> None:
        """Bypass hardware-locked license with HWID spoofing."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        hwid_spoof = gen.generate_hardware_id_spoof(0x401000, b"VALID123")
        hwid_check_bypass = gen.generate_license_check_bypass(0x402000)

        patches = gen.get_generated_patches()
        assert len(patches) == 2
        assert patches[0]["type"] == "hardware_id_spoof"
        assert patches[1]["type"] == "license_check_bypass"

    def test_cross_platform_patch_generation(self) -> None:
        """Generate patches for both Windows and Linux versions of same software."""
        gen_win = LicenseBypassCodeGenerator("x86_64", "windows")
        gen_linux = LicenseBypassCodeGenerator("x86_64", "linux")

        win_patch = gen_win.generate_license_check_bypass(0x401000)
        linux_patch = gen_linux.generate_license_check_bypass(0x401000)

        assert win_patch != linux_patch
        assert len(win_patch) > 0
        assert len(linux_patch) > 0

    def test_multi_architecture_deployment(self) -> None:
        """Generate patches for multiple architectures of same application."""
        gen_x64 = LicenseBypassCodeGenerator("x86_64", "windows")
        gen_x86 = LicenseBypassCodeGenerator("x86", "windows")
        gen_arm = LicenseBypassCodeGenerator("arm64", "linux")

        patch_x64 = gen_x64.generate_license_check_bypass(0x401000)
        patch_x86 = gen_x86.generate_license_check_bypass(0x401000)
        patch_arm = gen_arm.generate_license_check_bypass(0x401000)

        assert len(patch_x64) > 0
        assert len(patch_x86) > 0
        assert len(patch_arm) > 0

        assert patch_x64 != patch_x86 != patch_arm
