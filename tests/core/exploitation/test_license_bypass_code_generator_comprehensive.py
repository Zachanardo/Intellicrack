"""Comprehensive production-ready tests for LicenseBypassCodeGenerator.

Validates actual license bypass code generation capabilities, assembly code correctness,
multi-architecture support, and proper calling convention implementation for defeating
real software licensing protections.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import struct
from typing import Any, Dict, List, Type

import pytest

from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator


class TestLicenseBypassCodeGeneratorInitialization:
    """Test code generator initialization and configuration."""

    def test_generator_initializes_x86_64_windows(self) -> None:
        """Generator initializes with x86_64 Windows configuration."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert gen.architecture == "x86_64"
        assert gen.platform == "windows"
        assert len(gen.generated_patches) == 0
        assert "x86_64" in gen.calling_conventions

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert cc_info["shadow_space"] == 32
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_x86_64_linux(self) -> None:
        """Generator initializes with x86_64 Linux configuration."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")

        assert gen.architecture == "x86_64"
        assert gen.platform == "linux"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert cc_info["shadow_space"] == 0
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_x86_windows(self) -> None:
        """Generator initializes with x86 Windows configuration."""
        gen = LicenseBypassCodeGenerator("x86", "windows")

        assert gen.architecture == "x86"
        assert gen.platform == "windows"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["calling"] == "cdecl"
        assert cc_info["stack_align"] == 4

    def test_generator_initializes_arm64(self) -> None:
        """Generator initializes with ARM64 configuration."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")

        assert gen.architecture == "arm64"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]
        assert cc_info["stack_align"] == 16

    def test_generator_initializes_arm(self) -> None:
        """Generator initializes with ARM configuration."""
        gen = LicenseBypassCodeGenerator("arm", "linux")

        assert gen.architecture == "arm"

        cc_info = gen.get_calling_convention_info()
        assert cc_info["int_params"] == ["r0", "r1", "r2", "r3"]
        assert cc_info["stack_align"] == 8


class TestLicenseCheckBypassGeneration:
    """Test license check bypass code generation for defeating license validation."""

    def test_x86_64_windows_license_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows license bypass generates correct stack-preserving code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "license_check_bypass"
        assert patches[0]["address"] == 0x401000
        assert patches[0]["preserve_stack"] is True

    def test_x86_64_linux_license_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux license bypass generates correct stack-preserving code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_64_license_bypass_without_stack_preservation(self) -> None:
        """x86_64 license bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert len(code) == 7
        assert code == b"\x48\x31\xc0\x48\xff\xc0\xc3"

    def test_x86_license_bypass_with_stack_preservation(self) -> None:
        """x86 license bypass generates correct stack frame code."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x89\xe5" in code
        assert b"\x31\xc0" in code
        assert b"\x40" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_license_bypass_without_stack_preservation(self) -> None:
        """x86 license bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert len(code) == 4
        assert code == b"\x31\xc0\x40\xc3"

    def test_arm64_license_bypass_generates_valid_code(self) -> None:
        """ARM64 license bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.startswith(b"\x20\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_license_bypass_generates_valid_code(self) -> None:
        """ARM license bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.startswith(b"\x01\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")

    def test_license_bypass_unsupported_architecture_raises_error(self) -> None:
        """License bypass for unsupported architecture raises ValueError."""
        gen = LicenseBypassCodeGenerator("mips", "linux")

        with pytest.raises(ValueError, match="Unsupported architecture: mips"):
            gen.generate_license_check_bypass(0x401000)


class TestTrialExtensionPatchGeneration:
    """Test trial period extension patch generation for defeating time-based licensing."""

    def test_x86_64_windows_trial_extension_with_stack_preservation(self) -> None:
        """x86_64 Windows trial extension generates correct code with stack preservation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x90" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "trial_extension"
        assert patches[0]["address"] == 0x402000

    def test_x86_64_linux_trial_extension_with_stack_preservation(self) -> None:
        """x86_64 Linux trial extension generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_trial_extension_without_stack_preservation(self) -> None:
        """x86 trial extension generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=False)

        assert b"\x31\xc0" in code
        assert b"\x90" in code
        assert code.endswith(b"\xc3")

    def test_arm64_trial_extension_generates_valid_code(self) -> None:
        """ARM64 trial extension generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert code.startswith(b"\x00\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_trial_extension_generates_valid_code(self) -> None:
        """ARM trial extension generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert code.startswith(b"\x00\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestActivationBypassGeneration:
    """Test activation bypass code generation for defeating product activation."""

    def test_x86_64_windows_activation_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows activation bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "activation_bypass"
        assert patches[0]["address"] == 0x403000

    def test_x86_64_linux_activation_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux activation bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_x86_activation_bypass_without_stack_preservation(self) -> None:
        """x86 activation bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=False)

        assert b"\xb8\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_arm64_activation_bypass_generates_valid_code(self) -> None:
        """ARM64 activation bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) == 8
        assert code.startswith(b"\x20\x00\x80\xd2")
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_activation_bypass_generates_valid_code(self) -> None:
        """ARM activation bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) == 8
        assert code.startswith(b"\x01\x00\xa0\xe3")
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestSerialValidationBypassGeneration:
    """Test serial validation bypass generation for defeating serial number checks."""

    def test_x86_64_windows_serial_bypass_with_stack_preservation(self) -> None:
        """x86_64 Windows serial bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "serial_validation_bypass"

    def test_x86_64_linux_serial_bypass_with_stack_preservation(self) -> None:
        """x86_64 Linux serial bypass generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert b"\x48\x31\xc0" in code
        assert code.endswith(b"\xc3")

    def test_x86_serial_bypass_without_stack_preservation(self) -> None:
        """x86 serial bypass generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=False)

        assert len(code) == 4
        assert code == b"\x31\xc0\x40\xc3"

    def test_arm64_serial_bypass_generates_valid_code(self) -> None:
        """ARM64 serial bypass generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_serial_validation_bypass(0x404000)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_serial_bypass_generates_valid_code(self) -> None:
        """ARM serial bypass generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_serial_validation_bypass(0x404000)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestHardwareIDSpoofGeneration:
    """Test hardware ID spoofing code generation for defeating hardware-locked licenses."""

    def test_x86_64_windows_hwid_spoof_with_stack_preservation(self) -> None:
        """x86_64 Windows HWID spoof generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        spoofed_hwid = b"SPOOF123"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xb8" in code
        assert spoofed_hwid in code
        assert b"\x48\x83\xc4\x28" in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "hardware_id_spoof"
        assert spoofed_hwid[:8].hex() in patches[0]["description"]

    def test_x86_64_linux_hwid_spoof_with_stack_preservation(self) -> None:
        """x86_64 Linux HWID spoof generates correct code."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        spoofed_hwid = b"HWID5678"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x48\xb8" in code
        assert spoofed_hwid in code
        assert code.endswith(b"\xc3")

    def test_x86_hwid_spoof_with_short_hwid(self) -> None:
        """x86 HWID spoof pads short HWID values correctly."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        spoofed_hwid = b"AB"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=False)

        assert b"\xb8" in code
        assert len(code) >= 6

    def test_x86_hwid_spoof_with_long_hwid_truncates(self) -> None:
        """x86 HWID spoof truncates long HWID values to 4 bytes."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        spoofed_hwid = b"VERYLONGHWID123456"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=False)

        assert b"\xb8" in code
        assert b"VERY" in code
        assert b"LONG" not in code

    def test_arm64_hwid_spoof_generates_valid_code(self) -> None:
        """ARM64 HWID spoof generates valid ARM64 instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        spoofed_hwid = b"ARM64HWD"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_hwid_spoof_generates_valid_code(self) -> None:
        """ARM HWID spoof generates valid ARM instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        spoofed_hwid = b"ARMH"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestNOPPatchGeneration:
    """Test NOP patch generation for neutralizing protection code."""

    def test_x86_64_nop_patch_generates_correct_size(self) -> None:
        """x86_64 NOP patch generates exact size requested."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x90" * 16

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "nop_patch"
        assert patches[0]["size"] == 16

    def test_x86_nop_patch_generates_correct_size(self) -> None:
        """x86 NOP patch generates exact size requested."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_nop_patch(0x406000, 32)

        assert len(code) == 32
        assert code == b"\x90" * 32

    def test_arm64_nop_patch_generates_multiple_nops(self) -> None:
        """ARM64 NOP patch generates multiple 4-byte NOP instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x1f\x20\x03\xd5" * 4

    def test_arm_nop_patch_generates_multiple_nops(self) -> None:
        """ARM NOP patch generates multiple 4-byte NOP instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_nop_patch(0x406000, 12)

        assert len(code) == 12
        assert code == b"\x00\xf0\x20\xe3" * 3

    def test_nop_patch_single_byte(self) -> None:
        """NOP patch generates single NOP for x86/x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 1)

        assert len(code) == 1
        assert code == b"\x90"

    def test_nop_patch_large_size(self) -> None:
        """NOP patch handles large sizes correctly."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 256)

        assert len(code) == 256
        assert all(b == 0x90 for b in code)


class TestConditionalJumpPatchGeneration:
    """Test conditional jump patch generation for controlling license check flow."""

    def test_x86_64_always_jump_patch(self) -> None:
        """x86_64 always jump patch generates unconditional jump."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 1
        assert code == b"\xeb"

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "jump_patch"
        assert "always" in patches[0]["description"]

    def test_x86_64_never_jump_patch(self) -> None:
        """x86_64 never jump patch generates NOPs."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 2
        assert code == b"\x90\x90"

        patches = gen.get_generated_patches()
        assert "never" in patches[0]["description"]

    def test_x86_always_jump_patch(self) -> None:
        """x86 always jump patch generates unconditional jump."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert code == b"\xeb"

    def test_x86_never_jump_patch(self) -> None:
        """x86 never jump patch generates NOPs."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert code == b"\x90\x90"

    def test_arm64_always_jump_patch(self) -> None:
        """ARM64 always jump patch generates branch instruction."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 4
        assert code == b"\x00\x00\x00\x14"

    def test_arm64_never_jump_patch(self) -> None:
        """ARM64 never jump patch generates NOP."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 4
        assert code == b"\x1f\x20\x03\xd5"

    def test_arm_always_jump_patch(self) -> None:
        """ARM always jump patch generates branch instruction."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 4
        assert code == b"\x00\x00\x00\xea"

    def test_arm_never_jump_patch(self) -> None:
        """ARM never jump patch generates NOP."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert len(code) == 4
        assert code == b"\x00\xf0\x20\xe3"


class TestReturnValuePatchGeneration:
    """Test return value patch generation for forcing function return values."""

    def test_x86_64_windows_return_value_patch_returns_one(self) -> None:
        """x86_64 Windows return value patch forces return of 1."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 1, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert b"\x48\xc7\xc0" in code
        assert struct.pack("<I", 1) in code
        assert code.endswith(b"\xc3")

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "return_value_patch"
        assert "value to 1" in patches[0]["description"]

    def test_x86_64_return_value_patch_returns_custom_value(self) -> None:
        """x86_64 return value patch forces custom return value."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 0x12345678, preserve_stack=False)

        assert b"\x48\xc7\xc0" in code
        assert struct.pack("<I", 0x12345678) in code
        assert code.endswith(b"\xc3")

    def test_x86_return_value_patch_with_stack_preservation(self) -> None:
        """x86 return value patch preserves stack frame."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 42, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x89\xe5" in code
        assert b"\xb8" in code
        assert struct.pack("<I", 42) in code
        assert b"\x5d" in code
        assert code.endswith(b"\xc3")

    def test_x86_return_value_patch_without_stack_preservation(self) -> None:
        """x86 return value patch generates minimal code without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 99, preserve_stack=False)

        assert b"\xb8" in code
        assert struct.pack("<I", 99) in code
        assert code.endswith(b"\xc3")

    def test_arm64_return_value_patch_generates_valid_code(self) -> None:
        """ARM64 return value patch generates valid instructions."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_return_value_patch(0x408000, 1)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_return_value_patch_generates_valid_code(self) -> None:
        """ARM return value patch generates valid instructions."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_return_value_patch(0x408000, 1)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")

    def test_return_value_patch_zero_value(self) -> None:
        """Return value patch handles zero return value."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x408000, 0, preserve_stack=False)

        assert struct.pack("<I", 0) in code

    def test_return_value_patch_negative_value(self) -> None:
        """Return value patch handles negative values as unsigned correctly."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x408000, 0xFFFFFFFF, preserve_stack=False)

        assert b"\xb8" in code
        assert struct.pack("<I", 0xFFFFFFFF) in code
        assert code.endswith(b"\xc3")


class TestPatchManagement:
    """Test patch tracking, export, and management functionality."""

    def test_get_generated_patches_returns_all_patches(self) -> None:
        """get_generated_patches returns all generated patches."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)
        gen.generate_activation_bypass(0x403000)

        patches = gen.get_generated_patches()
        assert len(patches) == 3
        assert patches[0]["type"] == "license_check_bypass"
        assert patches[1]["type"] == "trial_extension"
        assert patches[2]["type"] == "activation_bypass"

    def test_get_generated_patches_returns_copy(self) -> None:
        """get_generated_patches returns a copy to prevent external modification."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        patches1 = gen.get_generated_patches()
        patches2 = gen.get_generated_patches()

        assert patches1 is not patches2
        assert patches1 == patches2

    def test_clear_patches_removes_all_patches(self) -> None:
        """clear_patches removes all generated patches."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)
        assert len(gen.get_generated_patches()) == 2

        gen.clear_patches()
        assert len(gen.get_generated_patches()) == 0

    def test_export_patches_binary_format(self) -> None:
        """export_patches exports patches in binary format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("binary")

        assert export["architecture"] == "x86_64"
        assert export["platform"] == "windows"
        assert export["format"] == "binary"
        assert len(export["patches"]) == 1
        assert isinstance(export["patches"][0]["code"], bytes)

    def test_export_patches_hex_format(self) -> None:
        """export_patches exports patches in hex format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("hex")

        assert export["format"] == "hex"
        assert isinstance(export["patches"][0]["code"], str)
        assert export["patches"][0]["code"] == code.hex()

    def test_export_patches_asm_format(self) -> None:
        """export_patches exports patches in assembly format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("asm")

        assert export["format"] == "asm"
        assert isinstance(export["patches"][0]["code"], str)

    def test_patch_metadata_includes_all_fields(self) -> None:
        """Generated patches include all required metadata fields."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        patches = gen.get_generated_patches()
        patch = patches[0]

        assert "type" in patch
        assert "address" in patch
        assert "code" in patch
        assert "size" in patch
        assert "description" in patch
        assert "preserve_stack" in patch


class TestCallingConventionSupport:
    """Test proper calling convention implementation across platforms."""

    def test_windows_x86_64_calling_convention_parameters(self) -> None:
        """Windows x86_64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert cc_info["shadow_space"] == 32
        assert "rax" in cc_info["volatile_regs"]
        assert "rbx" in cc_info["nonvolatile_regs"]

    def test_linux_x86_64_calling_convention_parameters(self) -> None:
        """Linux x86_64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert cc_info["shadow_space"] == 0
        assert "rdi" in cc_info["volatile_regs"]
        assert "rbx" in cc_info["nonvolatile_regs"]

    def test_x86_calling_convention_cdecl(self) -> None:
        """x86 platforms use cdecl calling convention."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["calling"] == "cdecl"
        assert cc_info["cleanup"] == "caller"

    def test_arm64_calling_convention_parameters(self) -> None:
        """ARM64 uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]
        assert cc_info["stack_align"] == 16

    def test_arm_calling_convention_parameters(self) -> None:
        """ARM uses correct parameter registers."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        cc_info = gen.get_calling_convention_info()

        assert cc_info["int_params"] == ["r0", "r1", "r2", "r3"]
        assert cc_info["stack_align"] == 8


class TestMultiArchitectureCodeGeneration:
    """Test code generation consistency across multiple architectures."""

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("x86", "linux"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ], indirect=False)
    def test_all_architectures_generate_valid_license_bypass(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid license bypass code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) > 0
        assert isinstance(code, bytes)

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["size"] == len(code)

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ], indirect=False)
    def test_all_architectures_generate_valid_trial_extension(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid trial extension code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert isinstance(code, bytes)

    @pytest.mark.parametrize("arch,platform", [
        ("x86_64", "windows"),
        ("x86_64", "linux"),
        ("x86", "windows"),
        ("arm64", "linux"),
        ("arm", "linux"),
    ], indirect=False)
    def test_all_architectures_generate_valid_activation_bypass(self, arch: str, platform: str) -> None:
        """All supported architectures generate valid activation bypass code."""
        gen = LicenseBypassCodeGenerator(arch, platform)
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) > 0
        assert isinstance(code, bytes)

    @pytest.mark.parametrize("arch", ["x86_64", "x86", "arm64", "arm"], indirect=False)
    def test_all_architectures_generate_valid_nop_patches(self, arch: str) -> None:
        """All supported architectures generate valid NOP patches."""
        gen = LicenseBypassCodeGenerator(arch, "linux")

        size = 16
        code = gen.generate_nop_patch(0x406000, size)
        assert len(code) == size


class TestCodeValidation:
    """Test validation of generated code correctness."""

    def test_x86_64_windows_stack_alignment_preserved(self) -> None:
        """x86_64 Windows code maintains 16-byte stack alignment."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert b"\x48\x83\xec\x28" in code
        assert b"\x48\x83\xc4\x28" in code

    def test_x86_64_linux_stack_frame_preserved(self) -> None:
        """x86_64 Linux code maintains proper stack frame."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code.startswith(b"\x55")
        assert b"\x5d" in code

    def test_all_functions_return_properly(self) -> None:
        """All generated functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        code1 = gen.generate_license_check_bypass(0x401000)
        code2 = gen.generate_trial_extension_patch(0x402000)
        code3 = gen.generate_activation_bypass(0x403000)
        code4 = gen.generate_serial_validation_bypass(0x404000)

        assert code1.endswith(b"\xc3")
        assert code2.endswith(b"\xc3")
        assert code3.endswith(b"\xc3")
        assert code4.endswith(b"\xc3")

    def test_arm64_functions_end_with_return(self) -> None:
        """ARM64 functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")

        code = gen.generate_license_check_bypass(0x401000)
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_arm_functions_end_with_return(self) -> None:
        """ARM functions end with proper return instruction."""
        gen = LicenseBypassCodeGenerator("arm", "linux")

        code = gen.generate_license_check_bypass(0x401000)
        assert code.endswith(b"\x1e\xff\x2f\xe1")


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_zero_address_patch_generation(self) -> None:
        """Patches can be generated for address 0x0."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x0)

        assert len(code) > 0
        patches = gen.get_generated_patches()
        assert patches[0]["address"] == 0x0

    def test_high_address_patch_generation(self) -> None:
        """Patches can be generated for high memory addresses."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0xFFFFFFFF)

        assert len(code) > 0
        patches = gen.get_generated_patches()
        assert patches[0]["address"] == 0xFFFFFFFF

    def test_empty_hwid_spoof(self) -> None:
        """Hardware ID spoof handles empty HWID."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_hardware_id_spoof(0x405000, b"")

        assert len(code) > 0

    def test_single_byte_nop_patch(self) -> None:
        """NOP patch can generate single byte."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x406000, 1)

        assert len(code) == 1
        assert code == b"\x90"

    def test_multiple_patches_same_address(self) -> None:
        """Multiple patches can be generated for same address."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        code1: bytes = gen.generate_license_check_bypass(0x401000)
        code2: bytes = gen.generate_activation_bypass(0x401000)
        assert len(code1) > 0
        assert len(code2) > 0

        patches = gen.get_generated_patches()
        assert len(patches) == 2
        assert patches[0]["address"] == 0x401000
        assert patches[1]["address"] == 0x401000

    def test_unsupported_architecture_raises_error(self) -> None:
        """Unsupported architecture raises appropriate error."""
        gen = LicenseBypassCodeGenerator("powerpc", "linux")

        with pytest.raises(ValueError, match="Unsupported architecture"):
            gen.generate_license_check_bypass(0x401000)


class TestRealWorldScenarios:
    """Test real-world license cracking scenarios."""

    def test_complete_license_bypass_workflow(self) -> None:
        """Complete workflow for bypassing all license checks in application."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        license_check_patch = gen.generate_license_check_bypass(0x401000)
        serial_check_patch = gen.generate_serial_validation_bypass(0x402000)
        activation_patch = gen.generate_activation_bypass(0x403000)
        trial_patch = gen.generate_trial_extension_patch(0x404000)
        hwid_patch = gen.generate_hardware_id_spoof(0x405000, b"CRACKED1")

        assert all(len(p) > 0 for p in [license_check_patch, serial_check_patch, activation_patch, trial_patch, hwid_patch])

        patches = gen.get_generated_patches()
        assert len(patches) == 5

        exported = gen.export_patches("hex")
        assert len(exported["patches"]) == 5

    def test_multi_protection_layer_bypass(self) -> None:
        """Bypass multiple protection layers with different techniques."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_conditional_jump_patch(0x401000, always_jump=True)
        gen.generate_nop_patch(0x401050, 20)
        gen.generate_return_value_patch(0x402000, 1)
        gen.generate_license_check_bypass(0x403000)

        patches = gen.get_generated_patches()
        assert len(patches) == 4

        patch_types = [p["type"] for p in patches]
        assert "jump_patch" in patch_types
        assert "nop_patch" in patch_types
        assert "return_value_patch" in patch_types
        assert "license_check_bypass" in patch_types

    def test_trial_reset_full_workflow(self) -> None:
        """Complete trial reset bypass workflow."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        time_check_nop: bytes = gen.generate_nop_patch(0x401000, 16)
        trial_extension: bytes = gen.generate_trial_extension_patch(0x402000)
        expiry_return: bytes = gen.generate_return_value_patch(0x403000, 0)
        assert len(time_check_nop) > 0
        assert len(trial_extension) > 0
        assert len(expiry_return) > 0

        patches = gen.get_generated_patches()
        assert len(patches) == 3

        assert all(len(p["code"]) > 0 for p in patches)

    def test_hardware_locked_license_bypass(self) -> None:
        """Bypass hardware-locked license with HWID spoofing."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        hwid_spoof: bytes = gen.generate_hardware_id_spoof(0x401000, b"VALID123")
        hwid_check_bypass: bytes = gen.generate_license_check_bypass(0x402000)
        assert len(hwid_spoof) > 0
        assert len(hwid_check_bypass) > 0

        patches = gen.get_generated_patches()
        assert len(patches) == 2
        assert patches[0]["type"] == "hardware_id_spoof"
        assert patches[1]["type"] == "license_check_bypass"

    def test_cross_platform_patch_generation(self) -> None:
        """Generate patches for both Windows and Linux versions of same software."""
        gen_win = LicenseBypassCodeGenerator("x86_64", "windows")
        gen_linux = LicenseBypassCodeGenerator("x86_64", "linux")

        win_patch = gen_win.generate_license_check_bypass(0x401000)
        linux_patch = gen_linux.generate_license_check_bypass(0x401000)

        assert win_patch != linux_patch
        assert len(win_patch) > 0
        assert len(linux_patch) > 0

    def test_multi_architecture_deployment(self) -> None:
        """Generate patches for multiple architectures of same application."""
        gen_x64 = LicenseBypassCodeGenerator("x86_64", "windows")
        gen_x86 = LicenseBypassCodeGenerator("x86", "windows")
        gen_arm = LicenseBypassCodeGenerator("arm64", "linux")

        patch_x64 = gen_x64.generate_license_check_bypass(0x401000)
        patch_x86 = gen_x86.generate_license_check_bypass(0x401000)
        patch_arm = gen_arm.generate_license_check_bypass(0x401000)

        assert len(patch_x64) > 0
        assert len(patch_x86) > 0
        assert len(patch_arm) > 0

        assert patch_x64 != patch_x86 != patch_arm


class TestAnalysisDepthEnum:
    """Test AnalysisDepth enum and depth-aware analysis functionality."""

    def test_analysis_depth_enum_values(self) -> None:
        """AnalysisDepth enum has correct string values."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        assert AnalysisDepth.QUICK.value == "quick"
        assert AnalysisDepth.STANDARD.value == "standard"
        assert AnalysisDepth.DEEP.value == "deep"
        assert AnalysisDepth.EXHAUSTIVE.value == "exhaustive"

    def test_analysis_depth_ordering(self) -> None:
        """AnalysisDepth values can be compared for ordering."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        depths = [AnalysisDepth.QUICK, AnalysisDepth.STANDARD, AnalysisDepth.DEEP, AnalysisDepth.EXHAUSTIVE]
        assert len(depths) == 4

    def test_generator_accepts_analysis_depth_parameter(self) -> None:
        """LicenseBypassCodeGenerator methods accept analysis_depth parameter."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        assert hasattr(gen, "_analysis_engines_available")


class TestEngineAvailability:
    """Test analysis engine availability detection."""

    def test_engine_availability_dict_exists(self) -> None:
        """Generator initializes engine availability dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_analysis_engines_available")
        assert isinstance(gen._analysis_engines_available, dict)

    def test_engine_availability_checks_required_engines(self) -> None:
        """Engine availability checks for all required engines."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        expected_engines = [
            "binary_pattern_detector",
            "yara_engine",
            "control_flow_deobfuscator",
            "opaque_predicate_analyzer",
            "angr_enhancements",
            "symbolic_devirtualizer",
        ]

        for engine in expected_engines:
            assert engine in gen._analysis_engines_available

    def test_engine_availability_stores_boolean_values(self) -> None:
        """Engine availability dictionary stores boolean values."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        for engine, available in gen._analysis_engines_available.items():
            assert isinstance(available, bool), f"Engine {engine} availability is not a boolean"


class TestPatternDetectionIntegration:
    """Test BinaryPatternDetector integration."""

    def test_run_pattern_detection_method_exists(self) -> None:
        """Generator has _run_pattern_detection method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_pattern_detection")
        assert callable(gen._run_pattern_detection)

    def test_pattern_detection_returns_dict(self) -> None:
        """_run_pattern_detection returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        test_data = b"\x00" * 100
        result = gen._run_pattern_detection(test_data, 0x400000, "")

        assert isinstance(result, dict)

    def test_pattern_detection_handles_empty_binary(self) -> None:
        """_run_pattern_detection handles empty binary data gracefully."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_pattern_detection(b"", 0x400000, "")

        assert isinstance(result, dict)


class TestYaraDetectionIntegration:
    """Test YaraPatternEngine integration."""

    def test_run_yara_detection_method_exists(self) -> None:
        """Generator has _run_yara_detection method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_yara_detection")
        assert callable(gen._run_yara_detection)

    def test_yara_detection_returns_dict(self) -> None:
        """_run_yara_detection returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_yara_detection("")

        assert isinstance(result, dict)


class TestDeobfuscationIntegration:
    """Test ControlFlowDeobfuscator integration."""

    def test_run_deobfuscation_method_exists(self) -> None:
        """Generator has _run_deobfuscation method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_deobfuscation")
        assert callable(gen._run_deobfuscation)

    def test_deobfuscation_returns_dict(self) -> None:
        """_run_deobfuscation returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_deobfuscation("", "unknown")

        assert isinstance(result, dict)

    def test_deobfuscation_patches_stored(self) -> None:
        """Deobfuscation patches are stored for later use."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_deobfuscation_patches")
        assert isinstance(gen._deobfuscation_patches, list)


class TestOpaquePredicateIntegration:
    """Test OpaquePredicateAnalyzer integration."""

    def test_run_opaque_predicate_method_exists(self) -> None:
        """Generator has _run_opaque_predicate_analysis method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_opaque_predicate_analysis")
        assert callable(gen._run_opaque_predicate_analysis)

    def test_opaque_predicate_returns_dict(self) -> None:
        """_run_opaque_predicate_analysis returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_opaque_predicate_analysis("")

        assert isinstance(result, dict)


class TestSymbolicAnalysisIntegration:
    """Test AngrEnhancements integration for symbolic execution."""

    def test_run_symbolic_analysis_method_exists(self) -> None:
        """Generator has _run_symbolic_analysis method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_symbolic_analysis")
        assert callable(gen._run_symbolic_analysis)

    def test_symbolic_analysis_returns_dict(self) -> None:
        """_run_symbolic_analysis returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_symbolic_analysis("")

        assert isinstance(result, dict)


class TestDevirtualizationIntegration:
    """Test SymbolicDevirtualizer integration."""

    def test_run_devirtualization_method_exists(self) -> None:
        """Generator has _run_devirtualization method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_run_devirtualization")
        assert callable(gen._run_devirtualization)

    def test_devirtualization_returns_dict(self) -> None:
        """_run_devirtualization returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._run_devirtualization("", "unknown")

        assert isinstance(result, dict)


class TestBypassStrategySelection:
    """Test protection-specific bypass strategy selection."""

    def test_select_bypass_strategy_method_exists(self) -> None:
        """Generator has _select_bypass_strategy method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_select_bypass_strategy")
        assert callable(gen._select_bypass_strategy)

    def test_select_bypass_strategy_returns_dict(self) -> None:
        """_select_bypass_strategy returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("vmprotect", {})

        assert isinstance(result, dict)

    def test_select_bypass_strategy_vmprotect(self) -> None:
        """_select_bypass_strategy handles VMProtect protection."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("vmprotect", {})

        assert "strategy" in result or result.get("success") is not None

    def test_select_bypass_strategy_themida(self) -> None:
        """_select_bypass_strategy handles Themida protection."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("themida", {})

        assert isinstance(result, dict)

    def test_select_bypass_strategy_denuvo(self) -> None:
        """_select_bypass_strategy handles Denuvo protection."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("denuvo", {})

        assert isinstance(result, dict)

    def test_select_bypass_strategy_hasp(self) -> None:
        """_select_bypass_strategy handles HASP protection."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("hasp", {})

        assert isinstance(result, dict)

    def test_select_bypass_strategy_flexlm(self) -> None:
        """_select_bypass_strategy handles FlexLM protection."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("flexlm", {})

        assert isinstance(result, dict)

    def test_select_bypass_strategy_unknown(self) -> None:
        """_select_bypass_strategy handles unknown protection gracefully."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen._select_bypass_strategy("unknown_protection", {})

        assert isinstance(result, dict)


class TestGenerateKeygenFromConstraints:
    """Test Z3-based keygen generation from symbolic constraints."""

    def test_generate_keygen_method_exists(self) -> None:
        """Generator has generate_keygen_from_constraints method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "generate_keygen_from_constraints")
        assert callable(gen.generate_keygen_from_constraints)

    def test_generate_keygen_returns_dict(self) -> None:
        """generate_keygen_from_constraints returns a dictionary."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen.generate_keygen_from_constraints()

        assert isinstance(result, dict)

    def test_generate_keygen_with_alphanumeric_format(self) -> None:
        """generate_keygen_from_constraints supports alphanumeric format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen.generate_keygen_from_constraints(key_format="alphanumeric", key_length=16)

        assert isinstance(result, dict)
        assert "success" in result or "key" in result or "error" in result

    def test_generate_keygen_with_hex_format(self) -> None:
        """generate_keygen_from_constraints supports hex format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen.generate_keygen_from_constraints(key_format="hex", key_length=32)

        assert isinstance(result, dict)

    def test_generate_keygen_with_numeric_format(self) -> None:
        """generate_keygen_from_constraints supports numeric format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen.generate_keygen_from_constraints(key_format="numeric", key_length=20)

        assert isinstance(result, dict)

    def test_generate_keygen_with_constraints(self) -> None:
        """generate_keygen_from_constraints accepts constraint list."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        constraints = ["key[0] == 'A'", "sum(key) == 1234"]
        result = gen.generate_keygen_from_constraints(constraints=constraints)

        assert isinstance(result, dict)

    def test_generate_keygen_with_custom_length(self) -> None:
        """generate_keygen_from_constraints accepts custom key length."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        for length in [8, 16, 24, 32]:
            result = gen.generate_keygen_from_constraints(key_length=length)
            assert isinstance(result, dict)


class TestGenerateShellcodeWithDepth:
    """Test shellcode generation with analysis depth parameter."""

    def test_generate_shellcode_method_exists(self) -> None:
        """Generator has generate_shellcode method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "generate_shellcode")
        assert callable(gen.generate_shellcode)

    def test_generate_shellcode_accepts_depth_parameter(self) -> None:
        """generate_shellcode accepts depth parameter."""
        import inspect

        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        sig = inspect.signature(gen.generate_shellcode)
        _ = AnalysisDepth  # Ensure import is used

        assert "depth" in sig.parameters

    def test_generate_shellcode_accepts_auto_apply_deobfuscation(self) -> None:
        """generate_shellcode accepts auto_apply_deobfuscation parameter."""
        import inspect

        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        sig = inspect.signature(gen.generate_shellcode)

        assert "auto_apply_deobfuscation" in sig.parameters


class TestAnalyzeLicenseProtections:
    """Test enhanced _analyze_license_protections method."""

    def test_analyze_license_protections_method_exists(self) -> None:
        """Generator has _analyze_license_protections method."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_analyze_license_protections")
        assert callable(gen._analyze_license_protections)

    def test_analyze_license_protections_accepts_depth(self) -> None:
        """_analyze_license_protections accepts depth parameter."""
        import inspect

        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        sig = inspect.signature(gen._analyze_license_protections)

        assert "depth" in sig.parameters

    def test_analysis_results_include_depth_info(self) -> None:
        """Analysis results include analysis_depth field."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        result = gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.QUICK)

        assert isinstance(result, dict)
        assert "analysis_depth" in result
        assert result["analysis_depth"] == "quick"


class TestLastAnalysisResultsCaching:
    """Test caching of last analysis results."""

    def test_last_analysis_results_attribute_exists(self) -> None:
        """Generator has _last_analysis_results attribute."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        assert hasattr(gen, "_last_analysis_results")

    def test_analysis_results_cached_after_analysis(self) -> None:
        """Analysis results are cached after running analysis."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.QUICK)

        assert gen._last_analysis_results is not None
        assert isinstance(gen._last_analysis_results, dict)


class TestAnalysisResultStructure:
    """Test structure of analysis results dictionary."""

    def test_analysis_results_contain_required_fields(self) -> None:
        """Analysis results contain all required fields."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        result = gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.QUICK)

        required_fields: List[str] = [
            "license_checks",
            "trial_checks",
            "activation_checks",
            "serial_checks",
            "hwid_checks",
            "protection_type",
            "protection_confidence",
            "detected_protection",
            "analysis_depth",
        ]

        for field in required_fields:
            assert field in result, f"Missing required field: {field}"

    def test_analysis_results_contain_engine_results_at_standard_depth(self) -> None:
        """Analysis results contain engine-specific results at STANDARD depth."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        result = gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.STANDARD)

        engine_fields: List[str] = [
            "pattern_detection",
            "yara_detection",
        ]

        for field in engine_fields:
            assert field in result, f"Missing engine results field: {field}"

    def test_analysis_results_contain_deep_analysis_at_deep_depth(self) -> None:
        """Analysis results contain deep analysis results at DEEP depth."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        result = gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.DEEP)

        deep_fields = [
            "deobfuscation_results",
            "opaque_predicate_analysis",
        ]

        for field in deep_fields:
            assert field in result, f"Missing deep analysis field: {field}"

    def test_analysis_results_contain_exhaustive_at_exhaustive_depth(self) -> None:
        """Analysis results contain exhaustive analysis at EXHAUSTIVE depth."""
        from intellicrack.core.exploitation.license_bypass_code_generator import AnalysisDepth

        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        class MockPE:
            OPTIONAL_HEADER: Any = type("OH", (), {"ImageBase": 0x400000})()
            sections: List[Any] = []

            def get_data(self) -> bytes:
                return b"\x00" * 100

        result = gen._analyze_license_protections(MockPE(), depth=AnalysisDepth.EXHAUSTIVE)

        exhaustive_fields = [
            "symbolic_analysis",
            "vm_analysis",
        ]

        for field in exhaustive_fields:
            assert field in result, f"Missing exhaustive analysis field: {field}"


class TestProtectionSpecificWorkflows:
    """Test complete workflows for specific protection types."""

    def test_vmprotect_analysis_workflow(self) -> None:
        """VMProtect analysis integrates with devirtualization."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        strategy = gen._select_bypass_strategy("vmprotect", {"vm_handlers": []})

        assert isinstance(strategy, dict)

    def test_themida_analysis_workflow(self) -> None:
        """Themida analysis integrates with deobfuscation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        strategy = gen._select_bypass_strategy("themida", {})

        assert isinstance(strategy, dict)

    def test_denuvo_analysis_workflow(self) -> None:
        """Denuvo analysis identifies license verification points."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        strategy = gen._select_bypass_strategy("denuvo", {})

        assert isinstance(strategy, dict)


class TestGracefulDegradation:
    """Test graceful degradation when engines are unavailable."""

    def test_analysis_continues_without_binary_pattern_detector(self) -> None:
        """Analysis continues when BinaryPatternDetector is unavailable."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen._analysis_engines_available["binary_pattern_detector"] = False

        result = gen._run_pattern_detection(b"\x00" * 100, 0x400000, "")

        assert isinstance(result, dict)

    def test_analysis_continues_without_yara_engine(self) -> None:
        """Analysis continues when YaraPatternEngine is unavailable."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen._analysis_engines_available["yara_engine"] = False

        result = gen._run_yara_detection("")

        assert isinstance(result, dict)

    def test_analysis_continues_without_deobfuscator(self) -> None:
        """Analysis continues when ControlFlowDeobfuscator is unavailable."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen._analysis_engines_available["control_flow_deobfuscator"] = False

        result = gen._run_deobfuscation("", "vmprotect")

        assert isinstance(result, dict)

    def test_analysis_continues_without_angr(self) -> None:
        """Analysis continues when AngrEnhancements is unavailable."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen._analysis_engines_available["angr_enhancements"] = False

        result = gen._run_symbolic_analysis("")

        assert isinstance(result, dict)

    def test_keygen_generation_without_z3(self) -> None:
        """Keygen generation handles Z3 unavailability gracefully."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        result = gen.generate_keygen_from_constraints()

        assert isinstance(result, dict)
