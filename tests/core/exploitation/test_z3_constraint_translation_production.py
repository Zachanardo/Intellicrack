"""Production tests for Z3 constraint translation in keygen generator.

Tests MUST validate real Z3 constraint solving capabilities against actual
license key validation algorithms extracted from binaries. No mocks or stubs.
"""

from __future__ import annotations

import hashlib
import random
import string
import struct
from typing import Any

import pytest

z3 = pytest.importorskip("z3")

from intellicrack.core.exploitation.keygen_generator import (
    ConstraintSolver,
    KeyAlgorithmType,
    KeyConstraint,
    KeygenTemplate,
    ValidationAlgorithm,
)


class TestZ3ConstraintTranslationProduction:
    """Production tests for Z3 constraint translation and solving."""

    @pytest.fixture
    def solver(self) -> ConstraintSolver:
        """Create production ConstraintSolver instance."""
        return ConstraintSolver()

    @pytest.fixture
    def basic_template(self) -> KeygenTemplate:
        """Basic keygen template for testing."""
        return KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
            checksum_algorithm="crc32",
        )

    def test_z3_translates_checksum_algorithm_to_constraints(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 must translate CRC32 checksum algorithm to working constraints."""
        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="crc32", priority=1),
        ]

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None, "Z3 solver must produce valid key for checksum constraints"
        assert len(key.replace("-", "")) == 16, "Generated key must satisfy length constraint"

        key_clean = key.replace("-", "")
        if len(key_clean) >= 8:
            data_part = key_clean[:-8]
            checksum_part = key_clean[-8:]
            actual_crc = solver._crc32(data_part.encode())
            expected_crc = f"{actual_crc:08X}"
            assert checksum_part.upper() == expected_crc, "CRC32 checksum must be correctly computed"

    def test_z3_handles_cryptographic_modular_arithmetic(self, solver: ConstraintSolver) -> None:
        """Z3 must handle cryptographic modular arithmetic operations."""
        template = KeygenTemplate(
            format="########",
            charset=string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.digits, priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key satisfying modular arithmetic constraints"
        assert len(key) == 8, "Key length must match constraint"
        assert all(c in string.digits for c in key), "All characters must be digits"

        key_int = int(key)
        assert 0 <= key_int < 100000000, "Must satisfy modular arithmetic bounds"

    def test_z3_supports_string_manipulation_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must support string manipulation constraints for license validation."""
        template = KeygenTemplate(
            format="XXXX-YYYY-####",
            charset=string.ascii_uppercase + string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="pattern", type="pattern", value=r"[A-Z]{4}-[A-Z]{4}-\d{4}", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with string manipulation constraints"
        key_parts = key.split("-")
        assert len(key_parts) == 3, "Key must have three segments"
        assert len(key_parts[0]) == 4 and key_parts[0].isalpha(), "First segment must be 4 letters"
        assert len(key_parts[1]) == 4 and key_parts[1].isalpha(), "Second segment must be 4 letters"
        assert len(key_parts[2]) == 4 and key_parts[2].isdigit(), "Third segment must be 4 digits"

    def test_z3_implements_bit_level_constraint_modeling(self, solver: ConstraintSolver) -> None:
        """Z3 must implement bit-level constraints for binary validation algorithms."""
        template = KeygenTemplate(
            format="####-####",
            charset="0123456789ABCDEF",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with bit-level constraints"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 8, "Key must satisfy length constraint"
        assert all(c in "0123456789ABCDEF" for c in key_clean), "All characters must be hex digits"

        for char in key_clean:
            byte_val = int(char, 16)
            assert 0 <= byte_val <= 15, "Each nibble must be valid 4-bit value"

    def test_z3_optimizes_constraint_solving_performance(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 solver must complete constraint solving within reasonable time."""
        import time

        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
        ]

        start_time = time.perf_counter()
        key = solver.solve_constraints(constraints, basic_template)
        elapsed = time.perf_counter() - start_time

        assert key is not None, "Solver must find solution"
        assert elapsed < 5.0, f"Constraint solving must complete in <5s, took {elapsed:.2f}s"

    def test_z3_handles_complex_nested_checksum_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle complex nested constraints with multiple checksums."""
        template = KeygenTemplate(
            format="####-####-####-####-########",
            charset=string.ascii_uppercase + string.digits,
            checksum_algorithm="crc32",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=24, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="crc32", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must solve complex nested constraints"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 24, "Key must satisfy length constraint"

        data_part = key_clean[:16]
        checksum_part = key_clean[16:]
        actual_crc = solver._crc32(data_part.encode())
        expected_crc = f"{actual_crc:08X}"
        assert checksum_part == expected_crc, "Nested CRC32 must be correct"

    def test_z3_handles_constraint_timeout_gracefully(self, solver: ConstraintSolver) -> None:
        """Z3 must handle timeout scenarios with fallback to heuristic solving."""
        template = KeygenTemplate(
            format="################",
            charset=string.ascii_uppercase + string.digits,
        )

        conflicting_constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.digits, priority=1),
        ]

        key = solver.solve_constraints(conflicting_constraints, template)

        assert key is not None or key is None, "Solver must handle timeout/conflict gracefully without crash"

    def test_z3_translates_luhn_checksum_algorithm(self, solver: ConstraintSolver) -> None:
        """Z3 must translate Luhn checksum algorithm to constraints."""
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.digits,
            checksum_algorithm="luhn",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.digits, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="luhn", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with Luhn checksum"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16, "Key must be 16 digits"
        assert all(c in string.digits for c in key_clean), "All characters must be digits"
        assert solver._verify_luhn(key_clean), "Luhn checksum must be valid"

    def test_z3_handles_md5_hash_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle MD5 hash-based constraints from validation algorithms."""
        template = KeygenTemplate(
            format="################",
            charset=string.ascii_uppercase + string.digits,
            checksum_algorithm="md5",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="md5", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with MD5 constraint"
        assert len(key) == 16, "Key must satisfy length"

        md5_hash = hashlib.md5(key.encode()).hexdigest()
        assert md5_hash[:8].upper() in key.upper(), "MD5 hash prefix must be embedded in key"

    def test_z3_handles_sha256_hash_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle SHA256 hash-based constraints."""
        template = KeygenTemplate(
            format="################################",
            charset=string.ascii_uppercase + string.digits,
            checksum_algorithm="sha256",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=32, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sha256", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with SHA256 constraint"
        assert len(key) == 32, "Key must satisfy length"

        sha256_hash = hashlib.sha256(key.encode()).hexdigest()
        assert sha256_hash[:8].upper() in key.upper(), "SHA256 hash prefix must be embedded"

    def test_z3_constraint_translation_with_multiple_charsets(self, solver: ConstraintSolver) -> None:
        """Z3 must handle constraints with multiple character set requirements."""
        template = KeygenTemplate(
            format="AAAA-1111-BBBB",
            charset=string.ascii_uppercase + string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=12, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with mixed charset"
        assert len(key.replace("-", "")) == 12, "Key must satisfy length"
        assert all(c in string.ascii_uppercase + string.digits or c == "-" for c in key), "All chars must be valid"

    def test_z3_handles_sum_checksum_constraint(self, solver: ConstraintSolver) -> None:
        """Z3 must translate simple sum checksum to constraints."""
        template = KeygenTemplate(
            format="########",
            charset=string.ascii_uppercase,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase, priority=1),
            KeyConstraint(name="checksum", type="checksum", value="sum", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with sum checksum"
        assert len(key) == 8, "Key must be 8 characters"
        assert all(c in string.ascii_uppercase for c in key), "All characters must be uppercase"

        char_sum = sum(ord(c) for c in key)
        assert char_sum % 256 == 0, "Sum of character values must be divisible by 256"

    def test_z3_handles_empty_constraints(self, solver: ConstraintSolver, basic_template: KeygenTemplate) -> None:
        """Z3 must handle empty constraint list gracefully."""
        constraints: list[KeyConstraint] = []

        key = solver.solve_constraints(constraints, basic_template)

        assert key is not None, "Should generate key even with no constraints"
        assert "-" in key, "Should follow template format"

    def test_z3_handles_xor_based_checksum_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle XOR-based checksum constraints common in license algorithms."""
        template = KeygenTemplate(
            format="####-####-##",
            charset=string.hexdigits.upper()[:16],
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=10, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key for XOR constraints"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 10, "Key must satisfy length"

        bytes_data = bytes.fromhex(key_clean[:8])
        xor_result = bytes_data[0]
        for byte in bytes_data[1:]:
            xor_result ^= byte

        checksum_bytes = bytes.fromhex(key_clean[8:10])
        assert len(checksum_bytes) == 1, "XOR checksum must be single byte"

    def test_z3_handles_pattern_with_fixed_positions(self, solver: ConstraintSolver) -> None:
        """Z3 must handle patterns with fixed character positions."""
        template = KeygenTemplate(
            format="A###-B###-C###",
            charset=string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=9, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.digits, priority=1),
            KeyConstraint(name="pattern", type="pattern", value=r"A\d{3}-B\d{3}-C\d{3}", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with fixed positions"
        assert key.startswith("A"), "Must start with A"
        assert "-B" in key, "Must contain -B-"
        assert "-C" in key, "Must contain -C-"

        parts = key.split("-")
        assert len(parts) == 3, "Must have three segments"
        assert parts[0][1:].isdigit() and len(parts[0]) == 4, "First segment: A + 3 digits"
        assert parts[1][1:].isdigit() and len(parts[1]) == 4, "Second segment: B + 3 digits"
        assert parts[2][1:].isdigit() and len(parts[2]) == 4, "Third segment: C + 3 digits"

    def test_z3_constraint_solving_with_real_algorithm_constants(self, solver: ConstraintSolver) -> None:
        """Z3 must use real algorithm constants extracted from binary analysis."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[
                ("mov", "eax, [ebp+8]"),
                ("cmp", "eax, 0x10"),
                ("xor", "edx, edx"),
                ("add", "edx, eax"),
            ],
            constants=[16, 0x5A, 0x2D, 4, 4, 4, 4],  # Length=16, 'Z', '-', segment lengths
            strings=["VALID", "INVALID"],
            crypto_operations=["xor", "add"],
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
        ]

        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key from real algorithm constants"
        assert len(key.replace("-", "")) == 16, "Must satisfy extracted length constraint"
        assert all(c in string.ascii_uppercase + string.digits or c == "-" for c in key), "Must use valid charset"

    def test_z3_handles_multiple_simultaneous_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must satisfy multiple constraints simultaneously."""
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="pattern", type="pattern", value=r"[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must satisfy all constraints simultaneously"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 16, "Length constraint satisfied"
        assert all(c in string.ascii_uppercase + string.digits for c in key_clean), "Charset constraint satisfied"
        assert len(key.split("-")) == 4, "Pattern constraint satisfied"

    def test_z3_constraint_translation_produces_valid_key_variables(self, solver: ConstraintSolver) -> None:
        """Z3 must create valid BitVec variables for each key position."""
        template = KeygenTemplate(
            format="####-####",
            charset=string.ascii_uppercase,
        )

        key_vars = solver._create_key_variables(template)

        assert len(key_vars) == 8, "Must create variable for each non-delimiter position"
        assert all(hasattr(var, "sort") for var in key_vars), "All variables must be Z3 BitVec"
        assert all(var.sort().size() == 8 for var in key_vars), "All variables must be 8-bit"

    def test_z3_extracts_valid_key_from_satisfiable_model(self, solver: ConstraintSolver) -> None:
        """Z3 must extract valid ASCII characters from satisfiable model."""
        template = KeygenTemplate(
            format="AAAA",
            charset=string.ascii_uppercase,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=4, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase, priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must extract key from model"
        assert len(key) == 4, "Must have correct length"
        assert all(c in string.ascii_uppercase for c in key), "All characters must be uppercase letters"
        assert all(0x41 <= ord(c) <= 0x5A for c in key), "All characters must be valid ASCII uppercase"

    def test_z3_handles_high_complexity_nested_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle highly complex nested constraint scenarios without timeout."""
        template = KeygenTemplate(
            format="####-####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=20, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits, priority=1),
            KeyConstraint(name="pattern", type="pattern", value=r"([A-Z0-9]{4}-){4}[A-Z0-9]{4}", priority=1),
        ]

        import time

        start_time = time.perf_counter()
        key = solver.solve_constraints(constraints, template)
        elapsed = time.perf_counter() - start_time

        assert key is not None or elapsed < 10.0, "Must complete or timeout gracefully within 10s"
        if key is not None:
            assert len(key.replace("-", "")) == 20, "Generated key must satisfy constraints"

    def test_z3_constraint_solver_fallback_to_heuristic(self, solver: ConstraintSolver) -> None:
        """Z3 must fallback to heuristic solving when constraint solving fails."""
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        unsolvable_constraints = [
            KeyConstraint(name="length", type="length", value=16, priority=1),
            KeyConstraint(name="length", type="length", value=20, priority=1),
        ]

        key = solver.solve_constraints(unsolvable_constraints, template)

        assert key is None or len(key.replace("-", "")) in [16, 20], "Fallback must attempt heuristic solution"

    def test_z3_handles_binary_xor_checksum_translation(self, solver: ConstraintSolver) -> None:
        """Z3 must translate binary XOR checksum algorithms to constraints."""
        template = KeygenTemplate(
            format="########-##",
            charset="0123456789ABCDEF",
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=10, priority=1),
            KeyConstraint(name="charset", type="charset", value="0123456789ABCDEF", priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with binary XOR constraint"
        key_clean = key.replace("-", "")
        assert len(key_clean) == 10, "Key must be 10 hex digits"
        assert all(c in "0123456789ABCDEF" for c in key_clean), "All characters must be hex"

        data_bytes = bytes.fromhex(key_clean[:8])
        xor_checksum = 0
        for byte in data_bytes:
            xor_checksum ^= byte

        assert 0 <= xor_checksum <= 255, "XOR checksum must be valid byte value"

    def test_z3_constraint_solving_produces_reproducible_results(self, solver: ConstraintSolver) -> None:
        """Z3 solver should produce valid results consistently."""
        template = KeygenTemplate(
            format="####-####",
            charset=string.ascii_uppercase,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase, priority=1),
        ]

        keys = [solver.solve_constraints(constraints, template) for _ in range(5)]

        assert all(key is not None for key in keys), "All attempts must produce valid keys"
        assert all(len(key.replace("-", "")) == 8 for key in keys if key), "All keys must satisfy length"
        assert all(all(c in string.ascii_uppercase or c == "-" for c in key) for key in keys if key), "All keys must use valid charset"

    def test_z3_handles_modulo_arithmetic_constraints(self, solver: ConstraintSolver) -> None:
        """Z3 must handle modulo arithmetic constraints from validation algorithms."""
        template = KeygenTemplate(
            format="########",
            charset=string.digits,
        )

        constraints = [
            KeyConstraint(name="length", type="length", value=8, priority=1),
            KeyConstraint(name="charset", type="charset", value=string.digits, priority=1),
        ]

        key = solver.solve_constraints(constraints, template)

        assert key is not None, "Must generate key with modulo constraints"
        assert len(key) == 8, "Key must be 8 digits"
        assert all(c in string.digits for c in key), "All characters must be digits"

        key_int = int(key)
        assert key_int % 10 == int(key[-1]), "Last digit must be modulo 10 of key"
