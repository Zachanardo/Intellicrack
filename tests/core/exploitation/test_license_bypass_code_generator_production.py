"""Production Tests for License Bypass Code Generator.

This module validates the LicenseBypassCodeGenerator's ability to generate
production-ready assembly code and binary patches for bypassing software
licensing protections. Tests verify code generation for x86, x86_64, ARM
architectures and validate proper calling conventions and stack preservation.

Copyright (C) 2025 Zachary Flint
"""

import struct
from typing import Any

import pytest

from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator


class TestLicenseBypassCodeGeneratorInitialization:
    """Test LicenseBypassCodeGenerator initialization."""

    def test_generator_initializes_x86_64_windows(self) -> None:
        """Generator initializes for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        assert gen.architecture == "x86_64"
        assert gen.platform == "windows"
        assert gen.generated_patches == []

    def test_generator_initializes_x86_64_linux(self) -> None:
        """Generator initializes for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        assert gen.architecture == "x86_64"
        assert gen.platform == "linux"

    def test_generator_initializes_x86_windows(self) -> None:
        """Generator initializes for x86 Windows."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        assert gen.architecture == "x86"
        assert gen.platform == "windows"

    def test_generator_initializes_arm64(self) -> None:
        """Generator initializes for ARM64."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        assert gen.architecture == "arm64"

    def test_calling_conventions_loaded(self) -> None:
        """Generator loads calling convention specifications."""
        gen = LicenseBypassCodeGenerator()
        assert "x86_64" in gen.calling_conventions
        assert "x86" in gen.calling_conventions
        assert "arm64" in gen.calling_conventions

    def test_x86_64_windows_calling_convention(self) -> None:
        """x86_64 Windows calling convention has correct parameters."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        conv = gen.calling_conventions["x86_64"]["windows"]
        assert conv["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert conv["shadow_space"] == 32
        assert conv["stack_align"] == 16

    def test_x86_64_linux_calling_convention(self) -> None:
        """x86_64 Linux calling convention has correct parameters."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        conv = gen.calling_conventions["x86_64"]["linux"]
        assert conv["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert conv["shadow_space"] == 0


class TestLicenseCheckBypassGeneration:
    """Test license check bypass code generation."""

    def test_generate_license_check_bypass_x86_64_windows(self) -> None:
        """Generates valid license bypass for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0
        assert code[-1:] == b"\xc3"

    def test_generate_license_check_bypass_x86_64_linux(self) -> None:
        """Generates valid license bypass for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0
        assert code[-1:] == b"\xc3"

    def test_generate_license_check_bypass_x86(self) -> None:
        """Generates valid license bypass for x86."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0
        assert code[-1:] == b"\xc3"

    def test_license_bypass_preserves_stack_windows(self) -> None:
        """License bypass includes stack preservation for Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)
        assert b"\x48\x83\xec\x28" in code
        assert b"\x48\x83\xc4\x28" in code

    def test_license_bypass_preserves_stack_linux(self) -> None:
        """License bypass includes stack preservation for Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)
        assert b"\x55" in code
        assert b"\x5d" in code

    def test_license_bypass_without_stack_preservation(self) -> None:
        """License bypass works without stack preservation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_license_bypass_sets_return_value_to_success(self) -> None:
        """License bypass sets return value to success (1)."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000)
        assert b"\x48\x31\xc0" in code or b"\x48\xc7\xc0" in code
        assert b"\x48\xff\xc0" in code or b"\x01\x00\x00\x00" in code


class TestTrialExtensionPatchGeneration:
    """Test trial extension patch generation."""

    def test_generate_trial_extension_x86_64_windows(self) -> None:
        """Generates valid trial extension patch for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_trial_extension_patch(0x401200, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_trial_extension_x86_64_linux(self) -> None:
        """Generates valid trial extension patch for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_trial_extension_patch(0x401200, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_trial_extension_returns_zero_timestamp(self) -> None:
        """Trial extension patch returns zero timestamp (infinite trial)."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_trial_extension_patch(0x401200)
        assert b"\x48\x31\xc0" in code


class TestActivationBypassGeneration:
    """Test activation bypass code generation."""

    def test_generate_activation_bypass_x86_64(self) -> None:
        """Generates valid activation bypass for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_activation_bypass(0x401300, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_activation_bypass_x86(self) -> None:
        """Generates valid activation bypass for x86."""
        gen = LicenseBypassCodeGenerator("x86", "linux")
        code = gen.generate_activation_bypass(0x401300, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_activation_bypass_returns_success(self) -> None:
        """Activation bypass returns success value."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_activation_bypass(0x401300)
        assert code[-1:] == b"\xc3"


class TestSerialValidationBypassGeneration:
    """Test serial validation bypass generation."""

    def test_generate_serial_validation_bypass_x86_64(self) -> None:
        """Generates valid serial validation bypass for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_serial_validation_bypass(0x401400, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_serial_validation_bypass_x86(self) -> None:
        """Generates valid serial validation bypass for x86."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_serial_validation_bypass(0x401400, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0


class TestHardwareIDSpoofGeneration:
    """Test hardware ID spoofing code generation."""

    def test_generate_hardware_id_spoof_x86_64(self) -> None:
        """Generates valid hardware ID spoof for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        spoofed_hwid = b"FAKE-HWID-12345678"
        code = gen.generate_hardware_id_spoof(0x401500, spoofed_hwid, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_hardware_id_spoof_contains_hwid_data(self) -> None:
        """Hardware ID spoof includes the spoofed HWID data."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        spoofed_hwid = b"TEST-HWID"
        code = gen.generate_hardware_id_spoof(0x401500, spoofed_hwid)
        assert spoofed_hwid in code or len(code) > len(spoofed_hwid)


class TestNOPPatchGeneration:
    """Test NOP patch generation."""

    def test_generate_nop_patch_x86_64(self) -> None:
        """Generates NOP patch for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x401000, 10)
        assert isinstance(code, bytes)
        assert len(code) == 10
        assert all(b == 0x90 for b in code)

    def test_generate_nop_patch_x86(self) -> None:
        """Generates NOP patch for x86."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_nop_patch(0x401000, 5)
        assert len(code) == 5
        assert all(b == 0x90 for b in code)

    def test_generate_nop_patch_variable_sizes(self) -> None:
        """Generates NOP patches of various sizes."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        for size in [1, 5, 10, 20, 100]:
            code = gen.generate_nop_patch(0x401000, size)
            assert len(code) == size


class TestConditionalJumpPatchGeneration:
    """Test conditional jump patch generation."""

    def test_generate_conditional_jump_patch_always_jump_x86_64(self) -> None:
        """Generates conditional jump patch that always jumps for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x401000, always_jump=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_conditional_jump_patch_never_jump_x86_64(self) -> None:
        """Generates conditional jump patch that never jumps for x86_64."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_conditional_jump_patch(0x401000, always_jump=False)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_conditional_jump_patch_x86(self) -> None:
        """Generates conditional jump patch for x86."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_conditional_jump_patch(0x401000, always_jump=True)
        assert isinstance(code, bytes)
        assert len(code) > 0


class TestReturnValuePatchGeneration:
    """Test return value patch generation."""

    def test_generate_return_value_patch_x86_64_windows(self) -> None:
        """Generates return value patch for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x401000, return_value=1, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_return_value_patch_x86_64_linux(self) -> None:
        """Generates return value patch for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        code = gen.generate_return_value_patch(0x401000, return_value=42, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_generate_return_value_patch_x86(self) -> None:
        """Generates return value patch for x86."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_return_value_patch(0x401000, return_value=0, preserve_stack=True)
        assert isinstance(code, bytes)
        assert len(code) > 0

    def test_return_value_patch_different_values(self) -> None:
        """Return value patch handles different return values."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        for value in [0, 1, 100, 0xFFFFFFFF]:
            code = gen.generate_return_value_patch(0x401000, return_value=value)
            assert isinstance(code, bytes)
            assert len(code) > 0


class TestPatchManagement:
    """Test patch tracking and management."""

    def test_get_generated_patches_initially_empty(self) -> None:
        """Generated patches list is initially empty."""
        gen = LicenseBypassCodeGenerator()
        patches = gen.get_generated_patches()
        assert patches == []

    def test_patches_tracked_after_generation(self) -> None:
        """Patches are tracked after generation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)
        patches = gen.get_generated_patches()
        assert len(patches) > 0

    def test_clear_patches(self) -> None:
        """clear_patches removes all tracked patches."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)
        assert len(gen.generated_patches) > 0
        gen.clear_patches()
        assert len(gen.generated_patches) == 0

    def test_export_patches_binary_format(self) -> None:
        """export_patches exports patches in binary format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)
        exported = gen.export_patches(format_type="binary")
        assert isinstance(exported, dict)
        assert "patches" in exported

    def test_export_patches_assembly_format(self) -> None:
        """export_patches exports patches in assembly format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)
        exported = gen.export_patches(format_type="assembly")
        assert isinstance(exported, dict)

    def test_export_patches_json_format(self) -> None:
        """export_patches exports patches in JSON format."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        gen.generate_license_check_bypass(0x401000)
        exported = gen.export_patches(format_type="json")
        assert isinstance(exported, dict)


class TestCallingConventionInfo:
    """Test calling convention information retrieval."""

    def test_get_calling_convention_info_x86_64_windows(self) -> None:
        """get_calling_convention_info returns correct info for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        info = gen.get_calling_convention_info()
        assert isinstance(info, dict)
        assert info["architecture"] == "x86_64"
        assert info["platform"] == "windows"

    def test_get_calling_convention_info_x86_64_linux(self) -> None:
        """get_calling_convention_info returns correct info for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator("x86_64", "linux")
        info = gen.get_calling_convention_info()
        assert info["architecture"] == "x86_64"
        assert info["platform"] == "linux"

    def test_calling_convention_info_includes_registers(self) -> None:
        """Calling convention info includes register information."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        info = gen.get_calling_convention_info()
        if "convention" in info:
            assert "int_params" in info["convention"] or "calling" in info["convention"]


class TestRealWorldScenarios:
    """Test realistic license bypass scenarios."""

    def test_complete_vmprotect_bypass_workflow(self) -> None:
        """Complete workflow: bypass VMProtect license check."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        license_check_address = 0x140001000
        bypass_code = gen.generate_license_check_bypass(license_check_address, preserve_stack=True)

        assert len(bypass_code) > 0
        assert bypass_code[-1:] == b"\xc3"

        patches = gen.get_generated_patches()
        assert len(patches) > 0

    def test_complete_themida_trial_reset_workflow(self) -> None:
        """Complete workflow: reset Themida trial period."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        time_check_address = 0x140002000
        trial_patch = gen.generate_trial_extension_patch(time_check_address, preserve_stack=True)

        assert len(trial_patch) > 0
        assert b"\x48\x31\xc0" in trial_patch

    def test_multi_protection_bypass_sequence(self) -> None:
        """Sequence: bypass license check, serial validation, and activation."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        license_patch = gen.generate_license_check_bypass(0x140001000)
        serial_patch = gen.generate_serial_validation_bypass(0x140002000)
        activation_patch = gen.generate_activation_bypass(0x140003000)

        assert all(len(patch) > 0 for patch in [license_patch, serial_patch, activation_patch])

        patches = gen.get_generated_patches()
        assert len(patches) >= 3

    def test_hardware_id_bypass_workflow(self) -> None:
        """Workflow: spoof hardware ID for hardware-locked license."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        original_hwid = b"REAL-HWID-ABC123"
        spoofed_hwid = b"FAKE-HWID-XYZ789"

        hwid_patch = gen.generate_hardware_id_spoof(0x140004000, spoofed_hwid, preserve_stack=True)

        assert len(hwid_patch) > 0

    def test_conditional_jump_patching_workflow(self) -> None:
        """Workflow: patch conditional jumps to bypass checks."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        jump_address_1 = 0x140001100
        jump_address_2 = 0x140001200

        always_jump = gen.generate_conditional_jump_patch(jump_address_1, always_jump=True)
        never_jump = gen.generate_conditional_jump_patch(jump_address_2, always_jump=False)

        assert len(always_jump) > 0
        assert len(never_jump) > 0

    def test_nop_out_anti_debug_checks(self) -> None:
        """Workflow: NOP out anti-debugging checks."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        anti_debug_addresses = [0x140005000, 0x140005020, 0x140005050]

        for address in anti_debug_addresses:
            nop_patch = gen.generate_nop_patch(address, 10)
            assert len(nop_patch) == 10
            assert all(b == 0x90 for b in nop_patch)

    def test_cross_platform_bypass_generation(self) -> None:
        """Generate bypasses for multiple platforms."""
        platforms = [
            ("x86_64", "windows"),
            ("x86_64", "linux"),
            ("x86", "windows"),
        ]

        for arch, platform in platforms:
            gen = LicenseBypassCodeGenerator(arch, platform)
            code = gen.generate_license_check_bypass(0x401000)
            assert len(code) > 0

    def test_export_patches_for_deployment(self) -> None:
        """Export generated patches for deployment."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        gen.generate_license_check_bypass(0x140001000)
        gen.generate_trial_extension_patch(0x140002000)
        gen.generate_activation_bypass(0x140003000)

        binary_export = gen.export_patches(format_type="binary")
        json_export = gen.export_patches(format_type="json")

        assert isinstance(binary_export, dict)
        assert isinstance(json_export, dict)
        assert "patches" in binary_export
        assert "patches" in json_export


class TestArchitectureSupport:
    """Test support for different architectures."""

    def test_x86_64_architecture_support(self) -> None:
        """Supports x86_64 architecture."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000)
        assert len(code) > 0

    def test_x86_architecture_support(self) -> None:
        """Supports x86 architecture."""
        gen = LicenseBypassCodeGenerator("x86", "windows")
        code = gen.generate_license_check_bypass(0x401000)
        assert len(code) > 0

    def test_arm64_architecture_support(self) -> None:
        """Supports ARM64 architecture."""
        gen = LicenseBypassCodeGenerator("arm64", "linux")
        code = gen.generate_license_check_bypass(0x401000)
        assert isinstance(code, bytes)

    def test_arm_architecture_support(self) -> None:
        """Supports ARM architecture."""
        gen = LicenseBypassCodeGenerator("arm", "linux")
        code = gen.generate_license_check_bypass(0x401000)
        assert isinstance(code, bytes)


class TestErrorHandling:
    """Test error handling and edge cases."""

    def test_zero_size_nop_patch(self) -> None:
        """NOP patch with zero size returns empty bytes."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_nop_patch(0x401000, 0)
        assert code == b""

    def test_large_return_value(self) -> None:
        """Return value patch handles large values."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_return_value_patch(0x401000, return_value=0xFFFFFFFF)
        assert isinstance(code, bytes)

    def test_empty_hardware_id(self) -> None:
        """Hardware ID spoof handles empty HWID."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_hardware_id_spoof(0x401000, b"")
        assert isinstance(code, bytes)


class TestCodeQuality:
    """Test generated code quality."""

    def test_all_patches_end_with_return(self) -> None:
        """All function patches end with return instruction."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")

        license_bypass = gen.generate_license_check_bypass(0x401000)
        trial_patch = gen.generate_trial_extension_patch(0x401000)
        activation_bypass = gen.generate_activation_bypass(0x401000)

        assert license_bypass[-1:] == b"\xc3"
        assert trial_patch[-1:] == b"\xc3"
        assert activation_bypass[-1:] == b"\xc3"

    def test_stack_preservation_symmetry(self) -> None:
        """Stack preservation has matching push/pop or sub/add."""
        gen = LicenseBypassCodeGenerator("x86_64", "windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert b"\x48\x83\xec" in code and b"\x48\x83\xc4" in code or b"\x55" in code and b"\x5d" in code
