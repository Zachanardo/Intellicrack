"""Regression tests for BinaryKeyValidator debugging/patching-based key validation.

Validates that previously working functionality continues to operate correctly:
- Frida dynamic instrumentation for key validation
- Breakpoint setting at validation routines
- Validation return value patching
- CPU flags and register state monitoring
- Process spawning and environment-based validation
- Radare2 binary patching for validation bypass

These tests use real binaries and actual debugging infrastructure. NO MOCKS.
Tests MUST FAIL if any regression is detected in the validation capabilities.
"""

from __future__ import annotations

import hashlib
import platform
import shutil
import subprocess
import tempfile
import threading
import time
from collections.abc import Iterator
from pathlib import Path
from typing import Any, Callable, NoReturn

import pytest

try:
    import frida

    FRIDA_AVAILABLE = True
except ImportError:
    FRIDA_AVAILABLE = False
    frida = None  # type: ignore[assignment]

try:
    import r2pipe

    R2PIPE_AVAILABLE = True
except ImportError:
    R2PIPE_AVAILABLE = False
    r2pipe = None  # type: ignore[assignment]

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False
    pefile = None  # type: ignore[assignment]

from intellicrack.core.exploitation.keygen_generator import (
    BinaryKeyValidator,
    KeyAlgorithmType,
    KeyConstraint,
    ValidationAlgorithm,
)


WINDOWS_SYSTEM_BINARIES: dict[str, Path] = {
    "notepad": Path(r"C:\Windows\System32\notepad.exe"),
    "calc": Path(r"C:\Windows\System32\calc.exe"),
    "cmd": Path(r"C:\Windows\System32\cmd.exe"),
    "powershell": Path(r"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"),
}


def _skip_not_windows() -> NoReturn:
    """Skip test if not on Windows platform."""
    pytest.skip(
        "REGRESSION TEST SKIP: Windows platform required for binary validation tests. "
        f"Current platform: {platform.system()}. "
        "BinaryKeyValidator requires Windows PE binaries with validation routines."
    )


def _skip_no_binaries() -> NoReturn:
    """Skip test if no Windows binaries available."""
    pytest.skip(
        "REGRESSION TEST SKIP: No Windows system binaries available for testing. "
        f"Checked paths: {list(WINDOWS_SYSTEM_BINARIES.values())}. "
        "BinaryKeyValidator requires real Windows PE executables for validation testing."
    )


@pytest.fixture(scope="session")
def system_binary_path() -> Path:
    """Provide path to Windows system binary for testing.

    Returns:
        Path to first available Windows system binary.

    Raises:
        pytest.skip: If no Windows system binaries are available.
    """
    if platform.system() != "Windows":
        _skip_not_windows()

    for binary_name, binary_path in WINDOWS_SYSTEM_BINARIES.items():
        if binary_path.exists():
            return binary_path

    _skip_no_binaries()


@pytest.fixture
def validation_algorithm() -> ValidationAlgorithm:
    """Create ValidationAlgorithm with realistic validation addresses.

    Returns:
        ValidationAlgorithm configured with test data.
    """
    return ValidationAlgorithm(
        algorithm_type=KeyAlgorithmType.CUSTOM,
        function_address=0x401000,
        constraints=[
            KeyConstraint(type="length", value=16, address=0x401050),
            KeyConstraint(type="pattern", value="[A-Z0-9]{16}", address=0x401080),
        ],
    )


@pytest.fixture
def temp_binary_copy(system_binary_path: Path) -> Iterator[Path]:
    """Create temporary copy of system binary for patching tests.

    Args:
        system_binary_path: Path to source binary.

    Yields:
        Path to temporary binary copy.
    """
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".exe")
    temp_path = Path(temp_file.name)
    temp_file.close()

    shutil.copy2(system_binary_path, temp_path)

    yield temp_path

    try:
        temp_path.unlink()
    except Exception:
        pass


class TestBinaryKeyValidatorInitialization:
    """Regression tests for BinaryKeyValidator initialization and address extraction."""

    def test_validator_initialization_with_valid_binary(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """BinaryKeyValidator initializes correctly with valid binary path."""
        validator = BinaryKeyValidator(
            str(system_binary_path), validation_algorithm, timeout=5.0
        )

        assert validator.binary_path == system_binary_path.resolve()
        assert validator.algorithm == validation_algorithm
        assert validator.timeout == 5.0
        assert hasattr(validator, "validation_addresses")
        assert isinstance(validator.validation_addresses, list)

    def test_validation_address_extraction_from_algorithm(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator extracts validation addresses from algorithm correctly."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        assert len(validator.validation_addresses) > 0
        assert 0x401000 in validator.validation_addresses
        assert 0x401050 in validator.validation_addresses
        assert 0x401080 in validator.validation_addresses

    def test_fallback_validation_search_when_no_addresses(
        self, system_binary_path: Path
    ) -> None:
        """Validator performs fallback search when algorithm has no addresses."""
        if not PEFILE_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: pefile required for fallback validation search. "
                "Install with: pip install pefile. "
                "This feature allows BinaryKeyValidator to find validation functions in "
                "binaries without explicit addresses by scanning for validation strings."
            )

        algorithm_no_addresses = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=None,  # type: ignore[arg-type]
            constraints=[],
        )

        validator = BinaryKeyValidator(str(system_binary_path), algorithm_no_addresses)

        assert hasattr(validator, "validation_addresses")


class TestFridaDynamicInstrumentation:
    """Regression tests for Frida-based dynamic instrumentation validation."""

    def test_frida_hook_script_generation(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator generates valid Frida hook scripts for validation addresses."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida not available for dynamic instrumentation testing. "
                "Install with: pip install frida frida-tools. "
                "Frida is required for BinaryKeyValidator to perform runtime validation "
                "by hooking validation functions and monitoring return values."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        test_key = "TESTKEY123456789"
        script_code = validator._generate_frida_hook_script(test_key)  # type: ignore[attr-defined]

        assert isinstance(script_code, str)
        assert len(script_code) > 0

        assert "Interceptor.attach" in script_code
        for addr in validator.validation_addresses:  # type: ignore[attr-defined]
            assert f"0x{addr:x}" in script_code

        assert "onEnter" in script_code
        assert "onLeave" in script_code
        assert test_key in script_code

        assert "ExitProcess" in script_code

    def test_frida_message_handler_processes_validation_results(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator message handler correctly processes Frida validation messages."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for message processing tests. "
                "BinaryKeyValidator._on_frida_message handles validation results from "
                "hooked functions. Install Frida to test this functionality."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        exit_message_success: dict[str, Any] = {
            "type": "send",
            "payload": {"type": "exit", "address": "0x401000", "result": 1},
        }

        validator._on_frida_message(exit_message_success, None)  # type: ignore[attr-defined]

        assert validator._validation_result is True  # type: ignore[attr-defined]

    def test_frida_message_handler_detects_validation_failure(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator message handler detects failed validation from return code 0."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for validation failure detection. "
                "BinaryKeyValidator must correctly identify when hooked validation "
                "functions return 0 (failure). Install Frida to test this capability."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        exit_message_failure: dict[str, Any] = {
            "type": "send",
            "payload": {"type": "exit", "address": "0x401000", "result": 0},
        }

        validator._on_frida_message(exit_message_failure, None)  # type: ignore[attr-defined]

        assert validator._validation_result is False  # type: ignore[attr-defined]

    def test_frida_message_handler_final_result_processing(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator processes final validation result from ExitProcess hook."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for final result processing. "
                "BinaryKeyValidator hooks ExitProcess to capture final validation state. "
                "This ensures all validation logic completes before result capture."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        final_message: dict[str, Any] = {
            "type": "send",
            "payload": {"type": "final", "result": True},
        }

        validator._on_frida_message(final_message, None)  # type: ignore[attr-defined]

        assert validator._validation_result is True  # type: ignore[attr-defined]

    def test_frida_validation_script_hooks_multiple_addresses(
        self, system_binary_path: Path
    ) -> None:
        """Frida script hooks all validation addresses from algorithm."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for multi-address hooking tests. "
                "BinaryKeyValidator must hook multiple validation functions to handle "
                "complex multi-stage validation. Install Frida to test this capability."
            )

        multi_address_algorithm = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=0x401000,
            constraints=[
                KeyConstraint(type="length", value=16, address=0x401050),
                KeyConstraint(type="checksum", value="crc32", address=0x401080),
                KeyConstraint(type="pattern", value="[A-Z]+", address=0x4010A0),
            ],
        )

        validator = BinaryKeyValidator(str(system_binary_path), multi_address_algorithm)
        script = validator._generate_frida_hook_script("TEST1234567890AB")  # type: ignore[attr-defined]

        assert script.count("Interceptor.attach") >= 4
        assert "0x401000" in script
        assert "0x401050" in script
        assert "0x401080" in script
        assert "0x4010a0" in script


class TestRadare2BinaryPatching:
    """Regression tests for radare2-based binary patching validation."""

    def test_radare2_patching_creates_modified_binary(
        self, temp_binary_copy: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Radare2 validation creates patched binary copy for testing."""
        if not R2PIPE_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: radare2/r2pipe not available for binary patching. "
                "Install with: pip install r2pipe && install radare2 from https://rada.re. "
                "BinaryKeyValidator uses radare2 to patch validation functions, forcing "
                "them to return success (0xb801000000c3 = mov eax,1; ret)."
            )

        original_size = temp_binary_copy.stat().st_size
        original_hash = hashlib.sha256(temp_binary_copy.read_bytes()).hexdigest()

        validator = BinaryKeyValidator(str(temp_binary_copy), validation_algorithm)

        result = validator._validate_with_radare2("TESTKEY123456789")

        current_size = temp_binary_copy.stat().st_size
        assert current_size == original_size

    def test_patched_binary_execution_environment_variables(
        self, temp_binary_copy: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Patched binary execution sets license key in environment variables."""
        if not R2PIPE_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: radare2 required for environment variable testing. "
                "BinaryKeyValidator sets LICENSE_KEY, SERIAL, REGISTRATION env vars when "
                "executing patched binaries to maximize validation code path coverage."
            )

        validator = BinaryKeyValidator(str(temp_binary_copy), validation_algorithm)

        test_key = "VALID_LICENSE_KEY123"

        with tempfile.NamedTemporaryFile(delete=False, suffix=".bat") as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write(b"@echo off\necho LICENSE_KEY=%LICENSE_KEY%\n")

        try:
            result = validator._execute_patched_binary(str(batch_path), test_key)
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_patched_binary_detects_success_indicators(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Patched binary execution detects success indicators in output."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho Validation SUCCESSFUL - license accepted\n")

        try:
            result = validator._execute_patched_binary(str(batch_path), "TESTKEY")
            assert result is True
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_patched_binary_detects_failure_indicators(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Patched binary execution detects failure indicators in output."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho ERROR: Invalid license key detected\n")

        try:
            result = validator._execute_patched_binary(str(batch_path), "BADKEY")
            assert result is False
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_patched_binary_timeout_handling(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Patched binary execution handles timeout correctly."""
        validator = BinaryKeyValidator(
            str(system_binary_path), validation_algorithm, timeout=1.0
        )

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\ntimeout /t 10 /nobreak\n")

        try:
            start_time = time.time()
            result = validator._execute_patched_binary(str(batch_path), "TESTKEY")
            elapsed = time.time() - start_time

            assert result is None
            assert elapsed < 2.0
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass


class TestProcessSpawnValidation:
    """Regression tests for process spawning-based validation."""

    def test_process_spawn_sets_environment_variables(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn validation sets license key in environment variables."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        test_key = "TEST_LICENSE_12345"

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write(
                "@echo off\n"
                "echo LICENSE_KEY=%LICENSE_KEY%\n"
                "echo SERIAL_NUMBER=%SERIAL_NUMBER%\n"
            )

        validator.binary_path = batch_path

        try:
            result = validator._validate_with_process_spawn(test_key)
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_process_spawn_uses_multiple_argument_formats(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn tries multiple command-line argument formats for keys."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        test_key = "MULTI_FORMAT_KEY_123"

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho %1 %2 %3 %4 %5 %6\n")

        validator.binary_path = batch_path

        try:
            result = validator._validate_with_process_spawn(test_key)
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_process_spawn_detects_valid_success_output(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn detects 'valid' keyword in output as success."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho License key is VALID\n")

        validator.binary_path = batch_path

        try:
            result = validator._validate_with_process_spawn("TESTKEY")
            assert result is True
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_process_spawn_detects_success_keyword(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn detects 'success' keyword in output."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho Registration SUCCESS\n")

        validator.binary_path = batch_path

        try:
            result = validator._validate_with_process_spawn("TESTKEY")
            assert result is True
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_process_spawn_detects_registered_keyword(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn detects 'registered' keyword in output."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\necho Application is now REGISTERED\n")

        validator.binary_path = batch_path

        try:
            result = validator._validate_with_process_spawn("TESTKEY")
            assert result is True
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass

    def test_process_spawn_timeout_handling(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Process spawn handles timeout without hanging."""
        validator = BinaryKeyValidator(
            str(system_binary_path), validation_algorithm, timeout=1.0
        )

        with tempfile.NamedTemporaryFile(
            mode="w", delete=False, suffix=".bat"
        ) as batch_file:
            batch_path = Path(batch_file.name)
            batch_file.write("@echo off\ntimeout /t 10 /nobreak\n")

        validator.binary_path = batch_path

        try:
            start_time = time.time()
            result = validator._validate_with_process_spawn("TESTKEY")
            elapsed = time.time() - start_time

            assert result is None
            assert elapsed < 2.0
        finally:
            try:
                batch_path.unlink()
            except Exception:
                pass


class TestHeuristicValidation:
    """Regression tests for fallback heuristic validation."""

    def test_heuristic_rejects_short_keys(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Heuristic validation rejects keys shorter than 8 characters."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        assert validator._heuristic_validate("SHORT") is False
        assert validator._heuristic_validate("1234567") is False

    def test_heuristic_accepts_valid_length_keys(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Heuristic validation accepts keys with valid length."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        assert validator._heuristic_validate("VALIDKEY12345678") is True

    def test_heuristic_validates_length_constraint(
        self, system_binary_path: Path
    ) -> None:
        """Heuristic validation enforces length constraints from algorithm."""
        length_algorithm = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=0x401000,
            constraints=[KeyConstraint(type="length", value=12, address=0x401050)],
        )

        validator = BinaryKeyValidator(str(system_binary_path), length_algorithm)

        assert validator._heuristic_validate("ABCDEFGHIJKL") is True
        assert validator._heuristic_validate("TOOLONG123456") is False
        assert validator._heuristic_validate("SHORT") is False

    def test_heuristic_validates_pattern_constraint(
        self, system_binary_path: Path
    ) -> None:
        """Heuristic validation enforces pattern constraints from algorithm."""
        pattern_algorithm = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=0x401000,
            constraints=[
                KeyConstraint(type="pattern", value="####-####-####", address=0x401050)
            ],
        )

        validator = BinaryKeyValidator(str(system_binary_path), pattern_algorithm)

        assert validator._heuristic_validate("ABCD-EFGH-IJKL") is True
        assert validator._heuristic_validate("1234-5678-9012") is True
        assert validator._heuristic_validate("INVALIDFORMAT") is False

    def test_heuristic_handles_keys_with_dashes(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Heuristic validation strips dashes and spaces before validation."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        assert validator._heuristic_validate("ABCD-EFGH-IJKL-MNOP") is True
        assert validator._heuristic_validate("ABCD EFGH IJKL MNOP") is True


class TestValidateKeyMainWorkflow:
    """Regression tests for main validate_key workflow and fallback chain."""

    def test_validate_key_tries_frida_first(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """validate_key attempts Frida validation first when available."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for validation priority testing. "
                "BinaryKeyValidator.validate_key prioritizes Frida dynamic instrumentation "
                "as the most reliable method. Install Frida to test this workflow."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        original_frida_method = validator._validate_with_frida
        frida_called = False

        def tracked_frida_validate(key: str) -> bool | None:
            nonlocal frida_called
            frida_called = True
            return None

        validator._validate_with_frida = tracked_frida_validate  # type: ignore[method-assign]

        validator.validate_key("TESTKEY123456789")

        assert frida_called is True

    def test_validate_key_fallback_to_radare2(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """validate_key falls back to radare2 when Frida unavailable."""
        if not R2PIPE_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: radare2 required for fallback chain testing. "
                "BinaryKeyValidator.validate_key uses radare2 as secondary method when "
                "Frida fails or is unavailable. Install r2pipe to test this fallback."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        radare2_called = False

        def tracked_radare2_validate(key: str) -> bool | None:
            nonlocal radare2_called
            radare2_called = True
            return None

        validator._validate_with_frida = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_radare2 = tracked_radare2_validate  # type: ignore[method-assign]

        validator.validate_key("TESTKEY123456789")

        assert radare2_called is True

    def test_validate_key_fallback_to_process_spawn(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """validate_key falls back to process spawn when other methods fail."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        process_spawn_called = False

        def tracked_process_spawn(key: str) -> bool | None:
            nonlocal process_spawn_called
            process_spawn_called = True
            return None

        validator._validate_with_frida = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_radare2 = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_process_spawn = tracked_process_spawn  # type: ignore[method-assign]

        validator.validate_key("TESTKEY123456789")

        assert process_spawn_called is True

    def test_validate_key_final_fallback_to_heuristic(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """validate_key uses heuristic validation as last resort."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        validator._validate_with_frida = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_radare2 = lambda key: None  # type: ignore[method-assign]
        validator._validate_with_process_spawn = lambda key: None  # type: ignore[method-assign]

        result = validator.validate_key("VALIDKEY12345678")

        assert isinstance(result, bool)

    def test_validate_key_returns_true_on_first_success(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """validate_key returns immediately when first method succeeds."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        radare2_called = False
        process_spawn_called = False

        validator._validate_with_frida = lambda key: True  # type: ignore[method-assign]

        def tracked_radare2(key: str) -> bool | None:
            nonlocal radare2_called
            radare2_called = True
            return None

        def tracked_spawn(key: str) -> bool | None:
            nonlocal process_spawn_called
            process_spawn_called = True
            return None

        validator._validate_with_radare2 = tracked_radare2  # type: ignore[method-assign]
        validator._validate_with_process_spawn = tracked_spawn  # type: ignore[method-assign]

        result = validator.validate_key("TESTKEY123456789")

        assert result is True
        assert radare2_called is False
        assert process_spawn_called is False


class TestProcessKilling:
    """Regression tests for safe process termination."""

    def test_kill_process_windows_taskkill(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator uses taskkill on Windows to terminate processes."""
        if platform.system() != "Windows":
            pytest.skip(
                "REGRESSION TEST SKIP: Windows required for taskkill testing. "
                "BinaryKeyValidator._kill_process uses Windows taskkill command. "
                f"Current platform: {platform.system()}"
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        proc = subprocess.Popen(
            [str(WINDOWS_SYSTEM_BINARIES["cmd"]), "/c", "timeout", "/t", "300"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        pid = proc.pid

        time.sleep(0.5)

        validator._kill_process(pid)

        time.sleep(0.5)

        assert proc.poll() is not None

    def test_kill_process_handles_invalid_pid(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator handles invalid PID without raising exceptions."""
        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        validator._kill_process(999999)

    def test_kill_process_handles_already_terminated(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator handles already terminated process gracefully."""
        if platform.system() != "Windows":
            pytest.skip(
                "REGRESSION TEST SKIP: Windows required for process termination testing. "
                f"Current platform: {platform.system()}"
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        proc = subprocess.Popen(
            [str(WINDOWS_SYSTEM_BINARIES["cmd"]), "/c", "exit"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        pid = proc.pid
        proc.wait()

        validator._kill_process(pid)


class TestThreadSafetyAndLocking:
    """Regression tests for thread-safe validation result handling."""

    def test_validation_result_thread_safety(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator uses locks for thread-safe result storage."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for thread safety testing. "
                "BinaryKeyValidator uses threading.Lock to protect _validation_result "
                "during concurrent access from Frida message callbacks."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        assert hasattr(validator, "_result_lock")
        assert isinstance(validator._result_lock, threading.Lock)

    def test_concurrent_message_handling(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validator handles concurrent Frida messages safely."""
        if not FRIDA_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: Frida required for concurrent message testing. "
                "Multiple validation functions may trigger simultaneously, requiring "
                "thread-safe result handling."
            )

        validator = BinaryKeyValidator(str(system_binary_path), validation_algorithm)

        messages = [
            {"type": "send", "payload": {"type": "exit", "result": 1}},
            {"type": "send", "payload": {"type": "exit", "result": 0}},
            {"type": "send", "payload": {"type": "final", "result": True}},
        ]

        threads = []
        for msg in messages:

            def send_message(message: dict[str, Any]) -> None:
                validator._on_frida_message(message, None)

            thread = threading.Thread(target=send_message, args=(msg,))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()

        assert validator._validation_result is not None


class TestRegressionIntegration:
    """End-to-end regression tests validating complete validation workflows."""

    def test_complete_validation_workflow_with_real_binary(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Complete validation workflow executes without errors on real binary."""
        validator = BinaryKeyValidator(
            str(system_binary_path), validation_algorithm, timeout=2.0
        )

        test_key = "TESTKEY123456789"

        result = validator.validate_key(test_key)

        assert isinstance(result, bool)

    def test_validation_with_multiple_constraints(
        self, system_binary_path: Path
    ) -> None:
        """Validation handles algorithms with multiple complex constraints."""
        complex_algorithm = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=0x401000,
            constraints=[
                KeyConstraint(type="length", value=20, address=0x401050),
                KeyConstraint(type="pattern", value="[A-Z0-9]{20}", address=0x401080),
                KeyConstraint(type="checksum", value="crc32", address=0x4010A0),
            ],
        )

        validator = BinaryKeyValidator(
            str(system_binary_path), complex_algorithm, timeout=2.0
        )

        result = validator.validate_key("ABCD1234EFGH5678IJKL")

        assert isinstance(result, bool)

    def test_validation_performance_within_timeout(
        self, system_binary_path: Path, validation_algorithm: ValidationAlgorithm
    ) -> None:
        """Validation completes within specified timeout period."""
        timeout_seconds = 3.0
        validator = BinaryKeyValidator(
            str(system_binary_path), validation_algorithm, timeout=timeout_seconds
        )

        start_time = time.time()
        validator.validate_key("TESTKEY123456789")
        elapsed = time.time() - start_time

        assert elapsed < timeout_seconds + 1.0

    def test_validation_algorithm_without_function_address(
        self, system_binary_path: Path
    ) -> None:
        """Validation works with algorithm lacking explicit function address."""
        if not PEFILE_AVAILABLE:
            pytest.skip(
                "REGRESSION TEST SKIP: pefile required for address-less validation. "
                "BinaryKeyValidator must fall back to heuristic address detection when "
                "algorithm has no function_address. Install pefile to test this capability."
            )

        no_address_algorithm = ValidationAlgorithm(
            algorithm_type=KeyAlgorithmType.CUSTOM,
            function_address=None,  # type: ignore[arg-type]
            constraints=[KeyConstraint(type="length", value=16, address=None)],  # type: ignore[arg-type]
        )

        validator = BinaryKeyValidator(
            str(system_binary_path), no_address_algorithm, timeout=2.0
        )

        result = validator.validate_key("TESTKEY123456789")

        assert isinstance(result, bool)
