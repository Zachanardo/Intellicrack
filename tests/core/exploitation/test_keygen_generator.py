"""
Comprehensive unit tests for Keygen Generator module.
Tests ALL classes: AlgorithmExtractor, ConstraintSolver, KeySpaceExplorer, KeygenGenerator.
NO MOCKS for core functionality - tests validate REAL licensing cracking capabilities.
"""

import binascii
import hashlib
import io
import random
import string
import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

try:
    from intellicrack.core.exploitation.keygen_generator import (
        AlgorithmExtractor,
        ConstraintSolver,
        KeyAlgorithmType,
        KeyConstraint,
        KeygenGenerator,
        KeygenTemplate,
        KeySpaceExplorer,
        ValidationAlgorithm,
    )
    MODULE_AVAILABLE = True
except ImportError:
    AlgorithmExtractor = None
    ConstraintSolver = None
    KeyAlgorithmType = None
    KeyConstraint = None
    KeygenGenerator = None
    KeygenTemplate = None
    KeySpaceExplorer = None
    ValidationAlgorithm = None
    MODULE_AVAILABLE = False

try:
    import capstone
    CAPSTONE_AVAILABLE = True
except ImportError:
    CAPSTONE_AVAILABLE = False

try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

try:
    import z3
    Z3_AVAILABLE = True
except ImportError:
    Z3_AVAILABLE = False

pytestmark = pytest.mark.skipif(not MODULE_AVAILABLE, reason="Module not available")


@pytest.fixture(autouse=True)
def _seed_random() -> None:
    """Seed random for reproducible test results."""
    random.seed(12345)
    yield
    random.seed(12345)


@pytest.fixture
def solver() -> ConstraintSolver:
    """Create ConstraintSolver instance."""
    return ConstraintSolver()


@pytest.fixture
def explorer() -> KeySpaceExplorer:
    """Create KeySpaceExplorer instance."""
    return KeySpaceExplorer()


@pytest.fixture
def standard_template() -> KeygenTemplate:
    """Standard keygen template."""
    return KeygenTemplate(
        format="####-####-####-####",
        charset=string.ascii_uppercase + string.digits,
        checksum_algorithm="crc32",
    )


@pytest.fixture
def digit_template() -> KeygenTemplate:
    """Digit-only template with Luhn checksum."""
    return KeygenTemplate(
        format="####-####-####-####-####-####",
        charset=string.digits,
        checksum_algorithm="luhn",
    )


@pytest.fixture
def simple_template() -> KeygenTemplate:
    """Simple template without checksum."""
    return KeygenTemplate(
        format="##########",
        charset=string.ascii_uppercase + string.digits,
        checksum_algorithm=None,
    )


@pytest.fixture
def mock_pe_binary(tmp_path: Path) -> str:
    """Create a minimal mock PE binary for testing."""
    binary_path = tmp_path / "test.exe"
    pe_header = (
        b"MZ"
        + b"\x90" * 58
        + b"\x00\x00\x00\x00"
        + b"PE\x00\x00"
        + b"\x4c\x01"
        + b"\x01\x00"
        + b"\x00" * 16
        + b"\xE0\x00\x02\x01"
        + b"\x0B\x01\x0E\x00"
        + b"\x00" * 200
    )

    binary_path.write_bytes(pe_header + b"\x00" * 1024)
    return str(binary_path)


class FakePE:
    """Fake pefile.PE object for testing."""
    def __init__(self) -> None:
        self.sections: list[Any] = []

    def close(self) -> None:
        pass


class TestAlgorithmExtractor:
    """Test AlgorithmExtractor class - 60+ tests."""

    def test_init_initializes_capstone_correctly(self) -> None:
        """Test AlgorithmExtractor.__init__() initializes Capstone disassembler."""
        extractor = AlgorithmExtractor()

        if CAPSTONE_AVAILABLE:
            assert extractor.md is not None
            assert extractor.md.arch == capstone.CS_ARCH_X86
            assert extractor.md.mode == capstone.CS_MODE_32
            assert extractor.md.detail is True
        else:
            assert extractor.md is None

    def test_init_handles_capstone_unavailable(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test AlgorithmExtractor.__init__() handles gracefully when Capstone not available."""
        import intellicrack.core.exploitation.keygen_generator as kg_module
        monkeypatch.setattr(kg_module, "CAPSTONE_AVAILABLE", False)
        extractor = AlgorithmExtractor()
        assert extractor.md is None

    def test_load_crypto_signatures_returns_all_signatures(self) -> None:
        """Test _load_crypto_signatures() returns dict with all cryptographic constants."""
        extractor = AlgorithmExtractor()
        signatures = extractor._load_crypto_signatures()

        assert isinstance(signatures, dict)
        assert b"\x67\xe6\x09\x6a" in signatures
        assert signatures[b"\x67\xe6\x09\x6a"] == "SHA256_K0"
        assert b"\x85\xae\x67\xbb" in signatures
        assert signatures[b"\x85\xae\x67\xbb"] == "SHA256_K1"
        assert b"\x78\xa4\x6a\xd7" in signatures
        assert signatures[b"\x78\xa4\x6a\xd7"] == "MD5_T0"
        assert b"\x63\x7c\x77\x7b" in signatures
        assert signatures[b"\x63\x7c\x77\x7b"] == "AES_SBOX_START"
        assert b"\xff\x25" in signatures
        assert b"\xdb\x71\x06\x41" in signatures
        assert signatures[b"\xdb\x71\x06\x41"] == "CRC32_POLY"
        assert len(signatures) >= 7

    def test_load_validation_patterns_returns_all_patterns(self) -> None:
        """Test _load_validation_patterns() returns list of validation patterns."""
        extractor = AlgorithmExtractor()
        patterns = extractor._load_validation_patterns()

        assert isinstance(patterns, list)
        assert len(patterns) >= 5

        pattern_names = [p["name"] for p in patterns]
        assert "length_check" in pattern_names
        assert "checksum_validation" in pattern_names
        assert "rsa_verify" in pattern_names
        assert "strcmp_check" in pattern_names
        assert "hardware_check" in pattern_names

        for pattern in patterns:
            assert "name" in pattern
            assert "pattern" in pattern
            assert "type" in pattern
            assert isinstance(pattern["type"], KeyAlgorithmType)

    def test_extract_algorithm_handles_file_not_found(self) -> None:
        """Test extract_algorithm() handles file not found error gracefully."""
        extractor = AlgorithmExtractor()
        result = extractor.extract_algorithm("/nonexistent/file.exe")
        assert result == []

    def test_extract_algorithm_handles_corrupted_pe(self, tmp_path: Path) -> None:
        """Test extract_algorithm() handles corrupted PE file gracefully."""
        corrupted_file = tmp_path / "corrupted.exe"
        corrupted_file.write_bytes(b"Not a valid PE file")

        extractor = AlgorithmExtractor()
        result = extractor.extract_algorithm(str(corrupted_file))
        assert result == []

    def test_extract_algorithm_returns_empty_when_pefile_unavailable(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test extract_algorithm() returns empty list when pefile not available."""
        import intellicrack.core.exploitation.keygen_generator as kg_module
        monkeypatch.setattr(kg_module, "PEFILE_AVAILABLE", False)
        extractor = AlgorithmExtractor()
        result = extractor.extract_algorithm("test.exe")
        assert result == []

    def test_find_validation_functions_uses_default_search_strings(self) -> None:
        """Test _find_validation_functions() searches for default strings when None provided."""
        extractor = AlgorithmExtractor()

        if not PEFILE_AVAILABLE:
            pytest.skip("pefile not available")

        expected_strings = [
            "Invalid",
            "License",
            "Key",
            "Serial",
            "Registration",
            "Activation",
            "Product",
            "Check",
            "Verify",
            "Validate",
        ]

        fake_pe = FakePE()
        result = extractor._find_validation_functions(fake_pe, None)
        assert isinstance(result, list)

    def test_analyze_instruction_patterns_counts_xor(self) -> None:
        """Test _analyze_instruction_patterns() counts XOR instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("xor", "eax, eax"), ("xor", "ebx, ecx"), ("add", "eax, 1")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["xor_count"] == 2

    def test_analyze_instruction_patterns_counts_add(self) -> None:
        """Test _analyze_instruction_patterns() counts ADD/ADC instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("add", "eax, 1"), ("adc", "ebx, 2"), ("sub", "ecx, 1")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["add_count"] == 2

    def test_analyze_instruction_patterns_counts_sub(self) -> None:
        """Test _analyze_instruction_patterns() counts SUB/SBB instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("sub", "eax, 1"), ("sbb", "ebx, 0"), ("add", "ecx, 1")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["sub_count"] == 2

    def test_analyze_instruction_patterns_counts_mul(self) -> None:
        """Test _analyze_instruction_patterns() counts MUL/IMUL instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("mul", "eax"), ("imul", "ebx, 5"), ("div", "ecx")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["mul_count"] == 2

    def test_analyze_instruction_patterns_counts_div(self) -> None:
        """Test _analyze_instruction_patterns() counts DIV/IDIV instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("div", "ebx"), ("idiv", "ecx"), ("mul", "eax")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["div_count"] == 2

    def test_analyze_instruction_patterns_counts_cmp(self) -> None:
        """Test _analyze_instruction_patterns() counts CMP instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("cmp", "eax, 10"), ("cmp", "ebx, ecx"), ("test", "eax, eax")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["cmp_count"] == 2

    def test_analyze_instruction_patterns_counts_call(self) -> None:
        """Test _analyze_instruction_patterns() counts CALL instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("call", "0x401000"), ("call", "printf"), ("jmp", "0x402000")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["call_count"] == 2

    def test_analyze_instruction_patterns_counts_jumps(self) -> None:
        """Test _analyze_instruction_patterns() counts jump instructions."""
        extractor = AlgorithmExtractor()
        instructions = [("je", "0x401000"), ("jnz", "0x402000"), ("jmp", "0x403000"), ("call", "printf")]

        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["jmp_count"] == 3

    def test_identify_algorithm_type_returns_rsa_signature(self) -> None:
        """Test _identify_algorithm_type() returns RSA_SIGNATURE when RSA operations detected."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA_verify", "SHA256_Init"],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.RSA_SIGNATURE

    def test_identify_algorithm_type_returns_ecc_signature(self) -> None:
        """Test _identify_algorithm_type() returns ECC_SIGNATURE when ECC/ECDSA detected."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["ECDSA_verify"],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.ECC_SIGNATURE

    def test_identify_algorithm_type_returns_symmetric_crypto(self) -> None:
        """Test _identify_algorithm_type() returns SYMMETRIC_CRYPTO when AES/DES detected."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.SYMMETRIC_CRYPTO

    def test_identify_algorithm_type_returns_cryptographic(self) -> None:
        """Test _identify_algorithm_type() returns CRYPTOGRAPHIC when SHA/MD5 detected."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["SHA256_K0", "MD5_T0"],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.CRYPTOGRAPHIC

    def test_identify_algorithm_type_returns_checksum_for_xor_add(self) -> None:
        """Test _identify_algorithm_type() returns CHECKSUM when xor_count > 5 and add_count > 5."""
        extractor = AlgorithmExtractor()
        instructions = [("xor", "eax, eax")] * 6 + [("add", "ebx, 1")] * 6
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=instructions, constants=[], strings=[], crypto_operations=[],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.CHECKSUM

    def test_identify_algorithm_type_returns_mathematical_for_mul(self) -> None:
        """Test _identify_algorithm_type() returns MATHEMATICAL when mul_count > 3."""
        extractor = AlgorithmExtractor()
        instructions = [("mul", "eax")] * 4
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=instructions, constants=[], strings=[], crypto_operations=[],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.MATHEMATICAL

    def test_identify_algorithm_type_returns_mathematical_for_div(self) -> None:
        """Test _identify_algorithm_type() returns MATHEMATICAL when div_count > 2."""
        extractor = AlgorithmExtractor()
        instructions = [("div", "ebx")] * 3
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=instructions, constants=[], strings=[], crypto_operations=[],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.MATHEMATICAL

    def test_identify_algorithm_type_returns_pattern_based(self) -> None:
        """Test _identify_algorithm_type() returns PATTERN_BASED when cmp_count > 10."""
        extractor = AlgorithmExtractor()
        instructions = [("cmp", "eax, 10")] * 11
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=instructions, constants=[], strings=[], crypto_operations=[],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.PATTERN_BASED

    def test_identify_algorithm_type_returns_custom_as_fallback(self) -> None:
        """Test _identify_algorithm_type() returns CUSTOM_ALGORITHM as fallback."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=[("nop", "")], constants=[], strings=[], crypto_operations=[],
        )

        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.CUSTOM_ALGORITHM

    def test_extract_constraints_extracts_length_constraint(self) -> None:
        """Test _extract_constraints() extracts length constraints from cmp instructions."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[("mov", "eax, strlen"), ("cmp", "eax, 16")],
            constants=[16],
            strings=[],
            crypto_operations=[],
        )

        constraints = extractor._extract_constraints(algorithm)
        length_constraints = [c for c in constraints if c.type == "length"]
        assert length_constraints
        assert any(c.value == 16 for c in length_constraints)

    def test_extract_constraints_extracts_charset_constraint(self) -> None:
        """Test _extract_constraints() extracts charset constraints from printable ASCII comparisons."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x1000,
            instructions=[("cmp", "al, 0x41")],
            constants=[0x41],
            strings=[],
            crypto_operations=[],
        )

        constraints = extractor._extract_constraints(algorithm)
        charset_constraints = [c for c in constraints if c.type == "charset"]
        assert charset_constraints

    def test_extract_constraints_adds_checksum_for_checksum_type(self) -> None:
        """Test _extract_constraints() adds checksum constraint for CHECKSUM algorithm type."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM, offset=0x1000, instructions=[], constants=[], strings=[], crypto_operations=[],
        )

        constraints = extractor._extract_constraints(algorithm)
        checksum_constraints = [c for c in constraints if c.type == "checksum"]
        assert len(checksum_constraints) == 1
        assert checksum_constraints[0].value == "crc32"

    def test_extract_key_pattern_identifies_delimiters(self) -> None:
        """Test _extract_key_pattern() identifies delimiter characters."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x1000,
            instructions=[],
            constants=[ord("-"), 4, 4, 4, 4],
            strings=[],
            crypto_operations=[],
        )

        if pattern := extractor._extract_key_pattern(algorithm):
            assert "-" in pattern

    def test_extract_key_pattern_builds_pattern_with_segments(self) -> None:
        """Test _extract_key_pattern() builds pattern string with # placeholders and delimiters."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x1000,
            instructions=[],
            constants=[ord("-"), 4, 4, 4, 4],
            strings=[],
            crypto_operations=[],
        )

        if pattern := extractor._extract_key_pattern(algorithm):
            assert "#" in pattern
            assert "-" in pattern

    def test_calculate_confidence_base_for_identified_type(self) -> None:
        """Test _calculate_confidence() returns 0.3 base when algorithm type identified."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM, offset=0x1000, instructions=[], constants=[], strings=[], crypto_operations=[],
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence >= 0.3

    def test_calculate_confidence_adds_for_crypto_operations(self) -> None:
        """Test _calculate_confidence() adds 0.1 per crypto operation (max 0.3)."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA_verify", "SHA256_Init", "MD5_Init"],
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence >= 0.6

    def test_calculate_confidence_adds_for_constraints(self) -> None:
        """Test _calculate_confidence() adds 0.05 per constraint (max 0.2)."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[
                KeyConstraint("length", "length", 16),
                KeyConstraint("charset", "charset", "ABC"),
                KeyConstraint("checksum", "checksum", "crc32"),
            ],
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence >= 0.45

    def test_calculate_confidence_adds_for_instruction_complexity(self) -> None:
        """Test _calculate_confidence() adds 0.1 for instruction complexity (>50 instructions)."""
        extractor = AlgorithmExtractor()
        instructions = [("nop", "")] * 51
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=instructions,
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence >= 0.4

    def test_calculate_confidence_adds_for_constants(self) -> None:
        """Test _calculate_confidence() adds 0.1 when constants found."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[0x12345678, 0xABCDEF00],
            strings=[],
            crypto_operations=[],
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence >= 0.4

    def test_calculate_confidence_caps_at_one(self) -> None:
        """Test _calculate_confidence() caps at 1.0 maximum."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[("nop", "")] * 100,
            constants=[1, 2, 3, 4, 5],
            strings=["test"],
            crypto_operations=["RSA_verify", "SHA256_Init", "MD5_Init", "AES_encrypt"],
            constraints=[KeyConstraint("test", "test", "test")] * 10,
        )

        confidence = extractor._calculate_confidence(algorithm)
        assert confidence <= 1.0


class TestConstraintSolver:
    """Test ConstraintSolver class - 50+ tests."""

    def test_init_initializes_z3_when_available(self) -> None:
        """Test ConstraintSolver.__init__() initializes Z3 solver when available."""
        solver = ConstraintSolver()

        if Z3_AVAILABLE:
            assert solver.solver is not None
            assert isinstance(solver.solver, z3.Solver)
        else:
            assert solver.solver is None

    def test_init_handles_z3_unavailable(self, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test ConstraintSolver.__init__() handles gracefully when Z3 not available."""
        import intellicrack.core.exploitation.keygen_generator as kg_module
        monkeypatch.setattr(kg_module, "Z3_AVAILABLE", False)
        solver = ConstraintSolver()
        assert solver.solver is None

    def test_init_crypto_engines_initializes_all_hashers(self) -> None:
        """Test _init_crypto_engines() initializes hashers (md5, sha1, sha256, sha512, crc32, luhn)."""
        solver = ConstraintSolver()
        engines = solver._init_crypto_engines()

        assert "md5" in engines
        assert "sha1" in engines
        assert "sha256" in engines
        assert "sha512" in engines
        assert "crc32" in engines
        assert "luhn" in engines

        assert engines["md5"] == hashlib.md5
        assert engines["sha1"] == hashlib.sha1
        assert engines["sha256"] == hashlib.sha256
        assert engines["sha512"] == hashlib.sha512
        assert callable(engines["crc32"])
        assert callable(engines["luhn"])

    def test_format_key_preserves_non_placeholders(self, solver: ConstraintSolver) -> None:
        """Test _format_key() formats characters according to template with # placeholders."""
        fmt = "AB##-CD##-EF##-GH##"
        chars = list("12345678")
        result = solver._format_key(chars, fmt)

        assert result.startswith("AB")
        assert "-" in result
        assert "CD" in result
        assert "EF" in result
        assert "GH" in result

        extracted = result.replace("AB", "").replace("CD", "").replace("EF", "").replace("GH", "").replace("-", "")
        assert extracted == "12345678"

    def test_format_key_handles_insufficient_chars(self, solver: ConstraintSolver) -> None:
        """Test _format_key() uses random chars when insufficient characters provided."""
        fmt = "####-####"
        chars = list("ABC")
        result = solver._format_key(chars, fmt)

        assert len(result) == 9
        assert result[4] == "-"

    def test_crc32_calculates_correct_checksum(self, solver: ConstraintSolver) -> None:
        """Test _crc32() calculates correct CRC32 using binascii."""
        data = b"Hello World"
        crc = solver._crc32(data)

        expected = binascii.crc32(data) & 0xFFFFFFFF
        assert crc == expected
        assert isinstance(crc, int)

    def test_luhn_checksum_calculates_correctly(self, solver: ConstraintSolver) -> None:
        """Test _luhn_checksum() calculates correct Luhn checksum."""
        data = "79927398713"
        checksum = solver._luhn_checksum(data)
        assert checksum == 0

    def test_calculate_luhn_generates_check_digit(self, solver: ConstraintSolver) -> None:
        """Test _calculate_luhn() calculates correct Luhn check digit."""
        base = "7992739871"
        check_digit = solver._calculate_luhn(base)
        full = base + str(check_digit)
        assert solver._verify_luhn(full)

    def test_verify_luhn_validates_correct_checksum(self, solver: ConstraintSolver) -> None:
        """Test _verify_luhn() validates Luhn checksum equals zero."""
        valid_luhn = "79927398713"
        assert solver._verify_luhn(valid_luhn) is True

        invalid_luhn = "79927398714"
        assert solver._verify_luhn(invalid_luhn) is False

    def test_apply_checksum_embeds_crc32(self, solver: ConstraintSolver, standard_template: KeygenTemplate) -> None:
        """Test _apply_checksum() calculates and embeds CRC32 in last segment."""
        pre_key = "AAAA-AAAA-AAAA-00000000"
        fixed = solver._apply_checksum(pre_key, "crc32")

        assert fixed.count("-") == 3
        assert solver._verify_checksum(fixed, "crc32") is True

    def test_apply_checksum_embeds_luhn(self, solver: ConstraintSolver, digit_template: KeygenTemplate) -> None:
        """Test _apply_checksum() calculates and embeds Luhn check digit."""
        pre_key = "1234-5678-9012-3456-7890-0000"
        applied = solver._apply_checksum(pre_key, "luhn")

        assert applied.count("-") == 5
        assert solver._verify_luhn(applied.replace("-", "")) is True

    def test_verify_checksum_validates_crc32(self, solver: ConstraintSolver) -> None:
        """Test _verify_checksum() validates CRC32 checksum in last 8 characters."""
        key = "AAAA-AAAA-AAAA-"
        data = "AAAA-AAAA-AAAA"
        crc = solver._crc32(data.encode())
        key_with_crc = f"{key}{crc:08X}"

        assert solver._verify_checksum(key_with_crc, "crc32") is True

    def test_verify_checksum_validates_luhn(self, solver: ConstraintSolver) -> None:
        """Test _verify_checksum() validates Luhn checksum."""
        valid_key = "7992739871-3"
        assert solver._verify_checksum(valid_key, "luhn") is True

    def test_verify_checksum_validates_md5(self, solver: ConstraintSolver) -> None:
        """Test _verify_checksum() validates cryptographic hash checksums (md5)."""
        payload = "PAYLOAD123"
        digest = hashlib.md5(payload.encode()).hexdigest()
        key = f"{payload}{digest[:8].upper()}"

        assert solver._verify_checksum(key, "md5") is True

    def test_verify_checksum_validates_sha256(self, solver: ConstraintSolver) -> None:
        """Test _verify_checksum() validates SHA256 checksum."""
        payload = "TESTKEY456"
        digest = hashlib.sha256(payload.encode()).hexdigest()
        key = f"{payload}{digest[:8].upper()}"

        assert solver._verify_checksum(key, "sha256") is True

    def test_match_pattern_converts_to_regex(self, solver: ConstraintSolver) -> None:
        """Test _match_pattern() converts pattern to regex and matches key."""
        pattern = "####-##-####"
        assert solver._match_pattern("ABCD-12-EF34", pattern) is True
        assert solver._match_pattern("abcd-12-ef34", pattern) is False

    def test_match_pattern_validates_format(self, solver: ConstraintSolver) -> None:
        """Test _match_pattern() validates key format correctly."""
        pattern = "####-####"
        assert solver._match_pattern("A1B2-C3D4", pattern) is True
        assert solver._match_pattern("A1B2C3D4", pattern) is False
        assert solver._match_pattern("A1B2-", pattern) is False

    def test_check_constraint_validates_length(self, solver: ConstraintSolver) -> None:
        """Test _check_constraint() validates length constraint (excluding delimiters)."""
        constraint = KeyConstraint(name="length", type="length", value=12)

        assert solver._check_constraint("AAAA-AAAA-AAAA", constraint) is True
        assert solver._check_constraint("AAA-AAA-AAA", constraint) is False

    def test_check_constraint_validates_charset(self, solver: ConstraintSolver) -> None:
        """Test _check_constraint() validates charset constraint (subset check)."""
        constraint = KeyConstraint(name="charset", type="charset", value="ABCD0123")

        assert solver._check_constraint("A1B2-C3D0", constraint) is True
        assert solver._check_constraint("A1B2-WXYZ", constraint) is False

    def test_check_constraint_validates_checksum(self, solver: ConstraintSolver) -> None:
        """Test _check_constraint() validates checksum constraint."""
        constraint = KeyConstraint(name="checksum", type="checksum", value="luhn")

        assert solver._check_constraint("79927398713", constraint) is True
        assert solver._check_constraint("79927398714", constraint) is False

    def test_check_constraint_validates_pattern(self, solver: ConstraintSolver) -> None:
        """Test _check_constraint() validates pattern constraint."""
        constraint = KeyConstraint(name="pattern", type="pattern", value="####-####")

        assert solver._check_constraint("ABCD-1234", constraint) is True
        assert solver._check_constraint("ABCD1234", constraint) is False

    def test_verify_key_checks_all_constraints(self, solver: ConstraintSolver) -> None:
        """Test _verify_key() checks key against all constraints."""
        constraints = [
            KeyConstraint(name="length", type="length", value=8),
            KeyConstraint(name="pattern", type="pattern", value="####-####"),
        ]

        assert solver._verify_key("ABCD-1234", constraints) is True
        assert solver._verify_key("ABC-123", constraints) is False
        assert solver._verify_key("ABCD1234", constraints) is False

    def test_heuristic_solve_generates_valid_keys(self, solver: ConstraintSolver, standard_template: KeygenTemplate) -> None:
        """Test _heuristic_solve() generates random keys from template charset."""
        constraints = []
        key = solver._heuristic_solve(constraints, standard_template)

        assert key.count("-") == 3
        parts = key.split("-")
        assert len(parts) == 4
        assert all(len(part) == 4 for part in parts)

    def test_heuristic_solve_applies_checksum(self, solver: ConstraintSolver, standard_template: KeygenTemplate) -> None:
        """Test _heuristic_solve() applies checksum when specified."""
        constraint = KeyConstraint(name="checksum", type="checksum", value="crc32")
        constraints = [constraint]

        key = solver._heuristic_solve(constraints, standard_template)
        assert solver._verify_checksum(key, "crc32") is True

    @pytest.mark.skipif(not Z3_AVAILABLE, reason="Z3 not available")
    def test_create_key_variables_creates_bitvec_for_segments(self, solver: ConstraintSolver) -> None:
        """Test _create_key_variables() creates 8-bit BitVec for each character position."""
        template = KeygenTemplate(format="##-##", charset="AB")
        variables = solver._create_key_variables(template)

        assert len(variables) == 4
        for var in variables:
            assert isinstance(var, z3.BitVecRef)

    @pytest.mark.skipif(not Z3_AVAILABLE, reason="Z3 not available")
    def test_add_constraint_adds_length_to_solver(self, solver: ConstraintSolver) -> None:
        """Test _add_constraint() adds length constraint to Z3 solver."""
        template = KeygenTemplate(format="####", charset="ABC")
        key_vars = solver._create_key_variables(template)
        constraint = KeyConstraint(name="length", type="length", value=4)

        solver.solver.reset()
        solver._add_constraint(constraint, key_vars, template)
        assertions = solver.solver.assertions()
        assert len(assertions) > 0

    @pytest.mark.skipif(not Z3_AVAILABLE, reason="Z3 not available")
    def test_solve_constraints_returns_satisfiable_solution(self, solver: ConstraintSolver) -> None:
        """Test solve_constraints() returns key when Z3 solver finds satisfiable solution."""
        template = KeygenTemplate(format="##", charset="AB")
        constraints = []

        if key := solver.solve_constraints(constraints, template):
            assert len(key.replace("-", "")) == 2
            assert all(c in "AB-" for c in key)


class TestKeySpaceExplorer:
    """Test KeySpaceExplorer class - 15+ tests."""

    def test_init_initializes_empty_collections(self, explorer: KeySpaceExplorer) -> None:
        """Test KeySpaceExplorer.__init__() initializes empty tested_keys set and valid_keys list."""
        assert isinstance(explorer.tested_keys, set)
        assert isinstance(explorer.valid_keys, list)
        assert len(explorer.tested_keys) == 0
        assert len(explorer.valid_keys) == 0

    def test_estimate_space_size_calculates_correctly(self, explorer: KeySpaceExplorer) -> None:
        """Test _estimate_space_size() calculates total keyspace correctly."""
        template = KeygenTemplate(format="##-#", charset="AB")
        size = explorer._estimate_space_size(template)
        assert size == 8

        template2 = KeygenTemplate(format="###", charset="ABC")
        size2 = explorer._estimate_space_size(template2)
        assert size2 == 27

    def test_explore_keyspace_uses_exhaustive_for_small_space(self, explorer: KeySpaceExplorer) -> None:
        """Test explore_keyspace() uses exhaustive search when space size < 1000000."""
        template = KeygenTemplate(format="#", charset="AB")
        constraints: list[KeyConstraint] = []

        def validator(k: str) -> bool:
            return k == "A"

        results = explorer.explore_keyspace(template, constraints, validator, max_keys=5)
        assert results == ["A"]

    def test_explore_keyspace_uses_intelligent_for_large_space(self, explorer: KeySpaceExplorer) -> None:
        """Test explore_keyspace() uses intelligent search when space size >= 1000000."""
        template = KeygenTemplate(format="####-####", charset="ABCDEF0123456789")
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        results = explorer.explore_keyspace(template, constraints, validator, max_keys=3)
        assert 0 < len(results) <= 3

    def test_exhaustive_search_generates_all_keys(self, explorer: KeySpaceExplorer) -> None:
        """Test _exhaustive_search() generates all possible keys from template."""
        template = KeygenTemplate(format="#", charset="AB")
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        results = explorer._exhaustive_search(template, constraints, validator, max_keys=10)
        assert set(results) == {"A", "B"}

    def test_exhaustive_search_checks_constraints_before_validation(self, explorer: KeySpaceExplorer) -> None:
        """Test _exhaustive_search() checks constraints before validation."""
        template = KeygenTemplate(format="##", charset="ABC")
        constraint = KeyConstraint(name="pattern", type="pattern", value="A#")
        constraints = [constraint]

        def validator(_k: str) -> bool:
            return True

        results = explorer._exhaustive_search(template, constraints, validator, max_keys=10)
        assert all(k.startswith("A") for k in results)

    def test_exhaustive_search_stops_at_max_keys(self, explorer: KeySpaceExplorer) -> None:
        """Test _exhaustive_search() stops when max_keys reached."""
        template = KeygenTemplate(format="##", charset="ABC")
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        results = explorer._exhaustive_search(template, constraints, validator, max_keys=3)
        assert len(results) == 3

    def test_intelligent_search_uses_genetic_algorithm(self, explorer: KeySpaceExplorer) -> None:
        """Test _intelligent_search() uses genetic algorithm with correct parameters."""
        template = KeygenTemplate(format="####", charset="ABCDEF0123456789")
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        results = explorer._intelligent_search(template, constraints, validator, max_keys=5)
        assert len(results) <= 5

    def test_intelligent_search_evaluates_fitness(self, explorer: KeySpaceExplorer) -> None:
        """Test _intelligent_search() evaluates fitness for each individual."""
        template = KeygenTemplate(format="##", charset="AB")
        constraint = KeyConstraint(name="pattern", type="pattern", value="A#", priority=1)
        constraints = [constraint]

        def validator(k: str) -> bool:
            return k == "AB"

        key1 = "AB"
        key2 = "BA"
        fitness1 = explorer._evaluate_fitness(key1, constraints, validator)
        fitness2 = explorer._evaluate_fitness(key2, constraints, validator)

        assert fitness1 == 1.0
        assert fitness2 < 1.0

    def test_evaluate_fitness_returns_one_for_valid_key(self, explorer: KeySpaceExplorer) -> None:
        """Test _evaluate_fitness() returns 1.0 when validator passes."""
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        fitness = explorer._evaluate_fitness("ABCD", constraints, validator)
        assert fitness == 1.0

    def test_crossover_performs_single_point_crossover(self, explorer: KeySpaceExplorer) -> None:
        """Test _crossover() performs single-point crossover between parent keys."""
        parent1 = "AAAA-AAAA"
        parent2 = "BBBB-BBBB"

        child = explorer._crossover(parent1, parent2)
        assert len(child) == len(parent1)
        assert child.count("-") == 1

    def test_crossover_returns_parent_for_different_lengths(self, explorer: KeySpaceExplorer) -> None:
        """Test _crossover() returns random parent when segment counts differ."""
        parent1 = "AA-AA"
        parent2 = "BBB-BBB-BBB"

        child = explorer._crossover(parent1, parent2)
        assert child in [parent1, parent2]

    def test_mutate_changes_random_character(self, explorer: KeySpaceExplorer) -> None:
        """Test _mutate() changes random character in random segment."""
        template = KeygenTemplate(format="####-####", charset="ABCDEFGHIJ")
        key = "AAAA-AAAA"

        mutated = explorer._mutate(key, template)
        assert len(mutated) == len(key)
        assert mutated.count("-") == key.count("-")

        if mutated != key:
            diff_count = sum(bool(a != b)
                         for a, b in zip(key, mutated))
            assert diff_count >= 1

    def test_generate_all_keys_yields_all_combinations(self, explorer: KeySpaceExplorer) -> None:
        """Test _generate_all_keys() yields all combinations using itertools.product."""
        template = KeygenTemplate(format="#-#", charset="AB")
        all_keys = list(explorer._generate_all_keys(template))

        expected = ["A-A", "A-B", "B-A", "B-B"]
        assert set(all_keys) == set(expected)

    def test_random_key_generates_from_charset(self, explorer: KeySpaceExplorer) -> None:
        """Test _random_key() generates random key from template charset."""
        template = KeygenTemplate(format="##-##", charset="XYZ")
        key = explorer._random_key(template)

        assert len(key) == 5
        assert key[2] == "-"
        assert all(c in "XYZ-" for c in key)


class FakeAlgorithmExtractor:
    """Fake AlgorithmExtractor that returns predetermined algorithms."""
    def __init__(self, algorithms_to_return: list[ValidationAlgorithm]) -> None:
        self.algorithms_to_return = algorithms_to_return

    def extract_algorithm(self, binary_path: str) -> list[ValidationAlgorithm]:
        return self.algorithms_to_return


class FakeValidator:
    """Fake validator function that accepts all keys."""
    def __init__(self, accept_all: bool = True, target_key: str | None = None) -> None:
        self.accept_all = accept_all
        self.target_key = target_key

    def __call__(self, key: str) -> bool:
        if self.accept_all:
            return True
        if self.target_key:
            return key == self.target_key
        return False


class TestKeygenGenerator:
    """Test KeygenGenerator class - 30+ tests."""

    def test_init_initializes_all_components(self) -> None:
        """Test KeygenGenerator.__init__() initializes AlgorithmExtractor, ConstraintSolver, KeySpaceExplorer."""
        generator = KeygenGenerator()

        assert isinstance(generator.extractor, AlgorithmExtractor)
        assert isinstance(generator.solver, ConstraintSolver)
        assert isinstance(generator.explorer, KeySpaceExplorer)
        assert isinstance(generator.templates, dict)

    def test_load_templates_loads_all_templates(self) -> None:
        """Test _load_templates() loads all templates (standard, windows, adobe, simple)."""
        generator = KeygenGenerator()
        templates = generator._load_templates()

        assert "standard" in templates
        assert "windows" in templates
        assert "adobe" in templates
        assert "simple" in templates

    def test_load_templates_standard_has_correct_format(self) -> None:
        """Test _load_templates() standard template has format and crc32 checksum."""
        generator = KeygenGenerator()
        standard = generator.templates["standard"]

        assert standard.format == "####-####-####-####"
        assert standard.checksum_algorithm == "crc32"
        assert string.ascii_uppercase in standard.charset
        assert string.digits in standard.charset

    def test_load_templates_windows_has_five_segments(self) -> None:
        """Test _load_templates() windows template has 5 segments and mod7 checksum."""
        generator = KeygenGenerator()
        windows = generator.templates["windows"]

        assert windows.format == "#####-#####-#####-#####-#####"
        assert windows.checksum_algorithm == "mod7"
        assert windows.format.count("-") == 4

    def test_load_templates_adobe_has_six_segments_digits(self) -> None:
        """Test _load_templates() adobe template has 6 segments of 4 digits and luhn checksum."""
        generator = KeygenGenerator()
        adobe = generator.templates["adobe"]

        assert adobe.format == "####-####-####-####-####-####"
        assert adobe.checksum_algorithm == "luhn"
        assert adobe.charset == string.digits
        assert adobe.format.count("-") == 5

    def test_load_templates_simple_has_no_checksum(self) -> None:
        """Test _load_templates() simple template has 10 characters and no checksum."""
        generator = KeygenGenerator()
        simple = generator.templates["simple"]

        assert simple.format == "##########"
        assert simple.checksum_algorithm is None
        assert len(simple.format) == 10

    def test_heuristic_generation_generates_requested_keys(self) -> None:
        """Test _heuristic_generation() generates random keys when no algorithm found."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("simple", 5)

        assert len(keys) == 5
        for key in keys:
            assert len(key) == 10
            assert key.isalnum()

    def test_heuristic_generation_applies_checksum_when_configured(self) -> None:
        """Test _heuristic_generation() applies checksum when template has checksum_algorithm."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("standard", 3)

        assert len(keys) == 3
        for key in keys:
            assert generator.solver._verify_checksum(key, "crc32") is True

    def test_generate_keygen_falls_back_to_heuristic(self, mock_pe_binary: str, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test generate_keygen() falls back to heuristic generation when no algorithms found."""
        generator = KeygenGenerator()

        fake_extractor = FakeAlgorithmExtractor([])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        keys = generator.generate_keygen(mock_pe_binary, template_name="simple", num_keys=4)

        assert 0 < len(keys) <= 4
        for key in keys:
            assert len(key) == 10
            assert key.isalnum()

    def test_generate_keygen_selects_highest_confidence_algorithm(self, mock_pe_binary: str, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test generate_keygen() selects algorithm with highest confidence."""
        generator = KeygenGenerator()

        algo1 = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM, offset=0x1000, instructions=[], constants=[], strings=[], crypto_operations=[], confidence=0.5,
        )
        algo2 = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x2000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            confidence=0.8,
        )

        fake_extractor = FakeAlgorithmExtractor([algo1, algo2])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        fake_validator = FakeValidator(accept_all=True)
        monkeypatch.setattr(generator, "_create_validator", lambda alg: fake_validator)

        keys = generator.generate_keygen(mock_pe_binary, num_keys=1)

    def test_validate_checksum_key_identifies_crc32(self) -> None:
        """Test _validate_checksum_key() identifies checksum type from crypto operations."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["CRC32_POLY"],
        )

        key = "AAAA-AAAA-AAAA-"
        data = "AAAA-AAAA-AAAA"
        crc = generator.solver._crc32(data.encode())
        key_with_crc = f"{key}{crc:08X}"

        result = generator._validate_checksum_key(key_with_crc, algorithm)
        assert result is True

    def test_validate_rsa_key_validates_minimum_length(self) -> None:
        """Test _validate_rsa_key() validates minimum key length (16 chars without delimiters)."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE, offset=0x1000, instructions=[], constants=[], strings=[], crypto_operations=[],
        )

        assert generator._validate_rsa_key("AAAA-AAAA-AAAA-AAAA", algorithm) is True
        assert generator._validate_rsa_key("AAA-AAA", algorithm) is False

    def test_validate_pattern_key_matches_constraint(self) -> None:
        """Test _validate_pattern_key() matches key against pattern constraint."""
        generator = KeygenGenerator()
        constraint = KeyConstraint(name="pattern", type="pattern", value="####-####")
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[constraint],
        )

        assert generator._validate_pattern_key("ABCD-1234", algorithm) is True
        assert generator._validate_pattern_key("ABCD1234", algorithm) is False

    def test_batch_generate_creates_output_file(self, mock_pe_binary: str, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test batch_generate() generates specified number of keys and saves to file."""
        generator = KeygenGenerator()
        output_file = str(tmp_path / "keys.txt")

        fake_extractor = FakeAlgorithmExtractor([])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        keys = generator.batch_generate(mock_pe_binary, output_file, num_keys=5, template="simple")

        assert Path(output_file).exists()
        content = Path(output_file).read_text()
        lines = content.strip().split("\n")
        assert len(lines) == 5

    def test_batch_generate_creates_statistics_json(self, mock_pe_binary: str, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test batch_generate() generates statistics JSON file."""
        generator = KeygenGenerator()
        output_file = str(tmp_path / "keys.txt")

        fake_extractor = FakeAlgorithmExtractor([])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        generator.batch_generate(mock_pe_binary, output_file, num_keys=5, template="simple")

        stats_file = str(tmp_path / "keys_stats.json")
        assert Path(stats_file).exists()

        import json

        stats = json.loads(Path(stats_file).read_text())
        assert "total_generated" in stats
        assert "unique_keys" in stats
        assert "template_used" in stats
        assert "algorithm_extracted" in stats
        assert stats["template_used"] == "simple"


class TestRealWorldScenarios:
    """Real-world scenario tests with actual cryptographic algorithms - 15+ tests."""

    def test_crc32_validation_real_algorithm(self) -> None:
        """Test with real CRC32 validation algorithm."""
        solver = ConstraintSolver()

        data = "TESTKEY123"
        expected_crc = binascii.crc32(data.encode()) & 0xFFFFFFFF

        key = f"{data}{expected_crc:08X}"
        assert solver._verify_checksum(key, "crc32") is True

        key_invalid = f"{data}DEADBEEF"
        assert solver._verify_checksum(key_invalid, "crc32") is False

    def test_luhn_validation_real_algorithm(self) -> None:
        """Test with real Luhn algorithm (common in activation codes)."""
        solver = ConstraintSolver()

        base = "123456789012"
        check_digit = solver._calculate_luhn(base)
        full_key = base + str(check_digit)

        assert solver._verify_luhn(full_key) is True

        invalid_key = base + str((check_digit + 1) % 10)
        assert solver._verify_luhn(invalid_key) is False

    def test_md5_hash_validation_real(self) -> None:
        """Test with real MD5 hash validation."""
        solver = ConstraintSolver()

        payload = "LICENSE2024"
        md5_hash = hashlib.md5(payload.encode()).hexdigest()
        key = f"{payload}{md5_hash[:8].upper()}"

        assert solver._verify_checksum(key, "md5") is True

    def test_sha256_hash_validation_real(self) -> None:
        """Test with real SHA256 hash validation."""
        solver = ConstraintSolver()

        payload = "PRODUCTKEY999"
        sha_hash = hashlib.sha256(payload.encode()).hexdigest()
        key = f"{payload}{sha_hash[:8].upper()}"

        assert solver._verify_checksum(key, "sha256") is True

    def test_pattern_based_validation_real(self) -> None:
        """Test with real pattern-based validation (specific format)."""
        solver = ConstraintSolver()
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="####-####-####", charset="ABCDEF0123456789")
        constraint = KeyConstraint(name="pattern", type="pattern", value="####-####-####")
        constraints = [constraint]

        def validator(k: str) -> bool:
            return solver._match_pattern(k, "####-####-####")

        keys = explorer.explore_keyspace(template, constraints, validator, max_keys=5)
        assert len(keys) > 0
        for key in keys:
            assert solver._match_pattern(key, "####-####-####") is True

    def test_genetic_algorithm_convergence_real(self) -> None:
        """Test genetic algorithm convergence (finds valid keys within 50 generations)."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="####", charset="ABCDEF0123456789")
        target_key = "ABCD"

        def validator(k: str) -> bool:
            return k == target_key

        constraints: list[KeyConstraint] = []
        keys = explorer._intelligent_search(template, constraints, validator, max_keys=1)

        if len(keys) > 0:
            assert keys[0] == target_key

    def test_exhaustive_search_completes_small_keyspace(self) -> None:
        """Test exhaustive search completes for small keyspaces (<1M combinations)."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="##", charset="ABC")
        constraints: list[KeyConstraint] = []

        def validator(_k: str) -> bool:
            return True

        keys = explorer._exhaustive_search(template, constraints, validator, max_keys=100)
        assert len(keys) == 9

    def test_z3_constraint_solver_satisfiable_solution(self) -> None:
        """Test Z3 constraint solver generates satisfiable solutions for complex constraints."""
        if not Z3_AVAILABLE:
            pytest.skip("Z3 not available")

        solver = ConstraintSolver()
        template = KeygenTemplate(format="####", charset="ABCDEFGHIJKLMNOP")

        length_constraint = KeyConstraint(name="length", type="length", value=4)
        charset_constraint = KeyConstraint(name="charset", type="charset", value="ABCDEFGHIJKLMNOP")
        constraints = [length_constraint, charset_constraint]

        if key := solver.solve_constraints(constraints, template):
            assert len(key.replace("-", "")) == 4
            assert all(c in "ABCDEFGHIJKLMNOP-" for c in key)

    def test_batch_generation_creates_unique_keys(self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Test batch generation creates valid, non-duplicate keys."""
        generator = KeygenGenerator()

        binary_path = tmp_path / "test.exe"
        binary_path.write_bytes(b"MZ" + b"\x00" * 1024)

        output_file = str(tmp_path / "batch_keys.txt")

        fake_extractor = FakeAlgorithmExtractor([])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        keys = generator.batch_generate(str(binary_path), output_file, num_keys=20, template="simple")

        assert len(keys) == 20
        assert len(set(keys)) == len(keys)

    def test_constraint_solver_multi_constraint_validation(self) -> None:
        """Test constraint solver with multiple constraints simultaneously."""
        solver = ConstraintSolver()

        constraints = [
            KeyConstraint(name="length", type="length", value=12),
            KeyConstraint(name="charset", type="charset", value=string.ascii_uppercase + string.digits),
            KeyConstraint(name="pattern", type="pattern", value="####-####-####"),
        ]

        template = KeygenTemplate(format="####-####-####", charset=string.ascii_uppercase + string.digits)

        key = solver._heuristic_solve(constraints, template)
        assert solver._verify_key(key, constraints) is True

    def test_keygen_with_checksum_constraint_integration(self) -> None:
        """Test keygen generation with checksum constraint integration."""
        generator = KeygenGenerator()
        solver = generator.solver

        template = generator.templates["standard"]
        constraint = KeyConstraint(name="checksum", type="checksum", value="crc32")
        constraints = [constraint]

        key = solver._heuristic_solve(constraints, template)
        assert solver._verify_checksum(key, "crc32") is True

    def test_algorithm_extraction_confidence_scoring(self) -> None:
        """Test algorithm extraction confidence scoring is realistic."""
        extractor = AlgorithmExtractor()

        high_confidence_algo = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x1000,
            instructions=[("nop", "")] * 60,
            constants=[1, 2, 3, 4, 5],
            strings=["test"],
            crypto_operations=["RSA_verify", "SHA256_Init"],
            constraints=[KeyConstraint("test", "length", 16)],
        )

        confidence = extractor._calculate_confidence(high_confidence_algo)
        assert 0.7 <= confidence <= 1.0

        low_confidence_algo = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN, offset=0x1000, instructions=[], constants=[], strings=[], crypto_operations=[],
        )

        confidence_low = extractor._calculate_confidence(low_confidence_algo)
        assert confidence_low < 0.3

    def test_keyspace_exploration_fitness_evaluation(self) -> None:
        """Test keyspace exploration fitness evaluation works correctly."""
        explorer = KeySpaceExplorer()

        constraint_high = KeyConstraint(name="pattern", type="pattern", value="A###", priority=10)
        constraint_low = KeyConstraint(name="length", type="length", value=4, priority=1)
        constraints = [constraint_high, constraint_low]

        def validator(k: str) -> bool:
            return k == "ABCD"

        fitness_exact = explorer._evaluate_fitness("ABCD", constraints, validator)
        assert fitness_exact == 1.0

        fitness_partial = explorer._evaluate_fitness("AXYZ", constraints, validator)
        assert 0.0 < fitness_partial < 1.0

        fitness_none = explorer._evaluate_fitness("BXYZ", constraints, validator)
        assert fitness_none < fitness_partial

    def test_comprehensive_keygen_workflow(self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:
        """Integration test: Extract algorithm, generate keys, validate keys."""
        generator = KeygenGenerator()

        binary_path = tmp_path / "target.exe"
        binary_path.write_bytes(b"MZ" + b"\x00" * 1024)

        mock_algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[KeyConstraint("checksum", "checksum", "crc32")],
            confidence=0.8,
        )

        fake_extractor = FakeAlgorithmExtractor([mock_algorithm])
        monkeypatch.setattr(generator, "extractor", fake_extractor)

        def validator(k: str) -> bool:
            return generator.solver._verify_checksum(k, "crc32")

        fake_validator_obj = FakeValidator(accept_all=False)
        fake_validator_obj.__call__ = validator
        monkeypatch.setattr(generator, "_create_validator", lambda alg: validator)

        keys = generator.generate_keygen(str(binary_path), template_name="standard", num_keys=5)

        assert len(keys) > 0
        for key in keys:
            assert generator.solver._verify_checksum(key, "crc32") is True
