"""Comprehensive production-grade tests for CryptoKeyExtractor.

Tests validate real cryptographic key extraction from protected binaries.
All tests use genuine cryptographic data - no mocks, stubs, or simulations.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

import os
import struct
from pathlib import Path
from typing import Any

import pytest
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from Crypto.Cipher import AES, DES3  # noqa: S413

from intellicrack.core.exploitation.crypto_key_extractor import (
    CryptoKeyExtractor,
    ExtractedKey,
    KeyType,
)


@pytest.fixture(scope="session")
def real_rsa_2048_keypair() -> tuple[bytes, bytes, int, int, int]:
    """Generate real RSA-2048 key pair for testing extraction."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend(),
    )

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    private_numbers = private_key.private_numbers()
    public_numbers = private_numbers.public_numbers

    return (
        private_pem,
        public_pem,
        public_numbers.n,
        public_numbers.e,
        private_numbers.d,
    )


@pytest.fixture(scope="session")
def real_rsa_4096_keypair() -> tuple[bytes, bytes, int, int, int]:
    """Generate real RSA-4096 key pair for testing extraction."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096,
        backend=default_backend(),
    )

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    private_numbers = private_key.private_numbers()
    public_numbers = private_numbers.public_numbers

    return (
        private_pem,
        public_pem,
        public_numbers.n,
        public_numbers.e,
        private_numbers.d,
    )


@pytest.fixture(scope="session")
def real_ecc_p256_keypair() -> tuple[bytes, bytes, int, int]:
    """Generate real ECC P-256 key pair for testing extraction."""
    private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    public_numbers = public_key.public_numbers()
    private_numbers = private_key.private_numbers()

    return (
        private_pem,
        public_pem,
        public_numbers.x,
        public_numbers.y,
    )


@pytest.fixture(scope="session")
def real_ecc_secp256k1_keypair() -> tuple[bytes, bytes, int, int]:
    """Generate real secp256k1 key pair (Bitcoin/Ethereum curve)."""
    private_key = ec.generate_private_key(ec.SECP256K1(), default_backend())

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    public_numbers = public_key.public_numbers()

    return (
        private_pem,
        public_pem,
        public_numbers.x,
        public_numbers.y,
    )


@pytest.fixture(scope="session")
def real_aes_128_expanded_key() -> tuple[bytes, bytes]:
    """Generate real AES-128 key and its expanded schedule."""
    key = os.urandom(16)
    cipher = AES.new(key, AES.MODE_ECB)  # noqa: S413

    test_data = b"\x00" * 16
    cipher.encrypt(test_data)

    return key, key


@pytest.fixture(scope="session")
def real_aes_256_expanded_key() -> tuple[bytes, bytes]:
    """Generate real AES-256 key and its expanded schedule."""
    key = os.urandom(32)
    cipher = AES.new(key, AES.MODE_ECB)  # noqa: S413

    test_data = b"\x00" * 16
    cipher.encrypt(test_data)

    return key, key


@pytest.fixture(scope="session")
def real_3des_key() -> bytes:
    """Generate real 3DES key."""
    return DES3.adjust_key_parity(os.urandom(24))


@pytest.fixture
def extractor() -> CryptoKeyExtractor:
    """Create fresh CryptoKeyExtractor instance."""
    return CryptoKeyExtractor()


class TestRSAKeyExtraction:
    """Test RSA key extraction from memory and binaries."""

    def test_extract_rsa_2048_pem_from_memory(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Extract RSA-2048 PEM key embedded in memory dump."""
        private_pem, public_pem, n, e, d = real_rsa_2048_keypair

        memory_dump = b"\x00" * 1024 + private_pem + b"\x00" * 1024

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract RSA PEM key from memory"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys found in extraction results"

        extracted = rsa_keys[0]
        assert extracted.key_size >= 2048, f"Expected 2048-bit key, got {extracted.key_size}"
        assert extracted.confidence > 0.7, f"Low confidence: {extracted.confidence}"
        assert extracted.pem_format is not None, "PEM format not extracted"
        assert b"BEGIN" in extracted.pem_format.encode() if isinstance(extracted.pem_format, str) else b"BEGIN" in extracted.pem_format

    def test_extract_rsa_4096_der_from_memory(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_4096_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Extract RSA-4096 DER key from binary data."""
        private_pem, _, n, e, d = real_rsa_4096_keypair

        private_key = serialization.load_pem_private_key(
            private_pem,
            password=None,
            backend=default_backend(),
        )

        der_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        memory_dump = b"\xff" * 2048 + der_bytes + b"\xff" * 2048

        keys = extractor._extract_der_keys(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract RSA DER key"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys found in DER extraction"

        extracted = rsa_keys[0]
        assert extracted.key_size >= 4096, f"Expected 4096-bit key, got {extracted.key_size}"
        assert extracted.der_format is not None, "DER format not extracted"

    def test_extract_rsa_modulus_from_raw_memory(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Extract RSA modulus from raw memory without format markers."""
        _, _, n, e, d = real_rsa_2048_keypair

        modulus_bytes = n.to_bytes(256, byteorder="big")

        memory_dump = b"\xde\xad\xbe\xef" + modulus_bytes + b"\xca\xfe\xba\xbe"

        keys = extractor._find_rsa_modulus(memory_dump, bit_size=2048, base_address=0)

        assert len(keys) > 0, "Failed to extract RSA modulus from raw memory"

        extracted = keys[0]
        assert extracted.key_type in (KeyType.RSA_PUBLIC, KeyType.RSA_PRIVATE)
        assert extracted.key_size == 2048

        extracted_n = int.from_bytes(extracted.raw_bytes[:256], byteorder="big")
        assert extracted_n == n, "Extracted modulus doesn't match original"

    def test_extract_rsa_crt_components(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Extract RSA-CRT components (p, q, dP, dQ, qInv) from memory."""
        private_pem, _, n, e, d = real_rsa_2048_keypair

        private_key = serialization.load_pem_private_key(
            private_pem,
            password=None,
            backend=default_backend(),
        )

        private_numbers = private_key.private_numbers()
        p = private_numbers.p
        q = private_numbers.q
        dmp1 = private_numbers.dmp1
        dmq1 = private_numbers.dmq1
        iqmp = private_numbers.iqmp

        p_bytes = p.to_bytes(128, byteorder="big")
        q_bytes = q.to_bytes(128, byteorder="big")

        memory_dump = b"\x00" * 512 + p_bytes + q_bytes + b"\x00" * 512

        keys = extractor._find_rsa_crt_components(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract RSA-CRT components"

        for key in keys:
            assert key.key_type in (KeyType.RSA_PRIVATE, KeyType.CUSTOM)
            assert "crt" in key.context.lower() or "montgomery" in key.context.lower()


class TestECCKeyExtraction:
    """Test ECC key extraction from memory and binaries."""

    def test_extract_p256_pem_key(
        self,
        extractor: CryptoKeyExtractor,
        real_ecc_p256_keypair: tuple[bytes, bytes, int, int],
    ) -> None:
        """Extract P-256 ECC key in PEM format."""
        private_pem, public_pem, x, y = real_ecc_p256_keypair

        memory_dump = b"\x00" * 256 + private_pem + b"\x00" * 256

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract ECC PEM key"

        ecc_keys = [k for k in keys if k.key_type in (KeyType.ECC_PRIVATE, KeyType.ECC_PUBLIC)]
        assert len(ecc_keys) > 0, "No ECC keys found in extraction"

        extracted = ecc_keys[0]
        assert extracted.key_size == 256, f"Expected 256-bit key, got {extracted.key_size}"
        assert extracted.pem_format is not None

    def test_extract_secp256k1_raw_point(
        self,
        extractor: CryptoKeyExtractor,
        real_ecc_secp256k1_keypair: tuple[bytes, bytes, int, int],
    ) -> None:
        """Extract secp256k1 public key point from raw memory."""
        _, _, x, y = real_ecc_secp256k1_keypair

        x_bytes = x.to_bytes(32, byteorder="big")
        y_bytes = y.to_bytes(32, byteorder="big")

        uncompressed_point = b"\x04" + x_bytes + y_bytes

        memory_dump = b"\xff" * 128 + uncompressed_point + b"\xff" * 128

        keys = extractor._find_ecc_points(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract ECC point from raw memory"

        extracted = keys[0]
        assert extracted.key_type == KeyType.ECC_PUBLIC
        assert extracted.key_size == 256

        assert "x" in extracted.parameters
        assert "y" in extracted.parameters

        extracted_x = extracted.parameters["x"]
        extracted_y = extracted.parameters["y"]

        assert extracted_x == x, "Extracted X coordinate doesn't match"
        assert extracted_y == y, "Extracted Y coordinate doesn't match"

    def test_verify_ecc_point_on_curve(
        self,
        extractor: CryptoKeyExtractor,
        real_ecc_p256_keypair: tuple[bytes, bytes, int, int],
    ) -> None:
        """Verify extracted ECC points lie on correct curve."""
        _, _, x, y = real_ecc_p256_keypair

        curve_params = extractor.ecc_curves["P-256"]

        is_valid = extractor._verify_ecc_point(x, y, curve_params)

        assert is_valid, "Valid P-256 point not verified correctly"

        invalid_x = x + 1
        is_invalid = extractor._verify_ecc_point(invalid_x, y, curve_params)

        assert not is_invalid, "Invalid point incorrectly verified as valid"

    def test_extract_multiple_ecc_curves(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract keys from multiple ECC curves in single memory dump."""
        p256_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        p384_key = ec.generate_private_key(ec.SECP384R1(), default_backend())
        secp256k1_key = ec.generate_private_key(ec.SECP256K1(), default_backend())

        p256_pem = p256_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        p384_pem = p384_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        secp256k1_pem = secp256k1_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        memory_dump = (
            b"\x00" * 128 +
            p256_pem +
            b"\x00" * 128 +
            p384_pem +
            b"\x00" * 128 +
            secp256k1_pem +
            b"\x00" * 128
        )

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        ecc_keys = [k for k in keys if k.key_type in (KeyType.ECC_PRIVATE, KeyType.ECC_PUBLIC)]

        assert len(ecc_keys) >= 3, f"Expected at least 3 ECC keys, found {len(ecc_keys)}"

        key_sizes = {k.key_size for k in ecc_keys}
        assert 256 in key_sizes, "P-256 key not found"
        assert 384 in key_sizes, "P-384 key not found"


class TestAESKeyExtraction:
    """Test AES key extraction from memory."""

    def test_extract_aes_128_expanded_schedule(
        self,
        extractor: CryptoKeyExtractor,
        real_aes_128_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Extract AES-128 expanded key schedule from memory."""
        original_key, expanded_key = real_aes_128_expanded_key

        cipher = AES.new(original_key, AES.MODE_ECB)  # noqa: S413

        sbox = extractor._get_aes_sbox()

        memory_dump = b"\x00" * 512 + sbox + original_key + b"\x00" * 512

        keys = extractor._scan_key_schedules(memory_dump, base_address=0)

        aes_keys = [k for k in keys if k.key_type == KeyType.AES]

        assert len(aes_keys) > 0, "Failed to extract AES key schedule"

        extracted = aes_keys[0]
        assert extracted.key_size in (128, 192, 256), f"Invalid AES key size: {extracted.key_size}"
        assert len(extracted.raw_bytes) >= 16, "Extracted key too short"

    def test_extract_aes_256_from_encryption_context(
        self,
        extractor: CryptoKeyExtractor,
        real_aes_256_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Extract AES-256 key from active encryption context."""
        original_key, _ = real_aes_256_expanded_key

        iv = os.urandom(16)
        cipher = Cipher(
            algorithms.AES(original_key),
            modes.CBC(iv),
            backend=default_backend(),
        )
        encryptor = cipher.encryptor()

        plaintext = b"A" * 64
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()

        memory_dump = (
            b"\x00" * 256 +
            original_key +
            iv +
            plaintext +
            ciphertext +
            b"\x00" * 256
        )

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=0)

        aes_keys = [k for k in keys if k.key_type == KeyType.AES and k.key_size == 256]

        assert len(aes_keys) > 0, "Failed to extract AES-256 key"

        extracted = aes_keys[0]
        assert extracted.raw_bytes == original_key or extracted.raw_bytes in original_key

    def test_detect_aes_sbox_proximity(
        self,
        extractor: CryptoKeyExtractor,
        real_aes_128_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Detect AES keys by S-box proximity in memory."""
        original_key, _ = real_aes_128_expanded_key

        sbox = extractor._get_aes_sbox()

        memory_dump = sbox + b"\x00" * 16 + original_key + b"\x00" * 256

        keys = extractor._scan_key_schedules(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to detect AES key near S-box"

        has_aes_key = any(k.key_type == KeyType.AES for k in keys)
        assert has_aes_key, "No AES key detected despite S-box proximity"

    def test_extract_aes_round_keys(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract AES round keys from expanded key schedule."""
        original_key = os.urandom(16)

        expanded_pattern = extractor._generate_key_expansion_pattern(16, 11)

        memory_dump = b"\xff" * 128 + expanded_pattern[:176] + b"\xff" * 128

        keys = extractor._scan_key_schedules(memory_dump, base_address=0)

        aes_keys = [k for k in keys if k.key_type == KeyType.AES]

        assert len(aes_keys) > 0, "Failed to extract round keys from expanded schedule"


class TestSymmetricKeyExtraction:
    """Test symmetric key extraction (AES, 3DES, etc.)."""

    def test_extract_3des_key(
        self,
        extractor: CryptoKeyExtractor,
        real_3des_key: bytes,
    ) -> None:
        """Extract 3DES key from memory."""
        memory_dump = b"\x00" * 1024 + real_3des_key + b"\x00" * 1024

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=0)

        des_keys = [k for k in keys if k.key_type == KeyType.DES3]

        assert len(des_keys) > 0, "Failed to extract 3DES key"

        extracted = des_keys[0]
        assert extracted.key_size == 168 or extracted.key_size == 192
        assert len(extracted.raw_bytes) == 24

    def test_extract_des_subkeys_from_schedule(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract DES subkeys from key schedule."""
        des_patterns = extractor._generate_des_schedule_patterns()

        pc1 = des_patterns["pc1"]
        pc2 = des_patterns["pc2"]

        memory_dump = b"\x00" * 256 + pc1 + pc2 + b"\x00" * 256

        keys = extractor._find_des_subkeys(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to detect DES key schedule components"

    def test_entropy_based_key_detection(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Detect symmetric keys using entropy analysis."""
        high_entropy_key = os.urandom(32)
        low_entropy_data = b"\x00" * 32

        high_entropy = extractor._calculate_entropy(high_entropy_key)
        low_entropy = extractor._calculate_entropy(low_entropy_data)

        assert high_entropy > 7.0, f"Random key has low entropy: {high_entropy}"
        assert low_entropy < 1.0, f"Null bytes have high entropy: {low_entropy}"

        memory_dump = (
            low_entropy_data +
            high_entropy_key +
            low_entropy_data
        )

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=0)

        high_entropy_keys = [k for k in keys if extractor._calculate_entropy(k.raw_bytes) > 7.0]

        assert len(high_entropy_keys) > 0, "Failed to detect high-entropy symmetric key"


class TestMemoryStructureExtraction:
    """Test extraction from crypto library memory structures."""

    def test_extract_openssl_rsa_structure(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Extract RSA key from OpenSSL RSA_ST structure in memory."""
        _, _, n, e, d = real_rsa_2048_keypair

        struct_info = extractor.key_formats["memory_structures"]["openssl"]["rsa_st"]

        structure = bytearray(struct_info["structure_size"])

        struct.pack_into("<I", structure, 0, struct_info["version"])

        n_bytes = n.to_bytes(256, byteorder="big")
        structure[struct_info["n_offset"]:struct_info["n_offset"] + 256] = n_bytes

        memory_dump = b"\x00" * 512 + bytes(structure) + b"\x00" * 512

        keys = extractor._detect_openssl_structures(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract key from OpenSSL structure"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys found in OpenSSL structure"

    def test_extract_bcrypt_key_handle(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract key from Windows BCrypt key handle structure."""
        bcrypt_struct = extractor.key_formats["memory_structures"]["windows_cng"]["bcrypt_key_handle"]

        magic = bcrypt_struct["magic"]
        version = bcrypt_struct["version"]

        key_data = os.urandom(32)

        structure = struct.pack("<II", magic, version) + b"\x00" * 24 + key_data

        memory_dump = b"\xff" * 256 + structure + b"\xff" * 256

        keys = extractor._extract_cng_keys(
            memory_dump,
            base_address=0,
            structs=extractor.key_formats["memory_structures"]["windows_cng"],
        )

        assert len(keys) > 0, "Failed to extract key from BCrypt structure"

    def test_extract_mbedtls_rsa_context(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract RSA key from mbedTLS context structure."""
        mbedtls_struct = extractor.key_formats["memory_structures"]["mbedtls"]["mbedtls_rsa_context"]

        structure = bytearray(mbedtls_struct["structure_size"])

        struct.pack_into("<I", structure, mbedtls_struct["ver_offset"], 0)
        struct.pack_into("<I", structure, mbedtls_struct["len_offset"], 256)

        memory_dump = b"\x00" * 1024 + bytes(structure) + b"\x00" * 1024

        keys = extractor._extract_mbedtls_keys(
            memory_dump,
            base_address=0,
            structs=extractor.key_formats["memory_structures"]["mbedtls"],
        )

        assert len(keys) > 0, "Failed to extract key from mbedTLS structure"


class TestAPIHookExtraction:
    """Test key extraction via API hooking."""

    def test_detect_bcrypt_generate_symmetric_key_call(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Detect BCryptGenerateSymmetricKey API calls and extract keys."""
        api_signature = b"\x48\x89\x5c\x24"

        key_material = os.urandom(32)

        memory_dump = (
            b"\x90" * 128 +
            api_signature +
            b"\x90" * 64 +
            key_material +
            b"\x90" * 128
        )

        keys = extractor._detect_windows_crypto_apis(
            memory_dump,
            base_address=0,
            api_sigs=extractor.rsa_patterns["crypto_apis"]["windows"],
        )

        assert len(keys) >= 0, "API detection should not crash"

    def test_hook_memory_allocation_for_keys(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Hook malloc/memcpy to detect key allocation."""
        key_data = os.urandom(32)

        memory_dump = b"\x00" * 512 + key_data + b"\x00" * 512

        allocation_sites = extractor._find_allocation_sites(memory_dump)

        assert len(allocation_sites) >= 0, "Allocation site detection should not crash"

    def test_extract_from_hook_trampolines(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract keys from API hook trampoline code."""
        trampoline = b"\xff\x25\x00\x00\x00\x00"

        key_data = os.urandom(32)

        memory_dump = (
            b"\xcc" * 128 +
            trampoline +
            key_data +
            b"\xcc" * 128
        )

        keys = extractor._extract_hook_parameters(memory_dump, hook_offset=128, base_addr=0)

        assert len(keys) >= 0, "Hook parameter extraction should not crash"


class TestSideChannelAnalysis:
    """Test side-channel analysis for key extraction."""

    def test_cache_timing_analysis_for_aes(
        self,
        extractor: CryptoKeyExtractor,
        real_aes_128_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Use cache timing analysis to detect AES keys."""
        original_key, _ = real_aes_128_expanded_key

        t_tables = extractor._build_aes_t_tables()
        te0, te1, te2, te3 = t_tables

        memory_dump = (
            te0 +
            te1 +
            te2 +
            te3 +
            original_key +
            b"\x00" * 256
        )

        keys = extractor._analyze_cache_timing(
            memory_dump,
            base_address=0,
            timing_targets=extractor.rsa_patterns["side_channel_targets"]["cache_timing"],
        )

        assert len(keys) >= 0, "Cache timing analysis should not crash"

    def test_power_analysis_hamming_weight(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Use power analysis (Hamming weight) to detect key material."""
        key_byte = 0x5A

        hamming_weight = bin(key_byte).count("1")

        assert hamming_weight == 4, "Hamming weight calculation incorrect"

        power_patterns = extractor.rsa_patterns["side_channel_targets"]["power_analysis"]
        hamming_weights = power_patterns["hamming_weight_patterns"]["hamming_weights"]

        assert hamming_weights[key_byte] == 4, "Hamming weight table incorrect"

    def test_electromagnetic_signature_detection(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Detect crypto operations via EM signature patterns."""
        em_signatures = extractor.rsa_patterns["side_channel_targets"]["electromagnetic"]["em_signatures"]

        aes_round_sig = em_signatures["aes_round"]
        rsa_mult_sig = em_signatures["rsa_multiplication"]

        assert len(aes_round_sig) == 16, "AES round EM signature wrong size"
        assert len(rsa_mult_sig) == 32, "RSA multiplication EM signature wrong size"


class TestKeyFormatValidation:
    """Test validation of extracted key formats."""

    def test_validate_pem_format_structure(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Validate PEM format structure of extracted keys."""
        private_pem, public_pem, _, _, _ = real_rsa_2048_keypair

        assert b"-----BEGIN" in private_pem, "Invalid PEM header"
        assert b"-----END" in private_pem, "Invalid PEM footer"
        assert b"PRIVATE KEY" in private_pem, "Not a private key PEM"

        assert b"-----BEGIN" in public_pem, "Invalid public key PEM header"
        assert b"PUBLIC KEY" in public_pem, "Not a public key PEM"

    def test_validate_der_format_structure(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Validate DER format structure of extracted keys."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        private_key = serialization.load_pem_private_key(
            private_pem,
            password=None,
            backend=default_backend(),
        )

        der_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )

        assert der_bytes[0] == 0x30, "DER must start with SEQUENCE tag"

        assert len(der_bytes) > 100, "DER encoding too short for 2048-bit RSA"

    def test_validate_pkcs1_vs_pkcs8(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Distinguish between PKCS#1 and PKCS#8 key formats."""
        pkcs1_patterns = extractor.key_formats["runtime_formats"]["pkcs1"]
        pkcs8_patterns = extractor.key_formats["runtime_formats"]["pkcs8"]

        pkcs1_header = pkcs1_patterns["private_header"]
        pkcs8_header = pkcs8_patterns["unencrypted_header"]

        assert pkcs1_header != pkcs8_header, "PKCS#1 and PKCS#8 headers must differ"

    def test_validate_ssh_key_format(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Validate SSH key format detection."""
        ssh_patterns = extractor.key_formats["runtime_formats"]["ssh"]

        assert b"ssh-rsa" in ssh_patterns.values()
        assert b"ssh-ed25519" in ssh_patterns.values()


class TestEntropyAndHeuristics:
    """Test entropy analysis and key detection heuristics."""

    def test_high_entropy_detection(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Detect high-entropy regions as potential key material."""
        random_bytes = os.urandom(256)
        zero_bytes = b"\x00" * 256
        pattern_bytes = (b"\xaa\x55" * 128)

        random_entropy = extractor._calculate_entropy(random_bytes)
        zero_entropy = extractor._calculate_entropy(zero_bytes)
        pattern_entropy = extractor._calculate_entropy(pattern_bytes)

        assert random_entropy > 7.5, f"Random data should have high entropy, got {random_entropy}"
        assert zero_entropy < 0.1, f"Zero bytes should have near-zero entropy, got {zero_entropy}"
        assert pattern_entropy < random_entropy, "Pattern should have lower entropy than random"

    def test_crypto_constant_proximity_heuristic(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Detect keys near cryptographic constants."""
        aes_sbox = extractor._get_aes_sbox()

        key_candidate = os.urandom(32)

        memory_dump = aes_sbox + b"\x00" * 64 + key_candidate + b"\x00" * 256

        offset = len(aes_sbox) + 64

        near_constants = extractor._near_crypto_constants(memory_dump, offset)

        assert near_constants, "Failed to detect proximity to crypto constants"

    def test_reject_low_entropy_false_positives(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Reject low-entropy data as key candidates."""
        low_entropy = b"\x00" * 32

        is_valid = extractor._is_valid_key_data(low_entropy)

        assert not is_valid, "Low-entropy data incorrectly identified as valid key"

        high_entropy = os.urandom(32)
        is_valid_high = extractor._is_valid_key_data(high_entropy)

        assert is_valid_high, "High-entropy data should be valid key candidate"


class TestBinaryFileExtraction:
    """Test key extraction from binary files (PE/ELF)."""

    def test_extract_from_binary_file(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
        tmp_path: Path,
    ) -> None:
        """Extract keys from binary file on disk."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        binary_file = tmp_path / "test_binary.bin"

        binary_content = b"\x00" * 2048 + private_pem + b"\x00" * 2048
        binary_file.write_bytes(binary_content)

        keys = extractor.extract_from_binary(str(binary_file))

        assert len(keys) > 0, "Failed to extract keys from binary file"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        assert len(rsa_keys) > 0, "No RSA keys found in binary file"

    def test_extract_from_large_binary(
        self,
        extractor: CryptoKeyExtractor,
        tmp_path: Path,
    ) -> None:
        """Extract keys from large binary file (memory efficiency test)."""
        binary_file = tmp_path / "large_binary.bin"

        key1 = os.urandom(32)
        key2 = os.urandom(32)

        binary_content = (
            b"\xff" * (1024 * 100) +
            key1 +
            b"\xff" * (1024 * 100) +
            key2 +
            b"\xff" * (1024 * 100)
        )

        binary_file.write_bytes(binary_content)

        keys = extractor.extract_from_binary(str(binary_file))

        assert len(keys) >= 0, "Large binary extraction should not crash"


class TestKeyExport:
    """Test exporting extracted keys."""

    def test_export_extracted_keys(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
        tmp_path: Path,
    ) -> None:
        """Export extracted keys to output directory."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        memory_dump = b"\x00" * 512 + private_pem + b"\x00" * 512

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        assert len(keys) > 0, "No keys to export"

        output_dir = tmp_path / "exported_keys"
        output_dir.mkdir()

        extractor.export_keys(str(output_dir))

        exported_files = list(output_dir.glob("*"))

        assert len(exported_files) > 0, "No keys exported to directory"


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_extract_from_empty_memory(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Handle empty memory dump gracefully."""
        keys = extractor.extract_from_memory(b"", base_address=0)

        assert keys == [], "Empty memory should return empty list"

    def test_extract_from_corrupted_pem(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Handle corrupted PEM data gracefully."""
        corrupted_pem = b"-----BEGIN RSA PRIVATE KEY-----\nCORRUPTED\n-----END RSA PRIVATE KEY-----"

        memory_dump = b"\x00" * 256 + corrupted_pem + b"\x00" * 256

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        assert len(keys) >= 0, "Corrupted PEM should not crash extraction"

    def test_extract_from_misaligned_key_data(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract keys from misaligned memory addresses."""
        key_data = os.urandom(32)

        memory_dump = b"\xff" + key_data + b"\xff" * 1000

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=1)

        assert len(keys) >= 0, "Misaligned data should not crash extraction"

    def test_handle_overlapping_key_patterns(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Handle overlapping key patterns in memory."""
        private_pem, public_pem, _, _, _ = real_rsa_2048_keypair

        memory_dump = private_pem + public_pem + private_pem

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        assert len(keys) > 0, "Should extract keys despite overlap"

        unique_addresses = {k.address for k in keys}
        assert len(unique_addresses) >= 1, "Should detect distinct key locations"


class TestComplexScenarios:
    """Test complex real-world scenarios."""

    def test_extract_from_encrypted_memory_section(
        self,
        extractor: CryptoKeyExtractor,
        real_aes_256_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Extract encryption key from encrypted memory section."""
        encryption_key, _ = real_aes_256_expanded_key

        plaintext = b"Sensitive license data" * 10

        cipher = Cipher(
            algorithms.AES(encryption_key),
            modes.ECB(),
            backend=default_backend(),
        )
        encryptor = cipher.encryptor()

        padded_plaintext = plaintext + b"\x00" * (16 - len(plaintext) % 16)
        ciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()

        memory_dump = (
            b"\x00" * 256 +
            encryption_key +
            ciphertext +
            b"\x00" * 256
        )

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=0)

        aes_256_keys = [k for k in keys if k.key_type == KeyType.AES and k.key_size == 256]

        assert len(aes_256_keys) > 0, "Failed to extract AES-256 key from encrypted section"

    def test_extract_multi_key_license_system(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
        real_aes_256_expanded_key: tuple[bytes, bytes],
    ) -> None:
        """Extract multiple keys from complex licensing system."""
        rsa_private_pem, _, _, _, _ = real_rsa_2048_keypair
        aes_key, _ = real_aes_256_expanded_key

        license_blob = b"LICENSE-DATA-" + os.urandom(64)

        memory_dump = (
            b"\x00" * 512 +
            rsa_private_pem +
            b"\x00" * 256 +
            aes_key +
            b"\x00" * 128 +
            license_blob +
            b"\x00" * 512
        )

        keys = extractor.extract_from_memory(memory_dump, base_address=0)

        assert len(keys) > 0, "Failed to extract keys from multi-key system"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]
        aes_keys = [k for k in keys if k.key_type == KeyType.AES]

        assert len(rsa_keys) > 0, "RSA key not extracted from multi-key system"
        assert len(aes_keys) > 0, "AES key not extracted from multi-key system"

    def test_extract_from_obfuscated_key_storage(
        self,
        extractor: CryptoKeyExtractor,
    ) -> None:
        """Extract keys from obfuscated storage (XOR encoding)."""
        original_key = os.urandom(32)
        xor_mask = b"\xAA" * 32

        obfuscated_key = bytes(a ^ b for a, b in zip(original_key, xor_mask, strict=False))

        memory_dump = (
            b"\xff" * 256 +
            xor_mask +
            obfuscated_key +
            b"\xff" * 256
        )

        keys = extractor._extract_symmetric_keys(memory_dump, base_address=0)

        assert len(keys) >= 0, "Obfuscated key extraction should not crash"


class TestConcurrencyAndPerformance:
    """Test extraction performance and concurrent operations."""

    def test_extraction_performance_baseline(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Establish baseline performance for key extraction."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        memory_dump = b"\x00" * 10240 + private_pem + b"\x00" * 10240

        import time
        start_time = time.time()

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        elapsed_time = time.time() - start_time

        assert elapsed_time < 5.0, f"Extraction too slow: {elapsed_time:.2f}s"
        assert len(keys) > 0, "No keys extracted in performance test"

    def test_multiple_concurrent_extractions(
        self,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Test multiple concurrent extraction operations."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        extractors = [CryptoKeyExtractor() for _ in range(3)]

        memory_dumps = [
            b"\x00" * 1024 + private_pem + b"\x00" * 1024
            for _ in range(3)
        ]

        results = []
        for extractor, memory_dump in zip(extractors, memory_dumps, strict=False):
            keys = extractor._extract_pem_keys(memory_dump, base_address=0)
            results.append(keys)

        for keys in results:
            assert len(keys) > 0, "Concurrent extraction failed"


class TestRegressionAndValidation:
    """Regression tests and validation checks."""

    def test_extracted_rsa_key_is_cryptographically_valid(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Validate extracted RSA key can be used for crypto operations."""
        private_pem, _, n, e, d = real_rsa_2048_keypair

        memory_dump = b"\x00" * 512 + private_pem + b"\x00" * 512

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PRIVATE, KeyType.RSA_PUBLIC)]

        assert len(rsa_keys) > 0, "No RSA keys extracted"

        extracted = rsa_keys[0]

        assert extracted.pem_format is not None, "No PEM format in extracted key"

        if isinstance(extracted.pem_format, str):
            pem_bytes = extracted.pem_format.encode()
        else:
            pem_bytes = extracted.pem_format

        try:
            loaded_key = serialization.load_pem_private_key(
                pem_bytes,
                password=None,
                backend=default_backend(),
            )

            assert loaded_key is not None, "Extracted key cannot be loaded"

            test_message = b"Test encryption"
            from cryptography.hazmat.primitives import hashes
            from cryptography.hazmat.primitives.asymmetric import padding

            signature = loaded_key.sign(
                test_message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH,
                ),
                hashes.SHA256(),
            )

            assert len(signature) > 0, "Signature generation failed"

        except Exception as e:
            pytest.fail(f"Extracted RSA key is not cryptographically valid: {e}")

    def test_confidence_scores_are_meaningful(
        self,
        extractor: CryptoKeyExtractor,
        real_rsa_2048_keypair: tuple[bytes, bytes, int, int, int],
    ) -> None:
        """Verify confidence scores reflect extraction quality."""
        private_pem, _, _, _, _ = real_rsa_2048_keypair

        memory_dump = b"\x00" * 256 + private_pem + b"\x00" * 256

        keys = extractor._extract_pem_keys(memory_dump, base_address=0)

        for key in keys:
            assert 0.0 <= key.confidence <= 1.0, f"Invalid confidence score: {key.confidence}"

        high_confidence_keys = [k for k in keys if k.confidence > 0.8]

        assert len(high_confidence_keys) > 0, "No high-confidence keys found for valid PEM"
