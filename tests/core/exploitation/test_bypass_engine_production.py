"""Production-ready tests for license bypass capabilities.

Tests validate genuine license bypass code generation and license validation bypass
using LicenseBypassCodeGenerator and LicenseValidationBypass against real Windows
binaries with actual licensing protection patterns.

CRITICAL: All tests use REAL binaries and test ACTUAL licensing bypass capabilities.
NO mocks, NO stubs, NO simulations - genuine production testing.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import struct
import tempfile
from pathlib import Path
from typing import Any

import pefile
import pytest

from intellicrack.core.exploitation.license_bypass_code_generator import (
    LicenseBypassCodeGenerator,
)
from intellicrack.core.license_validation_bypass import (
    ExtractedKey,
    KeyType,
    LicenseValidationBypass,
)


WINDOWS_BINARIES: dict[str, Path] = {
    "kernel32": Path(r"C:\Windows\System32\kernel32.dll"),
    "advapi32": Path(r"C:\Windows\System32\advapi32.dll"),
    "crypt32": Path(r"C:\Windows\System32\crypt32.dll"),
    "bcrypt": Path(r"C:\Windows\System32\bcrypt.dll"),
}


class TestLicenseBypassCodeGeneratorInitialization:
    """Test LicenseBypassCodeGenerator initialization for multiple platforms."""

    def test_generator_initializes_x86_64_windows(self) -> None:
        """Generator initializes correctly for x86_64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")

        assert gen.architecture == "x86_64"
        assert gen.platform == "windows"
        assert len(gen.generated_patches) == 0

    def test_generator_initializes_x86_64_linux(self) -> None:
        """Generator initializes correctly for x86_64 Linux."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="linux")

        assert gen.architecture == "x86_64"
        assert gen.platform == "linux"

    def test_generator_initializes_x86_windows(self) -> None:
        """Generator initializes correctly for x86 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")

        assert gen.architecture == "x86"
        assert gen.platform == "windows"

    def test_generator_initializes_arm64(self) -> None:
        """Generator initializes correctly for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")

        assert gen.architecture == "arm64"
        assert gen.platform == "linux"

    def test_generator_initializes_arm(self) -> None:
        """Generator initializes correctly for ARM."""
        gen = LicenseBypassCodeGenerator(architecture="arm", platform="linux")

        assert gen.architecture == "arm"

    def test_calling_conventions_initialized(self) -> None:
        """Calling conventions are properly initialized."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")

        assert "x86_64" in gen.calling_conventions
        assert "x86" in gen.calling_conventions
        assert "arm64" in gen.calling_conventions
        assert "arm" in gen.calling_conventions

    def test_windows_x64_calling_convention_details(self) -> None:
        """Windows x64 calling convention has correct parameters."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        conv = gen.get_calling_convention_info()

        assert conv["int_params"] == ["rcx", "rdx", "r8", "r9"]
        assert conv["shadow_space"] == 32
        assert conv["stack_align"] == 16

    def test_linux_x64_calling_convention_details(self) -> None:
        """Linux x64 (System V) calling convention has correct parameters."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="linux")
        conv = gen.get_calling_convention_info()

        assert conv["int_params"] == ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        assert conv["shadow_space"] == 0
        assert conv["stack_align"] == 16


class TestLicenseCheckBypassGeneration:
    """Test license check bypass code generation."""

    def test_generate_license_bypass_x64_windows_with_stack(self) -> None:
        """Generate license bypass for x64 Windows with stack preservation."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x48\x83\xec\x28")
        assert code.endswith(b"\xc3")
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code

    def test_generate_license_bypass_x64_linux_with_stack(self) -> None:
        """Generate license bypass for x64 Linux with stack frame."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x55")
        assert b"\x48\x89\xe5" in code
        assert code.endswith(b"\xc3")

    def test_generate_license_bypass_x86_with_stack(self) -> None:
        """Generate license bypass for x86 with stack preservation."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x55")
        assert b"\x31\xc0" in code
        assert b"\x40" in code
        assert code.endswith(b"\xc3")

    def test_generate_license_bypass_x64_without_stack(self) -> None:
        """Generate minimal license bypass without stack preservation."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert len(code) > 0
        assert b"\x48\x31\xc0" in code
        assert code.endswith(b"\xc3")
        assert len(code) < 15

    def test_generate_license_bypass_arm64(self) -> None:
        """Generate license bypass for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_generate_license_bypass_arm(self) -> None:
        """Generate license bypass for ARM."""
        gen = LicenseBypassCodeGenerator(architecture="arm", platform="linux")
        code = gen.generate_license_check_bypass(0x401000)

        assert len(code) == 8
        assert code.endswith(b"\x1e\xff\x2f\xe1")

    def test_bypass_recorded_in_patches(self) -> None:
        """Generated bypass is recorded in patches list."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "license_check_bypass"
        assert patches[0]["address"] == 0x401000
        assert "preserve_stack" in patches[0]


class TestTrialExtensionPatchGeneration:
    """Test trial period extension patch generation."""

    def test_generate_trial_extension_x64_windows(self) -> None:
        """Generate trial extension patch for x64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert len(code) > 0
        assert b"\x48\x31\xc0" in code
        assert b"\x90" in code
        assert code.endswith(b"\xc3")

    def test_generate_trial_extension_x64_linux(self) -> None:
        """Generate trial extension patch for x64 Linux."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="linux")
        code = gen.generate_trial_extension_patch(0x402000, preserve_stack=True)

        assert len(code) > 0
        assert code.startswith(b"\x55")
        assert b"\x90" in code

    def test_generate_trial_extension_x86(self) -> None:
        """Generate trial extension patch for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert b"\x31\xc0" in code
        assert b"\x90" in code

    def test_generate_trial_extension_arm64(self) -> None:
        """Generate trial extension patch for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_trial_extension_patch(0x402000)

        assert len(code) > 0
        assert code.endswith(b"\xc0\x03\x5f\xd6")

    def test_trial_extension_recorded(self) -> None:
        """Trial extension patch recorded in patches list."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_trial_extension_patch(0x402000)

        patches = gen.get_generated_patches()
        assert len(patches) == 1
        assert patches[0]["type"] == "trial_extension"


class TestActivationBypassGeneration:
    """Test product activation bypass generation."""

    def test_generate_activation_bypass_x64_windows(self) -> None:
        """Generate activation bypass for x64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_activation_bypass(0x403000, preserve_stack=True)

        assert len(code) > 0
        assert b"\x48\xc7\xc0\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_generate_activation_bypass_x86(self) -> None:
        """Generate activation bypass for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) > 0
        assert b"\xb8\x01\x00\x00\x00" in code
        assert code.endswith(b"\xc3")

    def test_generate_activation_bypass_arm64(self) -> None:
        """Generate activation bypass for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_activation_bypass(0x403000)

        assert len(code) == 8

    def test_activation_bypass_recorded(self) -> None:
        """Activation bypass recorded correctly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_activation_bypass(0x403000)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "activation_bypass"
        assert patches[0]["description"] == "Forces activation check to return activated"


class TestSerialValidationBypassGeneration:
    """Test serial number validation bypass generation."""

    def test_generate_serial_bypass_x64_windows(self) -> None:
        """Generate serial validation bypass for x64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_serial_validation_bypass(0x404000, preserve_stack=True)

        assert len(code) > 0
        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code
        assert code.endswith(b"\xc3")

    def test_generate_serial_bypass_x86(self) -> None:
        """Generate serial validation bypass for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_serial_validation_bypass(0x404000)

        assert len(code) > 0
        assert b"\x31\xc0" in code
        assert b"\x40" in code

    def test_serial_bypass_recorded(self) -> None:
        """Serial bypass recorded in patches."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_serial_validation_bypass(0x404000)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "serial_validation_bypass"


class TestHardwareIDSpoofGeneration:
    """Test hardware ID spoofing code generation."""

    def test_generate_hwid_spoof_x64_windows(self) -> None:
        """Generate hardware ID spoof for x64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        spoofed_hwid = b"SPOOF-HWID-1234"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) > 0
        assert b"\x48\xb8" in code
        assert code.endswith(b"\xc3")

    def test_generate_hwid_spoof_x86(self) -> None:
        """Generate hardware ID spoof for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        spoofed_hwid = b"SPOOF"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        assert len(code) > 0
        assert b"\xb8" in code

    def test_hwid_spoof_contains_spoofed_data(self) -> None:
        """Hardware ID spoof contains the spoofed data."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        spoofed_hwid = b"TESTTEST"
        code = gen.generate_hardware_id_spoof(0x405000, spoofed_hwid, preserve_stack=False)

        assert spoofed_hwid in code

    def test_hwid_spoof_recorded(self) -> None:
        """Hardware ID spoof recorded with description."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        spoofed_hwid = b"ABCD1234"
        gen.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "hardware_id_spoof"
        assert "4142434431323334" in patches[0]["description"]


class TestNOPPatchGeneration:
    """Test NOP sled generation for protection neutralization."""

    def test_generate_nop_patch_x64(self) -> None:
        """Generate NOP patch for x64."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x90" * 16

    def test_generate_nop_patch_x86(self) -> None:
        """Generate NOP patch for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_nop_patch(0x406000, 32)

        assert len(code) == 32
        assert code == b"\x90" * 32

    def test_generate_nop_patch_arm64(self) -> None:
        """Generate NOP patch for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_nop_patch(0x406000, 16)

        assert len(code) == 16
        assert code == b"\x1f\x20\x03\xd5" * 4

    def test_generate_nop_patch_arm(self) -> None:
        """Generate NOP patch for ARM."""
        gen = LicenseBypassCodeGenerator(architecture="arm", platform="linux")
        code = gen.generate_nop_patch(0x406000, 12)

        assert len(code) == 12

    def test_nop_patch_recorded(self) -> None:
        """NOP patch recorded correctly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_nop_patch(0x406000, 20)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "nop_patch"
        assert "20 bytes" in patches[0]["description"]


class TestConditionalJumpPatching:
    """Test conditional jump modification for license checks."""

    def test_generate_always_jump_x64(self) -> None:
        """Generate always-jump patch for x64."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert code == b"\xeb"

    def test_generate_never_jump_x64(self) -> None:
        """Generate never-jump patch for x64."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert code == b"\x90\x90"

    def test_generate_always_jump_arm64(self) -> None:
        """Generate always-jump patch for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        assert len(code) == 4

    def test_generate_never_jump_arm64(self) -> None:
        """Generate never-jump (NOP) patch for ARM64."""
        gen = LicenseBypassCodeGenerator(architecture="arm64", platform="linux")
        code = gen.generate_conditional_jump_patch(0x407000, always_jump=False)

        assert code == b"\x1f\x20\x03\xd5"

    def test_jump_patch_recorded(self) -> None:
        """Jump patch recorded correctly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_conditional_jump_patch(0x407000, always_jump=True)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "jump_patch"
        assert "always" in patches[0]["description"]


class TestReturnValuePatching:
    """Test forced return value patch generation."""

    def test_generate_return_value_x64_windows(self) -> None:
        """Generate return value patch for x64 Windows."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_return_value_patch(0x408000, 1, preserve_stack=True)

        assert len(code) > 0
        assert struct.pack("<I", 1) in code
        assert code.endswith(b"\xc3")

    def test_generate_return_value_x86(self) -> None:
        """Generate return value patch for x86."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_return_value_patch(0x408000, 0x12345678)

        assert len(code) > 0
        assert struct.pack("<I", 0x12345678) in code

    def test_generate_return_zero_x64(self) -> None:
        """Generate return zero patch for x64."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_return_value_patch(0x408000, 0)

        assert struct.pack("<I", 0) in code

    def test_return_value_recorded(self) -> None:
        """Return value patch recorded correctly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_return_value_patch(0x408000, 42)

        patches = gen.get_generated_patches()
        assert patches[0]["type"] == "return_value_patch"
        assert "42" in patches[0]["description"]


class TestPatchManagement:
    """Test patch list management functionality."""

    def test_get_generated_patches_returns_copy(self) -> None:
        """get_generated_patches returns a copy, not the original."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)

        patches1 = gen.get_generated_patches()
        patches2 = gen.get_generated_patches()

        assert patches1 is not patches2
        assert patches1 == patches2

    def test_clear_patches(self) -> None:
        """clear_patches removes all patches."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)

        assert len(gen.get_generated_patches()) == 2

        gen.clear_patches()
        assert len(gen.get_generated_patches()) == 0

    def test_multiple_patches_accumulated(self) -> None:
        """Multiple patches accumulate correctly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")

        gen.generate_license_check_bypass(0x401000)
        gen.generate_trial_extension_patch(0x402000)
        gen.generate_activation_bypass(0x403000)
        gen.generate_serial_validation_bypass(0x404000)

        patches = gen.get_generated_patches()
        assert len(patches) == 4

        types = {p["type"] for p in patches}
        assert "license_check_bypass" in types
        assert "trial_extension" in types
        assert "activation_bypass" in types
        assert "serial_validation_bypass" in types


class TestPatchExport:
    """Test patch export functionality."""

    def test_export_patches_binary(self) -> None:
        """Export patches in binary format."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("binary")

        assert export["architecture"] == "x86_64"
        assert export["platform"] == "windows"
        assert export["format"] == "binary"
        assert len(export["patches"]) == 1
        assert isinstance(export["patches"][0]["code"], bytes)

    def test_export_patches_hex(self) -> None:
        """Export patches in hex format."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("hex")

        assert export["format"] == "hex"
        assert isinstance(export["patches"][0]["code"], str)
        assert all(c in "0123456789abcdef" for c in export["patches"][0]["code"])

    def test_export_patches_asm(self) -> None:
        """Export patches in assembly format."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        gen.generate_license_check_bypass(0x401000)

        export = gen.export_patches("asm")

        assert export["format"] == "asm"
        assert isinstance(export["patches"][0]["code"], str)


class TestLicenseValidationBypassInitialization:
    """Test LicenseValidationBypass initialization."""

    def test_bypass_engine_initializes(self) -> None:
        """LicenseValidationBypass initializes correctly."""
        bypass = LicenseValidationBypass()

        assert bypass.backend is not None
        assert bypass.cs_x86 is not None
        assert bypass.cs_x64 is not None
        assert bypass.ks_x86 is not None
        assert bypass.ks_x64 is not None

    def test_bypass_engine_has_rsa_patterns(self) -> None:
        """RSA key detection patterns are initialized."""
        bypass = LicenseValidationBypass()

        assert len(bypass.rsa_patterns) > 0
        assert any(pat.pattern for pat in bypass.rsa_patterns)

    def test_bypass_engine_has_ecc_patterns(self) -> None:
        """ECC key detection patterns are initialized."""
        bypass = LicenseValidationBypass()

        assert len(bypass.ecc_patterns) > 0

    def test_bypass_engine_has_cert_patterns(self) -> None:
        """Certificate detection patterns are initialized."""
        bypass = LicenseValidationBypass()

        assert len(bypass.cert_patterns) > 0


class TestRSAKeyExtractionFromCrypt32:
    """Test RSA key extraction from crypt32.dll - a real crypto library."""

    @pytest.fixture
    def crypt32_path(self) -> str:
        """Get path to crypt32.dll."""
        path = WINDOWS_BINARIES["crypt32"]
        if not path.exists():
            pytest.skip(f"crypt32.dll not found at {path}")
        return str(path)

    def test_extract_rsa_keys_returns_list(self, crypt32_path: str) -> None:
        """RSA key extraction returns a list of ExtractedKey objects."""
        bypass = LicenseValidationBypass()
        keys = bypass.extract_rsa_keys_from_binary(crypt32_path)

        assert isinstance(keys, list)
        for key in keys:
            assert isinstance(key, ExtractedKey)

    def test_extracted_keys_have_required_fields(self, crypt32_path: str) -> None:
        """Extracted keys have all required fields populated."""
        bypass = LicenseValidationBypass()
        keys = bypass.extract_rsa_keys_from_binary(crypt32_path)

        for key in keys:
            assert key.key_type in list(KeyType)
            assert isinstance(key.key_data, bytes)
            assert key.confidence >= 0.0
            assert key.confidence <= 1.0

    def test_rsa_public_key_has_modulus_and_exponent(self, crypt32_path: str) -> None:
        """RSA public keys have modulus and exponent."""
        bypass = LicenseValidationBypass()
        keys = bypass.extract_rsa_keys_from_binary(crypt32_path)

        public_keys = [k for k in keys if k.key_type == KeyType.RSA_PUBLIC]
        for key in public_keys:
            if key.modulus is not None:
                assert isinstance(key.modulus, int)
                assert key.modulus > 0
            if key.exponent is not None:
                assert isinstance(key.exponent, int)


class TestECCKeyExtractionFromBcrypt:
    """Test ECC key extraction from bcrypt.dll - Windows crypto library."""

    @pytest.fixture
    def bcrypt_path(self) -> str:
        """Get path to bcrypt.dll."""
        path = WINDOWS_BINARIES["bcrypt"]
        if not path.exists():
            pytest.skip(f"bcrypt.dll not found at {path}")
        return str(path)

    def test_extract_ecc_keys_returns_list(self, bcrypt_path: str) -> None:
        """ECC key extraction returns a list of ExtractedKey objects."""
        bypass = LicenseValidationBypass()
        keys = bypass.extract_ecc_keys_from_binary(bcrypt_path)

        assert isinstance(keys, list)

    def test_ecc_keys_have_curve_info(self, bcrypt_path: str) -> None:
        """Extracted ECC keys have curve information."""
        bypass = LicenseValidationBypass()
        keys = bypass.extract_ecc_keys_from_binary(bcrypt_path)

        for key in keys:
            if key.key_type in (KeyType.ECC_PUBLIC, KeyType.ECC_PRIVATE):
                assert key.curve is not None or key.key_data is not None


class TestCertificateExtraction:
    """Test X.509 certificate extraction."""

    @pytest.fixture
    def crypt32_path(self) -> str:
        """Get path to crypt32.dll."""
        path = WINDOWS_BINARIES["crypt32"]
        if not path.exists():
            pytest.skip(f"crypt32.dll not found at {path}")
        return str(path)

    def test_extract_certificates_returns_list(self, crypt32_path: str) -> None:
        """Certificate extraction returns a list."""
        bypass = LicenseValidationBypass()
        certs = bypass.extract_certificates(crypt32_path)

        assert isinstance(certs, list)


class TestAllKeyExtraction:
    """Test comprehensive key extraction."""

    @pytest.fixture
    def advapi32_path(self) -> str:
        """Get path to advapi32.dll."""
        path = WINDOWS_BINARIES["advapi32"]
        if not path.exists():
            pytest.skip(f"advapi32.dll not found at {path}")
        return str(path)

    def test_extract_all_keys_returns_dict(self, advapi32_path: str) -> None:
        """extract_all_keys returns a dictionary with all key types."""
        bypass = LicenseValidationBypass()
        results = bypass.extract_all_keys(advapi32_path)

        assert isinstance(results, dict)
        assert "rsa" in results
        assert "ecc" in results
        assert "symmetric" in results
        assert "certificates" in results

    def test_extract_all_keys_lists_are_typed(self, advapi32_path: str) -> None:
        """All key lists contain ExtractedKey objects."""
        bypass = LicenseValidationBypass()
        results = bypass.extract_all_keys(advapi32_path)

        for key in results["rsa"]:
            assert isinstance(key, ExtractedKey)
        for key in results["ecc"]:
            assert isinstance(key, ExtractedKey)
        for key in results["symmetric"]:
            assert isinstance(key, ExtractedKey)


class TestEntropyCalculation:
    """Test entropy calculation for key detection."""

    def test_entropy_zero_for_null_data(self) -> None:
        """Zero entropy for null bytes."""
        bypass = LicenseValidationBypass()
        entropy = bypass._calculate_entropy(b"\x00" * 1024)

        assert entropy == 0.0

    def test_entropy_zero_for_empty_data(self) -> None:
        """Zero entropy for empty data."""
        bypass = LicenseValidationBypass()
        entropy = bypass._calculate_entropy(b"")

        assert entropy == 0.0

    def test_entropy_high_for_random_data(self) -> None:
        """High entropy for random-like data."""
        bypass = LicenseValidationBypass()
        random_data = bytes(range(256)) * 4
        entropy = bypass._calculate_entropy(random_data)

        assert entropy > 7.0
        assert entropy <= 8.0

    def test_entropy_low_for_repetitive_data(self) -> None:
        """Low entropy for repetitive data."""
        bypass = LicenseValidationBypass()
        repetitive = b"AAAA" * 256
        entropy = bypass._calculate_entropy(repetitive)

        assert entropy == 0.0


class TestKeyStructureDetection:
    """Test key structure detection heuristics."""

    def test_is_key_data_rejects_short_data(self) -> None:
        """Reject data shorter than minimum key size."""
        bypass = LicenseValidationBypass()
        result = bypass._is_key_data(b"\x00" * 64)

        assert result is False

    def test_is_key_data_rejects_low_entropy(self) -> None:
        """Reject data with low entropy."""
        bypass = LicenseValidationBypass()
        result = bypass._is_key_data(b"\x00" * 256)

        assert result is False

    def test_has_key_structure_detects_asn1(self) -> None:
        """Detect ASN.1 structure markers."""
        bypass = LicenseValidationBypass()
        asn1_data = b"\x30\x82" + b"\x00" * 254
        result = bypass._has_key_structure(asn1_data)

        assert result is True


class TestBCryptKeyBlobParsing:
    """Test Windows BCRYPT key blob parsing."""

    def test_parse_bcrypt_rsa_public_blob(self) -> None:
        """Parse BCRYPT_RSAPUBLIC_BLOB structure."""
        bypass = LicenseValidationBypass()

        blob = b"RSA1"
        blob += struct.pack("<I", 2048)
        blob += struct.pack("<I", 4)
        blob += struct.pack("<I", 256)
        blob += b"\x00" * 8
        blob += b"\x01\x00\x01\x00"
        blob += b"\x00" * 256

        key = bypass._parse_bcrypt_key_blob(blob)

        if key is not None:
            assert key.key_type == KeyType.RSA_PUBLIC
            assert key.exponent == 65537

    def test_parse_bcrypt_invalid_magic(self) -> None:
        """Reject invalid BCRYPT blob magic."""
        bypass = LicenseValidationBypass()

        blob = b"XXXX" + b"\x00" * 100
        key = bypass._parse_bcrypt_key_blob(blob)

        assert key is None


class TestRealWorldLicenseBypassScenarios:
    """Test real-world license bypass scenarios."""

    def test_complete_license_bypass_workflow(self) -> None:
        """Complete workflow: detect protection, generate bypass."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")

        license_check_addr = 0x401000
        trial_check_addr = 0x402000
        activation_check_addr = 0x403000
        serial_check_addr = 0x404000

        gen.generate_license_check_bypass(license_check_addr)
        gen.generate_trial_extension_patch(trial_check_addr)
        gen.generate_activation_bypass(activation_check_addr)
        gen.generate_serial_validation_bypass(serial_check_addr)

        patches = gen.get_generated_patches()
        assert len(patches) == 4

        for patch in patches:
            assert patch["address"] in [
                license_check_addr,
                trial_check_addr,
                activation_check_addr,
                serial_check_addr,
            ]
            assert len(patch["code"]) > 0

    def test_bypass_code_is_valid_x86_64(self) -> None:
        """Generated bypass code is valid x86_64 assembly."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code[0:4] == b"\x48\x83\xec\x28"
        assert code[-1:] == b"\xc3"

    def test_bypass_code_returns_true(self) -> None:
        """Generated bypass code sets return value to 1 (true)."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=False)

        assert b"\x48\x31\xc0" in code
        assert b"\x48\xff\xc0" in code


class TestArchitectureSupport:
    """Test multi-architecture support."""

    @pytest.mark.parametrize(
        "arch,platform",
        [
            ("x86_64", "windows"),
            ("x86_64", "linux"),
            ("x86", "windows"),
            ("x86", "linux"),
            ("arm64", "linux"),
            ("arm", "linux"),
        ],
    )
    def test_all_bypass_types_supported(self, arch: str, platform: str) -> None:
        """All bypass types supported for each architecture."""
        gen = LicenseBypassCodeGenerator(architecture=arch, platform=platform)

        code1 = gen.generate_license_check_bypass(0x1000)
        code2 = gen.generate_trial_extension_patch(0x2000)
        code3 = gen.generate_activation_bypass(0x3000)
        code4 = gen.generate_serial_validation_bypass(0x4000)
        code5 = gen.generate_hardware_id_spoof(0x5000, b"SPOOF123")
        code6 = gen.generate_nop_patch(0x6000, 16)
        code7 = gen.generate_conditional_jump_patch(0x7000, True)
        code8 = gen.generate_return_value_patch(0x8000, 1)

        assert len(code1) > 0
        assert len(code2) > 0
        assert len(code3) > 0
        assert len(code4) > 0
        assert len(code5) > 0
        assert len(code6) > 0
        assert len(code7) > 0
        assert len(code8) > 0

    def test_unsupported_architecture_raises(self) -> None:
        """Unsupported architecture raises ValueError."""
        gen = LicenseBypassCodeGenerator(architecture="mips", platform="linux")

        with pytest.raises(ValueError, match="Unsupported architecture"):
            gen.generate_license_check_bypass(0x1000)


class TestPatchCodeIntegrity:
    """Test integrity of generated patch code."""

    def test_x64_windows_code_has_proper_prologue(self) -> None:
        """x64 Windows code has proper function prologue."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code[0:4] == b"\x48\x83\xec\x28"

    def test_x64_linux_code_has_proper_prologue(self) -> None:
        """x64 Linux code has proper function prologue."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="linux")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code[0:1] == b"\x55"
        assert b"\x48\x89\xe5" in code[:5]

    def test_x86_code_has_proper_prologue(self) -> None:
        """x86 code has proper function prologue."""
        gen = LicenseBypassCodeGenerator(architecture="x86", platform="windows")
        code = gen.generate_license_check_bypass(0x401000, preserve_stack=True)

        assert code[0:1] == b"\x55"
        assert b"\x89\xe5" in code[:5]

    def test_all_code_ends_with_ret(self) -> None:
        """All generated code ends with return instruction."""
        gen = LicenseBypassCodeGenerator(architecture="x86_64", platform="windows")

        code1 = gen.generate_license_check_bypass(0x1000)
        code2 = gen.generate_trial_extension_patch(0x2000)
        code3 = gen.generate_activation_bypass(0x3000)
        code4 = gen.generate_serial_validation_bypass(0x4000)
        code5 = gen.generate_return_value_patch(0x5000, 1)

        assert code1[-1:] == b"\xc3"
        assert code2[-1:] == b"\xc3"
        assert code3[-1:] == b"\xc3"
        assert code4[-1:] == b"\xc3"
        assert code5[-1:] == b"\xc3"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
