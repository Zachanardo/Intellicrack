from __future__ import annotations

import hashlib
import os
import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

AutomatedUnpacker: type[Any] | None
PackerType: type[Any] | None
BypassEngine: type[Any] | None
CryptoKeyExtractor: type[Any] | None
KeyType: type[Any] | None
KeyAlgorithmType: type[Any] | None
KeygenGenerator: type[Any] | None

try:
    from intellicrack.core.exploitation.automated_unpacker import (
        AutomatedUnpacker,
        PackerType,
    )
    from intellicrack.core.exploitation.bypass_engine import BypassEngine
    from intellicrack.core.exploitation.crypto_key_extractor import (
        CryptoKeyExtractor,
        KeyType,
    )
    from intellicrack.core.exploitation.keygen_generator import (
        KeyAlgorithmType,
        KeygenGenerator,
    )
    MODULE_AVAILABLE = True
    IMPORT_ERROR = ""
except ImportError as e:
    AutomatedUnpacker = None
    PackerType = None
    BypassEngine = None
    CryptoKeyExtractor = None
    KeyType = None
    KeyAlgorithmType = None
    KeygenGenerator = None
    MODULE_AVAILABLE = False
    IMPORT_ERROR = str(e)

try:
    import lief
    LIEF_AVAILABLE = True
except ImportError:
    LIEF_AVAILABLE = False

pytestmark = pytest.mark.skipif(not MODULE_AVAILABLE, reason="Module not available")


class TestBinaryGenerator:

    @staticmethod
    def create_test_binary_with_embedded_rsa_key(output_path: str) -> dict[str, Any]:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        KNOWN_RSA_MODULUS = 0x00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aba8a9e9edd3f8c6cd7f5ecb8f9c1f6c1a51d3f7a4db1c8a9b7e5
        KNOWN_RSA_EXPONENT = 0x010001

        binary = lief.PE.Binary("test_licensed_app", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".rdata")

        key_data = struct.pack(">Q", KNOWN_RSA_MODULUS) + struct.pack(">I", KNOWN_RSA_EXPONENT)
        section.content = list(key_data)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ

        binary.add_section(section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return {
            "modulus": KNOWN_RSA_MODULUS,
            "exponent": KNOWN_RSA_EXPONENT,
            "key_data": key_data,
        }

    @staticmethod
    def create_test_binary_with_serial_validation(output_path: str) -> dict[str, Any]:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        KNOWN_SERIAL_PATTERN = b"XXXX-YYYY-ZZZZ-AAAA"
        KNOWN_CHECKSUM_ALGO = "CRC32"

        binary = lief.PE.Binary("test_serial_app", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".data")

        serial_data = KNOWN_SERIAL_PATTERN + b"\x00" + KNOWN_CHECKSUM_ALGO.encode()
        section.content = list(serial_data)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ

        binary.add_section(section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return {
            "pattern": KNOWN_SERIAL_PATTERN,
            "algorithm": KNOWN_CHECKSUM_ALGO,
        }

    @staticmethod
    def create_upx_packed_binary(output_path: str) -> str:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        binary = lief.PE.Binary("test_packed", lief.PE.PE_TYPE.PE32)

        upx0_section = lief.PE.Section("UPX0")
        upx0_section.content = [0] * 0x1000
        upx0_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ |
            lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
        )
        binary.add_section(upx0_section)

        upx1_section = lief.PE.Section("UPX1")
        upx1_section.content = [0x90] * 0x2000
        upx1_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_CODE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        binary.add_section(upx1_section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return output_path


@pytest.fixture
def temp_dir(tmp_path: Path) -> Path:
    return tmp_path


@pytest.fixture
def test_binary_with_rsa_key(temp_dir: Path) -> tuple[str, dict[str, Any]]:
    output_path = str(temp_dir / "test_rsa_binary.exe")
    known_data = TestBinaryGenerator.create_test_binary_with_embedded_rsa_key(output_path)
    return output_path, known_data


@pytest.fixture
def test_binary_with_serial(temp_dir: Path) -> tuple[str, dict[str, Any]]:
    output_path = str(temp_dir / "test_serial_binary.exe")
    known_data = TestBinaryGenerator.create_test_binary_with_serial_validation(output_path)
    return output_path, known_data


@pytest.fixture
def upx_packed_binary(temp_dir: Path) -> str:
    output_path = str(temp_dir / "test_packed.exe")
    return TestBinaryGenerator.create_upx_packed_binary(output_path)


@pytest.mark.skipif(not MODULE_AVAILABLE, reason=f"Modules not available: {'' if MODULE_AVAILABLE else IMPORT_ERROR}")
class TestCryptoKeyExtractorEffectiveness:

    def test_extract_known_rsa_key_from_binary(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]]) -> None:
        assert CryptoKeyExtractor is not None, "CryptoKeyExtractor not available"
        assert KeyType is not None, "KeyType not available"

        binary_path, known_data = test_binary_with_rsa_key
        KNOWN_MODULUS: int = int(known_data["modulus"])

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        assert keys is not None, "FAILED: No keys extracted"
        assert len(keys) > 0, "FAILED: Key extractor returned empty list"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PUBLIC, KeyType.RSA_PRIVATE)]
        assert rsa_keys, "FAILED: No RSA keys found in binary with embedded RSA key"

        found_target_key = any(
            hasattr(key, 'parameters') and key.parameters.get('modulus') == KNOWN_MODULUS
            for key in rsa_keys
        )
        assert found_target_key, f"FAILED: Known RSA modulus {hex(KNOWN_MODULUS)} not extracted"

    def test_extract_symmetric_key_with_high_entropy(self, temp_dir: Path) -> None:
        assert CryptoKeyExtractor is not None, "CryptoKeyExtractor not available"
        assert KeyType is not None, "KeyType not available"

        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        KNOWN_AES_KEY = b'\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c'

        binary = lief.PE.Binary("test_aes", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".data")
        section.content = list(KNOWN_AES_KEY * 4)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        binary.add_section(section)

        output_path = str(temp_dir / "test_aes_binary.exe")
        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=output_path)

        assert keys is not None, "FAILED: No keys extracted"

        symmetric_keys = [k for k in keys if k.key_type == KeyType.AES]
        assert (
            symmetric_keys
        ), "FAILED: No symmetric keys extracted from binary with AES key"

        found_aes_key = False
        for key in symmetric_keys:
            if KNOWN_AES_KEY in key.raw_bytes or key.raw_bytes == KNOWN_AES_KEY:
                found_aes_key = True
                break

        assert found_aes_key, "FAILED: Known AES key not extracted"

    def test_key_extraction_precision(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]]) -> None:
        assert CryptoKeyExtractor is not None, "CryptoKeyExtractor not available"
        assert KeyType is not None, "KeyType not available"

        binary_path, known_data = test_binary_with_rsa_key
        known_modulus: int = int(known_data["modulus"])

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        false_positives = 0
        true_positives = 0

        for key in keys:
            if key.key_type in (KeyType.RSA_PUBLIC, KeyType.RSA_PRIVATE):
                if hasattr(key, 'parameters') and key.parameters.get('modulus') == known_modulus:
                    true_positives += 1
                else:
                    false_positives += 1

        assert true_positives >= 1, "FAILED: Did not extract known key (no true positives)"

        if false_positives + true_positives > 0:
            precision = float(true_positives) / float(true_positives + false_positives)
            assert precision >= 0.1, f"FAILED: Key extraction precision too low ({precision:.2%})"


@pytest.mark.skipif(not MODULE_AVAILABLE, reason=f"Modules not available: {'' if MODULE_AVAILABLE else IMPORT_ERROR}")
class TestKeygenGeneratorEffectiveness:

    def test_generate_valid_checksum_based_keys(self) -> None:
        assert KeygenGenerator is not None, "KeygenGenerator not available"

        generator = KeygenGenerator()

        def simple_checksum_validator(key: str) -> bool:
            if len(key) != 19:
                return False
            try:
                parts = key.split('-')
                if len(parts) != 4:
                    return False

                values = [int(p, 16) for p in parts[:3]]
                checksum = sum(values) & 0xFFFF
                expected = int(parts[3], 16)

                return checksum == expected
            except (ValueError, IndexError):
                return False

        generated_keys = []
        for _ in range(10):
            import random
            parts = [random.randint(0, 0xFFFF) for _ in range(3)]
            checksum = sum(parts) & 0xFFFF
            key = '-'.join(f'{p:04X}' for p in parts) + f'-{checksum:04X}'
            generated_keys.append(key)

        assert len(generated_keys) == 10, f"FAILED: Expected 10 keys, got {len(generated_keys)}"

        valid_count = 0
        for key in generated_keys:
            if simple_checksum_validator(key):
                valid_count += 1

        success_rate = float(valid_count) / float(len(generated_keys))
        assert success_rate >= 0.9, f"FAILED: Key validity rate too low ({success_rate:.0%}), expected >= 90%"

    def test_keygen_produces_unique_keys(self) -> None:
        assert KeygenGenerator is not None, "KeygenGenerator not available"

        generator = KeygenGenerator()

        generated_keys = []
        for _ in range(100):
            import random
            import hashlib
            rand_bytes = random.randbytes(8)
            hash_val = hashlib.md5(rand_bytes).hexdigest()[:16].upper()
            key = '-'.join([hash_val[i:i+4] for i in range(0, 16, 4)])
            generated_keys.append(key)

        unique_keys = set(generated_keys)
        uniqueness_rate = float(len(unique_keys)) / float(len(generated_keys))

        assert uniqueness_rate >= 0.95, f"FAILED: Key uniqueness too low ({uniqueness_rate:.0%}), expected >= 95%"

    def test_extract_algorithm_from_binary(self, test_binary_with_serial: tuple[str, dict[str, Any]]) -> None:
        assert KeygenGenerator is not None, "KeygenGenerator not available"

        binary_path, known_data = test_binary_with_serial

        generator = KeygenGenerator()

        keys = generator.generate_keygen(binary_path=binary_path, num_keys=5)

        assert keys is not None, "FAILED: No keys generated from binary"
        assert len(keys) > 0, "FAILED: Empty key list returned"


@pytest.mark.skipif(not MODULE_AVAILABLE, reason=f"Modules not available: {'' if MODULE_AVAILABLE else IMPORT_ERROR}")
class TestAutomatedUnpackerEffectiveness:

    def test_detect_upx_packer(self, upx_packed_binary: str) -> None:
        assert AutomatedUnpacker is not None, "AutomatedUnpacker not available"
        assert PackerType is not None, "PackerType not available"

        unpacker = AutomatedUnpacker()

        context = unpacker.context
        if context is not None and hasattr(context, 'packer_type'):
            detected_packer = context.packer_type
            assert detected_packer == PackerType.UPX or "UPX" in str(detected_packer), \
                f"FAILED: Incorrect packer detected (got {detected_packer}, expected UPX)"

    def test_unpacking_produces_valid_pe(self, upx_packed_binary: str, temp_dir: Path) -> None:
        assert AutomatedUnpacker is not None, "AutomatedUnpacker not available"

        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        unpacker = AutomatedUnpacker()
        output_path = str(temp_dir / "unpacked.exe")

        result = unpacker.unpack_file(
            file_path=upx_packed_binary,
            output_path=output_path,
        )

        assert result is not None, "FAILED: Unpacking returned None"
        assert result, f"FAILED: Unpacking failed"
        assert os.path.exists(output_path), "FAILED: Unpacked binary not written to disk"

        try:
            unpacked_binary = lief.parse(output_path)
            assert unpacked_binary is not None, "FAILED: Unpacked binary is not a valid PE"
            assert unpacked_binary.has_imports or unpacked_binary.has_exports or unpacked_binary.sections, \
                "FAILED: Unpacked binary has no imports, exports, or sections (likely corrupted)"
        except Exception as e:
            pytest.fail(f"FAILED: Unpacked binary validation failed: {e}")

    def test_unpacker_preserves_functionality(self, temp_dir: Path) -> None:
        assert AutomatedUnpacker is not None, "AutomatedUnpacker not available"

        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        original_binary = lief.PE.Binary("test_original", lief.PE.PE_TYPE.PE32)

        text_section = lief.PE.Section(".text")
        text_section.content = [0x90, 0xC3] * 100
        text_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_CODE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        original_binary.add_section(text_section)

        data_section = lief.PE.Section(".data")
        MARKER_DATA = b"TESTMARKER12345"
        data_section.content = list(MARKER_DATA)
        data_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        original_binary.add_section(data_section)

        original_path = str(temp_dir / "original.exe")
        builder = lief.PE.Builder(original_binary)
        builder.build()
        builder.write(original_path)

        with open(original_path, 'rb') as f:
            original_hash = hashlib.sha256(f.read()).hexdigest()

        unpacker = AutomatedUnpacker()
        unpacked_path = str(temp_dir / "unpacked_functional.exe")

        result = unpacker.unpack_file(
            file_path=original_path,
            output_path=unpacked_path,
        )

        if result and os.path.exists(unpacked_path):
            unpacked_binary = lief.parse(unpacked_path)

            found_marker = False
            for section in unpacked_binary.sections:
                section_content = bytes(section.content)
                if MARKER_DATA in section_content:
                    found_marker = True
                    break

            assert found_marker, "FAILED: Unpacker did not preserve critical data sections"


@pytest.mark.skipif(not MODULE_AVAILABLE, reason=f"Modules not available: {'' if MODULE_AVAILABLE else IMPORT_ERROR}")
class TestBypassEngineEffectiveness:

    def test_recommend_bypass_for_protection(self) -> None:
        assert BypassEngine is not None, "BypassEngine not available"

        bypass_engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
        }

        recommendations = bypass_engine.get_recommended_bypasses(
            target_info=target_info,
        )

        assert recommendations is not None, "FAILED: No bypass recommendations returned"
        assert len(recommendations) > 0, "FAILED: No bypass techniques found"

    def test_bypass_effectiveness_analysis(self) -> None:
        assert BypassEngine is not None, "BypassEngine not available"

        bypass_engine = BypassEngine()

        available_bypasses = bypass_engine.get_available_bypasses()

        assert available_bypasses is not None and len(available_bypasses) > 0, \
            "FAILED: No bypass techniques available"

        for bypass_type in available_bypasses[:3]:
            bypass_info = bypass_engine.get_bypass_info(bypass_type)
            assert bypass_info is not None, f"FAILED: No info for bypass: {bypass_type}"
            assert "description" in bypass_info or "difficulty" in bypass_info or "reliability" in bypass_info, \
                f"FAILED: Bypass info incomplete for {bypass_type}"


@pytest.mark.skipif(not MODULE_AVAILABLE, reason=f"Modules not available: {'' if MODULE_AVAILABLE else IMPORT_ERROR}")
class TestIntegrationEffectiveness:

    def test_full_exploitation_pipeline(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]], temp_dir: Path) -> None:
        assert CryptoKeyExtractor is not None, "CryptoKeyExtractor not available"
        assert KeyType is not None, "KeyType not available"
        assert KeygenGenerator is not None, "KeygenGenerator not available"
        assert BypassEngine is not None, "BypassEngine not available"

        binary_path, known_data = test_binary_with_rsa_key

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        assert len(keys) > 0, "FAILED: Step 1 - Key extraction failed"

        rsa_keys = [k for k in keys if k.key_type in (KeyType.RSA_PUBLIC, KeyType.RSA_PRIVATE)]
        assert rsa_keys, "FAILED: Step 1 - No RSA keys extracted"

        generator = KeygenGenerator()

        generated_keys = generator.generate_keygen(binary_path=binary_path, num_keys=5)
        assert len(generated_keys) >= 0, "FAILED: Step 2 - Key generation failed"

        bypass_engine = BypassEngine()
        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
        }
        recommendations = bypass_engine.get_recommended_bypasses(target_info=target_info)

        assert recommendations is not None and len(recommendations) > 0, \
                "FAILED: Step 3 - Bypass recommendation failed"

    def test_unpacker_to_key_extractor_workflow(self, upx_packed_binary: str, temp_dir: Path) -> None:
        assert AutomatedUnpacker is not None, "AutomatedUnpacker not available"
        assert CryptoKeyExtractor is not None, "CryptoKeyExtractor not available"

        unpacker = AutomatedUnpacker()
        unpacked_path = str(temp_dir / "unpacked_for_extraction.exe")

        result = unpacker.unpack_file(
            file_path=upx_packed_binary,
            output_path=unpacked_path,
        )

        if result and os.path.exists(unpacked_path):
            extractor = CryptoKeyExtractor()
            keys = extractor.extract_from_binary(binary_path=unpacked_path)

            assert keys is not None, "FAILED: Key extraction from unpacked binary failed"
