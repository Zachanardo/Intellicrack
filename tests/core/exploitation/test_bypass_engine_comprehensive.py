"""Comprehensive production-ready tests for BypassEngine.

Validates actual exploit mitigation bypass capability analysis for defeating modern
software protection mechanisms including ASLR, DEP, CFI, CFG, and CET. Tests verify
genuine analysis of available bypass techniques based on target protection configuration.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

from typing import Any

import pytest

from intellicrack.core.exploitation.bypass_engine import BypassEngine


class TestBypassEngineInitialization:
    """Test BypassEngine initialization and configuration."""

    def test_bypass_engine_initializes_successfully(self) -> None:
        """BypassEngine initializes with logger configured."""
        engine = BypassEngine()

        assert engine is not None
        assert engine.logger is not None
        assert hasattr(engine, "analyze_bypass_capabilities")
        assert hasattr(engine, "get_available_bypasses")
        assert hasattr(engine, "get_bypass_info")
        assert hasattr(engine, "get_recommended_bypasses")

    def test_bypass_engine_has_logger_name(self) -> None:
        """BypassEngine logger has correct module name."""
        engine = BypassEngine()

        assert engine.logger.name == "intellicrack.core.exploitation.bypass_engine"


class TestGetAvailableBypassesCapabilities:
    """Test retrieval of available bypass techniques."""

    def test_get_available_bypasses_returns_all_bypass_types(self) -> None:
        """get_available_bypasses returns complete list of bypass techniques."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()

        assert isinstance(bypasses, list)
        assert len(bypasses) == 5
        assert "aslr_bypass" in bypasses
        assert "dep_bypass" in bypasses
        assert "cfi_bypass" in bypasses
        assert "cfg_bypass" in bypasses
        assert "cet_bypass" in bypasses

    def test_get_available_bypasses_returns_consistent_results(self) -> None:
        """get_available_bypasses returns consistent results across calls."""
        engine = BypassEngine()

        bypasses_first = engine.get_available_bypasses()
        bypasses_second = engine.get_available_bypasses()

        assert bypasses_first == bypasses_second
        assert len(bypasses_first) == len(bypasses_second)

    def test_get_available_bypasses_covers_major_mitigations(self) -> None:
        """get_available_bypasses includes bypasses for all major exploit mitigations."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()

        major_mitigations = ["aslr", "dep", "cfi", "cfg", "cet"]
        for mitigation in major_mitigations:
            bypass_name = f"{mitigation}_bypass"
            assert bypass_name in bypasses, f"Missing bypass for {mitigation.upper()}"


class TestGetBypassInfoCapabilities:
    """Test retrieval of detailed bypass technique information."""

    def test_get_bypass_info_aslr_returns_complete_details(self) -> None:
        """get_bypass_info returns complete ASLR bypass information."""
        engine = BypassEngine()

        info = engine.get_bypass_info("aslr_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Address Space Layout Randomization bypass"
        assert info["target_protection"] == "aslr_enabled"
        assert info["difficulty"] == "medium"
        assert info["reliability"] == 7
        assert 0 <= info["reliability"] <= 10

    def test_get_bypass_info_dep_returns_complete_details(self) -> None:
        """get_bypass_info returns complete DEP bypass information."""
        engine = BypassEngine()

        info = engine.get_bypass_info("dep_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Data Execution Prevention bypass"
        assert info["target_protection"] == "dep_enabled"
        assert info["difficulty"] == "high"
        assert info["reliability"] == 8
        assert info["reliability"] > 5

    def test_get_bypass_info_cfi_returns_complete_details(self) -> None:
        """get_bypass_info returns complete CFI bypass information."""
        engine = BypassEngine()

        info = engine.get_bypass_info("cfi_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Control Flow Integrity bypass"
        assert info["target_protection"] == "cfi_enabled"
        assert info["difficulty"] == "high"
        assert info["reliability"] == 6

    def test_get_bypass_info_cfg_returns_complete_details(self) -> None:
        """get_bypass_info returns complete CFG bypass information."""
        engine = BypassEngine()

        info = engine.get_bypass_info("cfg_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Control Flow Guard bypass"
        assert info["target_protection"] == "cfg_enabled"
        assert info["difficulty"] == "medium"
        assert info["reliability"] == 7

    def test_get_bypass_info_cet_returns_complete_details(self) -> None:
        """get_bypass_info returns complete CET bypass information."""
        engine = BypassEngine()

        info = engine.get_bypass_info("cet_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Control-flow Enforcement Technology bypass"
        assert info["target_protection"] == "cet_enabled"
        assert info["difficulty"] == "very_high"
        assert info["reliability"] == 5

    def test_get_bypass_info_unknown_type_returns_default(self) -> None:
        """get_bypass_info returns default information for unknown bypass type."""
        engine = BypassEngine()

        info = engine.get_bypass_info("nonexistent_bypass")

        assert isinstance(info, dict)
        assert info["description"] == "Unknown bypass type"
        assert info["target_protection"] == "unknown"
        assert info["difficulty"] == "unknown"
        assert info["reliability"] == 0

    def test_get_bypass_info_validates_all_required_fields(self) -> None:
        """get_bypass_info returns all required fields for each bypass type."""
        engine = BypassEngine()

        required_fields = ["description", "target_protection", "difficulty", "reliability"]
        bypasses = engine.get_available_bypasses()

        for bypass_type in bypasses:
            info = engine.get_bypass_info(bypass_type)
            for field in required_fields:
                assert field in info, f"Missing {field} in {bypass_type} info"

    def test_get_bypass_info_reliability_scores_are_realistic(self) -> None:
        """get_bypass_info returns realistic reliability scores for all bypasses."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()

        for bypass_type in bypasses:
            info = engine.get_bypass_info(bypass_type)
            reliability = info["reliability"]
            assert 0 <= reliability <= 10, f"{bypass_type} has invalid reliability: {reliability}"
            assert isinstance(reliability, int), f"{bypass_type} reliability must be integer"


class TestAnalyzeBypassCapabilitiesSingleMitigation:
    """Test bypass capability analysis for targets with single mitigations."""

    def test_analyze_bypass_aslr_only_target(self) -> None:
        """analyze_bypass_capabilities identifies ASLR bypass for ASLR-only target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert isinstance(result, dict)
        assert "bypasses_available" in result
        assert "target_info" in result
        assert "bypass_count" in result
        assert result["bypasses_available"] == ["aslr_bypass"]
        assert result["bypass_count"] == 1
        assert result["target_info"] == target_info

    def test_analyze_bypass_dep_only_target(self) -> None:
        """analyze_bypass_capabilities identifies DEP bypass for DEP-only target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypasses_available"] == ["dep_bypass"]
        assert result["bypass_count"] == 1

    def test_analyze_bypass_cfi_only_target(self) -> None:
        """analyze_bypass_capabilities identifies CFI bypass for CFI-only target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": True,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypasses_available"] == ["cfi_bypass"]
        assert result["bypass_count"] == 1

    def test_analyze_bypass_cfg_only_target(self) -> None:
        """analyze_bypass_capabilities identifies CFG bypass for CFG-only target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypasses_available"] == ["cfg_bypass"]
        assert result["bypass_count"] == 1

    def test_analyze_bypass_cet_only_target(self) -> None:
        """analyze_bypass_capabilities identifies CET bypass for CET-only target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypasses_available"] == ["cet_bypass"]
        assert result["bypass_count"] == 1


class TestAnalyzeBypassCapabilitiesMultipleMitigations:
    """Test bypass capability analysis for targets with multiple mitigations."""

    def test_analyze_bypass_aslr_plus_dep_target(self) -> None:
        """analyze_bypass_capabilities identifies both ASLR and DEP bypasses."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 2
        assert "aslr_bypass" in result["bypasses_available"]
        assert "dep_bypass" in result["bypasses_available"]

    def test_analyze_bypass_windows_standard_protections(self) -> None:
        """analyze_bypass_capabilities handles Windows standard protection configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 3
        assert "aslr_bypass" in result["bypasses_available"]
        assert "dep_bypass" in result["bypasses_available"]
        assert "cfg_bypass" in result["bypasses_available"]

    def test_analyze_bypass_windows_maximum_protections(self) -> None:
        """analyze_bypass_capabilities handles Windows maximum protection configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 5
        assert len(result["bypasses_available"]) == 5
        assert "aslr_bypass" in result["bypasses_available"]
        assert "dep_bypass" in result["bypasses_available"]
        assert "cfi_bypass" in result["bypasses_available"]
        assert "cfg_bypass" in result["bypasses_available"]
        assert "cet_bypass" in result["bypasses_available"]

    def test_analyze_bypass_legacy_protections_only(self) -> None:
        """analyze_bypass_capabilities handles legacy protection configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 2
        assert "aslr_bypass" in result["bypasses_available"]
        assert "dep_bypass" in result["bypasses_available"]
        assert "cfi_bypass" not in result["bypasses_available"]
        assert "cfg_bypass" not in result["bypasses_available"]
        assert "cet_bypass" not in result["bypasses_available"]

    def test_analyze_bypass_modern_protections_only(self) -> None:
        """analyze_bypass_capabilities handles modern protection configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 3
        assert "cfi_bypass" in result["bypasses_available"]
        assert "cfg_bypass" in result["bypasses_available"]
        assert "cet_bypass" in result["bypasses_available"]
        assert "aslr_bypass" not in result["bypasses_available"]
        assert "dep_bypass" not in result["bypasses_available"]


class TestAnalyzeBypassCapabilitiesNoMitigations:
    """Test bypass capability analysis for unprotected targets."""

    def test_analyze_bypass_no_protections_enabled(self) -> None:
        """analyze_bypass_capabilities returns empty list for unprotected target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 0
        assert result["bypasses_available"] == []
        assert result["target_info"] == target_info

    def test_analyze_bypass_empty_target_info(self) -> None:
        """analyze_bypass_capabilities handles empty target information."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {}

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 0
        assert result["bypasses_available"] == []
        assert result["target_info"] == target_info

    def test_analyze_bypass_missing_protection_keys(self) -> None:
        """analyze_bypass_capabilities handles missing protection keys gracefully."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)

        assert result["bypass_count"] == 1
        assert result["bypasses_available"] == ["aslr_bypass"]


class TestGetRecommendedBypassesDefaultThreshold:
    """Test recommended bypass retrieval with default reliability threshold."""

    def test_get_recommended_bypasses_aslr_dep_default_threshold(self) -> None:
        """get_recommended_bypasses returns high reliability bypasses for ASLR+DEP target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        recommended = engine.get_recommended_bypasses(target_info)

        assert isinstance(recommended, list)
        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended
        assert len(recommended) == 2

    def test_get_recommended_bypasses_all_protections_default_threshold(self) -> None:
        """get_recommended_bypasses filters out low reliability bypasses."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info)

        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended
        assert "cfi_bypass" in recommended
        assert "cfg_bypass" in recommended
        assert "cet_bypass" not in recommended
        assert len(recommended) == 4

    def test_get_recommended_bypasses_windows_standard_default_threshold(self) -> None:
        """get_recommended_bypasses returns reliable bypasses for standard Windows config."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        recommended = engine.get_recommended_bypasses(target_info)

        assert len(recommended) == 3
        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended
        assert "cfg_bypass" in recommended


class TestGetRecommendedBypassesCustomThresholds:
    """Test recommended bypass retrieval with custom reliability thresholds."""

    def test_get_recommended_bypasses_minimum_threshold_zero(self) -> None:
        """get_recommended_bypasses returns all bypasses with threshold 0."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=0)

        assert len(recommended) == 5
        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended
        assert "cfi_bypass" in recommended
        assert "cfg_bypass" in recommended
        assert "cet_bypass" in recommended

    def test_get_recommended_bypasses_high_threshold_eight(self) -> None:
        """get_recommended_bypasses returns only highest reliability bypasses with threshold 8."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=8)

        assert len(recommended) == 1
        assert "dep_bypass" in recommended
        assert "aslr_bypass" not in recommended
        assert "cfi_bypass" not in recommended
        assert "cfg_bypass" not in recommended
        assert "cet_bypass" not in recommended

    def test_get_recommended_bypasses_very_high_threshold_ten(self) -> None:
        """get_recommended_bypasses returns empty list with unreachable threshold."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=10)

        assert len(recommended) == 0

    def test_get_recommended_bypasses_threshold_seven(self) -> None:
        """get_recommended_bypasses filters correctly with threshold 7."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=7)

        assert len(recommended) == 3
        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended
        assert "cfg_bypass" in recommended
        assert "cfi_bypass" not in recommended
        assert "cet_bypass" not in recommended

    def test_get_recommended_bypasses_threshold_five(self) -> None:
        """get_recommended_bypasses includes all available bypasses with threshold 5."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=5)

        assert len(recommended) == 5


class TestGetRecommendedBypassesEdgeCases:
    """Test recommended bypass retrieval with edge case scenarios."""

    def test_get_recommended_bypasses_no_protections_enabled(self) -> None:
        """get_recommended_bypasses returns empty list for unprotected target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        recommended = engine.get_recommended_bypasses(target_info)

        assert len(recommended) == 0

    def test_get_recommended_bypasses_only_low_reliability_protections(self) -> None:
        """get_recommended_bypasses returns empty when only low reliability bypasses available."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": False,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=6)

        assert len(recommended) == 0

    def test_get_recommended_bypasses_mixed_reliability_protections(self) -> None:
        """get_recommended_bypasses correctly filters mixed reliability bypasses."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": False,
            "cfi_enabled": True,
            "cfg_enabled": False,
            "cet_enabled": True,
        }

        recommended = engine.get_recommended_bypasses(target_info, min_reliability=7)

        assert len(recommended) == 1
        assert "aslr_bypass" in recommended
        assert "cfi_bypass" not in recommended
        assert "cet_bypass" not in recommended


class TestBypassEngineRealWorldScenarios:
    """Test bypass engine with real-world exploit scenario configurations."""

    def test_bypass_engine_windows_7_enterprise_scenario(self) -> None:
        """BypassEngine analyzes Windows 7 Enterprise target configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)
        recommended = engine.get_recommended_bypasses(target_info)

        assert result["bypass_count"] == 2
        assert len(recommended) == 2
        assert "aslr_bypass" in recommended
        assert "dep_bypass" in recommended

    def test_bypass_engine_windows_10_1909_scenario(self) -> None:
        """BypassEngine analyzes Windows 10 1909 target configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)
        recommended = engine.get_recommended_bypasses(target_info)

        assert result["bypass_count"] == 3
        assert len(recommended) == 3

    def test_bypass_engine_windows_11_latest_scenario(self) -> None:
        """BypassEngine analyzes Windows 11 latest target configuration."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)
        recommended_high = engine.get_recommended_bypasses(target_info, min_reliability=7)
        recommended_low = engine.get_recommended_bypasses(target_info, min_reliability=5)

        assert result["bypass_count"] == 5
        assert len(recommended_high) == 3
        assert len(recommended_low) == 5

    def test_bypass_engine_embedded_system_scenario(self) -> None:
        """BypassEngine analyzes embedded system with minimal protections."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": False,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        result = engine.analyze_bypass_capabilities(target_info)
        recommended = engine.get_recommended_bypasses(target_info)

        assert result["bypass_count"] == 1
        assert "dep_bypass" in recommended

    def test_bypass_engine_hardened_server_scenario(self) -> None:
        """BypassEngine analyzes hardened server with all protections."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        result = engine.analyze_bypass_capabilities(target_info)
        aslr_info = engine.get_bypass_info("aslr_bypass")
        dep_info = engine.get_bypass_info("dep_bypass")
        cet_info = engine.get_bypass_info("cet_bypass")

        assert result["bypass_count"] == 5
        assert aslr_info["reliability"] >= 6
        assert dep_info["reliability"] >= 6
        assert cet_info["reliability"] < 6


class TestBypassEngineIntegrationWorkflows:
    """Test complete bypass analysis workflows."""

    def test_bypass_engine_complete_analysis_workflow(self) -> None:
        """BypassEngine performs complete analysis workflow from capabilities to recommendations."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        available_bypasses = engine.get_available_bypasses()
        assert len(available_bypasses) == 5

        capabilities = engine.analyze_bypass_capabilities(target_info)
        assert capabilities["bypass_count"] == 4

        recommended = engine.get_recommended_bypasses(target_info)
        assert len(recommended) <= capabilities["bypass_count"]

        for bypass_type in recommended:
            info = engine.get_bypass_info(bypass_type)
            assert info["reliability"] >= 6
            assert bypass_type in capabilities["bypasses_available"]

    def test_bypass_engine_progressive_reliability_filtering(self) -> None:
        """BypassEngine progressively filters bypasses by increasing reliability threshold."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        recommended_5 = engine.get_recommended_bypasses(target_info, min_reliability=5)
        recommended_6 = engine.get_recommended_bypasses(target_info, min_reliability=6)
        recommended_7 = engine.get_recommended_bypasses(target_info, min_reliability=7)
        recommended_8 = engine.get_recommended_bypasses(target_info, min_reliability=8)

        assert len(recommended_5) >= len(recommended_6)
        assert len(recommended_6) >= len(recommended_7)
        assert len(recommended_7) >= len(recommended_8)

        assert set(recommended_8).issubset(set(recommended_7))
        assert set(recommended_7).issubset(set(recommended_6))
        assert set(recommended_6).issubset(set(recommended_5))

    def test_bypass_engine_difficulty_correlation_with_reliability(self) -> None:
        """BypassEngine difficulty levels correlate appropriately with reliability."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()
        difficulty_reliability_map: dict[str, list[int]] = {
            "medium": [],
            "high": [],
            "very_high": [],
        }

        for bypass_type in bypasses:
            info = engine.get_bypass_info(bypass_type)
            difficulty = info["difficulty"]
            reliability = info["reliability"]
            if difficulty in difficulty_reliability_map:
                difficulty_reliability_map[difficulty].append(reliability)

        medium_avg = sum(difficulty_reliability_map["medium"]) / len(difficulty_reliability_map["medium"])
        high_avg = sum(difficulty_reliability_map["high"]) / len(difficulty_reliability_map["high"])
        very_high_avg = sum(difficulty_reliability_map["very_high"]) / len(difficulty_reliability_map["very_high"])

        assert medium_avg >= high_avg
        assert high_avg >= very_high_avg


class TestBypassEngineConsistencyAndValidation:
    """Test consistency and validation of bypass engine behavior."""

    def test_bypass_engine_consistent_results_across_instances(self) -> None:
        """Multiple BypassEngine instances return consistent results."""
        engine1 = BypassEngine()
        engine2 = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        result1 = engine1.analyze_bypass_capabilities(target_info)
        result2 = engine2.analyze_bypass_capabilities(target_info)

        assert result1 == result2
        assert result1["bypass_count"] == result2["bypass_count"]
        assert result1["bypasses_available"] == result2["bypasses_available"]

    def test_bypass_engine_all_bypasses_have_valid_target_protection(self) -> None:
        """All bypass types have valid target_protection field that matches target_info keys."""
        engine = BypassEngine()

        bypasses = engine.get_available_bypasses()
        valid_protection_keys = ["aslr_enabled", "dep_enabled", "cfi_enabled", "cfg_enabled", "cet_enabled"]

        for bypass_type in bypasses:
            info = engine.get_bypass_info(bypass_type)
            target_protection = info["target_protection"]
            assert target_protection in valid_protection_keys, f"{bypass_type} has invalid target_protection: {target_protection}"

    def test_bypass_engine_recommended_bypasses_subset_of_available(self) -> None:
        """Recommended bypasses are always subset of available bypasses for target."""
        engine = BypassEngine()

        target_info: dict[str, Any] = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": True,
            "cfg_enabled": True,
            "cet_enabled": True,
        }

        capabilities = engine.analyze_bypass_capabilities(target_info)
        available = capabilities["bypasses_available"]

        for threshold in range(0, 11):
            recommended = engine.get_recommended_bypasses(target_info, min_reliability=threshold)
            for bypass in recommended:
                assert bypass in available, f"{bypass} recommended but not in available bypasses"

    def test_bypass_engine_bypass_count_matches_list_length(self) -> None:
        """analyze_bypass_capabilities bypass_count always matches bypasses_available length."""
        engine = BypassEngine()

        test_configs = [
            {"aslr_enabled": True, "dep_enabled": False, "cfi_enabled": False, "cfg_enabled": False, "cet_enabled": False},
            {"aslr_enabled": True, "dep_enabled": True, "cfi_enabled": False, "cfg_enabled": False, "cet_enabled": False},
            {"aslr_enabled": True, "dep_enabled": True, "cfi_enabled": True, "cfg_enabled": False, "cet_enabled": False},
            {"aslr_enabled": True, "dep_enabled": True, "cfi_enabled": True, "cfg_enabled": True, "cet_enabled": False},
            {"aslr_enabled": True, "dep_enabled": True, "cfi_enabled": True, "cfg_enabled": True, "cet_enabled": True},
        ]

        for config in test_configs:
            result = engine.analyze_bypass_capabilities(config)
            assert result["bypass_count"] == len(result["bypasses_available"])
