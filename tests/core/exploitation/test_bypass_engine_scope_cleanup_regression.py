"""Regression tests for bypass engine scope cleanup verification.

This module contains regression tests verifying that shell-related payloads
(REVERSE_SHELL, BIND_SHELL) have been completely removed from the codebase
and only legitimate license bypass payloads remain. Tests verify that previously
working functionality continues to work after scope cleanup.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import ast
import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.analysis.radare2_advanced_patcher import Architecture
from intellicrack.core.exploitation.bypass_engine import BypassEngine, PayloadType
from intellicrack.core.shared.bypass_config import BypassConfig


class TestBypassEngineScopeCleanupRegression:
    """Regression tests verifying shell-related payloads removed from bypass engine.

    These tests ensure that the bypass engine scope cleanup completed previously
    continues to be enforced - no shell-related payloads, only licensing bypass
    payloads remain in the codebase.
    """

    @pytest.fixture
    def bypass_engine(self) -> BypassEngine:
        """Create bypass engine instance for testing.

        Returns:
            Initialized BypassEngine instance.
        """
        return BypassEngine()

    @pytest.fixture
    def bypass_engine_source_path(self) -> Path:
        """Get path to bypass_engine.py source file.

        Returns:
            Path to bypass_engine.py module source file.
        """
        return Path(__file__).parent.parent.parent.parent / "intellicrack" / "core" / "exploitation" / "bypass_engine.py"

    @pytest.fixture
    def bypass_config_source_path(self) -> Path:
        """Get path to bypass_config.py source file.

        Returns:
            Path to bypass_config.py module source file.
        """
        return Path(__file__).parent.parent.parent.parent / "intellicrack" / "core" / "shared" / "bypass_config.py"

    def test_payload_type_enum_contains_only_license_bypass_types(self, bypass_engine: BypassEngine) -> None:
        """Verify PayloadType enum contains ONLY license-related bypass types.

        Tests that the PayloadType enum has been cleaned of all shell-related
        payloads (REVERSE_SHELL, BIND_SHELL) and contains only legitimate
        license bypass payload types.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        valid_license_payloads = {
            "LICENSE_CHECK_BYPASS",
            "TRIAL_EXTENSION",
            "ACTIVATION_BYPASS",
            "SERIAL_VALIDATION_BYPASS",
            "HARDWARE_ID_SPOOF",
        }

        actual_payload_types = {member.name for member in PayloadType}

        assert actual_payload_types == valid_license_payloads, (
            f"PayloadType enum contains unexpected payload types. "
            f"Expected: {valid_license_payloads}, Got: {actual_payload_types}"
        )

    def test_payload_type_enum_no_shell_payloads(self, bypass_engine: BypassEngine) -> None:
        """Verify PayloadType enum contains NO shell-related payloads.

        Tests that REVERSE_SHELL and BIND_SHELL payload types have been
        completely removed from the PayloadType enum.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        forbidden_payloads = {"REVERSE_SHELL", "BIND_SHELL", "SHELL", "BIND", "REVERSE"}

        actual_payload_types = {member.name for member in PayloadType}

        for forbidden in forbidden_payloads:
            assert forbidden not in actual_payload_types, (
                f"Forbidden shell-related payload type '{forbidden}' found in PayloadType enum. "
                f"All shell payloads must be removed from license bypass tool."
            )

    def test_payload_type_enum_values_are_license_focused(self, bypass_engine: BypassEngine) -> None:
        """Verify PayloadType enum values describe license bypass functionality.

        Tests that all PayloadType enum values contain licensing-related terms
        and no shell/network attack terminology.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        license_keywords = {
            "license",
            "trial",
            "activation",
            "serial",
            "hardware",
            "bypass",
            "check",
            "validation",
            "extension",
            "spoof",
        }

        forbidden_keywords = {
            "shell",
            "bind",
            "reverse",
            "connect",
            "backdoor",
            "exploit",
            "payload",
            "attack",
        }

        for member in PayloadType:
            value_lower = member.value.lower()

            has_license_keyword = any(keyword in value_lower for keyword in license_keywords)
            assert has_license_keyword, (
                f"PayloadType.{member.name} value '{member.value}' does not contain "
                f"licensing-related keywords. Expected one of: {license_keywords}"
            )

            has_forbidden_keyword = any(keyword in value_lower for keyword in forbidden_keywords)
            assert not has_forbidden_keyword, (
                f"PayloadType.{member.name} value '{member.value}' contains forbidden "
                f"shell/attack keyword. Found: {[kw for kw in forbidden_keywords if kw in value_lower]}"
            )

    def test_bypass_engine_source_code_no_shell_references(self, bypass_engine_source_path: Path) -> None:
        """Verify bypass_engine.py source code contains NO shell-related references.

        Tests that the bypass_engine.py source file does not contain any
        references to shell payloads, reverse shells, bind shells, or
        network exploitation code.

        Args:
            bypass_engine_source_path: Path to bypass_engine.py source file.
        """
        source_code = bypass_engine_source_path.read_text(encoding="utf-8")

        forbidden_patterns = [
            "REVERSE_SHELL",
            "BIND_SHELL",
            "reverse_shell",
            "bind_shell",
            "reverse shell",
            "bind shell",
            "shell payload",
            "backdoor",
            "netcat",
            "nc -l",
            "connect-back",
            "connectback",
        ]

        found_patterns: list[str] = []
        for pattern in forbidden_patterns:
            if pattern.lower() in source_code.lower():
                found_patterns.append(pattern)

        assert not found_patterns, (
            f"bypass_engine.py source code contains forbidden shell-related patterns: {found_patterns}. "
            f"All shell payload references must be removed from license bypass tool."
        )

    def test_bypass_engine_source_code_contains_license_focus_documentation(
        self, bypass_engine_source_path: Path
    ) -> None:
        """Verify bypass_engine.py contains clear licensing-focused documentation.

        Tests that the bypass_engine.py source file contains explicit documentation
        stating the tool is EXCLUSIVELY for license bypass and NOT for shell
        payloads or general exploitation.

        Args:
            bypass_engine_source_path: Path to bypass_engine.py source file.
        """
        source_code = bypass_engine_source_path.read_text(encoding="utf-8")

        required_documentation_keywords = [
            "license",
            "licensing",
            "EXCLUSIVELY",
            "bypass",
            "protection",
        ]

        for keyword in required_documentation_keywords:
            assert keyword in source_code, (
                f"bypass_engine.py source code missing required documentation keyword: '{keyword}'. "
                f"Module must clearly document its exclusive focus on license bypass."
            )

        forbidden_documentation = [
            "general exploitation",
            "network attack",
            "remote code execution",
            "arbitrary code execution",
        ]

        for forbidden in forbidden_documentation:
            assert forbidden.lower() not in source_code.lower(), (
                f"bypass_engine.py documentation contains forbidden general exploitation "
                f"reference: '{forbidden}'. Module must focus exclusively on license bypass."
            )

    def test_bypass_engine_payload_generators_mapping_contains_only_license_types(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify payload_generators mapping contains ONLY license bypass generators.

        Tests that the internal payload_generators dictionary in generate_payload()
        method contains only mappings to license-related generator methods.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        valid_generator_methods = {
            "_generate_license_check_bypass",
            "_generate_trial_extension",
            "_generate_activation_bypass",
            "_generate_serial_validation_bypass",
            "_generate_hardware_id_spoof",
        }

        for member in PayloadType:
            assert hasattr(bypass_engine, f"_generate_{member.value}"), (
                f"BypassEngine missing expected generator method for PayloadType.{member.name}: "
                f"_generate_{member.value}"
            )

        actual_methods = {
            method_name
            for method_name in dir(bypass_engine)
            if method_name.startswith("_generate_") and callable(getattr(bypass_engine, method_name))
        }

        license_bypass_methods = {
            method for method in actual_methods if method in valid_generator_methods or method.startswith("_generate_x") or method.startswith("_generate_arm")
        }

        forbidden_methods = {
            "_generate_reverse_shell",
            "_generate_bind_shell",
            "_generate_shell",
            "_generate_backdoor",
            "_generate_connect_back",
        }

        for forbidden in forbidden_methods:
            assert forbidden not in actual_methods, (
                f"BypassEngine contains forbidden shell generator method: {forbidden}. "
                f"All shell payload generators must be removed."
            )

    def test_bypass_engine_generate_payload_rejects_invalid_payload_types(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify generate_payload() gracefully handles invalid payload type strings.

        Tests that attempting to generate shell-related payloads via string
        identifiers defaults to license check bypass instead of raising errors
        or generating shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        invalid_payload_types = [
            "REVERSE_SHELL",
            "BIND_SHELL",
            "reverse_shell",
            "bind_shell",
            "shell",
            "backdoor",
            "invalid_type",
            "nonexistent",
        ]

        for invalid_type in invalid_payload_types:
            result = bypass_engine.generate_payload(
                payload_type=invalid_type,
                architecture="x64",
                target_info=target_info,
                options={},
            )

            assert result["payload_type"] == "license_check_bypass", (
                f"generate_payload() with invalid type '{invalid_type}' should default to "
                f"'license_check_bypass', but got: {result['payload_type']}"
            )

            assert isinstance(result["payload"], bytes), (
                f"generate_payload() should return bytes payload, got: {type(result['payload'])}"
            )

    def test_bypass_engine_generated_payloads_contain_no_network_code(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify generated payloads contain NO network connection code.

        Tests that payloads generated by BypassEngine do not contain network
        socket operations, IP addresses, port numbers, or connection establishment
        code typical of shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        for payload_type in PayloadType:
            result = bypass_engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info=target_info,
                options={"return_value": 1, "preserve_stack": True},
            )

            payload_bytes = result["payload"]

            forbidden_network_patterns = [
                b"\x02\x00",
                b"\x7F\x00\x00\x01",
                b"\xC0\xA8",
                b"\x0A\x00",
                b"socket",
                b"connect",
                b"bind",
                b"listen",
                b"accept",
                b"recv",
                b"send",
                b"ws2_32",
                b"WSAStartup",
            ]

            for pattern in forbidden_network_patterns:
                assert pattern not in payload_bytes, (
                    f"Payload for {payload_type.name} contains forbidden network pattern: {pattern.hex()}. "
                    f"License bypass payloads must not contain network code."
                )

    def test_bypass_engine_all_architectures_generate_license_bypass_only(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify all architecture-specific generators produce license bypass code.

        Tests that x86, x64, ARM, and ARM64 architecture-specific generators
        produce only license bypass shellcode without shell/network functionality.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        architectures = ["x86", "x64", "arm", "arm64"]

        for arch in architectures:
            result = bypass_engine.generate_payload(
                payload_type=PayloadType.LICENSE_CHECK_BYPASS,
                architecture=arch,
                target_info=target_info,
                options={"return_value": 1, "preserve_stack": True},
            )

            payload = result["payload"]

            assert len(payload) > 0, f"Generated payload for {arch} is empty"

            assert result["payload_type"] == "license_check_bypass", (
                f"Payload type mismatch for {arch}: expected 'license_check_bypass', "
                f"got '{result['payload_type']}'"
            )

            x86_return_patterns = [b"\xb8", b"\xc3"]
            x64_return_patterns = [b"\x48\xc7\xc0", b"\xc3"]
            arm_return_patterns = [b"\x00\x00\xa0\xe3"]
            arm64_return_patterns = [b"\x00\x00\x80\xd2", b"\xc0\x03\x5f\xd6"]

            if arch in {"x86", "i386", "i686"}:
                has_x86_pattern = any(pattern in payload for pattern in x86_return_patterns)
                assert has_x86_pattern, f"x86 payload missing expected return instruction patterns"
            elif arch in {"x64", "x86_64", "amd64"}:
                has_x64_pattern = any(pattern in payload for pattern in x64_return_patterns)
                assert has_x64_pattern, f"x64 payload missing expected return instruction patterns"
            elif arch in {"arm", "armv7"}:
                has_arm_pattern = any(pattern in payload for pattern in arm_return_patterns)
                assert has_arm_pattern, f"ARM payload missing expected instruction patterns"
            elif arch in {"arm64", "aarch64"}:
                has_arm64_pattern = any(pattern in payload for pattern in arm64_return_patterns)
                assert has_arm64_pattern, f"ARM64 payload missing expected instruction patterns"

    def test_bypass_config_contains_only_mitigation_bypasses(self) -> None:
        """Verify BypassConfig contains only exploit mitigation bypass types.

        Tests that BypassConfig.BYPASS_TYPES contains only legitimate exploit
        mitigation bypasses (ASLR, DEP, CFI, CFG, CET) and no shell payload
        configurations.

        """
        valid_bypass_types = {
            "aslr_bypass",
            "dep_bypass",
            "cfi_bypass",
            "cfg_bypass",
            "cet_bypass",
        }

        actual_bypass_types = set(BypassConfig.BYPASS_TYPES.keys())

        assert actual_bypass_types == valid_bypass_types, (
            f"BypassConfig.BYPASS_TYPES contains unexpected bypass types. "
            f"Expected: {valid_bypass_types}, Got: {actual_bypass_types}"
        )

    def test_bypass_config_no_shell_payload_configurations(self) -> None:
        """Verify BypassConfig contains NO shell payload configurations.

        Tests that BypassConfig.BYPASS_TYPES does not contain any shell-related
        payload configurations or network attack bypass types.

        """
        forbidden_bypass_types = {
            "shell_bypass",
            "reverse_shell_bypass",
            "bind_shell_bypass",
            "network_bypass",
            "firewall_bypass",
        }

        actual_bypass_types = set(BypassConfig.BYPASS_TYPES.keys())

        for forbidden in forbidden_bypass_types:
            assert forbidden not in actual_bypass_types, (
                f"BypassConfig.BYPASS_TYPES contains forbidden shell-related bypass: '{forbidden}'. "
                f"Configuration must focus exclusively on exploit mitigation bypasses."
            )

    def test_bypass_config_source_code_no_shell_references(self, bypass_config_source_path: Path) -> None:
        """Verify bypass_config.py source code contains NO shell-related references.

        Tests that the bypass_config.py source file does not contain any
        references to shell payloads or network attack configurations.

        Args:
            bypass_config_source_path: Path to bypass_config.py source file.
        """
        source_code = bypass_config_source_path.read_text(encoding="utf-8")

        forbidden_patterns = [
            "shell",
            "reverse",
            "bind",
            "backdoor",
            "network attack",
            "remote code",
        ]

        found_patterns: list[str] = []
        for pattern in forbidden_patterns:
            if pattern.lower() in source_code.lower():
                found_patterns.append(pattern)

        assert not found_patterns, (
            f"bypass_config.py source code contains forbidden patterns: {found_patterns}. "
            f"Configuration must focus exclusively on exploit mitigation bypasses."
        )

    def test_bypass_engine_docstrings_emphasize_license_focus(self, bypass_engine: BypassEngine) -> None:
        """Verify BypassEngine class and method docstrings emphasize license focus.

        Tests that class and method docstrings clearly state the exclusive
        focus on license bypass and explicitly exclude shell/network payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        class_doc = BypassEngine.__doc__
        assert class_doc is not None, "BypassEngine class missing docstring"
        assert "license" in class_doc.lower() or "licensing" in class_doc.lower(), (
            "BypassEngine class docstring must mention 'license' or 'licensing'"
        )

        generate_payload_doc = BypassEngine.generate_payload.__doc__
        assert generate_payload_doc is not None, "generate_payload method missing docstring"
        assert "license" in generate_payload_doc.lower() or "licensing" in generate_payload_doc.lower(), (
            "generate_payload method docstring must mention 'license' or 'licensing'"
        )

    def test_payload_type_enum_docstring_emphasizes_license_focus(self) -> None:
        """Verify PayloadType enum docstring emphasizes license focus.

        Tests that the PayloadType enum docstring clearly states it contains
        EXCLUSIVELY license-related bypass payloads and NO shell payloads.

        """
        enum_doc = PayloadType.__doc__
        assert enum_doc is not None, "PayloadType enum missing docstring"

        required_keywords = ["license", "licensing", "EXCLUSIVELY"]
        for keyword in required_keywords:
            assert keyword in enum_doc, (
                f"PayloadType docstring must contain keyword '{keyword}' to emphasize license focus"
            )

        forbidden_keywords = ["general exploitation", "shell payload"]
        for keyword in forbidden_keywords:
            assert keyword.lower() not in enum_doc.lower(), (
                f"PayloadType docstring must not contain '{keyword}' - should emphasize license bypass only"
            )

    def test_bypass_engine_format_payload_no_network_formats(self, bypass_engine: BypassEngine) -> None:
        """Verify _format_payload method does not support network payload formats.

        Tests that the _format_payload method only supports local code formats
        (c, python, powershell, exe, dll, raw) and does not include formats
        typical of network payloads (elf_bind, elf_reverse, etc).

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        sample_payload = b"\x90\x90\xc3"

        valid_formats = ["raw", "c", "python", "powershell", "exe", "dll"]

        for output_format in valid_formats:
            result = bypass_engine._format_payload(sample_payload, output_format, "x64")
            assert isinstance(result, bytes), (
                f"_format_payload with format '{output_format}' should return bytes"
            )

        forbidden_formats = [
            "elf_bind",
            "elf_reverse",
            "macho_bind",
            "macho_reverse",
            "reverse_tcp",
            "bind_tcp",
        ]

        for forbidden_format in forbidden_formats:
            result = bypass_engine._format_payload(sample_payload, forbidden_format, "x64")
            assert result == sample_payload, (
                f"_format_payload should not recognize forbidden format '{forbidden_format}' "
                f"and should return raw payload unchanged"
            )

    def test_bypass_engine_apply_encoding_no_network_evasion(self, bypass_engine: BypassEngine) -> None:
        """Verify _apply_encoding method contains only local obfuscation schemes.

        Tests that the _apply_encoding method supports only local obfuscation
        schemes (base64, null_free, reverse, rot13, xor) and does not include
        network-specific evasion techniques.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        sample_payload = b"\x90\x90\xc3"

        valid_schemes = ["base64", "null_free", "reverse", "rot13", "xor"]

        for scheme in valid_schemes:
            result = bypass_engine._apply_encoding(sample_payload, scheme)
            assert isinstance(result, bytes), (
                f"_apply_encoding with scheme '{scheme}' should return bytes"
            )

        forbidden_schemes = [
            "network_encode",
            "tcp_encode",
            "http_encode",
            "dns_encode",
            "ssl_encode",
        ]

        for forbidden_scheme in forbidden_schemes:
            result = bypass_engine._apply_encoding(sample_payload, forbidden_scheme)
            assert result == sample_payload, (
                f"_apply_encoding should not recognize forbidden scheme '{forbidden_scheme}' "
                f"and should return payload unchanged"
            )

    def test_bypass_engine_source_ast_no_shell_string_literals(
        self, bypass_engine_source_path: Path
    ) -> None:
        """Verify bypass_engine.py AST contains NO shell-related string literals.

        Tests that parsing the bypass_engine.py source code reveals no string
        literals referencing shells, reverse connections, or bind listeners.

        Args:
            bypass_engine_source_path: Path to bypass_engine.py source file.
        """
        source_code = bypass_engine_source_path.read_text(encoding="utf-8")

        try:
            tree = ast.parse(source_code)
        except SyntaxError:
            pytest.fail("bypass_engine.py contains syntax errors")

        forbidden_string_patterns = [
            "reverse_shell",
            "bind_shell",
            "REVERSE_SHELL",
            "BIND_SHELL",
            "shell payload",
            "reverse connection",
            "bind listener",
        ]

        found_forbidden_strings: list[str] = []

        for node in ast.walk(tree):
            if isinstance(node, ast.Constant) and isinstance(node.value, str):
                string_value = node.value.lower()
                for pattern in forbidden_string_patterns:
                    if pattern.lower() in string_value:
                        found_forbidden_strings.append(f"{pattern} in '{node.value}'")

        assert not found_forbidden_strings, (
            f"bypass_engine.py AST contains forbidden shell-related string literals: "
            f"{found_forbidden_strings}"
        )

    def test_bypass_engine_no_network_options_in_generate_payload(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify generate_payload method does not accept network-related options.

        Tests that the generate_payload method's options parameter documentation
        and implementation do not expect or process network-related options like
        LHOST/LPORT (typical of shell payloads).

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        network_options = {
            "lhost": "192.168.1.100",
            "lport": 4444,
        }

        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=target_info,
            options=network_options,
        )

        payload = result["payload"]

        lhost_bytes = b"192.168.1.100"
        assert lhost_bytes not in payload, (
            "Generated payload should not contain LHOST value - network options should be ignored"
        )

        lport_bytes_be = b"\x11\x5c"
        lport_bytes_le = b"\x5c\x11"
        assert lport_bytes_be not in payload and lport_bytes_le not in payload, (
            "Generated payload should not contain LPORT value - network options should be ignored"
        )

    def test_all_payload_types_generate_valid_license_bypass_code(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify all PayloadType enum members generate valid license bypass code.

        Tests that every payload type in the PayloadType enum successfully
        generates non-empty, architecture-appropriate license bypass shellcode.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        for payload_type in PayloadType:
            result = bypass_engine.generate_payload(
                payload_type=payload_type,
                architecture="x64",
                target_info=target_info,
                options={"return_value": 1, "preserve_stack": True},
            )

            assert result["payload"], f"PayloadType.{payload_type.name} generated empty payload"
            assert result["size"] > 0, f"PayloadType.{payload_type.name} payload size is 0"
            assert result["architecture"] == "x64", (
                f"PayloadType.{payload_type.name} returned wrong architecture"
            )
            assert result["payload_type"] in {
                "license_check_bypass",
                "trial_extension",
                "activation_bypass",
                "serial_validation_bypass",
                "hardware_id_spoof",
            }, f"PayloadType.{payload_type.name} returned invalid payload_type: {result['payload_type']}"

    def test_bypass_engine_hardware_id_spoof_no_network_communication(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify HARDWARE_ID_SPOOF payload contains no network communication code.

        Tests that the hardware ID spoofing payload (used for dongle emulation)
        does not include network communication code to connect to remote dongles
        or license servers.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        result = bypass_engine.generate_payload(
            payload_type=PayloadType.HARDWARE_ID_SPOOF,
            architecture="x64",
            target_info=target_info,
            options={"spoofed_hwid": b"\x11\x22\x33\x44\x55\x66\x77\x88\x99\xAA\xBB\xCC\xDD\xEE\xFF\x00"},
        )

        payload = result["payload"]

        forbidden_network_instructions = [
            b"\x48\x83\xEC",
            b"\xFF\x15",
        ]

        assert payload, "HARDWARE_ID_SPOOF generated empty payload"

        spoofed_hwid = b"\x11\x22\x33\x44\x55\x66\x77\x88\x99\xAA\xBB\xCC\xDD\xEE\xFF\x00"
        assert spoofed_hwid in payload, (
            "HARDWARE_ID_SPOOF payload should contain the spoofed hardware ID bytes"
        )

    def test_payload_type_string_conversion_only_accepts_valid_license_types(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Verify string-to-PayloadType conversion only accepts valid license types.

        Tests that attempting to convert shell-related payload type strings
        fails gracefully and defaults to LICENSE_CHECK_BYPASS.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info: dict[str, Any] = {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": [],
            "av_products": [],
        }

        valid_strings = [
            "LICENSE_CHECK_BYPASS",
            "TRIAL_EXTENSION",
            "ACTIVATION_BYPASS",
            "SERIAL_VALIDATION_BYPASS",
            "HARDWARE_ID_SPOOF",
        ]

        for valid_string in valid_strings:
            result = bypass_engine.generate_payload(
                payload_type=valid_string,
                architecture="x64",
                target_info=target_info,
                options={},
            )

            expected_type = valid_string.lower()
            assert result["payload_type"] == expected_type, (
                f"String '{valid_string}' should convert to payload_type '{expected_type}', "
                f"got '{result['payload_type']}'"
            )

        invalid_strings = ["REVERSE_SHELL", "BIND_SHELL", "invalid", "shell"]

        for invalid_string in invalid_strings:
            result = bypass_engine.generate_payload(
                payload_type=invalid_string,
                architecture="x64",
                target_info=target_info,
                options={},
            )

            assert result["payload_type"] == "license_check_bypass", (
                f"Invalid string '{invalid_string}' should default to 'license_check_bypass', "
                f"got '{result['payload_type']}'"
            )

    def test_bypass_engine_class_attributes_no_shell_references(self, bypass_engine: BypassEngine) -> None:
        """Verify BypassEngine class has no shell-related instance attributes.

        Tests that the BypassEngine class instance does not contain any
        attributes related to shell payloads, network connections, or
        reverse/bind configurations.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        instance_attrs = dir(bypass_engine)

        forbidden_attrs = [
            "shell_config",
            "reverse_shell",
            "bind_shell",
            "network_config",
            "lhost",
            "lport",
            "connect_back",
            "listener",
        ]

        for forbidden_attr in forbidden_attrs:
            assert forbidden_attr not in instance_attrs, (
                f"BypassEngine instance contains forbidden attribute '{forbidden_attr}'. "
                f"Class should not have shell-related attributes."
            )

    def test_bypass_engine_exported_symbols_only_license_bypass(self) -> None:
        """Verify __all__ exports only BypassEngine and PayloadType.

        Tests that the bypass_engine module's __all__ list contains only
        the BypassEngine class and PayloadType enum, with no shell-related
        exports.

        """
        from intellicrack.core.exploitation.bypass_engine import __all__

        expected_exports = {"BypassEngine", "PayloadType"}
        actual_exports = set(__all__)

        assert actual_exports == expected_exports, (
            f"bypass_engine.__all__ contains unexpected exports. "
            f"Expected: {expected_exports}, Got: {actual_exports}"
        )


class TestBypassEngineFunctionalityRegression:
    """Regression tests verifying that legitimate license bypass functionality still works.

    These tests ensure that after scope cleanup, all legitimate license bypass
    capabilities continue to function correctly for all architectures and payload types.
    """

    @pytest.fixture
    def bypass_engine(self) -> BypassEngine:
        """Create bypass engine instance for testing.

        Returns:
            Initialized BypassEngine instance.
        """
        return BypassEngine()

    @pytest.fixture
    def standard_target_info(self) -> dict[str, Any]:
        """Create standard target info for testing.

        Returns:
            Dictionary containing standard Windows target configuration.
        """
        return {
            "os_type": "windows",
            "os_version": "10",
            "architecture": "x64",
            "protections": ["aslr", "dep", "cfg"],
            "av_products": [],
            "network_config": {},
            "process_info": {},
        }

    def test_license_check_bypass_x64_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """LICENSE_CHECK_BYPASS generates valid x64 shellcode with proper return instruction.

        Regression test ensuring x64 license check bypass generation still works
        after scope cleanup removed shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"return_value": 1, "preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "x64 LICENSE_CHECK_BYPASS generated empty payload"
        assert isinstance(payload, bytes), "Payload must be bytes type"

        expected_instructions = [
            b"\x55",
            b"\x48\x89\xe5",
            b"\x48\xc7\xc0",
            b"\xc3",
        ]

        for instruction in expected_instructions:
            assert instruction in payload, (
                f"x64 LICENSE_CHECK_BYPASS missing expected instruction: {instruction.hex()}"
            )

        return_value_bytes = struct.pack("<I", 1)
        assert return_value_bytes in payload, "Payload missing return value encoding"

        assert result["architecture"] == "x64"
        assert result["payload_type"] == "license_check_bypass"
        assert result["size"] == len(payload)

    def test_license_check_bypass_x86_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """LICENSE_CHECK_BYPASS generates valid x86 shellcode with proper return instruction.

        Regression test ensuring x86 license check bypass generation still works
        after scope cleanup removed shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x86",
            target_info=standard_target_info,
            options={"return_value": 1, "preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "x86 LICENSE_CHECK_BYPASS generated empty payload"

        expected_instructions = [
            b"\x55",
            b"\x89\xe5",
            b"\xb8",
            b"\xc3",
        ]

        for instruction in expected_instructions:
            assert instruction in payload, (
                f"x86 LICENSE_CHECK_BYPASS missing expected instruction: {instruction.hex()}"
            )

        return_value_bytes = struct.pack("<I", 1)
        assert return_value_bytes in payload, "Payload missing return value encoding"

        assert result["architecture"] == "x86"
        assert result["payload_type"] == "license_check_bypass"

    def test_license_check_bypass_arm64_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """LICENSE_CHECK_BYPASS generates valid ARM64 shellcode with proper return instruction.

        Regression test ensuring ARM64 license check bypass generation still works
        after scope cleanup removed shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="arm64",
            target_info=standard_target_info,
            options={"return_value": 1, "preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "ARM64 LICENSE_CHECK_BYPASS generated empty payload"
        assert len(payload) % 4 == 0, "ARM64 payload must be 4-byte aligned"

        expected_arm64_ret = b"\xc0\x03\x5f\xd6"
        assert expected_arm64_ret in payload, "ARM64 payload missing RET instruction"

        assert result["architecture"] == "arm64"
        assert result["payload_type"] == "license_check_bypass"

    def test_license_check_bypass_arm_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """LICENSE_CHECK_BYPASS generates valid ARM32 shellcode with proper return instruction.

        Regression test ensuring ARM32 license check bypass generation still works
        after scope cleanup removed shell payloads.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="arm",
            target_info=standard_target_info,
            options={"return_value": 1, "preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "ARM LICENSE_CHECK_BYPASS generated empty payload"
        assert len(payload) % 4 == 0, "ARM payload must be 4-byte aligned"

        assert result["architecture"] == "arm"
        assert result["payload_type"] == "license_check_bypass"

    def test_trial_extension_generates_large_return_value(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """TRIAL_EXTENSION generates shellcode with maximum trial period value.

        Regression test ensuring trial extension payload still works after scope cleanup.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.TRIAL_EXTENSION,
            architecture="x64",
            target_info=standard_target_info,
            options={"preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "TRIAL_EXTENSION generated empty payload"

        max_trial_value = struct.pack("<I", 0x7FFFFFFF)
        assert max_trial_value in payload, (
            "TRIAL_EXTENSION payload should contain maximum trial period value (0x7FFFFFFF)"
        )

        assert result["payload_type"] == "trial_extension"

    def test_activation_bypass_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """ACTIVATION_BYPASS generates valid activation check bypass shellcode.

        Regression test ensuring activation bypass payload still works after scope cleanup.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.ACTIVATION_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "ACTIVATION_BYPASS generated empty payload"

        assert b"\x48\xc7\xc0" in payload, "ACTIVATION_BYPASS missing x64 MOV RAX instruction"
        assert b"\xc3" in payload, "ACTIVATION_BYPASS missing RET instruction"

        assert result["payload_type"] == "activation_bypass"

    def test_serial_validation_bypass_generates_valid_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """SERIAL_VALIDATION_BYPASS generates valid serial check bypass shellcode.

        Regression test ensuring serial validation bypass payload still works after scope cleanup.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.SERIAL_VALIDATION_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"preserve_stack": True},
        )

        payload = result["payload"]

        assert len(payload) > 0, "SERIAL_VALIDATION_BYPASS generated empty payload"

        assert result["payload_type"] == "serial_validation_bypass"

    def test_hardware_id_spoof_generates_dongle_emulation_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """HARDWARE_ID_SPOOF generates dongle emulation shellcode with embedded HWID.

        Regression test ensuring hardware ID spoofing payload still works after scope cleanup.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        custom_hwid = b"\xDE\xAD\xBE\xEF" * 4

        result = bypass_engine.generate_payload(
            payload_type=PayloadType.HARDWARE_ID_SPOOF,
            architecture="x64",
            target_info=standard_target_info,
            options={"spoofed_hwid": custom_hwid},
        )

        payload = result["payload"]

        assert len(payload) > 0, "HARDWARE_ID_SPOOF generated empty payload"

        assert custom_hwid in payload, (
            "HARDWARE_ID_SPOOF payload should contain embedded spoofed hardware ID"
        )

        assert result["payload_type"] == "hardware_id_spoof"

    def test_payload_formatting_c_array_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload formatting to C array format still works after scope cleanup.

        Regression test ensuring C array output format functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"output_format": "c", "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "C formatted payload is empty"

        payload_str = payload.decode("utf-8")
        assert "unsigned char payload[]" in payload_str, "C array format missing declaration"
        assert "0x" in payload_str, "C array format missing hex byte values"

    def test_payload_formatting_python_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload formatting to Python bytes format still works after scope cleanup.

        Regression test ensuring Python output format functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"output_format": "python", "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "Python formatted payload is empty"

        payload_str = payload.decode("utf-8")
        assert "payload = bytes.fromhex" in payload_str, "Python format missing bytes.fromhex call"

    def test_payload_formatting_powershell_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload formatting to PowerShell byte array format still works after scope cleanup.

        Regression test ensuring PowerShell output format functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"output_format": "powershell", "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "PowerShell formatted payload is empty"

        payload_str = payload.decode("utf-8")
        assert "[Byte[]]$payload" in payload_str, "PowerShell format missing byte array declaration"
        assert "0x" in payload_str, "PowerShell format missing hex byte values"

    def test_payload_formatting_pe_exe_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload formatting to PE executable format still works after scope cleanup.

        Regression test ensuring PE executable wrapping functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"output_format": "exe", "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "PE EXE formatted payload is empty"
        assert payload[:2] == b"MZ", "PE EXE payload missing DOS header MZ signature"
        assert b"PE\x00\x00" in payload, "PE EXE payload missing PE signature"

        assert len(payload) >= 0x200, "PE EXE payload too small (missing headers/sections)"

    def test_payload_formatting_pe_dll_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload formatting to PE DLL format still works after scope cleanup.

        Regression test ensuring PE DLL wrapping functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"output_format": "dll", "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "PE DLL formatted payload is empty"
        assert payload[:2] == b"MZ", "PE DLL payload missing DOS header MZ signature"
        assert b"PE\x00\x00" in payload, "PE DLL payload missing PE signature"

    def test_payload_encoding_base64_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload base64 encoding still works after scope cleanup.

        Regression test ensuring base64 encoding functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"encoding_schemes": ["base64"], "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "Base64 encoded payload is empty"

        import base64

        try:
            decoded = base64.b64decode(payload)
            assert len(decoded) > 0, "Base64 decoded payload is empty"
        except Exception as e:
            pytest.fail(f"Failed to decode base64 payload: {e}")

    def test_payload_encoding_null_free_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload null-free encoding still works after scope cleanup.

        Regression test ensuring null-free encoding functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"encoding_schemes": ["null_free"], "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "Null-free encoded payload is empty"

    def test_payload_encoding_xor_works(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload XOR encoding still works after scope cleanup.

        Regression test ensuring XOR encoding functionality remains intact.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"encoding_schemes": ["xor"], "preserve_stack": False},
        )

        payload = result["payload"]

        assert len(payload) > 0, "XOR encoded payload is empty"

    def test_bypass_capabilities_analysis_works(
        self, bypass_engine: BypassEngine
    ) -> None:
        """Bypass capabilities analysis still works after scope cleanup.

        Regression test ensuring analyze_bypass_capabilities method remains functional.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": True,
            "cet_enabled": False,
        }

        result = bypass_engine.analyze_bypass_capabilities(target_info)

        assert "bypasses_available" in result
        assert "target_info" in result
        assert "bypass_count" in result

        assert isinstance(result["bypasses_available"], list)
        assert result["bypass_count"] == len(result["bypasses_available"])

    def test_get_available_bypasses_returns_mitigation_bypasses(
        self, bypass_engine: BypassEngine
    ) -> None:
        """get_available_bypasses returns only exploit mitigation bypasses.

        Regression test ensuring bypass type listing remains functional and scoped.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        available = bypass_engine.get_available_bypasses()

        assert isinstance(available, list)
        assert len(available) > 0

        expected_bypasses = {"aslr_bypass", "dep_bypass", "cfi_bypass", "cfg_bypass", "cet_bypass"}
        assert set(available) == expected_bypasses

    def test_get_bypass_info_returns_detailed_information(
        self, bypass_engine: BypassEngine
    ) -> None:
        """get_bypass_info returns detailed bypass technique information.

        Regression test ensuring bypass info retrieval remains functional.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        info = bypass_engine.get_bypass_info("aslr_bypass")

        assert "description" in info
        assert "target_protection" in info
        assert "difficulty" in info
        assert "reliability" in info

        assert isinstance(info["description"], str)
        assert len(info["description"]) > 0

    def test_get_recommended_bypasses_filters_by_reliability(
        self, bypass_engine: BypassEngine
    ) -> None:
        """get_recommended_bypasses correctly filters bypasses by reliability threshold.

        Regression test ensuring recommended bypass selection remains functional.

        Args:
            bypass_engine: Initialized BypassEngine instance.
        """
        target_info = {
            "aslr_enabled": True,
            "dep_enabled": True,
            "cfi_enabled": False,
            "cfg_enabled": False,
            "cet_enabled": False,
        }

        recommended = bypass_engine.get_recommended_bypasses(target_info, min_reliability=7)

        assert isinstance(recommended, list)

        for bypass_type in recommended:
            info = bypass_engine.get_bypass_info(bypass_type)
            assert info["reliability"] >= 7, (
                f"Bypass {bypass_type} has reliability {info['reliability']} < 7"
            )

    def test_payload_metadata_contains_correct_information(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Payload generation includes correct metadata after scope cleanup.

        Regression test ensuring metadata generation remains functional.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"encoding_schemes": ["xor"], "output_format": "python"},
        )

        assert "metadata" in result
        assert "encoding_applied" in result["metadata"]
        assert "output_format" in result["metadata"]
        assert "target_os" in result["metadata"]

        assert result["metadata"]["encoding_applied"] == ["xor"]
        assert result["metadata"]["output_format"] == "python"
        assert result["metadata"]["target_os"] == "windows"

    def test_preserve_stack_false_generates_minimal_shellcode(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """preserve_stack=False generates minimal shellcode without prologue/epilogue.

        Regression test ensuring stack preservation option still works.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        result_with_stack = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"preserve_stack": True, "return_value": 1},
        )

        result_without_stack = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"preserve_stack": False, "return_value": 1},
        )

        payload_with_stack = result_with_stack["payload"]
        payload_without_stack = result_without_stack["payload"]

        assert len(payload_with_stack) > len(payload_without_stack), (
            "Payload with stack preservation should be larger than minimal payload"
        )

        assert b"\x55" in payload_with_stack, "Stack-preserving payload missing PUSH RBP"
        assert b"\x55" not in payload_without_stack, "Minimal payload should not contain PUSH RBP"

    def test_custom_return_value_correctly_encoded(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """Custom return values are correctly encoded in generated shellcode.

        Regression test ensuring return value customization still works.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        custom_return_value = 0x12345678

        result = bypass_engine.generate_payload(
            payload_type=PayloadType.LICENSE_CHECK_BYPASS,
            architecture="x64",
            target_info=standard_target_info,
            options={"return_value": custom_return_value, "preserve_stack": False},
        )

        payload = result["payload"]

        return_value_bytes = struct.pack("<I", custom_return_value)
        assert return_value_bytes in payload, (
            f"Payload should contain custom return value 0x{custom_return_value:08x}"
        )

    def test_all_architectures_support_all_payload_types(
        self, bypass_engine: BypassEngine, standard_target_info: dict[str, Any]
    ) -> None:
        """All payload types work for all supported architectures.

        Comprehensive regression test ensuring cross-architecture compatibility.

        Args:
            bypass_engine: Initialized BypassEngine instance.
            standard_target_info: Standard target configuration.
        """
        architectures = ["x86", "x64", "arm", "arm64"]
        payload_types = list(PayloadType)

        for arch in architectures:
            for payload_type in payload_types:
                result = bypass_engine.generate_payload(
                    payload_type=payload_type,
                    architecture=arch,
                    target_info=standard_target_info,
                    options={"preserve_stack": True},
                )

                assert result["payload"], (
                    f"Empty payload generated for {arch} / {payload_type.name}"
                )
                assert result["size"] > 0, (
                    f"Zero-size payload for {arch} / {payload_type.name}"
                )
                assert result["architecture"] == arch, (
                    f"Architecture mismatch for {arch} / {payload_type.name}"
                )
