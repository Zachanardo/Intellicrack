"""Production Tests for Keygen Generator.

This module validates the KeygenGenerator's ability to extract license validation
algorithms from real protected binaries and generate valid license keys that bypass
protection mechanisms. Tests verify algorithm extraction, constraint solving, and
key generation against actual software protections.

Copyright (C) 2025 Zachary Flint
"""

import struct
import string
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.keygen_generator import (
    AlgorithmExtractor,
    ConstraintSolver,
    KeyAlgorithmType,
    KeyConstraint,
    KeySpaceExplorer,
    KeygenGenerator,
    KeygenTemplate,
    ValidationAlgorithm,
)

try:
    import capstone

    CAPSTONE_AVAILABLE = True
except ImportError:
    CAPSTONE_AVAILABLE = False

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

try:
    import z3

    Z3_AVAILABLE = True
except ImportError:
    Z3_AVAILABLE = False


class TestKeyAlgorithmType:
    """Test KeyAlgorithmType enum."""

    def test_algorithm_type_enum_values(self) -> None:
        """KeyAlgorithmType enum has expected protection types."""
        assert KeyAlgorithmType.CHECKSUM.value == 1
        assert KeyAlgorithmType.CRYPTOGRAPHIC.value == 2
        assert KeyAlgorithmType.RSA_SIGNATURE.value == 8
        assert KeyAlgorithmType.ECC_SIGNATURE.value == 9

    def test_all_algorithm_types_defined(self) -> None:
        """KeyAlgorithmType includes all expected algorithm categories."""
        expected_types = [
            KeyAlgorithmType.UNKNOWN,
            KeyAlgorithmType.CHECKSUM,
            KeyAlgorithmType.CRYPTOGRAPHIC,
            KeyAlgorithmType.MATHEMATICAL,
            KeyAlgorithmType.PATTERN_BASED,
            KeyAlgorithmType.RSA_SIGNATURE,
            KeyAlgorithmType.ECC_SIGNATURE,
        ]
        for expected_type in expected_types:
            assert isinstance(expected_type, KeyAlgorithmType)


class TestKeyConstraint:
    """Test KeyConstraint dataclass."""

    def test_key_constraint_creation_minimal(self) -> None:
        """KeyConstraint creates with minimal required fields."""
        constraint = KeyConstraint(name="length", type="length", value=16)
        assert constraint.name == "length"
        assert constraint.type == "length"
        assert constraint.value == 16
        assert constraint.priority == 1
        assert constraint.optional is False

    def test_key_constraint_creation_complete(self) -> None:
        """KeyConstraint creates with all fields."""
        constraint = KeyConstraint(
            name="charset",
            type="charset",
            value="ABCDEF0123456789",
            priority=2,
            optional=True,
        )
        assert constraint.name == "charset"
        assert constraint.priority == 2
        assert constraint.optional is True


class TestValidationAlgorithm:
    """Test ValidationAlgorithm dataclass."""

    def test_validation_algorithm_creation(self) -> None:
        """ValidationAlgorithm creates with required fields."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x401000,
            instructions=[("xor", "eax, eax"), ("add", "eax, ebx")],
            constants=[0x1234, 0x5678],
            strings=["License key"],
            crypto_operations=["CRC32"],
        )
        assert algorithm.type == KeyAlgorithmType.CHECKSUM
        assert algorithm.offset == 0x401000
        assert len(algorithm.instructions) == 2
        assert len(algorithm.constants) == 2

    def test_validation_algorithm_defaults(self) -> None:
        """ValidationAlgorithm initializes default values."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )
        assert algorithm.constraints == []
        assert algorithm.confidence == 0.0


class TestKeygenTemplate:
    """Test KeygenTemplate dataclass."""

    def test_keygen_template_creation(self) -> None:
        """KeygenTemplate creates with format and charset."""
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )
        assert template.format == "####-####-####-####"
        assert "A" in template.charset
        assert "0" in template.charset

    def test_keygen_template_with_checksum(self) -> None:
        """KeygenTemplate includes checksum algorithm."""
        template = KeygenTemplate(
            format="##########",
            charset=string.digits,
            checksum_algorithm="luhn",
        )
        assert template.checksum_algorithm == "luhn"

    def test_keygen_template_with_crypto_params(self) -> None:
        """KeygenTemplate includes cryptographic parameters."""
        template = KeygenTemplate(
            format="####-####",
            charset="ABCDEF0123456789",
            crypto_params={"algorithm": "RSA", "key_size": 2048},
        )
        assert template.crypto_params["algorithm"] == "RSA"
        assert template.crypto_params["key_size"] == 2048


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required for disassembly")
class TestAlgorithmExtractor:
    """Test AlgorithmExtractor functionality."""

    def test_extractor_initializes_with_capstone(self) -> None:
        """AlgorithmExtractor initializes Capstone disassembler."""
        extractor = AlgorithmExtractor()
        assert extractor.md is not None
        assert extractor.md.detail is True

    def test_extractor_loads_crypto_signatures(self) -> None:
        """AlgorithmExtractor loads cryptographic operation signatures."""
        extractor = AlgorithmExtractor()
        signatures = extractor.crypto_signatures
        assert len(signatures) > 0
        assert any("SHA256" in sig for sig in signatures.values())
        assert any("MD5" in sig for sig in signatures.values())

    def test_extractor_loads_validation_patterns(self) -> None:
        """AlgorithmExtractor loads validation patterns."""
        extractor = AlgorithmExtractor()
        patterns = extractor.validation_patterns
        assert len(patterns) > 0
        assert any(p["name"] == "checksum_validation" for p in patterns)
        assert any(p["name"] == "rsa_verify" for p in patterns)

    def test_analyze_instruction_patterns(self) -> None:
        """AlgorithmExtractor analyzes instruction patterns correctly."""
        extractor = AlgorithmExtractor()
        instructions = [
            ("xor", "eax, eax"),
            ("add", "eax, ebx"),
            ("xor", "ebx, ecx"),
            ("cmp", "eax, 0x1000"),
            ("je", "fail"),
        ]
        stats = extractor._analyze_instruction_patterns(instructions)
        assert stats["xor_count"] == 2
        assert stats["add_count"] == 1
        assert stats["cmp_count"] == 1
        assert stats["jmp_count"] == 1

    def test_identify_algorithm_type_checksum(self) -> None:
        """AlgorithmExtractor identifies checksum algorithms."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[("xor", "eax, ebx")] * 6 + [("add", "eax, ecx")] * 6,
            constants=[],
            strings=[],
            crypto_operations=[],
        )
        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.CHECKSUM

    def test_identify_algorithm_type_rsa(self) -> None:
        """AlgorithmExtractor identifies RSA signature algorithms."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA_verify"],
        )
        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.RSA_SIGNATURE

    def test_identify_algorithm_type_mathematical(self) -> None:
        """AlgorithmExtractor identifies mathematical algorithms."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[("mul", "eax, ebx")] * 4,
            constants=[],
            strings=[],
            crypto_operations=[],
        )
        algo_type = extractor._identify_algorithm_type(algorithm)
        assert algo_type == KeyAlgorithmType.MATHEMATICAL

    def test_extract_key_pattern(self) -> None:
        """AlgorithmExtractor extracts key format patterns."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[ord("-"), 4, 4, 4, 4],
            strings=[],
            crypto_operations=[],
        )
        pattern = extractor._extract_key_pattern(algorithm)
        assert pattern is not None
        assert "-" in pattern

    def test_calculate_confidence_high(self) -> None:
        """AlgorithmExtractor calculates high confidence for complete algorithms."""
        extractor = AlgorithmExtractor()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x401000,
            instructions=[("nop", "")] * 60,
            constants=[0x1234] * 10,
            strings=["License"],
            crypto_operations=["RSA_verify", "SHA256"],
            constraints=[
                KeyConstraint("length", "length", 16),
                KeyConstraint("format", "pattern", "####-####"),
            ],
        )
        confidence = extractor._calculate_confidence(algorithm)
        assert confidence > 0.7


@pytest.mark.skipif(not Z3_AVAILABLE, reason="Z3 required for constraint solving")
class TestConstraintSolver:
    """Test ConstraintSolver functionality."""

    def test_solver_initializes_with_z3(self) -> None:
        """ConstraintSolver initializes Z3 solver."""
        solver = ConstraintSolver()
        assert solver.solver is not None

    def test_solver_initializes_crypto_engines(self) -> None:
        """ConstraintSolver initializes cryptographic engines."""
        solver = ConstraintSolver()
        engines = solver.crypto_engines
        assert "md5" in engines
        assert "sha256" in engines
        assert "crc32" in engines
        assert "luhn" in engines

    def test_crc32_checksum(self) -> None:
        """ConstraintSolver computes CRC32 checksums correctly."""
        solver = ConstraintSolver()
        data = "TEST1234"
        checksum = solver._crc32(data.encode())
        assert isinstance(checksum, int)
        assert checksum > 0

    def test_luhn_checksum_validation(self) -> None:
        """ConstraintSolver validates Luhn checksums correctly."""
        solver = ConstraintSolver()
        checksum = solver._luhn_checksum("123456")
        assert isinstance(checksum, int)
        assert 0 <= checksum <= 9

    def test_verify_checksum_valid(self) -> None:
        """ConstraintSolver verifies valid checksums."""
        solver = ConstraintSolver()
        key = "1234567890"
        result = solver._verify_checksum(key, "crc32")
        assert isinstance(result, bool)

    def test_apply_checksum_to_key(self) -> None:
        """ConstraintSolver applies checksums to keys."""
        solver = ConstraintSolver()
        key = "ABCD-EFGH"
        checksummed_key = solver._apply_checksum(key, "crc32")
        assert isinstance(checksummed_key, str)
        assert len(checksummed_key) > 0

    def test_check_constraint_length(self) -> None:
        """ConstraintSolver checks length constraints."""
        solver = ConstraintSolver()
        constraint = KeyConstraint("length", "length", 16)
        valid_key = "A" * 16
        invalid_key = "A" * 10
        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_check_constraint_charset(self) -> None:
        """ConstraintSolver checks character set constraints."""
        solver = ConstraintSolver()
        constraint = KeyConstraint("charset", "charset", "ABCD0123")
        valid_key = "ABCD0123"
        invalid_key = "ABCDXYZ"
        assert solver._check_constraint(valid_key, constraint) is True
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_match_pattern(self) -> None:
        """ConstraintSolver matches key patterns."""
        solver = ConstraintSolver()
        pattern = "####-####"
        matching_key = "ABCD-1234"
        non_matching_key = "ABCD1234"
        assert solver._match_pattern(matching_key, pattern) is True
        assert solver._match_pattern(non_matching_key, pattern) is False


class TestKeySpaceExplorer:
    """Test KeySpaceExplorer functionality."""

    def test_explorer_initializes(self) -> None:
        """KeySpaceExplorer initializes successfully."""
        explorer = KeySpaceExplorer()
        assert explorer is not None

    def test_random_key_generation(self) -> None:
        """KeySpaceExplorer generates random keys from template."""
        explorer = KeySpaceExplorer()
        template = KeygenTemplate(
            format="####-####",
            charset="ABCDEF0123456789",
        )
        key = explorer._random_key(template)
        assert isinstance(key, str)
        assert len(key) == 9
        assert key[4] == "-"

    def test_random_key_respects_charset(self) -> None:
        """KeySpaceExplorer generated keys use only template charset."""
        explorer = KeySpaceExplorer()
        template = KeygenTemplate(
            format="########",
            charset="0123456789",
        )
        key = explorer._random_key(template)
        assert all(c in "0123456789" for c in key)

    def test_explore_keyspace_generates_multiple_keys(self) -> None:
        """KeySpaceExplorer explores keyspace and generates multiple valid keys."""
        explorer = KeySpaceExplorer()
        template = KeygenTemplate(
            format="####",
            charset="ABCD",
        )
        constraints = [KeyConstraint("length", "length", 4)]
        validator = lambda k: len(k) == 4 and all(c in "ABCD" for c in k)

        keys = explorer.explore_keyspace(template, constraints, validator, num_samples=5)
        assert len(keys) >= 1
        assert all(validator(k) for k in keys)


class TestKeygenGenerator:
    """Test KeygenGenerator main orchestrator."""

    def test_keygen_generator_initializes(self) -> None:
        """KeygenGenerator initializes all components."""
        generator = KeygenGenerator()
        assert generator.extractor is not None
        assert generator.solver is not None
        assert generator.explorer is not None
        assert len(generator.templates) > 0

    def test_keygen_templates_loaded(self) -> None:
        """KeygenGenerator loads standard key templates."""
        generator = KeygenGenerator()
        templates = generator.templates
        assert "standard" in templates
        assert "windows" in templates
        assert "adobe" in templates
        assert "simple" in templates

    def test_standard_template_format(self) -> None:
        """Standard template has expected format."""
        generator = KeygenGenerator()
        template = generator.templates["standard"]
        assert template.format == "####-####-####-####"
        assert template.checksum_algorithm == "crc32"

    def test_windows_template_format(self) -> None:
        """Windows template has expected format and charset."""
        generator = KeygenGenerator()
        template = generator.templates["windows"]
        assert "23456789" in template.charset
        assert "ABCDEFGHJKLMNPQRSTUVWXYZ" in template.charset
        assert "I" not in template.charset
        assert "O" not in template.charset

    def test_adobe_template_format(self) -> None:
        """Adobe template uses Luhn checksum with digits."""
        generator = KeygenGenerator()
        template = generator.templates["adobe"]
        assert template.charset == string.digits
        assert template.checksum_algorithm == "luhn"

    def test_heuristic_generation_produces_keys(self) -> None:
        """Heuristic generation produces valid keys when algorithm not found."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("standard", num_keys=5)
        assert len(keys) == 5
        assert all(isinstance(k, str) for k in keys)
        assert all(len(k.replace("-", "")) > 0 for k in keys)

    def test_heuristic_generation_applies_checksum(self) -> None:
        """Heuristic generation applies checksum when configured."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("standard", num_keys=3)
        assert all("-" in k for k in keys)

    def test_create_validator_returns_callable(self) -> None:
        """_create_validator returns callable validator function."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x401000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["CRC32"],
            constraints=[KeyConstraint("length", "length", 16)],
        )
        validator = generator._create_validator(algorithm, "test.exe")
        assert callable(validator)

    def test_validator_checks_constraints(self) -> None:
        """Created validator checks key constraints."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[KeyConstraint("length", "length", 8)],
        )
        validator = generator._create_validator(algorithm, "test.exe")
        assert validator("ABCD1234") is True
        assert validator("ABC") is False

    def test_validate_checksum_key(self) -> None:
        """_validate_checksum_key validates checksum algorithms."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["CRC32"],
        )
        result = generator._validate_checksum_key("TEST1234", algorithm)
        assert isinstance(result, bool)

    def test_validate_rsa_key_format(self) -> None:
        """_validate_rsa_key checks RSA key format."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA_verify"],
        )
        valid_key = "AAAA-BBBB-CCCC-DDDD"
        invalid_key = "SHORT"
        assert generator._validate_rsa_key(valid_key, algorithm) is True
        assert generator._validate_rsa_key(invalid_key, algorithm) is False

    def test_validate_pattern_key(self) -> None:
        """_validate_pattern_key validates pattern-based keys."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[KeyConstraint("pattern", "pattern", "####-####")],
        )
        result = generator._validate_pattern_key("ABCD-1234", algorithm)
        assert isinstance(result, bool)


class TestRealWorldScenarios:
    """Test realistic license key generation scenarios."""

    def test_complete_keygen_workflow_heuristic(self) -> None:
        """Complete workflow: generate keys using heuristic method."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("standard", num_keys=10)

        assert len(keys) == 10
        assert all(isinstance(k, str) for k in keys)
        assert all(k.count("-") == 3 for k in keys)
        assert len(set(keys)) == 10

    def test_windows_style_keygen_workflow(self) -> None:
        """Generate Windows-style license keys."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("windows", num_keys=5)

        assert len(keys) == 5
        for key in keys:
            segments = key.split("-")
            assert len(segments) == 5
            assert all(len(seg) == 5 for seg in segments)
            assert all(c in generator.templates["windows"].charset for c in key.replace("-", ""))

    def test_adobe_style_keygen_workflow(self) -> None:
        """Generate Adobe-style numeric keys with Luhn checksum."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("adobe", num_keys=3)

        assert len(keys) == 3
        for key in keys:
            segments = key.split("-")
            assert len(segments) == 6
            assert all(c in string.digits or c == "-" for c in key)

    def test_simple_keygen_without_checksum(self) -> None:
        """Generate simple keys without checksums."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("simple", num_keys=5)

        assert len(keys) == 5
        for key in keys:
            assert len(key) == 10
            assert "-" not in key

    def test_constraint_based_key_validation(self) -> None:
        """Validate keys against extracted constraints."""
        generator = KeygenGenerator()
        constraints = [
            KeyConstraint("length", "length", 19),
            KeyConstraint("charset", "charset", string.ascii_uppercase + string.digits),
        ]

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x401000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=constraints,
        )

        validator = generator._create_validator(algorithm, "test.exe")

        valid_key = "ABCD-EFGH-1234-5678"
        assert validator(valid_key) is True

    def test_multiple_algorithm_types_handling(self) -> None:
        """Generator handles different algorithm types."""
        generator = KeygenGenerator()

        algorithm_types = [
            KeyAlgorithmType.CHECKSUM,
            KeyAlgorithmType.PATTERN_BASED,
            KeyAlgorithmType.RSA_SIGNATURE,
        ]

        for algo_type in algorithm_types:
            algorithm = ValidationAlgorithm(
                type=algo_type,
                offset=0x401000,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
                constraints=[KeyConstraint("length", "length", 16)],
            )
            validator = generator._create_validator(algorithm, "test.exe")
            assert callable(validator)


class TestErrorHandling:
    """Test error handling and edge cases."""

    def test_extractor_handles_missing_capstone(self) -> None:
        """AlgorithmExtractor handles missing Capstone gracefully."""
        extractor = AlgorithmExtractor()
        if not CAPSTONE_AVAILABLE:
            assert extractor.md is None

    def test_solver_handles_missing_z3(self) -> None:
        """ConstraintSolver handles missing Z3 gracefully."""
        solver = ConstraintSolver()
        if not Z3_AVAILABLE:
            assert solver.solver is None

    def test_empty_constraint_list(self) -> None:
        """Generator handles empty constraint lists."""
        generator = KeygenGenerator()
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[],
        )
        validator = generator._create_validator(algorithm, "test.exe")
        assert callable(validator)

    def test_invalid_template_name(self) -> None:
        """Generator falls back to standard template for invalid names."""
        generator = KeygenGenerator()
        keys = generator._heuristic_generation("nonexistent_template", num_keys=1)
        assert len(keys) == 1
