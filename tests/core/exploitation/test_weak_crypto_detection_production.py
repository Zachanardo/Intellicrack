"""Production Tests for Weak Crypto Detection in Keygen Generator.

This module validates the AlgorithmExtractor's ability to detect weak cryptographic
implementations in license validation code. Tests verify detection of weak algorithms,
short keys, hardcoded secrets, magic numbers, and cryptographic vulnerabilities in
real binaries with actual licensing protections.

All tests validate genuine offensive capability - tests MUST fail if detection does
not work on real cryptographic weaknesses.

Copyright (C) 2025 Zachary Flint
"""

from __future__ import annotations

import hashlib
import struct
from dataclasses import dataclass
from enum import IntEnum
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.keygen_generator import (
    AlgorithmExtractor,
    KeyAlgorithmType,
    ValidationAlgorithm,
)

try:
    import capstone

    CAPSTONE_AVAILABLE = True
except ImportError:
    CAPSTONE_AVAILABLE = False

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False


class CryptoWeaknessSeverity(IntEnum):
    """Severity levels for cryptographic weaknesses."""

    CRITICAL = 4
    HIGH = 3
    MEDIUM = 2
    LOW = 1
    INFO = 0


@dataclass
class CryptoWeakness:
    """Detected cryptographic weakness in binary."""

    weakness_type: str
    severity: CryptoWeaknessSeverity
    description: str
    offset: int
    evidence: dict[str, Any]


class WeakCryptoDetector:
    """Detects weak cryptographic implementations in validation algorithms.

    Analyzes disassembled validation code to identify cryptographic vulnerabilities
    including weak algorithms, short keys, hardcoded secrets, and insecure constants.
    """

    CRYPTO_CONSTANTS = {
        b"\x67\xe6\x09\x6a": ("SHA256_K0", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x85\xae\x67\xbb": ("SHA256_K1", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x72\xf3\x6e\x3c": ("SHA256_K2", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x3a\xf5\x4f\xa5": ("SHA256_K3", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x78\xa4\x6a\xd7": ("MD5_T0", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x56\xb7\xc7\xe8": ("MD5_T1", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\xdb\x70\x20\x24": ("MD5_T2", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\xee\xce\xbd\xc1": ("MD5_T3", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\x63\x7c\x77\x7b": ("AES_SBOX_START", KeyAlgorithmType.SYMMETRIC_CRYPTO),
        b"\xdb\x71\x06\x41": ("CRC32_POLY", KeyAlgorithmType.CHECKSUM),
        b"\x04\xc1\x1d\xb7": ("CRC32_POLY_REV", KeyAlgorithmType.CHECKSUM),
        b"\x01\x23\x45\x67": ("DES_CONSTANT", KeyAlgorithmType.SYMMETRIC_CRYPTO),
        b"\x89\xab\xcd\xef": ("MD5_INIT_A", KeyAlgorithmType.CRYPTOGRAPHIC),
        b"\xfe\xdc\xba\x98": ("MD5_INIT_B", KeyAlgorithmType.CRYPTOGRAPHIC),
    }

    WEAK_ALGORITHMS = {
        "MD5": CryptoWeaknessSeverity.HIGH,
        "MD4": CryptoWeaknessSeverity.CRITICAL,
        "SHA1": CryptoWeaknessSeverity.MEDIUM,
        "DES": CryptoWeaknessSeverity.CRITICAL,
        "3DES": CryptoWeaknessSeverity.HIGH,
        "RC4": CryptoWeaknessSeverity.CRITICAL,
        "RC2": CryptoWeaknessSeverity.CRITICAL,
    }

    WEAK_KEY_LENGTHS = {
        "RSA": {512: CryptoWeaknessSeverity.CRITICAL, 1024: CryptoWeaknessSeverity.HIGH},
        "AES": {64: CryptoWeaknessSeverity.CRITICAL, 128: CryptoWeaknessSeverity.LOW},
        "DES": {56: CryptoWeaknessSeverity.CRITICAL},
    }

    COMMON_HARDCODED_KEYS = [
        b"0123456789ABCDEF",
        b"password",
        b"secret",
        b"default",
        b"12345678",
        b"\x00\x00\x00\x00\x00\x00\x00\x00",
        b"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
    ]

    def __init__(self) -> None:
        """Initialize weak crypto detector."""
        if CAPSTONE_AVAILABLE:
            self.md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            self.md.detail = True
        else:
            self.md = None

    def detect_weak_crypto(
        self,
        algorithm: ValidationAlgorithm,
        binary_data: bytes | None = None,
    ) -> list[CryptoWeakness]:
        """Detect cryptographic weaknesses in validation algorithm.

        Args:
            algorithm: Extracted validation algorithm to analyze.
            binary_data: Optional raw binary data for additional analysis.

        Returns:
            List of detected cryptographic weaknesses with severity levels.
        """
        weaknesses: list[CryptoWeakness] = []

        weaknesses.extend(self._detect_weak_algorithms(algorithm))
        weaknesses.extend(self._detect_weak_key_lengths(algorithm))
        weaknesses.extend(self._detect_hardcoded_secrets(algorithm, binary_data))
        weaknesses.extend(self._detect_magic_numbers(algorithm))
        weaknesses.extend(self._detect_weak_ivs(algorithm))

        return weaknesses

    def _detect_weak_algorithms(self, algorithm: ValidationAlgorithm) -> list[CryptoWeakness]:
        """Detect use of weak cryptographic algorithms.

        Args:
            algorithm: Validation algorithm to analyze.

        Returns:
            List of weaknesses for insecure algorithm usage.
        """
        weaknesses: list[CryptoWeakness] = []

        for crypto_op in algorithm.crypto_operations:
            for weak_alg, severity in self.WEAK_ALGORITHMS.items():
                if weak_alg in crypto_op.upper():
                    weaknesses.append(
                        CryptoWeakness(
                            weakness_type="WEAK_ALGORITHM",
                            severity=severity,
                            description=f"Use of weak cryptographic algorithm: {weak_alg}",
                            offset=algorithm.offset,
                            evidence={
                                "algorithm": weak_alg,
                                "operation": crypto_op,
                                "replacement": self._suggest_replacement(weak_alg),
                            },
                        ),
                    )

        return weaknesses

    def _detect_weak_key_lengths(self, algorithm: ValidationAlgorithm) -> list[CryptoWeakness]:
        """Detect weak key lengths in cryptographic operations.

        Args:
            algorithm: Validation algorithm to analyze.

        Returns:
            List of weaknesses for insufficient key lengths.
        """
        weaknesses: list[CryptoWeakness] = []

        for const in algorithm.constants:
            for alg_type, weak_lengths in self.WEAK_KEY_LENGTHS.items():
                if const in weak_lengths:
                    weaknesses.append(
                        CryptoWeakness(
                            weakness_type="WEAK_KEY_LENGTH",
                            severity=weak_lengths[const],
                            description=f"Weak {alg_type} key length: {const} bits",
                            offset=algorithm.offset,
                            evidence={
                                "algorithm": alg_type,
                                "key_length": const,
                                "minimum_recommended": 2048 if alg_type == "RSA" else 256,
                            },
                        ),
                    )

        if algorithm.type == KeyAlgorithmType.RSA_SIGNATURE:
            rsa_modulus_length = self._estimate_rsa_modulus_length(algorithm)
            if rsa_modulus_length and rsa_modulus_length < 2048:
                severity = CryptoWeaknessSeverity.CRITICAL if rsa_modulus_length <= 512 else CryptoWeaknessSeverity.HIGH
                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="WEAK_KEY_LENGTH",
                        severity=severity,
                        description=f"Weak RSA modulus: {rsa_modulus_length} bits",
                        offset=algorithm.offset,
                        evidence={"key_length": rsa_modulus_length, "minimum_recommended": 2048},
                    ),
                )

        return weaknesses

    def _detect_hardcoded_secrets(
        self,
        algorithm: ValidationAlgorithm,
        binary_data: bytes | None,
    ) -> list[CryptoWeakness]:
        """Detect hardcoded cryptographic keys and secrets.

        Args:
            algorithm: Validation algorithm to analyze.
            binary_data: Raw binary data to scan for secrets.

        Returns:
            List of weaknesses for hardcoded secrets found.
        """
        weaknesses: list[CryptoWeakness] = []

        for string_data in algorithm.strings:
            string_bytes = string_data.encode() if isinstance(string_data, str) else string_data
            for known_key in self.COMMON_HARDCODED_KEYS:
                if known_key in string_bytes:
                    weaknesses.append(
                        CryptoWeakness(
                            weakness_type="HARDCODED_SECRET",
                            severity=CryptoWeaknessSeverity.CRITICAL,
                            description="Hardcoded cryptographic secret detected",
                            offset=algorithm.offset,
                            evidence={"secret_type": "common_password", "found": known_key.decode(errors="ignore")},
                        ),
                    )

        if binary_data:
            weaknesses.extend(self._scan_binary_for_keys(binary_data, algorithm.offset))

        return weaknesses

    def _detect_magic_numbers(self, algorithm: ValidationAlgorithm) -> list[CryptoWeakness]:
        """Detect cryptographic magic numbers and constants.

        Args:
            algorithm: Validation algorithm to analyze.

        Returns:
            List of detected magic numbers with identified algorithms.
        """
        weaknesses: list[CryptoWeakness] = []

        for const in algorithm.constants:
            const_bytes = struct.pack("<I", const & 0xFFFFFFFF)
            if const_bytes in self.CRYPTO_CONSTANTS:
                const_name, crypto_type = self.CRYPTO_CONSTANTS[const_bytes]
                severity = CryptoWeaknessSeverity.INFO

                if "MD5" in const_name or "DES" in const_name:
                    severity = CryptoWeaknessSeverity.HIGH

                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="CRYPTO_CONSTANT",
                        severity=severity,
                        description=f"Cryptographic constant detected: {const_name}",
                        offset=algorithm.offset,
                        evidence={"constant": const_name, "value": hex(const), "crypto_type": crypto_type.name},
                    ),
                )

        return weaknesses

    def _detect_weak_ivs(self, algorithm: ValidationAlgorithm) -> list[CryptoWeakness]:
        """Detect weak or predictable initialization vectors.

        Args:
            algorithm: Validation algorithm to analyze.

        Returns:
            List of weaknesses for insecure IV usage.
        """
        weaknesses: list[CryptoWeakness] = []

        zero_iv_patterns = [0x00000000, 0xFFFFFFFF, 0x11111111, 0x01010101]

        for const in algorithm.constants:
            if const in zero_iv_patterns:
                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="WEAK_IV",
                        severity=CryptoWeaknessSeverity.MEDIUM,
                        description="Weak or predictable initialization vector",
                        offset=algorithm.offset,
                        evidence={"iv_value": hex(const), "issue": "predictable_pattern"},
                    ),
                )

        if algorithm.type == KeyAlgorithmType.SYMMETRIC_CRYPTO:
            if self._has_static_iv_pattern(algorithm):
                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="STATIC_IV",
                        severity=CryptoWeaknessSeverity.HIGH,
                        description="Static IV reuse detected in symmetric encryption",
                        offset=algorithm.offset,
                        evidence={"issue": "iv_reuse", "recommendation": "Use random IV per encryption"},
                    ),
                )

        return weaknesses

    def _estimate_rsa_modulus_length(self, algorithm: ValidationAlgorithm) -> int | None:
        """Estimate RSA modulus bit length from algorithm constants.

        Args:
            algorithm: RSA validation algorithm.

        Returns:
            Estimated modulus length in bits, or None if cannot estimate.
        """
        candidate_lengths = [512, 1024, 2048, 4096]

        for const in algorithm.constants:
            if const in candidate_lengths:
                return const

        large_constants = [c for c in algorithm.constants if c > 256]
        if large_constants:
            max_const = max(large_constants)
            return max_const.bit_length()

        return None

    def _scan_binary_for_keys(self, binary_data: bytes, base_offset: int) -> list[CryptoWeakness]:
        """Scan binary data for embedded cryptographic keys.

        Args:
            binary_data: Raw binary data to scan.
            base_offset: Base offset for weakness reporting.

        Returns:
            List of weaknesses for found embedded keys.
        """
        weaknesses: list[CryptoWeakness] = []

        for known_key in self.COMMON_HARDCODED_KEYS:
            offset = binary_data.find(known_key)
            if offset != -1:
                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="EMBEDDED_KEY",
                        severity=CryptoWeaknessSeverity.CRITICAL,
                        description="Embedded cryptographic key in binary",
                        offset=base_offset + offset,
                        evidence={"key_location": offset, "key_preview": known_key[:8].hex()},
                    ),
                )

        entropy_blocks = self._find_high_entropy_blocks(binary_data)
        for block_offset, entropy in entropy_blocks:
            if entropy > 7.5:
                weaknesses.append(
                    CryptoWeakness(
                        weakness_type="POTENTIAL_EMBEDDED_KEY",
                        severity=CryptoWeaknessSeverity.LOW,
                        description="High entropy block may contain embedded key material",
                        offset=base_offset + block_offset,
                        evidence={"entropy": entropy, "block_size": 32},
                    ),
                )

        return weaknesses

    def _find_high_entropy_blocks(self, data: bytes, block_size: int = 32) -> list[tuple[int, float]]:
        """Find blocks with high entropy that may contain key material.

        Args:
            data: Binary data to analyze.
            block_size: Size of blocks to analyze.

        Returns:
            List of (offset, entropy) tuples for high-entropy blocks.
        """
        high_entropy_blocks: list[tuple[int, float]] = []

        for i in range(0, len(data) - block_size, block_size):
            block = data[i : i + block_size]
            entropy = self._calculate_entropy(block)
            if entropy > 7.0:
                high_entropy_blocks.append((i, entropy))

        return high_entropy_blocks

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data.

        Args:
            data: Bytes to calculate entropy for.

        Returns:
            Shannon entropy value (0-8 for bytes).
        """
        if not data:
            return 0.0

        entropy = 0.0
        byte_counts: dict[int, int] = {}

        for byte in data:
            byte_counts[byte] = byte_counts.get(byte, 0) + 1

        data_len = len(data)
        for count in byte_counts.values():
            probability = count / data_len
            if probability > 0:
                entropy -= probability * (probability.bit_length() - 1)

        return entropy

    def _has_static_iv_pattern(self, algorithm: ValidationAlgorithm) -> bool:
        """Check if algorithm uses static IV pattern.

        Args:
            algorithm: Algorithm to check for static IV.

        Returns:
            True if static IV pattern detected.
        """
        iv_load_count = 0
        random_calls = 0

        for mnemonic, operands in algorithm.instructions:
            if mnemonic in ["mov", "movdqu"] and any(reg in operands for reg in ["xmm", "ymm"]):
                iv_load_count += 1
            if "random" in operands.lower() or "rand" in operands.lower():
                random_calls += 1

        return iv_load_count > 0 and random_calls == 0

    def _suggest_replacement(self, weak_algorithm: str) -> str:
        """Suggest secure replacement for weak algorithm.

        Args:
            weak_algorithm: Name of weak algorithm.

        Returns:
            Recommended replacement algorithm.
        """
        replacements = {
            "MD5": "SHA-256 or SHA-3",
            "MD4": "SHA-256 or SHA-3",
            "SHA1": "SHA-256 or SHA-3",
            "DES": "AES-256",
            "3DES": "AES-256",
            "RC4": "AES-256-GCM or ChaCha20-Poly1305",
            "RC2": "AES-256-GCM",
        }
        return replacements.get(weak_algorithm, "Use modern cryptographic algorithms")


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required for disassembly")
class TestWeakCryptoDetectionOperandAnalysis:
    """Test operand analysis for cryptographic constant detection."""

    def test_detect_md5_magic_constants_in_operands(self) -> None:
        """Detector identifies MD5 initialization constants in instruction operands."""
        detector = WeakCryptoDetector()

        md5_init_constants = [0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE]

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x401000,
            instructions=[
                ("mov", "eax, 0xd76aa478"),
                ("mov", "ebx, 0xe8c7b756"),
            ],
            constants=md5_init_constants,
            strings=[],
            crypto_operations=["MD5_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        md5_weaknesses = [w for w in weaknesses if "MD5" in w.evidence.get("constant", "")]
        assert len(md5_weaknesses) > 0, "MD5 magic constants not detected in operands"
        assert all(w.severity >= CryptoWeaknessSeverity.MEDIUM for w in md5_weaknesses)

    def test_detect_sha256_round_constants(self) -> None:
        """Detector identifies SHA-256 round constants in algorithm."""
        detector = WeakCryptoDetector()

        sha256_constants = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A]

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x402000,
            instructions=[("mov", "esi, 0x6a09e667")],
            constants=sha256_constants,
            strings=[],
            crypto_operations=["SHA256_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        sha_weaknesses = [w for w in weaknesses if "SHA256" in w.evidence.get("constant", "")]
        assert len(sha_weaknesses) > 0, "SHA-256 constants not detected"
        assert all(w.weakness_type == "CRYPTO_CONSTANT" for w in sha_weaknesses)

    def test_detect_aes_sbox_constant(self) -> None:
        """Detector identifies AES S-box initialization patterns."""
        detector = WeakCryptoDetector()

        aes_sbox_start = 0x7B777C63

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x403000,
            instructions=[("mov", "edi, offset sbox_table")],
            constants=[aes_sbox_start],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        aes_weaknesses = [w for w in weaknesses if "AES" in w.evidence.get("constant", "")]
        assert len(aes_weaknesses) > 0, "AES S-box constant not detected"

    def test_detect_crc32_polynomial(self) -> None:
        """Detector identifies CRC32 polynomial constants."""
        detector = WeakCryptoDetector()

        crc32_poly = 0x04C11DB7

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x404000,
            instructions=[("xor", "eax, 0x04c11db7")],
            constants=[crc32_poly],
            strings=[],
            crypto_operations=["CRC32"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        crc_weaknesses = [w for w in weaknesses if "CRC32" in w.evidence.get("constant", "")]
        assert len(crc_weaknesses) > 0, "CRC32 polynomial not detected"


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionMagicNumbers:
    """Test scanning for magic numbers and initialization vectors."""

    def test_scan_for_des_magic_numbers(self) -> None:
        """Detector finds DES-specific magic numbers indicating weak encryption."""
        detector = WeakCryptoDetector()

        des_constant = 0x01234567

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x405000,
            instructions=[],
            constants=[des_constant],
            strings=[],
            crypto_operations=["DES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        des_weaknesses = [w for w in weaknesses if "DES" in w.evidence.get("constant", "")]
        assert len(des_weaknesses) > 0, "DES magic number not detected"
        assert any(w.severity >= CryptoWeaknessSeverity.HIGH for w in weaknesses)

    def test_detect_predictable_iv_patterns(self) -> None:
        """Detector identifies predictable IV patterns (all zeros, all ones)."""
        detector = WeakCryptoDetector()

        predictable_ivs = [0x00000000, 0xFFFFFFFF, 0x11111111]

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x406000,
            instructions=[("movdqu", "xmm0, [iv_buffer]")],
            constants=predictable_ivs,
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        iv_weaknesses = [w for w in weaknesses if w.weakness_type in ["WEAK_IV", "STATIC_IV"]]
        assert len(iv_weaknesses) > 0, "Weak IV patterns not detected"
        assert any("predictable" in w.evidence.get("issue", "") for w in iv_weaknesses)

    def test_detect_static_iv_reuse(self) -> None:
        """Detector identifies static IV reuse in symmetric encryption."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x407000,
            instructions=[
                ("mov", "esi, offset static_iv"),
                ("movdqu", "xmm0, [esi]"),
                ("call", "AES_encrypt"),
            ],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        static_iv_weaknesses = [w for w in weaknesses if w.weakness_type == "STATIC_IV"]
        assert len(static_iv_weaknesses) > 0, "Static IV reuse not detected"
        assert all(w.severity >= CryptoWeaknessSeverity.MEDIUM for w in static_iv_weaknesses)


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionKeyLengths:
    """Test identification of weak key lengths and insecure algorithms."""

    def test_detect_512bit_rsa_weak_key(self) -> None:
        """Detector flags 512-bit RSA keys as critically weak."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x408000,
            instructions=[],
            constants=[512],
            strings=[],
            crypto_operations=["RSA_verify"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        rsa_weaknesses = [w for w in weaknesses if w.weakness_type == "WEAK_KEY_LENGTH" and "RSA" in w.description]
        assert len(rsa_weaknesses) > 0, "512-bit RSA not flagged as weak"
        assert any(w.severity == CryptoWeaknessSeverity.CRITICAL for w in rsa_weaknesses)

    def test_detect_1024bit_rsa_deprecated_key(self) -> None:
        """Detector flags 1024-bit RSA keys as high risk."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x409000,
            instructions=[],
            constants=[1024],
            strings=[],
            crypto_operations=["RSA_public_decrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        rsa_weaknesses = [w for w in weaknesses if "1024" in w.description]
        assert len(rsa_weaknesses) > 0, "1024-bit RSA not flagged"
        assert any(w.severity >= CryptoWeaknessSeverity.HIGH for w in rsa_weaknesses)

    def test_detect_des_56bit_key(self) -> None:
        """Detector identifies critically weak 56-bit DES keys."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x40A000,
            instructions=[],
            constants=[56],
            strings=[],
            crypto_operations=["DES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        des_weaknesses = [w for w in weaknesses if "DES" in w.description and "56" in w.description]
        assert len(des_weaknesses) > 0, "56-bit DES key not detected as weak"
        assert all(w.severity == CryptoWeaknessSeverity.CRITICAL for w in des_weaknesses)

    def test_recommend_2048bit_rsa_minimum(self) -> None:
        """Detector recommends minimum 2048-bit RSA keys."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x40B000,
            instructions=[],
            constants=[1024],
            strings=[],
            crypto_operations=["RSA_verify"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        rsa_weaknesses = [w for w in weaknesses if w.weakness_type == "WEAK_KEY_LENGTH"]
        assert len(rsa_weaknesses) > 0
        assert all(w.evidence.get("minimum_recommended", 0) >= 2048 for w in rsa_weaknesses)


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionHardcodedSecrets:
    """Test detection of hardcoded keys and passwords."""

    def test_detect_hardcoded_password_in_strings(self) -> None:
        """Detector finds common hardcoded passwords in algorithm strings."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x40C000,
            instructions=[],
            constants=[],
            strings=["password", "License key validation"],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        secret_weaknesses = [w for w in weaknesses if w.weakness_type == "HARDCODED_SECRET"]
        assert len(secret_weaknesses) > 0, "Hardcoded password not detected"
        assert all(w.severity == CryptoWeaknessSeverity.CRITICAL for w in secret_weaknesses)

    def test_detect_hardcoded_key_12345678(self) -> None:
        """Detector identifies common weak hardcoded key '12345678'."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x40D000,
            instructions=[],
            constants=[],
            strings=["12345678"],
            crypto_operations=["DES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        secret_weaknesses = [w for w in weaknesses if "12345678" in w.evidence.get("found", "")]
        assert len(secret_weaknesses) > 0, "Common weak key not detected"

    def test_detect_all_zero_key(self) -> None:
        """Detector flags all-zero keys as critical vulnerability."""
        detector = WeakCryptoDetector()

        binary_data = b"\x00\x00\x00\x00\x00\x00\x00\x00SOME_OTHER_DATA"

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x40E000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm, binary_data)

        zero_key_weaknesses = [w for w in weaknesses if w.weakness_type in ["HARDCODED_SECRET", "EMBEDDED_KEY"]]
        assert len(zero_key_weaknesses) > 0, "All-zero key not detected"

    def test_detect_embedded_key_in_binary(self) -> None:
        """Detector finds embedded cryptographic keys in binary data."""
        detector = WeakCryptoDetector()

        binary_with_key = b"HEADER_DATA" + b"0123456789ABCDEF" + b"MORE_DATA"

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x40F000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm, binary_with_key)

        embedded_weaknesses = [w for w in weaknesses if w.weakness_type == "EMBEDDED_KEY"]
        assert len(embedded_weaknesses) > 0, "Embedded key in binary not detected"
        assert all(w.severity == CryptoWeaknessSeverity.CRITICAL for w in embedded_weaknesses)


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionVulnerabilitySeverity:
    """Test vulnerability severity level reporting."""

    def test_critical_severity_for_md4(self) -> None:
        """MD4 usage assigned CRITICAL severity level."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x410000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["MD4_Init", "MD4_Update"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        md4_weaknesses = [w for w in weaknesses if "MD4" in w.description]
        assert len(md4_weaknesses) > 0, "MD4 usage not detected"
        assert all(w.severity == CryptoWeaknessSeverity.CRITICAL for w in md4_weaknesses)

    def test_high_severity_for_md5(self) -> None:
        """MD5 usage assigned HIGH severity level."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x411000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["MD5_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        md5_weaknesses = [w for w in weaknesses if w.weakness_type == "WEAK_ALGORITHM" and "MD5" in w.description]
        assert len(md5_weaknesses) > 0, "MD5 usage not detected"
        assert all(w.severity == CryptoWeaknessSeverity.HIGH for w in md5_weaknesses)

    def test_medium_severity_for_sha1(self) -> None:
        """SHA-1 usage assigned MEDIUM severity level."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x412000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["SHA1_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        sha1_weaknesses = [w for w in weaknesses if "SHA1" in w.description]
        assert len(sha1_weaknesses) > 0, "SHA-1 usage not detected"
        assert all(w.severity == CryptoWeaknessSeverity.MEDIUM for w in sha1_weaknesses)

    def test_severity_ordering_critical_highest(self) -> None:
        """CRITICAL severity has highest numeric value for prioritization."""
        assert CryptoWeaknessSeverity.CRITICAL > CryptoWeaknessSeverity.HIGH
        assert CryptoWeaknessSeverity.HIGH > CryptoWeaknessSeverity.MEDIUM
        assert CryptoWeaknessSeverity.MEDIUM > CryptoWeaknessSeverity.LOW
        assert CryptoWeaknessSeverity.LOW > CryptoWeaknessSeverity.INFO

    def test_multiple_weaknesses_all_reported(self) -> None:
        """Detector reports all weaknesses with appropriate severity levels."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x413000,
            instructions=[],
            constants=[512, 0x00000000],
            strings=["password"],
            crypto_operations=["MD5_Init", "DES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        assert len(weaknesses) >= 3, "Not all weaknesses detected"
        severities = {w.severity for w in weaknesses}
        assert CryptoWeaknessSeverity.CRITICAL in severities or CryptoWeaknessSeverity.HIGH in severities


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionEdgeCases:
    """Test edge cases: obfuscated constants and dynamic key generation."""

    def test_detect_obfuscated_constant_split_loads(self) -> None:
        """Detector handles constants loaded in multiple parts."""
        detector = WeakCryptoDetector()

        md5_const_obfuscated = 0xD76AA478

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x414000,
            instructions=[
                ("mov", "eax, 0xd76a0000"),
                ("add", "eax, 0xa478"),
            ],
            constants=[md5_const_obfuscated],
            strings=[],
            crypto_operations=["MD5_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        md5_weaknesses = [w for w in weaknesses if "MD5" in str(w.evidence)]
        assert len(md5_weaknesses) > 0, "Obfuscated MD5 constant not detected"

    def test_handle_dynamic_key_generation_no_false_positives(self) -> None:
        """Detector avoids false positives for dynamic key generation."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x415000,
            instructions=[
                ("call", "CryptGenRandom"),
                ("mov", "[key_buffer], eax"),
            ],
            constants=[],
            strings=[],
            crypto_operations=["SHA256_Init", "CryptGenRandom"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        hardcoded_weaknesses = [w for w in weaknesses if w.weakness_type == "HARDCODED_SECRET"]
        assert len(hardcoded_weaknesses) == 0, "False positive for dynamic key generation"

    def test_detect_xor_obfuscated_key(self) -> None:
        """Detector identifies keys obfuscated with simple XOR."""
        detector = WeakCryptoDetector()

        xor_obfuscated_data = bytes([ord(c) ^ 0xAA for c in "password"])
        binary_data = b"PREFIX" + xor_obfuscated_data + b"SUFFIX"

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x416000,
            instructions=[
                ("mov", "al, [esi]"),
                ("xor", "al, 0xaa"),
            ],
            constants=[0xAA],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm, binary_data)

        assert len(weaknesses) > 0, "Analysis completed for obfuscated key scenario"

    def test_handle_runtime_computed_constants(self) -> None:
        """Detector handles constants computed at runtime."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x417000,
            instructions=[
                ("rdtsc", ""),
                ("xor", "eax, edx"),
                ("mov", "[iv_buffer], eax"),
            ],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        static_iv_weaknesses = [w for w in weaknesses if w.weakness_type == "STATIC_IV"]
        assert len(static_iv_weaknesses) == 0, "False positive for runtime-computed IV"

    def test_detect_high_entropy_potential_keys(self) -> None:
        """Detector identifies high-entropy blocks as potential embedded keys."""
        detector = WeakCryptoDetector()

        high_entropy_data = bytes(range(256))
        binary_data = b"LOW_ENTROPY" + high_entropy_data + b"MORE_LOW"

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x418000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["AES_encrypt"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm, binary_data)

        potential_key_weaknesses = [w for w in weaknesses if w.weakness_type == "POTENTIAL_EMBEDDED_KEY"]
        assert len(potential_key_weaknesses) > 0, "High-entropy key blocks not detected"

    def test_handle_polymorphic_constant_loading(self) -> None:
        """Detector handles polymorphic constant loading patterns."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x419000,
            instructions=[
                ("push", "0x78a46ad7"),
                ("pop", "eax"),
                ("ror", "eax, 8"),
                ("rol", "eax, 8"),
            ],
            constants=[0xD76AA478],
            strings=[],
            crypto_operations=["MD5_Init"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        crypto_const_weaknesses = [w for w in weaknesses if w.weakness_type == "CRYPTO_CONSTANT"]
        assert len(crypto_const_weaknesses) > 0, "Polymorphic constant loading not handled"


@pytest.mark.skipif(not CAPSTONE_AVAILABLE, reason="Capstone required")
class TestWeakCryptoDetectionIntegration:
    """Integration tests validating complete weak crypto detection workflow."""

    def test_complete_weak_license_validation_analysis(self) -> None:
        """Detector performs comprehensive analysis of weak license validation."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.SYMMETRIC_CRYPTO,
            offset=0x41A000,
            instructions=[
                ("mov", "esi, offset des_key"),
                ("mov", "edi, offset iv_buffer"),
                ("call", "DES_encrypt"),
            ],
            constants=[56, 0x00000000, 0xD76AA478],
            strings=["default", "12345678"],
            crypto_operations=["DES_encrypt", "MD5_Init"],
        )

        binary_data = b"HEADER" + b"0123456789ABCDEF" + b"FOOTER"

        weaknesses = detector.detect_weak_crypto(algorithm, binary_data)

        assert len(weaknesses) >= 5, "Comprehensive analysis incomplete"

        weakness_types = {w.weakness_type for w in weaknesses}
        assert "WEAK_ALGORITHM" in weakness_types
        assert "WEAK_KEY_LENGTH" in weakness_types or "HARDCODED_SECRET" in weakness_types

        critical_weaknesses = [w for w in weaknesses if w.severity == CryptoWeaknessSeverity.CRITICAL]
        assert len(critical_weaknesses) > 0, "No critical weaknesses flagged"

    def test_secure_algorithm_no_false_positives(self) -> None:
        """Detector does not flag secure modern cryptographic implementations."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x41B000,
            instructions=[
                ("call", "CryptGenRandom"),
                ("call", "SHA256_Init"),
            ],
            constants=[2048, 256],
            strings=[],
            crypto_operations=["SHA256_Init", "AES_encrypt", "CryptGenRandom"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        critical_weaknesses = [w for w in weaknesses if w.severity >= CryptoWeaknessSeverity.HIGH]
        assert len(critical_weaknesses) == 0, "False positives for secure algorithms"

    def test_weakness_evidence_provides_actionable_info(self) -> None:
        """Detected weaknesses include actionable remediation information."""
        detector = WeakCryptoDetector()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CRYPTOGRAPHIC,
            offset=0x41C000,
            instructions=[],
            constants=[512],
            strings=[],
            crypto_operations=["MD5_Init", "RSA_verify"],
        )

        weaknesses = detector.detect_weak_crypto(algorithm)

        for weakness in weaknesses:
            assert weakness.evidence is not None
            assert len(weakness.evidence) > 0

            if weakness.weakness_type == "WEAK_ALGORITHM":
                assert "replacement" in weakness.evidence or "algorithm" in weakness.evidence

            if weakness.weakness_type == "WEAK_KEY_LENGTH":
                assert "minimum_recommended" in weakness.evidence
