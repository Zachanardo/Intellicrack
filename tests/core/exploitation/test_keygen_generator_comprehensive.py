"""Comprehensive production-ready tests for KeygenGenerator.

Validates actual license key generation capabilities against real binary protection
schemes including RSA, ECC, CRC, MD5/SHA-based validation, hardware-locked licenses,
and time-based protections for defeating commercial software licensing mechanisms.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import hashlib
import json
import re
import string
import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.exploitation.keygen_generator import (
    AlgorithmExtractor,
    ConstraintSolver,
    KeyAlgorithmType,
    KeyConstraint,
    KeygenGenerator,
    KeygenTemplate,
    KeySpaceExplorer,
    ValidationAlgorithm,
)

FIXTURES_DIR = Path(__file__).parent.parent.parent / "fixtures"
PROTECTED_BINARIES_DIR = FIXTURES_DIR / "binaries" / "pe" / "protected"
LEGITIMATE_BINARIES_DIR = FIXTURES_DIR / "binaries" / "pe" / "legitimate"


@pytest.fixture
def sample_pe_binary() -> Path:
    """Provide path to real PE binary for testing."""
    binary_path = PROTECTED_BINARIES_DIR / "enterprise_license_check.exe"
    if not binary_path.exists():
        binary_path = LEGITIMATE_BINARIES_DIR / "notepadpp.exe"
    if not binary_path.exists():
        pytest.skip("No suitable PE binary available for testing")
    return binary_path


@pytest.fixture
def vmprotect_binary() -> Path:
    """Provide VMProtect-protected binary."""
    binary_path = PROTECTED_BINARIES_DIR / "vmprotect_protected.exe"
    if not binary_path.exists():
        pytest.skip("VMProtect binary not available")
    return binary_path


@pytest.fixture
def themida_binary() -> Path:
    """Provide Themida-protected binary."""
    binary_path = PROTECTED_BINARIES_DIR / "themida_protected.exe"
    if not binary_path.exists():
        pytest.skip("Themida binary not available")
    return binary_path


@pytest.fixture
def flexlm_binary() -> Path:
    """Provide FlexLM-protected binary."""
    binary_path = PROTECTED_BINARIES_DIR / "flexlm_license_protected.exe"
    if not binary_path.exists():
        pytest.skip("FlexLM binary not available")
    return binary_path


@pytest.fixture
def hasp_binary() -> Path:
    """Provide HASP Sentinel protected binary."""
    binary_path = PROTECTED_BINARIES_DIR / "hasp_sentinel_protected.exe"
    if not binary_path.exists():
        pytest.skip("HASP binary not available")
    return binary_path


class TestAlgorithmExtractorInitialization:
    """Test AlgorithmExtractor initialization and configuration."""

    def test_extractor_initializes_with_crypto_signatures(self) -> None:
        """Extractor initializes with crypto signature database."""
        extractor = AlgorithmExtractor()

        assert extractor.crypto_signatures is not None
        assert len(extractor.crypto_signatures) > 0
        assert b"\x67\xe6\x09\x6a" in extractor.crypto_signatures
        assert extractor.crypto_signatures[b"\x67\xe6\x09\x6a"] == "SHA256_K0"
        assert b"\x78\xa4\x6a\xd7" in extractor.crypto_signatures
        assert extractor.crypto_signatures[b"\x78\xa4\x6a\xd7"] == "MD5_T0"
        assert b"\xdb\x71\x06\x41" in extractor.crypto_signatures
        assert extractor.crypto_signatures[b"\xdb\x71\x06\x41"] == "CRC32_POLY"

    def test_extractor_initializes_with_validation_patterns(self) -> None:
        """Extractor initializes with validation pattern database."""
        extractor = AlgorithmExtractor()

        assert extractor.validation_patterns is not None
        assert len(extractor.validation_patterns) > 0

        pattern_names = [p["name"] for p in extractor.validation_patterns]
        assert "length_check" in pattern_names
        assert "checksum_validation" in pattern_names
        assert "rsa_verify" in pattern_names
        assert "hardware_check" in pattern_names

    def test_extractor_initializes_capstone_when_available(self) -> None:
        """Extractor initializes Capstone disassembler when available."""
        extractor = AlgorithmExtractor()

        try:
            import capstone

            assert extractor.md is not None
            assert extractor.md.arch == capstone.CS_ARCH_X86
            assert extractor.md.detail is True
        except ImportError:
            assert extractor.md is None


class TestAlgorithmExtractionFromRealBinaries:
    """Test algorithm extraction from real protected binaries."""

    def test_extract_algorithm_from_enterprise_license_binary(self, sample_pe_binary: Path) -> None:
        """Extract validation algorithm from real enterprise license check binary."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        assert isinstance(algorithms, list)
        if len(algorithms) > 0:
            algorithm = algorithms[0]
            assert isinstance(algorithm, ValidationAlgorithm)
            assert algorithm.type in KeyAlgorithmType
            assert algorithm.offset >= 0
            assert algorithm.confidence >= 0.0
            assert algorithm.confidence <= 1.0

    def test_extract_algorithm_with_custom_search_strings(self, sample_pe_binary: Path) -> None:
        """Extract algorithm using custom search strings for targeted analysis."""
        extractor = AlgorithmExtractor()
        search_strings = ["Serial", "License", "Key", "Activation"]

        algorithms = extractor.extract_algorithm(str(sample_pe_binary), search_strings)

        assert isinstance(algorithms, list)

    def test_extract_algorithm_identifies_crypto_operations(self, sample_pe_binary: Path) -> None:
        """Extracted algorithm identifies cryptographic operations in binary."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        if algorithms:
            algorithm = algorithms[0]
            assert isinstance(algorithm.crypto_operations, list)

    def test_extract_algorithm_extracts_constraints(self, sample_pe_binary: Path) -> None:
        """Extracted algorithm includes license key constraints."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        if algorithms:
            algorithm = algorithms[0]
            assert isinstance(algorithm.constraints, list)
            for constraint in algorithm.constraints:
                assert isinstance(constraint, KeyConstraint)
                assert constraint.name in ["length", "charset", "checksum", "format", "pattern"]
                assert constraint.priority >= 1

    def test_extract_algorithm_calculates_confidence_score(self, sample_pe_binary: Path) -> None:
        """Extracted algorithm has realistic confidence score based on analysis."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        if algorithms:
            for algorithm in algorithms:
                assert 0.0 <= algorithm.confidence <= 1.0
                if algorithm.type != KeyAlgorithmType.UNKNOWN:
                    assert algorithm.confidence >= 0.3
                if algorithm.crypto_operations:
                    assert algorithm.confidence >= 0.4
                if algorithm.constraints:
                    assert algorithm.confidence >= 0.5

    def test_extract_multiple_validation_algorithms_from_complex_binary(self, sample_pe_binary: Path) -> None:
        """Extract multiple validation algorithms from binary with layered protection."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        assert isinstance(algorithms, list)
        if len(algorithms) > 1:
            algorithm_types = [alg.type for alg in algorithms]
            assert len(set(algorithm_types)) > 0

    def test_algorithm_extraction_identifies_rsa_signatures(self, sample_pe_binary: Path) -> None:
        """Algorithm extraction detects RSA signature validation."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        for algorithm in algorithms:
            if "RSA" in algorithm.crypto_operations:
                assert algorithm.type == KeyAlgorithmType.RSA_SIGNATURE
                break

    def test_algorithm_extraction_identifies_checksum_algorithms(self, sample_pe_binary: Path) -> None:
        """Algorithm extraction detects checksum-based validation."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm(str(sample_pe_binary))

        for algorithm in algorithms:
            if algorithm.type == KeyAlgorithmType.CHECKSUM:
                assert algorithm.instructions is not None
                assert len(algorithm.instructions) > 0
                break


class TestConstraintSolverInitialization:
    """Test ConstraintSolver initialization and crypto engines."""

    def test_solver_initializes_with_crypto_engines(self) -> None:
        """Solver initializes with cryptographic hash engines."""
        solver = ConstraintSolver()

        assert solver.crypto_engines is not None
        assert "md5" in solver.crypto_engines
        assert "sha1" in solver.crypto_engines
        assert "sha256" in solver.crypto_engines
        assert "sha512" in solver.crypto_engines
        assert "crc32" in solver.crypto_engines
        assert "luhn" in solver.crypto_engines

    def test_solver_initializes_z3_when_available(self) -> None:
        """Solver initializes Z3 constraint solver when available."""
        solver = ConstraintSolver()

        try:
            import z3

            assert solver.solver is not None
        except ImportError:
            assert solver.solver is None

    def test_crc32_checksum_calculation(self) -> None:
        """CRC32 calculation produces correct checksums."""
        solver = ConstraintSolver()

        test_data = b"ABCD-1234-EFGH"
        crc = solver._crc32(test_data)

        assert isinstance(crc, int)
        assert 0 <= crc <= 0xFFFFFFFF

        import binascii
        expected_crc = binascii.crc32(test_data) & 0xFFFFFFFF
        assert crc == expected_crc

    def test_luhn_checksum_calculation(self) -> None:
        """Luhn checksum calculation validates credit card algorithm."""
        solver = ConstraintSolver()

        valid_luhn = "79927398713"
        checksum = solver._luhn_checksum(valid_luhn)
        assert checksum == 0

    def test_luhn_check_digit_calculation(self) -> None:
        """Luhn check digit calculation generates valid check digits."""
        solver = ConstraintSolver()

        data = "7992739871"
        check_digit = solver._calculate_luhn(data)

        assert isinstance(check_digit, int)
        assert 0 <= check_digit <= 9

        full_number = data + str(check_digit)
        assert solver._verify_luhn(full_number) is True


class TestConstraintSolvingAndKeyGeneration:
    """Test constraint solving to generate valid license keys."""

    def test_solve_length_constraint_generates_correct_length_key(self) -> None:
        """Solver generates key with exact length from constraint."""
        solver = ConstraintSolver()

        constraint = KeyConstraint(name="length", type="length", value=16, priority=1)
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        key = solver.solve_constraints([constraint], template)

        if key:
            clean_key = key.replace("-", "")
            assert len(clean_key) == 16

    def test_solve_charset_constraint_uses_only_allowed_characters(self) -> None:
        """Solver generates key using only characters from charset constraint."""
        solver = ConstraintSolver()

        charset = "ABCDEF0123456789"
        constraint = KeyConstraint(name="charset", type="charset", value=charset, priority=1)
        template = KeygenTemplate(
            format="####-####",
            charset=charset,
        )

        key = solver.solve_constraints([constraint], template)

        if key:
            clean_key = key.replace("-", "")
            assert all(c in charset for c in clean_key)

    def test_solve_pattern_constraint_matches_required_format(self) -> None:
        """Solver generates key matching pattern constraint."""
        solver = ConstraintSolver()

        pattern = "####-####-####-####"
        constraint = KeyConstraint(name="format", type="pattern", value=pattern, priority=1)
        template = KeygenTemplate(
            format=pattern,
            charset=string.ascii_uppercase + string.digits,
        )

        key = solver.solve_constraints([constraint], template)

        if key:
            assert len(key) == len(pattern)
            assert key[4] == "-"
            assert key[9] == "-"
            assert key[14] == "-"

    def test_heuristic_solve_generates_valid_key_when_z3_unavailable(self) -> None:
        """Heuristic solver generates valid keys without Z3."""
        solver = ConstraintSolver()

        constraints: list[KeyConstraint] = []
        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        key = solver._heuristic_solve(constraints, template)

        assert key is not None
        assert len(key) == len("####-####-####-####")
        assert key.count("-") == 3

    def test_apply_crc32_checksum_to_generated_key(self) -> None:
        """Solver applies CRC32 checksum to key segment."""
        solver = ConstraintSolver()

        key = "ABCD-1234-EFGH-5678"
        checksummed_key = solver._apply_checksum(key, "crc32")

        assert checksummed_key is not None
        assert len(checksummed_key) == len(key)
        parts = checksummed_key.split("-")
        assert len(parts[-1]) == 4

    def test_apply_luhn_checksum_to_generated_key(self) -> None:
        """Solver applies Luhn checksum to key."""
        solver = ConstraintSolver()

        key = "1234-5678-9012-3456"
        checksummed_key = solver._apply_checksum(key, "luhn")

        assert checksummed_key is not None
        clean_key = checksummed_key.replace("-", "")
        assert solver._verify_luhn(clean_key) is True

    def test_verify_checksum_validates_crc32_keys(self) -> None:
        """Solver validates CRC32 keys with correct checksum."""
        solver = ConstraintSolver()

        data_part = "ABCD1234"
        crc_of_data = solver._crc32(data_part.encode())
        valid_crc_suffix = f"{crc_of_data:08X}"
        valid_key = data_part + valid_crc_suffix

        assert solver._verify_checksum(valid_key, "crc32") is True

    def test_verify_checksum_rejects_invalid_crc32_keys(self) -> None:
        """Solver correctly rejects keys with invalid CRC32 checksums."""
        solver = ConstraintSolver()

        invalid_key = "ABCD1234DEADBEEF"
        assert solver._verify_checksum(invalid_key, "crc32") is False

    def test_verify_constraint_checks_length_correctly(self) -> None:
        """Solver correctly validates length constraints."""
        solver = ConstraintSolver()

        constraint = KeyConstraint(name="length", type="length", value=16, priority=1)

        valid_key = "ABCD-1234-EFGH-5678"
        assert solver._check_constraint(valid_key, constraint) is True

        invalid_key = "ABCD-1234"
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_verify_constraint_checks_charset_correctly(self) -> None:
        """Solver correctly validates charset constraints."""
        solver = ConstraintSolver()

        charset = "ABCDEF0123456789"
        constraint = KeyConstraint(name="charset", type="charset", value=charset, priority=1)

        valid_key = "ABCD-1234-EF56"
        assert solver._check_constraint(valid_key, constraint) is True

        invalid_key = "ABCD-1234-GHIJ"
        assert solver._check_constraint(invalid_key, constraint) is False

    def test_match_pattern_validates_key_format(self) -> None:
        """Solver correctly validates pattern matching."""
        solver = ConstraintSolver()

        pattern = "####-####-####"
        valid_key = "ABCD-1234-EFGH"
        assert solver._match_pattern(valid_key, pattern) is True

        invalid_key = "ABCD-1234-efgh"
        assert solver._match_pattern(invalid_key, pattern) is False


class TestKeySpaceExplorerInitialization:
    """Test KeySpaceExplorer initialization and key space estimation."""

    def test_explorer_initializes_with_empty_collections(self) -> None:
        """Explorer initializes with empty key collections."""
        explorer = KeySpaceExplorer()

        assert len(explorer.tested_keys) == 0
        assert len(explorer.valid_keys) == 0
        assert len(explorer.worker_threads) == 0

    def test_estimate_keyspace_size_calculates_correctly(self) -> None:
        """Explorer correctly estimates total keyspace size."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="##-##", charset="ABC")
        size = explorer._estimate_space_size(template)

        assert size == 3**4

    def test_estimate_large_keyspace_size(self) -> None:
        """Explorer estimates large keyspace correctly."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(
            format="####-####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )
        size = explorer._estimate_space_size(template)

        assert size == 36**16

    def test_random_key_generation_produces_valid_format(self) -> None:
        """Explorer generates random keys matching template format."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(
            format="####-####-####",
            charset=string.ascii_uppercase + string.digits,
        )

        key = explorer._random_key(template)

        assert len(key) == len("####-####-####")
        assert key[4] == "-"
        assert key[9] == "-"
        assert all(c in template.charset or c == "-" for c in key)


class TestKeySpaceExplorationAlgorithms:
    """Test keyspace exploration using genetic algorithms and exhaustive search."""

    def test_generate_all_keys_for_small_keyspace(self) -> None:
        """Explorer generates all possible keys for small keyspace."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="##", charset="AB")

        keys = list(explorer._generate_all_keys(template))

        assert len(keys) == 4
        assert "AA" in keys
        assert "AB" in keys
        assert "BA" in keys
        assert "BB" in keys

    def test_exhaustive_search_finds_valid_keys_in_small_space(self) -> None:
        """Exhaustive search finds all valid keys in small keyspace."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="##", charset="AB")
        constraints: list[KeyConstraint] = []

        def validator(key: str) -> bool:
            return "A" in key

        valid_keys = explorer._exhaustive_search(template, constraints, validator, max_keys=10)

        assert len(valid_keys) >= 2
        assert all("A" in key for key in valid_keys)

    def test_intelligent_search_uses_genetic_algorithm(self) -> None:
        """Intelligent search uses genetic algorithm for large keyspace."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(
            format="####-####",
            charset=string.ascii_uppercase + string.digits,
        )
        constraints: list[KeyConstraint] = []

        def validator(key: str) -> bool:
            return key.startswith("TEST")

        valid_keys = explorer._intelligent_search(template, constraints, validator, max_keys=5)

        assert isinstance(valid_keys, list)

    def test_evaluate_fitness_scores_keys_correctly(self) -> None:
        """Explorer correctly evaluates fitness scores for keys."""
        explorer = KeySpaceExplorer()

        constraint = KeyConstraint(name="length", type="length", value=8, priority=1)

        def validator(key: str) -> bool:
            return len(key.replace("-", "")) == 8

        key1 = "ABCD-EFGH"
        fitness1 = explorer._evaluate_fitness(key1, [constraint], validator)
        assert fitness1 == 1.0

        key2 = "AB-CD"
        fitness2 = explorer._evaluate_fitness(key2, [constraint], validator)
        assert fitness2 < 1.0

    def test_crossover_creates_valid_offspring(self) -> None:
        """Genetic crossover creates valid offspring from parent keys."""
        explorer = KeySpaceExplorer()

        parent1 = "ABCD-1234-EFGH"
        parent2 = "WXYZ-5678-IJKL"

        child = explorer._crossover(parent1, parent2)

        assert len(child) == len(parent1)
        assert child.count("-") == 2

    def test_mutate_changes_key_character(self) -> None:
        """Mutation changes random character in key."""
        explorer = KeySpaceExplorer()

        original = "AAAA-AAAA-AAAA"
        template = KeygenTemplate(
            format="####-####-####",
            charset=string.ascii_uppercase,
        )

        mutated = explorer._mutate(original, template)

        assert len(mutated) == len(original)
        assert mutated != original or mutated == original


class TestKeygenGeneratorInitialization:
    """Test KeygenGenerator initialization and template loading."""

    def test_generator_initializes_all_components(self) -> None:
        """Generator initializes with all required components."""
        generator = KeygenGenerator()

        assert generator.extractor is not None
        assert isinstance(generator.extractor, AlgorithmExtractor)
        assert generator.solver is not None
        assert isinstance(generator.solver, ConstraintSolver)
        assert generator.explorer is not None
        assert isinstance(generator.explorer, KeySpaceExplorer)
        assert generator.templates is not None
        assert len(generator.templates) > 0

    def test_generator_loads_standard_templates(self) -> None:
        """Generator loads standard keygen templates."""
        generator = KeygenGenerator()

        assert "standard" in generator.templates
        assert "windows" in generator.templates
        assert "adobe" in generator.templates
        assert "simple" in generator.templates

    def test_standard_template_configuration(self) -> None:
        """Standard template has correct configuration."""
        generator = KeygenGenerator()

        template = generator.templates["standard"]

        assert template.format == "####-####-####-####"
        assert template.charset == string.ascii_uppercase + string.digits
        assert template.checksum_algorithm == "crc32"

    def test_windows_template_configuration(self) -> None:
        """Windows template has correct configuration."""
        generator = KeygenGenerator()

        template = generator.templates["windows"]

        assert template.format == "#####-#####-#####-#####-#####"
        assert "O" not in template.charset
        assert "I" not in template.charset
        assert "0" not in template.charset
        assert "1" not in template.charset
        assert template.checksum_algorithm == "mod7"

    def test_adobe_template_configuration(self) -> None:
        """Adobe template uses Luhn algorithm with numeric charset."""
        generator = KeygenGenerator()

        template = generator.templates["adobe"]

        assert template.format == "####-####-####-####-####-####"
        assert template.charset == string.digits
        assert template.checksum_algorithm == "luhn"


class TestKeygenGenerationFromRealBinaries:
    """Test keygen generation against real protected binaries."""

    def test_generate_keygen_from_enterprise_license_binary(self, sample_pe_binary: Path) -> None:
        """Generate valid keys for enterprise license check binary."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(sample_pe_binary), template_name="standard", num_keys=5)

        assert isinstance(keys, list)
        assert len(keys) <= 5
        if keys:
            for key in keys:
                assert isinstance(key, str)
                assert len(key) > 0
                assert "-" in key or len(key) >= 10

    def test_generate_keygen_with_standard_template(self, sample_pe_binary: Path) -> None:
        """Generate keys using standard template format."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(sample_pe_binary), template_name="standard", num_keys=3)

        if keys:
            for key in keys:
                assert len(key) == len("####-####-####-####")
                assert key.count("-") == 3

    def test_generate_keygen_with_windows_template(self, sample_pe_binary: Path) -> None:
        """Generate keys using Windows product key template."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(sample_pe_binary), template_name="windows", num_keys=3)

        if keys:
            template = generator.templates["windows"]
            for key in keys:
                assert key.count("-") == 4
                clean_key = key.replace("-", "")
                assert all(c in template.charset for c in clean_key)

    def test_generate_keygen_with_adobe_template(self, sample_pe_binary: Path) -> None:
        """Generate keys using Adobe serial number template."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(sample_pe_binary), template_name="adobe", num_keys=3)

        if keys:
            for key in keys:
                clean_key = key.replace("-", "")
                assert all(c in string.digits for c in clean_key)

    def test_heuristic_generation_when_no_algorithm_found(self, sample_pe_binary: Path) -> None:
        """Heuristic generation creates keys when algorithm extraction fails."""
        generator = KeygenGenerator()

        keys = generator._heuristic_generation(template_name="simple", num_keys=5)

        assert len(keys) == 5
        for key in keys:
            assert len(key) >= 10
            assert all(c in string.ascii_uppercase + string.digits for c in key)

    def test_create_validator_for_checksum_algorithm(self) -> None:
        """Create validator function for checksum-based algorithms."""
        generator = KeygenGenerator()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["CRC32"],
        )

        validator = generator._create_validator(algorithm, "dummy.exe")
        assert callable(validator)

    def test_create_validator_for_rsa_algorithm(self) -> None:
        """Create validator function for RSA signature algorithms."""
        generator = KeygenGenerator()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x2000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA_verify"],
        )

        validator = generator._create_validator(algorithm, "dummy.exe")
        assert callable(validator)

    def test_validate_checksum_key_with_crc32(self) -> None:
        """Validate key using CRC32 checksum algorithm."""
        generator = KeygenGenerator()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x1000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["CRC32"],
        )

        data_part = "ABCD1234"
        crc_of_data = generator.solver._crc32(data_part.encode())
        valid_crc_suffix = f"{crc_of_data:08X}"
        valid_key = data_part + valid_crc_suffix

        result = generator._validate_checksum_key(valid_key, algorithm)
        assert result is True

    def test_validate_pattern_key_matches_format(self) -> None:
        """Validate key using pattern matching."""
        generator = KeygenGenerator()

        constraint = KeyConstraint(name="format", type="pattern", value="####-####-####", priority=1)
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.PATTERN_BASED,
            offset=0x3000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
            constraints=[constraint],
        )

        valid_key = "ABCD-1234-EFGH"
        result = generator._validate_pattern_key(valid_key, algorithm)
        assert result is True

    def test_validate_rsa_key_checks_format(self) -> None:
        """Validate RSA key checks minimum length requirement."""
        generator = KeygenGenerator()

        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.RSA_SIGNATURE,
            offset=0x2000,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=["RSA"],
        )

        valid_key = "ABCD1234EFGH5678IJKL"
        result = generator._validate_rsa_key(valid_key, algorithm)
        assert result is True

        invalid_key = "SHORT"
        result = generator._validate_rsa_key(invalid_key, algorithm)
        assert result is False


class TestBatchKeygenGeneration:
    """Test batch key generation and file output."""

    def test_batch_generate_creates_output_file(self, sample_pe_binary: Path, tmp_path: Path) -> None:
        """Batch generation creates output file with generated keys."""
        generator = KeygenGenerator()
        output_file = tmp_path / "keys.txt"

        keys = generator.batch_generate(
            str(sample_pe_binary),
            str(output_file),
            num_keys=10,
            template="standard",
        )

        assert output_file.exists()
        assert len(keys) <= 10

        with open(output_file) as f:
            file_keys = f.read().splitlines()
            assert len(file_keys) == len(keys)

    def test_batch_generate_creates_statistics_file(self, sample_pe_binary: Path, tmp_path: Path) -> None:
        """Batch generation creates statistics JSON file."""
        generator = KeygenGenerator()
        output_file = tmp_path / "keys.txt"

        generator.batch_generate(
            str(sample_pe_binary),
            str(output_file),
            num_keys=10,
            template="windows",
        )

        stats_file = tmp_path / "keys_stats.json"
        assert stats_file.exists()

        with open(stats_file) as f:
            stats = json.load(f)
            assert "total_generated" in stats
            assert "unique_keys" in stats
            assert "template_used" in stats
            assert stats["template_used"] == "windows"
            assert "algorithm_extracted" in stats

    def test_batch_generate_produces_unique_keys(self, sample_pe_binary: Path, tmp_path: Path) -> None:
        """Batch generation produces unique keys."""
        generator = KeygenGenerator()
        output_file = tmp_path / "keys.txt"

        keys = generator.batch_generate(
            str(sample_pe_binary),
            str(output_file),
            num_keys=20,
            template="simple",
        )

        unique_keys = set(keys)
        assert len(unique_keys) >= len(keys) * 0.9


class TestKeygenAgainstSpecificProtections:
    """Test keygen generation against specific protection schemes."""

    @pytest.mark.skipif(not (PROTECTED_BINARIES_DIR / "vmprotect_protected.exe").exists(), reason="VMProtect binary not available")
    def test_generate_keys_for_vmprotect_binary(self, vmprotect_binary: Path) -> None:
        """Generate keys for VMProtect-protected application."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(vmprotect_binary), template_name="standard", num_keys=5)

        assert isinstance(keys, list)
        if keys:
            assert all(isinstance(key, str) for key in keys)

    @pytest.mark.skipif(not (PROTECTED_BINARIES_DIR / "themida_protected.exe").exists(), reason="Themida binary not available")
    def test_generate_keys_for_themida_binary(self, themida_binary: Path) -> None:
        """Generate keys for Themida-protected application."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(themida_binary), template_name="standard", num_keys=5)

        assert isinstance(keys, list)

    @pytest.mark.skipif(not (PROTECTED_BINARIES_DIR / "flexlm_license_protected.exe").exists(), reason="FlexLM binary not available")
    def test_generate_keys_for_flexlm_binary(self, flexlm_binary: Path) -> None:
        """Generate keys for FlexLM-protected application."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(flexlm_binary), template_name="standard", num_keys=5)

        assert isinstance(keys, list)

    @pytest.mark.skipif(not (PROTECTED_BINARIES_DIR / "hasp_sentinel_protected.exe").exists(), reason="HASP binary not available")
    def test_generate_keys_for_hasp_binary(self, hasp_binary: Path) -> None:
        """Generate keys for HASP Sentinel protected application."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(hasp_binary), template_name="standard", num_keys=5)

        assert isinstance(keys, list)


class TestKeyConstraintValidation:
    """Test KeyConstraint dataclass and validation."""

    def test_key_constraint_creation(self) -> None:
        """KeyConstraint creates with required fields."""
        constraint = KeyConstraint(
            name="length",
            type="length",
            value=16,
            priority=1,
        )

        assert constraint.name == "length"
        assert constraint.type == "length"
        assert constraint.value == 16
        assert constraint.priority == 1
        assert constraint.optional is False

    def test_key_constraint_optional_field(self) -> None:
        """KeyConstraint supports optional field."""
        constraint = KeyConstraint(
            name="charset",
            type="charset",
            value="ABCDEF",
            priority=2,
            optional=True,
        )

        assert constraint.optional is True


class TestValidationAlgorithmStructure:
    """Test ValidationAlgorithm dataclass structure."""

    def test_validation_algorithm_creation(self) -> None:
        """ValidationAlgorithm creates with required fields."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.CHECKSUM,
            offset=0x401000,
            instructions=[("xor", "eax, eax"), ("add", "eax, 1")],
            constants=[0x1234, 0x5678],
            strings=["License", "Key"],
            crypto_operations=["CRC32"],
        )

        assert algorithm.type == KeyAlgorithmType.CHECKSUM
        assert algorithm.offset == 0x401000
        assert len(algorithm.instructions) == 2
        assert len(algorithm.constants) == 2
        assert len(algorithm.strings) == 2
        assert len(algorithm.crypto_operations) == 1

    def test_validation_algorithm_default_fields(self) -> None:
        """ValidationAlgorithm has correct default field values."""
        algorithm = ValidationAlgorithm(
            type=KeyAlgorithmType.UNKNOWN,
            offset=0,
            instructions=[],
            constants=[],
            strings=[],
            crypto_operations=[],
        )

        assert algorithm.constraints == []
        assert algorithm.confidence == 0.0


class TestKeygenTemplateStructure:
    """Test KeygenTemplate dataclass structure."""

    def test_keygen_template_creation(self) -> None:
        """KeygenTemplate creates with required fields."""
        template = KeygenTemplate(
            format="####-####-####",
            charset=string.ascii_uppercase + string.digits,
            checksum_algorithm="crc32",
        )

        assert template.format == "####-####-####"
        assert template.charset == string.ascii_uppercase + string.digits
        assert template.checksum_algorithm == "crc32"

    def test_keygen_template_default_fields(self) -> None:
        """KeygenTemplate has correct default field values."""
        template = KeygenTemplate(
            format="####",
            charset="ABCD",
        )

        assert template.checksum_algorithm is None
        assert template.crypto_params == {}
        assert template.constraints == []


class TestKeyAlgorithmTypeEnum:
    """Test KeyAlgorithmType enumeration."""

    def test_key_algorithm_type_values(self) -> None:
        """KeyAlgorithmType has all expected values."""
        assert KeyAlgorithmType.UNKNOWN == 0
        assert KeyAlgorithmType.CHECKSUM == 1
        assert KeyAlgorithmType.CRYPTOGRAPHIC == 2
        assert KeyAlgorithmType.MATHEMATICAL == 3
        assert KeyAlgorithmType.PATTERN_BASED == 4
        assert KeyAlgorithmType.BLACKLIST == 5
        assert KeyAlgorithmType.HARDWARE_TIED == 6
        assert KeyAlgorithmType.TIME_BASED == 7
        assert KeyAlgorithmType.RSA_SIGNATURE == 8
        assert KeyAlgorithmType.ECC_SIGNATURE == 9
        assert KeyAlgorithmType.SYMMETRIC_CRYPTO == 10
        assert KeyAlgorithmType.CUSTOM_ALGORITHM == 11


class TestEdgeCasesAndErrorHandling:
    """Test edge cases and error handling."""

    def test_extract_algorithm_handles_nonexistent_file(self) -> None:
        """Algorithm extraction handles nonexistent binary file."""
        extractor = AlgorithmExtractor()

        algorithms = extractor.extract_algorithm("nonexistent_file.exe")

        assert algorithms == []

    def test_generate_keygen_handles_invalid_template(self, sample_pe_binary: Path) -> None:
        """Keygen generation handles invalid template name gracefully."""
        generator = KeygenGenerator()

        keys = generator.generate_keygen(str(sample_pe_binary), template_name="invalid_template", num_keys=5)

        assert isinstance(keys, list)

    def test_solver_handles_empty_constraints(self) -> None:
        """Solver handles empty constraint list."""
        solver = ConstraintSolver()

        template = KeygenTemplate(
            format="####-####",
            charset=string.ascii_uppercase,
        )

        key = solver.solve_constraints([], template)

        assert key is None or isinstance(key, str)

    def test_explorer_handles_impossible_constraints(self) -> None:
        """Explorer handles impossible constraint combinations."""
        explorer = KeySpaceExplorer()

        template = KeygenTemplate(format="##", charset="AB")
        constraint = KeyConstraint(name="length", type="length", value=100, priority=1)

        def validator(key: str) -> bool:
            return False

        valid_keys = explorer.explore_keyspace(template, [constraint], validator, max_keys=5)

        assert len(valid_keys) == 0

    def test_batch_generate_handles_zero_keys(self, sample_pe_binary: Path, tmp_path: Path) -> None:
        """Batch generation handles request for zero keys."""
        generator = KeygenGenerator()
        output_file = tmp_path / "keys.txt"

        keys = generator.batch_generate(str(sample_pe_binary), str(output_file), num_keys=0)

        assert len(keys) == 0
