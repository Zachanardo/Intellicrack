"""Production tests for exploit developer module.

Tests real exploit payload generation and template-based exploit creation.
"""

import struct

import pytest

from intellicrack.core.vulnerability_research.exploit_developer import (
    ExploitDeveloper,
    ExploitTemplate,
)


@pytest.fixture
def exploit_dev() -> ExploitDeveloper:
    """Create exploit developer instance."""
    return ExploitDeveloper()


def test_exploit_developer_initialization(exploit_dev: ExploitDeveloper) -> None:
    """Test exploit developer initializes correctly."""
    assert len(exploit_dev.templates) == 0
    assert "buffer_overflow" in exploit_dev.techniques
    assert "format_string" in exploit_dev.techniques
    assert "use_after_free" in exploit_dev.techniques


def test_develop_buffer_overflow_exploit(exploit_dev: ExploitDeveloper) -> None:
    """Test buffer overflow exploit generation."""
    vuln_info = {
        "type": "buffer_overflow",
        "target_address": 0x08048400,
    }

    result = exploit_dev.develop_exploit(vuln_info)

    assert result["success"] is True
    assert result["exploit_type"] == "buffer_overflow"
    assert isinstance(result["payload"], bytes)
    assert len(result["payload"]) > 0
    assert b"\x90" in result["payload"]
    assert struct.pack("<I", 0x08048400) in result["payload"]


def test_develop_use_after_free_exploit(exploit_dev: ExploitDeveloper) -> None:
    """Test use-after-free exploit generation."""
    vuln_info = {
        "type": "use_after_free",
        "target_address": 0x41414141,
    }

    result = exploit_dev.develop_exploit(vuln_info)

    assert result["success"] is True
    assert result["exploit_type"] == "use_after_free"
    assert isinstance(result["payload"], bytes)
    assert struct.pack("<Q", 0x41414141) in result["payload"]


def test_develop_format_string_exploit(exploit_dev: ExploitDeveloper) -> None:
    """Test format string exploit generation."""
    vuln_info = {
        "type": "format_string",
        "target_address": 0x08049000,
    }

    result = exploit_dev.develop_exploit(vuln_info)

    assert result["success"] is True
    assert result["exploit_type"] == "format_string"
    assert b"%x" in result["payload"]
    assert b"%n" in result["payload"]


def test_develop_default_rop_exploit(exploit_dev: ExploitDeveloper) -> None:
    """Test default ROP chain generation."""
    vuln_info = {
        "type": "return_oriented_programming",
        "target_address": 0x12345678,
    }

    result = exploit_dev.develop_exploit(vuln_info)

    assert result["success"] is True
    assert isinstance(result["payload"], bytes)
    assert len(result["payload"]) > 0


def test_exploit_metadata(exploit_dev: ExploitDeveloper) -> None:
    """Test exploit metadata is populated."""
    vuln_info = {"type": "buffer_overflow", "target_address": 0x1000}

    result = exploit_dev.develop_exploit(vuln_info)

    assert "metadata" in result
    metadata = result["metadata"]
    assert "technique" in metadata
    assert "reliability" in metadata
    assert "payload_size" in metadata
    assert "target_address" in metadata
    assert metadata["target_address"] == "0x1000"


def test_exploit_template_initialization() -> None:
    """Test exploit template initialization."""
    template = ExploitTemplate("buffer_overflow")

    assert template.exploit_type == "buffer_overflow"
    assert template.template == ""


def test_template_generate_buffer_overflow() -> None:
    """Test buffer overflow template generation."""
    template = ExploitTemplate("buffer_overflow")

    params = {
        "architecture": "x86",
        "os": "linux",
        "buffer_size": 256,
        "offset": 128,
        "return_address": 0x08048400,
        "bad_chars": [],
    }

    result = template.generate(params)

    assert result["success"] is True
    assert isinstance(result["exploit"], str)
    assert len(result["exploit"]) > 0
    assert result["metadata"]["type"] == "buffer_overflow"


def test_template_generate_format_string() -> None:
    """Test format string template generation."""
    template = ExploitTemplate("format_string")

    params = {
        "architecture": "x86",
        "os": "linux",
        "format_writes": [
            {"address": 0x08049000, "value": 0x41424344},
        ],
        "format_offset": 4,
    }

    result = template.generate(params)

    assert result["success"] is True
    assert "format" in result["exploit"] or "%" in result["exploit"]


def test_template_generate_use_after_free() -> None:
    """Test UAF template generation."""
    template = ExploitTemplate("use_after_free")

    params = {
        "architecture": "x64",
        "os": "linux",
        "object_size": 64,
        "spray_count": 100,
        "hijacked_vtable": 0x7f00001000,
    }

    result = template.generate(params)

    assert result["success"] is True
    assert "Heap spray" in result["exploit"]
    assert "vtable" in result["exploit"]


def test_template_generate_integer_overflow() -> None:
    """Test integer overflow template generation."""
    template = ExploitTemplate("integer_overflow")

    params = {
        "architecture": "x86",
        "os": "windows",
        "overflow_value": 0xFFFFFFFF,
        "calculation": "multiply",
    }

    result = template.generate(params)

    assert result["success"] is True
    assert "overflow" in result["exploit"]


def test_template_architecture_specific_code() -> None:
    """Test architecture-specific code generation."""
    template = ExploitTemplate("buffer_overflow")

    x86_result = template.generate({"architecture": "x86", "os": "linux"})
    x64_result = template.generate({"architecture": "x64", "os": "linux"})
    arm_result = template.generate({"architecture": "arm", "os": "linux"})

    assert x86_result["metadata"]["architecture"] == "x86"
    assert x64_result["metadata"]["architecture"] == "x64"
    assert arm_result["metadata"]["architecture"] == "arm"


def test_template_os_specific_code() -> None:
    """Test OS-specific code generation."""
    template = ExploitTemplate("buffer_overflow")

    windows_result = template.generate({"architecture": "x86", "os": "windows"})
    linux_result = template.generate({"architecture": "x86", "os": "linux"})

    assert windows_result["metadata"]["os"] == "windows"
    assert linux_result["metadata"]["os"] == "linux"


def test_template_bad_char_avoidance() -> None:
    """Test bad character avoidance."""
    template = ExploitTemplate("buffer_overflow")

    params = {
        "architecture": "x86",
        "os": "linux",
        "bad_chars": ["\\x90", "\\x00"],
        "buffer_size": 100,
    }

    result = template.generate(params)

    assert result["metadata"]["bad_chars_avoided"] == 2


def test_template_custom_shellcode() -> None:
    """Test custom shellcode injection."""
    template = ExploitTemplate("buffer_overflow")

    params = {
        "architecture": "x86",
        "os": "linux",
        "shellcode": "\\x31\\xc0\\x50\\x68",
        "bad_chars": [],
    }

    result = template.generate(params)

    assert result["success"] is True


def test_template_payload_size_limit() -> None:
    """Test payload size limiting."""
    template = ExploitTemplate("buffer_overflow")

    params = {
        "architecture": "x86",
        "os": "linux",
        "buffer_size": 1000,
        "payload_size": 50,
    }

    result = template.generate(params)

    assert len(result["exploit"]) <= 50


def test_template_metadata_completeness() -> None:
    """Test exploit metadata is complete."""
    template = ExploitTemplate("buffer_overflow")

    params = {
        "architecture": "x86",
        "os": "linux",
        "buffer_size": 256,
        "custom_param": "value",
    }

    result = template.generate(params)

    metadata = result["metadata"]
    assert "type" in metadata
    assert "architecture" in metadata
    assert "os" in metadata
    assert "size" in metadata
    assert "bad_chars_avoided" in metadata
    assert "params_used" in metadata
    assert "custom_param" in metadata["params_used"]


def test_multiple_exploit_types(exploit_dev: ExploitDeveloper) -> None:
    """Test generating multiple exploit types."""
    types = ["buffer_overflow", "use_after_free", "format_string", "double_free", "integer_overflow"]

    for exploit_type in types:
        vuln_info = {"type": exploit_type, "target_address": 0x41414141}
        result = exploit_dev.develop_exploit(vuln_info)

        assert result["success"] is True
        assert result["exploit_type"] == exploit_type


def test_exploit_template_vtable_address_legacy_param() -> None:
    """Test UAF template supports legacy vtable_address parameter."""
    template = ExploitTemplate("use_after_free")

    params = {
        "architecture": "x64",
        "os": "linux",
        "object_size": 64,
        "spray_count": 100,
        "vtable_address": 0x7f00001000,
    }

    result = template.generate(params)

    assert result["success"] is True
    assert "vtable" in result["exploit"]
