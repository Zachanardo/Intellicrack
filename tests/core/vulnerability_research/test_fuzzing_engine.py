"""Comprehensive production-grade tests for fuzzing_engine.py.

This test suite validates REAL fuzzing capabilities against actual binaries.
Tests MUST FAIL when fuzzing functionality breaks.
NO mocks for fuzzing operations - all tests use real data and real processes.
"""

import hashlib
import os
import struct
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.vulnerability_research.fuzzing_engine import (
    CrashSeverity,
    FuzzingEngine,
    FuzzingStrategy,
)


@pytest.fixture
def fuzzing_engine() -> FuzzingEngine:
    """Create fuzzing engine instance."""
    return FuzzingEngine()


@pytest.fixture
def vulnerable_binary(temp_workspace: Path) -> Path:
    """Create a simple vulnerable test binary that crashes on specific input."""
    binary_path = temp_workspace / "vulnerable_test.py"

    vulnerable_code = '''#!/usr/bin/env python3
import sys

if len(sys.argv) < 2:
    sys.exit(0)

with open(sys.argv[1], 'rb') as f:
    data = f.read()

if b"CRASH" in data:
    raise Exception("Intentional crash for fuzzing test")

if len(data) > 1000 and data[0:4] == b"AAAA":
    raise Exception("Buffer overflow simulation")

if b"%n%n%n" in data:
    raise Exception("Format string vulnerability simulation")

sys.exit(0)
'''

    binary_path.write_text(vulnerable_code)
    binary_path.chmod(0o755)

    return binary_path


@pytest.fixture
def seed_files(temp_workspace: Path) -> list[str]:
    """Create seed input files for fuzzing."""
    seeds_dir = temp_workspace / "seeds"
    seeds_dir.mkdir(exist_ok=True)

    seed_data = [
        b"AAAA",
        b"test input",
        b"\x00\x01\x02\x03",
        b"normal data",
        b"A" * 50,
    ]

    seed_paths = []
    for i, data in enumerate(seed_data):
        seed_path = seeds_dir / f"seed_{i}.dat"
        seed_path.write_bytes(data)
        seed_paths.append(str(seed_path))

    return seed_paths


class TestFuzzingEngineInitialization:
    """Test fuzzing engine initialization and configuration."""

    def test_initialization_creates_default_config(self, fuzzing_engine: FuzzingEngine) -> None:
        """Engine initializes with default configuration values."""
        assert fuzzing_engine.config["max_iterations"] == 10000
        assert fuzzing_engine.config["max_file_size"] == 1024 * 1024
        assert fuzzing_engine.config["timeout"] == 30
        assert fuzzing_engine.config["crash_detection"] is True
        assert 0.0 < fuzzing_engine.config["mutation_rate"] <= 1.0
        assert 0.0 < fuzzing_engine.config["crossover_rate"] <= 1.0

    def test_initialization_creates_mutation_strategies(self, fuzzing_engine: FuzzingEngine) -> None:
        """Engine initializes with all mutation strategies."""
        expected_strategies = {
            "bit_flip",
            "byte_flip",
            "arithmetic",
            "insert",
            "delete",
            "duplicate",
            "splice",
            "magic_values",
            "string_replace",
            "format_aware",
        }

        assert set(fuzzing_engine.mutation_strategies.keys()) == expected_strategies

        for strategy_name, strategy_func in fuzzing_engine.mutation_strategies.items():
            assert callable(strategy_func)

    def test_initialization_creates_file_grammars(self, fuzzing_engine: FuzzingEngine) -> None:
        """Engine initializes with file format grammar generators."""
        expected_grammars = {"text", "xml", "json", "http", "binary"}

        assert set(fuzzing_engine.file_grammars.keys()) == expected_grammars

        for grammar_name, grammar_func in fuzzing_engine.file_grammars.items():
            assert callable(grammar_func)

    def test_initialization_creates_magic_values(self, fuzzing_engine: FuzzingEngine) -> None:
        """Engine initializes with magic values for mutations."""
        assert "integers" in fuzzing_engine.magic_values
        assert "strings" in fuzzing_engine.magic_values
        assert "format_strings" in fuzzing_engine.magic_values
        assert "special_chars" in fuzzing_engine.magic_values

        assert 0 in fuzzing_engine.magic_values["integers"]
        assert -1 in fuzzing_engine.magic_values["integers"]
        assert 2147483647 in fuzzing_engine.magic_values["integers"]

        assert b"%n" in fuzzing_engine.magic_values["format_strings"]

    def test_initialization_creates_empty_statistics(self, fuzzing_engine: FuzzingEngine) -> None:
        """Engine initializes with empty statistics tracking."""
        assert fuzzing_engine.stats["total_executions"] == 0
        assert fuzzing_engine.stats["crashes_found"] == 0
        assert fuzzing_engine.stats["unique_crashes"] == 0
        assert fuzzing_engine.stats["hangs_found"] == 0
        assert fuzzing_engine.stats["coverage_paths"] == 0


class TestMutationStrategies:
    """Test individual mutation strategy implementations."""

    def test_mutate_bit_flip_changes_single_bit(self, fuzzing_engine: FuzzingEngine) -> None:
        """Bit flip mutation changes exactly one bit in data."""
        original = bytearray(b"\x00\x00\x00\x00")

        for _ in range(10):
            mutated = fuzzing_engine._mutate_bit_flip(original.copy())

            assert len(mutated) == len(original)

            bit_differences = 0
            for orig_byte, mut_byte in zip(original, mutated):
                xor_result = orig_byte ^ mut_byte
                bit_differences += bin(xor_result).count('1')

            assert bit_differences >= 1

    def test_mutate_byte_flip_changes_byte_value(self, fuzzing_engine: FuzzingEngine) -> None:
        """Byte flip mutation changes byte values."""
        original = bytearray(b"AAAA")

        mutated = fuzzing_engine._mutate_byte_flip(original.copy())

        assert len(mutated) == len(original)

    def test_mutate_arithmetic_modifies_integer_values(self, fuzzing_engine: FuzzingEngine) -> None:
        """Arithmetic mutation modifies integer values in data."""
        original = bytearray(struct.pack("<HH", 1000, 2000))

        mutated = fuzzing_engine._mutate_arithmetic(original.copy())

        assert len(mutated) == len(original)

    def test_mutate_insert_increases_data_size(self, fuzzing_engine: FuzzingEngine) -> None:
        """Insert mutation increases data size."""
        original = bytearray(b"test")

        mutated = fuzzing_engine._mutate_insert(original.copy())

        assert len(mutated) > len(original)

    def test_mutate_delete_decreases_data_size(self, fuzzing_engine: FuzzingEngine) -> None:
        """Delete mutation decreases data size."""
        original = bytearray(b"A" * 20)

        mutated = fuzzing_engine._mutate_delete(original.copy())

        assert len(mutated) <= len(original)

    def test_mutate_duplicate_copies_chunk(self, fuzzing_engine: FuzzingEngine) -> None:
        """Duplicate mutation copies chunks of data."""
        original = bytearray(b"ABCDEFGH")

        mutated = fuzzing_engine._mutate_duplicate(original.copy())

        assert len(mutated) > len(original)

    def test_mutate_splice_inserts_magic_values(self, fuzzing_engine: FuzzingEngine) -> None:
        """Splice mutation inserts magic values."""
        original = bytearray(b"test data")

        mutated = fuzzing_engine._mutate_splice(original.copy())

        assert len(mutated) > len(original)

    def test_mutate_magic_values_replaces_with_integers(self, fuzzing_engine: FuzzingEngine) -> None:
        """Magic values mutation replaces data with magic integers."""
        original = bytearray(b"\x00" * 8)

        mutated = fuzzing_engine._mutate_magic_values(original.copy())

        assert len(mutated) == len(original)

    def test_mutate_string_replace_inserts_format_strings(self, fuzzing_engine: FuzzingEngine) -> None:
        """String replace mutation inserts format string payloads."""
        original = bytearray(b"A" * 20)

        mutated = fuzzing_engine._mutate_string_replace(original.copy())

        assert len(mutated) == len(original)

    def test_mutate_empty_data_returns_safely(self, fuzzing_engine: FuzzingEngine) -> None:
        """Mutations handle empty data safely."""
        empty = bytearray(b"")

        assert fuzzing_engine._mutate_bit_flip(empty) == empty
        assert fuzzing_engine._mutate_byte_flip(empty) == empty
        assert fuzzing_engine._mutate_splice(empty) == empty


class TestInputGeneration:
    """Test input generation patterns."""

    def test_generate_overflow_pattern_creates_large_buffer(self, fuzzing_engine: FuzzingEngine) -> None:
        """Overflow pattern generates large buffers."""
        pattern = fuzzing_engine._generate_overflow_pattern()

        assert len(pattern) >= 100
        assert len(pattern) <= 2000

    def test_generate_format_string_pattern_creates_format_strings(self, fuzzing_engine: FuzzingEngine) -> None:
        """Format string pattern generates format specifiers."""
        pattern = fuzzing_engine._generate_format_string_pattern()

        assert b"%" in pattern
        assert any(fmt in pattern for fmt in [b"%s", b"%x", b"%n", b"%p", b"%d"])

    def test_generate_unicode_pattern_creates_unicode_markers(self, fuzzing_engine: FuzzingEngine) -> None:
        """Unicode pattern generates BOM markers."""
        pattern = fuzzing_engine._generate_unicode_pattern()

        assert len(pattern) > 0
        unicode_markers = [b"\xff\xfe", b"\xfe\xff", b"\xef\xbb\xbf"]
        assert any(marker in pattern for marker in unicode_markers)

    def test_generate_binary_pattern_creates_random_bytes(self, fuzzing_engine: FuzzingEngine) -> None:
        """Binary pattern generates random bytes."""
        pattern = fuzzing_engine._generate_binary_pattern()

        assert 10 <= len(pattern) <= 1000
        assert isinstance(pattern, bytes)


class TestGrammarGeneration:
    """Test file format grammar generators."""

    def test_generate_text_grammar_creates_valid_text(self, fuzzing_engine: FuzzingEngine) -> None:
        """Text grammar generates word-based text."""
        text = fuzzing_engine._generate_text_grammar()

        assert len(text) > 0
        assert b" " in text or len(text.split()) == 1

    def test_generate_xml_grammar_creates_valid_xml(self, fuzzing_engine: FuzzingEngine) -> None:
        """XML grammar generates well-formed XML."""
        xml = fuzzing_engine._generate_xml_grammar()

        assert xml.startswith(b'<?xml version="1.0"?>')
        assert b"<" in xml and b">" in xml
        assert xml.count(b"<") == xml.count(b">")

    def test_generate_json_grammar_creates_valid_json(self, fuzzing_engine: FuzzingEngine) -> None:
        """JSON grammar generates JSON structure."""
        json_data = fuzzing_engine._generate_json_grammar()

        assert json_data.startswith(b"{")
        assert json_data.endswith(b"}")
        assert b":" in json_data

    def test_generate_http_grammar_creates_http_request(self, fuzzing_engine: FuzzingEngine) -> None:
        """HTTP grammar generates HTTP request."""
        http = fuzzing_engine._generate_http_grammar()

        assert any(method in http for method in [b"GET", b"POST", b"PUT"])
        assert b"HTTP/1.1" in http
        assert b"Host:" in http

    def test_generate_binary_grammar_creates_binary_data(self, fuzzing_engine: FuzzingEngine) -> None:
        """Binary grammar generates binary with header."""
        binary = fuzzing_engine._generate_binary_grammar()

        assert len(binary) > 4
        assert binary[:4] == b"BIN\x00"


class TestFileFormatDetection:
    """Test file format detection from seeds."""

    def test_detect_xml_format(self, fuzzing_engine: FuzzingEngine, temp_workspace: Path) -> None:
        """Detects XML file format."""
        xml_file = temp_workspace / "test.xml"
        xml_file.write_bytes(b'<?xml version="1.0"?><root>test</root>')

        format_type = fuzzing_engine._detect_file_format([str(xml_file)])

        assert format_type == "xml"

    def test_detect_json_format(self, fuzzing_engine: FuzzingEngine, temp_workspace: Path) -> None:
        """Detects JSON file format."""
        json_file = temp_workspace / "test.json"
        json_file.write_bytes(b'{"key": "value"}')

        format_type = fuzzing_engine._detect_file_format([str(json_file)])

        assert format_type == "json"

    def test_detect_http_format(self, fuzzing_engine: FuzzingEngine, temp_workspace: Path) -> None:
        """Detects HTTP protocol format."""
        http_file = temp_workspace / "test.http"
        http_file.write_bytes(b"GET / HTTP/1.1\r\nHost: test\r\n\r\n")

        format_type = fuzzing_engine._detect_file_format([str(http_file)])

        assert format_type == "http"

    def test_detect_text_format(self, fuzzing_engine: FuzzingEngine, temp_workspace: Path) -> None:
        """Detects text file format."""
        text_file = temp_workspace / "test.txt"
        text_file.write_bytes(b"plain text data")

        format_type = fuzzing_engine._detect_file_format([str(text_file)])

        assert format_type == "text"

    def test_detect_binary_format(self, fuzzing_engine: FuzzingEngine, temp_workspace: Path) -> None:
        """Detects binary file format."""
        bin_file = temp_workspace / "test.bin"
        bin_file.write_bytes(b"\x00\x01\x02\x03\xff\xfe\xfd")

        format_type = fuzzing_engine._detect_file_format([str(bin_file)])

        assert format_type == "binary"


class TestTargetExecution:
    """Test target execution and crash detection."""

    def test_execute_target_runs_command(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Execute target runs command with input file."""
        test_script = temp_workspace / "echo_test.py"
        test_script.write_text('#!/usr/bin/env python3\nimport sys\nprint("OK")')
        test_script.chmod(0o755)

        input_data = b"test input"
        command = f"python3 {test_script} @@@"

        result = fuzzing_engine._execute_target(command, input_data, str(temp_workspace))

        assert "exit_code" in result
        assert "crashed" in result
        assert "execution_time" in result

    def test_execute_target_detects_crash(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, temp_workspace: Path
    ) -> None:
        """Execute target detects crashes."""
        crash_input = b"CRASH trigger"
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine._execute_target(command, crash_input, str(temp_workspace))

        assert result["crashed"] is True or result["exit_code"] != 0

    def test_execute_target_handles_timeout(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Execute target handles timeouts."""
        hang_script = temp_workspace / "hang.py"
        hang_script.write_text('#!/usr/bin/env python3\nimport time\ntime.sleep(100)')
        hang_script.chmod(0o755)

        fuzzing_engine.config["timeout"] = 1
        command = f"python3 {hang_script} @@@"

        result = fuzzing_engine._execute_target(command, b"test", str(temp_workspace))

        assert result["hanged"] is True


class TestCrashProcessing:
    """Test crash detection and processing."""

    def test_process_crash_saves_crash_file(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Process crash saves crash input to file."""
        output_dir = str(temp_workspace)
        os.makedirs(os.path.join(output_dir, "crashes"), exist_ok=True)

        execution_result = {
            "crashed": True,
            "exit_code": -11,
            "signal": 11,
            "stderr": "Segmentation fault",
            "execution_time": 0.5,
        }

        crash_input = b"crash triggering input"

        crash_info = fuzzing_engine._process_crash(
            execution_result, crash_input, output_dir, iteration=1
        )

        assert crash_info["crash_file"] is not None
        assert os.path.exists(crash_info["crash_file"])
        assert crash_info["iteration"] == 1
        assert crash_info["input_size"] == len(crash_input)

    def test_calculate_crash_hash_identifies_unique_crashes(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Calculate crash hash identifies unique crashes."""
        crash1 = {"exit_code": -11, "signal": 11, "stderr": "Segmentation fault"}
        crash2 = {"exit_code": -11, "signal": 11, "stderr": "Segmentation fault"}
        crash3 = {"exit_code": -6, "signal": 6, "stderr": "Abort"}

        hash1 = fuzzing_engine._calculate_crash_hash(crash1)
        hash2 = fuzzing_engine._calculate_crash_hash(crash2)
        hash3 = fuzzing_engine._calculate_crash_hash(crash3)

        assert hash1 == hash2
        assert hash1 != hash3


class TestFuzzingCampaigns:
    """Test complete fuzzing campaigns."""

    def test_start_fuzzing_validates_command_format(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Start fuzzing validates command contains @@@ marker."""
        result = fuzzing_engine.start_fuzzing(
            target_command="./binary input.txt",
            max_iterations=10,
        )

        assert result["success"] is False
        assert "substitution marker" in result["error"].lower()

    def test_start_fuzzing_random_strategy(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, seed_files: list[str]
    ) -> None:
        """Random fuzzing strategy generates random inputs."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=seed_files,
            strategy=FuzzingStrategy.RANDOM,
            max_iterations=50,
        )

        assert result["success"] is True
        assert result["iterations_completed"] > 0
        assert "statistics" in result

    def test_start_fuzzing_mutation_strategy(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, seed_files: list[str]
    ) -> None:
        """Mutation fuzzing mutates seed inputs."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=seed_files,
            strategy=FuzzingStrategy.MUTATION,
            max_iterations=50,
        )

        assert result["success"] is True
        assert result["iterations_completed"] > 0

    def test_start_fuzzing_generation_strategy(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path
    ) -> None:
        """Generation fuzzing generates structured inputs."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            strategy=FuzzingStrategy.GENERATION,
            max_iterations=50,
        )

        assert result["success"] is True
        assert result["iterations_completed"] > 0

    def test_start_fuzzing_grammar_strategy(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, seed_files: list[str]
    ) -> None:
        """Grammar-based fuzzing uses file format grammars."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=seed_files,
            strategy=FuzzingStrategy.GRAMMAR_BASED,
            max_iterations=50,
        )

        assert result["success"] is True
        assert result["iterations_completed"] > 0

    def test_start_fuzzing_hybrid_strategy(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, seed_files: list[str]
    ) -> None:
        """Hybrid fuzzing combines multiple strategies."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=seed_files,
            strategy=FuzzingStrategy.HYBRID,
            max_iterations=100,
        )

        assert result["success"] is True
        assert result["iterations_completed"] > 0

    def test_start_fuzzing_finds_crashes(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, temp_workspace: Path
    ) -> None:
        """Fuzzing campaign finds crashes in vulnerable binary."""
        crash_seed = temp_workspace / "crash_seed.dat"
        crash_seed.write_bytes(b"CRAS")

        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=[str(crash_seed)],
            strategy=FuzzingStrategy.MUTATION,
            max_iterations=200,
        )

        assert result["success"] is True


class TestCrashAnalysis:
    """Test crash analysis and exploitability assessment."""

    def test_analyze_crash_handles_missing_file(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Analyze crash handles missing crash file."""
        result = fuzzing_engine.analyze_crash(
            crash_file="/nonexistent/crash.dat",
            target_command="./binary @@@",
        )

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_analyze_crash_pattern_analyzes_input(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Analyze crash pattern examines crash input."""
        crash_file = temp_workspace / "crash_input.dat"
        crash_data = b"CRASH" * 100 + b"%n%n%n"
        crash_file.write_bytes(crash_data)

        analysis = fuzzing_engine._analyze_crash_pattern(str(crash_file))

        assert "input_size" in analysis
        assert "entropy" in analysis
        assert "repeated_patterns" in analysis


class TestTestcaseMinimization:
    """Test crash testcase minimization."""

    def test_minimize_testcase_handles_missing_file(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Minimize testcase handles missing crash file."""
        result = fuzzing_engine.minimize_testcase(
            crash_file="/nonexistent/crash.dat",
            target_command="./binary @@@",
        )

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_minimize_binary_search_reduces_input_size(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, temp_workspace: Path
    ) -> None:
        """Binary search minimization reduces input size."""
        crash_input = b"CRASH trigger with extra padding" * 10
        crash_file = temp_workspace / "large_crash.dat"
        crash_file.write_bytes(crash_input)

        command = f"python3 {vulnerable_binary} @@@"

        minimized = fuzzing_engine._minimize_binary_search(crash_input, command)

        assert len(minimized) <= len(crash_input)

    def test_minimize_delta_debugging_reduces_input(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path, temp_workspace: Path
    ) -> None:
        """Delta debugging minimizes crash input."""
        crash_input = b"prefix CRASH suffix" * 5

        command = f"python3 {vulnerable_binary} @@@"

        minimized = fuzzing_engine._minimize_delta_debugging(crash_input, command)

        assert len(minimized) <= len(crash_input)


class TestCoverageGuidedFuzzing:
    """Test coverage-guided fuzzing capabilities."""

    def test_check_execution_paths_detects_new_paths(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Execution path tracking detects new paths."""
        coverage_dir = str(temp_workspace / "coverage")
        os.makedirs(coverage_dir, exist_ok=True)

        result1 = {"exit_code": 0, "stdout": "output1", "stderr": "", "crashed": False, "hanged": False}
        result2 = {"exit_code": 0, "stdout": "output2", "stderr": "", "crashed": False, "hanged": False}
        result3 = {"exit_code": 0, "stdout": "output1", "stderr": "", "crashed": False, "hanged": False}

        new_path1 = fuzzing_engine._check_execution_paths(result1, coverage_dir)
        new_path2 = fuzzing_engine._check_execution_paths(result2, coverage_dir)
        new_path3 = fuzzing_engine._check_execution_paths(result3, coverage_dir)

        assert new_path1 is True
        assert new_path2 is True
        assert new_path3 is False


class TestHelperMethods:
    """Test helper and utility methods."""

    def test_generate_default_seeds_creates_seed_files(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Generate default seeds creates valid seed files."""
        seeds = fuzzing_engine._generate_default_seeds()

        assert len(seeds) > 0
        for seed_file in seeds:
            assert os.path.exists(seed_file)
            assert os.path.getsize(seed_file) > 0

    def test_randomize_data_mutates_bytes(self, fuzzing_engine: FuzzingEngine) -> None:
        """Randomize data mutates byte values."""
        original = b"A" * 100

        randomized = fuzzing_engine._randomize_data(original)

        assert len(randomized) == len(original)

    def test_is_interesting_input_identifies_interesting_executions(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Is interesting input identifies valuable executions."""
        fuzzing_engine.config["timeout"] = 10

        boring = {"new_coverage": False, "hanged": False, "execution_time": 0.1}
        interesting_coverage = {"new_coverage": True, "hanged": False, "execution_time": 0.1}
        interesting_hang = {"new_coverage": False, "hanged": True, "execution_time": 0.1}
        interesting_slow = {"new_coverage": False, "hanged": False, "execution_time": 9.0}

        assert fuzzing_engine._is_interesting_input(boring) is False
        assert fuzzing_engine._is_interesting_input(interesting_coverage) is True
        assert fuzzing_engine._is_interesting_input(interesting_hang) is True
        assert fuzzing_engine._is_interesting_input(interesting_slow) is True

    def test_select_strategy_uses_probabilities(self, fuzzing_engine: FuzzingEngine) -> None:
        """Select strategy chooses based on probability weights."""
        strategies = [
            ("strategy1", 0.6),
            ("strategy2", 0.3),
            ("strategy3", 0.1),
        ]

        selected_strategies = set()
        for _ in range(100):
            selected = fuzzing_engine._select_strategy(strategies)
            selected_strategies.add(selected)

        assert "strategy1" in selected_strategies

    def test_create_output_directories_creates_structure(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Create output directories creates campaign structure."""
        campaign_id = fuzzing_engine._generate_campaign_id()

        output_dir = fuzzing_engine._create_output_directories(campaign_id)

        assert os.path.isdir(output_dir)
        assert os.path.isdir(os.path.join(output_dir, "crashes"))
        assert os.path.isdir(os.path.join(output_dir, "hangs"))
        assert os.path.isdir(os.path.join(output_dir, "queue"))

    def test_generate_campaign_id_creates_unique_ids(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Generate campaign ID creates unique identifiers."""
        id1 = fuzzing_engine._generate_campaign_id()
        time.sleep(0.01)
        id2 = fuzzing_engine._generate_campaign_id()

        assert id1 != id2
        assert len(id1) == 12
        assert len(id2) == 12

    def test_generate_crash_id_creates_unique_ids(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Generate crash ID creates unique identifiers."""
        id1 = fuzzing_engine._generate_crash_id()
        time.sleep(0.01)
        id2 = fuzzing_engine._generate_crash_id()

        assert id1 != id2
        assert len(id1) == 8
        assert len(id2) == 8


class TestStatisticsAndReporting:
    """Test statistics collection and result reporting."""

    def test_get_statistics_returns_stats(self, fuzzing_engine: FuzzingEngine) -> None:
        """Get statistics returns current fuzzing statistics."""
        fuzzing_engine.stats["total_executions"] = 1000
        fuzzing_engine.stats["crashes_found"] = 5

        stats = fuzzing_engine.get_statistics()

        assert stats["total_executions"] == 1000
        assert stats["crashes_found"] == 5

    def test_get_crashes_returns_crash_info(self, fuzzing_engine: FuzzingEngine) -> None:
        """Get crashes returns crash information."""
        fuzzing_engine.stats["crashes_found"] = 10
        fuzzing_engine.stats["unique_crashes"] = 3

        crashes = fuzzing_engine.get_crashes()

        assert crashes["total_crashes"] == 10
        assert crashes["unique_crashes"] == 3
        assert "crash_details" in crashes

    def test_export_results_creates_json_file(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Export results creates JSON output file."""
        output_file = temp_workspace / "results.json"

        fuzzing_engine.stats["total_executions"] = 100
        fuzzing_engine.stats["crashes_found"] = 2

        success = fuzzing_engine.export_results(str(output_file), format="json")

        assert success is True
        assert output_file.exists()

        import json
        with open(output_file) as f:
            data = json.load(f)

        assert "statistics" in data
        assert "crashes" in data
        assert "configuration" in data


class TestApplyMutations:
    """Test mutation application."""

    def test_apply_mutations_applies_random_mutations(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Apply mutations applies multiple mutation strategies."""
        original = b"test data for mutation"

        mutated = fuzzing_engine._apply_mutations(original)

        assert isinstance(mutated, bytes)
        assert len(mutated) > 0

    def test_apply_mutations_handles_empty_data(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Apply mutations handles empty input."""
        empty = b""

        mutated = fuzzing_engine._apply_mutations(empty)

        assert mutated == empty


class TestDataAnalysis:
    """Test data analysis capabilities."""

    def test_calculate_data_entropy_measures_randomness(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Calculate data entropy measures randomness."""
        low_entropy = b"AAAAAAAAAA"
        high_entropy = bytes(range(256))

        low_score = fuzzing_engine._calculate_data_entropy(low_entropy)
        high_score = fuzzing_engine._calculate_data_entropy(high_entropy)

        assert 0.0 <= low_score <= 8.0
        assert 0.0 <= high_score <= 8.0
        assert high_score > low_score

    def test_find_repeated_patterns_detects_patterns(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Find repeated patterns detects byte sequences."""
        data = b"ABCD" * 10 + b"EFGH" * 5

        patterns = fuzzing_engine._find_repeated_patterns(data)

        assert isinstance(patterns, list)


class TestCrashDebugging:
    """Test crash debugging capabilities."""

    def test_debug_with_windbg_returns_info_structure(
        self, fuzzing_engine: FuzzingEngine, temp_workspace: Path
    ) -> None:
        """Debug with WinDbg returns proper info structure."""
        crash_file = temp_workspace / "crash.dat"
        crash_file.write_bytes(b"crash data")

        debug_info = fuzzing_engine._debug_with_windbg(
            "python3 test.py @@@", str(crash_file)
        )

        assert isinstance(debug_info, dict)
        assert "platform" in debug_info
        assert debug_info["platform"] == "windows"

    def test_parse_windbg_output_extracts_crash_info(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Parse WinDbg output extracts crash information."""
        windbg_output = """
ExceptionCode: c0000005 (Access violation)
ExceptionAddress: 00007ff6a1b2c3d4
eax=00000001 ebx=00000002 ecx=00000003
0 00000001 00000002 module!function
"""

        parsed = fuzzing_engine._parse_windbg_output(windbg_output)

        assert "exception_code" in parsed
        assert "crash_address" in parsed
        assert "registers" in parsed


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_fuzzing_with_no_seeds_generates_defaults(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path
    ) -> None:
        """Fuzzing with no seeds generates default inputs."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            seed_inputs=None,
            strategy=FuzzingStrategy.MUTATION,
            max_iterations=10,
        )

        assert result["success"] is True

    def test_mutation_strategies_handle_small_data(
        self, fuzzing_engine: FuzzingEngine
    ) -> None:
        """Mutation strategies handle very small inputs."""
        small_data = bytearray(b"A")

        for strategy_func in fuzzing_engine.mutation_strategies.values():
            result = strategy_func(small_data.copy())
            assert isinstance(result, bytearray)

    def test_fuzzing_respects_max_iterations(
        self, fuzzing_engine: FuzzingEngine, vulnerable_binary: Path
    ) -> None:
        """Fuzzing campaign respects max iterations limit."""
        command = f"python3 {vulnerable_binary} @@@"

        result = fuzzing_engine.start_fuzzing(
            target_command=command,
            strategy=FuzzingStrategy.RANDOM,
            max_iterations=25,
        )

        assert result["success"] is True
        assert result["iterations_completed"] <= 25
