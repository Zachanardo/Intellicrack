"""Comprehensive tests for research_manager.py vulnerability research capabilities.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

import os
import tempfile
import time
from pathlib import Path
from typing import Any, Dict, List, cast

import pytest

from intellicrack.core.vulnerability_research.binary_differ import BinaryDiffer
from intellicrack.core.vulnerability_research.fuzzing_engine import (
    FuzzingEngine,
    FuzzingStrategy,
)
from intellicrack.core.vulnerability_research.research_manager import (
    CampaignStatus,
    CampaignType,
    ResearchManager,
)
from intellicrack.core.vulnerability_research.vulnerability_analyzer import (
    AnalysisMethod,
    VulnerabilityAnalyzer,
)


@pytest.fixture
def research_manager() -> ResearchManager:
    """Create ResearchManager instance for testing."""
    return ResearchManager()


@pytest.fixture
def sample_binary(tmp_path: Path) -> str:
    """Create sample binary file for testing."""
    binary_path = tmp_path / "sample.exe"
    binary_content = b"MZ\x90\x00" + b"\x00" * 100 + b"\x55\x89\xe5" * 50
    binary_path.write_bytes(binary_content)
    return str(binary_path)


@pytest.fixture
def sample_binaries(tmp_path: Path) -> List[str]:
    """Create multiple sample binary files for testing."""
    binaries: List[str] = []
    for i in range(3):
        binary_path = tmp_path / f"sample_{i}.exe"
        binary_content = b"MZ\x90\x00" + bytes([i] * 100) + b"\x55\x89\xe5" * 50
        binary_path.write_bytes(binary_content)
        binaries.append(str(binary_path))
    return binaries


@pytest.fixture
def binary_pair(tmp_path: Path) -> tuple[str, str]:
    """Create pair of binaries for diff testing."""
    old_binary = tmp_path / "old.exe"
    new_binary = tmp_path / "new.exe"

    old_content = b"MZ\x90\x00" + b"\x00" * 200 + b"\x55\x89\xe5" * 100
    new_content = b"MZ\x90\x00" + b"\x01" * 200 + b"\x55\x89\xe5\x5d\xc3" * 100

    old_binary.write_bytes(old_content)
    new_binary.write_bytes(new_content)

    return str(old_binary), str(new_binary)


class TestResearchManagerInitialization:
    """Test ResearchManager initialization and configuration."""

    def test_initialization_creates_engines(self, research_manager: ResearchManager) -> None:
        """ResearchManager initializes all required engines."""
        assert isinstance(research_manager.binary_differ, BinaryDiffer)
        assert isinstance(research_manager.fuzzing_engine, FuzzingEngine)
        assert isinstance(research_manager.vulnerability_analyzer, VulnerabilityAnalyzer)

    def test_initialization_creates_campaign_storage(self, research_manager: ResearchManager) -> None:
        """ResearchManager initializes campaign storage dictionaries."""
        assert isinstance(research_manager.active_campaigns, dict)
        assert isinstance(research_manager.completed_campaigns, dict)
        assert isinstance(research_manager.campaign_results, dict)
        assert len(research_manager.active_campaigns) == 0
        assert len(research_manager.completed_campaigns) == 0

    def test_initialization_loads_default_config(self, research_manager: ResearchManager) -> None:
        """ResearchManager loads default configuration."""
        assert research_manager.config["max_concurrent_campaigns"] == 5
        assert research_manager.config["default_timeout"] == 3600
        assert research_manager.config["auto_correlation"] is True
        assert research_manager.config["ml_integration"] is True
        assert "result_storage_dir" in research_manager.config

    def test_initialization_creates_campaign_templates(self, research_manager: ResearchManager) -> None:
        """ResearchManager initializes campaign templates."""
        assert "basic_fuzzing" in research_manager.campaign_templates
        assert "comprehensive_analysis" in research_manager.campaign_templates
        assert "patch_research" in research_manager.campaign_templates

        fuzzing_template = research_manager.campaign_templates["basic_fuzzing"]
        assert fuzzing_template["type"] == CampaignType.FUZZING
        assert fuzzing_template["fuzzing_strategy"] == FuzzingStrategy.HYBRID

    def test_initialization_sets_correlation_patterns(self, research_manager: ResearchManager) -> None:
        """ResearchManager initializes correlation patterns."""
        assert "crash_to_vulnerability" in research_manager.correlation_patterns
        assert "binary_diff_to_fuzzing" in research_manager.correlation_patterns
        assert "static_to_dynamic" in research_manager.correlation_patterns
        assert callable(research_manager.correlation_patterns["crash_to_vulnerability"])

    def test_initialization_creates_storage_directory(self, research_manager: ResearchManager) -> None:
        """ResearchManager creates result storage directory."""
        storage_dir = cast(str, research_manager.config["result_storage_dir"])
        assert os.path.exists(storage_dir)
        assert os.path.isdir(storage_dir)


class TestCampaignCreation:
    """Test research campaign creation functionality."""

    def test_create_campaign_basic_success(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Create basic research campaign successfully."""
        result = research_manager.create_campaign(
            name="Test Campaign",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        assert result["success"] is True
        assert "campaign_id" in result
        assert result["name"] == "Test Campaign"
        assert result["type"] == CampaignType.FUZZING.value
        assert result["status"] == CampaignStatus.CREATED.value
        assert sample_binary in result["targets"]

        campaign_id = result["campaign_id"]
        assert campaign_id in research_manager.active_campaigns

    def test_create_campaign_with_template(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Create campaign using predefined template."""
        result = research_manager.create_campaign(
            name="Template Campaign",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            template="basic_fuzzing"
        )

        assert result["success"] is True
        assert result["config"]["fuzzing_strategy"] == FuzzingStrategy.HYBRID
        assert result["config"]["max_iterations"] == 10000
        assert result["config"]["timeout"] == 1800

    def test_create_campaign_with_custom_config(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Create campaign with custom configuration."""
        custom_config = {
            "max_iterations": 5000,
            "timeout": 900,
            "custom_option": "test_value"
        }

        result = research_manager.create_campaign(
            name="Custom Campaign",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            custom_config=custom_config
        )

        assert result["success"] is True
        assert result["config"]["max_iterations"] == 5000
        assert result["config"]["timeout"] == 900
        assert result["config"]["custom_option"] == "test_value"

    def test_create_campaign_template_override_with_custom_config(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Custom config overrides template settings."""
        result = research_manager.create_campaign(
            name="Override Campaign",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            template="basic_fuzzing",
            custom_config={"max_iterations": 2000}
        )

        assert result["success"] is True
        assert result["config"]["max_iterations"] == 2000
        assert result["config"]["fuzzing_strategy"] == FuzzingStrategy.HYBRID

    def test_create_campaign_multiple_targets(
        self,
        research_manager: ResearchManager,
        sample_binaries: List[str]
    ) -> None:
        """Create campaign with multiple target binaries."""
        result = research_manager.create_campaign(
            name="Multi-Target Campaign",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=sample_binaries
        )

        assert result["success"] is True
        assert len(result["targets"]) == 3
        assert all(target in result["targets"] for target in sample_binaries)

    def test_create_campaign_nonexistent_target_fails(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Campaign creation fails with nonexistent target."""
        result = research_manager.create_campaign(
            name="Invalid Campaign",
            campaign_type=CampaignType.FUZZING,
            targets=["/nonexistent/binary.exe"]
        )

        assert result["success"] is False
        assert result["error"] is not None
        assert "not found" in result["error"].lower()
        assert len(research_manager.active_campaigns) == 0

    def test_create_campaign_concurrent_limit(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Campaign creation fails when concurrent limit reached."""
        research_manager.config["max_concurrent_campaigns"] = 2

        result1 = research_manager.create_campaign(
            name="Campaign 1",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )
        assert result1["success"] is True

        result2 = research_manager.create_campaign(
            name="Campaign 2",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )
        assert result2["success"] is True

        result3 = research_manager.create_campaign(
            name="Campaign 3",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )
        assert result3["success"] is False
        assert result3["error"] is not None
        assert "Maximum concurrent campaigns" in result3["error"]

    def test_create_campaign_generates_unique_ids(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Each campaign receives unique ID."""
        result1 = research_manager.create_campaign(
            name="Campaign A",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        result2 = research_manager.create_campaign(
            name="Campaign B",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        assert result1["success"] is True
        assert result2["success"] is True
        assert result1["campaign_id"] != result2["campaign_id"]

    def test_create_campaign_stores_metadata(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Campaign stores complete metadata."""
        result = research_manager.create_campaign(
            name="Metadata Campaign",
            campaign_type=CampaignType.VULNERABILITY_ASSESSMENT,
            targets=[sample_binary]
        )

        campaign_id = result["campaign_id"]
        campaign = research_manager.active_campaigns[campaign_id]

        assert campaign["id"] == campaign_id
        assert campaign["name"] == "Metadata Campaign"
        assert campaign["type"] == CampaignType.VULNERABILITY_ASSESSMENT
        assert campaign["status"] == CampaignStatus.CREATED
        assert "created_at" in campaign
        assert campaign["progress"] == 0.0
        assert isinstance(campaign["results"], dict)
        assert isinstance(campaign["errors"], list)


class TestCampaignExecution:
    """Test research campaign execution functionality."""

    def test_start_fuzzing_campaign_executes(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Fuzzing campaign executes and completes."""
        create_result = research_manager.create_campaign(
            name="Fuzz Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            custom_config={"max_iterations": 10, "timeout": 5}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        assert "success" in start_result
        assert campaign_id in research_manager.completed_campaigns
        assert campaign_id not in research_manager.active_campaigns

    def test_start_vulnerability_campaign_executes(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Vulnerability assessment campaign executes."""
        create_result = research_manager.create_campaign(
            name="Vuln Test",
            campaign_type=CampaignType.VULNERABILITY_ASSESSMENT,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        assert "results" in start_result
        assert "campaign_type" in start_result["results"]
        assert start_result["results"]["campaign_type"] == "vulnerability_assessment"

    def test_start_binary_analysis_campaign_executes(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Binary analysis campaign executes."""
        create_result = research_manager.create_campaign(
            name="Binary Test",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        assert "results" in start_result
        assert start_result["results"]["campaign_type"] == "binary_analysis"

    def test_start_patch_analysis_campaign_executes(
        self,
        research_manager: ResearchManager,
        binary_pair: tuple[str, str]
    ) -> None:
        """Patch analysis campaign executes with binary pairs."""
        old_binary, new_binary = binary_pair

        create_result = research_manager.create_campaign(
            name="Patch Test",
            campaign_type=CampaignType.PATCH_ANALYSIS,
            targets=[old_binary, new_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        assert "results" in start_result
        assert start_result["results"]["campaign_type"] == "patch_analysis"

    def test_start_hybrid_campaign_executes_all_phases(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Hybrid campaign executes all analysis phases."""
        create_result = research_manager.create_campaign(
            name="Hybrid Test",
            campaign_type=CampaignType.HYBRID_RESEARCH,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        assert "results" in start_result
        results = start_result["results"]
        assert results["campaign_type"] == "hybrid_research"
        assert "static_analysis_results" in results
        assert "fuzzing_results" in results
        assert "dynamic_analysis_results" in results
        assert "correlation_findings" in results

    def test_start_campaign_updates_status(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Campaign status updates during execution."""
        create_result = research_manager.create_campaign(
            name="Status Test",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        completed_campaign = research_manager.completed_campaigns[campaign_id]
        assert completed_campaign["status"] in [CampaignStatus.COMPLETED, CampaignStatus.FAILED]
        assert completed_campaign["progress"] == 1.0
        assert completed_campaign["started_at"] is not None
        assert completed_campaign["completed_at"] is not None

    def test_start_campaign_stores_results(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Campaign results stored after execution."""
        create_result = research_manager.create_campaign(
            name="Results Test",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        assert campaign_id in research_manager.campaign_results
        results = research_manager.campaign_results[campaign_id]
        assert "success" in results
        assert "campaign_type" in results

    def test_start_nonexistent_campaign_fails(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Starting nonexistent campaign fails."""
        result = research_manager.start_campaign("invalid_campaign_id")

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_start_campaign_wrong_status_fails(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Starting campaign in wrong status fails."""
        create_result = research_manager.create_campaign(
            name="Wrong Status",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        retry_result = research_manager.start_campaign(campaign_id)
        assert retry_result["success"] is False
        assert "not found" in retry_result["error"].lower()

    def test_campaign_auto_correlation_enabled(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Campaign performs auto-correlation when enabled."""
        research_manager.config["auto_correlation"] = True

        create_result = research_manager.create_campaign(
            name="Correlation Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        completed_campaign = research_manager.completed_campaigns[campaign_id]
        assert "correlation_results" in completed_campaign


class TestCampaignControl:
    """Test campaign control operations (pause, resume, cancel)."""

    def test_pause_campaign_success(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Pause running campaign successfully."""
        create_result = research_manager.create_campaign(
            name="Pause Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        campaign = research_manager.active_campaigns[campaign_id]
        campaign["status"] = CampaignStatus.RUNNING

        pause_result = research_manager.pause_campaign(campaign_id)

        assert pause_result["success"] is True
        assert pause_result["status"] == CampaignStatus.PAUSED.value
        assert campaign["status"] == CampaignStatus.PAUSED
        assert "paused_at" in campaign

    def test_pause_nonexistent_campaign_fails(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Pausing nonexistent campaign fails."""
        result = research_manager.pause_campaign("invalid_id")

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_pause_non_running_campaign_fails(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Pausing non-running campaign fails."""
        create_result = research_manager.create_campaign(
            name="Not Running",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        pause_result = research_manager.pause_campaign(campaign_id)

        assert pause_result["success"] is False
        assert "not running" in pause_result["error"].lower()

    def test_resume_campaign_success(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Resume paused campaign successfully."""
        create_result = research_manager.create_campaign(
            name="Resume Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        campaign = research_manager.active_campaigns[campaign_id]
        campaign["status"] = CampaignStatus.PAUSED

        resume_result = research_manager.resume_campaign(campaign_id)

        assert resume_result["success"] is True
        assert resume_result["status"] == CampaignStatus.RUNNING.value
        assert campaign["status"] == CampaignStatus.RUNNING

    def test_resume_nonexistent_campaign_fails(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Resuming nonexistent campaign fails."""
        result = research_manager.resume_campaign("invalid_id")

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_resume_non_paused_campaign_fails(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Resuming non-paused campaign fails."""
        create_result = research_manager.create_campaign(
            name="Not Paused",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        resume_result = research_manager.resume_campaign(campaign_id)

        assert resume_result["success"] is False
        assert "not paused" in resume_result["error"].lower()

    def test_cancel_campaign_success(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Cancel campaign successfully."""
        create_result = research_manager.create_campaign(
            name="Cancel Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        cancel_result = research_manager.cancel_campaign(campaign_id)

        assert cancel_result["success"] is True
        assert cancel_result["status"] == CampaignStatus.CANCELLED.value
        assert campaign_id in research_manager.completed_campaigns
        assert campaign_id not in research_manager.active_campaigns

    def test_cancel_campaign_moves_to_completed(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Cancelled campaign moves to completed campaigns."""
        create_result = research_manager.create_campaign(
            name="Cancel Move Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.cancel_campaign(campaign_id)

        completed_campaign = research_manager.completed_campaigns[campaign_id]
        assert completed_campaign["status"] == CampaignStatus.CANCELLED
        assert "completed_at" in completed_campaign

    def test_cancel_nonexistent_campaign_fails(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Cancelling nonexistent campaign fails."""
        result = research_manager.cancel_campaign("invalid_id")

        assert result["success"] is False
        assert "not found" in result["error"].lower()


class TestCampaignQuerying:
    """Test campaign status and results querying."""

    def test_get_campaign_status_active(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Get status of active campaign."""
        create_result = research_manager.create_campaign(
            name="Status Query",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        status = research_manager.get_campaign_status(campaign_id)

        assert status["found"] is True
        assert status["campaign_id"] == campaign_id
        assert status["status"] == CampaignStatus.CREATED.value
        assert status["progress"] == 0.0
        assert "created_at" in status
        assert sample_binary in status["targets"]

    def test_get_campaign_status_completed(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Get status of completed campaign."""
        create_result = research_manager.create_campaign(
            name="Completed Status",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        status = research_manager.get_campaign_status(campaign_id)

        assert status["found"] is True
        assert status["progress"] == 1.0
        assert "completed_at" in status
        assert "results" in status

    def test_get_campaign_status_nonexistent(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Get status of nonexistent campaign."""
        status = research_manager.get_campaign_status("invalid_id")

        assert status["found"] is False
        assert "not found" in status["error"].lower()

    def test_list_campaigns_empty(self, research_manager: ResearchManager) -> None:
        """List campaigns when none exist."""
        result = research_manager.list_campaigns()

        assert result["success"] is True
        assert result["total_count"] == 0
        assert result["active_count"] == 0
        assert result["completed_count"] == 0
        assert len(result["campaigns"]) == 0

    def test_list_campaigns_with_active(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """List campaigns includes active campaigns."""
        research_manager.create_campaign(
            name="Active 1",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        research_manager.create_campaign(
            name="Active 2",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        result = research_manager.list_campaigns()

        assert result["success"] is True
        assert result["total_count"] == 2
        assert result["active_count"] == 2
        assert result["completed_count"] == 0

    def test_list_campaigns_with_completed(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """List campaigns includes completed campaigns."""
        create_result = research_manager.create_campaign(
            name="To Complete",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        result = research_manager.list_campaigns()

        assert result["success"] is True
        assert result["total_count"] == 1
        assert result["active_count"] == 0
        assert result["completed_count"] == 1

    def test_list_campaigns_status_filter(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """List campaigns with status filtering."""
        research_manager.create_campaign(
            name="Created",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary]
        )

        create_result = research_manager.create_campaign(
            name="Completed",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )
        research_manager.start_campaign(create_result["campaign_id"])

        created_result = research_manager.list_campaigns(status_filter="created")
        completed_result = research_manager.list_campaigns(status_filter="completed")

        assert len(created_result["campaigns"]) == 1
        assert created_result["campaigns"][0]["status"] == "created"

        assert len(completed_result["campaigns"]) >= 0

    def test_get_campaign_results_success(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Get campaign results after completion."""
        create_result = research_manager.create_campaign(
            name="Results Test",
            campaign_type=CampaignType.BINARY_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        results = research_manager.get_campaign_results(campaign_id)

        assert results["found"] is True
        assert results["campaign_id"] == campaign_id
        assert "results" in results
        assert results["results"]["campaign_type"] == "binary_analysis"

    def test_get_campaign_results_nonexistent(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Get results for nonexistent campaign."""
        results = research_manager.get_campaign_results("invalid_id")

        assert results["found"] is False
        assert "not found" in results["error"].lower()


class TestFuzzingCampaignExecution:
    """Test fuzzing campaign execution details."""

    def test_fuzzing_campaign_processes_targets(
        self,
        research_manager: ResearchManager,
        sample_binaries: List[str]
    ) -> None:
        """Fuzzing campaign processes all targets."""
        create_result = research_manager.create_campaign(
            name="Multi-Fuzz",
            campaign_type=CampaignType.FUZZING,
            targets=sample_binaries,
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "detailed_results" in results
        assert len(results["detailed_results"]) <= len(sample_binaries)

    def test_fuzzing_campaign_updates_progress(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Fuzzing campaign updates progress during execution."""
        create_result = research_manager.create_campaign(
            name="Progress Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        research_manager.start_campaign(campaign_id)

        completed = research_manager.completed_campaigns[campaign_id]
        assert completed["progress"] == 1.0

    def test_fuzzing_campaign_generates_summary(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Fuzzing campaign generates summary report."""
        create_result = research_manager.create_campaign(
            name="Summary Test",
            campaign_type=CampaignType.FUZZING,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "summary_report" in results
        assert "FUZZING CAMPAIGN SUMMARY" in results["summary_report"]
        assert "Targets Processed" in results["summary_report"]


class TestVulnerabilityCampaignExecution:
    """Test vulnerability assessment campaign execution."""

    def test_vulnerability_campaign_analyzes_targets(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Vulnerability campaign analyzes targets."""
        create_result = research_manager.create_campaign(
            name="Vuln Analysis",
            campaign_type=CampaignType.VULNERABILITY_ASSESSMENT,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert results["campaign_type"] == "vulnerability_assessment"
        assert "detailed_results" in results

    def test_vulnerability_campaign_counts_by_severity(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Vulnerability campaign counts findings by severity."""
        create_result = research_manager.create_campaign(
            name="Severity Count",
            campaign_type=CampaignType.VULNERABILITY_ASSESSMENT,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "critical_vulnerabilities" in results
        assert "high_vulnerabilities" in results
        assert "medium_vulnerabilities" in results
        assert "low_vulnerabilities" in results

    def test_vulnerability_campaign_generates_summary(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Vulnerability campaign generates summary report."""
        create_result = research_manager.create_campaign(
            name="Vuln Summary",
            campaign_type=CampaignType.VULNERABILITY_ASSESSMENT,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "summary_report" in results
        assert "VULNERABILITY ASSESSMENT SUMMARY" in results["summary_report"]


class TestPatchAnalysisCampaignExecution:
    """Test patch analysis campaign execution."""

    def test_patch_analysis_requires_pairs(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Patch analysis requires even number of binaries."""
        create_result = research_manager.create_campaign(
            name="Odd Binaries",
            campaign_type=CampaignType.PATCH_ANALYSIS,
            targets=[sample_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert results["success"] is False
        assert "pairs" in results["error"].lower()

    def test_patch_analysis_processes_pairs(
        self,
        research_manager: ResearchManager,
        binary_pair: tuple[str, str]
    ) -> None:
        """Patch analysis processes binary pairs."""
        old_binary, new_binary = binary_pair

        create_result = research_manager.create_campaign(
            name="Pair Analysis",
            campaign_type=CampaignType.PATCH_ANALYSIS,
            targets=[old_binary, new_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert results["campaign_type"] == "patch_analysis"
        assert "detailed_results" in results

    def test_patch_analysis_identifies_security_patches(
        self,
        research_manager: ResearchManager,
        binary_pair: tuple[str, str]
    ) -> None:
        """Patch analysis identifies security-related changes."""
        old_binary, new_binary = binary_pair

        create_result = research_manager.create_campaign(
            name="Security Patches",
            campaign_type=CampaignType.PATCH_ANALYSIS,
            targets=[old_binary, new_binary]
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "security_patches_identified" in results
        assert "vulnerability_fixes_found" in results
        assert "new_attack_surface" in results


class TestHybridCampaignExecution:
    """Test hybrid research campaign execution."""

    def test_hybrid_campaign_executes_all_phases(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Hybrid campaign executes all research phases."""
        create_result = research_manager.create_campaign(
            name="Hybrid Full",
            campaign_type=CampaignType.HYBRID_RESEARCH,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert results["total_phases"] == 3
        assert "static_analysis_results" in results
        assert "fuzzing_results" in results
        assert "dynamic_analysis_results" in results

    def test_hybrid_campaign_correlates_results(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Hybrid campaign correlates findings across phases."""
        create_result = research_manager.create_campaign(
            name="Hybrid Correlation",
            campaign_type=CampaignType.HYBRID_RESEARCH,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "correlation_findings" in results
        correlation = results["correlation_findings"]
        assert "confirmed_vulnerabilities" in correlation
        assert "exploitation_paths" in correlation

    def test_hybrid_campaign_generates_summary(
        self,
        research_manager: ResearchManager,
        sample_binary: str
    ) -> None:
        """Hybrid campaign generates comprehensive summary."""
        create_result = research_manager.create_campaign(
            name="Hybrid Summary",
            campaign_type=CampaignType.HYBRID_RESEARCH,
            targets=[sample_binary],
            custom_config={"max_iterations": 10}
        )

        campaign_id = create_result["campaign_id"]
        start_result = research_manager.start_campaign(campaign_id)

        results = start_result["results"]
        assert "summary_report" in results
        assert "HYBRID RESEARCH SUMMARY" in results["summary_report"]
        assert "Phases Completed" in results["summary_report"]


class TestCrashAnalysis:
    """Test crash analysis for vulnerability detection."""

    def test_analyze_crash_segfault(self, research_manager: ResearchManager) -> None:
        """Analyze SIGSEGV crash for exploitability."""
        crash_data = {
            "crash_type": "SIGSEGV",
            "crash_address": 0x41414141,
            "registers": {"eip": 0x41414141, "eax": 0x42424242},
            "stack_trace": ["func_vulnerable", "main"]
        }

        analysis = research_manager._analyze_crash_for_vulnerability(crash_data)

        assert analysis["vulnerability_type"] == "memory_corruption"
        assert analysis["exploitability_score"] > 0.0
        assert "details" in analysis

    def test_analyze_crash_controlled_memory(self, research_manager: ResearchManager) -> None:
        """Analyze crash with controlled memory access."""
        crash_data = {
            "crash_type": "SIGSEGV",
            "crash_address": 0x41414141,
            "registers": {"eip": 0x41414141},
            "stack_trace": []
        }

        analysis = research_manager._analyze_crash_for_vulnerability(crash_data)

        assert analysis["is_exploitable"] is True
        assert analysis["exploitability_score"] >= 0.7

    def test_analyze_crash_stack_overflow(self, research_manager: ResearchManager) -> None:
        """Analyze stack overflow crash."""
        crash_data = {
            "crash_type": "stack_overflow",
            "crash_address": 0x7fff0000,
            "registers": {"esp": 0x7fff0000},
            "stack_trace": ["recursive_func"] * 100
        }

        analysis = research_manager._analyze_crash_for_vulnerability(crash_data)

        assert analysis["vulnerability_type"] == "stack_overflow"
        assert analysis["is_exploitable"] is True
        assert analysis["severity"] in ["high", "critical"]

    def test_analyze_crash_heap_corruption(self, research_manager: ResearchManager) -> None:
        """Analyze heap corruption crash."""
        crash_data = {
            "crash_type": "heap_corruption",
            "crash_address": 0x00100000,
            "registers": {},
            "stack_trace": ["free", "malloc"]
        }

        analysis = research_manager._analyze_crash_for_vulnerability(crash_data)

        assert analysis["vulnerability_type"] == "heap_corruption"
        assert analysis["exploitability_score"] > 0.0


class TestPatchSecurityAnalysis:
    """Test patch security implications analysis."""

    def test_analyze_patch_security_keywords(self, research_manager: ResearchManager) -> None:
        """Patch analysis detects security keywords."""
        diff_result = {
            "changes": {
                "function_changes": [
                    {
                        "name": "validate_buffer",
                        "changes": [
                            {"type": "add", "content": "bounds check added"},
                            {"type": "add", "content": "buffer overflow protection"}
                        ]
                    }
                ],
                "new_functions": [],
                "removed_functions": []
            }
        }

        analysis = research_manager._analyze_patch_security_implications(diff_result)

        assert analysis["is_security_patch"] is True
        assert analysis["vulnerability_fixes"] > 0
        assert len(analysis["security_indicators"]) > 0

    def test_analyze_patch_new_attack_surface(self, research_manager: ResearchManager) -> None:
        """Patch analysis identifies new attack surface."""
        diff_result = {
            "changes": {
                "function_changes": [],
                "new_functions": [
                    {"name": "handle_network_request"},
                    {"name": "process_file_upload"}
                ],
                "removed_functions": []
            }
        }

        analysis = research_manager._analyze_patch_security_implications(diff_result)

        assert analysis["new_attack_surface"] > 0
        assert any(
            ind["type"] in ["new_network_function", "new_file_function"]
            for ind in analysis["security_indicators"]
        )

    def test_analyze_patch_risk_assessment(self, research_manager: ResearchManager) -> None:
        """Patch analysis provides risk assessment."""
        diff_result = {
            "changes": {
                "function_changes": [
                    {
                        "name": "auth_check",
                        "changes": [
                            {"type": "modify", "content": "validate user input"},
                            {"type": "add", "content": "sanitize credentials"},
                            {"type": "add", "content": "check bounds"}
                        ]
                    }
                ],
                "new_functions": [],
                "removed_functions": []
            }
        }

        analysis = research_manager._analyze_patch_security_implications(diff_result)

        assert analysis["risk_assessment"] in ["low", "medium", "high"]
        assert "recommendations" in analysis


class TestCorrelation:
    """Test result correlation functionality."""

    def test_correlate_crash_to_vulnerability(self, research_manager: ResearchManager) -> None:
        """Correlate crash data with vulnerability."""
        crash_data = {
            "crash_type": "SIGSEGV",
            "function": "parse_input",
            "module": "main.exe",
            "severity": "high",
            "timestamp": time.time()
        }

        vuln_data = {
            "type": "buffer_overflow",
            "function": "parse_input",
            "module": "main.exe",
            "severity": "high",
            "discovery_time": time.time()
        }

        score = research_manager._correlate_crash_to_vulnerability(crash_data, vuln_data)

        assert score > 0.0
        assert score <= 1.0

    def test_correlate_static_to_dynamic(self, research_manager: ResearchManager) -> None:
        """Correlate static analysis with dynamic findings."""
        static_data = {
            "vulnerabilities": [
                {
                    "type": "buffer_overflow",
                    "function": "vulnerable_func",
                    "severity": "high"
                }
            ],
            "warnings": []
        }

        dynamic_data = {
            "vulnerabilities": [
                {
                    "type": "buffer_overflow",
                    "function": "vulnerable_func",
                    "severity": "high"
                }
            ],
            "crashes": []
        }

        score = research_manager._correlate_static_to_dynamic(static_data, dynamic_data)

        assert score > 0.0
        assert score <= 1.0

    def test_find_fuzzing_patterns(self, research_manager: ResearchManager) -> None:
        """Find patterns in fuzzing results."""
        results = {
            "detailed_results": {
                "target1": {
                    "crashes": [
                        {"crash_type": "SIGSEGV"},
                        {"crash_type": "SIGSEGV"},
                        {"crash_type": "SIGABRT"}
                    ]
                }
            }
        }

        patterns = research_manager._find_fuzzing_patterns(results)

        assert len(patterns) > 0
        assert any(p["type"] == "repeated_crash_type" for p in patterns)

    def test_find_vulnerability_patterns(self, research_manager: ResearchManager) -> None:
        """Find patterns in vulnerability results."""
        results = {
            "detailed_results": {
                "target1": {
                    "vulnerabilities": [
                        {"type": "buffer_overflow"},
                        {"type": "buffer_overflow"},
                        {"type": "integer_overflow"}
                    ]
                }
            }
        }

        patterns = research_manager._find_vulnerability_patterns(results)

        assert len(patterns) > 0
        assert any(p["type"] == "repeated_vulnerability_type" for p in patterns)


class TestMLInsights:
    """Test ML-based insights generation."""

    def test_generate_ml_insights_fuzzing(self, research_manager: ResearchManager) -> None:
        """Generate ML insights for fuzzing results."""
        execution_result = {
            "campaign_type": "fuzzing",
            "crashes_found": 150,
            "success": True
        }

        insights = research_manager._generate_ml_insights(execution_result)

        assert "anomaly_detection" in insights
        assert "pattern_recognition" in insights
        assert "risk_scoring" in insights
        assert "predictions" in insights

    def test_generate_ml_insights_vulnerability(self, research_manager: ResearchManager) -> None:
        """Generate ML insights for vulnerability assessment."""
        execution_result = {
            "campaign_type": "vulnerability_assessment",
            "critical_vulnerabilities": 10,
            "success": True
        }

        insights = research_manager._generate_ml_insights(execution_result)

        assert "risk_scoring" in insights
        if insights["risk_scoring"]:
            assert "overall_risk" in insights["risk_scoring"]


class TestRecommendations:
    """Test recommendation generation."""

    def test_generate_recommendations_fuzzing(self, research_manager: ResearchManager) -> None:
        """Generate recommendations for fuzzing results."""
        execution_result = {
            "campaign_type": "fuzzing",
            "crashes_found": 25,
            "coverage_achieved": 30.0
        }

        correlation_results: Dict[str, List[Any]] = {"patterns_found": []}

        recommendations = research_manager._generate_recommendations(
            execution_result,
            correlation_results
        )

        assert len(recommendations) > 0
        assert any("crash" in r.lower() for r in recommendations)

    def test_generate_recommendations_critical_vulns(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Generate recommendations for critical vulnerabilities."""
        execution_result = {
            "campaign_type": "vulnerability_assessment",
            "critical_vulnerabilities": 5
        }

        correlation_results: Dict[str, List[Any]] = {"patterns_found": []}

        recommendations = research_manager._generate_recommendations(
            execution_result,
            correlation_results
        )

        assert len(recommendations) > 0
        assert any("critical" in r.lower() for r in recommendations)


class TestHelperMethods:
    """Test helper and utility methods."""

    def test_generate_campaign_id_unique(self, research_manager: ResearchManager) -> None:
        """Campaign ID generation produces unique IDs."""
        id1 = research_manager._generate_campaign_id()
        time.sleep(0.001)
        id2 = research_manager._generate_campaign_id()

        assert id1 != id2
        assert id1.startswith("camp_")
        assert id2.startswith("camp_")

    def test_is_controlled_crash_detects_patterns(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Controlled crash detection identifies controlled addresses."""
        assert research_manager._is_controlled_crash(0x41414141, {}) is True
        assert research_manager._is_controlled_crash(0x42424242, {}) is True
        assert research_manager._is_controlled_crash(0x12345678, {}) is False

    def test_is_controlled_crash_checks_registers(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Controlled crash detection checks register values."""
        registers = {"eip": 0x41414141, "eax": 0x12345678}
        assert research_manager._is_controlled_crash(0x12345678, registers) is True

    def test_analyze_registers(self, research_manager: ResearchManager) -> None:
        """Register analysis identifies controlled values."""
        registers = {
            "eip": 0x41414141,
            "eax": 0x42424242,
            "ebx": 0x00401000
        }

        analysis = research_manager._analyze_registers(registers)

        assert "controlled_registers" in analysis
        assert len(analysis["controlled_registers"]) == 2
        assert "potential_exploitability" in analysis

    def test_analyze_stack_trace(self, research_manager: ResearchManager) -> None:
        """Stack trace analysis identifies exploitation indicators."""
        stack_trace = [
            "strcpy+0x10",
            "vulnerable_func+0x20",
            "41414141",
            "main+0x50"
        ]

        analysis = research_manager._analyze_stack_trace(stack_trace)

        assert analysis["depth"] == 4
        assert "controlled_frames" in analysis
        assert "interesting_functions" in analysis

    def test_vulnerabilities_match_same_function(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Vulnerability matching identifies same function."""
        vuln1 = {
            "type": "buffer_overflow",
            "location": {"function": "parse_input"}
        }

        vuln2 = {
            "type": "buffer_overflow",
            "location": {"function": "parse_input"}
        }

        assert research_manager._vulnerabilities_match(vuln1, vuln2) is True

    def test_location_matches_crash(self, research_manager: ResearchManager) -> None:
        """Location matching checks address proximity."""
        vuln_location = {"address": 0x00401000}
        crash_address = 0x00401100

        assert research_manager._location_matches_crash(
            vuln_location,
            crash_address
        ) is True

        far_crash_address = 0x00500000
        assert research_manager._location_matches_crash(
            vuln_location,
            far_crash_address
        ) is False


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_empty_targets_list(self, research_manager: ResearchManager) -> None:
        """Campaign creation handles empty targets list."""
        result = research_manager.create_campaign(
            name="Empty Targets",
            campaign_type=CampaignType.FUZZING,
            targets=[]
        )

        assert result["success"] is True
        assert len(result["targets"]) == 0

    def test_correlation_with_empty_results(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Correlation handles empty results."""
        static_results: Dict[str, Dict[str, Any]] = {"detailed_results": {}}
        fuzzing_results: Dict[str, Dict[str, Any]] = {"detailed_results": {}}
        vuln_results: Dict[str, Dict[str, Any]] = {"detailed_results": {}}

        correlation = research_manager._correlate_hybrid_results(
            static_results,
            fuzzing_results,
            vuln_results
        )

        assert "confirmed_vulnerabilities" in correlation
        assert len(correlation["confirmed_vulnerabilities"]) == 0

    def test_patch_analysis_with_no_changes(
        self,
        research_manager: ResearchManager
    ) -> None:
        """Patch security analysis handles no changes."""
        diff_result: Dict[str, Dict[str, List[Any]]] = {
            "changes": {
                "function_changes": [],
                "new_functions": [],
                "removed_functions": []
            }
        }

        analysis = research_manager._analyze_patch_security_implications(diff_result)

        assert analysis["is_security_patch"] is False
        assert analysis["vulnerability_fixes"] == 0
