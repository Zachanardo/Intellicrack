"""Production tests for fuzzing_engine.py - Real binary fuzzing validation.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import os
import struct
import tempfile
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.vulnerability_research.fuzzing_engine import (
    CrashSeverity,
    FuzzingEngine,
    FuzzingStrategy,
)


class TestFuzzingEngineInitialization:
    """Production tests for FuzzingEngine initialization."""

    def test_fuzzing_engine_initializes_with_config(self) -> None:
        """FuzzingEngine initializes with complete configuration."""
        engine: FuzzingEngine = FuzzingEngine()

        assert hasattr(engine, "config"), "Must have config"
        assert isinstance(engine.config, dict), "Config must be dict"

        assert "max_iterations" in engine.config, "Must have max_iterations"
        assert "timeout" in engine.config, "Must have timeout"
        assert "mutation_rate" in engine.config, "Must have mutation_rate"

    def test_mutation_strategies_registered(self) -> None:
        """Mutation strategies are registered."""
        engine: FuzzingEngine = FuzzingEngine()

        expected_strategies: list[str] = [
            "bit_flip",
            "byte_flip",
            "arithmetic",
            "insert",
            "delete",
            "magic_values",
        ]

        for strategy in expected_strategies:
            assert strategy in engine.mutation_strategies, f"Must have {strategy}"
            assert callable(engine.mutation_strategies[strategy]), f"{strategy} must be callable"

    def test_magic_values_defined(self) -> None:
        """Magic values for fuzzing are defined."""
        engine: FuzzingEngine = FuzzingEngine()

        assert "integers" in engine.magic_values, "Must have integer magic values"
        assert "strings" in engine.magic_values, "Must have string magic values"
        assert "special_chars" in engine.magic_values, "Must have special chars"

        assert len(engine.magic_values["integers"]) > 0, "Must have integer values"
        assert len(engine.magic_values["strings"]) > 0, "Must have string values"

    def test_file_grammars_registered(self) -> None:
        """File format grammars are registered."""
        engine: FuzzingEngine = FuzzingEngine()

        expected_formats: list[str] = ["text", "xml", "json", "binary"]

        for format_type in expected_formats:
            assert format_type in engine.file_grammars, f"Must have {format_type} grammar"

    def test_statistics_initialized(self) -> None:
        """Fuzzing statistics are initialized."""
        engine: FuzzingEngine = FuzzingEngine()

        assert "total_executions" in engine.stats, "Must track executions"
        assert "crashes_found" in engine.stats, "Must track crashes"
        assert "unique_crashes" in engine.stats, "Must track unique crashes"
        assert engine.stats["total_executions"] == 0, "Initial executions must be 0"


class TestMutationStrategies:
    """Production tests for mutation strategies."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_bit_flip_mutation_changes_data(self, engine: FuzzingEngine) -> None:
        """Bit flip mutation modifies input data."""
        original: bytes = b"Hello, World!"

        mutated: bytes = engine._mutate_bit_flip(original)

        assert isinstance(mutated, bytes), "Must return bytes"
        assert len(mutated) == len(original), "Length must be preserved"

    def test_byte_flip_mutation(self, engine: FuzzingEngine) -> None:
        """Byte flip mutation inverts bytes."""
        original: bytes = bytes([0x00, 0xFF, 0xAA, 0x55])

        mutated: bytes = engine._mutate_byte_flip(original)

        assert isinstance(mutated, bytes), "Must return bytes"

    def test_arithmetic_mutation(self, engine: FuzzingEngine) -> None:
        """Arithmetic mutation adds/subtracts from bytes."""
        original: bytes = bytes([100, 50, 25, 10])

        mutated: bytes = engine._mutate_arithmetic(original)

        assert isinstance(mutated, bytes), "Must return bytes"
        assert len(mutated) == len(original), "Length must be preserved"

    def test_insert_mutation_grows_data(self, engine: FuzzingEngine) -> None:
        """Insert mutation adds bytes to input."""
        original: bytes = b"test"

        mutated: bytes = engine._mutate_insert(original)

        assert isinstance(mutated, bytes), "Must return bytes"
        assert len(mutated) >= len(original), "Must grow or maintain size"

    def test_delete_mutation_shrinks_data(self, engine: FuzzingEngine) -> None:
        """Delete mutation removes bytes from input."""
        original: bytes = b"x" * 100

        mutated: bytes = engine._mutate_delete(original)

        assert isinstance(mutated, bytes), "Must return bytes"
        assert len(mutated) <= len(original), "Must shrink or maintain size"

    def test_duplicate_mutation(self, engine: FuzzingEngine) -> None:
        """Duplicate mutation duplicates data segments."""
        original: bytes = b"ABCD"

        mutated: bytes = engine._mutate_duplicate(original)

        assert isinstance(mutated, bytes), "Must return bytes"

    def test_magic_values_mutation_injects_special_values(self, engine: FuzzingEngine) -> None:
        """Magic values mutation injects boundary values."""
        original: bytes = b"\x00" * 100

        mutated: bytes = engine._mutate_magic_values(original)

        assert isinstance(mutated, bytes), "Must return bytes"

    def test_mutation_handles_empty_input(self, engine: FuzzingEngine) -> None:
        """Mutations handle empty input gracefully."""
        original: bytes = b""

        for strategy_name, mutate_func in engine.mutation_strategies.items():
            mutated: bytes = mutate_func(original)
            assert isinstance(mutated, bytes), f"{strategy_name} must return bytes for empty input"


class TestFuzzingExecution:
    """Production tests for fuzzing execution."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    @pytest.fixture
    def target_script(self, tmp_path: Path) -> Path:
        """Create test target script."""
        script_path: Path = tmp_path / "target.py"

        script_content: str = """import sys
try:
    with open(sys.argv[1], 'rb') as f:
        data = f.read()
        if b'CRASH' in data:
            raise Exception('Intentional crash for testing')
except:
    sys.exit(1)
"""

        script_path.write_text(script_content)
        return script_path

    def test_start_fuzzing_validates_target_command(self, engine: FuzzingEngine) -> None:
        """start_fuzzing validates target command format."""
        result: dict[str, Any] = engine.start_fuzzing(
            target_command="python test.py",
            max_iterations=1,
        )

        assert not result["success"] or result["error"] is not None, "Must validate @@@ marker"

    @pytest.mark.skipif(os.name != "nt", reason="Test requires Windows")
    def test_start_fuzzing_with_valid_command(self, engine: FuzzingEngine, target_script: Path, tmp_path: Path) -> None:
        """start_fuzzing executes with valid command."""
        seed_file: Path = tmp_path / "seed.txt"
        seed_file.write_bytes(b"normal input")

        result: dict[str, Any] = engine.start_fuzzing(
            target_command=f"python {target_script} @@@",
            seed_inputs=[str(seed_file)],
            strategy=FuzzingStrategy.RANDOM,
            max_iterations=5,
        )

        assert "success" in result, "Must have success field"
        assert "iterations_completed" in result, "Must track iterations"
        assert "crashes_found" in result, "Must track crashes"

    def test_fuzzing_campaign_generates_campaign_id(self, engine: FuzzingEngine) -> None:
        """Fuzzing campaign generates unique campaign ID."""
        result: dict[str, Any] = engine.start_fuzzing(
            target_command="test @@@",
            max_iterations=1,
        )

        assert "campaign_id" in result, "Must have campaign ID"
        assert result["campaign_id"] is not None, "Campaign ID must not be None"

    def test_fuzzing_respects_max_iterations(self, engine: FuzzingEngine, target_script: Path, tmp_path: Path) -> None:
        """Fuzzing respects max_iterations configuration."""
        max_iterations: int = 10

        seed_file: Path = tmp_path / "seed.txt"
        seed_file.write_bytes(b"test")

        result: dict[str, Any] = engine.start_fuzzing(
            target_command=f"python {target_script} @@@",
            seed_inputs=[str(seed_file)],
            strategy=FuzzingStrategy.MUTATION,
            max_iterations=max_iterations,
        )

        if result["success"]:
            assert result["iterations_completed"] <= max_iterations, "Must not exceed max iterations"


class TestCrashDetection:
    """Production tests for crash detection and analysis."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    @pytest.fixture
    def crashing_binary(self, tmp_path: Path) -> Path:
        """Create test binary that crashes on specific input."""
        binary_path: Path = tmp_path / "crash_test.exe"

        dos_header = b"MZ" + b"\x00" * 58 + struct.pack("<I", 0x80)
        pe_signature = b"PE\x00\x00"
        coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
        optional_header = b"\x00" * 224
        section = b".text\x00\x00\x00" + struct.pack("<IIIIII", 0x1000, 0x1000, 0x200, 0x200, 0, 0) + struct.pack("<HHI", 0, 0, 0x60000020)

        pe_file = dos_header + b"\x00" * (0x80 - len(dos_header))
        pe_file += pe_signature + coff_header + optional_header + section

        binary_path.write_bytes(pe_file)
        return binary_path

    def test_detect_crash_identifies_crashes(self, engine: FuzzingEngine) -> None:
        """_detect_crash identifies program crashes."""
        crash_info: dict[str, Any] = {
            "returncode": -1073741819,
            "stderr": b"Access violation",
        }

        is_crash: bool = engine._detect_crash(crash_info)

        assert isinstance(is_crash, bool), "Must return boolean"

    def test_analyze_crash_extracts_info(self, engine: FuzzingEngine, tmp_path: Path) -> None:
        """_analyze_crash extracts crash information."""
        crash_input: Path = tmp_path / "crash_input.bin"
        crash_input.write_bytes(b"CRASH_TRIGGER")

        crash_data: dict[str, Any] = {
            "returncode": -1,
            "stderr": b"Segmentation fault",
            "input_file": str(crash_input),
        }

        analysis: dict[str, Any] = engine._analyze_crash(crash_data, str(crash_input))

        assert "crash_hash" in analysis, "Must compute crash hash"
        assert "severity" in analysis, "Must assess severity"
        assert "input_file" in analysis, "Must track input file"

    def test_crash_severity_assessment(self, engine: FuzzingEngine) -> None:
        """Crash severity is properly assessed."""
        crash_with_exception: dict[str, Any] = {
            "exception_code": 0xC0000005,
            "stderr": b"Access violation",
        }

        severity: CrashSeverity = engine._assess_crash_severity(crash_with_exception)

        assert isinstance(severity, CrashSeverity), "Must return CrashSeverity enum"

    def test_crash_deduplication(self, engine: FuzzingEngine, tmp_path: Path) -> None:
        """Crashes are deduplicated by hash."""
        crash1: dict[str, Any] = {
            "returncode": -1,
            "stderr": b"Error at 0x1234",
            "input_file": str(tmp_path / "input1.bin"),
        }

        crash2: dict[str, Any] = {
            "returncode": -1,
            "stderr": b"Error at 0x1234",
            "input_file": str(tmp_path / "input2.bin"),
        }

        analysis1: dict[str, Any] = engine._analyze_crash(crash1, str(tmp_path / "input1.bin"))
        analysis2: dict[str, Any] = engine._analyze_crash(crash2, str(tmp_path / "input2.bin"))

        assert "crash_hash" in analysis1 and "crash_hash" in analysis2, "Must compute hashes"


class TestGrammarBasedGeneration:
    """Production tests for grammar-based input generation."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_generate_text_grammar(self, engine: FuzzingEngine) -> None:
        """Text grammar generation produces valid text."""
        text: bytes = engine._generate_text_grammar()

        assert isinstance(text, bytes), "Must return bytes"
        assert text, "Must generate non-empty text"

    def test_generate_xml_grammar(self, engine: FuzzingEngine) -> None:
        """XML grammar generation produces XML-like structure."""
        xml: bytes = engine._generate_xml_grammar()

        assert isinstance(xml, bytes), "Must return bytes"
        assert b"<" in xml or xml, "Must have XML-like structure or content"

    def test_generate_json_grammar(self, engine: FuzzingEngine) -> None:
        """JSON grammar generation produces JSON-like structure."""
        json_data: bytes = engine._generate_json_grammar()

        assert isinstance(json_data, bytes), "Must return bytes"
        assert (
            b"{" in json_data or b"[" in json_data or json_data
        ), "Must have JSON-like structure"

    def test_generate_binary_grammar(self, engine: FuzzingEngine) -> None:
        """Binary grammar generation produces binary data."""
        binary: bytes = engine._generate_binary_grammar()

        assert isinstance(binary, bytes), "Must return bytes"
        assert binary, "Must generate binary data"


class TestCoverageMechanisms:
    """Production tests for coverage collection mechanisms."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_coverage_data_storage(self, engine: FuzzingEngine) -> None:
        """Coverage data is stored correctly."""
        assert hasattr(engine, "coverage_data"), "Must have coverage storage"
        assert isinstance(engine.coverage_data, dict), "Coverage data must be dict"

    def test_interesting_inputs_tracking(self, engine: FuzzingEngine) -> None:
        """Interesting inputs are tracked."""
        assert hasattr(engine, "interesting_inputs"), "Must track interesting inputs"
        assert isinstance(engine.interesting_inputs, list), "Must be list"


class TestFuzzingStrategies:
    """Production tests for different fuzzing strategies."""

    def test_fuzzing_strategy_enum_values(self) -> None:
        """FuzzingStrategy enum has all expected strategies."""
        expected_strategies: list[str] = [
            "RANDOM",
            "MUTATION",
            "GENERATION",
            "GRAMMAR_BASED",
            "COVERAGE_GUIDED",
            "HYBRID",
        ]

        for strategy_name in expected_strategies:
            assert hasattr(FuzzingStrategy, strategy_name), f"Must have {strategy_name} strategy"

    def test_fuzzing_strategies_are_distinct(self) -> None:
        """All fuzzing strategies have unique values."""
        strategies: list[FuzzingStrategy] = list(FuzzingStrategy)
        values: list[str] = [s.value for s in strategies]

        assert len(values) == len(set(values)), "Strategy values must be unique"


class TestStatisticsTracking:
    """Production tests for fuzzing statistics tracking."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_statistics_track_executions(self, engine: FuzzingEngine) -> None:
        """Statistics track total executions."""
        assert "total_executions" in engine.stats, "Must track total executions"
        assert isinstance(engine.stats["total_executions"], int), "Executions must be int"

    def test_statistics_track_crashes(self, engine: FuzzingEngine) -> None:
        """Statistics track crashes found."""
        assert "crashes_found" in engine.stats, "Must track crashes"
        assert "unique_crashes" in engine.stats, "Must track unique crashes"

    def test_statistics_track_timing(self, engine: FuzzingEngine) -> None:
        """Statistics track timing information."""
        assert "start_time" in engine.stats, "Must track start time"
        assert "elapsed_time" in engine.stats, "Must track elapsed time"
        assert "execution_speed" in engine.stats, "Must track execution speed"


class TestConfigurationManagement:
    """Production tests for configuration management."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_config_has_reasonable_defaults(self, engine: FuzzingEngine) -> None:
        """Configuration has reasonable default values."""
        assert engine.config["max_iterations"] > 0, "Max iterations must be positive"
        assert engine.config["timeout"] > 0, "Timeout must be positive"
        assert 0.0 <= engine.config["mutation_rate"] <= 1.0, "Mutation rate must be 0-1"
        assert 0.0 <= engine.config["crossover_rate"] <= 1.0, "Crossover rate must be 0-1"

    def test_config_max_file_size_set(self, engine: FuzzingEngine) -> None:
        """Configuration includes max file size limit."""
        assert "max_file_size" in engine.config, "Must have max_file_size"
        assert engine.config["max_file_size"] > 0, "Max file size must be positive"

    def test_config_parallel_workers(self, engine: FuzzingEngine) -> None:
        """Configuration includes parallel worker count."""
        assert "parallel_workers" in engine.config, "Must have parallel_workers"
        assert engine.config["parallel_workers"] > 0, "Worker count must be positive"


class TestOutputHandling:
    """Production tests for fuzzing output handling."""

    @pytest.fixture
    def engine(self) -> FuzzingEngine:
        """Create fuzzing engine for testing."""
        return FuzzingEngine()

    def test_campaign_id_generation(self, engine: FuzzingEngine) -> None:
        """Campaign ID generation produces unique IDs."""
        campaign_id1: str = engine._generate_campaign_id()
        campaign_id2: str = engine._generate_campaign_id()

        assert isinstance(campaign_id1, str), "Campaign ID must be string"
        assert campaign_id1 != "", "Campaign ID must not be empty"
        assert campaign_id1 != campaign_id2, "Campaign IDs must be unique"

    def test_output_directory_creation(self, engine: FuzzingEngine, tmp_path: Path) -> None:
        """Output directories are created for campaigns."""
        campaign_id: str = "test_campaign_123"

        output_dir: Path = engine._create_output_directories(campaign_id)

        assert isinstance(output_dir, Path), "Must return Path"
