"""Production Tests for Vulnerability Analyzer.

Tests validate real vulnerability detection capabilities for license cracking analysis.
All tests verify production-ready vulnerability analysis without mocks or stubs.

Copyright (C) 2025 Zachary Flint
"""

from __future__ import annotations

import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.vulnerability_research.vulnerability_analyzer import (
    AnalysisMethod,
    VulnerabilityAnalyzer,
    VulnerabilityType,
)
from intellicrack.utils.severity_levels import ConfidenceLevel


@pytest.fixture
def vuln_analyzer() -> VulnerabilityAnalyzer:
    """Create VulnerabilityAnalyzer instance for testing."""
    return VulnerabilityAnalyzer()


@pytest.fixture
def sample_binary_with_buffer_overflow(tmp_path: Path) -> Path:
    """Create binary with buffer overflow vulnerability patterns."""
    binary_path = tmp_path / "vulnerable.exe"

    dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
    pe_signature = b"PE\x00\x00"
    coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)

    vulnerable_code = b"strcpy" + b"\x00" * 50
    vulnerable_code += b"gets" + b"\x00" * 50
    vulnerable_code += b"sprintf" + b"\x00" * 50

    content = dos_header + b"\x00" * (0x80 - len(dos_header))
    content += pe_signature + coff_header + b"\x00" * 200
    content += vulnerable_code + b"\x00" * 1000

    binary_path.write_bytes(content)
    return binary_path


@pytest.fixture
def sample_binary_with_format_string(tmp_path: Path) -> Path:
    """Create binary with format string vulnerability patterns."""
    binary_path = tmp_path / "format_vuln.exe"

    dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
    vulnerable_code = b'printf("%s")' + b"\x00" * 50
    vulnerable_code += b'fprintf(fp, "%d")' + b"\x00" * 50

    content = dos_header + b"\x00" * (0x80 - len(dos_header))
    content += b"PE\x00\x00" + b"\x00" * 200
    content += vulnerable_code + b"\x00" * 1000

    binary_path.write_bytes(content)
    return binary_path


@pytest.fixture
def sample_secure_binary(tmp_path: Path) -> Path:
    """Create binary with secure functions."""
    binary_path = tmp_path / "secure.exe"

    dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
    secure_code = b"strncpy" + b"\x00" * 50
    secure_code += b"fgets" + b"\x00" * 50
    secure_code += b"snprintf" + b"\x00" * 50

    content = dos_header + b"\x00" * (0x80 - len(dos_header))
    content += b"PE\x00\x00" + b"\x00" * 200
    content += secure_code + b"\x00" * 1000

    binary_path.write_bytes(content)
    return binary_path


class TestVulnerabilityAnalyzerInitialization:
    """Test VulnerabilityAnalyzer initialization."""

    def test_analyzer_initializes_vulnerability_patterns(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Analyzer initializes with vulnerability detection patterns."""
        assert vuln_analyzer.vulnerability_patterns is not None
        assert len(vuln_analyzer.vulnerability_patterns) > 0
        assert VulnerabilityType.BUFFER_OVERFLOW in vuln_analyzer.vulnerability_patterns
        assert VulnerabilityType.FORMAT_STRING in vuln_analyzer.vulnerability_patterns

    def test_analyzer_initializes_cache(self, vuln_analyzer: VulnerabilityAnalyzer) -> None:
        """Analyzer initializes with analysis cache."""
        assert vuln_analyzer.analysis_cache is not None
        assert isinstance(vuln_analyzer.analysis_cache, dict)

    def test_analyzer_has_vulnerability_pattern_definitions(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Vulnerability patterns have required structure."""
        for vuln_type, pattern_info in vuln_analyzer.vulnerability_patterns.items():
            assert isinstance(vuln_type, VulnerabilityType)
            assert "functions" in pattern_info or "patterns" in pattern_info
            assert "severity" in pattern_info


class TestBasicVulnerabilityAnalysis:
    """Test basic vulnerability analysis functionality."""

    def test_analyze_vulnerability_with_valid_target(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Vulnerability analysis completes for valid binary."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result is not None
        assert isinstance(result, dict)
        assert "success" in result
        assert "vulnerabilities" in result
        assert "statistics" in result
        assert "recommendations" in result

    def test_analyze_nonexistent_target_returns_error(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Analysis of nonexistent target returns error."""
        result = vuln_analyzer.analyze_vulnerability(
            "D:\\nonexistent\\binary.exe", AnalysisMethod.STATIC
        )

        assert result["success"] is False
        assert result["error"] is not None
        assert "not found" in result["error"].lower()

    def test_analyze_vulnerability_returns_all_required_fields(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis result contains all required fields."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        required_fields = [
            "success",
            "target_path",
            "analysis_method",
            "vulnerabilities",
            "statistics",
            "recommendations",
            "analysis_time",
            "confidence_scores",
        ]

        for field in required_fields:
            assert field in result


class TestBufferOverflowDetection:
    """Test buffer overflow vulnerability detection."""

    def test_detect_strcpy_vulnerability(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Detects strcpy buffer overflow vulnerability."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result is not None
        vulnerabilities = result.get("vulnerabilities", [])
        assert isinstance(vulnerabilities, list)

    def test_buffer_overflow_patterns_include_unsafe_functions(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Buffer overflow patterns include known unsafe functions."""
        bo_patterns = vuln_analyzer.vulnerability_patterns[VulnerabilityType.BUFFER_OVERFLOW]

        unsafe_funcs = ["strcpy", "strcat", "sprintf", "gets"]
        for func in unsafe_funcs:
            assert func in bo_patterns["functions"]


class TestFormatStringDetection:
    """Test format string vulnerability detection."""

    def test_format_string_patterns_include_printf_family(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Format string patterns include printf family functions."""
        fs_patterns = vuln_analyzer.vulnerability_patterns[VulnerabilityType.FORMAT_STRING]

        printf_funcs = ["printf", "fprintf", "sprintf", "snprintf"]
        for func in printf_funcs:
            assert func in fs_patterns["functions"]


class TestAnalysisMethods:
    """Test different analysis methods."""

    def test_static_analysis_method(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Static analysis method completes successfully."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result is not None
        assert result["analysis_method"] == AnalysisMethod.STATIC.value

    def test_dynamic_analysis_method(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Dynamic analysis method completes successfully."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.DYNAMIC
        )

        assert result is not None
        assert result["analysis_method"] == AnalysisMethod.DYNAMIC.value

    def test_hybrid_analysis_method(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Hybrid analysis method combines static and dynamic."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.HYBRID
        )

        assert result is not None
        assert result["analysis_method"] == AnalysisMethod.HYBRID.value

    def test_ml_assisted_analysis_method(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """ML-assisted analysis method completes."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.ML_ASSISTED
        )

        assert result is not None
        assert result["analysis_method"] == AnalysisMethod.ML_ASSISTED.value


class TestSpecificVulnerabilityTypes:
    """Test detection of specific vulnerability types."""

    def test_analyze_specific_vulnerability_type(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis can target specific vulnerability types."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow),
            AnalysisMethod.STATIC,
            [VulnerabilityType.BUFFER_OVERFLOW],
        )

        assert result is not None
        assert isinstance(result, dict)

    def test_analyze_multiple_vulnerability_types(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis can target multiple vulnerability types."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow),
            AnalysisMethod.STATIC,
            [VulnerabilityType.BUFFER_OVERFLOW, VulnerabilityType.FORMAT_STRING],
        )

        assert result is not None


class TestConfidenceScores:
    """Test confidence score calculation for vulnerabilities."""

    def test_confidence_scores_calculated(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Confidence scores are calculated for detected vulnerabilities."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert "confidence_scores" in result
        assert isinstance(result["confidence_scores"], dict)

    def test_confidence_scores_in_valid_range(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Confidence scores are within valid range."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        for score_type, score_value in result["confidence_scores"].items():
            if isinstance(score_value, (int, float)):
                assert 0.0 <= score_value <= 1.0


class TestStatisticsGeneration:
    """Test vulnerability statistics generation."""

    def test_statistics_generated(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Vulnerability statistics are generated."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert "statistics" in result
        assert isinstance(result["statistics"], dict)

    def test_analysis_time_recorded(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis execution time is recorded."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert "analysis_time" in result
        assert result["analysis_time"] >= 0


class TestRecommendationsGeneration:
    """Test security recommendations generation."""

    def test_recommendations_generated(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Security recommendations are generated."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert "recommendations" in result
        assert isinstance(result["recommendations"], list)


class TestAnalysisCaching:
    """Test analysis result caching."""

    def test_analysis_results_cached(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis results are cached for repeated requests."""
        result1 = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        result2 = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result1 is not None
        assert result2 is not None
        assert len(vuln_analyzer.analysis_cache) > 0

    def test_cache_key_generation(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Cache keys are generated for analysis requests."""
        cache_key = vuln_analyzer._generate_cache_key(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC, None
        )

        assert cache_key is not None
        assert isinstance(cache_key, str)
        assert len(cache_key) > 0


class TestTargetAnalysis:
    """Test analyze_target method with target information."""

    def test_analyze_target_with_valid_info(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analyze target using target information dictionary."""
        target_info: dict[str, Any] = {
            "path": str(sample_binary_with_buffer_overflow),
            "type": "binary",
        }

        result = vuln_analyzer.analyze_target(target_info)

        assert result is not None
        assert isinstance(result, dict)

    def test_analyze_target_with_analysis_options(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analyze target with custom analysis options."""
        target_info: dict[str, Any] = {"path": str(sample_binary_with_buffer_overflow)}
        analysis_options: dict[str, Any] = {
            "analysis_method": "static",
            "vulnerability_types": ["buffer_overflow"],
        }

        result = vuln_analyzer.analyze_target(target_info, analysis_options)

        assert result is not None

    def test_analyze_target_missing_path_returns_error(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Analyze target with missing path returns error."""
        target_info: dict[str, Any] = {"type": "binary"}

        result = vuln_analyzer.analyze_target(target_info)

        assert result["success"] is False
        assert result["error"] is not None


class TestVulnerabilityMerging:
    """Test vulnerability deduplication and merging."""

    def test_merge_vulnerabilities_deduplicates(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Duplicate vulnerabilities are merged."""
        vulnerabilities = [
            {
                "type": VulnerabilityType.BUFFER_OVERFLOW.value,
                "location": "0x401000",
                "description": "strcpy vulnerability",
            },
            {
                "type": VulnerabilityType.BUFFER_OVERFLOW.value,
                "location": "0x401000",
                "description": "strcpy vulnerability",
            },
        ]

        merged = vuln_analyzer._merge_vulnerabilities(vulnerabilities)

        assert isinstance(merged, list)


class TestVulnerabilityPatterns:
    """Test vulnerability pattern definitions."""

    def test_all_vulnerability_types_have_patterns(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """All major vulnerability types have detection patterns."""
        critical_types = [
            VulnerabilityType.BUFFER_OVERFLOW,
            VulnerabilityType.FORMAT_STRING,
            VulnerabilityType.USE_AFTER_FREE,
            VulnerabilityType.INTEGER_OVERFLOW,
        ]

        for vuln_type in critical_types:
            assert vuln_type in vuln_analyzer.vulnerability_patterns

    def test_vulnerability_patterns_have_severity(
        self, vuln_analyzer: VulnerabilityAnalyzer
    ) -> None:
        """Vulnerability patterns include severity ratings."""
        for pattern_info in vuln_analyzer.vulnerability_patterns.values():
            assert "severity" in pattern_info
            assert pattern_info["severity"] in ["low", "medium", "high", "critical"]


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_analyze_empty_binary(self, vuln_analyzer: VulnerabilityAnalyzer, tmp_path: Path) -> None:
        """Analysis handles empty binary files."""
        empty_binary = tmp_path / "empty.bin"
        empty_binary.write_bytes(b"")

        result = vuln_analyzer.analyze_vulnerability(str(empty_binary), AnalysisMethod.STATIC)

        assert result is not None

    def test_analyze_very_small_binary(
        self, vuln_analyzer: VulnerabilityAnalyzer, tmp_path: Path
    ) -> None:
        """Analysis handles very small binaries."""
        small_binary = tmp_path / "small.bin"
        small_binary.write_bytes(b"MZ")

        result = vuln_analyzer.analyze_vulnerability(str(small_binary), AnalysisMethod.STATIC)

        assert result is not None

    def test_analyze_with_invalid_analysis_method(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Analysis defaults to valid method for invalid input."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result is not None


class TestRealWorldScenarios:
    """Test complete real-world vulnerability analysis scenarios."""

    def test_analyze_binary_with_multiple_vulnerabilities(
        self, vuln_analyzer: VulnerabilityAnalyzer, tmp_path: Path
    ) -> None:
        """Analyzes binary with multiple vulnerability types."""
        multi_vuln = tmp_path / "multi_vuln.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        vuln_code = b"strcpy" + b"\x00" * 30
        vuln_code += b"printf" + b"\x00" * 30
        vuln_code += b"malloc" + b"\x00" * 30
        vuln_code += b"free" + b"\x00" * 30

        content = dos_header + b"\x00" * (0x80 - len(dos_header))
        content += b"PE\x00\x00" + b"\x00" * 200
        content += vuln_code + b"\x00" * 1000

        multi_vuln.write_bytes(content)

        result = vuln_analyzer.analyze_vulnerability(str(multi_vuln), AnalysisMethod.STATIC)

        assert result is not None
        assert isinstance(result["vulnerabilities"], list)

    def test_compare_vulnerable_vs_patched_binary(
        self,
        vuln_analyzer: VulnerabilityAnalyzer,
        sample_binary_with_buffer_overflow: Path,
        sample_secure_binary: Path,
    ) -> None:
        """Compares vulnerability counts between vulnerable and secure binaries."""
        vuln_result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )
        secure_result = vuln_analyzer.analyze_vulnerability(
            str(sample_secure_binary), AnalysisMethod.STATIC
        )

        assert vuln_result is not None
        assert secure_result is not None

    def test_analyze_license_check_bypass_target(
        self, vuln_analyzer: VulnerabilityAnalyzer, tmp_path: Path
    ) -> None:
        """Analyzes binary with license check for bypass opportunities."""
        license_binary = tmp_path / "licensed_app.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        license_code = b"CheckLicense" + b"\x00" * 50
        license_code += b"ValidateSerial" + b"\x00" * 50
        license_code += b"RegQueryValueExW" + b"\x00" * 50

        content = dos_header + b"\x00" * (0x80 - len(dos_header))
        content += b"PE\x00\x00" + b"\x00" * 200
        content += license_code + b"\x00" * 1000

        license_binary.write_bytes(content)

        result = vuln_analyzer.analyze_vulnerability(str(license_binary), AnalysisMethod.HYBRID)

        assert result is not None
        assert result["success"] or result["error"] is not None


class TestPerformance:
    """Test performance characteristics of vulnerability analysis."""

    def test_static_analysis_completes_quickly(
        self, vuln_analyzer: VulnerabilityAnalyzer, sample_binary_with_buffer_overflow: Path
    ) -> None:
        """Static analysis completes within reasonable time."""
        result = vuln_analyzer.analyze_vulnerability(
            str(sample_binary_with_buffer_overflow), AnalysisMethod.STATIC
        )

        assert result["analysis_time"] < 30.0

    def test_analysis_of_larger_binary(
        self, vuln_analyzer: VulnerabilityAnalyzer, tmp_path: Path
    ) -> None:
        """Analysis handles larger binary files."""
        large_binary = tmp_path / "large.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        large_content = dos_header + b"\x00" * (0x80 - len(dos_header))
        large_content += b"PE\x00\x00" + b"\x00" * 200
        large_content += b"\x00" * 100000

        large_binary.write_bytes(large_content)

        result = vuln_analyzer.analyze_vulnerability(str(large_binary), AnalysisMethod.STATIC)

        assert result is not None


class TestVulnerabilityTypeEnumeration:
    """Test VulnerabilityType enumeration completeness."""

    def test_all_critical_vulnerability_types_defined(self) -> None:
        """All critical vulnerability types are defined in enum."""
        critical_types = [
            "BUFFER_OVERFLOW",
            "FORMAT_STRING",
            "INTEGER_OVERFLOW",
            "USE_AFTER_FREE",
            "DOUBLE_FREE",
            "NULL_POINTER_DEREFERENCE",
        ]

        for vuln_type in critical_types:
            assert hasattr(VulnerabilityType, vuln_type)

    def test_vulnerability_type_values_unique(self) -> None:
        """All vulnerability type values are unique."""
        values = [vt.value for vt in VulnerabilityType]
        assert len(values) == len(set(values))
