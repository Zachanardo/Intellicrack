"""Production tests for BaseAnalyzer vulnerability research base class.

This test suite validates the core functionality of the BaseAnalyzer class,
which provides foundational capabilities for vulnerability research and
binary protection analysis within Intellicrack.
"""

import logging
import time
from typing import Any

import pytest

from intellicrack.core.vulnerability_research.base_analyzer import BaseAnalyzer


class ConcreteAnalyzer(BaseAnalyzer):
    """Concrete implementation of BaseAnalyzer for testing purposes."""

    def analyze(self, target: str) -> dict[str, Any]:
        """Perform a basic analysis operation.

        Args:
            target: Target to analyze

        Returns:
            dict[str, Any]: Analysis results
        """
        start_time = time.time()
        result: dict[str, Any] = {"target": target, "vulnerabilities": []}

        try:
            if target == "error_case":
                raise ValueError("Simulated analysis error")

            result["vulnerabilities"] = [
                {"type": "licensing_bypass", "severity": "high"},
                {"type": "trial_reset", "severity": "medium"},
            ]

            return self.finalize_analysis_result(
                result,
                start_time,
                success_message="Found {count} vulnerabilities",
                count_key="vulnerabilities"
            )

        except Exception as e:
            return self.handle_analysis_error(result, e, start_time)


class TestBaseAnalyzerInitialization:
    """Tests for BaseAnalyzer initialization and setup."""

    def test_initialization_creates_logger(self) -> None:
        """BaseAnalyzer initializes with properly configured logger."""
        analyzer = ConcreteAnalyzer()

        assert hasattr(analyzer, "logger")
        assert isinstance(analyzer.logger, logging.Logger)
        assert analyzer.logger.name == "ConcreteAnalyzer"

    def test_initialization_inherits_result_mixin(self) -> None:
        """BaseAnalyzer properly inherits from ResultMixin."""
        analyzer = ConcreteAnalyzer()

        assert hasattr(analyzer, "logger")


class TestErrorHandling:
    """Tests for BaseAnalyzer error handling functionality."""

    def test_handle_analysis_error_captures_exception(self) -> None:
        """handle_analysis_error captures exception details in result dictionary."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"target": "test_binary.exe"}
        error = ValueError("License validation failed")

        updated_result = analyzer.handle_analysis_error(result, error, start_time)

        assert "error" in updated_result
        assert updated_result["error"] == "License validation failed"
        assert "target" in updated_result
        assert updated_result["target"] == "test_binary.exe"

    def test_handle_analysis_error_calculates_time(self) -> None:
        """handle_analysis_error accurately calculates analysis duration."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        time.sleep(0.01)
        result: dict[str, Any] = {}
        error = RuntimeError("Protection detection failed")

        updated_result = analyzer.handle_analysis_error(result, error, start_time)

        assert "analysis_time" in updated_result
        assert updated_result["analysis_time"] >= 0.01
        assert updated_result["analysis_time"] < 1.0

    def test_handle_analysis_error_preserves_existing_data(self) -> None:
        """handle_analysis_error does not overwrite existing result data."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {
            "target": "protected.exe",
            "partial_findings": ["vmprotect_detected"],
            "status": "in_progress"
        }
        error = Exception("Analysis interrupted")

        updated_result = analyzer.handle_analysis_error(result, error, start_time)

        assert updated_result["target"] == "protected.exe"
        assert updated_result["partial_findings"] == ["vmprotect_detected"]
        assert updated_result["status"] == "in_progress"
        assert "error" in updated_result

    def test_handle_analysis_error_logs_error(self, caplog: pytest.LogCaptureFixture) -> None:
        """handle_analysis_error logs error message at ERROR level."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {}
        error = RuntimeError("Keygen generation failed")

        with caplog.at_level(logging.ERROR):
            analyzer.handle_analysis_error(result, error, start_time)

        assert len(caplog.records) == 1
        assert caplog.records[0].levelname == "ERROR"
        assert "Analysis failed" in caplog.records[0].message
        assert "Keygen generation failed" in caplog.records[0].message


class TestAnalysisResultFinalization:
    """Tests for BaseAnalyzer result finalization functionality."""

    def test_finalize_analysis_result_sets_success_flag(self) -> None:
        """finalize_analysis_result marks result as successful."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"bypasses": []}

        finalized = analyzer.finalize_analysis_result(result, start_time)

        assert "success" in finalized
        assert finalized["success"] is True

    def test_finalize_analysis_result_calculates_time(self) -> None:
        """finalize_analysis_result accurately calculates analysis duration."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        time.sleep(0.01)
        result: dict[str, Any] = {}

        finalized = analyzer.finalize_analysis_result(result, start_time)

        assert "analysis_time" in finalized
        assert finalized["analysis_time"] >= 0.01
        assert finalized["analysis_time"] < 1.0

    def test_finalize_analysis_result_with_list_count(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result logs success message with list count."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {
            "license_bypasses": [
                {"method": "patch", "offset": 0x1234},
                {"method": "keygen", "algorithm": "RSA"},
                {"method": "trial_reset", "registry_key": "HKCU\\Software\\App"}
            ]
        }

        with caplog.at_level(logging.INFO):
            finalized = analyzer.finalize_analysis_result(
                result,
                start_time,
                success_message="Discovered {count} license bypasses",
                count_key="license_bypasses"
            )

        assert finalized["success"] is True
        assert len(caplog.records) == 1
        assert "Discovered 3 license bypasses" in caplog.records[0].message

    def test_finalize_analysis_result_with_dict_count(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result logs success message with dict count."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {
            "protection_schemes": {
                "vmprotect": {"version": "3.5", "strength": "high"},
                "themida": {"version": "3.1", "strength": "high"},
                "asprotect": {"version": "2.5", "strength": "medium"}
            }
        }

        with caplog.at_level(logging.INFO):
            analyzer.finalize_analysis_result(
                result,
                start_time,
                success_message="Identified {count} protection schemes",
                count_key="protection_schemes"
            )

        assert len(caplog.records) == 1
        assert "Identified 3 protection schemes" in caplog.records[0].message

    def test_finalize_analysis_result_with_primitive_count(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result logs success message with primitive count."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"key_generation_attempts": 42}

        with caplog.at_level(logging.INFO):
            analyzer.finalize_analysis_result(
                result,
                start_time,
                success_message="Performed {count} key generation attempts",
                count_key="key_generation_attempts"
            )

        assert len(caplog.records) == 1
        assert "Performed 42 key generation attempts" in caplog.records[0].message

    def test_finalize_analysis_result_without_success_message(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result works without success message."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"data": "test"}

        with caplog.at_level(logging.INFO):
            finalized = analyzer.finalize_analysis_result(result, start_time)

        assert finalized["success"] is True
        assert "analysis_time" in finalized
        assert len(caplog.records) == 0

    def test_finalize_analysis_result_missing_count_key(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result handles missing count_key gracefully."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"other_data": "value"}

        with caplog.at_level(logging.INFO):
            finalized = analyzer.finalize_analysis_result(
                result,
                start_time,
                success_message="Found {count} items",
                count_key="missing_key"
            )

        assert finalized["success"] is True
        assert len(caplog.records) == 0

    def test_finalize_analysis_result_preserves_existing_data(self) -> None:
        """finalize_analysis_result does not overwrite existing result data."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {
            "target": "license_server.dll",
            "algorithms_found": ["RSA-2048", "AES-256"],
            "complexity_score": 8.5
        }

        finalized = analyzer.finalize_analysis_result(result, start_time)

        assert finalized["target"] == "license_server.dll"
        assert finalized["algorithms_found"] == ["RSA-2048", "AES-256"]
        assert finalized["complexity_score"] == 8.5
        assert finalized["success"] is True


class TestConcreteAnalyzerIntegration:
    """Integration tests using concrete analyzer implementation."""

    def test_successful_analysis_workflow(self) -> None:
        """Complete successful analysis workflow from start to finish."""
        analyzer = ConcreteAnalyzer()

        result = analyzer.analyze("test_target.exe")

        assert result["success"] is True
        assert "analysis_time" in result
        assert result["target"] == "test_target.exe"
        assert len(result["vulnerabilities"]) == 2
        assert result["vulnerabilities"][0]["type"] == "licensing_bypass"
        assert result["vulnerabilities"][1]["type"] == "trial_reset"

    def test_error_analysis_workflow(self) -> None:
        """Complete error analysis workflow from start to finish."""
        analyzer = ConcreteAnalyzer()

        result = analyzer.analyze("error_case")

        assert "error" in result
        assert result["error"] == "Simulated analysis error"
        assert "analysis_time" in result
        assert result["target"] == "error_case"
        assert "success" not in result or result.get("success") is not True

    def test_multiple_sequential_analyses(self) -> None:
        """Analyzer handles multiple sequential analysis operations correctly."""
        analyzer = ConcreteAnalyzer()

        result1 = analyzer.analyze("target1.exe")
        result2 = analyzer.analyze("target2.exe")
        result3 = analyzer.analyze("error_case")

        assert result1["success"] is True
        assert result1["target"] == "target1.exe"

        assert result2["success"] is True
        assert result2["target"] == "target2.exe"

        assert "error" in result3
        assert result3["target"] == "error_case"

    def test_analysis_timing_accuracy(self) -> None:
        """Analysis timing measurements are accurate across operations."""
        analyzer = ConcreteAnalyzer()
        start_overall = time.time()

        result = analyzer.analyze("timed_target.exe")
        end_overall = time.time()

        assert "analysis_time" in result
        assert result["analysis_time"] <= (end_overall - start_overall)
        assert result["analysis_time"] > 0


class TestEdgeCases:
    """Edge case tests for BaseAnalyzer."""

    def test_empty_result_dictionary(self) -> None:
        """BaseAnalyzer handles empty result dictionaries correctly."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {}

        finalized = analyzer.finalize_analysis_result(result, start_time)

        assert finalized["success"] is True
        assert "analysis_time" in finalized
        assert len(finalized) == 2

    def test_zero_duration_analysis(self) -> None:
        """BaseAnalyzer handles near-instantaneous analysis correctly."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {}

        finalized = analyzer.finalize_analysis_result(result, start_time)

        assert "analysis_time" in finalized
        assert finalized["analysis_time"] >= 0

    def test_exception_with_complex_message(self) -> None:
        """handle_analysis_error handles complex exception messages."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {}
        error = RuntimeError(
            "Multi-line error\nwith special characters: @#$%\n"
            "and detailed information about licensing bypass failure"
        )

        updated_result = analyzer.handle_analysis_error(result, error, start_time)

        assert "error" in updated_result
        assert "Multi-line error" in updated_result["error"]
        assert "special characters" in updated_result["error"]

    def test_success_message_with_zero_count(self, caplog: pytest.LogCaptureFixture) -> None:
        """finalize_analysis_result logs success message even with zero count."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        result: dict[str, Any] = {"findings": []}

        with caplog.at_level(logging.INFO):
            analyzer.finalize_analysis_result(
                result,
                start_time,
                success_message="Found {count} findings",
                count_key="findings"
            )

        assert len(caplog.records) == 1
        assert "Found 0 findings" in caplog.records[0].message

    def test_result_dictionary_mutation_safety(self) -> None:
        """BaseAnalyzer methods safely mutate result dictionaries."""
        analyzer = ConcreteAnalyzer()
        start_time = time.time()
        original_result: dict[str, Any] = {"key": "value"}

        finalized = analyzer.finalize_analysis_result(original_result, start_time)

        assert finalized is original_result
        assert finalized["key"] == "value"
        assert finalized["success"] is True
