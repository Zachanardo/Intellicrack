"""Production Tests for Binary Differ.

Tests validate real binary comparison and patch analysis for vulnerability research.
All tests verify production-ready binary diffing without mocks or stubs.

Copyright (C) 2025 Zachary Flint
"""

from __future__ import annotations

import os
import struct
from pathlib import Path
from typing import Any

import pytest

from intellicrack.core.vulnerability_research.binary_differ import (
    BinaryDiffer,
    DiffType,
)
from intellicrack.core.vulnerability_research.common_enums import SecurityRelevance


@pytest.fixture
def binary_differ() -> BinaryDiffer:
    """Create BinaryDiffer instance for testing."""
    return BinaryDiffer()


@pytest.fixture
def sample_pe_binary(tmp_path: Path) -> Path:
    """Create a minimal valid PE binary for testing."""
    pe_path = tmp_path / "original.exe"

    dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
    pe_signature = b"PE\x00\x00"
    coff_header = struct.pack(
        "<HHIIIHH",
        0x014C,
        1,
        0,
        0,
        0,
        0xE0,
        0x010B,
    )
    optional_header = b"\x0b\x01" + b"\x00" * 222

    pe_content = dos_header + b"\x00" * (0x80 - len(dos_header))
    pe_content += pe_signature + coff_header + optional_header
    pe_content += b"\x00" * 512

    pe_path.write_bytes(pe_content)
    return pe_path


@pytest.fixture
def modified_pe_binary(tmp_path: Path, sample_pe_binary: Path) -> Path:
    """Create a modified version of the PE binary."""
    modified_path = tmp_path / "modified.exe"

    original_content = sample_pe_binary.read_bytes()
    modified_content = original_content[:-100] + b"\x41" * 100

    modified_path.write_bytes(modified_content)
    return modified_path


@pytest.fixture
def patched_binary_with_security_change(tmp_path: Path) -> tuple[Path, Path]:
    """Create two binaries simulating a security patch."""
    old_binary = tmp_path / "vulnerable.exe"
    new_binary = tmp_path / "patched.exe"

    dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
    pe_signature = b"PE\x00\x00"
    coff_header = struct.pack("<HHIIIHH", 0x014C, 1, 0, 0, 0, 0xE0, 0x010B)
    optional_header = b"\x0b\x01" + b"\x00" * 222

    base_content = dos_header + b"\x00" * (0x80 - len(dos_header))
    base_content += pe_signature + coff_header + optional_header

    vulnerable_code = b"strcpy" + b"\x00" * 100 + b"sprintf" + b"\x00" * 100
    patched_code = b"strncpy" + b"\x00" * 99 + b"snprintf" + b"\x00" * 99

    old_binary.write_bytes(base_content + vulnerable_code + b"\x00" * 1024)
    new_binary.write_bytes(base_content + patched_code + b"\x00" * 1024)

    return old_binary, new_binary


class TestBinaryDifferInitialization:
    """Test BinaryDiffer initialization and configuration."""

    def test_differ_initializes_security_functions(
        self, binary_differ: BinaryDiffer
    ) -> None:
        """BinaryDiffer initializes with security function patterns."""
        assert binary_differ.security_functions is not None
        assert "memory" in binary_differ.security_functions
        assert "crypto" in binary_differ.security_functions
        assert "auth" in binary_differ.security_functions

    def test_differ_initializes_security_mitigations(
        self, binary_differ: BinaryDiffer
    ) -> None:
        """BinaryDiffer initializes with security mitigation patterns."""
        assert binary_differ.security_mitigations is not None
        assert "stack_protection" in binary_differ.security_mitigations
        assert "aslr" in binary_differ.security_mitigations
        assert "dep" in binary_differ.security_mitigations

    def test_differ_initializes_vulnerability_patterns(
        self, binary_differ: BinaryDiffer
    ) -> None:
        """BinaryDiffer initializes with vulnerability patterns."""
        assert binary_differ.vuln_patterns is not None
        assert "buffer_overflow" in binary_differ.vuln_patterns
        assert "format_string" in binary_differ.vuln_patterns
        assert "use_after_free" in binary_differ.vuln_patterns

    def test_differ_initializes_analysis_cache(self, binary_differ: BinaryDiffer) -> None:
        """BinaryDiffer initializes with empty analysis cache."""
        assert binary_differ.analysis_cache is not None
        assert isinstance(binary_differ.analysis_cache, dict)


class TestBasicBinaryComparison:
    """Test basic binary comparison functionality."""

    def test_compare_identical_binaries(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """Comparing identical binaries shows no content differences."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(sample_pe_binary), analysis_level="basic"
        )

        assert result is not None
        assert isinstance(result, dict)
        assert "differences" in result
        assert "security_impact" in result

        content_diffs = [
            d for d in result["differences"] if d["type"] == DiffType.DATA_CHANGED.value
        ]
        hash_diffs = [d for d in content_diffs if "content changed" in d["description"].lower()]
        assert len(hash_diffs) == 0

    def test_compare_different_binaries_detects_changes(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comparing different binaries detects content changes."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        assert result is not None
        assert len(result["differences"]) > 0

        has_content_change = any(
            d["type"] == DiffType.DATA_CHANGED.value for d in result["differences"]
        )
        assert has_content_change

    def test_compare_binaries_detects_size_change(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Binary comparison detects file size changes."""
        binary1 = tmp_path / "small.bin"
        binary2 = tmp_path / "large.bin"

        binary1.write_bytes(b"MZ" + b"\x00" * 1000)
        binary2.write_bytes(b"MZ" + b"\x00" * 2000)

        result = binary_differ.compare_binaries(
            str(binary1), str(binary2), analysis_level="basic"
        )

        size_diffs = [
            d
            for d in result["differences"]
            if "size changed" in d.get("description", "").lower()
        ]
        assert len(size_diffs) > 0

    def test_compare_nonexistent_old_binary(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """Comparison with nonexistent old binary returns error."""
        result = binary_differ.compare_binaries(
            "D:\\nonexistent\\old.exe", str(sample_pe_binary)
        )

        assert result["success"] is False
        assert result["error"] is not None
        assert "not found" in result["error"].lower()

    def test_compare_nonexistent_new_binary(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """Comparison with nonexistent new binary returns error."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), "D:\\nonexistent\\new.exe"
        )

        assert result["success"] is False
        assert result["error"] is not None
        assert "not found" in result["error"].lower()


class TestSectionAnalysis:
    """Test binary section comparison."""

    def test_detect_section_modifications(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, tmp_path: Path
    ) -> None:
        """Section modifications are detected in binary comparison."""
        modified = tmp_path / "modified_sections.exe"
        original_content = sample_pe_binary.read_bytes()

        modified_content = original_content[:200] + b"\xFF" * 100 + original_content[300:]
        modified.write_bytes(modified_content)

        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified), analysis_level="basic"
        )

        assert result is not None
        assert len(result["differences"]) > 0


class TestSecurityRelevanceAssessment:
    """Test security relevance assessment of binary changes."""

    def test_security_impact_includes_relevance_scores(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Security impact assessment includes relevance scores."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="comprehensive"
        )

        assert "security_impact" in result
        assert isinstance(result["security_impact"], dict)

    def test_differences_include_security_relevance(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Each difference includes security relevance rating."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        for diff in result["differences"]:
            assert "security_relevance" in diff
            assert diff["security_relevance"] in [sr.value for sr in SecurityRelevance]


class TestHashCalculation:
    """Test binary hash calculation."""

    def test_calculate_file_hash_returns_valid_hash(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """File hash calculation returns valid SHA256 hash."""
        file_hash = binary_differ._calculate_file_hash(str(sample_pe_binary))

        assert file_hash is not None
        assert isinstance(file_hash, str)
        assert len(file_hash) == 64

    def test_identical_files_have_same_hash(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Identical files produce identical hashes."""
        binary1 = tmp_path / "test1.bin"
        binary2 = tmp_path / "test2.bin"

        content = b"MZ" + b"\x00" * 1000
        binary1.write_bytes(content)
        binary2.write_bytes(content)

        hash1 = binary_differ._calculate_file_hash(str(binary1))
        hash2 = binary_differ._calculate_file_hash(str(binary2))

        assert hash1 == hash2

    def test_different_files_have_different_hashes(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Different files produce different hashes."""
        binary1 = tmp_path / "test1.bin"
        binary2 = tmp_path / "test2.bin"

        binary1.write_bytes(b"MZ" + b"\x00" * 1000)
        binary2.write_bytes(b"MZ" + b"\xFF" * 1000)

        hash1 = binary_differ._calculate_file_hash(str(binary1))
        hash2 = binary_differ._calculate_file_hash(str(binary2))

        assert hash1 != hash2


class TestAnalysisLevels:
    """Test different analysis depth levels."""

    def test_basic_analysis_level_completes(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Basic analysis level completes successfully."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        assert result is not None
        assert "analysis_level" in result
        assert result["analysis_level"] == "basic"
        assert "analysis_time" in result

    def test_intermediate_analysis_level_completes(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Intermediate analysis level completes successfully."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="intermediate"
        )

        assert result is not None
        assert result["analysis_level"] == "intermediate"

    def test_comprehensive_analysis_level_completes(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comprehensive analysis level completes successfully."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="comprehensive"
        )

        assert result is not None
        assert result["analysis_level"] == "comprehensive"

    def test_comprehensive_analysis_includes_more_details(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comprehensive analysis provides more detailed results."""
        basic_result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )
        comprehensive_result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="comprehensive"
        )

        assert len(comprehensive_result.get("recommendations", [])) >= len(
            basic_result.get("recommendations", [])
        )


class TestStatisticsGeneration:
    """Test statistics generation for binary comparisons."""

    def test_comparison_result_includes_statistics(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comparison results include statistical data."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        assert "statistics" in result
        assert isinstance(result["statistics"], dict)

    def test_statistics_include_analysis_time(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Statistics include analysis execution time."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        assert "analysis_time" in result
        assert result["analysis_time"] >= 0


class TestRecommendationsGeneration:
    """Test security recommendations generation."""

    def test_comparison_includes_recommendations(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comparison results include security recommendations."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="comprehensive"
        )

        assert "recommendations" in result
        assert isinstance(result["recommendations"], list)


class TestDifferentBinaryFormats:
    """Test diffing various binary formats."""

    def test_compare_elf_binaries(self, binary_differ: BinaryDiffer, tmp_path: Path) -> None:
        """Binary differ handles ELF format binaries."""
        elf1 = tmp_path / "program1.elf"
        elf2 = tmp_path / "program2.elf"

        elf_header = b"\x7fELF" + b"\x02\x01\x01\x00" + b"\x00" * 8
        elf1.write_bytes(elf_header + b"\x00" * 1000)
        elf2.write_bytes(elf_header + b"\xFF" * 1000)

        result = binary_differ.compare_binaries(
            str(elf1), str(elf2), analysis_level="basic"
        )

        assert result is not None
        assert len(result["differences"]) > 0

    def test_compare_raw_binaries(self, binary_differ: BinaryDiffer, tmp_path: Path) -> None:
        """Binary differ handles raw binary files."""
        raw1 = tmp_path / "firmware1.bin"
        raw2 = tmp_path / "firmware2.bin"

        raw1.write_bytes(b"\x00" * 2048)
        raw2.write_bytes(b"\xFF" * 2048)

        result = binary_differ.compare_binaries(
            str(raw1), str(raw2), analysis_level="basic"
        )

        assert result is not None
        assert len(result["differences"]) > 0


class TestVulnerabilityPatternDetection:
    """Test detection of vulnerability patterns in binary diffs."""

    def test_detect_unsafe_function_usage(
        self, binary_differ: BinaryDiffer, patched_binary_with_security_change: tuple[Path, Path]
    ) -> None:
        """Detects changes from unsafe to safe function usage."""
        old_binary, new_binary = patched_binary_with_security_change

        result = binary_differ.compare_binaries(
            str(old_binary), str(new_binary), analysis_level="comprehensive"
        )

        assert result is not None
        assert len(result["differences"]) > 0


class TestSecurityFunctionDetection:
    """Test detection of security-relevant functions."""

    def test_identify_security_functions_in_patterns(
        self, binary_differ: BinaryDiffer
    ) -> None:
        """Security function patterns are properly categorized."""
        assert "malloc" in binary_differ.security_functions["memory"]
        assert "encrypt" in binary_differ.security_functions["crypto"]
        assert "authenticate" in binary_differ.security_functions["auth"]

    def test_identify_security_mitigations(self, binary_differ: BinaryDiffer) -> None:
        """Security mitigation patterns are properly defined."""
        assert "__stack_chk_fail" in binary_differ.security_mitigations["stack_protection"]
        assert "CFG" in binary_differ.security_mitigations["cfg"]


class TestImportAnalysis:
    """Test import table analysis capabilities."""

    def test_extract_imports_from_binary(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """Import extraction returns list of imports."""
        imports = binary_differ._extract_imports(str(sample_pe_binary))

        assert isinstance(imports, list)


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_compare_empty_binaries(self, binary_differ: BinaryDiffer, tmp_path: Path) -> None:
        """Comparing empty binaries handles gracefully."""
        empty1 = tmp_path / "empty1.bin"
        empty2 = tmp_path / "empty2.bin"

        empty1.write_bytes(b"")
        empty2.write_bytes(b"")

        result = binary_differ.compare_binaries(
            str(empty1), str(empty2), analysis_level="basic"
        )

        assert result is not None

    def test_compare_very_small_binaries(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Comparing very small binaries works correctly."""
        small1 = tmp_path / "small1.bin"
        small2 = tmp_path / "small2.bin"

        small1.write_bytes(b"MZ")
        small2.write_bytes(b"MZ")

        result = binary_differ.compare_binaries(
            str(small1), str(small2), analysis_level="basic"
        )

        assert result is not None

    def test_compare_binaries_with_invalid_analysis_level(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path
    ) -> None:
        """Invalid analysis level defaults to basic or comprehensive."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(sample_pe_binary), analysis_level="invalid_level"
        )

        assert result is not None
        assert isinstance(result, dict)


class TestResultStructure:
    """Test structure and completeness of comparison results."""

    def test_result_has_all_required_fields(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Comparison result contains all required fields."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        required_fields = [
            "success",
            "old_binary",
            "new_binary",
            "analysis_level",
            "differences",
            "security_impact",
            "statistics",
            "recommendations",
            "analysis_time",
        ]

        for field in required_fields:
            assert field in result

    def test_difference_entries_have_required_fields(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Each difference entry has required fields."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="basic"
        )

        for diff in result["differences"]:
            assert "type" in diff
            assert "description" in diff
            assert "security_relevance" in diff


class TestRealWorldScenarios:
    """Test complete real-world binary diffing scenarios."""

    def test_detect_security_patch_application(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Detects security patches between binary versions."""
        vulnerable = tmp_path / "app_v1.0.exe"
        patched = tmp_path / "app_v1.1.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        base = dos_header + b"\x00" * (0x80 - len(dos_header)) + b"PE\x00\x00"

        vuln_code = b"gets" + b"\x00" * 100 + b"strcpy" + b"\x00" * 100
        patch_code = b"fgets" + b"\x00" * 99 + b"strncpy" + b"\x00" * 99

        vulnerable.write_bytes(base + vuln_code + b"\x00" * 2000)
        patched.write_bytes(base + patch_code + b"\x00" * 2000)

        result = binary_differ.compare_binaries(
            str(vulnerable), str(patched), analysis_level="comprehensive"
        )

        assert result is not None
        assert len(result["differences"]) > 0

    def test_detect_feature_addition_vs_security_fix(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Distinguishes between feature additions and security fixes."""
        original = tmp_path / "app_original.exe"
        updated = tmp_path / "app_updated.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        base = dos_header + b"\x00" * (0x80 - len(dos_header)) + b"PE\x00\x00"

        original_features = b"feature_a" + b"\x00" * 100
        updated_features = b"feature_a" + b"\x00" * 50 + b"feature_b" + b"\x00" * 49

        original.write_bytes(base + original_features + b"\x00" * 2000)
        updated.write_bytes(base + updated_features + b"\x00" * 2000)

        result = binary_differ.compare_binaries(
            str(original), str(updated), analysis_level="comprehensive"
        )

        assert result is not None
        assert len(result["differences"]) > 0

    def test_analyze_multi_version_patch_series(
        self, binary_differ: BinaryDiffer, tmp_path: Path
    ) -> None:
        """Analyzes multiple versions in a patch series."""
        v1 = tmp_path / "app_v1.0.exe"
        v2 = tmp_path / "app_v2.0.exe"
        v3 = tmp_path / "app_v3.0.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        base = dos_header + b"\x00" * (0x80 - len(dos_header)) + b"PE\x00\x00"

        v1.write_bytes(base + b"\x00" * 1000)
        v2.write_bytes(base + b"\x11" * 1000)
        v3.write_bytes(base + b"\x22" * 1000)

        result_v1_v2 = binary_differ.compare_binaries(str(v1), str(v2), analysis_level="basic")
        result_v2_v3 = binary_differ.compare_binaries(str(v2), str(v3), analysis_level="basic")

        assert result_v1_v2 is not None
        assert result_v2_v3 is not None
        assert len(result_v1_v2["differences"]) > 0
        assert len(result_v2_v3["differences"]) > 0


class TestPerformance:
    """Test performance characteristics of binary diffing."""

    def test_analysis_completes_in_reasonable_time(
        self, binary_differ: BinaryDiffer, sample_pe_binary: Path, modified_pe_binary: Path
    ) -> None:
        """Binary analysis completes within reasonable time."""
        result = binary_differ.compare_binaries(
            str(sample_pe_binary), str(modified_pe_binary), analysis_level="comprehensive"
        )

        assert result["analysis_time"] < 30.0

    def test_large_binary_analysis(self, binary_differ: BinaryDiffer, tmp_path: Path) -> None:
        """Can analyze larger binary files."""
        large1 = tmp_path / "large1.exe"
        large2 = tmp_path / "large2.exe"

        dos_header = b"MZ" + b"\x90" * 58 + struct.pack("<I", 0x80)
        base = dos_header + b"\x00" * (0x80 - len(dos_header)) + b"PE\x00\x00"

        large1.write_bytes(base + b"\x00" * 50000)
        large2.write_bytes(base + b"\xFF" * 50000)

        result = binary_differ.compare_binaries(
            str(large1), str(large2), analysis_level="basic"
        )

        assert result is not None
        assert result["analysis_time"] < 60.0
