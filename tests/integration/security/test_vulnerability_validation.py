"""
Security tests for Intellicrack's vulnerability validation and exploit prevention.

This module contains comprehensive security tests for vulnerability validation and exploit prevention in Intellicrack,
including buffer overflow vulnerability detection and prevention,
format string vulnerability validation,
command injection detection and prevention,
SQL injection detection and prevention,
XSS prevention and validation,
timing attack resistance validation,
race condition vulnerability detection,
memory corruption protection mechanisms,
cryptographic vulnerability validation,
privilege escalation detection,
anti-exploitation mechanism validation,
polymorphic/metamorphic code detection,
API hooking detection and validation,
sandbox escape prevention and detection,
and various other security validation tests.
These tests ensure Intellicrack's security components work effectively to prevent
real-world vulnerabilities and exploit attempts.
"""

import pytest
import tempfile
import os
import struct
import subprocess
import threading
import time
import socket
import json
from pathlib import Path

from intellicrack.core.security_utils import SecurityUtils
from intellicrack.protection.protection_detector import ProtectionDetector
from intellicrack.core.exploitation.bypass_engine import BypassEngine
from intellicrack.core.anti_analysis.api_obfuscation import APIObfuscation
from intellicrack.core.anti_analysis.timing_attacks import TimingAttacks
from intellicrack.core.exploitation.polymorphic_engine import PolymorphicEngine
from intellicrack.core.app_context import AppContext


class TestVulnerabilityValidation:
    """Security tests for REAL vulnerability validation and exploit prevention."""

    @pytest.fixture
    def vulnerable_test_binary(self):
        """Create REAL vulnerable binary for security testing."""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as temp_file:
            # DOS Header
            dos_header = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'
            dos_header += b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00'
            dos_header += b'\x00' * 40
            dos_header += b'\x80\x00\x00\x00'
            dos_header += b'\x00' * 60

            # PE Signature
            pe_signature = b'PE\x00\x00'

            # COFF Header
            coff_header = b'\x4c\x01\x03\x00' + b'\x00' * 16

            # Optional Header
            optional_header = b'\x0b\x01\x0e\x00' + b'\x00' * 220

            # Section Headers
            text_section = b'.text\x00\x00\x00'
            text_section += b'\x00\x20\x00\x00'  # VirtualSize
            text_section += b'\x00\x10\x00\x00'  # VirtualAddress
            text_section += b'\x00\x20\x00\x00'  # SizeOfRawData
            text_section += b'\x00\x04\x00\x00'  # PointerToRawData
            text_section += b'\x00' * 12
            text_section += b'\x20\x00\x00\x60'  # Characteristics

            # Vulnerable code section
            vuln_code = b''

            # Stack buffer overflow vulnerability
            vuln_code += b'\x55'  # push ebp
            vuln_code += b'\x8b\xec'  # mov ebp, esp
            vuln_code += b'\x83\xec\x40'  # sub esp, 64 (small buffer)
            vuln_code += b'\x8b\x45\x08'  # mov eax, [ebp+8] (user input)
            vuln_code += b'\x8d\x4d\xc0'  # lea ecx, [ebp-64] (buffer)
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call strcpy (no bounds check)

            # Format string vulnerability
            vuln_code += b'\x8b\x45\x0c'  # mov eax, [ebp+12]
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call printf(user_input)

            # Command injection vulnerability
            vuln_code += b'\x8b\x45\x10'  # mov eax, [ebp+16]
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call system(user_input)

            # SQL injection simulation
            vuln_code += b'\x8b\x45\x14'  # mov eax, [ebp+20]
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call execute_query(user_input)

            # Pad to section size
            vuln_code += b'\x90' * (8192 - len(vuln_code))

            temp_file.write(dos_header + pe_signature + coff_header + optional_header +
                          text_section + vuln_code)
            temp_file.flush()
            yield temp_file.name

        try:
            os.unlink(temp_file.name)
        except Exception:
            pass

    @pytest.fixture
    def app_context(self):
        """Create REAL application context."""
        context = AppContext()
        context.initialize()
        return context

    @pytest.fixture
    def exploit_payloads(self):
        """REAL exploit payloads for testing."""
        return {
            'buffer_overflow': [
                b'A' * 100,  # Simple overflow
                b'A' * 64 + b'\x41\x41\x41\x41',  # EIP overwrite
                b'\x90' * 60 + b'\xeb\x06\x90\x90' + b'\x41\x41\x41\x41' + b'\xcc' * 50,  # With shellcode
                b'A' * 64 + struct.pack('<I', 0x41414141) + b'\x90' * 100  # ROP chain start
            ],
            'format_string': [
                b'%x%x%x%x',  # Stack leak
                b'%s%s%s%s',  # Crash attempt
                b'%n%n%n%n',  # Write attempt
                b'%08x' * 10 + b'%n',  # Controlled write
                b'AAAA%08x' * 8 + b'%s'  # Read from 0x41414141
            ],
            'command_injection': [
                b'; whoami',
                b'| net user hacker password /add',
                b'& powershell -enc <base64>',
                b'\n/bin/sh\n',
                b'`rm -rf /`'
            ],
            'sql_injection': [
                b"' OR '1'='1",
                b"'; DROP TABLE users; --",
                b"' UNION SELECT NULL, NULL, NULL--",
                b"admin'--",
                b"1' AND (SELECT * FROM users) --"
            ],
            'xss_payloads': [
                b'<script>alert(1)</script>',
                b'<img src=x onerror=alert(1)>',
                b'javascript:alert(1)',
                b'<svg onload=alert(1)>',
                b'"><script>alert(String.fromCharCode(88,83,83))</script>'
            ]
        }

    def test_buffer_overflow_detection_and_prevention(self, vulnerable_test_binary, exploit_payloads, app_context):
        """Test REAL buffer overflow vulnerability detection and prevention."""
        security_utils = SecurityUtils()
        protection_detector = ProtectionDetector()

        # Analyze binary for vulnerabilities
        vuln_analysis = security_utils.analyze_vulnerabilities(vulnerable_test_binary)
        assert vuln_analysis is not None, "Vulnerability analysis must succeed"
        assert 'buffer_overflow' in vuln_analysis, "Must detect buffer overflow"

        # Test each overflow payload
        for i, payload in enumerate(exploit_payloads['buffer_overflow']):
            # Simulate exploitation attempt
            exploit_result = security_utils.test_exploit_payload(
                vulnerable_test_binary,
                payload,
                'buffer_overflow'
            )

            assert exploit_result is not None, f"Exploit test {i} must return result"
            assert 'detected' in exploit_result, "Must have detection status"
            assert 'severity' in exploit_result, "Must assess severity"

            # Verify detection
            if len(payload) > 64:  # Actual overflow
                assert exploit_result['detected'], f"Overflow {i} must be detected"
                assert exploit_result['severity'] in ['high', 'critical'], \
                    "Buffer overflow must be high/critical severity"

            # Test prevention mechanism
            prevention_result = security_utils.apply_overflow_prevention(
                vulnerable_test_binary,
                payload
            )

            assert prevention_result is not None, "Prevention must return result"
            assert 'blocked' in prevention_result, "Must indicate if blocked"
            assert 'method' in prevention_result, "Must specify prevention method"

            if prevention_result['blocked']:
                assert prevention_result['method'] in [
                    'stack_canary', 'dep', 'aslr', 'control_flow_guard'
                ], "Must use valid prevention method"

    def test_format_string_vulnerability_validation(self, vulnerable_test_binary, exploit_payloads, app_context):
        """Test REAL format string vulnerability validation."""
        security_utils = SecurityUtils()

        # Test format string detection
        for i, payload in enumerate(exploit_payloads['format_string']):
            format_result = security_utils.validate_format_string_safety(payload)

            assert format_result is not None, f"Format validation {i} must return result"
            assert 'safe' in format_result, "Must indicate safety"
            assert 'risk_level' in format_result, "Must assess risk level"
            assert 'specifiers_found' in format_result, "Must identify format specifiers"

            # All test payloads should be unsafe
            assert not format_result['safe'], f"Payload {i} must be detected as unsafe"

            # Check specific dangerous patterns
            if b'%n' in payload:
                assert format_result['risk_level'] == 'critical', \
                    "%n format must be critical risk"
                assert 'write_attempt' in format_result, "Must detect write attempt"

            if b'%s' in payload:
                assert format_result['risk_level'] in ['high', 'critical'], \
                    "%s format must be high risk"
                assert 'read_violation' in format_result.get('warnings', []), \
                    "Must warn about potential read violation"

            # Test mitigation
            mitigated = security_utils.sanitize_format_string(payload)
            assert mitigated != payload, "Dangerous format strings must be sanitized"
            assert b'%n' not in mitigated, "%n must be removed"

    def test_command_injection_prevention(self, exploit_payloads, app_context):
        """Test REAL command injection detection and prevention."""
        security_utils = SecurityUtils()

        # Test each command injection payload
        for i, payload in enumerate(exploit_payloads['command_injection']):
            # Validate command safety
            cmd_result = security_utils.validate_command_safety(payload)

            assert cmd_result is not None, f"Command validation {i} must return result"
            assert 'safe' in cmd_result, "Must indicate safety"
            assert 'injection_chars' in cmd_result, "Must identify injection characters"
            assert 'risk_commands' in cmd_result, "Must identify risky commands"

            # All payloads should be detected as unsafe
            assert not cmd_result['safe'], f"Payload {i} must be unsafe"
            assert len(cmd_result['injection_chars']) > 0, "Must find injection chars"

            # Test command sanitization
            sanitized = security_utils.sanitize_command_input(payload)
            assert sanitized != payload, "Commands must be sanitized"

            # Verify dangerous characters removed/escaped
            dangerous_chars = [b';', b'|', b'&', b'`', b'\n']
            for char in dangerous_chars:
                if char in payload:
                    assert char not in sanitized or b'\\' + char in sanitized, \
                        f"Dangerous char {char} must be escaped/removed"

            # Test sandbox execution
            sandbox_result = security_utils.execute_in_sandbox(sanitized)
            assert sandbox_result is not None, "Sandbox execution must return result"
            assert 'executed' in sandbox_result, "Must indicate execution status"
            assert 'restricted' in sandbox_result, "Must show restrictions applied"

    def test_sql_injection_validation(self, exploit_payloads, app_context):
        """Test REAL SQL injection detection and prevention."""
        security_utils = SecurityUtils()

        # Test SQL injection patterns
        for i, payload in enumerate(exploit_payloads['sql_injection']):
            sql_result = security_utils.validate_sql_input(payload)

            assert sql_result is not None, f"SQL validation {i} must return result"
            assert 'safe' in sql_result, "Must indicate safety"
            assert 'injection_patterns' in sql_result, "Must identify patterns"
            assert 'risk_score' in sql_result, "Must calculate risk score"

            # All payloads should be detected
            assert not sql_result['safe'], f"SQL payload {i} must be unsafe"
            assert sql_result['risk_score'] >= 0.7, "Risk score must be high"

            # Check specific patterns
            patterns = sql_result['injection_patterns']
            if b"' OR" in payload or b"'=" in payload:
                assert 'boolean_injection' in patterns, "Must detect boolean injection"
            if b"UNION" in payload:
                assert 'union_injection' in patterns, "Must detect UNION injection"
            if b"--" in payload:
                assert 'comment_injection' in patterns, "Must detect comment injection"

            # Test parameterization
            param_result = security_utils.parameterize_query(
                b"SELECT * FROM users WHERE name = %s",
                payload
            )
            assert param_result is not None, "Parameterization must succeed"
            assert 'query' in param_result, "Must have parameterized query"
            assert 'params' in param_result, "Must have parameters"
            assert payload not in param_result['query'], \
                "User input must not be in query string"

    def test_xss_prevention_validation(self, exploit_payloads, app_context):
        """Test REAL XSS prevention and validation."""
        security_utils = SecurityUtils()

        # Test XSS detection
        for i, payload in enumerate(exploit_payloads['xss_payloads']):
            xss_result = security_utils.validate_xss_safety(payload)

            assert xss_result is not None, f"XSS validation {i} must return result"
            assert 'safe' in xss_result, "Must indicate safety"
            assert 'xss_type' in xss_result, "Must identify XSS type"
            assert 'dangerous_elements' in xss_result, "Must find dangerous elements"

            # All payloads should be detected
            assert not xss_result['safe'], f"XSS payload {i} must be unsafe"

            # Check XSS types
            if b'<script>' in payload:
                assert xss_result['xss_type'] == 'script', "Must detect script XSS"
            elif b'javascript:' in payload:
                assert xss_result['xss_type'] == 'javascript_uri', "Must detect JS URI"
            elif b'onerror=' in payload or b'onload=' in payload:
                assert xss_result['xss_type'] == 'event_handler', "Must detect event handler"

            # Test HTML encoding
            encoded = security_utils.html_encode(payload)
            assert b'<' not in encoded or encoded == b'&lt;', "< must be encoded"
            assert b'>' not in encoded or encoded == b'&gt;', "> must be encoded"
            assert b'"' not in encoded or encoded == b'&quot;', '" must be encoded'

            # Test CSP generation
            csp_result = security_utils.generate_csp_for_content(payload)
            assert csp_result is not None, "CSP generation must succeed"
            assert 'policy' in csp_result, "Must have CSP policy"
            assert 'script-src' in csp_result['policy'], "Must restrict scripts"

    def test_timing_attack_resistance(self, app_context):
        """Test REAL timing attack resistance validation."""
        timing_attacks = TimingAttacks()
        security_utils = SecurityUtils()

        # Test password comparison timing
        correct_password = b"SuperSecretPassword123!"
        test_passwords = [
            b"S",  # First char match
            b"SuperS",  # Partial match
            b"SuperSecretPassword123",  # Almost complete
            b"WrongPassword123!",  # No match
            correct_password  # Full match
        ]

        # Measure timing differences
        timing_results = []
        for test_pwd in test_passwords:
            timings = []
            for _ in range(100):  # Multiple measurements
                start = time.perf_counter_ns()
                result = security_utils.constant_time_compare(correct_password, test_pwd)
                end = time.perf_counter_ns()
                timings.append(end - start)

            avg_time = sum(timings) / len(timings)
            timing_results.append({
                'password': test_pwd,
                'avg_time': avg_time,
                'match': result
            })

        # Analyze timing variance
        times = [r['avg_time'] for r in timing_results]
        max_time = max(times)
        min_time = min(times)
        variance = (max_time - min_time) / min_time

        # Timing should be constant (low variance)
        assert variance < 0.1, f"Timing variance {variance} too high, vulnerable to timing attacks"

        # Test timing attack detection
        attack_detected = timing_attacks.detect_timing_attack(timing_results)
        assert not attack_detected, "Should not be vulnerable to timing attacks"

    def test_race_condition_vulnerability(self, app_context):
        """Test REAL race condition vulnerability detection."""
        security_utils = SecurityUtils()

        # Simulate race condition scenario
        shared_resource = {'counter': 0, 'lock': threading.Lock()}
        race_detected = False

        def unsafe_increment():
            # Unsafe operation without proper locking
            current = shared_resource['counter']
            time.sleep(0.001)  # Simulate processing
            shared_resource['counter'] = current + 1

        def safe_increment():
            # Safe operation with locking
            with shared_resource['lock']:
                current = shared_resource['counter']
                time.sleep(0.001)
                shared_resource['counter'] = current + 1

        # Test unsafe operation
        shared_resource['counter'] = 0
        threads = []
        for _ in range(10):
            t = threading.Thread(target=unsafe_increment)
            threads.append(t)
            t.start()

        for t in threads:
            t.join()

        # Check for race condition
        if shared_resource['counter'] != 10:
            race_detected = True

        assert race_detected or shared_resource['counter'] < 10, \
            "Race condition should cause incorrect counter"

        # Test safe operation
        shared_resource['counter'] = 0
        threads = []
        for _ in range(10):
            t = threading.Thread(target=safe_increment)
            threads.append(t)
            t.start()

        for t in threads:
            t.join()

        assert shared_resource['counter'] == 10, \
            "Safe operation should prevent race condition"

        # Test race condition detection
        race_result = security_utils.detect_race_conditions({
            'operations': ['read', 'write'],
            'shared_resources': ['counter'],
            'synchronization': False
        })

        assert race_result is not None, "Race detection must return result"
        assert race_result['vulnerable'], "Must detect race vulnerability"
        assert 'recommendations' in race_result, "Must provide recommendations"

    def test_memory_corruption_protection(self, vulnerable_test_binary, app_context):
        """Test REAL memory corruption protection mechanisms."""
        security_utils = SecurityUtils()
        protection_detector = ProtectionDetector()

        # Check memory protections
        protections = protection_detector.check_memory_protections(vulnerable_test_binary)
        assert protections is not None, "Protection check must succeed"

        # Test heap corruption detection
        heap_corruption_test = {
            'operation': 'double_free',
            'address': 0x10000000,
            'size': 256
        }

        heap_result = security_utils.detect_heap_corruption(heap_corruption_test)
        assert heap_result is not None, "Heap corruption detection must work"
        assert heap_result['detected'], "Double free must be detected"
        assert heap_result['type'] == 'double_free', "Must identify corruption type"

        # Test stack corruption detection
        stack_test = {
            'canary_value': 0xDEADBEEF,
            'current_value': 0x41414141,
            'return_address': 0x00401000
        }

        stack_result = security_utils.detect_stack_corruption(stack_test)
        assert stack_result is not None, "Stack corruption detection must work"
        assert stack_result['detected'], "Stack corruption must be detected"
        assert 'canary_mismatch' in stack_result, "Must detect canary corruption"

        # Test use-after-free detection
        uaf_test = {
            'freed_address': 0x20000000,
            'access_type': 'write',
            'access_after_free': True
        }

        uaf_result = security_utils.detect_use_after_free(uaf_test)
        assert uaf_result is not None, "UAF detection must work"
        assert uaf_result['detected'], "Use-after-free must be detected"
        assert uaf_result['severity'] == 'critical', "UAF must be critical"

    def test_cryptographic_vulnerability_validation(self, app_context):
        """Test REAL cryptographic vulnerability validation."""
        security_utils = SecurityUtils()

        # Test weak cryptography detection
        weak_crypto_tests = [
            {
                'algorithm': 'MD5',
                'key_size': None,
                'usage': 'password_hashing'
            },
            {
                'algorithm': 'DES',
                'key_size': 56,
                'usage': 'encryption'
            },
            {
                'algorithm': 'RC4',
                'key_size': 128,
                'usage': 'stream_cipher'
            },
            {
                'algorithm': 'SHA1',
                'key_size': None,
                'usage': 'digital_signature'
            }
        ]

        for crypto_test in weak_crypto_tests:
            crypto_result = security_utils.validate_cryptography(crypto_test)

            assert crypto_result is not None, f"Crypto validation must work for {crypto_test['algorithm']}"
            assert not crypto_result['secure'], f"{crypto_test['algorithm']} must be detected as insecure"
            assert 'vulnerabilities' in crypto_result, "Must list vulnerabilities"
            assert 'recommendations' in crypto_result, "Must provide recommendations"

            # Check specific vulnerabilities
            vulns = crypto_result['vulnerabilities']
            if crypto_test['algorithm'] == 'MD5':
                assert 'collision_attacks' in vulns, "Must mention MD5 collisions"
            elif crypto_test['algorithm'] == 'DES':
                assert 'key_size_insufficient' in vulns, "Must mention DES key size"
            elif crypto_test['algorithm'] == 'RC4':
                assert 'biases' in vulns or 'weak_cipher' in vulns, "Must mention RC4 weaknesses"

        # Test secure cryptography validation
        secure_crypto = {
            'algorithm': 'AES',
            'key_size': 256,
            'mode': 'GCM',
            'usage': 'encryption'
        }

        secure_result = security_utils.validate_cryptography(secure_crypto)
        assert secure_result['secure'], "AES-256-GCM should be secure"
        assert len(secure_result.get('vulnerabilities', [])) == 0, \
            "Secure crypto should have no vulnerabilities"

    def test_privilege_escalation_detection(self, app_context):
        """Test REAL privilege escalation vulnerability detection."""
        security_utils = SecurityUtils()
        bypass_engine = BypassEngine()

        # Test various privilege escalation vectors
        priv_esc_tests = [
            {
                'type': 'service_permissions',
                'service': 'VulnerableService',
                'permissions': 'SERVICE_ALL_ACCESS',
                'running_as': 'SYSTEM'
            },
            {
                'type': 'dll_hijacking',
                'target_process': 'admin_tool.exe',
                'search_order': ['current_dir', 'system32'],
                'writable_paths': ['current_dir']
            },
            {
                'type': 'unquoted_service_path',
                'path': 'C:\\Program Files\\Vulnerable App\\service.exe',
                'writable_locations': ['C:\\Program Files\\Vulnerable']
            },
            {
                'type': 'registry_permissions',
                'key': 'HKLM\\System\\CurrentControlSet\\Services\\VulnService',
                'permissions': 'KEY_ALL_ACCESS',
                'user': 'Users'
            }
        ]

        for test in priv_esc_tests:
            priv_result = security_utils.detect_privilege_escalation(test)

            assert priv_result is not None, f"Priv esc detection must work for {test['type']}"
            assert priv_result['vulnerable'], f"{test['type']} must be detected as vulnerable"
            assert 'exploitation_difficulty' in priv_result, "Must assess difficulty"
            assert 'impact' in priv_result, "Must assess impact"
            assert 'mitigation' in priv_result, "Must provide mitigation"

            # All test cases should be exploitable
            assert priv_result['exploitation_difficulty'] in ['low', 'medium'], \
                "Test cases should be exploitable"
            assert priv_result['impact'] in ['high', 'critical'], \
                "Privilege escalation should be high impact"

    def test_anti_exploit_mechanism_validation(self, vulnerable_test_binary, app_context):
        """Test REAL anti-exploitation mechanism validation."""
        protection_detector = ProtectionDetector()
        security_utils = SecurityUtils()

        # Check exploit mitigations
        mitigations = protection_detector.check_exploit_mitigations(vulnerable_test_binary)
        assert mitigations is not None, "Mitigation check must succeed"

        # Test each mitigation
        expected_mitigations = ['DEP', 'ASLR', 'CFG', 'Stack_Canaries', 'SafeSEH']

        for mitigation in expected_mitigations:
            if mitigation in mitigations:
                # Test bypass difficulty
                bypass_result = security_utils.assess_bypass_difficulty(
                    vulnerable_test_binary,
                    mitigation
                )

                assert bypass_result is not None, f"Bypass assessment must work for {mitigation}"
                assert 'difficulty' in bypass_result, "Must assess difficulty"
                assert 'techniques' in bypass_result, "Must list bypass techniques"
                assert 'success_rate' in bypass_result, "Must estimate success rate"

                # Verify mitigation effectiveness
                effectiveness = bypass_result.get('effectiveness', 0)
                assert effectiveness > 0, f"{mitigation} must have some effectiveness"

    def test_polymorphic_code_detection(self, app_context):
        """Test REAL polymorphic/metamorphic code detection."""
        polymorphic_engine = PolymorphicEngine()
        security_utils = SecurityUtils()

        # Generate polymorphic shellcode variants
        base_shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

        variants = []
        for i in range(5):
            variant = polymorphic_engine.generate_variant(base_shellcode)
            variants.append(variant)
            assert variant != base_shellcode, f"Variant {i} must be different"
            assert len(variant) >= len(base_shellcode), "Variant should not be smaller"

        # Test polymorphic detection
        for i, variant in enumerate(variants):
            poly_result = security_utils.detect_polymorphic_code(variant)

            assert poly_result is not None, f"Polymorphic detection {i} must work"
            assert 'is_polymorphic' in poly_result, "Must indicate if polymorphic"
            assert 'confidence' in poly_result, "Must have confidence score"
            assert 'indicators' in poly_result, "Must list indicators"

            # Should detect polymorphic characteristics
            if poly_result['is_polymorphic']:
                assert poly_result['confidence'] > 0.5, \
                    "Should have reasonable confidence"
                assert len(poly_result['indicators']) > 0, \
                    "Should have polymorphic indicators"

    def test_api_hooking_detection(self, app_context):
        """Test REAL API hooking detection and validation."""
        api_obfuscation = APIObfuscation()
        security_utils = SecurityUtils()

        # Simulate API hooks
        hook_tests = [
            {
                'api': 'CreateProcessW',
                'original_bytes': b'\x8b\xff\x55\x8b\xec',  # Original prologue
                'hooked_bytes': b'\xe9\x00\x00\x00\x00',  # JMP
                'hook_type': 'inline'
            },
            {
                'api': 'NtQuerySystemInformation',
                'original_bytes': b'\xb8\x36\x00\x00\x00',  # Original syscall
                'hooked_bytes': b'\xff\x25\x00\x00\x00\x00',  # JMP indirect
                'hook_type': 'iat'
            },
            {
                'api': 'VirtualProtect',
                'original_bytes': b'\x8b\xff\x55\x8b\xec',
                'hooked_bytes': b'\xcc\xcc\xcc\xcc\xcc',  # INT3 breakpoints
                'hook_type': 'debug'
            }
        ]

        for test in hook_tests:
            hook_result = security_utils.detect_api_hook(test)

            assert hook_result is not None, f"Hook detection must work for {test['api']}"
            assert hook_result['hooked'], f"{test['api']} must be detected as hooked"
            assert hook_result['hook_type'] == test['hook_type'], \
                f"Must correctly identify {test['hook_type']} hook"
            assert 'severity' in hook_result, "Must assess hook severity"

            # Test hook removal
            unhook_result = security_utils.remove_api_hook(test)
            assert unhook_result is not None, "Unhook must return result"
            assert 'success' in unhook_result, "Must indicate unhook success"

            if unhook_result['success']:
                assert unhook_result['restored_bytes'] == test['original_bytes'], \
                    "Must restore original bytes"

    def test_sandbox_escape_prevention(self, app_context):
        """Test REAL sandbox escape prevention and detection."""
        security_utils = SecurityUtils()

        # Test sandbox escape attempts
        escape_attempts = [
            {
                'method': 'process_hollowing',
                'target': 'svchost.exe',
                'payload': b'\xcc' * 100
            },
            {
                'method': 'com_hijacking',
                'clsid': '{00000000-0000-0000-0000-000000000000}',
                'dll_path': 'C:\\evil.dll'
            },
            {
                'method': 'token_manipulation',
                'privilege': 'SeDebugPrivilege',
                'target_pid': 4  # System process
            },
            {
                'method': 'job_object_escape',
                'restriction_bypass': 'handle_inheritance'
            }
        ]

        for attempt in escape_attempts:
            escape_result = security_utils.detect_sandbox_escape(attempt)

            assert escape_result is not None, f"Escape detection must work for {attempt['method']}"
            assert escape_result['detected'], f"{attempt['method']} must be detected"
            assert 'blocked' in escape_result, "Must indicate if blocked"
            assert 'severity' in escape_result, "Must assess severity"

            # All escape attempts should be high severity
            assert escape_result['severity'] in ['high', 'critical'], \
                "Sandbox escapes must be high severity"

            # Test prevention
            if escape_result['blocked']:
                assert 'prevention_method' in escape_result, \
                    "Must specify prevention method"
                assert escape_result['prevention_method'] in [
                    'process_isolation', 'privilege_restriction',
                    'handle_validation', 'com_filtering'
                ], "Must use valid prevention method"
