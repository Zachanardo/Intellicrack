import pytest
import tempfile
import os
import struct
import time
from pathlib import Path

from intellicrack.core.vulnerability_research.vulnerability_analyzer import VulnerabilityAnalyzer
from intellicrack.core.vulnerability_research.fuzzing_engine import FuzzingEngine
from intellicrack.core.vulnerability_research.binary_differ import BinaryDiffer
from intellicrack.core.vulnerability_research.research_manager import ResearchManager
from intellicrack.core.app_context import AppContext


class TestRealVulnerabilityResearch:
    """Functional tests for REAL vulnerability research operations."""

    @pytest.fixture
    def vulnerable_binary(self):
        """Create REAL vulnerable binary for testing."""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as temp_file:
            # DOS Header
            dos_header = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'
            dos_header += b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00'
            dos_header += b'\x00' * 40
            dos_header += b'\x80\x00\x00\x00'
            dos_header += b'\x00' * 60
            
            # PE Signature
            pe_signature = b'PE\x00\x00'
            
            # COFF Header
            coff_header = b'\x4c\x01\x03\x00' + b'\x00' * 16
            
            # Optional Header
            optional_header = b'\x0b\x01\x0e\x00' + b'\x00' * 220
            
            # Section Headers
            text_section = b'.text\x00\x00\x00'
            text_section += b'\x00\x10\x00\x00'  # VirtualSize
            text_section += b'\x00\x10\x00\x00'  # VirtualAddress
            text_section += b'\x00\x10\x00\x00'  # SizeOfRawData
            text_section += b'\x00\x04\x00\x00'  # PointerToRawData
            text_section += b'\x00' * 12
            text_section += b'\x20\x00\x00\x60'  # Characteristics
            
            data_section = b'.data\x00\x00\x00'
            data_section += b'\x00\x10\x00\x00'
            data_section += b'\x00\x20\x00\x00'
            data_section += b'\x00\x10\x00\x00'
            data_section += b'\x00\x14\x00\x00'
            data_section += b'\x00' * 12
            data_section += b'\x40\x00\x00\xc0'
            
            # Vulnerable code with buffer overflow
            vuln_code = b''
            # Function prologue
            vuln_code += b'\x55'  # push ebp
            vuln_code += b'\x8b\xec'  # mov ebp, esp
            vuln_code += b'\x81\xec\x00\x01\x00\x00'  # sub esp, 256 (local buffer)
            
            # Vulnerable strcpy without bounds checking
            vuln_code += b'\x8b\x45\x08'  # mov eax, [ebp+8] (src param)
            vuln_code += b'\x8d\x8d\x00\xff\xff\xff'  # lea ecx, [ebp-256] (local buffer)
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\x51'  # push ecx
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call strcpy (relative)
            vuln_code += b'\x83\xc4\x08'  # add esp, 8
            
            # Integer overflow vulnerability
            vuln_code += b'\x8b\x45\x0c'  # mov eax, [ebp+12] (size param)
            vuln_code += b'\x6b\xc0\x04'  # imul eax, 4 (multiply without overflow check)
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call malloc
            vuln_code += b'\x83\xc4\x04'  # add esp, 4
            
            # Format string vulnerability
            vuln_code += b'\x8b\x45\x10'  # mov eax, [ebp+16] (user input)
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call printf (direct user input)
            vuln_code += b'\x83\xc4\x04'  # add esp, 4
            
            # Use-after-free vulnerability
            vuln_code += b'\x6a\x40'  # push 64
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call malloc
            vuln_code += b'\x83\xc4\x04'  # add esp, 4
            vuln_code += b'\x89\x45\xfc'  # mov [ebp-4], eax (save ptr)
            vuln_code += b'\x50'  # push eax
            vuln_code += b'\xe8\x00\x00\x00\x00'  # call free
            vuln_code += b'\x83\xc4\x04'  # add esp, 4
            vuln_code += b'\x8b\x45\xfc'  # mov eax, [ebp-4] (use freed ptr)
            vuln_code += b'\xc7\x00\x41\x41\x41\x41'  # mov [eax], 0x41414141
            
            # Function epilogue
            vuln_code += b'\x8b\xe5'  # mov esp, ebp
            vuln_code += b'\x5d'  # pop ebp
            vuln_code += b'\xc3'  # ret
            
            vuln_code += b'\x90' * (4096 - len(vuln_code))
            
            # Data section with strings
            data_content = b'strcpy\x00malloc\x00printf\x00free\x00'
            data_content += b'Enter input: \x00'
            data_content += b'Buffer: %s\x00'
            data_content += b'\x00' * (4096 - len(data_content))
            
            temp_file.write(dos_header + pe_signature + coff_header + optional_header + 
                          text_section + data_section + vuln_code + data_content)
            temp_file.flush()
            yield temp_file.name
        
        try:
            os.unlink(temp_file.name)
        except:
            pass

    @pytest.fixture
    def app_context(self):
        """Create REAL application context."""
        context = AppContext()
        context.initialize()
        return context

    @pytest.fixture
    def fuzzing_test_cases(self):
        """Create REAL fuzzing test cases."""
        return {
            'buffer_overflow': [
                b'A' * 256,
                b'A' * 512,
                b'A' * 1024,
                b'A' * 4096,
                b'%s' * 100,
                b'\x41\x41\x41\x41' * 256
            ],
            'format_string': [
                b'%s%s%s%s%s',
                b'%x%x%x%x%x',
                b'%n%n%n%n%n',
                b'%p%p%p%p%p',
                b'%.1024d',
                b'%*.*s'
            ],
            'integer_overflow': [
                struct.pack('<I', 0xffffffff),
                struct.pack('<I', 0x7fffffff),
                struct.pack('<I', 0x80000000),
                struct.pack('<I', 0x40000000),
                struct.pack('<I', 0x3fffffff)
            ],
            'heap_corruption': [
                b'\xff' * 16 + b'\x00' * 16,
                b'\x00\x00\x00\x00' + b'\xff\xff\xff\xff',
                b'\x41' * 8 + b'\x00' * 8 + b'\x42' * 8
            ]
        }

    def test_real_vulnerability_detection(self, vulnerable_binary, app_context):
        """Test REAL vulnerability detection in binaries."""
        analyzer = VulnerabilityAnalyzer()
        
        # Analyze binary for vulnerabilities
        vuln_results = analyzer.analyze_binary(vulnerable_binary)
        assert vuln_results is not None, "Vulnerability analysis must return results"
        assert 'vulnerabilities' in vuln_results, "Results must contain vulnerabilities"
        assert 'risk_score' in vuln_results, "Results must contain risk score"
        assert 'exploitability' in vuln_results, "Results must contain exploitability"
        
        vulnerabilities = vuln_results['vulnerabilities']
        assert len(vulnerabilities) > 0, "Must detect at least one vulnerability"
        
        # Check vulnerability details
        vuln_types_found = []
        for vuln in vulnerabilities:
            assert 'type' in vuln, "Each vulnerability must have type"
            assert 'severity' in vuln, "Each vulnerability must have severity"
            assert 'location' in vuln, "Each vulnerability must have location"
            assert 'description' in vuln, "Each vulnerability must have description"
            vuln_types_found.append(vuln['type'])
        
        # Verify common vulnerability types detected
        expected_types = ['buffer_overflow', 'format_string', 'integer_overflow', 'use_after_free']
        found_count = sum(1 for t in expected_types if any(t in v.lower() for v in vuln_types_found))
        assert found_count >= 2, f"Must detect at least 2 vulnerability types, found: {vuln_types_found}"
        
        # Check risk assessment
        risk_score = vuln_results['risk_score']
        assert isinstance(risk_score, (int, float)), "Risk score must be numeric"
        assert 0 <= risk_score <= 10, "Risk score must be between 0 and 10"
        assert risk_score >= 7, "Binary with multiple vulnerabilities should have high risk"

    def test_real_fuzzing_engine_operations(self, vulnerable_binary, fuzzing_test_cases, app_context):
        """Test REAL fuzzing engine functionality."""
        fuzzer = FuzzingEngine()
        
        # Configure fuzzing session
        fuzz_config = {
            'target': vulnerable_binary,
            'input_vectors': fuzzing_test_cases,
            'mutation_strategies': ['bit_flip', 'byte_replace', 'insert_special'],
            'coverage_guided': True,
            'max_iterations': 1000,
            'timeout': 5.0
        }
        
        # Start fuzzing session
        session_id = fuzzer.start_fuzzing_session(fuzz_config)
        assert session_id is not None, "Fuzzing session must start"
        
        # Run fuzzing iterations
        start_time = time.time()
        crashes_found = []
        
        while time.time() - start_time < 10.0:  # Run for up to 10 seconds
            iteration_result = fuzzer.run_fuzzing_iteration(session_id)
            if iteration_result and iteration_result.get('status') == 'crash':
                crashes_found.append(iteration_result)
            
            if len(crashes_found) >= 3:  # Stop after finding 3 crashes
                break
        
        # Get fuzzing results
        fuzz_results = fuzzer.get_session_results(session_id)
        assert fuzz_results is not None, "Must return fuzzing results"
        assert 'total_iterations' in fuzz_results, "Results must show iterations"
        assert 'crashes' in fuzz_results, "Results must contain crashes"
        assert 'coverage' in fuzz_results, "Results must contain coverage info"
        
        # Verify crash detection
        crashes = fuzz_results['crashes']
        assert isinstance(crashes, list), "Crashes must be a list"
        
        for crash in crashes:
            assert 'input' in crash, "Crash must record input"
            assert 'crash_type' in crash, "Crash must identify type"
            assert 'exploitability' in crash, "Crash must assess exploitability"
            assert 'stack_trace' in crash or 'registers' in crash, "Crash must have debug info"
        
        # Check coverage metrics
        coverage = fuzz_results['coverage']
        assert 'basic_blocks' in coverage, "Coverage must track basic blocks"
        assert 'functions' in coverage, "Coverage must track functions"
        assert coverage['basic_blocks'] > 0, "Fuzzing must achieve some coverage"

    def test_real_exploit_generation_from_crash(self, vulnerable_binary, fuzzing_test_cases, app_context):
        """Test REAL exploit generation from crash analysis."""
        analyzer = VulnerabilityAnalyzer()
        
        # Simulate crash with controlled input
        crash_data = {
            'crash_input': b'A' * 300 + struct.pack('<I', 0x41414141),
            'crash_type': 'access_violation',
            'exception_address': 0x41414141,
            'registers': {
                'eip': 0x41414141,
                'esp': 0x0012ff00,
                'ebp': 0x41414141,
                'eax': 0x00000000
            },
            'stack_dump': b'A' * 256 + b'B' * 256
        }
        
        # Generate exploit from crash
        exploit_result = analyzer.generate_exploit_from_crash(crash_data)
        assert exploit_result is not None, "Exploit generation must succeed"
        assert 'exploit_code' in exploit_result, "Result must contain exploit code"
        assert 'reliability' in exploit_result, "Result must assess reliability"
        assert 'bypass_techniques' in exploit_result, "Result must include bypasses"
        
        exploit_code = exploit_result['exploit_code']
        assert len(exploit_code) > 0, "Exploit code must not be empty"
        assert b'\x90' in exploit_code or b'\xeb' in exploit_code, "Exploit should contain NOP sled or JMP"
        
        # Verify exploit structure
        assert 'payload_offset' in exploit_result, "Must identify payload offset"
        assert 'return_address' in exploit_result, "Must provide return address"
        assert exploit_result['payload_offset'] > 0, "Payload offset must be positive"
        
        reliability = exploit_result['reliability']
        assert 0 <= reliability <= 1, "Reliability must be between 0 and 1"

    def test_real_binary_diffing_analysis(self, vulnerable_binary, app_context):
        """Test REAL binary diffing for patch analysis."""
        differ = BinaryDiffer()
        
        # Create patched version (simulate)
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as patched_file:
            with open(vulnerable_binary, 'rb') as orig:
                patched_data = bytearray(orig.read())
            
            # Simulate patches
            # Replace strcpy call with bounds-checked version
            strcpy_offset = patched_data.find(b'\xe8\x00\x00\x00\x00')
            if strcpy_offset > 0:
                patched_data[strcpy_offset:strcpy_offset+5] = b'\x90' * 5
            
            # Fix integer overflow
            imul_offset = patched_data.find(b'\x6b\xc0\x04')
            if imul_offset > 0:
                patched_data[imul_offset:imul_offset+3] = b'\x90\x90\x90'
            
            patched_file.write(patched_data)
            patched_file.flush()
            patched_path = patched_file.name
        
        try:
            # Perform binary diff
            diff_result = differ.diff_binaries(vulnerable_binary, patched_path)
            assert diff_result is not None, "Binary diff must succeed"
            assert 'changes' in diff_result, "Diff must identify changes"
            assert 'patch_analysis' in diff_result, "Diff must analyze patches"
            assert 'security_impact' in diff_result, "Diff must assess security impact"
            
            changes = diff_result['changes']
            assert len(changes) > 0, "Must detect at least one change"
            
            for change in changes:
                assert 'offset' in change, "Change must have offset"
                assert 'original' in change, "Change must have original bytes"
                assert 'patched' in change, "Change must have patched bytes"
                assert 'type' in change, "Change must identify type"
            
            # Verify patch analysis
            patch_analysis = diff_result['patch_analysis']
            assert 'vulnerabilities_fixed' in patch_analysis, "Must identify fixed vulns"
            assert 'patch_quality' in patch_analysis, "Must assess patch quality"
            
            security_impact = diff_result['security_impact']
            assert isinstance(security_impact, dict), "Security impact must be detailed"
            assert 'risk_reduction' in security_impact, "Must quantify risk reduction"
        
        finally:
            try:
                os.unlink(patched_path)
            except:
                pass

    def test_real_vulnerability_research_workflow(self, vulnerable_binary, app_context):
        """Test REAL end-to-end vulnerability research workflow."""
        research_manager = ResearchManager(app_context)
        
        # Create research project
        project_config = {
            'name': 'test_vuln_research',
            'target': vulnerable_binary,
            'research_goals': ['find_memory_corruption', 'develop_exploit', 'create_patch'],
            'techniques': ['static_analysis', 'dynamic_fuzzing', 'symbolic_execution']
        }
        
        project_id = research_manager.create_research_project(project_config)
        assert project_id is not None, "Research project must be created"
        
        # Execute research workflow
        workflow_result = research_manager.execute_research_workflow(project_id)
        assert workflow_result is not None, "Workflow must return results"
        assert 'status' in workflow_result, "Result must have status"
        assert 'findings' in workflow_result, "Result must have findings"
        assert 'artifacts' in workflow_result, "Result must have artifacts"
        
        # Check findings
        findings = workflow_result['findings']
        assert isinstance(findings, dict), "Findings must be structured"
        assert 'vulnerabilities' in findings, "Must report vulnerabilities"
        assert 'exploits' in findings, "Must report exploits"
        assert 'mitigations' in findings, "Must report mitigations"
        
        # Verify artifacts
        artifacts = workflow_result['artifacts']
        assert 'poc_exploits' in artifacts, "Must generate PoC exploits"
        assert 'crash_dumps' in artifacts, "Must save crash dumps"
        assert 'analysis_reports' in artifacts, "Must generate reports"

    def test_real_advanced_fuzzing_techniques(self, vulnerable_binary, app_context):
        """Test REAL advanced fuzzing techniques."""
        fuzzer = FuzzingEngine()
        
        # Grammar-based fuzzing
        grammar_config = {
            'target': vulnerable_binary,
            'grammar': {
                'start': ['command'],
                'command': ['action argument', 'action'],
                'action': ['READ', 'WRITE', 'DELETE'],
                'argument': ['string', 'number'],
                'string': ['"test"', '"A"*100', '"%s"*10'],
                'number': ['0', '-1', '4294967295']
            },
            'max_depth': 5
        }
        
        grammar_results = fuzzer.grammar_based_fuzzing(grammar_config)
        assert grammar_results is not None, "Grammar fuzzing must return results"
        assert 'generated_inputs' in grammar_results, "Must generate inputs"
        assert 'interesting_behaviors' in grammar_results, "Must track behaviors"
        
        # Coverage-guided fuzzing
        coverage_config = {
            'target': vulnerable_binary,
            'seed_inputs': [b'test', b'A'*10, b'%x%x'],
            'coverage_metric': 'edge',
            'energy_assignment': 'aflfast'
        }
        
        coverage_results = fuzzer.coverage_guided_fuzzing(coverage_config)
        assert coverage_results is not None, "Coverage fuzzing must return results"
        assert 'coverage_progress' in coverage_results, "Must track coverage"
        assert 'new_paths' in coverage_results, "Must discover new paths"
        
        # Hybrid concolic fuzzing
        hybrid_config = {
            'target': vulnerable_binary,
            'concrete_inputs': fuzzing_test_cases['buffer_overflow'],
            'symbolic_constraints': True,
            'solver': 'z3'
        }
        
        hybrid_results = fuzzer.hybrid_concolic_fuzzing(hybrid_config)
        assert hybrid_results is not None, "Hybrid fuzzing must return results"
        assert 'constraint_solutions' in hybrid_results, "Must solve constraints"
        assert 'deep_paths' in hybrid_results, "Must reach deep paths"

    def test_real_crash_triage_and_classification(self, vulnerable_binary, fuzzing_test_cases, app_context):
        """Test REAL crash triage and classification."""
        analyzer = VulnerabilityAnalyzer()
        
        # Simulate multiple crashes
        test_crashes = [
            {
                'input': fuzzing_test_cases['buffer_overflow'][2],
                'crash_address': 0x41414141,
                'exception_code': 0xc0000005,
                'context': {'eip': 0x41414141, 'esp': 0x0012f000}
            },
            {
                'input': fuzzing_test_cases['format_string'][0],
                'crash_address': 0x00401234,
                'exception_code': 0xc0000005,
                'context': {'eip': 0x00401234, 'esp': 0x0012f100}
            },
            {
                'input': fuzzing_test_cases['heap_corruption'][0],
                'crash_address': 0x77c12345,
                'exception_code': 0xc0000374,
                'context': {'eip': 0x77c12345, 'esp': 0x0012f200}
            }
        ]
        
        # Triage crashes
        triage_results = analyzer.triage_crashes(test_crashes)
        assert triage_results is not None, "Crash triage must return results"
        assert 'unique_bugs' in triage_results, "Must identify unique bugs"
        assert 'exploitability_assessment' in triage_results, "Must assess exploitability"
        assert 'root_causes' in triage_results, "Must identify root causes"
        
        unique_bugs = triage_results['unique_bugs']
        assert len(unique_bugs) > 0, "Must identify at least one unique bug"
        
        for bug in unique_bugs:
            assert 'bug_id' in bug, "Each bug must have ID"
            assert 'crash_count' in bug, "Must count related crashes"
            assert 'exploitability' in bug, "Must assess exploitability"
            assert 'priority' in bug, "Must assign priority"
            assert bug['exploitability'] in ['exploitable', 'probably_exploitable', 
                                            'unknown', 'probably_not_exploitable'], \
                   "Exploitability must use standard classification"

    def test_real_patch_validation(self, vulnerable_binary, app_context):
        """Test REAL patch validation and effectiveness."""
        analyzer = VulnerabilityAnalyzer()
        differ = BinaryDiffer()
        
        # Create test patch
        patch_data = {
            'target': vulnerable_binary,
            'patches': [
                {
                    'offset': 0x1000,
                    'original': b'\xe8\x00\x00\x00\x00',  # call strcpy
                    'patched': b'\xe8\x50\x00\x00\x00',   # call safe_strcpy
                    'vulnerability': 'buffer_overflow'
                },
                {
                    'offset': 0x1050,
                    'original': b'\x6b\xc0\x04',  # imul eax, 4
                    'patched': b'\x90\x90\x90',   # nop nop nop
                    'vulnerability': 'integer_overflow'
                }
            ]
        }
        
        # Validate patches
        validation_result = analyzer.validate_patches(patch_data)
        assert validation_result is not None, "Patch validation must return results"
        assert 'effectiveness' in validation_result, "Must assess effectiveness"
        assert 'side_effects' in validation_result, "Must check side effects"
        assert 'regression_risk' in validation_result, "Must assess regression risk"
        
        effectiveness = validation_result['effectiveness']
        assert isinstance(effectiveness, dict), "Effectiveness must be detailed"
        
        for vuln_type in ['buffer_overflow', 'integer_overflow']:
            if vuln_type in effectiveness:
                assert 'fixed' in effectiveness[vuln_type], f"Must indicate if {vuln_type} is fixed"
                assert 'confidence' in effectiveness[vuln_type], f"Must have confidence for {vuln_type}"

    def test_real_symbolic_execution_integration(self, vulnerable_binary, app_context):
        """Test REAL symbolic execution for vulnerability discovery."""
        research_manager = ResearchManager(app_context)
        
        # Configure symbolic execution
        symbolic_config = {
            'binary': vulnerable_binary,
            'entry_points': ['vulnerable_function', 'main'],
            'symbolic_inputs': ['argv', 'file_content', 'network_data'],
            'constraints': {
                'input_size': 1024,
                'timeout': 300,
                'max_states': 10000
            },
            'targets': ['buffer_overflow', 'integer_overflow', 'null_deref']
        }
        
        # Run symbolic execution
        symbolic_results = research_manager.run_symbolic_analysis(symbolic_config)
        assert symbolic_results is not None, "Symbolic execution must return results"
        assert 'paths_explored' in symbolic_results, "Must report paths explored"
        assert 'vulnerabilities_found' in symbolic_results, "Must report vulnerabilities"
        assert 'test_cases' in symbolic_results, "Must generate test cases"
        
        # Check path exploration
        paths = symbolic_results['paths_explored']
        assert isinstance(paths, int), "Paths must be numeric"
        assert paths > 0, "Must explore at least one path"
        
        # Verify test case generation
        test_cases = symbolic_results['test_cases']
        assert isinstance(test_cases, list), "Test cases must be a list"
        
        for test_case in test_cases:
            assert 'input' in test_case, "Test case must have input"
            assert 'constraints' in test_case, "Test case must have constraints"
            assert 'expected_behavior' in test_case, "Test case must predict behavior"

    def test_real_exploit_reliability_testing(self, vulnerable_binary, app_context):
        """Test REAL exploit reliability and stability."""
        analyzer = VulnerabilityAnalyzer()
        
        # Create test exploit
        test_exploit = {
            'target': vulnerable_binary,
            'vulnerability': 'buffer_overflow',
            'payload': b'A' * 268 + struct.pack('<I', 0x12345678) + b'\x90' * 16 + b'\xcc' * 100,
            'technique': 'ret_overwrite'
        }
        
        # Test exploit reliability
        reliability_test = analyzer.test_exploit_reliability(test_exploit, iterations=10)
        assert reliability_test is not None, "Reliability test must return results"
        assert 'success_rate' in reliability_test, "Must calculate success rate"
        assert 'failure_reasons' in reliability_test, "Must track failure reasons"
        assert 'aslr_bypass' in reliability_test, "Must test ASLR bypass"
        assert 'dep_bypass' in reliability_test, "Must test DEP bypass"
        
        success_rate = reliability_test['success_rate']
        assert 0 <= success_rate <= 1, "Success rate must be between 0 and 1"
        
        # Test exploit variants
        variants_test = analyzer.generate_exploit_variants(test_exploit)
        assert variants_test is not None, "Variant generation must succeed"
        assert 'variants' in variants_test, "Must generate variants"
        assert len(variants_test['variants']) > 0, "Must generate at least one variant"
        
        for variant in variants_test['variants']:
            assert 'technique' in variant, "Variant must specify technique"
            assert 'modifications' in variant, "Variant must describe modifications"
            assert 'expected_reliability' in variant, "Variant must estimate reliability"