"""
Comprehensive unit tests for intellicrack.utils.exploitation.__init__.py module.

CRITICAL TESTING REQUIREMENTS:
- ALL tests validate REAL functionality, never mocks or stubs
- Tests must prove genuine binary analysis and exploitation capabilities
- 80%+ test coverage requirement
- Real-world binary exploitation scenarios
- Production-ready validation
- Specification-driven testing without implementation inspection

This test suite validates the module initialization, imports, and exported functionality
of the exploitation utilities package.

Copyright (C) 2025 Zachary Flint
Part of Intellicrack Testing Framework
"""

import pytest
import sys
import tempfile
import os
import struct
from pathlib import Path
from typing import Dict, List, Any
import inspect

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Import the module under test
import intellicrack.utils.exploitation as exploitation_module
from intellicrack.utils.exploitation import (
    _detect_key_format,
    _detect_license_algorithm,
    analyze_existing_keys,
    exploit,
    generate_bypass_script,
    generate_exploit,
    generate_exploit_strategy,
    generate_license_key,
)
from tests.base_test import BaseIntellicrackTest


class TestExploitationInit(BaseIntellicrackTest):
    """Comprehensive tests for exploitation utils __init__.py module."""

    @pytest.fixture(autouse=True)
    def setup_test_environment(self, temp_workspace):
        """Setup test environment with real binary files and license samples."""
        self.temp_dir = temp_workspace
        self.test_binary_path = self.create_test_pe_binary()
        self.test_license_keys = self.create_test_license_keys()
        self.test_vulnerability_data = self.create_vulnerability_test_data()

    def create_test_pe_binary(self) -> Path:
        """Create a realistic PE binary with exploitation targets."""
        binary_path = self.temp_dir / "test_protected_binary.exe"

        # Create PE header structure with realistic protection patterns
        dos_header = struct.pack('<H', 0x5A4D)  # MZ signature
        dos_header += b'\x90' * 58  # DOS stub
        dos_header += struct.pack('<L', 0x80)  # PE offset

        pe_signature = b'PE\x00\x00'
        file_header = struct.pack('<HHILIHH',
            0x014c,  # Machine i386
            3,       # Number of sections
            0x12345678,  # Timestamp
            0,       # Pointer to symbol table
            0,       # Number of symbols
            0xE0,    # Size of optional header
            0x010F   # Characteristics
        )

        # Optional header with realistic values
        optional_header = struct.pack('<HBBLLLLLLLHHHHHHLLLLHH',
            0x10b,      # Magic PE32
            1, 0,       # Linker version
            0x1000,     # Size of code
            0x1000,     # Size of initialized data
            0,          # Size of uninitialized data
            0x1000,     # Entry point RVA
            0x1000,     # Base of code
            0x2000,     # Base of data
            0x400000,   # Image base
            0x1000,     # Section alignment
            0x200,      # File alignment
            4, 0,       # OS version
            0, 0,       # Image version
            4, 0,       # Subsystem version
            0,          # Win32 version
            0x4000,     # Size of image
            0x200,      # Size of headers
            0,          # Checksum
            2,          # Subsystem GUI
            0           # DLL characteristics
        )
        optional_header += b'\x00' * (0xE0 - len(optional_header))

        with open(binary_path, 'wb') as f:
            f.write(dos_header)
            f.write(pe_signature)
            f.write(file_header)
            f.write(optional_header)

            # Add exploitable code section
            code_section = b'\x90' * 512  # NOP sled
            code_section += b'AAAA' * 64  # Buffer overflow target
            code_section += b'\x41\x41\x41\x41'  # Return address overwrite
            code_section += b'\x90' * 256  # More shellcode space

            f.write(code_section)

            # Add license validation code patterns
            license_section = b'LICENSE_KEY_HERE' + b'A' * 100
            license_section += b'SERIAL_NUMBER_VALIDATION' + b'B' * 200
            license_section += b'HARDWARE_ID_CHECK' + b'C' * 150

            f.write(license_section)

        return binary_path

    def create_test_license_keys(self) -> list[str]:
        """Create realistic license key samples for analysis."""
        return [
            "ABCD-1234-EFGH-5678-IJKL",  # Standard format
            "A1B2C3D4E5F6G7H8I9J0K1L2",  # Hex-style format
            "123456789012345678901234",   # Numeric format
            "INTEL-CRACK-2025-PROD-KEY", # Product-style format
            "F7A8B9C0-D1E2-F3G4-H5I6-J7K8L9M0N1O2", # GUID-style format
            "LICENSE:ABCDEF123456789",    # Prefixed format
            "12AB34CD56EF78GH90IJ12KL",  # Mixed alphanumeric
            "TRIAL-VERSION-EXPIRED-001",  # Trial key format
        ]

    def create_vulnerability_test_data(self) -> dict[str, Any]:
        """Create realistic vulnerability test data."""
        return {
            "buffer_overflow": {
                "target_offset": 256,
                "return_address": 0x41414141,
                "shellcode_space": 512,
                "arch": "x86"
            },
            "format_string": {
                "format_string": "%08x.%08x.%08x.%08x.%n",
                "write_address": 0x08048000,
                "target_value": 0xdeadbeef
            },
            "integer_overflow": {
                "max_value": 0xFFFFFFFF,
                "overflow_trigger": 0x100000000,
                "target_size": 4
            },
            "use_after_free": {
                "object_size": 64,
                "freed_pointer": 0x12345678,
                "reuse_pattern": "AAAABBBBCCCCDDDD"
            }
        }

    def test_module_import_successful(self):
        """Test that the exploitation module imports successfully."""
        assert exploitation_module is not None
        assert hasattr(exploitation_module, '__all__')
        assert hasattr(exploitation_module, '__file__')

        # Verify module docstring exists and indicates purpose
        assert exploitation_module.__doc__ is not None
        doc_lower = exploitation_module.__doc__.lower()
        assert any(keyword in doc_lower for keyword in ["exploitation", "vulnerability", "security"])

    def test_all_exports_defined(self):
        """Test that __all__ is properly defined and contains expected exports."""
        expected_exports = [
            "_detect_key_format",
            "_detect_license_algorithm",
            "analyze_existing_keys",
            "exploit",
            "generate_bypass_script",
            "generate_exploit",
            "generate_exploit_strategy",
            "generate_license_key",
        ]

        assert hasattr(exploitation_module, '__all__')
        actual_exports = exploitation_module.__all__

        assert isinstance(actual_exports, list), "__all__ must be a list"
        assert len(actual_exports) == len(expected_exports), f"Expected {len(expected_exports)} exports, got {len(actual_exports)}"

        for export in expected_exports:
            assert export in actual_exports, f"Missing export: {export}"

    def test_all_functions_importable(self):
        """Test that all exported functions can be imported directly."""
        exported_functions = [
            _detect_key_format,
            _detect_license_algorithm,
            analyze_existing_keys,
            exploit,
            generate_bypass_script,
            generate_exploit,
            generate_exploit_strategy,
            generate_license_key,
        ]

        for func in exported_functions:
            assert callable(func), f"Export {func.__name__} is not callable"
            assert hasattr(func, '__name__'), f"Function {func} missing __name__ attribute"
            assert hasattr(func, '__doc__'), f"Function {func.__name__} missing docstring"

    def test_function_signatures_valid(self):
        """Test that all exported functions have valid signatures."""
        functions_to_test = [
            (_detect_key_format, "key analysis"),
            (_detect_license_algorithm, "license algorithm detection"),
            (analyze_existing_keys, "key analysis"),
            (exploit, "exploitation"),
            (generate_bypass_script, "bypass script generation"),
            (generate_exploit, "exploit generation"),
            (generate_exploit_strategy, "strategy generation"),
            (generate_license_key, "key generation"),
        ]

        for func, description in functions_to_test:
            signature = inspect.signature(func)
            assert len(signature.parameters) > 0, f"{func.__name__} should accept parameters for {description}"

            # Verify function has reasonable docstring
            assert func.__doc__ is not None, f"{func.__name__} must have docstring"
            assert len(func.__doc__.strip()) > 20, f"{func.__name__} docstring too short"

    @pytest.mark.real_data
    def test_detect_key_format_real_functionality(self):
        """Test _detect_key_format with real license key formats."""
        for key in self.test_license_keys:
            result = _detect_key_format(key)

            # Validate real format detection
            self.assert_real_output(result, f"Key format detection returned mock data for {key}")

            assert isinstance(result, dict), "Format detection should return dictionary"
            assert "format_type" in result, "Missing format_type in result"
            assert "pattern" in result, "Missing pattern in result"
            assert "confidence" in result, "Missing confidence score"

            # Confidence should be realistic
            confidence = result["confidence"]
            assert 0.0 <= confidence <= 1.0, "Confidence must be between 0 and 1"

    @pytest.mark.real_data
    def test_detect_license_algorithm_production_ready(self):
        """Test _detect_license_algorithm with real binary analysis."""
        with open(self.test_binary_path, 'rb') as f:
            binary_data = f.read()

        result = _detect_license_algorithm(binary_data, str(self.test_binary_path))

        # Validate genuine algorithm detection
        self.assert_real_output(result, "Algorithm detection returned mock data")

        assert isinstance(result, dict), "Algorithm detection should return dictionary"
        assert "algorithm_type" in result, "Missing algorithm_type"
        assert "complexity" in result, "Missing complexity assessment"
        assert "bypass_difficulty" in result, "Missing bypass difficulty"

        # Should identify realistic algorithm characteristics
        algorithm_type = result["algorithm_type"]
        assert algorithm_type in ["checksum", "cryptographic", "custom", "mathematical", "unknown"]

    @pytest.mark.real_data
    def test_analyze_existing_keys_comprehensive(self):
        """Test analyze_existing_keys with comprehensive key analysis."""
        result = analyze_existing_keys(self.test_license_keys)

        # Validate real analysis results
        self.assert_real_output(result, "Key analysis returned mock data")

        assert isinstance(result, dict), "Key analysis should return dictionary"
        assert "patterns" in result, "Missing patterns analysis"
        assert "algorithms" in result, "Missing algorithms detection"
        assert "generation_strategy" in result, "Missing generation strategy"

        # Should identify patterns from real keys
        patterns = result["patterns"]
        assert isinstance(patterns, list), "Patterns should be list"
        assert len(patterns) > 0, "Should identify at least one pattern"

    @pytest.mark.real_data
    def test_exploit_function_real_exploitation(self):
        """Test exploit function with real vulnerability data."""
        vuln_data = self.test_vulnerability_data["buffer_overflow"]

        result = exploit(
            binary_path=str(self.test_binary_path),
            vulnerability_type="buffer_overflow",
            target_offset=vuln_data["target_offset"],
            return_address=vuln_data["return_address"]
        )

        # Validate real exploit generation
        self.assert_real_output(result, "Exploit function returned mock data")
        self.assert_exploit_works(result)

        assert isinstance(result, dict), "Exploit should return dictionary"
        assert "exploit_code" in result, "Missing exploit code"
        assert "success_probability" in result, "Missing success probability"

    @pytest.mark.real_data
    def test_generate_bypass_script_production(self):
        """Test generate_bypass_script with real protection scenarios."""
        result = generate_bypass_script(
            protection_type="license_check",
            binary_path=str(self.test_binary_path),
            target_function="validate_license"
        )

        # Validate real bypass script generation
        self.assert_real_output(result, "Bypass script generation returned mock data")

        assert isinstance(result, (str, dict)), "Bypass script should return string or dictionary"

        if isinstance(result, dict):
            assert "script" in result, "Missing script content"
            assert "instructions" in result, "Missing usage instructions"
        else:
            assert len(result) > 100, "Bypass script too short for real functionality"
            assert "function" in result.lower(), "Script should reference functions"

    @pytest.mark.real_data
    def test_generate_exploit_comprehensive(self):
        """Test generate_exploit with comprehensive vulnerability scenarios."""
        for vuln_type, vuln_data in self.test_vulnerability_data.items():
            result = generate_exploit(
                vulnerability_type=vuln_type,
                target_binary=str(self.test_binary_path),
                **vuln_data
            )

            # Validate real exploit generation
            self.assert_real_output(result, f"Exploit generation returned mock data for {vuln_type}")

            assert isinstance(result, dict), f"Exploit for {vuln_type} should return dictionary"
            assert "payload" in result, f"Missing payload for {vuln_type}"
            assert "delivery_method" in result, f"Missing delivery method for {vuln_type}"

    @pytest.mark.real_data
    def test_generate_exploit_strategy_real_planning(self):
        """Test generate_exploit_strategy with real strategic planning."""
        result = generate_exploit_strategy(
            binary_path=str(self.test_binary_path),
            protection_analysis={"license_check": True, "anti_debug": False},
            target_goals=["bypass_license", "extract_algorithm"]
        )

        # Validate real strategy generation
        self.assert_real_output(result, "Strategy generation returned mock data")

        assert isinstance(result, dict), "Strategy should return dictionary"
        assert "phases" in result, "Missing exploitation phases"
        assert "tools_required" in result, "Missing tools requirements"
        assert "success_probability" in result, "Missing success probability"

        # Strategy should be multi-phase
        phases = result["phases"]
        assert isinstance(phases, list), "Phases should be list"
        assert len(phases) >= 2, "Strategy should have multiple phases"

    @pytest.mark.real_data
    def test_generate_license_key_production_ready(self):
        """Test generate_license_key with real key generation."""
        algorithm_data = {
            "algorithm_type": "checksum",
            "key_length": 25,
            "format_pattern": "XXXXX-XXXXX-XXXXX-XXXXX-XXXXX",
            "checksum_algorithm": "luhn"
        }

        result = generate_license_key(
            algorithm_data=algorithm_data,
            user_info={"name": "TestUser", "email": "test@example.com"},
            product_info={"name": "TestProduct", "version": "1.0"}
        )

        # Validate real key generation
        self.assert_real_output(result, "License key generation returned mock data")

        assert isinstance(result, (str, dict)), "Key generation should return string or dictionary"

        if isinstance(result, dict):
            assert "license_key" in result, "Missing license key"
            assert "validation_code" in result, "Missing validation code"
            key = result["license_key"]
        else:
            key = result

        # Validate key format and structure
        assert len(key) >= 10, "Generated key too short"
        assert not key.lower().startswith("todo"), "Key appears to be placeholder"

    def test_cross_function_integration(self):
        """Test integration between different exploitation functions."""
        # Analyze keys to get algorithm information
        key_analysis = analyze_existing_keys(self.test_license_keys[:3])
        self.assert_real_output(key_analysis, "Key analysis integration failed")

        # Use analysis results to detect specific algorithm
        if "suggested_algorithm" in key_analysis:
            algorithm_info = key_analysis["suggested_algorithm"]

            # Generate new key using detected algorithm
            new_key = generate_license_key(
                algorithm_data=algorithm_info,
                user_info={"name": "IntegrationTest"}
            )
            self.assert_real_output(new_key, "Integrated key generation failed")

    def test_error_handling_robustness(self):
        """Test error handling across all exported functions."""
        error_test_cases = [
            # Invalid file paths
            (lambda: _detect_license_algorithm(b"invalid", "/nonexistent/file")),
            # Invalid key formats
            (lambda: _detect_key_format("")),
            # Empty key lists
            (lambda: analyze_existing_keys([])),
            # Invalid vulnerability types
            (lambda: generate_exploit("unknown_vuln", str(self.test_binary_path))),
            # Missing binary paths
            (lambda: exploit("")),
        ]

        for test_case in error_test_cases:
            try:
                result = test_case()
                # If no exception, result should indicate error gracefully
                if result is not None:
                    assert isinstance(result, dict), "Error result should be dictionary"
                    assert "error" in result or "status" in result, "Should indicate error status"
            except (FileNotFoundError, ValueError, TypeError) as e:
                # Expected exceptions are acceptable
                assert len(str(e)) > 0, "Exception should have meaningful message"

    def test_performance_requirements(self):
        """Test that functions meet production performance requirements."""
        import time

        performance_tests = [
            (lambda: _detect_key_format(self.test_license_keys[0]), 0.1),
            (lambda: analyze_existing_keys(self.test_license_keys[:3]), 1.0),
            (lambda: generate_license_key({"algorithm_type": "simple"}), 0.5),
        ]

        for test_func, max_time in performance_tests:
            start_time = time.time()
            result = test_func()
            execution_time = time.time() - start_time

            assert execution_time < max_time, f"Function too slow: {execution_time:.2f}s > {max_time}s"
            self.assert_real_output(result, "Performance test returned mock data")

    def test_module_metadata_completeness(self):
        """Test that module metadata is complete and professional."""
        # Check module-level attributes
        assert hasattr(exploitation_module, '__author__') or 'Copyright' in exploitation_module.__doc__
        assert hasattr(exploitation_module, '__version__') or 'version' in exploitation_module.__doc__.lower()

        # Verify all functions have proper metadata
        for func_name in exploitation_module.__all__:
            func = getattr(exploitation_module, func_name)
            assert func.__doc__ is not None, f"{func_name} missing docstring"
            assert len(func.__doc__.strip()) > 30, f"{func_name} docstring too brief"

            # Check for professional documentation markers
            doc_lower = func.__doc__.lower()
            professional_markers = ["param", "return", "raise", "example", "note"]
            has_markers = any(marker in doc_lower for marker in professional_markers)
            assert has_markers, f"{func_name} lacks professional documentation"

    @pytest.mark.security
    def test_security_compliance(self):
        """Test that all functions comply with security research ethics."""
        # Verify functions support defensive security research
        for func_name in exploitation_module.__all__:
            func = getattr(exploitation_module, func_name)

            # Functions should not contain obvious malicious indicators
            source_lines = inspect.getsource(func).lower()
            malicious_indicators = ["backdoor", "trojan", "keylogger", "steal", "hijack_system"]

            for indicator in malicious_indicators:
                assert indicator not in source_lines, f"{func_name} contains suspicious code: {indicator}"

            # Functions should have security research purpose
            purpose_indicators = ["analysis", "research", "security", "protection", "validation"]
            has_purpose = any(indicator in func.__doc__.lower() for indicator in purpose_indicators)
            assert has_purpose, f"{func_name} lacks clear security research purpose"


class TestExploitationInitIntegration(BaseIntellicrackTest):
    """Integration tests for the exploitation module initialization."""

    def test_full_exploitation_workflow(self):
        """Test complete exploitation workflow using module exports."""
        # Create test binary
        temp_dir = Path(tempfile.mkdtemp())
        binary_path = temp_dir / "workflow_test.exe"

        with open(binary_path, 'wb') as f:
            f.write(b'MZ' + b'\x90' * 1000 + b'LICENSE_CHECK' + b'A' * 500)

        try:
            # Step 1: Analyze binary for license algorithm
            with open(binary_path, 'rb') as f:
                binary_data = f.read()
            algorithm_info = _detect_license_algorithm(binary_data, str(binary_path))
            self.assert_real_output(algorithm_info, "Algorithm detection failed in workflow")

            # Step 2: Generate exploitation strategy
            strategy = generate_exploit_strategy(
                binary_path=str(binary_path),
                protection_analysis=algorithm_info
            )
            self.assert_real_output(strategy, "Strategy generation failed in workflow")

            # Step 3: Generate bypass script
            bypass_script = generate_bypass_script(
                protection_type="license_check",
                binary_path=str(binary_path)
            )
            self.assert_real_output(bypass_script, "Bypass generation failed in workflow")

            # Validate workflow completeness
            assert isinstance(strategy, dict), "Strategy should be dictionary"
            assert isinstance(bypass_script, (str, dict)), "Bypass should be string or dictionary"

        finally:
            # Cleanup
            if binary_path.exists():
                binary_path.unlink()
            temp_dir.rmdir()

    def test_concurrent_function_usage(self):
        """Test that multiple functions can be used concurrently."""
        import threading
        import time

        results = {}
        errors = []

        def test_key_analysis():
            try:
                keys = ["TEST-1234-ABCD-5678", "DEMO-KEY-2025-PROD"]
                result = analyze_existing_keys(keys)
                results["key_analysis"] = result
            except Exception as e:
                errors.append(f"Key analysis error: {e}")

        def test_key_generation():
            try:
                result = generate_license_key({
                    "algorithm_type": "simple",
                    "key_length": 20
                })
                results["key_generation"] = result
            except Exception as e:
                errors.append(f"Key generation error: {e}")

        # Run functions concurrently
        threads = [
            threading.Thread(target=test_key_analysis),
            threading.Thread(target=test_key_generation),
        ]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join(timeout=10)

        # Validate concurrent execution
        assert len(errors) == 0, f"Concurrent execution errors: {errors}"
        assert len(results) == 2, "Not all concurrent functions completed"

        for name, result in results.items():
            self.assert_real_output(result, f"Concurrent {name} returned mock data")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
