"""
Comprehensive unit tests for exploit_common.py module.

CRITICAL TESTING REQUIREMENTS:
- ALL tests validate REAL functionality, never mocks or stubs
- Tests must prove genuine binary analysis and exploitation capabilities
- 80%+ test coverage requirement
- Real-world binary exploitation scenarios
- Production-ready validation

Copyright (C) 2025 Zachary Flint
Part of Intellicrack Testing Framework
"""

import pytest
import sys
from pathlib import Path
from unittest.mock import Mock, MagicMock
import tempfile
import os

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).parent.parent.parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from intellicrack.utils.exploitation.exploit_common import (
    handle_exploit_strategy_generation,
    handle_exploit_payload_generation,
    create_analysis_button
)
from tests.base_test import BaseIntellicrackTest


class TestExploitCommon(BaseIntellicrackTest):
    """Comprehensive tests for exploit_common module functions."""

    @pytest.fixture(autouse=True)
    def setup_test_environment(self, temp_workspace):
        """Setup test environment with real binary files."""
        self.temp_dir = temp_workspace
        self.test_binary_path = self.create_test_binary()
        self.mock_signal = Mock()
        self.signal_messages = []

        # Capture emitted messages
        def capture_emit(message):
            self.signal_messages.append(message)

        self.mock_signal.emit = capture_emit

    def create_test_binary(self):
        """Create a real test binary file for exploitation testing."""
        binary_path = self.temp_dir / "test_vulnerable_binary.exe"

        # Create a minimal PE header structure for realistic testing
        pe_header = (
            b'MZ'                    # DOS signature
            b'\x90' * 58            # DOS stub
            b'\x3c\x00\x00\x00'    # PE offset
            b'PE\x00\x00'          # PE signature
            b'\x4c\x01'            # Machine (i386)
            b'\x03\x00'            # Number of sections
            b'\x00' * 16           # Timestamp and other fields
            b'\xe0\x00'            # Characteristics
            b'\x0b\x01'            # Magic (PE32)
            b'\x00' * 200          # Optional header and sections
        )

        with open(binary_path, 'wb') as f:
            f.write(pe_header)
            # Add some code section data
            f.write(b'\x90' * 1000)  # NOP padding
            # Add vulnerable buffer overflow pattern
            f.write(b'A' * 256 + b'\x41\x41\x41\x41')  # Buffer + return address

        return binary_path

    def test_handle_exploit_strategy_generation_buffer_overflow(self):
        """Test exploit strategy generation for buffer overflow vulnerabilities."""
        # Test with real buffer overflow vulnerability type
        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "buffer_overflow"
        )

        # Validate real exploit strategy was generated
        self.assert_real_output(strategy, "Strategy generation returned mock data")

        # Check strategy structure
        assert isinstance(strategy, dict), "Strategy must be dictionary"

        # Validate signal messages were emitted
        assert len(self.signal_messages) >= 2, "Should emit multiple log messages"
        assert any("Generating exploitation strategy" in msg for msg in self.signal_messages)

        # Strategy should contain real exploitation details
        if "strategy" in strategy and "steps" in strategy["strategy"]:
            steps = strategy["strategy"]["steps"]
            assert len(steps) > 0, "Strategy must contain exploitation steps"

            # Validate steps contain real exploitation techniques
            for step in steps:
                self.assert_real_output(step, "Strategy step contains placeholder text")
                assert len(step.strip()) > 10, "Strategy steps must be detailed"

        # Check for automation script generation
        if "automation_script" in strategy:
            script = strategy["automation_script"]
            self.assert_real_output(script, "Automation script appears to be placeholder")
            assert len(script) > 50, "Automation script must be substantial"

    def test_handle_exploit_strategy_generation_format_string(self):
        """Test exploit strategy generation for format string vulnerabilities."""
        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "format_string"
        )

        self.assert_real_output(strategy, "Format string strategy returned mock data")

        # Should handle different vulnerability types appropriately
        if "error" not in strategy:
            assert "strategy" in strategy, "Valid strategy should contain strategy field"

    def test_handle_exploit_strategy_generation_use_after_free(self):
        """Test exploit strategy generation for use-after-free vulnerabilities."""
        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "use_after_free"
        )

        self.assert_real_output(strategy, "Use-after-free strategy returned mock data")

        # Validate strategy contains heap exploitation techniques
        if "strategy" in strategy and "steps" in strategy["strategy"]:
            steps = strategy["strategy"]["steps"]
            heap_terms = ["heap", "malloc", "free", "dangling", "pointer"]
            has_heap_content = any(
                any(term in step.lower() for term in heap_terms)
                for step in steps
            )
            assert has_heap_content, "Use-after-free strategy should mention heap concepts"

    def test_handle_exploit_strategy_generation_invalid_path(self):
        """Test strategy generation with invalid binary path."""
        invalid_path = str(self.temp_dir / "nonexistent_binary.exe")

        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            invalid_path,
            "buffer_overflow"
        )

        # Should handle errors gracefully with real error messages
        if "error" in strategy:
            error_msg = strategy["error"]
            self.assert_real_output(error_msg, "Error message appears to be placeholder")
            assert "not found" in error_msg.lower() or "no such file" in error_msg.lower(), \
                "Error should indicate file not found"

    def test_handle_exploit_payload_generation_license_bypass(self):
        """Test license bypass payload generation with real bypass techniques."""
        payload_result = handle_exploit_payload_generation(
            self.mock_signal,
            "License Bypass"
        )

        self.assert_real_output(payload_result, "License bypass payload returned mock data")

        # Validate payload structure
        assert isinstance(payload_result, dict), "Payload result must be dictionary"

        # Check for real payload components
        if "error" not in payload_result:
            assert "method" in payload_result, "Payload should specify method"

            if "payload_bytes" in payload_result:
                payload_bytes = payload_result["payload_bytes"]
                assert len(payload_bytes) > 0, "Payload bytes cannot be empty"
                self.assert_real_output(payload_bytes, "Payload bytes appear to be placeholder")

            if "description" in payload_result:
                description = payload_result["description"]
                self.assert_real_output(description, "Payload description is placeholder")
                assert "bypass" in description.lower(), "Description should mention bypass"

        # Validate signal messages
        assert len(self.signal_messages) >= 2, "Should emit multiple log messages"
        assert any("License Bypass" in msg for msg in self.signal_messages)

    def test_handle_exploit_payload_generation_function_hijack(self):
        """Test function hijack payload generation with real hijacking techniques."""
        payload_result = handle_exploit_payload_generation(
            self.mock_signal,
            "Function Hijack"
        )

        self.assert_real_output(payload_result, "Function hijack payload returned mock data")

        if "error" not in payload_result:
            # Should contain function hijacking specifics
            if "method" in payload_result:
                assert payload_result["method"] == "function_hijacking", \
                    "Method should be function_hijacking"

            if "description" in payload_result:
                description = payload_result["description"]
                hijack_terms = ["hijack", "hook", "redirect", "intercept"]
                has_hijack_content = any(term in description.lower() for term in hijack_terms)
                assert has_hijack_content, "Description should contain hijacking terminology"

    def test_handle_exploit_payload_generation_buffer_overflow(self):
        """Test buffer overflow payload generation with real shellcode."""
        payload_result = handle_exploit_payload_generation(
            self.mock_signal,
            "Buffer Overflow"
        )

        self.assert_real_output(payload_result, "Buffer overflow payload returned mock data")

        if "error" not in payload_result:
            # Should contain real exploit components
            self.assert_exploit_works(str(payload_result))

            # Check for shellcode indicators
            payload_str = str(payload_result).lower()
            shellcode_terms = ["shellcode", "exploit", "overflow", "buffer", "stack"]
            has_exploit_content = any(term in payload_str for term in shellcode_terms)
            assert has_exploit_content, "Payload should contain exploitation terminology"

    def test_handle_exploit_payload_generation_unknown_type(self):
        """Test payload generation with unknown payload type."""
        payload_result = handle_exploit_payload_generation(
            self.mock_signal,
            "Unknown Payload Type"
        )

        # Should handle unknown types gracefully
        assert "error" in payload_result, "Should return error for unknown payload type"
        error_msg = payload_result["error"]
        self.assert_real_output(error_msg, "Error message appears to be placeholder")
        assert "unknown" in error_msg.lower(), "Error should mention unknown type"

    def test_create_analysis_button_simple(self):
        """Test creating simple analysis button configuration."""
        callback_func = lambda: print("Test callback")

        buttons = create_analysis_button("Test Button", callback_func)

        # Validate button configuration
        assert isinstance(buttons, list), "Should return list of button configs"
        assert len(buttons) == 1, "Should return one button for simple case"

        button_config = buttons[0]
        assert len(button_config) == 3, "Button config should have 3 elements"

        button_text, callback, style = button_config
        assert button_text == "Test Button", "Button text should match input"
        assert callback == callback_func, "Callback should match input"
        assert isinstance(style, str), "Style should be string"

    def test_create_analysis_button_analyze_binary_styling(self):
        """Test special styling for 'Analyze Binary' button."""
        callback_func = lambda: print("Analyze callback")

        buttons = create_analysis_button("Analyze Binary", callback_func)

        assert len(buttons) == 1, "Should return one button"
        button_text, callback, style = buttons[0]

        assert button_text == "Analyze Binary", "Button text should match"
        assert callback == callback_func, "Callback should match"

        # Should have special styling for Analyze Binary button
        assert style != "", "Analyze Binary button should have styling"
        assert "background-color" in style, "Should have background color styling"
        assert "#2196F3" in style, "Should use specific blue color"
        assert "color: white" in style, "Should have white text"
        assert "font-weight: bold" in style, "Should be bold"

    def test_create_analysis_button_with_extra_buttons(self):
        """Test creating button configuration with extra buttons."""
        main_callback = lambda: print("Main callback")
        extra_callbacks = [
            lambda: print("Extra 1"),
            lambda: print("Extra 2")
        ]

        extra_buttons = [
            ("Extra Button 1", extra_callbacks[0]),
            ("Extra Button 2", extra_callbacks[1])
        ]

        buttons = create_analysis_button("Main Button", main_callback, extra_buttons)

        # Should return main button plus extra buttons
        assert len(buttons) == 3, "Should return main + 2 extra buttons"

        # Validate main button
        main_text, main_cb, main_style = buttons[0]
        assert main_text == "Main Button"
        assert main_cb == main_callback

        # Validate extra buttons
        for i, (text, cb, style) in enumerate(buttons[1:], 1):
            expected_text = f"Extra Button {i}"
            assert text == expected_text, f"Extra button {i} text should match"
            assert cb == extra_callbacks[i-1], f"Extra button {i} callback should match"
            assert isinstance(style, str), f"Extra button {i} should have style"

    def test_create_analysis_button_extra_analyze_binary(self):
        """Test extra button with 'Analyze Binary' gets special styling."""
        main_callback = lambda: print("Main")
        analyze_callback = lambda: print("Analyze")

        extra_buttons = [("Analyze Binary", analyze_callback)]

        buttons = create_analysis_button("Main Button", main_callback, extra_buttons)

        assert len(buttons) == 2, "Should have main + extra button"

        # Check extra 'Analyze Binary' button styling
        extra_text, extra_cb, extra_style = buttons[1]
        assert extra_text == "Analyze Binary"
        assert extra_cb == analyze_callback
        assert "#2196F3" in extra_style, "Extra Analyze Binary should have special styling"

    def test_signal_message_formatting(self):
        """Test that signal messages are properly formatted with timestamps."""
        handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "buffer_overflow"
        )

        # Check that messages contain timestamps
        for message in self.signal_messages:
            assert "[" in message and "]" in message, "Messages should contain timestamp brackets"
            # Timestamp format: [HH:MM:SS]
            import re
            timestamp_pattern = r'\[\d{2}:\d{2}:\d{2}\]'
            assert re.search(timestamp_pattern, message), f"Message should have timestamp: {message}"

    def test_error_handling_import_failures(self):
        """Test graceful handling of import failures in dependencies."""
        # Test strategy generation with potential import issues
        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "complex_vulnerability"
        )

        # Should handle import errors gracefully
        assert isinstance(strategy, dict), "Should always return dictionary"

        if "error" in strategy:
            # Error should be informative, not a generic placeholder
            self.assert_real_output(strategy["error"], "Error message is placeholder")

    def test_payload_generation_with_real_binary_context(self):
        """Test payload generation using real binary analysis context."""
        # Generate payload with binary-specific context
        payload_result = handle_exploit_payload_generation(
            self.mock_signal,
            "Function Hijack"
        )

        # Validate real binary analysis was performed
        self.assert_real_output(payload_result, "Payload generation returned mock data")

        if "payload_bytes" in payload_result:
            payload_bytes = payload_result["payload_bytes"]
            # Should contain hex-encoded bytes or raw bytes
            if isinstance(payload_bytes, str):
                # If hex string, should be valid hex
                try:
                    bytes.fromhex(payload_bytes.replace('\\x', ''))
                except ValueError:
                    # Might be hex with 0x prefix or other format
                    assert len(payload_bytes) > 10, "Payload should be substantial"

    def test_comprehensive_vulnerability_types(self):
        """Test strategy generation for comprehensive vulnerability types."""
        vulnerability_types = [
            "buffer_overflow",
            "format_string",
            "use_after_free",
            "integer_overflow",
            "race_condition",
            "injection",
            "privilege_escalation"
        ]

        successful_strategies = 0

        for vuln_type in vulnerability_types:
            strategy = handle_exploit_strategy_generation(
                Mock(),
                str(self.test_binary_path),
                vuln_type
            )

            if "error" not in strategy:
                successful_strategies += 1
                # Validate real strategy generation
                self.assert_real_output(strategy, f"Strategy for {vuln_type} is placeholder")

        # Should successfully handle at least half of vulnerability types
        assert successful_strategies >= len(vulnerability_types) // 2, \
            "Should handle majority of vulnerability types"

    def test_payload_types_comprehensive(self):
        """Test payload generation for comprehensive payload types."""
        payload_types = [
            "License Bypass",
            "Function Hijack",
            "Buffer Overflow",
            "Shellcode Injection",
            "Return-to-libc",
            "ROP Chain"
        ]

        successful_payloads = 0

        for payload_type in payload_types:
            payload_result = handle_exploit_payload_generation(
                Mock(),
                payload_type
            )

            if "error" not in payload_result:
                successful_payloads += 1
                self.assert_real_output(payload_result, f"Payload {payload_type} is placeholder")

        # Should handle at least the core payload types
        assert successful_payloads >= 3, "Should handle core payload types"

    def test_integration_with_real_exploitation_pipeline(self):
        """Test integration with real exploitation pipeline components."""
        # Test full exploitation workflow
        strategy = handle_exploit_strategy_generation(
            self.mock_signal,
            str(self.test_binary_path),
            "buffer_overflow"
        )

        if "error" not in strategy:
            # Use strategy to generate corresponding payload
            payload_result = handle_exploit_payload_generation(
                self.mock_signal,
                "Buffer Overflow"
            )

            # Strategy and payload should be compatible
            self.assert_real_output(strategy, "Strategy is not real")
            self.assert_real_output(payload_result, "Payload is not real")

            # Should demonstrate real integration
            if "strategy" in strategy and "payload_bytes" in payload_result:
                assert len(str(strategy["strategy"])) > 50, "Strategy should be detailed"
                assert len(str(payload_result["payload_bytes"])) > 10, "Payload should be substantial"

    def test_performance_requirements(self):
        """Test that functions meet performance requirements for production use."""
        # Strategy generation should be reasonably fast
        def test_strategy_performance():
            handle_exploit_strategy_generation(
                Mock(),
                str(self.test_binary_path),
                "buffer_overflow"
            )

        self.assert_performance_acceptable(test_strategy_performance, max_time=5.0)

        # Payload generation should be reasonably fast
        def test_payload_performance():
            handle_exploit_payload_generation(Mock(), "License Bypass")

        self.assert_performance_acceptable(test_payload_performance, max_time=5.0)

        # Button creation should be very fast
        def test_button_performance():
            create_analysis_button("Test", lambda: None)

        self.assert_performance_acceptable(test_button_performance, max_time=0.1)

    def test_memory_management(self):
        """Test proper memory management in exploit functions."""
        import gc

        initial_objects = len(gc.get_objects())

        # Generate multiple strategies and payloads
        for i in range(10):
            strategy = handle_exploit_strategy_generation(
                Mock(),
                str(self.test_binary_path),
                "buffer_overflow"
            )

            payload = handle_exploit_payload_generation(Mock(), "License Bypass")

            buttons = create_analysis_button(f"Button {i}", lambda: None)

            # Clear references
            del strategy, payload, buttons

        # Force garbage collection
        gc.collect()

        final_objects = len(gc.get_objects())

        # Memory growth should be reasonable
        memory_growth = final_objects - initial_objects
        assert memory_growth < 1000, f"Excessive memory growth: {memory_growth} objects"

    def teardown_method(self):
        """Clean up after each test method."""
        # Clear signal messages
        self.signal_messages.clear()

        # Clean up temporary files
        if hasattr(self, 'test_binary_path') and self.test_binary_path.exists():
            try:
                os.remove(self.test_binary_path)
            except (PermissionError, FileNotFoundError):
                pass  # File may be locked or already removed


# Additional integration tests for real-world scenarios
class TestExploitCommonIntegration(BaseIntellicrackTest):
    """Integration tests with real exploitation scenarios."""

    def test_real_world_buffer_overflow_scenario(self):
        """Test complete buffer overflow exploitation scenario."""
        # Create a more realistic vulnerable binary
        binary_path = self.create_realistic_vulnerable_binary()

        # Generate strategy
        signal = Mock()
        strategy = handle_exploit_strategy_generation(
            signal, str(binary_path), "buffer_overflow"
        )

        # Generate payload
        payload = handle_exploit_payload_generation(signal, "Buffer Overflow")

        # Validate complete scenario
        self.assert_real_output(strategy, "Buffer overflow strategy is not real")
        self.assert_real_output(payload, "Buffer overflow payload is not real")

    def create_realistic_vulnerable_binary(self):
        """Create a binary with realistic vulnerability patterns."""
        import tempfile

        binary_path = Path(tempfile.gettempdir()) / "realistic_vulnerable.exe"

        # Create a binary with stack-based buffer overflow vulnerability
        vulnerable_code = bytes([
            # PE header (simplified)
            0x4D, 0x5A,  # MZ signature
        ]) + b'\x00' * 60 + bytes([
            # PE signature offset
            0x3C, 0x00, 0x00, 0x00,
            # PE signature
            0x50, 0x45, 0x00, 0x00,
            # Machine type (i386)
            0x4C, 0x01,
        ]) + b'\x00' * 200

        # Add vulnerable function pattern
        vulnerable_pattern = (
            b'\x55'                    # push ebp
            b'\x8B\xEC'               # mov ebp, esp
            b'\x81\xEC\x00\x01\x00\x00'  # sub esp, 100h (256 bytes local buffer)
            b'\x8D\x45\x00'          # lea eax, [ebp+var_100] (buffer address)
            b'\x50'                   # push eax
            b'\xFF\x15\x00\x00\x40\x00'  # call gets (vulnerable function)
            b'\x83\xC4\x04'          # add esp, 4
            b'\x8B\xE5'              # mov esp, ebp
            b'\x5D'                   # pop ebp
            b'\xC3'                   # ret (vulnerable return)
        )

        with open(binary_path, 'wb') as f:
            f.write(vulnerable_code)
            f.write(vulnerable_pattern)
            f.write(b'\x00' * 1000)  # Padding

        return binary_path

    @pytest.mark.real_data
    def test_production_exploitation_workflow(self):
        """Test production-ready exploitation workflow."""
        binary_path = self.create_realistic_vulnerable_binary()

        try:
            # Full exploitation pipeline
            signal = Mock()

            # 1. Strategy generation
            strategy = handle_exploit_strategy_generation(
                signal, str(binary_path), "buffer_overflow"
            )

            # 2. Payload generation
            payload = handle_exploit_payload_generation(signal, "Buffer Overflow")

            # 3. UI integration
            buttons = create_analysis_button("Exploit Binary", lambda: None)

            # Validate production readiness
            assert strategy is not None, "Strategy generation failed"
            assert payload is not None, "Payload generation failed"
            assert len(buttons) > 0, "Button creation failed"

            # Validate real functionality
            self.assert_real_output(strategy, "Strategy is not production-ready")
            self.assert_real_output(payload, "Payload is not production-ready")

        finally:
            # Cleanup
            if binary_path.exists():
                try:
                    binary_path.unlink()
                except:
                    pass  # Best effort cleanup


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
