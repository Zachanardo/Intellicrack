"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.

Comprehensive Test Suite for PayloadResultHandler

Tests all production-ready functionality for payload result processing,
including success/failure scenarios, metadata handling, and callbacks.
"""

import pytest
from typing import Any, Dict, List, Callable, Optional
import hashlib

from intellicrack.utils.exploitation.payload_result_handler import PayloadResultHandler


class TestPayloadResultHandler:
    """Comprehensive test suite for PayloadResultHandler functionality."""

    def setup_method(self):
        """Set up test fixtures for each test method."""
        self.output_messages: List[str] = []
        self.save_callback_calls: List[tuple] = []

    def output_capture_func(self, message: str) -> None:
        """Capture output messages for testing."""
        self.output_messages.append(message)

    def save_callback_capture(self, payload: bytes, metadata: Dict[str, Any]) -> None:
        """Capture save callback calls for testing."""
        self.save_callback_calls.append((payload, metadata))

    def test_successful_payload_processing_minimal_metadata(self):
        """Test successful payload processing with minimal required metadata."""
        # Real shellcode payload (calc.exe spawning shellcode for Windows x64)
        payload_data = b"\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff"

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 4.237
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert len(self.output_messages) == 3
        assert self.output_messages[0] == "✓ Payload generated successfully!"
        assert f"Size: {len(payload_data)} bytes" in self.output_messages[1]
        assert "Entropy: 4.237" in self.output_messages[2]

    def test_successful_payload_processing_full_metadata(self):
        """Test successful payload processing with all optional metadata fields."""
        # Real reverse shell payload
        payload_data = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
        payload_hash = hashlib.md5(payload_data).hexdigest()

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 5.842,
                "null_bytes": 3,
                "bad_chars": [b"\x00", b"\x0a", b"\x0d"],
                "compatibility_score": 0.87,
                "hash_md5": payload_hash
            },
            "generation_time": 0.15
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert len(self.output_messages) == 8
        assert "✓ Payload generated successfully!" in self.output_messages[0]
        assert f"Size: {len(payload_data)} bytes" in self.output_messages[1]
        assert "Entropy: 5.842" in self.output_messages[2]
        assert "Null bytes: 3" in self.output_messages[3]
        assert "Bad chars: 3" in self.output_messages[4]
        assert "Compatibility: 0.87" in self.output_messages[5]
        assert f"MD5: {payload_hash}" in self.output_messages[6]
        assert "Generation time: 0.15s" in self.output_messages[7]

    def test_successful_payload_with_save_callback(self):
        """Test successful payload processing with save callback."""
        # Real bind shell payload
        payload_data = b"\x89\xe5\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x51\x6a\x06\x6a\x01\x6a\x02"

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 4.156,
                "compatibility_score": 0.92
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func, self.save_callback_capture
        )

        assert success is True
        assert len(self.save_callback_calls) == 1
        saved_payload, saved_metadata = self.save_callback_calls[0]
        assert saved_payload == payload_data
        assert saved_metadata == result["metadata"]

    def test_failed_payload_with_error_message(self):
        """Test failed payload generation with specific error message."""
        result = {
            "success": False,
            "error": "Invalid architecture specified: x86-128"
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is False
        assert len(self.output_messages) == 1
        assert "✗ Payload generation failed: Invalid architecture specified: x86-128" in self.output_messages[0]

    def test_failed_payload_without_error_message(self):
        """Test failed payload generation without specific error message."""
        result = {
            "success": False
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is False
        assert len(self.output_messages) == 1
        assert "✗ Payload generation failed: Unknown error occurred" in self.output_messages[0]

    def test_save_callback_not_called_on_failure(self):
        """Test that save callback is not called when payload generation fails."""
        result = {
            "success": False,
            "error": "Insufficient memory for payload generation"
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func, self.save_callback_capture
        )

        assert success is False
        assert len(self.save_callback_calls) == 0

    def test_none_save_callback_handling(self):
        """Test proper handling of None save callback."""
        payload_data = b"\x90\x90\x90\x90"  # NOP sled

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 0.0
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func, None
        )

        assert success is True
        assert len(self.save_callback_calls) == 0

    def test_partial_optional_metadata_fields(self):
        """Test handling of some but not all optional metadata fields."""
        payload_data = b"\xeb\xfe"  # Infinite loop shellcode

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 1.0,
                "null_bytes": 0,
                "compatibility_score": 1.0
                # Missing bad_chars and hash_md5
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert len(self.output_messages) == 5
        assert any("Null bytes: 0" in msg for msg in self.output_messages)
        assert any("Compatibility: 1.00" in msg for msg in self.output_messages)
        assert not any("Bad chars:" in msg for msg in self.output_messages)
        assert not any("MD5:" in msg for msg in self.output_messages)

    def test_zero_values_in_metadata(self):
        """Test proper handling of zero values in metadata fields."""
        payload_data = b"\x90" * 100  # Large NOP sled

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 0.0,
                "null_bytes": 0,
                "bad_chars": [],
                "compatibility_score": 0.0
            },
            "generation_time": 0.0
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert any("Entropy: 0.000" in msg for msg in self.output_messages)
        assert any("Null bytes: 0" in msg for msg in self.output_messages)
        assert any("Bad chars: 0" in msg for msg in self.output_messages)
        assert any("Compatibility: 0.00" in msg for msg in self.output_messages)
        assert any("Generation time: 0.00s" in msg for msg in self.output_messages)

    def test_large_payload_handling(self):
        """Test handling of large payload data."""
        # Simulate large payload (e.g., staged payload)
        payload_data = b"\x90" * 65536  # 64KB payload

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 0.0,
                "null_bytes": 65536,
                "bad_chars": [b"\x90"] * 1000  # Many bad chars
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func, self.save_callback_capture
        )

        assert success is True
        assert len(self.save_callback_calls) == 1
        saved_payload, _ = self.save_callback_calls[0]
        assert len(saved_payload) == 65536
        assert any("Size: 65536 bytes" in msg for msg in self.output_messages)

    def test_high_entropy_payload(self):
        """Test handling of high-entropy payload (encrypted/obfuscated)."""
        import secrets

        # Generate high-entropy payload
        payload_data = secrets.token_bytes(256)

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 7.98,  # Very high entropy
                "compatibility_score": 0.15  # Low compatibility due to randomness
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert any("Entropy: 7.980" in msg for msg in self.output_messages)
        assert any("Compatibility: 0.15" in msg for msg in self.output_messages)

    def test_edge_case_empty_bad_chars_list(self):
        """Test handling of empty bad characters list."""
        payload_data = b"\x31\xc0\x40\xc3"  # Simple payload

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 2.0,
                "bad_chars": []  # No bad characters
            }
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert any("Bad chars: 0" in msg for msg in self.output_messages)

    def test_metadata_formatting_precision(self):
        """Test that metadata values are formatted with correct precision."""
        payload_data = b"\x48\x89\xe5"

        result = {
            "success": True,
            "payload": payload_data,
            "metadata": {
                "size_bytes": len(payload_data),
                "entropy": 2.3456789,  # Test precision limiting
                "compatibility_score": 0.876543  # Test precision limiting
            },
            "generation_time": 1.23456789  # Test precision limiting
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func
        )

        assert success is True
        assert any("Entropy: 2.346" in msg for msg in self.output_messages)  # 3 decimal places
        assert any("Compatibility: 0.88" in msg for msg in self.output_messages)  # 2 decimal places
        assert any("Generation time: 1.23s" in msg for msg in self.output_messages)  # 2 decimal places

    def test_multiple_calls_state_independence(self):
        """Test that multiple calls don't interfere with each other."""
        payload1 = b"\x90\x90"
        payload2 = b"\x31\xc0"

        result1 = {
            "success": True,
            "payload": payload1,
            "metadata": {
                "size_bytes": len(payload1),
                "entropy": 0.0
            }
        }

        result2 = {
            "success": False,
            "error": "Test error"
        }

        # Clear previous state
        self.output_messages.clear()
        self.save_callback_calls.clear()

        # First call
        success1 = PayloadResultHandler.process_payload_result(
            result1, self.output_capture_func, self.save_callback_capture
        )

        first_call_messages = len(self.output_messages)
        first_call_saves = len(self.save_callback_calls)

        # Second call
        success2 = PayloadResultHandler.process_payload_result(
            result2, self.output_capture_func, self.save_callback_capture
        )

        assert success1 is True
        assert success2 is False
        assert len(self.output_messages) == first_call_messages + 1  # One error message added
        assert len(self.save_callback_calls) == first_call_saves  # No additional saves

    def test_real_world_msfvenom_like_result(self):
        """Test with realistic payload result similar to msfvenom output."""
        # Simulate msfvenom windows/x64/meterpreter/reverse_tcp payload
        meterpreter_payload = bytes.fromhex(
            "fc4883e4f0e8c0000000415141505251564831d265488b5260488b5218488b52204"
            "88b72504d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed5241514831d265488b"
        )

        result = {
            "success": True,
            "payload": meterpreter_payload,
            "metadata": {
                "size_bytes": len(meterpreter_payload),
                "entropy": 6.234,
                "null_bytes": 0,
                "bad_chars": [],
                "compatibility_score": 0.95,
                "hash_md5": hashlib.md5(meterpreter_payload).hexdigest()
            },
            "generation_time": 0.08
        }

        success = PayloadResultHandler.process_payload_result(
            result, self.output_capture_func, self.save_callback_capture
        )

        assert success is True
        assert len(self.save_callback_calls) == 1
        saved_payload, saved_metadata = self.save_callback_calls[0]
        assert saved_payload == meterpreter_payload
        assert saved_metadata["entropy"] == 6.234
        assert saved_metadata["compatibility_score"] == 0.95

    def test_exploitation_framework_integration(self):
        """Test integration with exploitation framework results."""
        # Simulate result from Intellicrack's AI-generated payload
        ai_payload = b"\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\xb0\x3b\x48\x89\xe7\xcd\x80"

        result = {
            "success": True,
            "payload": ai_payload,
            "metadata": {
                "size_bytes": len(ai_payload),
                "entropy": 4.567,
                "null_bytes": 2,
                "bad_chars": [b"\x00", b"\x0a"],
                "compatibility_score": 0.78,
                "hash_md5": hashlib.md5(ai_payload).hexdigest()
            },
            "generation_time": 2.34
        }

        # Test with lambda output function (common pattern)
        output_log = []
        success = PayloadResultHandler.process_payload_result(
            result,
            lambda msg: output_log.append(msg),
            lambda payload, metadata: None  # Discard save
        )

        assert success is True
        assert len(output_log) == 8
        assert "✓ Payload generated successfully!" in output_log[0]
        assert f"Size: {len(ai_payload)} bytes" in output_log[1]
        assert "Generation time: 2.34s" in output_log[7]
