from __future__ import annotations

import hashlib
import os
import struct
import sys
import tempfile
from pathlib import Path
from typing import Any

import pytest

sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent.parent))

try:
    from intellicrack.core.exploitation.automated_unpacker import (
        AutomatedUnpacker,
        PackerType,
    )
    from intellicrack.core.exploitation.bypass_engine import BypassEngine
    from intellicrack.core.exploitation.crypto_key_extractor import (
        CryptoKeyExtractor,
        KeyType,
    )
    from intellicrack.core.exploitation.keygen_generator import (
        KeyAlgorithmType,
        KeygenGenerator,
    )
    MODULE_AVAILABLE = True
except ImportError as e:
    AutomatedUnpacker = None
    PackerType = None
    BypassEngine = None
    CryptoKeyExtractor = None
    KeyType = None
    KeyAlgorithmType = None
    KeygenGenerator = None
    MODULE_AVAILABLE = False
    IMPORT_ERROR = str(e)

try:
    import lief
    LIEF_AVAILABLE = True
except ImportError:
    LIEF_AVAILABLE = False

pytestmark = pytest.mark.skipif(not MODULE_AVAILABLE, reason="Module not available")


class TestBinaryGenerator:

    @staticmethod
    def create_test_binary_with_embedded_rsa_key(output_path: str) -> dict[str, Any]:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        KNOWN_RSA_MODULUS = 0x00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aba8a9e9edd3f8c6cd7f5ecb8f9c1f6c1a51d3f7a4db1c8a9b7e5
        KNOWN_RSA_EXPONENT = 0x010001

        binary = lief.PE.Binary("test_licensed_app", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".rdata")

        key_data = struct.pack(">Q", KNOWN_RSA_MODULUS) + struct.pack(">I", KNOWN_RSA_EXPONENT)
        section.content = list(key_data)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ

        binary.add_section(section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return {
            "modulus": KNOWN_RSA_MODULUS,
            "exponent": KNOWN_RSA_EXPONENT,
            "key_data": key_data,
        }

    @staticmethod
    def create_test_binary_with_serial_validation(output_path: str) -> dict[str, Any]:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        KNOWN_SERIAL_PATTERN = b"XXXX-YYYY-ZZZZ-AAAA"
        KNOWN_CHECKSUM_ALGO = "CRC32"

        binary = lief.PE.Binary("test_serial_app", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".data")

        serial_data = KNOWN_SERIAL_PATTERN + b"\x00" + KNOWN_CHECKSUM_ALGO.encode()
        section.content = list(serial_data)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ

        binary.add_section(section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return {
            "pattern": KNOWN_SERIAL_PATTERN,
            "algorithm": KNOWN_CHECKSUM_ALGO,
        }

    @staticmethod
    def create_upx_packed_binary(output_path: str) -> str:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available for test binary generation")

        binary = lief.PE.Binary("test_packed", lief.PE.PE_TYPE.PE32)

        upx0_section = lief.PE.Section("UPX0")
        upx0_section.content = [0] * 0x1000
        upx0_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ |
            lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
        )
        binary.add_section(upx0_section)

        upx1_section = lief.PE.Section("UPX1")
        upx1_section.content = [0x90] * 0x2000
        upx1_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_CODE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        binary.add_section(upx1_section)

        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        return output_path


@pytest.fixture
def temp_dir(tmp_path: Path) -> Path:
    return tmp_path


@pytest.fixture
def test_binary_with_rsa_key(temp_dir: Path) -> tuple[str, dict[str, Any]]:
    output_path = str(temp_dir / "test_rsa_binary.exe")
    known_data = TestBinaryGenerator.create_test_binary_with_embedded_rsa_key(output_path)
    return output_path, known_data


@pytest.fixture
def test_binary_with_serial(temp_dir: Path) -> tuple[str, dict[str, Any]]:
    output_path = str(temp_dir / "test_serial_binary.exe")
    known_data = TestBinaryGenerator.create_test_binary_with_serial_validation(output_path)
    return output_path, known_data


@pytest.fixture
def upx_packed_binary(temp_dir: Path) -> str:
    output_path = str(temp_dir / "test_packed.exe")
    return TestBinaryGenerator.create_upx_packed_binary(output_path)


@pytest.mark.skipif(not MODULES_AVAILABLE, reason=f"Modules not available: {'' if MODULES_AVAILABLE else IMPORT_ERROR}")
class TestCryptoKeyExtractorEffectiveness:

    def test_extract_known_rsa_key_from_binary(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]]) -> None:
        binary_path, known_data = test_binary_with_rsa_key
        KNOWN_MODULUS = known_data["modulus"]

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        assert keys is not None, "FAILED: No keys extracted"
        assert len(keys) > 0, "FAILED: Key extractor returned empty list"

        rsa_keys = [k for k in keys if k.key_type == KeyType.RSA]
        assert rsa_keys, "FAILED: No RSA keys found in binary with embedded RSA key"

        found_target_key = any(
            hasattr(key, 'modulus') and key.modulus == KNOWN_MODULUS
            for key in rsa_keys
        )
        assert found_target_key, f"FAILED: Known RSA modulus {hex(KNOWN_MODULUS)} not extracted"

    def test_extract_symmetric_key_with_high_entropy(self, temp_dir: Path) -> None:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        KNOWN_AES_KEY = b'\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c'

        binary = lief.PE.Binary("test_aes", lief.PE.PE_TYPE.PE32)
        section = lief.PE.Section(".data")
        section.content = list(KNOWN_AES_KEY * 4)
        section.characteristics = lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA | lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        binary.add_section(section)

        output_path = str(temp_dir / "test_aes_binary.exe")
        builder = lief.PE.Builder(binary)
        builder.build()
        builder.write(output_path)

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=output_path)

        assert keys is not None, "FAILED: No keys extracted"

        symmetric_keys = [k for k in keys if k.key_type in (KeyType.AES, KeyType.SYMMETRIC)]
        assert (
            symmetric_keys
        ), "FAILED: No symmetric keys extracted from binary with AES key"

        found_aes_key = False
        for key in symmetric_keys:
            if hasattr(key, 'key_data') and (KNOWN_AES_KEY in key.key_data or key.key_data == KNOWN_AES_KEY):
                found_aes_key = True
                break

        assert found_aes_key, "FAILED: Known AES key not extracted"

    def test_key_extraction_precision(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]]) -> None:
        binary_path, known_data = test_binary_with_rsa_key

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        false_positives = 0
        true_positives = 0

        for key in keys:
            if key.key_type == KeyType.RSA:
                if hasattr(key, 'modulus') and key.modulus == known_data["modulus"]:
                    true_positives += 1
                else:
                    false_positives += 1

        assert true_positives >= 1, "FAILED: Did not extract known key (no true positives)"

        if false_positives + true_positives > 0:
            precision = true_positives / (true_positives + false_positives)
            assert precision >= 0.1, f"FAILED: Key extraction precision too low ({precision:.2%})"


@pytest.mark.skipif(not MODULES_AVAILABLE, reason=f"Modules not available: {'' if MODULES_AVAILABLE else IMPORT_ERROR}")
class TestKeygenGeneratorEffectiveness:

    def test_generate_valid_checksum_based_keys(self) -> None:
        generator = KeygenGenerator()

        def simple_checksum_validator(key: str) -> bool:
            if len(key) != 16:
                return False
            try:
                parts = key.split('-')
                if len(parts) != 4:
                    return False

                values = [int(p, 16) for p in parts[:3]]
                checksum = sum(values) & 0xFFFF
                expected = int(parts[3], 16)

                return checksum == expected
            except (ValueError, IndexError):
                return False

        template_code = """
def generate_key():
    import random
    parts = [random.randint(0, 0xFFFF) for _ in range(3)]
    checksum = sum(parts) & 0xFFFF
    return '-'.join(f'{p:04X}' for p in parts) + f'-{checksum:04X}'
"""

        keygen = generator.create_keygen_from_algorithm(
            algorithm_type=KeyAlgorithmType.CHECKSUM,
            template_code=template_code,
        )

        assert keygen is not None, "FAILED: Keygen creation failed"

        generated_keys = generator.generate_batch_keys(keygen=keygen, count=10)

        assert len(generated_keys) == 10, f"FAILED: Expected 10 keys, got {len(generated_keys)}"

        valid_count = 0
        for key in generated_keys:
            if simple_checksum_validator(key):
                valid_count += 1

        success_rate = valid_count / len(generated_keys)
        assert success_rate >= 0.9, f"FAILED: Key validity rate too low ({success_rate:.0%}), expected >= 90%"

    def test_keygen_produces_unique_keys(self) -> None:
        generator = KeygenGenerator()

        template_code = """
def generate_key():
    import random
    import hashlib
    rand_bytes = random.randbytes(8)
    hash_val = hashlib.md5(rand_bytes).hexdigest()[:16].upper()
    return '-'.join([hash_val[i:i+4] for i in range(0, 16, 4)])
"""

        keygen = generator.create_keygen_from_algorithm(
            algorithm_type=KeyAlgorithmType.HASH,
            template_code=template_code,
        )

        generated_keys = generator.generate_batch_keys(keygen=keygen, count=100)

        unique_keys = set(generated_keys)
        uniqueness_rate = len(unique_keys) / len(generated_keys)

        assert uniqueness_rate >= 0.95, f"FAILED: Key uniqueness too low ({uniqueness_rate:.0%}), expected >= 95%"

    def test_extract_algorithm_from_binary(self, test_binary_with_serial: tuple[str, dict[str, Any]]) -> None:
        binary_path, known_data = test_binary_with_serial

        generator = KeygenGenerator()

        algorithm = generator.extract_algorithm_from_binary(binary_path=binary_path)

        assert algorithm is not None, "FAILED: No algorithm extracted from binary"
        assert hasattr(algorithm, 'algorithm_type'), "FAILED: Extracted algorithm missing type"

        if hasattr(algorithm, 'pattern'):
            pattern_bytes = known_data["pattern"]
            assert pattern_bytes in str(algorithm.pattern).encode() or str(algorithm.pattern).encode() in pattern_bytes, \
                "FAILED: Extracted algorithm doesn't match known pattern"


@pytest.mark.skipif(not MODULES_AVAILABLE, reason=f"Modules not available: {'' if MODULES_AVAILABLE else IMPORT_ERROR}")
class TestAutomatedUnpackerEffectiveness:

    def test_detect_upx_packer(self, upx_packed_binary: str) -> None:
        unpacker = AutomatedUnpacker()

        detected_packer = unpacker.detect_packer(binary_path=upx_packed_binary)

        assert detected_packer is not None, "FAILED: No packer detected in UPX-packed binary"
        assert detected_packer == PackerType.UPX or "UPX" in str(detected_packer), \
            f"FAILED: Incorrect packer detected (got {detected_packer}, expected UPX)"

    def test_unpacking_produces_valid_pe(self, upx_packed_binary: str, temp_dir: Path) -> None:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        unpacker = AutomatedUnpacker()
        output_path = str(temp_dir / "unpacked.exe")

        result = unpacker.unpack_file(
            input_path=upx_packed_binary,
            output_path=output_path,
        )

        assert result is not None, "FAILED: Unpacking returned None"
        assert result.get("success", False), f"FAILED: Unpacking failed: {result.get('error', 'Unknown error')}"
        assert os.path.exists(output_path), "FAILED: Unpacked binary not written to disk"

        try:
            unpacked_binary = lief.parse(output_path)
            assert unpacked_binary is not None, "FAILED: Unpacked binary is not a valid PE"
            assert unpacked_binary.has_imports or unpacked_binary.has_exports or unpacked_binary.sections, \
                "FAILED: Unpacked binary has no imports, exports, or sections (likely corrupted)"
        except Exception as e:
            pytest.fail(f"FAILED: Unpacked binary validation failed: {e}")

    def test_unpacker_preserves_functionality(self, temp_dir: Path) -> None:
        if not LIEF_AVAILABLE:
            pytest.skip("LIEF not available")

        original_binary = lief.PE.Binary("test_original", lief.PE.PE_TYPE.PE32)

        text_section = lief.PE.Section(".text")
        text_section.content = [0x90, 0xC3] * 100
        text_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_CODE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        original_binary.add_section(text_section)

        data_section = lief.PE.Section(".data")
        MARKER_DATA = b"TESTMARKER12345"
        data_section.content = list(MARKER_DATA)
        data_section.characteristics = (
            lief.PE.SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA |
            lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        )
        original_binary.add_section(data_section)

        original_path = str(temp_dir / "original.exe")
        builder = lief.PE.Builder(original_binary)
        builder.build()
        builder.write(original_path)

        with open(original_path, 'rb') as f:
            original_hash = hashlib.sha256(f.read()).hexdigest()

        unpacker = AutomatedUnpacker()
        unpacked_path = str(temp_dir / "unpacked_functional.exe")

        result = unpacker.unpack_file(
            input_path=original_path,
            output_path=unpacked_path,
        )

        if result and result.get("success") and os.path.exists(unpacked_path):
            unpacked_binary = lief.parse(unpacked_path)

            found_marker = False
            for section in unpacked_binary.sections:
                section_content = bytes(section.content)
                if MARKER_DATA in section_content:
                    found_marker = True
                    break

            assert found_marker, "FAILED: Unpacker did not preserve critical data sections"


@pytest.mark.skipif(not MODULES_AVAILABLE, reason=f"Modules not available: {'' if MODULES_AVAILABLE else IMPORT_ERROR}")
class TestBypassEngineEffectiveness:

    def test_recommend_bypass_for_protection(self) -> None:
        bypass_engine = BypassEngine()

        protection_type = "VMProtect"

        recommendations = bypass_engine.get_bypass_recommendations(
            protection_type=protection_type,
        )

        assert recommendations is not None, "FAILED: No bypass recommendations returned"
        assert len(recommendations) > 0, f"FAILED: No bypass techniques for {protection_type}"

        required_techniques = ["devirtualization", "hook", "emulation"]
        found_techniques = [rec for rec in recommendations if any(tech in str(rec).lower() for tech in required_techniques)]

        assert (
            found_techniques
        ), f"FAILED: Bypass recommendations don't include expected techniques for {protection_type}"

    def test_bypass_effectiveness_analysis(self) -> None:
        bypass_engine = BypassEngine()

        protection_types = ["VMProtect", "Themida", "Denuvo", "Arxan"]

        for protection in protection_types:
            recommendations = bypass_engine.get_bypass_recommendations(protection_type=protection)

            assert recommendations is not None and len(recommendations) > 0, \
                f"FAILED: No bypass recommendations for common protection: {protection}"

            has_actionable_bypass = False
            for rec in recommendations:
                rec_str = str(rec).lower()
                if any(keyword in rec_str for keyword in ["hook", "patch", "emulate", "devirtualize", "unpack"]):
                    has_actionable_bypass = True
                    break

            assert has_actionable_bypass, \
                f"FAILED: Bypass recommendations for {protection} lack actionable techniques"


@pytest.mark.skipif(not MODULES_AVAILABLE, reason=f"Modules not available: {'' if MODULES_AVAILABLE else IMPORT_ERROR}")
class TestIntegrationEffectiveness:

    def test_full_exploitation_pipeline(self, test_binary_with_rsa_key: tuple[str, dict[str, Any]], temp_dir: Path) -> None:
        binary_path, known_data = test_binary_with_rsa_key

        extractor = CryptoKeyExtractor()
        keys = extractor.extract_from_binary(binary_path=binary_path)

        assert len(keys) > 0, "FAILED: Step 1 - Key extraction failed"

        rsa_keys = [k for k in keys if k.key_type == KeyType.RSA]
        assert rsa_keys, "FAILED: Step 1 - No RSA keys extracted"

        generator = KeygenGenerator()

        if rsa_keys[0].key_data:
            template_code = f"""
def generate_key():
    return "{rsa_keys[0].key_data.hex()}"
"""

            keygen = generator.create_keygen_from_algorithm(
                algorithm_type=KeyAlgorithmType.RSA,
                template_code=template_code,
            )

            assert keygen is not None, "FAILED: Step 2 - Keygen creation failed"

            generated_keys = generator.generate_batch_keys(keygen=keygen, count=5)
            assert len(generated_keys) == 5, "FAILED: Step 2 - Key generation failed"

        bypass_engine = BypassEngine()
        recommendations = bypass_engine.get_bypass_recommendations(protection_type="RSA")

        assert recommendations is not None and len(recommendations) > 0, \
                "FAILED: Step 3 - Bypass recommendation failed"

    def test_unpacker_to_key_extractor_workflow(self, upx_packed_binary: str, temp_dir: Path) -> None:
        unpacker = AutomatedUnpacker()
        unpacked_path = str(temp_dir / "unpacked_for_extraction.exe")

        result = unpacker.unpack_file(
            input_path=upx_packed_binary,
            output_path=unpacked_path,
        )

        if result and result.get("success") and os.path.exists(unpacked_path):
            extractor = CryptoKeyExtractor()
            keys = extractor.extract_from_binary(binary_path=unpacked_path)

            assert keys is not None, "FAILED: Key extraction from unpacked binary failed"
