import random
import string
import types
from pathlib import Path

import pytest

from intellicrack.core.exploitation.keygen_generator import (
    ConstraintSolver,
    KeySpaceExplorer,
    KeygenGenerator,
    KeyAlgorithmType,
    KeyConstraint,
    KeygenTemplate,
)


@pytest.fixture(autouse=True)
def _seed_random():
    random.seed(12345)
    yield
    random.seed(12345)


@pytest.fixture
def solver():
    return ConstraintSolver()


@pytest.fixture
def explorer():
    return KeySpaceExplorer()


@pytest.fixture
def standard_template():
    return KeygenTemplate(
        format="####-####-####-####",
        charset=string.ascii_uppercase + string.digits,
        checksum_algorithm="crc32",
    )


@pytest.fixture
def digit_template():
    return KeygenTemplate(
        format="####-####-####-####-####-####",
        charset=string.digits,
        checksum_algorithm="luhn",
    )


def test_formatting_preserves_non_placeholders(solver):
    # Behavior 1: formatting should preserve non-# characters and fill #
    fmt = "AB##-CD##-EF##-GH##"
    chars = list("12345678")
    result = solver._format_key(chars, fmt)
    assert result.startswith("AB") and "-" in result and "CD" in result and "EF" in result and "GH" in result
    # Ensure all # were substituted by the provided chars in order
    extracted = result.replace("AB", "").replace("CD", "").replace("EF", "").replace("GH", "").replace("-", "")
    assert extracted == "12345678"


def test_crc32_checksum_apply_and_verify(solver, standard_template):
    # Behavior 2: CRC32 checksum should be applied and verified
    # Build a key with last segment reserved for CRC (8 chars), others random
    pre_key = "AAAA-AAAA-AAAA-00000000"
    fixed = solver._apply_checksum(pre_key, "crc32")
    assert fixed.count("-") == 3
    # Verify checksum recognizes the last 8 as CRC of first parts
    assert solver._verify_checksum(fixed, "crc32") is True


def test_luhn_checksum_calculation_and_verification(solver, digit_template):
    # Behavior 3: Luhn calculation and verification
    # Construct a numeric string ending with check digit
    base = "7992739871"  # classic Luhn example base
    check = solver._calculate_luhn(base)
    full = base + str(check)
    # Should verify to True
    assert solver._verify_luhn(full) is True
    # Using template apply should embed Luhn check in last char of last segment
    pre_key = "1234-5678-9012-3456-7890-0000"
    applied = solver._apply_checksum(pre_key, "luhn")
    assert applied.count("-") == 5
    # Remove dashes and verify luhn
    assert solver._verify_luhn(applied.replace("-", "")) is True


def test_pattern_matching_accepts_and_rejects(solver):
    # Behavior 4: _match_pattern should map # to [A-Z0-9]
    pattern = "####-##-####"
    assert solver._match_pattern("ABCD-12-EF34", pattern) is True
    assert solver._match_pattern("abcd-12-ef34", pattern) is False  # lowercase not allowed by pattern
    assert solver._match_pattern("ABCD-1X-EF34", pattern) is False  # mixed letter-digit in 2-length segment shouldn't fit if not strictly alnum length


@pytest.mark.parametrize("algo", ["md5", "sha1", "sha256"])  # Behavior 5
def test_hash_prefix_verification(solver, algo):
    # Build a key that includes the digest prefix within
    payload = "PAYLOAD123"
    engine = solver._init_crypto_engines()[algo]
    digest = engine()
    digest.update(payload.encode())
    hexd = digest.hexdigest().upper()
    # Place first 8 chars of digest within key
    key = f"{payload}{hexd[:8]}"  # no dashes; _verify_checksum strips dashes only
    assert solver._verify_checksum(key, algo) is True


def test_space_size_estimation(explorer):
    # Behavior 6: correct key space estimation
    tpl = KeygenTemplate(format="##-#", charset="AB")  # 3 placeholders, charset size 2 => 2^3 = 8
    assert explorer._estimate_space_size(tpl) == 8


def test_exhaustive_search_small_space(explorer):
    # Behavior 7: exhaustive path for small space and honoring validator
    tpl = KeygenTemplate(format="#", charset="AB")  # space size 2
    constraints = []
    def validator(k: str) -> bool:
        return k == "A"
    results = explorer.explore_keyspace(tpl, constraints, validator, max_keys=5)
    assert results == ["A"]


def test_intelligent_search_large_space_returns_results(explorer):
    # Behavior 8: intelligent GA path for large space
    tpl = KeygenTemplate(format="####-####", charset="ABCDEF0123456789")  # large space
    constraints = []
    # Permissive validator always returns True
    def validator(_k: str) -> bool:
        return True
    results = explorer.explore_keyspace(tpl, constraints, validator, max_keys=3)
    # Should return up to requested keys
    assert 0 < len(results) <= 3
    # Keys should follow the format
    for k in results:
        assert len(k.split("-")) == 2
        assert all(c in tpl.charset or c == "-" for c in k)


class DummyExtractor:
    def extract_algorithm(self, _binary_path, search_strings=None):
        return []  # Force heuristic path


def test_heuristic_generation_applies_template_and_checksum(monkeypatch, standard_template):
    # Behavior 9: heuristic generation applies template and checksum if configured
    gen = KeygenGenerator()
    # Patch extractor to avoid PE/capstone dependency and force heuristic
    monkeypatch.setattr(gen, "extractor", DummyExtractor())

    keys = gen._heuristic_generation("standard", 5)
    assert len(keys) == 5
    for k in keys:
        # Validate format and checksum
        assert k.count("-") == 3
        assert all(ch in standard_template.charset or ch == "-" for ch in k)
        assert gen.solver._verify_checksum(k, "crc32") is True


def test_generate_keygen_falls_back_to_heuristic(monkeypatch, tmp_path):
    # Behavior 10: generate_keygen falls back when no algorithms extracted
    gen = KeygenGenerator()
    monkeypatch.setattr(gen, "extractor", DummyExtractor())

    # Provide a dummy binary path (not opened due to mocked extractor)
    fake_binary = str(tmp_path / "fake.exe")
    Path(fake_binary).write_bytes(b"MZ\x90\x00")

    keys = gen.generate_keygen(fake_binary, template_name="simple", num_keys=4)
    assert 0 < len(keys) <= 4
    # Validate simple template structure (no dashes, 10 chars)
    for k in keys:
        assert len(k) == 10
        assert k.isalnum()

