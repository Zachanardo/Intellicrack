"""
Unit tests for Bypass Engine with REAL mitigation bypass techniques.
Tests REAL ASLR, DEP, and CFI bypass generation.
NO MOCKS - ALL TESTS GENERATE REAL BYPASS CODE FOR ANALYSIS.
"""

import pytest
import struct
from pathlib import Path

from intellicrack.core.exploitation.bypass_engine import BypassEngine
from intellicrack.core.exploitation.aslr_bypass import ASLRBypass
from intellicrack.core.exploitation.dep_bypass import DEPBypass
from intellicrack.core.exploitation.cet_bypass import CETBypass
from tests.base_test import BaseIntellicrackTest


class TestBypassEngine(BaseIntellicrackTest):
    """Test bypass engine with REAL mitigation bypass techniques."""

    @pytest.fixture(autouse=True)
    def setup(self, real_pe_binary):
        """Set up test with bypass engine and real binary."""
        self.engine = BypassEngine()
        self.test_binary = real_pe_binary

    def test_aslr_bypass_generation_real(self):
        """Test REAL ASLR bypass technique generation."""
        # Analyze binary for ASLR bypass opportunities
        aslr_analysis = self.engine.analyze_aslr_mitigations(self.test_binary)

        # Generate ASLR bypass
        bypass_config = {
            'technique': 'info_leak',
            'target_binary': self.test_binary,
            'leak_method': 'partial_overwrite',
            'architecture': 'x64'
        }

        bypass_result = self.engine.generate_aslr_bypass(bypass_config)

        # Validate real ASLR bypass
        self.assert_real_output(bypass_result)
        assert 'bypass_code' in bypass_result
        assert 'technique_details' in bypass_result
        assert 'success_probability' in bypass_result

        # Check bypass code structure
        bypass_code = bypass_result['bypass_code']
        assert isinstance(bypass_code, (bytes, str))
        assert len(bypass_code) > 0

        # Validate technique details
        technique_details = bypass_result['technique_details']
        assert 'method' in technique_details
        assert 'requirements' in technique_details
        assert 'reliability' in technique_details

        # Check success probability is realistic
        assert 0 <= bypass_result['success_probability'] <= 100

    def test_dep_bypass_rop_chain_real(self):
        """Test REAL DEP bypass using ROP chain generation."""
        # Generate ROP chain for DEP bypass
        rop_config = {
            'technique': 'rop_chain',
            'target_binary': self.test_binary,
            'objective': 'make_memory_executable',
            'payload_location': 'stack'
        }

        rop_result = self.engine.generate_dep_bypass(rop_config)

        # Validate real ROP chain
        self.assert_real_output(rop_result)
        assert 'rop_chain' in rop_result
        assert 'gadgets_used' in rop_result
        assert 'chain_length' in rop_result

        # Check ROP chain structure
        rop_chain = rop_result['rop_chain']
        assert isinstance(rop_chain, (list, bytes))

        if isinstance(rop_chain, list):
            # List of addresses/gadgets
            assert len(rop_chain) > 0
            for gadget in rop_chain:
                assert 'address' in gadget
                assert 'instruction' in gadget

        # Validate gadgets
        gadgets_used = rop_result['gadgets_used']
        assert len(gadgets_used) > 0

        for gadget in gadgets_used:
            assert 'address' in gadget
            assert 'bytes' in gadget
            assert 'disasm' in gadget
            assert gadget['address'] > 0

    def test_cfi_bypass_generation_real(self):
        """Test REAL Control Flow Integrity bypass generation."""
        # Generate CFI bypass
        cfi_config = {
            'technique': 'indirect_call_hijack',
            'target_binary': self.test_binary,
            'cfi_type': 'intel_cet',
            'bypass_method': 'shadow_stack_corruption'
        }

        cfi_result = self.engine.generate_cfi_bypass(cfi_config)

        # Validate real CFI bypass
        self.assert_real_output(cfi_result)
        assert 'bypass_technique' in cfi_result
        assert 'implementation' in cfi_result
        assert 'requirements' in cfi_result

        # Check implementation details
        implementation = cfi_result['implementation']
        assert 'payload' in implementation
        assert 'setup_code' in implementation
        assert 'trigger_conditions' in implementation

    def test_stack_canary_bypass_real(self):
        """Test REAL stack canary bypass techniques."""
        # Generate stack canary bypass
        canary_config = {
            'technique': 'canary_bruteforce',
            'target_binary': self.test_binary,
            'canary_type': 'gs_cookie',
            'architecture': 'x64'
        }

        canary_result = self.engine.generate_canary_bypass(canary_config)

        # Validate real canary bypass
        self.assert_real_output(canary_result)
        assert 'bypass_method' in canary_result
        assert 'exploit_code' in canary_result
        assert 'time_complexity' in canary_result

        # Check exploit code
        exploit_code = canary_result['exploit_code']
        assert isinstance(exploit_code, (bytes, str))
        assert len(exploit_code) > 0

        # Time complexity should be realistic
        assert canary_result['time_complexity'] > 0

    def test_heap_spray_technique_real(self):
        """Test REAL heap spray technique generation."""
        # Generate heap spray
        spray_config = {
            'technique': 'heap_spray',
            'target_heap': 'process_heap',
            'spray_size': 0x10000,
            'nop_sled_size': 0x1000,
            'payload_offset': 0x8000
        }

        spray_result = self.engine.generate_heap_spray(spray_config)

        # Validate real heap spray
        self.assert_real_output(spray_result)
        assert 'spray_data' in spray_result
        assert 'allocation_strategy' in spray_result
        assert 'success_rate' in spray_result

        # Check spray data
        spray_data = spray_result['spray_data']
        assert len(spray_data) == spray_config['spray_size']

        # Should contain NOP sled and payload
        nop_sled_end = spray_config['nop_sled_size']
        nop_section = spray_data[:nop_sled_end]

        # Check for NOP instructions (0x90 on x86/x64)
        nop_count = nop_section.count(0x90)
        assert nop_count > len(nop_section) * 0.8  # Mostly NOPs

    def test_return_oriented_programming_real(self):
        """Test REAL Return-Oriented Programming chain construction."""
        # Find ROP gadgets in binary
        gadget_search = self.engine.find_rop_gadgets(self.test_binary)

        # Validate gadget discovery
        self.assert_real_output(gadget_search)
        assert 'gadgets' in gadget_search
        assert 'total_found' in gadget_search

        gadgets = gadget_search['gadgets']
        assert len(gadgets) > 0

        # Build ROP chain for specific objective
        rop_objective = {
            'goal': 'call_function',
            'function': 'VirtualProtect',
            'parameters': [
                {'type': 'address', 'value': 'stack_location'},
                {'type': 'size', 'value': 0x1000},
                {'type': 'protection', 'value': 0x40},  # PAGE_EXECUTE_READWRITE
                {'type': 'old_protect', 'value': 'stack_temp'}
            ]
        }

        chain_result = self.engine.build_rop_chain(gadgets, rop_objective)

        # Validate ROP chain construction
        self.assert_real_output(chain_result)
        assert 'chain' in chain_result
        assert 'gadgets_used' in chain_result
        assert 'chain_reliability' in chain_result

        # Check chain structure
        chain = chain_result['chain']
        assert len(chain) > 0

        for link in chain:
            assert 'address' in link
            assert 'purpose' in link
            assert link['address'] > 0

    def test_jop_chain_generation_real(self):
        """Test REAL Jump-Oriented Programming chain generation."""
        # Find JOP gadgets (dispatcher + functional gadgets)
        jop_search = self.engine.find_jop_gadgets(self.test_binary)

        if jop_search['total_found'] == 0:
            pytest.skip("No JOP gadgets found in test binary")

        # Validate JOP gadget discovery
        self.assert_real_output(jop_search)
        assert 'dispatchers' in jop_search
        assert 'functional_gadgets' in jop_search

        # Build JOP chain
        jop_objective = {
            'goal': 'arbitrary_code_execution',
            'payload_location': 'heap',
            'dispatcher_address': jop_search['dispatchers'][0]['address']
        }

        jop_result = self.engine.build_jop_chain(jop_search, jop_objective)

        # Validate JOP chain
        self.assert_real_output(jop_result)
        assert 'jop_program' in jop_result
        assert 'dispatcher_used' in jop_result

    def test_format_string_exploit_real(self):
        """Test REAL format string exploit generation."""
        # Generate format string exploit
        format_config = {
            'vulnerability_type': 'printf',
            'target_function': 'printf',
            'objective': 'arbitrary_write',
            'target_address': 0x08048000,
            'write_value': 0x41414141
        }

        format_result = self.engine.generate_format_string_exploit(format_config)

        # Validate format string exploit
        self.assert_real_output(format_result)
        assert 'format_string' in format_result
        assert 'payload_breakdown' in format_result
        assert 'write_primitive' in format_result

        # Check format string structure
        format_string = format_result['format_string']
        assert '%' in format_string  # Should contain format specifiers
        assert 'n' in format_string  # Should use %n for writing

    def test_integer_overflow_exploit_real(self):
        """Test REAL integer overflow exploit generation."""
        # Generate integer overflow exploit
        overflow_config = {
            'overflow_type': 'signed_integer',
            'target_variable': 'buffer_size',
            'overflow_value': 0x80000000,  # Causes signed overflow
            'exploitation_method': 'heap_corruption'
        }

        overflow_result = self.engine.generate_integer_overflow_exploit(overflow_config)

        # Validate integer overflow exploit
        self.assert_real_output(overflow_result)
        assert 'payload_values' in overflow_result
        assert 'overflow_calculation' in overflow_result
        assert 'exploitation_vector' in overflow_result

        # Check overflow calculation
        calculation = overflow_result['overflow_calculation']
        assert 'original_value' in calculation
        assert 'overflow_value' in calculation
        assert 'result_value' in calculation

    def test_use_after_free_exploit_real(self):
        """Test REAL use-after-free exploit generation."""
        # Generate UAF exploit
        uaf_config = {
            'freed_object_size': 0x100,
            'object_type': 'vtable_object',
            'reallocation_strategy': 'heap_spray',
            'control_method': 'vtable_hijack'
        }

        uaf_result = self.engine.generate_uaf_exploit(uaf_config)

        # Validate UAF exploit
        self.assert_real_output(uaf_result)
        assert 'exploit_sequence' in uaf_result
        assert 'heap_manipulation' in uaf_result
        assert 'control_hijack' in uaf_result

        # Check exploit sequence
        sequence = uaf_result['exploit_sequence']
        assert 'allocation_phase' in sequence
        assert 'free_phase' in sequence
        assert 'reallocation_phase' in sequence
        assert 'exploitation_phase' in sequence

    def test_bypass_technique_chaining_real(self):
        """Test REAL chaining of multiple bypass techniques."""
        # Chain multiple bypass techniques
        chain_config = {
            'techniques': [
                {'type': 'aslr_bypass', 'method': 'info_leak'},
                {'type': 'dep_bypass', 'method': 'rop_chain'},
                {'type': 'canary_bypass', 'method': 'overwrite'}
            ],
            'target_binary': self.test_binary,
            'objective': 'full_control'
        }

        chain_result = self.engine.chain_bypass_techniques(chain_config)

        # Validate technique chaining
        self.assert_real_output(chain_result)
        assert 'exploit_chain' in chain_result
        assert 'chain_reliability' in chain_result
        assert 'execution_order' in chain_result

        # Check each step in chain
        exploit_chain = chain_result['exploit_chain']
        assert len(exploit_chain) == len(chain_config['techniques'])

        for i, step in enumerate(exploit_chain):
            assert 'step_number' in step
            assert 'technique' in step
            assert 'payload' in step
            assert step['step_number'] == i + 1

    def test_bypass_reliability_analysis_real(self):
        """Test REAL bypass technique reliability analysis."""
        # Analyze reliability of bypass techniques
        reliability_config = {
            'techniques': ['aslr_bypass', 'dep_bypass', 'cfi_bypass'],
            'target_environment': {
                'os': 'windows_10',
                'architecture': 'x64',
                'patches': ['KB5000001', 'KB5000002'],
                'mitigations': ['ASLR', 'DEP', 'CFG', 'CET']
            }
        }

        reliability_result = self.engine.analyze_bypass_reliability(reliability_config)

        # Validate reliability analysis
        self.assert_real_output(reliability_result)
        assert 'technique_scores' in reliability_result
        assert 'overall_success_rate' in reliability_result
        assert 'risk_factors' in reliability_result

        # Check individual technique scores
        technique_scores = reliability_result['technique_scores']
        for technique, score in technique_scores.items():
            assert 0 <= score <= 100

        # Overall success rate should be realistic
        assert 0 <= reliability_result['overall_success_rate'] <= 100

    def test_advanced_mitigation_bypass_real(self):
        """Test REAL advanced mitigation bypass techniques."""
        # Test modern mitigation bypasses
        advanced_config = {
            'mitigations': ['CET', 'IBT', 'SMEP', 'SMAP'],
            'bypass_methods': [
                'ret2dir',
                'physmap_spray',
                'kernel_rop',
                'exception_handler_corruption'
            ],
            'target_architecture': 'x64'
        }

        advanced_result = self.engine.generate_advanced_bypasses(advanced_config)

        # Validate advanced bypasses
        self.assert_real_output(advanced_result)
        assert 'bypass_implementations' in advanced_result
        assert 'compatibility_matrix' in advanced_result
        assert 'success_rates' in advanced_result

        # Check implementations
        implementations = advanced_result['bypass_implementations']
        assert len(implementations) > 0

        for impl in implementations:
            assert 'mitigation_target' in impl
            assert 'bypass_code' in impl
            assert 'requirements' in impl
