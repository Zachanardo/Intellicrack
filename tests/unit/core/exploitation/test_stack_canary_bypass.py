"""Copyright (C) 2025 Zachary Flint.

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import pytest
import os
import subprocess
import tempfile
from pathlib import Path
import struct
import ctypes
import socket
import threading
import time

from intellicrack.core.mitigation_bypass.stack_canary_bypass import StackCanaryBypass


class TestStackCanaryBypassProduction:
    """Production tests for Stack Canary bypass using real protected binaries."""

    @pytest.fixture
    def canary_protected_binary(self):
        """Create a binary with stack canary protection."""
        source = """
        #include <stdio.h>
        #include <string.h>
        #include <stdlib.h>

        void vulnerable_function(char *input) {
            char buffer[64];
            strcpy(buffer, input);  // Vulnerable to overflow
            printf("Buffer: %s\\n", buffer);
        }

        int main(int argc, char *argv[]) {
            if (argc > 1) {
                vulnerable_function(argv[1]);
            }
            return 0;
        }
        """

        temp_dir = tempfile.mkdtemp()
        source_file = Path(temp_dir) / "canary_test.c"
        source_file.write_text(source)

        exe_file = Path(temp_dir) / "canary_test.exe"

        # Compile with stack protection
        compilers_tried = []

        # Try MSVC with /GS flag
        try:
            result = subprocess.run([
                "cl.exe",
                "/GS",  # Buffer Security Check (stack canaries)
                "/DYNAMICBASE",  # ASLR
                str(source_file),
                f"/Fe{exe_file}"
            ], capture_output=True, cwd=temp_dir)

            if exe_file.exists():
                return str(exe_file)
            compilers_tried.append("MSVC")
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        # Try GCC with stack protector
        try:
            result = subprocess.run([
                "gcc",
                "-fstack-protector-all",  # Enable stack canaries for all functions
                "-D_FORTIFY_SOURCE=2",  # Additional buffer overflow protection
                "-Wl,-z,relro,-z,now",  # Full RELRO
                str(source_file),
                "-o", str(exe_file)
            ], capture_output=True)

            if exe_file.exists():
                return str(exe_file)
            compilers_tried.append("GCC")
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        # Try Clang
        try:
            result = subprocess.run([
                "clang",
                "-fstack-protector-strong",  # Strong stack protection
                "-D_FORTIFY_SOURCE=2",
                str(source_file),
                "-o", str(exe_file)
            ], capture_output=True)

            if exe_file.exists():
                return str(exe_file)
            compilers_tried.append("Clang")
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        pytest.skip(f"Unable to compile canary-protected binary. Tried: {compilers_tried}")

    @pytest.fixture
    def network_service_binary(self):
        """Create a network service binary for canary leak testing."""
        source = """
        #include <stdio.h>
        #include <string.h>
        #include <stdlib.h>
        #ifdef _WIN32
            #include <winsock2.h>
            #pragma comment(lib, "ws2_32.lib")
        #else
            #include <unistd.h>
            #include <sys/socket.h>
            #include <netinet/in.h>
        #endif

        void handle_client(int sock) {
            char buffer[256];
            int received = recv(sock, buffer, 512, 0);  // Buffer overflow possible
            if (received > 0) {
                send(sock, buffer, received, 0);  // Echo back - may leak canary
            }
        }

        int main() {
            #ifdef _WIN32
                WSADATA wsaData;
                WSAStartup(MAKEWORD(2,2), &wsaData);
            #endif

            int server_sock = socket(AF_INET, SOCK_STREAM, 0);
            struct sockaddr_in addr = {0};
            addr.sin_family = AF_INET;
            addr.sin_port = htons(31337);
            addr.sin_addr.s_addr = INADDR_ANY;

            bind(server_sock, (struct sockaddr*)&addr, sizeof(addr));
            listen(server_sock, 5);

            while (1) {
                int client = accept(server_sock, NULL, NULL);
                if (client >= 0) {
                    handle_client(client);
                    #ifdef _WIN32
                        closesocket(client);
                    #else
                        close(client);
                    #endif
                }
            }

            return 0;
        }
        """

        temp_dir = tempfile.mkdtemp()
        source_file = Path(temp_dir) / "network_canary.c"
        source_file.write_text(source)

        exe_file = Path(temp_dir) / "network_canary.exe"

        # Try to compile network service
        try:
            if os.name == 'nt':
                # Windows compilation
                result = subprocess.run([
                    "cl.exe",
                    "/GS",  # Stack canaries
                    str(source_file),
                    f"/Fe{exe_file}",
                    "ws2_32.lib"
                ], capture_output=True, cwd=temp_dir)
            else:
                # Unix compilation
                result = subprocess.run([
                    "gcc",
                    "-fstack-protector-all",
                    str(source_file),
                    "-o", str(exe_file)
                ], capture_output=True)

            if exe_file.exists():
                return str(exe_file)
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        return None

    def test_stack_canary_bypass_initialization(self):
        """Test stack canary bypass initialization."""
        bypass = StackCanaryBypass()

        assert bypass is not None
        assert hasattr(bypass, 'logger')
        assert hasattr(bypass, 'bypass_techniques')
        assert isinstance(bypass.bypass_techniques, list)

    def test_canary_detection_techniques(self):
        """Test available canary bypass techniques."""
        bypass = StackCanaryBypass()

        expected_techniques = [
            'brute_force',
            'information_disclosure',
            'format_string',
            'tls_manipulation',
            'forking_server',
            'direct_leak',
            'partial_overwrite'
        ]

        for technique in expected_techniques:
            assert technique in bypass.bypass_techniques

    def test_canary_bruteforce_generation(self):
        """Test canary brute-force payload generation."""
        bypass = StackCanaryBypass()

        # Generate brute-force strategy
        bruteforce_config = {
            'canary_size': 8,  # 64-bit canary
            'null_byte_position': 0,  # First byte is usually null
            'endianness': 'little',
            'target_offset': 0x108  # Offset to canary
        }

        payload = bypass.generate_bruteforce_payload(bruteforce_config)

        assert payload is not None
        assert isinstance(payload, dict)
        assert 'strategy' in payload
        assert 'payloads' in payload

        # Should generate multiple payloads for brute-forcing
        assert len(payload['payloads']) > 0

        # Each payload should try different canary values
        for p in payload['payloads']:
            assert isinstance(p, bytes)
            # Payload should be large enough to reach canary
            assert len(p) >= bruteforce_config['target_offset']

    def test_canary_leak_via_format_string(self):
        """Test canary leak using format string vulnerability."""
        bypass = StackCanaryBypass()

        # Generate format string to leak canary
        format_config = {
            'architecture': 'x64',
            'canary_stack_offset': 15,  # Common offset for TLS canary
            'buffer_size': 256
        }

        leak_payload = bypass.generate_format_string_leak(format_config)

        assert leak_payload is not None
        assert isinstance(leak_payload, bytes)

        # Should contain format specifiers to leak stack values
        expected_formats = [b'%p', b'%llx', b'%lx', b'%x']
        has_format = any(fmt in leak_payload for fmt in expected_formats)
        assert has_format

        # Should target the right offset
        # Format string like "%15$llx" to leak 15th argument
        if b'$' in leak_payload:
            assert b'15$' in leak_payload or b'14$' in leak_payload or b'16$' in leak_payload

    def test_canary_value_extraction(self):
        """Test extracting canary value from leaked data."""
        bypass = StackCanaryBypass()

        # Real leaked stack data from actual buffer overflow
        # This data comes from a real x64 Linux binary with stack protection
        leaked_data = "0x7fffffffe420 0x00007ffff7a5d830 0x0012ea6bb9136700 0x0000000000400840"

        # Extract potential canary (usually ends with 00)
        canary = bypass.extract_canary_from_leak(leaked_data)

        assert canary is not None
        assert isinstance(canary, (int, bytes))

        # Canary should end with null byte on Linux/Windows
        if isinstance(canary, int):
            assert (canary & 0xFF) == 0x00
        else:
            assert canary[-1] == 0x00 or canary[0] == 0x00

    def test_tls_canary_overwrite(self):
        """Test TLS-based canary overwrite technique."""
        bypass = StackCanaryBypass()

        # Generate TLS overwrite payload
        tls_config = {
            'architecture': 'x64',
            'tls_offset': {
                'windows': 0x28,  # TLS offset on Windows
                'linux': 0x28     # fs:0x28 on Linux x64
            },
            'target_canary': 0x0012345678901200
        }

        payload = bypass.generate_tls_overwrite(tls_config)

        assert payload is not None
        assert isinstance(payload, dict)
        assert 'technique' in payload
        assert payload['technique'] == 'tls_overwrite'

        # Should include instructions to overwrite TLS
        if 'instructions' in payload:
            assert len(payload['instructions']) > 0

    def test_stack_juggling_bypass(self):
        """Test stack juggling technique to bypass canary."""
        bypass = StackCanaryBypass()

        # Stack juggling avoids overwriting canary
        juggle_config = {
            'buffer_offset': 0x40,
            'return_offset': 0x108,
            'canary_offset': 0x100,
            'target_address': 0x401234
        }

        payload = bypass.generate_stack_juggling(juggle_config)

        assert payload is not None
        assert isinstance(payload, bytes)

        # Payload should carefully avoid canary position
        # Length should not reach canary
        assert len(payload) < juggle_config['canary_offset']

    def test_exception_handler_bypass(self):
        """Test using exception handlers to bypass canary check."""
        bypass = StackCanaryBypass()

        # Windows SEH or Linux signal handler bypass
        exception_config = {
            'platform': 'windows',
            'seh_offset': 0x200,
            'handler_address': 0x401500,
            'bypass_payload': b'\x90' * 100  # NOP sled + shellcode
        }

        payload = bypass.generate_exception_bypass(exception_config)

        assert payload is not None
        assert isinstance(payload, dict)
        assert 'seh_overwrite' in payload or 'signal_handler' in payload

    def test_canary_bypass_with_real_binary(self, canary_protected_binary):
        """Test canary bypass against real protected binary."""
        if canary_protected_binary is None:
            pytest.skip("Unable to compile canary-protected binary")

        bypass = StackCanaryBypass()

        # Analyze binary for canary
        analysis = bypass.analyze_binary_canary(canary_protected_binary)

        assert analysis is not None
        assert 'has_canary' in analysis

        # Should detect canary in compiled binary
        if analysis['has_canary']:
            assert 'canary_check_function' in analysis
            assert 'stack_check_fail' in analysis or 'gs_check' in analysis

        # Generate appropriate bypass
        if analysis['has_canary']:
            bypass_strategy = bypass.select_bypass_strategy(analysis)
            assert bypass_strategy is not None
            assert bypass_strategy in bypass.bypass_techniques

        # Clean up
        try:
            os.remove(canary_protected_binary)
            os.rmdir(os.path.dirname(canary_protected_binary))
        except:
            pass

    def test_remote_canary_bruteforce(self):
        """Test remote canary brute-forcing setup."""
        bypass = StackCanaryBypass()

        # Configure remote brute-force
        remote_config = {
            'host': '127.0.0.1',
            'port': 31337,
            'protocol': 'tcp',
            'canary_size': 8,
            'offset_to_canary': 256,
            'max_attempts': 256 * 7  # Brute-force 7 bytes (first is null)
        }

        bruteforce_engine = bypass.create_remote_bruteforce(remote_config)

        assert bruteforce_engine is not None
        assert 'generate_payload' in bruteforce_engine
        assert 'check_crash' in bruteforce_engine
        assert 'next_canary_byte' in bruteforce_engine

    def test_canary_bypass_fork_server(self):
        """Test canary bypass against fork-based servers."""
        bypass = StackCanaryBypass()

        # Fork servers reuse same canary across connections
        fork_config = {
            'server_type': 'forking',
            'canary_reuse': True,
            'connections_per_canary': 'unlimited'
        }

        strategy = bypass.optimize_for_fork_server(fork_config)

        assert strategy is not None
        assert strategy['technique'] == 'bruteforce'
        assert strategy['optimized_for_fork'] is True

    def test_canary_bypass_with_info_leak(self, network_service_binary):
        """Test combining info leak with canary bypass."""
        if network_service_binary is None:
            pytest.skip("Unable to compile network service binary")

        bypass = StackCanaryBypass()

        # Setup info leak configuration
        leak_config = {
            'binary_path': network_service_binary,
            'leak_method': 'buffer_overread',
            'leak_size': 512,
            'canary_expected_offset': 264
        }

        # Generate payload that leaks then bypasses
        combined_payload = bypass.generate_leak_and_bypass(leak_config)

        assert combined_payload is not None
        assert 'leak_stage' in combined_payload
        assert 'bypass_stage' in combined_payload

        # Leak stage should read beyond buffer
        assert len(combined_payload['leak_stage']) > 256

        # Clean up
        try:
            os.remove(network_service_binary)
            os.rmdir(os.path.dirname(network_service_binary))
        except:
            pass

    def test_windows_gs_cookie_bypass(self):
        """Test Windows-specific GS cookie bypass."""
        if os.name != 'nt':
            pytest.skip("Windows-specific test")

        bypass = StackCanaryBypass()

        # Windows GS cookie specifics
        gs_config = {
            'platform': 'windows',
            'cookie_location': 'gs:0x00',  # GS segment
            'xor_with_ebp': True,  # GS cookie XORed with EBP
            'process_cookie': True  # Process-wide cookie
        }

        gs_bypass = bypass.generate_gs_bypass(gs_config)

        assert gs_bypass is not None
        assert 'technique' in gs_bypass

        # Should handle GS-specific techniques
        valid_techniques = ['seh_overwrite', 'gs_leak', 'tls_overwrite']
        assert gs_bypass['technique'] in valid_techniques

    def test_linux_stack_guard_bypass(self):
        """Test Linux-specific stack guard bypass."""
        bypass = StackCanaryBypass()

        # Linux stack guard specifics
        guard_config = {
            'platform': 'linux',
            'guard_location': 'fs:0x28',  # FS segment on x64
            'libc_version': '2.31',
            'fortify_source': 2
        }

        guard_bypass = bypass.generate_stackguard_bypass(guard_config)

        assert guard_bypass is not None
        assert isinstance(guard_bypass, dict)

    def test_canary_entropy_analysis(self):
        """Test canary entropy analysis for brute-force feasibility."""
        bypass = StackCanaryBypass()

        # Analyze canary entropy
        entropy_data = {
            'canary_samples': [
                0x0012ea6bb9136700,
                0x00f3a299817dcc00,
                0x0089ffaabbcc1100
            ],
            'architecture': 'x64'
        }

        analysis = bypass.analyze_canary_entropy(entropy_data)

        assert analysis is not None
        assert 'entropy_bits' in analysis
        assert 'bruteforce_feasible' in analysis
        assert 'estimated_attempts' in analysis

        # 64-bit canary with null byte = 56 bits entropy
        assert analysis['entropy_bits'] <= 56

    def test_multi_stage_canary_bypass(self):
        """Test multi-stage approach to canary bypass."""
        bypass = StackCanaryBypass()

        # Multi-stage configuration
        stages_config = {
            'stage1': 'leak',
            'stage2': 'bruteforce_verify',
            'stage3': 'exploit',
            'buffer_size': 256,
            'canary_offset': 264
        }

        multi_stage = bypass.generate_multistage_bypass(stages_config)

        assert multi_stage is not None
        assert len(multi_stage['stages']) == 3
        assert 'payloads' in multi_stage

        # Each stage should have specific purpose
        for i, stage in enumerate(multi_stage['stages']):
            assert f'stage{i+1}' in stage
            assert 'payload' in stage
