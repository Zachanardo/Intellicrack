"""Copyright (C) 2025 Zachary Flint.

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import pytest
import os
import sys
import struct
import subprocess
from pathlib import Path
import ctypes
from ctypes import wintypes
import tempfile
import shutil

from intellicrack.core.exploitation.cet_bypass import CETBypass


class TestCETBypassReal:
    """Production tests for CET Bypass using real Windows binaries."""

    @pytest.fixture
    def real_cet_binary(self):
        """Acquire a real Windows binary with CET enabled."""
        # Use Windows system binaries that have CET enabled
        system32 = Path("C:/Windows/System32")

        # Windows Calculator has CET enabled on Windows 11
        calc_path = system32 / "calc.exe"
        if calc_path.exists():
            return str(calc_path)

        # Try Windows Terminal if available
        terminal_path = Path("C:/Program Files/WindowsApps")
        for terminal in terminal_path.glob("*WindowsTerminal*/WindowsTerminal.exe"):
            if terminal.exists():
                return str(terminal)

        # Fall back to notepad.exe which should exist
        notepad = system32 / "notepad.exe"
        if notepad.exists():
            return str(notepad)

        pytest.skip("No suitable CET-enabled binary found")

    @pytest.fixture
    def test_binary_with_cet(self):
        """Create a test binary compiled with CET flags."""
        # Create a simple C program and compile with CET
        source = """
        #include <windows.h>
        #include <stdio.h>

        __declspec(guard(cf)) void protected_function() {
            printf("Protected by CET\\n");
        }

        int main() {
            protected_function();
            return 0;
        }
        """

        temp_dir = tempfile.mkdtemp()
        source_file = Path(temp_dir) / "test_cet.c"
        source_file.write_text(source)

        exe_file = Path(temp_dir) / "test_cet.exe"

        # Try to compile with MSVC if available
        try:
            # Use cl.exe with CET flags
            result = subprocess.run([
                "cl.exe",
                "/guard:cf",  # Enable Control Flow Guard
                "/Qspectre",  # Enable Spectre mitigations
                str(source_file),
                f"/Fe{exe_file}"
            ], capture_output=True, cwd=temp_dir)

            if exe_file.exists():
                return str(exe_file)
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        # Try MinGW as fallback
        try:
            result = subprocess.run([
                "gcc",
                "-fcf-protection=full",  # Enable CET
                "-mshstk",  # Enable shadow stack
                str(source_file),
                "-o", str(exe_file)
            ], capture_output=True)

            if exe_file.exists():
                return str(exe_file)
        except (FileNotFoundError, subprocess.CalledProcessError):
            pass

        # Return None if compilation fails
        return None

    def test_cet_bypass_initialization(self):
        """Test CET bypass initialization with real parameters."""
        bypass = CETBypass()
        assert bypass is not None
        assert bypass.logger is not None
        assert isinstance(bypass.is_windows, bool)
        assert isinstance(bypass.cet_features, dict)

    def test_detect_cet_in_real_binary(self, real_cet_binary):
        """Test CET detection in real Windows binaries."""
        bypass = CETBypass()

        # Check if binary has CET enabled using _check_pe_cet_flags
        result = bypass._check_pe_cet_flags(real_cet_binary)

        # Result should be a dictionary with CET status
        assert isinstance(result, dict)
        assert 'ibt' in result
        assert 'shadow_stack' in result

    def test_parse_pe_headers_for_cet(self, real_cet_binary):
        """Test parsing PE headers for CET configuration."""
        bypass = CETBypass()

        # Read PE headers
        with open(real_cet_binary, 'rb') as f:
            dos_header = f.read(2)
            assert dos_header == b'MZ'  # Verify it's a PE file

            # Parse for CET indicators
            f.seek(0)
            pe_data = f.read(4096)  # Read first 4KB for headers

            # Check for Guard CF flags in DLL characteristics
            # IMAGE_DLLCHARACTERISTICS_GUARD_CF = 0x4000
            if b'\x00\x40' in pe_data or b'\x40\x00' in pe_data:
                assert True  # Guard CF flag found

    def test_shadow_stack_bypass_payload(self):
        """Test shadow stack bypass payload generation."""
        bypass = CETBypass()

        # Generate bypass payload with target_info
        target_info = {
            'binary_path': 'C:/Windows/System32/notepad.exe',
            'arch': 'x64',
            'has_cet': True
        }
        result = bypass.bypass_shadow_stack(target_info)

        assert result is not None
        assert isinstance(result, dict)
        assert 'success' in result or 'payload' in result

        # If payload is present, verify it
        if 'payload' in result:
            payload = result['payload']
            assert isinstance(payload, (bytes, list))
            if isinstance(payload, bytes):
                assert len(payload) > 0

    def test_ibt_bypass_generation(self):
        """Test Indirect Branch Tracking bypass generation."""
        bypass = CETBypass()

        # Generate IBT bypass with target_info
        target_info = {
            'binary_path': 'C:/Windows/System32/notepad.exe',
            'arch': 'x64',
            'has_ibt': True
        }
        ibt_bypass = bypass.bypass_ibt(target_info)

        assert ibt_bypass is not None
        assert isinstance(ibt_bypass, dict)
        assert 'technique' in ibt_bypass
        assert 'payload' in ibt_bypass
        assert isinstance(ibt_bypass['payload'], bytes)

        # Verify it uses valid bypass technique
        valid_techniques = [
            'endbr_hijack',
            'jmp_chain',
            'ret2endbr',
            'notrack_prefix'
        ]
        assert ibt_bypass['technique'] in valid_techniques

    def test_cet_bypass_with_process_injection(self):
        """Test CET bypass in context of process injection."""
        bypass = CETBypass()

        # Test generating injection-compatible bypass
        bypass_result = bypass.generate_bypass()

        assert bypass_result is not None
        assert isinstance(bypass_result, dict)
        assert 'technique' in bypass_result or 'techniques' in bypass_result

    def test_cet_configuration_query(self):
        """Test querying system CET configuration."""
        bypass = CETBypass()

        # Query system CET status
        if sys.platform == 'win32':
            # Use Windows API to check CET status
            kernel32 = ctypes.windll.kernel32

            # GetEnabledXStateFeatures for CET
            try:
                features = kernel32.GetEnabledXStateFeatures()
                # CET_U is bit 11, CET_S is bit 12
                cet_u_enabled = bool(features & (1 << 11))
                cet_s_enabled = bool(features & (1 << 12))

                assert isinstance(cet_u_enabled, bool)
                assert isinstance(cet_s_enabled, bool)
            except AttributeError:
                # Function not available on older Windows
                pytest.skip("CET APIs not available on this Windows version")

    def test_bypass_persistence(self, real_cet_binary):
        """Test that bypass remains effective across operations."""
        bypass = CETBypass()

        # Generate initial bypass
        initial_result = bypass.generate_bypass()

        # Generate second bypass for same target
        second_result = bypass.generate_bypass()

        # Results should be consistent
        assert initial_result is not None
        assert second_result is not None
        assert isinstance(initial_result, dict)
        assert isinstance(second_result, dict)

    def test_cet_bypass_error_handling(self):
        """Test error handling for invalid inputs."""
        bypass = CETBypass()

        # Test with non-existent binary
        result = bypass._check_pe_cet_flags("nonexistent.exe")
        assert result is not None
        assert isinstance(result, dict)

        # Test with invalid target info
        target_info = {}
        result = bypass.bypass_shadow_stack(target_info)
        # Should handle gracefully
        assert result is not None

    def test_cet_bypass_compilation_compatibility(self, test_binary_with_cet):
        """Test bypass against binary compiled with CET."""
        if test_binary_with_cet is None:
            pytest.skip("Unable to compile test binary with CET")

        bypass = CETBypass()

        # Check CET status of compiled binary
        result = bypass._check_pe_cet_flags(test_binary_with_cet)
        assert result is not None

        # Generate targeted bypass
        target_info = {
            'binary_path': test_binary_with_cet,
            'arch': 'x64'
        }
        bypass_result = bypass.bypass_shadow_stack(target_info)
        assert bypass_result is not None

        # Clean up test binary
        try:
            os.remove(test_binary_with_cet)
            os.rmdir(os.path.dirname(test_binary_with_cet))
        except:
            pass
