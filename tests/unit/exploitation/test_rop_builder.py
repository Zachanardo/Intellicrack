"""
Unit tests for ROP Builder with REAL ROP chain construction.
Tests REAL ROP gadget finding and chain building for bypass techniques.
NO MOCKS - ALL TESTS USE REAL BINARIES AND PRODUCE REAL RESULTS.
"""

import pytest
from pathlib import Path

from intellicrack.core.exploitation.rop_builder import ROPBuilder
from tests.base_test import IntellicrackTestBase


class TestROPBuilder(IntellicrackTestBase):
    """Test ROP chain building with REAL binaries and gadgets."""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test with real ROP builder."""
        self.builder = ROPBuilder()
        self.test_dir = Path(__file__).parent.parent.parent / 'fixtures' / 'binaries'
        
        # Real test binaries
        self.test_binary = self.test_dir / 'vulnerable' / 'buffer_overflow_0.exe'
        self.system_dll = Path('C:/Windows/System32/kernel32.dll')
        
    def test_gadget_discovery(self):
        """Test ROP gadget discovery in real binaries."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        gadgets = self.builder.find_gadgets(self.test_binary)
        
        self.assert_real_output(gadgets)
        assert isinstance(gadgets, list)
        assert len(gadgets) > 0
        
        # Validate gadget structure
        for gadget in gadgets[:10]:  # Check first 10
            assert 'address' in gadget
            assert 'instructions' in gadget
            assert 'bytes' in gadget
            assert 'type' in gadget
            
            # Real addresses
            assert gadget['address'] > 0x400000  # Typical base
            assert isinstance(gadget['bytes'], bytes)
            assert len(gadget['instructions']) > 0
            
    def test_common_gadget_patterns(self):
        """Test finding common ROP gadget patterns."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Find specific gadget types
        pop_gadgets = self.builder.find_pop_gadgets(self.test_binary)
        self.assert_real_output(pop_gadgets)
        assert len(pop_gadgets) > 0
        
        # Find ret gadgets
        ret_gadgets = self.builder.find_ret_gadgets(self.test_binary)
        assert len(ret_gadgets) > 0
        
        # Find mov gadgets
        mov_gadgets = self.builder.find_mov_gadgets(self.test_binary)
        assert len(mov_gadgets) > 0
        
        # Verify gadget quality
        for gadget in pop_gadgets[:5]:
            # Should end with ret
            assert gadget['instructions'][-1].startswith('ret')
            
    def test_rop_chain_construction(self):
        """Test building complete ROP chains."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Build DEP bypass chain
        chain = self.builder.build_dep_bypass_chain(
            self.test_binary,
            shellcode_addr=0x10000000,
            shellcode_size=0x1000
        )
        
        self.assert_real_output(chain)
        assert isinstance(chain, list)
        assert len(chain) > 0
        
        # Validate chain structure
        for link in chain:
            assert 'address' in link
            assert 'purpose' in link
            assert 'gadget' in link
            
            # Real addresses
            assert isinstance(link['address'], int)
            assert link['address'] > 0
            
    def test_virtualprotect_chain(self):
        """Test VirtualProtect ROP chain construction."""
        if not self.system_dll.exists():
            pytest.skip("System DLL not found")
            
        # Build VirtualProtect chain
        chain = self.builder.build_virtualprotect_chain(
            binary_path=self.test_binary,
            target_addr=0x10000000,
            size=0x1000,
            protection=0x40  # PAGE_EXECUTE_READWRITE
        )
        
        self.assert_real_output(chain)
        assert len(chain) > 5  # Need several gadgets
        
        # Should include VirtualProtect setup
        purposes = [link['purpose'] for link in chain]
        assert any('VirtualProtect' in p for p in purposes)
        assert any('lpAddress' in p for p in purposes)
        assert any('dwSize' in p for p in purposes)
        
    def test_stack_pivot_gadgets(self):
        """Test stack pivot gadget discovery."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        pivots = self.builder.find_stack_pivots(self.test_binary)
        
        self.assert_real_output(pivots)
        assert isinstance(pivots, list)
        
        # Check for common pivot patterns
        for pivot in pivots:
            instructions = pivot['instructions']
            # xchg esp, eax / mov esp, eax / etc
            assert any(
                'esp' in inst and ('xchg' in inst or 'mov' in inst)
                for inst in instructions
            )
            
    def test_jop_gadgets(self):
        """Test JOP (Jump-Oriented Programming) gadget finding."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        jop_gadgets = self.builder.find_jop_gadgets(self.test_binary)
        
        self.assert_real_output(jop_gadgets)
        
        # JOP gadgets use jumps instead of returns
        for gadget in jop_gadgets[:5]:
            instructions = gadget['instructions']
            # Should have jmp/call but not ret
            assert any('jmp' in inst or 'call' in inst for inst in instructions)
            
    def test_gadget_semantic_analysis(self):
        """Test semantic analysis of gadgets."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        gadgets = self.builder.find_gadgets(self.test_binary, limit=50)
        
        # Analyze gadget semantics
        analyzed = self.builder.analyze_gadget_semantics(gadgets)
        
        self.assert_real_output(analyzed)
        
        for gadget in analyzed:
            assert 'semantic_type' in gadget
            assert 'side_effects' in gadget
            assert 'registers_modified' in gadget
            assert 'stack_delta' in gadget
            
            # Validate analysis
            if gadget['semantic_type'] == 'stack_cleanup':
                assert gadget['stack_delta'] > 0
                
    def test_bad_character_avoidance(self):
        """Test ROP chain construction avoiding bad characters."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        bad_chars = b'\x00\x0a\x0d'
        
        # Build chain avoiding bad characters
        chain = self.builder.build_chain_avoiding_chars(
            self.test_binary,
            goal='exec_shellcode',
            bad_chars=bad_chars
        )
        
        self.assert_real_output(chain)
        
        # Verify no bad characters in addresses
        for link in chain:
            addr_bytes = link['address'].to_bytes(4, 'little')
            for bad in bad_chars:
                assert bytes([bad]) not in addr_bytes
                
    def test_aslr_bypass_info_leak(self):
        """Test ASLR bypass using information leak."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Find gadgets for info leak
        leak_gadgets = self.builder.find_info_leak_gadgets(self.test_binary)
        
        self.assert_real_output(leak_gadgets)
        
        # Should find write/printf type gadgets
        for gadget in leak_gadgets:
            assert any(
                keyword in str(gadget['instructions']).lower()
                for keyword in ['write', 'send', 'printf', 'puts']
            )
            
    def test_full_exploit_chain(self):
        """Test building complete exploit ROP chain."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Build complete exploit chain
        exploit = self.builder.build_full_exploit_chain(
            binary=self.test_binary,
            vulnerability_type='stack_overflow',
            shellcode_size=200,
            target_os='windows'
        )
        
        self.assert_real_output(exploit)
        assert 'chain' in exploit
        assert 'padding' in exploit
        assert 'shellcode_addr' in exploit
        assert 'total_size' in exploit
        
        # Validate complete chain
        chain = exploit['chain']
        assert len(chain) > 0
        assert exploit['total_size'] > 100
        
    def test_automatic_chain_generation(self):
        """Test automatic ROP chain generation."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Auto-generate chain for common goals
        goals = ['disable_dep', 'disable_aslr', 'exec_shellcode']
        
        for goal in goals:
            chain = self.builder.auto_generate_chain(
                self.test_binary,
                goal=goal
            )
            
            self.assert_real_output(chain)
            assert len(chain) > 0
            assert chain[0]['purpose'].lower().startswith(goal.replace('_', ' '))
            
    def test_gadget_quality_scoring(self):
        """Test gadget quality scoring system."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        gadgets = self.builder.find_gadgets(self.test_binary, limit=100)
        
        # Score gadgets
        scored = self.builder.score_gadget_quality(gadgets)
        
        self.assert_real_output(scored)
        
        for gadget in scored:
            assert 'quality_score' in gadget
            assert 0.0 <= gadget['quality_score'] <= 1.0
            assert 'score_factors' in gadget
            
            # High quality gadgets
            if gadget['quality_score'] > 0.8:
                # Should be short and useful
                assert len(gadget['instructions']) <= 3
                
    def test_chain_validation(self):
        """Test ROP chain validation."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Build a chain
        chain = self.builder.build_dep_bypass_chain(
            self.test_binary,
            shellcode_addr=0x10000000,
            shellcode_size=0x1000
        )
        
        # Validate chain
        validation = self.builder.validate_chain(chain, self.test_binary)
        
        self.assert_real_output(validation)
        assert 'valid' in validation
        assert 'issues' in validation
        assert 'suggestions' in validation
        
        # Check validation details
        if not validation['valid']:
            assert len(validation['issues']) > 0
            
    def test_multi_module_rop(self):
        """Test ROP across multiple modules."""
        modules = [self.test_binary]
        if self.system_dll.exists():
            modules.append(self.system_dll)
            
        # Find gadgets across modules
        all_gadgets = self.builder.find_gadgets_multi_module(modules)
        
        self.assert_real_output(all_gadgets)
        
        # Should have gadgets from each module
        module_names = set(g['module'] for g in all_gadgets)
        assert len(module_names) == len(modules)
        
    def test_rop_chain_encoding(self):
        """Test ROP chain encoding for exploits."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Build chain
        chain = self.builder.build_dep_bypass_chain(
            self.test_binary,
            shellcode_addr=0x10000000,
            shellcode_size=0x1000
        )
        
        # Encode for exploit
        encoded = self.builder.encode_chain_for_exploit(
            chain,
            format='python',
            arch='x86'
        )
        
        self.assert_real_output(encoded)
        assert isinstance(encoded, str)
        assert 'struct.pack' in encoded or 'p32' in encoded
        
    def test_gadget_caching(self):
        """Test gadget caching for performance."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # First scan
        import time
        start = time.time()
        gadgets1 = self.builder.find_gadgets(self.test_binary)
        time1 = time.time() - start
        
        # Second scan (should be cached)
        start = time.time()
        gadgets2 = self.builder.find_gadgets(self.test_binary)
        time2 = time.time() - start
        
        # Cache should make it faster
        assert time2 < time1 * 0.5
        assert gadgets1 == gadgets2
        
    def test_conditional_gadgets(self):
        """Test conditional execution gadgets."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Find conditional gadgets
        conditional = self.builder.find_conditional_gadgets(self.test_binary)
        
        self.assert_real_output(conditional)
        
        # Should have jumps/branches
        for gadget in conditional:
            instructions = ' '.join(gadget['instructions'])
            assert any(
                cond in instructions 
                for cond in ['je', 'jne', 'jz', 'jnz', 'ja', 'jb']
            )
            
    def test_write_primitive_chain(self):
        """Test building write-what-where primitive."""
        if not self.test_binary.exists():
            pytest.skip("Test binary not found")
            
        # Build write primitive
        chain = self.builder.build_write_primitive(
            self.test_binary,
            what=0x41414141,
            where=0x10000000
        )
        
        self.assert_real_output(chain)
        assert len(chain) >= 2  # Need setup + write
        
        # Should have mov/store gadgets
        purposes = [link['purpose'] for link in chain]
        assert any('write' in p.lower() or 'store' in p.lower() for p in purposes)