"""
Comprehensive test suite for ActivationBypass engine.
Tests license detection, taint tracking, and bypass capabilities.
"""

import pytest
import tempfile
import os
import struct
from unittest.mock import Mock, patch, MagicMock
from intellicrack.core.licensing.activation_bypass import (
    ActivationBypass,
    LicenseType,
    BypassTechnique,
    LicenseDetector,
    TaintTracker,
    PatchPointDetector,
    CertificateBypass
)


class TestActivationBypassInitialization:
    """Test suite for ActivationBypass initialization and basic functionality"""
    
    def setup_method(self):
        """Setup test environment"""
        self.bypass = ActivationBypass()
    
    def test_initialization(self):
        """Test ActivationBypass initialization"""
        assert self.bypass is not None
        assert hasattr(self.bypass, 'license_detector')
        assert hasattr(self.bypass, 'taint_tracker')
        assert hasattr(self.bypass, 'patch_detector')
        assert hasattr(self.bypass, 'cert_bypass')
    
    def test_license_type_enum(self):
        """Test LicenseType enum values"""
        assert hasattr(LicenseType, 'SERIAL_KEY')
        assert hasattr(LicenseType, 'HARDWARE_ID')
        assert hasattr(LicenseType, 'ONLINE_ACTIVATION')
        assert hasattr(LicenseType, 'CERTIFICATE')
        assert hasattr(LicenseType, 'DONGLE')
        assert hasattr(LicenseType, 'TIME_TRIAL')
    
    def test_bypass_technique_enum(self):
        """Test BypassTechnique enum values"""
        assert hasattr(BypassTechnique, 'PATCH_VALIDATION')
        assert hasattr(BypassTechnique, 'HOOK_APIS')
        assert hasattr(BypassTechnique, 'TAINT_TRACKING')
        assert hasattr(BypassTechnique, 'CERTIFICATE_FORGERY')


class TestLicenseDetector:
    """Test suite for LicenseDetector component"""
    
    def setup_method(self):
        """Setup test environment"""
        self.detector = LicenseDetector()
    
    def test_serial_key_detection(self):
        """Test serial key license detection"""
        # Mock binary with serial key patterns
        mock_binary = b'ENTER-YOUR-SERIAL-KEY-HERE' + b'\x00' * 100
        
        result = self.detector.detect_license_type(mock_binary)
        assert result in [LicenseType.SERIAL_KEY, LicenseType.UNKNOWN]
    
    def test_hardware_id_detection(self):
        """Test hardware ID license detection"""
        # Mock binary with hardware ID patterns
        patterns = [
            b'HARDWARE-ID',
            b'GetVolumeInformation',
            b'GetAdaptersInfo',
            b'cpuid'
        ]
        
        for pattern in patterns:
            mock_binary = pattern + b'\x00' * 100
            result = self.detector.detect_license_type(mock_binary)
            # Should detect hardware-based licensing or be unknown
            assert result in [LicenseType.HARDWARE_ID, LicenseType.UNKNOWN]
    
    def test_online_activation_detection(self):
        """Test online activation detection"""
        # Mock binary with online activation patterns
        patterns = [
            b'activation.server.com',
            b'WinInet.dll',
            b'InternetConnect',
            b'license.verify'
        ]
        
        for pattern in patterns:
            mock_binary = pattern + b'\x00' * 100
            result = self.detector.detect_license_type(mock_binary)
            assert result in [LicenseType.ONLINE_ACTIVATION, LicenseType.UNKNOWN]
    
    def test_certificate_detection(self):
        """Test certificate-based license detection"""
        # Mock binary with certificate patterns
        patterns = [
            b'-----BEGIN CERTIFICATE-----',
            b'X509Certificate',
            b'CertVerifySignature',
            b'.p12',
            b'.pfx'
        ]
        
        for pattern in patterns:
            mock_binary = pattern + b'\x00' * 100
            result = self.detector.detect_license_type(mock_binary)
            assert result in [LicenseType.CERTIFICATE, LicenseType.UNKNOWN]
    
    def test_dongle_detection(self):
        """Test dongle license detection"""
        # Mock binary with dongle patterns
        patterns = [
            b'HASP',
            b'Sentinel',
            b'SafeNet',
            b'dongle',
            b'hardware key'
        ]
        
        for pattern in patterns:
            mock_binary = pattern + b'\x00' * 100
            result = self.detector.detect_license_type(mock_binary)
            assert result in [LicenseType.DONGLE, LicenseType.UNKNOWN]
    
    def test_time_trial_detection(self):
        """Test time trial license detection"""
        # Mock binary with time trial patterns
        patterns = [
            b'trial expired',
            b'GetSystemTime',
            b'FileTimeToSystemTime',
            b'RegQueryValueEx'
        ]
        
        for pattern in patterns:
            mock_binary = pattern + b'\x00' * 100
            result = self.detector.detect_license_type(mock_binary)
            assert result in [LicenseType.TIME_TRIAL, LicenseType.UNKNOWN]


class TestTaintTracker:
    """Test suite for TaintTracker component"""
    
    def setup_method(self):
        """Setup test environment"""
        self.tracker = TaintTracker()
    
    @patch('angr.Project')
    def test_angr_taint_analysis(self, mock_project):
        """Test angr-based taint tracking"""
        mock_proj = MagicMock()
        mock_project.return_value = mock_proj
        
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'MZ\x90\x00' + b'\x00' * 100)
            tmp_file.flush()
            
            try:
                result = self.tracker.trace_license_data_flow(tmp_file.name, 0x401000)
                assert isinstance(result, (list, dict, type(None)))
            finally:
                os.unlink(tmp_file.name)
    
    def test_input_source_identification(self):
        """Test identification of license input sources"""
        mock_sources = [
            {'type': 'registry', 'path': 'HKLM\\Software\\Company\\License'},
            {'type': 'file', 'path': 'license.dat'},
            {'type': 'user_input', 'function': 'GetDlgItemText'}
        ]
        
        for source in mock_sources:
            result = self.tracker.identify_input_source(source)
            assert isinstance(result, bool)
    
    def test_validation_function_tracking(self):
        """Test tracking of license validation functions"""
        mock_addresses = [0x401000, 0x401100, 0x401200]
        
        result = self.tracker.track_validation_functions(mock_addresses)
        assert isinstance(result, list)
    
    def test_data_transformation_analysis(self):
        """Test analysis of license data transformations"""
        mock_transformations = [
            {'operation': 'XOR', 'key': 0x12345678},
            {'operation': 'MD5', 'input': 'license_string'},
            {'operation': 'BASE64', 'encoded': True}
        ]
        
        for transform in mock_transformations:
            result = self.tracker.analyze_transformation(transform)
            assert isinstance(result, dict)


class TestPatchPointDetector:
    """Test suite for PatchPointDetector component"""
    
    def setup_method(self):
        """Setup test environment"""
        self.detector = PatchPointDetector()
    
    def test_validation_function_detection(self):
        """Test detection of license validation functions"""
        # Mock disassembly with validation patterns
        mock_instructions = [
            ('cmp', 'eax', '0'),
            ('jne', 'invalid_license'),
            ('mov', 'eax', '1'),
            ('ret', None)
        ]
        
        result = self.detector.detect_validation_functions(mock_instructions)
        assert isinstance(result, list)
    
    def test_jump_patch_points(self):
        """Test detection of conditional jump patch points"""
        # Mock conditional jumps that could be patched
        mock_jumps = [
            {'address': 0x401000, 'instruction': 'jne', 'target': 0x401100},
            {'address': 0x401050, 'instruction': 'jz', 'target': 0x401200},
            {'address': 0x401070, 'instruction': 'je', 'target': 0x401300}
        ]
        
        for jump in mock_jumps:
            result = self.detector.analyze_jump_target(jump)
            assert isinstance(result, dict)
    
    def test_api_call_patch_points(self):
        """Test detection of API call patch points"""
        # Mock API calls related to licensing
        licensing_apis = [
            'RegQueryValueEx',
            'GetVolumeInformation',
            'CryptVerifySignature',
            'InternetConnect'
        ]
        
        for api in licensing_apis:
            result = self.detector.detect_api_patch_point(api, 0x401000)
            assert isinstance(result, dict)
    
    def test_return_value_patch_points(self):
        """Test detection of return value patch points"""
        # Mock function returns that could be patched
        mock_returns = [
            {'address': 0x401000, 'value': 0, 'expected': 1},
            {'address': 0x401010, 'value': -1, 'expected': 0}
        ]
        
        for ret in mock_returns:
            result = self.detector.analyze_return_value(ret['address'], ret['value'])
            assert isinstance(result, bool)


class TestCertificateBypass:
    """Test suite for CertificateBypass component"""
    
    def setup_method(self):
        """Setup test environment"""
        self.cert_bypass = CertificateBypass()
    
    def test_certificate_detection(self):
        """Test detection of embedded certificates"""
        # Mock certificate data
        cert_patterns = [
            b'-----BEGIN CERTIFICATE-----',
            b'0\x82',  # DER encoded certificate start
            b'MII',    # Base64 encoded certificate start
        ]
        
        for pattern in cert_patterns:
            mock_data = pattern + b'\x00' * 100
            result = self.cert_bypass.detect_certificates(mock_data)
            assert isinstance(result, list)
    
    @patch('cryptography.x509.load_pem_x509_certificate')
    def test_certificate_parsing(self, mock_load_cert):
        """Test certificate parsing capabilities"""
        mock_cert = MagicMock()
        mock_cert.subject = "CN=Test Certificate"
        mock_load_cert.return_value = mock_cert
        
        cert_data = b'-----BEGIN CERTIFICATE-----\nMIIC...\n-----END CERTIFICATE-----'
        result = self.cert_bypass.parse_certificate(cert_data)
        assert isinstance(result, (dict, type(None)))
    
    def test_signature_verification_bypass(self):
        """Test signature verification bypass"""
        mock_signature = b'\x00' * 128  # Mock signature
        mock_data = b'test data to verify'
        
        result = self.cert_bypass.bypass_signature_verification(mock_data, mock_signature)
        assert isinstance(result, bool)
    
    def test_certificate_validation_bypass(self):
        """Test certificate validation bypass"""
        mock_cert_data = {
            'subject': 'CN=Test',
            'issuer': 'CN=CA',
            'serial_number': 12345,
            'not_before': '2023-01-01',
            'not_after': '2025-01-01'
        }
        
        result = self.cert_bypass.bypass_certificate_validation(mock_cert_data)
        assert isinstance(result, bool)


class TestFridaIntegration:
    """Test suite for Frida-based dynamic bypass"""
    
    def setup_method(self):
        """Setup test environment"""
        self.bypass = ActivationBypass()
    
    @patch('frida.attach')
    def test_frida_hook_installation(self, mock_attach):
        """Test Frida hook installation for license bypass"""
        mock_session = MagicMock()
        mock_attach.return_value = mock_session
        
        result = self.bypass.install_frida_hooks(process_id=1234)
        assert isinstance(result, (bool, type(None)))
    
    def test_license_api_hooking(self):
        """Test hooking of license-related APIs"""
        license_apis = [
            'RegQueryValueEx',
            'CryptVerifySignature',
            'InternetConnect',
            'GetVolumeInformation'
        ]
        
        for api in license_apis:
            script = self.bypass.generate_api_hook_script(api)
            assert isinstance(script, str)
            assert api in script
    
    def test_return_value_modification(self):
        """Test runtime return value modification"""
        mock_function = "ValidateLicense"
        mock_original_return = 0  # Failed validation
        mock_desired_return = 1   # Successful validation
        
        script = self.bypass.generate_return_modifier_script(
            mock_function, mock_original_return, mock_desired_return
        )
        assert isinstance(script, str)
        assert mock_function in script


class TestBypassWorkflow:
    """Test suite for complete bypass workflow"""
    
    def setup_method(self):
        """Setup test environment"""
        self.bypass = ActivationBypass()
    
    def test_complete_bypass_workflow(self):
        """Test complete license bypass workflow"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create test binary with license patterns
            test_data = (b'MZ\x90\x00' + b'SERIAL-KEY-VALIDATION' + 
                        b'RegQueryValueEx' + b'\x00' * 500)
            tmp_file.write(test_data)
            tmp_file.flush()
            
            try:
                result = self.bypass.bypass_license_protection(tmp_file.name)
                assert isinstance(result, dict)
                assert 'success' in result
                assert 'license_type' in result
                assert 'bypass_method' in result
            finally:
                os.unlink(tmp_file.name)
    
    def test_method_selection(self):
        """Test bypass method selection based on license type"""
        test_cases = [
            (LicenseType.SERIAL_KEY, BypassTechnique.PATCH_VALIDATION),
            (LicenseType.ONLINE_ACTIVATION, BypassTechnique.HOOK_APIS),
            (LicenseType.CERTIFICATE, BypassTechnique.CERTIFICATE_FORGERY),
            (LicenseType.HARDWARE_ID, BypassTechnique.TAINT_TRACKING)
        ]
        
        for license_type, expected_technique in test_cases:
            result = self.bypass.select_bypass_method(license_type)
            assert result in [expected_technique, BypassTechnique.HOOK_APIS]  # Fallback allowed
    
    def test_multi_stage_bypass(self):
        """Test multi-stage bypass for complex protections"""
        complex_protection = {
            'license_types': [LicenseType.SERIAL_KEY, LicenseType.HARDWARE_ID],
            'validation_functions': [0x401000, 0x401100, 0x401200],
            'encryption': True,
            'obfuscation': True
        }
        
        result = self.bypass.apply_multi_stage_bypass(complex_protection)
        assert isinstance(result, dict)
        assert 'stages_completed' in result
        assert 'success_rate' in result


class TestBypassValidation:
    """Test suite for bypass validation and verification"""
    
    def setup_method(self):
        """Setup test environment"""
        self.bypass = ActivationBypass()
    
    def test_bypass_effectiveness_validation(self):
        """Test validation of bypass effectiveness"""
        mock_bypass_result = {
            'success': True,
            'license_type': LicenseType.SERIAL_KEY,
            'bypass_method': BypassTechnique.PATCH_VALIDATION,
            'patches_applied': 3,
            'validation_functions_bypassed': 2
        }
        
        result = self.bypass.validate_bypass_effectiveness(mock_bypass_result)
        assert isinstance(result, dict)
        assert 'effectiveness_score' in result
        assert 'remaining_protections' in result
    
    def test_functional_verification(self):
        """Test functional verification of bypassed application"""
        mock_app_path = "test_app.exe"
        
        # Should not crash with invalid path
        result = self.bypass.verify_bypassed_functionality(mock_app_path)
        assert isinstance(result, bool)
    
    def test_stealth_validation(self):
        """Test validation of bypass stealth"""
        mock_bypass_data = {
            'patches_visible': False,
            'api_hooks_detectable': False,
            'timing_consistent': True,
            'memory_signatures_hidden': True
        }
        
        result = self.bypass.validate_bypass_stealth(mock_bypass_data)
        assert isinstance(result, dict)
        assert 'stealth_score' in result


class TestErrorHandlingAndRobustness:
    """Test suite for error handling and robustness"""
    
    def setup_method(self):
        """Setup test environment"""
        self.bypass = ActivationBypass()
    
    def test_invalid_binary_handling(self):
        """Test handling of invalid binary files"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'Invalid binary data')
            tmp_file.flush()
            
            try:
                result = self.bypass.bypass_license_protection(tmp_file.name)
                assert isinstance(result, dict)
                assert result['success'] is False
            finally:
                os.unlink(tmp_file.name)
    
    def test_permission_error_handling(self):
        """Test handling of permission errors"""
        # Try to access system process
        result = self.bypass.install_frida_hooks(process_id=4)  # System process
        # Should not crash, may return False
        assert isinstance(result, (bool, type(None)))
    
    def test_complex_protection_fallback(self):
        """Test fallback handling for complex protections"""
        complex_case = {
            'license_type': LicenseType.UNKNOWN,
            'encryption': True,
            'virtualization': True,
            'anti_debug': True
        }
        
        result = self.bypass.handle_complex_protection(complex_case)
        assert isinstance(result, dict)
        assert 'fallback_applied' in result
    
    def test_resource_cleanup(self):
        """Test proper resource cleanup"""
        bypass = ActivationBypass()
        
        # Simulate resource allocation
        bypass.allocate_resources()
        
        # Cleanup should not crash
        bypass.cleanup_resources()
        assert True


if __name__ == "__main__":
    pytest.main([__file__])