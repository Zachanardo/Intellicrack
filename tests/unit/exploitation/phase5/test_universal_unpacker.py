"""
Comprehensive test suite for UniversalUnpacker engine.
Tests VMProtect, Themida, and Denuvo unpacking capabilities.
"""

import pytest
import os
import tempfile
import struct
from unittest.mock import Mock, patch, MagicMock
from intellicrack.core.exploitation.universal_unpacker import (
    UniversalUnpacker,
    PackerType,
    UnpackingMethod,
    PackerSignature,
    UnpackingResult
)


class TestPackerDetection:
    """Test suite for packer detection capabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    def test_initialization(self):
        """Test UniversalUnpacker initialization"""
        assert self.unpacker is not None
        assert hasattr(self.unpacker, 'supported_packers')
        assert hasattr(self.unpacker, 'frida_session')
        assert hasattr(self.unpacker, 'angr_project')
    
    def test_packer_type_enum(self):
        """Test PackerType enum values"""
        assert hasattr(PackerType, 'VMPROTECT')
        assert hasattr(PackerType, 'THEMIDA')
        assert hasattr(PackerType, 'DENUVO')
        assert hasattr(PackerType, 'UPX')
        assert hasattr(PackerType, 'UNKNOWN')
    
    def test_unpacking_method_enum(self):
        """Test UnpackingMethod enum values"""
        assert hasattr(UnpackingMethod, 'DYNAMIC_ANALYSIS')
        assert hasattr(UnpackingMethod, 'STATIC_RECONSTRUCTION')
        assert hasattr(UnpackingMethod, 'MEMORY_DUMPING')
        assert hasattr(UnpackingMethod, 'HYBRID')
    
    def test_vmprotect_signature_detection(self):
        """Test VMProtect signature detection"""
        # Create mock PE with VMProtect-like characteristics
        vmprotect_signatures = [
            b'.vmp0',
            b'.vmp1',
            b'VMProtect',
            b'\x68\x00\x00\x00\x00\x8B\x04\x24',  # Common VMProtect stub
        ]
        
        for signature in vmprotect_signatures:
            result = self.unpacker._detect_packer_signature(signature + b'\x00' * 100)
            assert result == PackerType.VMPROTECT or result == PackerType.UNKNOWN
    
    def test_themida_signature_detection(self):
        """Test Themida signature detection"""
        themida_signatures = [
            b'.themida',
            b'Themida',
            b'WinLicense',
            b'\x8B\x85\x00\x00\x00\x00\x03\x85\x00\x00\x00\x00',  # Themida pattern
        ]
        
        for signature in themida_signatures:
            result = self.unpacker._detect_packer_signature(signature + b'\x00' * 100)
            assert result == PackerType.THEMIDA or result == PackerType.UNKNOWN
    
    def test_denuvo_signature_detection(self):
        """Test Denuvo signature detection"""
        denuvo_signatures = [
            b'denuvo',
            b'DENUVO',
            b'.denuvo',
            b'Denuvo Anti-Tamper',
        ]
        
        for signature in denuvo_signatures:
            result = self.unpacker._detect_packer_signature(signature + b'\x00' * 100)
            assert result == PackerType.DENUVO or result == PackerType.UNKNOWN
    
    def test_unknown_packer_handling(self):
        """Test handling of unknown packer signatures"""
        unknown_data = b'Random binary data with no known signatures'
        result = self.unpacker._detect_packer_signature(unknown_data)
        assert result == PackerType.UNKNOWN


class TestUnpackingStrategies:
    """Test suite for unpacking strategy selection and execution"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    def test_strategy_selection_vmprotect(self):
        """Test strategy selection for VMProtect"""
        strategy = self.unpacker._select_unpacking_strategy(PackerType.VMPROTECT)
        assert strategy in [UnpackingMethod.DYNAMIC_ANALYSIS, UnpackingMethod.HYBRID]
    
    def test_strategy_selection_themida(self):
        """Test strategy selection for Themida"""
        strategy = self.unpacker._select_unpacking_strategy(PackerType.THEMIDA)
        assert strategy in [UnpackingMethod.DYNAMIC_ANALYSIS, UnpackingMethod.HYBRID]
    
    def test_strategy_selection_denuvo(self):
        """Test strategy selection for Denuvo"""
        strategy = self.unpacker._select_unpacking_strategy(PackerType.DENUVO)
        assert strategy in [UnpackingMethod.MEMORY_DUMPING, UnpackingMethod.HYBRID]
    
    def test_strategy_selection_unknown(self):
        """Test strategy selection for unknown packers"""
        strategy = self.unpacker._select_unpacking_strategy(PackerType.UNKNOWN)
        assert strategy == UnpackingMethod.DYNAMIC_ANALYSIS
    
    @patch('frida.spawn')
    def test_dynamic_analysis_setup(self, mock_spawn):
        """Test dynamic analysis environment setup"""
        mock_spawn.return_value = 1234  # Mock PID
        
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'MZ\x90\x00' + b'\x00' * 100)  # Minimal PE header
            tmp_file.flush()
            
            try:
                result = self.unpacker._setup_dynamic_analysis(tmp_file.name)
                assert isinstance(result, dict)
                assert 'pid' in result or 'error' in result
            finally:
                os.unlink(tmp_file.name)
    
    def test_memory_dump_validation(self):
        """Test memory dump validation"""
        # Create mock memory dump
        mock_dump = b'MZ\x90\x00' + b'\x00' * 1000  # PE header + data
        
        result = self.unpacker._validate_memory_dump(mock_dump)
        assert isinstance(result, bool)
    
    def test_entry_point_detection(self):
        """Test original entry point detection"""
        # Mock unpacked data with PE structure
        mock_data = struct.pack('<H', 0x5A4D)  # MZ signature
        mock_data += b'\x00' * 58
        mock_data += struct.pack('<L', 0x80)  # PE offset
        mock_data += b'\x00' * (0x80 - len(mock_data))
        mock_data += b'PE\x00\x00'  # PE signature
        
        result = self.unpacker._detect_original_entry_point(mock_data)
        assert isinstance(result, (int, type(None)))


class TestFridaIntegration:
    """Test suite for Frida-based dynamic unpacking"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    @patch('frida.attach')
    def test_frida_script_injection(self, mock_attach):
        """Test Frida script injection for unpacking"""
        mock_session = MagicMock()
        mock_attach.return_value = mock_session
        
        script_content = self.unpacker._generate_frida_unpacking_script(PackerType.VMPROTECT)
        assert isinstance(script_content, str)
        assert 'console.log' in script_content
        assert 'Module.enumerateRanges' in script_content
    
    def test_vmprotect_frida_script(self):
        """Test VMProtect-specific Frida script generation"""
        script = self.unpacker._generate_frida_unpacking_script(PackerType.VMPROTECT)
        assert 'VMProtect' in script or 'vm_' in script.lower()
        assert 'Memory.protect' in script
    
    def test_themida_frida_script(self):
        """Test Themida-specific Frida script generation"""
        script = self.unpacker._generate_frida_unpacking_script(PackerType.THEMIDA)
        assert 'Themida' in script or 'themida' in script.lower()
        assert 'Interceptor.attach' in script
    
    def test_denuvo_frida_script(self):
        """Test Denuvo-specific Frida script generation"""
        script = self.unpacker._generate_frida_unpacking_script(PackerType.DENUVO)
        assert 'Denuvo' in script or 'denuvo' in script.lower()
        assert 'Memory.scan' in script


class TestAngrIntegration:
    """Test suite for angr-based static analysis"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    def test_angr_project_creation(self):
        """Test angr project creation for analysis"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create minimal PE file
            pe_header = b'MZ\x90\x00' + b'\x00' * 58 + struct.pack('<L', 0x80)
            pe_header += b'\x00' * (0x80 - len(pe_header))
            pe_header += b'PE\x00\x00'
            tmp_file.write(pe_header + b'\x00' * 500)
            tmp_file.flush()
            
            try:
                project = self.unpacker._create_angr_project(tmp_file.name)
                assert project is not None or isinstance(project, type(None))
            finally:
                os.unlink(tmp_file.name)
    
    def test_control_flow_analysis(self):
        """Test control flow analysis capabilities"""
        # Mock angr project
        mock_project = MagicMock()
        mock_project.factory.block.return_value.instructions = 10
        
        result = self.unpacker._analyze_control_flow(mock_project, 0x401000)
        assert isinstance(result, dict)
    
    def test_packer_stub_detection(self):
        """Test packer stub detection using static analysis"""
        mock_instructions = [
            ('push', 0x401000),
            ('call', 0x401010),
            ('jmp', 0x401020),
        ]
        
        result = self.unpacker._detect_packer_stub(mock_instructions)
        assert isinstance(result, bool)


class TestUnpackingResults:
    """Test suite for unpacking results and validation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    def test_unpacking_result_structure(self):
        """Test UnpackingResult data structure"""
        result = UnpackingResult(
            success=True,
            packer_type=PackerType.VMPROTECT,
            method=UnpackingMethod.DYNAMIC_ANALYSIS,
            unpacked_data=b'test data',
            entry_point=0x401000,
            metadata={'test': 'value'}
        )
        
        assert result.success is True
        assert result.packer_type == PackerType.VMPROTECT
        assert result.method == UnpackingMethod.DYNAMIC_ANALYSIS
        assert result.unpacked_data == b'test data'
        assert result.entry_point == 0x401000
        assert result.metadata == {'test': 'value'}
    
    def test_result_validation(self):
        """Test unpacking result validation"""
        valid_result = UnpackingResult(
            success=True,
            packer_type=PackerType.THEMIDA,
            method=UnpackingMethod.MEMORY_DUMPING,
            unpacked_data=b'MZ\x90\x00' + b'\x00' * 100,
            entry_point=0x401000
        )
        
        validation = self.unpacker._validate_unpacking_result(valid_result)
        assert isinstance(validation, bool)
    
    def test_metadata_extraction(self):
        """Test metadata extraction from unpacked binaries"""
        mock_data = b'MZ\x90\x00' + b'\x00' * 200
        
        metadata = self.unpacker._extract_metadata(mock_data)
        assert isinstance(metadata, dict)
        assert 'file_size' in metadata
        assert 'pe_valid' in metadata


class TestUnpackingIntegration:
    """Integration tests for complete unpacking workflow"""
    
    def setup_method(self):
        """Setup test environment"""
        self.unpacker = UniversalUnpacker()
    
    def test_complete_unpacking_workflow(self):
        """Test complete unpacking workflow"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create test binary with minimal PE structure
            test_data = b'MZ\x90\x00' + b'VMProtect' + b'\x00' * 500
            tmp_file.write(test_data)
            tmp_file.flush()
            
            try:
                result = self.unpacker.unpack_binary(tmp_file.name)
                assert isinstance(result, UnpackingResult)
                assert hasattr(result, 'success')
                assert hasattr(result, 'packer_type')
            finally:
                os.unlink(tmp_file.name)
    
    def test_error_handling_robustness(self):
        """Test error handling for invalid inputs"""
        # Test with non-existent file
        result = self.unpacker.unpack_binary("non_existent_file.exe")
        assert isinstance(result, UnpackingResult)
        assert result.success is False
        
        # Test with empty file
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'')
            tmp_file.flush()
            
            try:
                result = self.unpacker.unpack_binary(tmp_file.name)
                assert isinstance(result, UnpackingResult)
                assert result.success is False
            finally:
                os.unlink(tmp_file.name)
    
    def test_multiple_packer_support(self):
        """Test support for multiple packer types"""
        test_cases = [
            (b'VMProtect', PackerType.VMPROTECT),
            (b'Themida', PackerType.THEMIDA),
            (b'denuvo', PackerType.DENUVO),
            (b'unknown_packer', PackerType.UNKNOWN),
        ]
        
        for signature, expected_type in test_cases:
            detected_type = self.unpacker._detect_packer_signature(signature + b'\x00' * 100)
            assert detected_type == expected_type or detected_type == PackerType.UNKNOWN


if __name__ == "__main__":
    pytest.main([__file__])