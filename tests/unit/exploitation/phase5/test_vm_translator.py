"""
Comprehensive test suite for VMTranslator devirtualization engine.
Tests VMProtect and Themida VM code translation capabilities.
"""

import pytest
import struct
import tempfile
import os
from unittest.mock import Mock, patch, MagicMock
from intellicrack.core.devirtualization.vm_translator import (
    VMTranslator,
    VMDetector,
    VMHandlerDatabase,
    VMArchitecture,
    VMHandlerType,
    TranslationResult
)


class TestVMTranslatorInitialization:
    """Test suite for VMTranslator initialization and basic functionality"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_initialization(self):
        """Test VMTranslator initialization"""
        assert self.translator is not None
        assert hasattr(self.translator, 'vm_detector')
        assert hasattr(self.translator, 'handler_database')
        assert hasattr(self.translator, 'capstone_engine')
        assert hasattr(self.translator, 'keystone_engine')
    
    def test_vm_architecture_enum(self):
        """Test VMArchitecture enum values"""
        assert hasattr(VMArchitecture, 'X86')
        assert hasattr(VMArchitecture, 'X64')
        assert hasattr(VMArchitecture, 'ARM')
        assert hasattr(VMArchitecture, 'MIPS')
    
    def test_vm_handler_type_enum(self):
        """Test VMHandlerType enum values"""
        assert hasattr(VMHandlerType, 'ARITHMETIC')
        assert hasattr(VMHandlerType, 'LOGICAL')
        assert hasattr(VMHandlerType, 'MEMORY')
        assert hasattr(VMHandlerType, 'CONTROL_FLOW')
        assert hasattr(VMHandlerType, 'STACK')
        assert hasattr(VMHandlerType, 'REGISTER')
    
    def test_translation_result_structure(self):
        """Test TranslationResult data structure"""
        result = TranslationResult(
            success=True,
            vm_type="VMProtect",
            architecture=VMArchitecture.X64,
            original_size=1000,
            translated_size=800,
            translated_code=b'\x48\x31\xc0',  # xor rax, rax
            handler_count=25,
            translation_ratio=0.8
        )
        
        assert result.success is True
        assert result.vm_type == "VMProtect"
        assert result.architecture == VMArchitecture.X64
        assert result.original_size == 1000
        assert result.translated_size == 800
        assert result.translated_code == b'\x48\x31\xc0'
        assert result.handler_count == 25
        assert result.translation_ratio == 0.8


class TestVMDetector:
    """Test suite for VM detection capabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.detector = VMDetector()
    
    def test_vmprotect_detection(self):
        """Test VMProtect detection"""
        # VMProtect signatures and patterns
        vmprotect_patterns = [
            b'.vmp0',
            b'.vmp1',
            b'VMProtect',
            b'\x55\x8B\xEC\x83\xEC\x04\x53\x56\x57',  # Common VMProtect prolog
            b'\x68\x00\x00\x00\x00\x8B\x04\x24'        # VMProtect stub
        ]
        
        for pattern in vmprotect_patterns:
            mock_binary = pattern + b'\x00' * 200
            result = self.detector.detect_vm_type(mock_binary)
            assert result in ["VMProtect", "Unknown"]
    
    def test_themida_detection(self):
        """Test Themida detection"""
        # Themida signatures and patterns
        themida_patterns = [
            b'.themida',
            b'Themida',
            b'WinLicense',
            b'\x8B\x85\x00\x00\x00\x00\x03\x85\x00\x00\x00\x00',  # Themida pattern
            b'\x55\x8B\xEC\x81\xEC\x00\x00\x00\x00\x53\x56\x57'   # Themida entry
        ]
        
        for pattern in themida_patterns:
            mock_binary = pattern + b'\x00' * 200
            result = self.detector.detect_vm_type(mock_binary)
            assert result in ["Themida", "Unknown"]
    
    def test_vm_entry_point_detection(self):
        """Test VM entry point detection"""
        # Mock VM entry with dispatcher characteristics
        mock_vm_entry = struct.pack('<L', 0x401000)  # VM entry address
        
        result = self.detector.detect_vm_entry_point(mock_vm_entry, 0x400000)
        assert isinstance(result, (int, type(None)))
    
    def test_vm_dispatcher_detection(self):
        """Test VM dispatcher detection"""
        # Mock dispatcher with characteristic patterns
        dispatcher_patterns = [
            b'\xFF\x24\x85',  # jmp dword ptr [eax*4+offset] - dispatcher table
            b'\x8B\x04\x85',  # mov eax, dword ptr [eax*4+offset]
            b'\xFF\xE0',      # jmp eax
        ]
        
        for pattern in dispatcher_patterns:
            result = self.detector.detect_vm_dispatcher(pattern + b'\x00' * 50)
            assert isinstance(result, bool)
    
    def test_vm_handler_table_detection(self):
        """Test VM handler table detection"""
        # Mock handler table with function pointers
        handler_table = struct.pack('<LLLL', 0x401000, 0x401100, 0x401200, 0x401300)
        
        result = self.detector.detect_handler_table(handler_table, 0x400000)
        assert isinstance(result, (list, type(None)))


class TestVMHandlerDatabase:
    """Test suite for VM handler database functionality"""
    
    def setup_method(self):
        """Setup test environment"""
        self.database = VMHandlerDatabase()
    
    def test_handler_signature_loading(self):
        """Test loading of VM handler signatures"""
        result = self.database.load_handler_signatures("VMProtect")
        assert isinstance(result, bool)
    
    def test_handler_classification(self):
        """Test VM handler classification"""
        # Mock handler with arithmetic operations
        arithmetic_handler = b'\x01\xC3\xC3'  # add ebx, eax; ret
        
        result = self.database.classify_handler(arithmetic_handler)
        assert result in [VMHandlerType.ARITHMETIC, VMHandlerType.LOGICAL, None]
    
    def test_vmprotect_handlers(self):
        """Test VMProtect-specific handler recognition"""
        # Common VMProtect handler patterns
        vmprotect_handlers = [
            {'pattern': b'\x8B\x45\x00\x01\x45\x04', 'type': VMHandlerType.ARITHMETIC},
            {'pattern': b'\x8B\x45\x00\x23\x45\x04', 'type': VMHandlerType.LOGICAL},
            {'pattern': b'\x8B\x45\x00\x8B\x00', 'type': VMHandlerType.MEMORY},
        ]
        
        for handler in vmprotect_handlers:
            result = self.database.match_vmprotect_handler(handler['pattern'])
            assert isinstance(result, (dict, type(None)))
    
    def test_themida_handlers(self):
        """Test Themida-specific handler recognition"""
        # Common Themida handler patterns
        themida_handlers = [
            {'pattern': b'\x8B\x44\x24\x04\x03\x44\x24\x08', 'type': VMHandlerType.ARITHMETIC},
            {'pattern': b'\x8B\x44\x24\x04\x33\x44\x24\x08', 'type': VMHandlerType.LOGICAL},
            {'pattern': b'\x8B\x44\x24\x04\x50\xFF\x74\x24\x0C', 'type': VMHandlerType.STACK},
        ]
        
        for handler in themida_handlers:
            result = self.database.match_themida_handler(handler['pattern'])
            assert isinstance(result, (dict, type(None)))
    
    def test_handler_database_update(self):
        """Test dynamic handler database updates"""
        new_handler = {
            'pattern': b'\x90\x90\x90',  # nop sequence
            'type': VMHandlerType.CONTROL_FLOW,
            'vm_type': 'VMProtect',
            'description': 'Test handler'
        }
        
        result = self.database.add_handler_signature(new_handler)
        assert isinstance(result, bool)


class TestVMCodeAnalysis:
    """Test suite for VM code analysis capabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_vm_bytecode_extraction(self):
        """Test extraction of VM bytecode from binary"""
        # Mock VM section with bytecode
        mock_vm_code = b'\x00\x01\x02\x03\x04\x05' * 20  # Mock VM opcodes
        
        result = self.translator.extract_vm_bytecode(mock_vm_code, 0x401000)
        assert isinstance(result, (bytes, type(None)))
    
    def test_vm_opcode_analysis(self):
        """Test VM opcode analysis"""
        # Mock VM opcodes
        vm_opcodes = [0x00, 0x01, 0x02, 0x03, 0x04]
        
        result = self.translator.analyze_vm_opcodes(vm_opcodes)
        assert isinstance(result, list)
    
    def test_vm_context_analysis(self):
        """Test VM context and stack analysis"""
        # Mock VM context structure
        vm_context = {
            'vm_stack_ptr': 0x500000,
            'vm_registers': {'vEAX': 0, 'vEBX': 0, 'vECX': 0},
            'vm_flags': 0x202
        }
        
        result = self.translator.analyze_vm_context(vm_context)
        assert isinstance(result, dict)
    
    def test_control_flow_reconstruction(self):
        """Test VM control flow reconstruction"""
        # Mock VM control flow data
        mock_flow = [
            {'address': 0x401000, 'type': 'basic_block'},
            {'address': 0x401010, 'type': 'conditional_jump'},
            {'address': 0x401020, 'type': 'basic_block'}
        ]
        
        result = self.translator.reconstruct_control_flow(mock_flow)
        assert isinstance(result, (list, dict))


class TestVMToNativeTranslation:
    """Test suite for VM to native code translation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_arithmetic_handler_translation(self):
        """Test translation of arithmetic VM handlers"""
        # Mock arithmetic VM handler (ADD operation)
        vm_handler = {
            'type': VMHandlerType.ARITHMETIC,
            'operation': 'ADD',
            'operands': ['vEAX', 'vEBX'],
            'result': 'vEAX'
        }
        
        result = self.translator.translate_arithmetic_handler(vm_handler)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_logical_handler_translation(self):
        """Test translation of logical VM handlers"""
        # Mock logical VM handler (XOR operation)
        vm_handler = {
            'type': VMHandlerType.LOGICAL,
            'operation': 'XOR',
            'operands': ['vEAX', 'vEBX'],
            'result': 'vEAX'
        }
        
        result = self.translator.translate_logical_handler(vm_handler)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_memory_handler_translation(self):
        """Test translation of memory VM handlers"""
        # Mock memory VM handler (LOAD operation)
        vm_handler = {
            'type': VMHandlerType.MEMORY,
            'operation': 'LOAD',
            'address': 'vEBX',
            'destination': 'vEAX',
            'size': 4
        }
        
        result = self.translator.translate_memory_handler(vm_handler)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_control_flow_handler_translation(self):
        """Test translation of control flow VM handlers"""
        # Mock control flow VM handler (JMP operation)
        vm_handler = {
            'type': VMHandlerType.CONTROL_FLOW,
            'operation': 'JMP',
            'target': 0x401100,
            'condition': None
        }
        
        result = self.translator.translate_control_flow_handler(vm_handler)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_stack_handler_translation(self):
        """Test translation of stack VM handlers"""
        # Mock stack VM handler (PUSH operation)
        vm_handler = {
            'type': VMHandlerType.STACK,
            'operation': 'PUSH',
            'operand': 'vEAX'
        }
        
        result = self.translator.translate_stack_handler(vm_handler)
        assert isinstance(result, (bytes, str, type(None)))


class TestArchitectureSpecific:
    """Test suite for architecture-specific translation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_x86_translation(self):
        """Test x86-specific translation"""
        self.translator.set_target_architecture(VMArchitecture.X86)
        
        vm_instruction = {
            'operation': 'MOV',
            'destination': 'vEAX',
            'source': 'vEBX'
        }
        
        result = self.translator.translate_to_x86(vm_instruction)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_x64_translation(self):
        """Test x64-specific translation"""
        self.translator.set_target_architecture(VMArchitecture.X64)
        
        vm_instruction = {
            'operation': 'MOV',
            'destination': 'vRAX',
            'source': 'vRBX'
        }
        
        result = self.translator.translate_to_x64(vm_instruction)
        assert isinstance(result, (bytes, str, type(None)))
    
    def test_register_mapping(self):
        """Test VM register to native register mapping"""
        # Test x86 register mapping
        vm_registers = ['vEAX', 'vEBX', 'vECX', 'vEDX']
        x86_mapping = self.translator.map_vm_registers_x86(vm_registers)
        assert isinstance(x86_mapping, dict)
        
        # Test x64 register mapping
        vm_registers_64 = ['vRAX', 'vRBX', 'vRCX', 'vRDX']
        x64_mapping = self.translator.map_vm_registers_x64(vm_registers_64)
        assert isinstance(x64_mapping, dict)


class TestTranslationOptimization:
    """Test suite for translation optimization"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_dead_code_elimination(self):
        """Test dead code elimination in translated output"""
        # Mock translated code with dead instructions
        mock_code = [
            {'instruction': 'mov eax, 0'},
            {'instruction': 'mov eax, 1'},  # Dead instruction
            {'instruction': 'ret'}
        ]
        
        result = self.translator.eliminate_dead_code(mock_code)
        assert isinstance(result, list)
        assert len(result) <= len(mock_code)
    
    def test_instruction_combining(self):
        """Test instruction combining optimization"""
        # Mock code with combinable instructions
        mock_code = [
            {'instruction': 'push eax'},
            {'instruction': 'pop ebx'},
            {'instruction': 'nop'}
        ]
        
        result = self.translator.combine_instructions(mock_code)
        assert isinstance(result, list)
    
    def test_register_allocation(self):
        """Test register allocation optimization"""
        # Mock VM register usage
        vm_register_usage = {
            'vEAX': ['read', 'write'],
            'vEBX': ['read'],
            'vECX': ['write']
        }
        
        result = self.translator.optimize_register_allocation(vm_register_usage)
        assert isinstance(result, dict)


class TestTranslationValidation:
    """Test suite for translation validation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_semantic_equivalence(self):
        """Test semantic equivalence between VM and native code"""
        vm_code = [
            {'operation': 'LOAD', 'address': 0x1000, 'destination': 'vEAX'},
            {'operation': 'ADD', 'operands': ['vEAX', 1], 'result': 'vEAX'},
            {'operation': 'STORE', 'source': 'vEAX', 'address': 0x1000}
        ]
        
        native_code = b'\x8B\x05\x00\x10\x00\x00\x83\xC0\x01\xA3\x00\x10\x00\x00'
        
        result = self.translator.validate_semantic_equivalence(vm_code, native_code)
        assert isinstance(result, bool)
    
    def test_control_flow_validation(self):
        """Test control flow validation"""
        vm_control_flow = [
            {'block': 1, 'successors': [2, 3]},
            {'block': 2, 'successors': [4]},
            {'block': 3, 'successors': [4]},
            {'block': 4, 'successors': []}
        ]
        
        result = self.translator.validate_control_flow(vm_control_flow)
        assert isinstance(result, bool)
    
    def test_memory_layout_validation(self):
        """Test memory layout validation"""
        vm_memory_layout = {
            'stack_base': 0x500000,
            'heap_base': 0x600000,
            'code_base': 0x401000
        }
        
        result = self.translator.validate_memory_layout(vm_memory_layout)
        assert isinstance(result, bool)


class TestCompleteTranslationWorkflow:
    """Test suite for complete translation workflow"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_vmprotect_translation_workflow(self):
        """Test complete VMProtect translation workflow"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create test binary with VMProtect-like structure
            test_data = (b'MZ\x90\x00' + b'.vmp0' + b'VMProtect' + 
                        b'\x55\x8B\xEC\x83\xEC\x04' + b'\x00' * 500)
            tmp_file.write(test_data)
            tmp_file.flush()
            
            try:
                result = self.translator.translate_vm_code(tmp_file.name, 0x401000, 0x1000)
                assert isinstance(result, TranslationResult)
                assert hasattr(result, 'success')
                assert hasattr(result, 'vm_type')
            finally:
                os.unlink(tmp_file.name)
    
    def test_themida_translation_workflow(self):
        """Test complete Themida translation workflow"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create test binary with Themida-like structure
            test_data = (b'MZ\x90\x00' + b'.themida' + b'Themida' + 
                        b'\x8B\x85\x00\x00\x00\x00' + b'\x00' * 500)
            tmp_file.write(test_data)
            tmp_file.flush()
            
            try:
                result = self.translator.translate_vm_code(tmp_file.name, 0x401000, 0x1000)
                assert isinstance(result, TranslationResult)
                assert hasattr(result, 'success')
                assert hasattr(result, 'vm_type')
            finally:
                os.unlink(tmp_file.name)
    
    def test_unknown_vm_handling(self):
        """Test handling of unknown VM types"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            test_data = b'MZ\x90\x00' + b'UnknownVM' + b'\x00' * 500
            tmp_file.write(test_data)
            tmp_file.flush()
            
            try:
                result = self.translator.translate_vm_code(tmp_file.name, 0x401000, 0x1000)
                assert isinstance(result, TranslationResult)
                assert result.success is False or result.vm_type == "Unknown"
            finally:
                os.unlink(tmp_file.name)


class TestErrorHandlingAndRobustness:
    """Test suite for error handling and robustness"""
    
    def setup_method(self):
        """Setup test environment"""
        self.translator = VMTranslator()
    
    def test_invalid_binary_handling(self):
        """Test handling of invalid binary files"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'Invalid binary data')
            tmp_file.flush()
            
            try:
                result = self.translator.translate_vm_code(tmp_file.name, 0x401000, 0x1000)
                assert isinstance(result, TranslationResult)
                assert result.success is False
            finally:
                os.unlink(tmp_file.name)
    
    def test_corrupted_vm_code_handling(self):
        """Test handling of corrupted VM code"""
        corrupted_vm_code = b'\xFF' * 100  # Invalid VM code
        
        result = self.translator.analyze_vm_opcodes(list(corrupted_vm_code))
        assert isinstance(result, list)
        # Should handle gracefully without crashing
    
    def test_memory_constraints_handling(self):
        """Test handling of memory constraints"""
        large_vm_code = b'\x00' * (10 * 1024 * 1024)  # 10MB of VM code
        
        result = self.translator.extract_vm_bytecode(large_vm_code, 0x401000)
        # Should handle large inputs gracefully
        assert isinstance(result, (bytes, type(None)))
    
    def test_resource_cleanup(self):
        """Test proper resource cleanup"""
        translator = VMTranslator()
        
        # Simulate resource allocation
        translator.allocate_analysis_resources()
        
        # Cleanup should not crash
        translator.cleanup_resources()
        assert True


if __name__ == "__main__":
    pytest.main([__file__])