"""
Comprehensive test suite for ImportRebuilder using Scylla algorithm.
Tests IAT reconstruction and import fixing capabilities.
"""

import pytest
import struct
import tempfile
import os
from unittest.mock import Mock, patch, MagicMock
from intellicrack.core.exploitation.import_rebuilder import (
    ImportRebuilder,
    IATEntry,
    ImportDescriptor,
    ReconstructionMethod,
    ReconstructionResult
)


class TestImportRebuilderInitialization:
    """Test suite for ImportRebuilder initialization and basic functionality"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_initialization(self):
        """Test ImportRebuilder initialization"""
        assert self.rebuilder is not None
        assert hasattr(self.rebuilder, 'pe_parser')
        assert hasattr(self.rebuilder, 'memory_scanner')
        assert hasattr(self.rebuilder, 'iat_entries')
    
    def test_iat_entry_structure(self):
        """Test IATEntry data structure"""
        entry = IATEntry(
            rva=0x1000,
            va=0x401000,
            api_name="MessageBoxA",
            dll_name="user32.dll",
            ordinal=None,
            is_ordinal=False
        )
        
        assert entry.rva == 0x1000
        assert entry.va == 0x401000
        assert entry.api_name == "MessageBoxA"
        assert entry.dll_name == "user32.dll"
        assert entry.ordinal is None
        assert entry.is_ordinal is False
    
    def test_import_descriptor_structure(self):
        """Test ImportDescriptor data structure"""
        descriptor = ImportDescriptor(
            dll_name="kernel32.dll",
            import_lookup_table_rva=0x2000,
            import_address_table_rva=0x3000,
            name_rva=0x4000,
            bound_import_table_rva=0x0
        )
        
        assert descriptor.dll_name == "kernel32.dll"
        assert descriptor.import_lookup_table_rva == 0x2000
        assert descriptor.import_address_table_rva == 0x3000
        assert descriptor.name_rva == 0x4000
        assert descriptor.bound_import_table_rva == 0x0
    
    def test_reconstruction_method_enum(self):
        """Test ReconstructionMethod enum values"""
        assert hasattr(ReconstructionMethod, 'SCYLLA_ALGORITHM')
        assert hasattr(ReconstructionMethod, 'MEMORY_SCANNING')
        assert hasattr(ReconstructionMethod, 'API_TRACING')
        assert hasattr(ReconstructionMethod, 'HYBRID')


class TestPEAnalysis:
    """Test suite for PE file analysis capabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_pe_header_parsing(self):
        """Test PE header parsing"""
        # Create minimal PE file
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # DOS header
            dos_header = b'MZ' + b'\x00' * 58 + struct.pack('<L', 0x80)
            # PE header offset
            pe_header = b'\x00' * (0x80 - len(dos_header))
            pe_header += b'PE\x00\x00'
            # File header
            file_header = struct.pack('<HHLLHH', 0x014c, 3, 0, 0, 0xE0, 0x102)
            # Optional header (simplified)
            opt_header = struct.pack('<HBBLLLLLLLHHHHHHLLLLHH',
                                   0x010b, 1, 0, 0x1000, 0x1000, 0x1000,
                                   0x401000, 0x1000, 0x400000, 0x1000, 0x200,
                                   4, 0, 0, 0, 0x10000, 0x1000, 0x100000, 2, 0)
            
            tmp_file.write(dos_header + pe_header + file_header + opt_header)
            tmp_file.flush()
            
            try:
                result = self.rebuilder.parse_pe_headers(tmp_file.name)
                assert isinstance(result, (dict, type(None)))
            finally:
                os.unlink(tmp_file.name)
    
    def test_import_directory_parsing(self):
        """Test import directory parsing"""
        # Mock import directory data
        import_desc = struct.pack('<LLLLL',
                                 0x2000,  # Import Lookup Table RVA
                                 0,       # Time stamp
                                 0,       # Forwarder chain
                                 0x3000,  # Name RVA
                                 0x4000)  # Import Address Table RVA
        
        result = self.rebuilder.parse_import_directory(import_desc)
        assert isinstance(result, list)
    
    def test_iat_location_detection(self):
        """Test IAT location detection"""
        mock_pe_data = b'MZ' + b'\x00' * 100 + b'PE\x00\x00' + b'\x00' * 500
        
        result = self.rebuilder.detect_iat_location(mock_pe_data)
        assert isinstance(result, (int, type(None)))
    
    def test_section_mapping(self):
        """Test section virtual address mapping"""
        # Mock section header
        section_header = struct.pack('<8sLLLLLLHL',
                                   b'.text\x00\x00\x00',  # Name
                                   0x1000,               # Virtual size
                                   0x1000,               # Virtual address
                                   0x1000,               # Size of raw data
                                   0x400,                # Pointer to raw data
                                   0, 0, 0, 0x60000020)  # Characteristics
        
        result = self.rebuilder.map_rva_to_file_offset(0x1500, [section_header])
        assert isinstance(result, (int, type(None)))


class TestScyllaAlgorithm:
    """Test suite for Scylla algorithm implementation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_scylla_iat_scanning(self):
        """Test Scylla IAT scanning algorithm"""
        # Mock IAT with valid API addresses
        mock_iat_data = struct.pack('<LL', 0x76A00000, 0x76A10000)  # Mock API addresses
        
        result = self.rebuilder.scylla_scan_iat(mock_iat_data, 0x401000)
        assert isinstance(result, list)
    
    def test_api_name_resolution(self):
        """Test API name resolution from addresses"""
        if platform.system() == 'Windows':
            # Test with known Windows API address
            result = self.rebuilder.resolve_api_name(0x76A00000)  # Mock kernel32 address
            assert isinstance(result, (str, type(None)))
    
    def test_dll_identification(self):
        """Test DLL identification from API addresses"""
        if platform.system() == 'Windows':
            result = self.rebuilder.identify_dll_from_address(0x76A00000)
            assert isinstance(result, (str, type(None)))
    
    def test_ordinal_resolution(self):
        """Test ordinal-based import resolution"""
        mock_dll_name = "user32.dll"
        mock_ordinal = 1
        
        result = self.rebuilder.resolve_ordinal_import(mock_dll_name, mock_ordinal)
        assert isinstance(result, (str, type(None)))
    
    def test_import_validation(self):
        """Test import entry validation"""
        valid_entry = IATEntry(
            rva=0x1000,
            va=0x401000,
            api_name="GetProcAddress",
            dll_name="kernel32.dll",
            ordinal=None,
            is_ordinal=False
        )
        
        result = self.rebuilder.validate_import_entry(valid_entry)
        assert isinstance(result, bool)


class TestMemoryScanning:
    """Test suite for memory-based IAT scanning"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    @patch('ctypes.windll.kernel32.ReadProcessMemory')
    def test_memory_iat_scanning(self, mock_read_memory):
        """Test memory-based IAT scanning"""
        if platform.system() == 'Windows':
            mock_read_memory.return_value = True
            
            result = self.rebuilder.scan_memory_iat(
                process_handle=0x100,
                start_address=0x401000,
                end_address=0x402000
            )
            assert isinstance(result, list)
    
    def test_api_hook_detection(self):
        """Test detection of hooked APIs in memory"""
        mock_api_address = 0x76A00000
        
        result = self.rebuilder.detect_api_hooks(mock_api_address)
        assert isinstance(result, bool)
    
    def test_memory_pattern_scanning(self):
        """Test memory pattern scanning for IAT signatures"""
        # Pattern for typical IAT entry (jmp instruction)
        iat_pattern = b'\xFF\x25'  # jmp dword ptr
        
        result = self.rebuilder.scan_memory_pattern(
            pattern=iat_pattern,
            start_address=0x401000,
            size=0x1000
        )
        assert isinstance(result, list)


class TestAPITracing:
    """Test suite for API tracing-based reconstruction"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    @patch('frida.attach')
    def test_frida_api_tracing(self, mock_attach):
        """Test Frida-based API tracing"""
        mock_session = MagicMock()
        mock_attach.return_value = mock_session
        
        result = self.rebuilder.setup_api_tracing(process_id=1234)
        assert isinstance(result, (bool, type(None)))
    
    def test_api_call_logging(self):
        """Test API call logging mechanism"""
        mock_api_call = {
            'api_name': 'MessageBoxA',
            'dll_name': 'user32.dll',
            'address': 0x76A00000,
            'parameters': ['Hello', 'World', 0, 0]
        }
        
        result = self.rebuilder.log_api_call(mock_api_call)
        assert isinstance(result, bool)
    
    def test_trace_analysis(self):
        """Test analysis of API trace data"""
        mock_trace_data = [
            {'api': 'LoadLibraryA', 'dll': 'kernel32.dll'},
            {'api': 'GetProcAddress', 'dll': 'kernel32.dll'},
            {'api': 'MessageBoxA', 'dll': 'user32.dll'}
        ]
        
        result = self.rebuilder.analyze_api_trace(mock_trace_data)
        assert isinstance(result, list)


class TestIATReconstruction:
    """Test suite for IAT reconstruction process"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_iat_table_building(self):
        """Test IAT table building from discovered imports"""
        mock_imports = [
            IATEntry(0x1000, 0x401000, "MessageBoxA", "user32.dll", None, False),
            IATEntry(0x1004, 0x401004, "GetProcAddress", "kernel32.dll", None, False),
            IATEntry(0x1008, 0x401008, "LoadLibraryA", "kernel32.dll", None, False)
        ]
        
        result = self.rebuilder.build_iat_table(mock_imports)
        assert isinstance(result, bytes)
        assert len(result) > 0
    
    def test_import_descriptor_creation(self):
        """Test import descriptor creation"""
        mock_dll_imports = {
            'kernel32.dll': [
                IATEntry(0x1000, 0x401000, "GetProcAddress", "kernel32.dll", None, False),
                IATEntry(0x1004, 0x401004, "LoadLibraryA", "kernel32.dll", None, False)
            ],
            'user32.dll': [
                IATEntry(0x1008, 0x401008, "MessageBoxA", "user32.dll", None, False)
            ]
        }
        
        result = self.rebuilder.create_import_descriptors(mock_dll_imports)
        assert isinstance(result, bytes)
    
    def test_pe_modification(self):
        """Test PE file modification with new import table"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            # Create minimal PE
            pe_data = b'MZ' + b'\x00' * 58 + struct.pack('<L', 0x80)
            pe_data += b'\x00' * (0x80 - len(pe_data))
            pe_data += b'PE\x00\x00' + b'\x00' * 500
            tmp_file.write(pe_data)
            tmp_file.flush()
            
            try:
                mock_imports = [
                    IATEntry(0x1000, 0x401000, "MessageBoxA", "user32.dll", None, False)
                ]
                
                result = self.rebuilder.modify_pe_imports(tmp_file.name, mock_imports)
                assert isinstance(result, bool)
            finally:
                os.unlink(tmp_file.name)
    
    def test_section_addition(self):
        """Test adding new section for imports"""
        mock_pe_data = bytearray(b'MZ' + b'\x00' * 1000)
        
        result = self.rebuilder.add_import_section(mock_pe_data, b'import_data')
        assert isinstance(result, (bytearray, bytes, type(None)))


class TestReconstructionValidation:
    """Test suite for reconstruction result validation"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_reconstruction_result_structure(self):
        """Test ReconstructionResult data structure"""
        result = ReconstructionResult(
            success=True,
            method=ReconstructionMethod.SCYLLA_ALGORITHM,
            imports_found=10,
            imports_resolved=9,
            iat_rva=0x2000,
            import_table_rva=0x3000,
            modified_pe_data=b'modified_pe',
            errors=[]
        )
        
        assert result.success is True
        assert result.method == ReconstructionMethod.SCYLLA_ALGORITHM
        assert result.imports_found == 10
        assert result.imports_resolved == 9
        assert result.iat_rva == 0x2000
        assert result.import_table_rva == 0x3000
        assert result.modified_pe_data == b'modified_pe'
        assert result.errors == []
    
    def test_import_resolution_validation(self):
        """Test import resolution validation"""
        mock_original_imports = ['MessageBoxA', 'GetProcAddress', 'LoadLibraryA']
        mock_resolved_imports = ['MessageBoxA', 'GetProcAddress']
        
        result = self.rebuilder.validate_import_resolution(
            mock_original_imports, mock_resolved_imports
        )
        assert isinstance(result, dict)
        assert 'resolution_rate' in result
        assert 'missing_imports' in result
    
    def test_pe_integrity_validation(self):
        """Test PE file integrity after modification"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            pe_data = b'MZ' + b'\x00' * 100 + b'PE\x00\x00' + b'\x00' * 500
            tmp_file.write(pe_data)
            tmp_file.flush()
            
            try:
                result = self.rebuilder.validate_pe_integrity(tmp_file.name)
                assert isinstance(result, bool)
            finally:
                os.unlink(tmp_file.name)
    
    def test_functional_validation(self):
        """Test functional validation of reconstructed imports"""
        mock_pe_path = "test.exe"
        
        # Should not crash with invalid path
        result = self.rebuilder.validate_reconstructed_functionality(mock_pe_path)
        assert isinstance(result, bool)


class TestHybridReconstruction:
    """Test suite for hybrid reconstruction methods"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_combined_method_selection(self):
        """Test selection of combined reconstruction methods"""
        result = self.rebuilder.select_optimal_method(
            pe_packed=True,
            memory_available=True,
            api_tracing_possible=True
        )
        assert result in [ReconstructionMethod.HYBRID, ReconstructionMethod.SCYLLA_ALGORITHM]
    
    def test_method_fallback(self):
        """Test fallback between reconstruction methods"""
        # Simulate primary method failure
        primary_result = ReconstructionResult(success=False, method=ReconstructionMethod.SCYLLA_ALGORITHM)
        
        fallback_result = self.rebuilder.apply_fallback_method(primary_result)
        assert isinstance(fallback_result, ReconstructionResult)
    
    def test_result_merging(self):
        """Test merging results from multiple methods"""
        result1 = ReconstructionResult(
            success=True,
            method=ReconstructionMethod.SCYLLA_ALGORITHM,
            imports_found=5
        )
        result2 = ReconstructionResult(
            success=True,
            method=ReconstructionMethod.MEMORY_SCANNING,
            imports_found=3
        )
        
        merged_result = self.rebuilder.merge_reconstruction_results([result1, result2])
        assert isinstance(merged_result, ReconstructionResult)
        assert merged_result.imports_found >= max(result1.imports_found, result2.imports_found)


class TestErrorHandlingAndRobustness:
    """Test suite for error handling and robustness"""
    
    def setup_method(self):
        """Setup test environment"""
        self.rebuilder = ImportRebuilder()
    
    def test_invalid_pe_handling(self):
        """Test handling of invalid PE files"""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as tmp_file:
            tmp_file.write(b'Invalid PE data')
            tmp_file.flush()
            
            try:
                result = self.rebuilder.reconstruct_imports(tmp_file.name)
                assert isinstance(result, ReconstructionResult)
                assert result.success is False
            finally:
                os.unlink(tmp_file.name)
    
    def test_memory_access_errors(self):
        """Test handling of memory access errors"""
        invalid_address = 0xDEADBEEF
        
        result = self.rebuilder.scan_memory_iat(
            process_handle=0x100,
            start_address=invalid_address,
            end_address=invalid_address + 0x1000
        )
        assert isinstance(result, list)
        # Should return empty list on error, not crash
    
    def test_corrupted_iat_handling(self):
        """Test handling of corrupted IAT data"""
        corrupted_iat = b'\xFF' * 100  # Invalid IAT data
        
        result = self.rebuilder.scylla_scan_iat(corrupted_iat, 0x401000)
        assert isinstance(result, list)
        # Should handle gracefully
    
    def test_resource_cleanup(self):
        """Test proper resource cleanup"""
        rebuilder = ImportRebuilder()
        
        # Simulate some resource allocation
        rebuilder.allocate_resources()
        
        # Cleanup should not crash
        rebuilder.cleanup_resources()
        assert True


if __name__ == "__main__":
    pytest.main([__file__])