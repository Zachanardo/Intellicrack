"""
Comprehensive test suite for DirectSyscallManager and AdvancedMemoryOperations.
Tests core memory manipulation framework for Phase 5 exploitation capabilities.
"""

import pytest
import ctypes
import os
import platform
from unittest.mock import Mock, patch, MagicMock
from intellicrack.core.exploitation.memory_framework import (
    DirectSyscallManager,
    AdvancedMemoryOperations,
    SyscallType,
    MemoryPermissions
)


class TestDirectSyscallManager:
    """Test suite for DirectSyscallManager class"""
    
    def setup_method(self):
        """Setup test environment"""
        self.manager = DirectSyscallManager()
    
    def test_initialization(self):
        """Test DirectSyscallManager initialization"""
        assert self.manager is not None
        assert hasattr(self.manager, 'syscall_cache')
        assert hasattr(self.manager, 'loaded_ntdll')
    
    def test_find_syscall_number_ntquerysysteminformation(self):
        """Test finding NtQuerySystemInformation syscall number"""
        if platform.system() == 'Windows':
            # Test real syscall lookup
            syscall_num = self.manager.find_syscall_number("NtQuerySystemInformation")
            assert isinstance(syscall_num, int)
            assert syscall_num > 0
            # Cache should store the result
            assert "NtQuerySystemInformation" in self.manager.syscall_cache
        else:
            # On non-Windows, should return None
            syscall_num = self.manager.find_syscall_number("NtQuerySystemInformation")
            assert syscall_num is None
    
    def test_syscall_caching(self):
        """Test syscall number caching mechanism"""
        if platform.system() == 'Windows':
            # First call should cache the result
            syscall_num1 = self.manager.find_syscall_number("NtCreateFile")
            syscall_num2 = self.manager.find_syscall_number("NtCreateFile")
            
            assert syscall_num1 == syscall_num2
            assert "NtCreateFile" in self.manager.syscall_cache
    
    def test_direct_syscall_execution(self):
        """Test direct syscall execution capability"""
        if platform.system() == 'Windows':
            # Test non-destructive syscall
            result = self.manager.execute_syscall(
                SyscallType.NT_QUERY_SYSTEM_INFORMATION,
                0, None, 0, None  # Query system basic information
            )
            # Should return NTSTATUS value
            assert isinstance(result, int)
    
    def test_invalid_syscall_handling(self):
        """Test handling of invalid syscall names"""
        result = self.manager.find_syscall_number("InvalidSyscallName")
        assert result is None
    
    def test_syscall_types_enum(self):
        """Test SyscallType enum values"""
        assert hasattr(SyscallType, 'NT_CREATE_FILE')
        assert hasattr(SyscallType, 'NT_OPEN_PROCESS')
        assert hasattr(SyscallType, 'NT_ALLOCATE_VIRTUAL_MEMORY')


class TestAdvancedMemoryOperations:
    """Test suite for AdvancedMemoryOperations class"""
    
    def setup_method(self):
        """Setup test environment"""
        self.memory_ops = AdvancedMemoryOperations()
    
    def test_initialization(self):
        """Test AdvancedMemoryOperations initialization"""
        assert self.memory_ops is not None
        assert hasattr(self.memory_ops, 'syscall_manager')
        assert isinstance(self.memory_ops.syscall_manager, DirectSyscallManager)
    
    def test_memory_permissions_enum(self):
        """Test MemoryPermissions enum values"""
        assert hasattr(MemoryPermissions, 'READ')
        assert hasattr(MemoryPermissions, 'WRITE')
        assert hasattr(MemoryPermissions, 'EXECUTE')
        assert hasattr(MemoryPermissions, 'READ_WRITE')
        assert hasattr(MemoryPermissions, 'READ_EXECUTE')
        assert hasattr(MemoryPermissions, 'READ_WRITE_EXECUTE')
    
    def test_allocate_memory_windows(self):
        """Test real memory allocation on Windows"""
        if platform.system() == 'Windows':
            # Test real memory allocation in current process
            result = self.memory_ops.allocate_memory(
                size=4096,
                permissions=MemoryPermissions.READ_WRITE,
                process_handle=-1  # Current process
            )
            
            assert result is not None
            assert isinstance(result, int)
            assert result > 0
            
            # Test that we can write to allocated memory
            test_data = b"Hello, World!"
            write_result = self.memory_ops.write_memory(
                address=result,
                data=test_data,
                process_handle=-1
            )
            assert write_result is True
            
            # Test that we can read back the data
            read_data = self.memory_ops.read_memory(
                address=result,
                size=len(test_data),
                process_handle=-1
            )
            assert read_data == test_data
    
    def test_calculate_aligned_size(self):
        """Test memory size alignment calculation"""
        # Test page alignment (4KB)
        aligned_size = self.memory_ops._calculate_aligned_size(1000)
        assert aligned_size == 4096
        
        aligned_size = self.memory_ops._calculate_aligned_size(4096)
        assert aligned_size == 4096
        
        aligned_size = self.memory_ops._calculate_aligned_size(5000)
        assert aligned_size == 8192
    
    def test_protection_bypass_detection(self):
        """Test detection of memory protection mechanisms"""
        # Mock memory region with protection
        mock_address = 0x400000
        mock_size = 4096
        
        result = self.memory_ops.detect_protection_mechanisms(mock_address, mock_size)
        assert isinstance(result, dict)
        assert 'has_guard_pages' in result
        assert 'has_no_access' in result
        assert 'has_dep' in result
    
    def test_hook_installation_validation(self):
        """Test memory hook installation validation"""
        mock_address = 0x401000
        mock_hook_data = b'\x48\x31\xc0'  # Sample x64 instructions
        
        result = self.memory_ops.validate_hook_installation(mock_address, mock_hook_data)
        assert isinstance(result, bool)
    
    def test_memory_scan_patterns(self):
        """Test memory scanning for specific patterns"""
        test_pattern = b'\x48\x89\xe5'  # mov rbp, rsp
        mock_start_addr = 0x400000
        mock_end_addr = 0x500000
        
        # Should not crash and return list
        results = self.memory_ops.scan_memory_pattern(
            pattern=test_pattern,
            start_address=mock_start_addr,
            end_address=mock_end_addr
        )
        assert isinstance(results, list)


class TestMemoryFrameworkIntegration:
    """Integration tests for memory framework components"""
    
    def test_syscall_manager_memory_ops_integration(self):
        """Test integration between syscall manager and memory operations"""
        memory_ops = AdvancedMemoryOperations()
        
        # Verify memory operations can access syscall manager
        assert memory_ops.syscall_manager is not None
        assert isinstance(memory_ops.syscall_manager, DirectSyscallManager)
    
    def test_cross_platform_compatibility(self):
        """Test cross-platform compatibility handling"""
        manager = DirectSyscallManager()
        memory_ops = AdvancedMemoryOperations()
        
        # Both should initialize without errors regardless of platform
        assert manager is not None
        assert memory_ops is not None
    
    @pytest.mark.skipif(platform.system() != 'Windows', reason="Windows-specific test")
    def test_real_syscall_execution_windows(self):
        """Test actual syscall execution on Windows (safe operations only)"""
        manager = DirectSyscallManager()
        
        # Test non-destructive system information query
        syscall_num = manager.find_syscall_number("NtQuerySystemInformation")
        if syscall_num:
            assert isinstance(syscall_num, int)
            assert syscall_num > 0
    
    def test_error_handling_robustness(self):
        """Test error handling across framework components"""
        manager = DirectSyscallManager()
        memory_ops = AdvancedMemoryOperations()
        
        # Test invalid operations don't crash
        invalid_result = manager.find_syscall_number("")
        assert invalid_result is None
        
        invalid_alloc = memory_ops.allocate_memory(size=0)
        assert invalid_alloc is None or invalid_alloc == 0


if __name__ == "__main__":
    pytest.main([__file__])