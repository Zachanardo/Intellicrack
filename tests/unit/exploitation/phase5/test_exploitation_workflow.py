"""
Comprehensive test suite for WorkflowOrchestrator central coordination system.
Tests workflow management, task execution, and system integration.
"""

import pytest
import asyncio
import tempfile
import os
import yaml
from unittest.mock import Mock, patch, MagicMock, AsyncMock
from intellicrack.core.exploitation.exploitation_workflow import (
    WorkflowOrchestrator,
    TaskExecutor,
    WorkflowExecution,
    WorkflowState,
    TaskState,
    WorkflowDefinition,
    TaskDefinition
)


class TestWorkflowOrchestratorInitialization:
    """Test suite for WorkflowOrchestrator initialization and basic functionality"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    def test_initialization(self):
        """Test WorkflowOrchestrator initialization"""
        assert self.orchestrator is not None
        assert hasattr(self.orchestrator, 'workflow_definitions')
        assert hasattr(self.orchestrator, 'active_executions')
        assert hasattr(self.orchestrator, 'task_executor')
        assert hasattr(self.orchestrator, 'event_handlers')
    
    def test_workflow_state_enum(self):
        """Test WorkflowState enum values"""
        assert hasattr(WorkflowState, 'PENDING')
        assert hasattr(WorkflowState, 'RUNNING')
        assert hasattr(WorkflowState, 'PAUSED')
        assert hasattr(WorkflowState, 'COMPLETED')
        assert hasattr(WorkflowState, 'FAILED')
        assert hasattr(WorkflowState, 'CANCELLED')
    
    def test_task_state_enum(self):
        """Test TaskState enum values"""
        assert hasattr(TaskState, 'PENDING')
        assert hasattr(TaskState, 'RUNNING')
        assert hasattr(TaskState, 'COMPLETED')
        assert hasattr(TaskState, 'FAILED')
        assert hasattr(TaskState, 'SKIPPED')
    
    def test_task_executor_initialization(self):
        """Test TaskExecutor initialization"""
        executor = TaskExecutor()
        assert executor is not None
        assert hasattr(executor, 'available_components')
        assert hasattr(executor, 'execution_context')


class TestWorkflowDefinitionLoading:
    """Test suite for workflow definition loading and parsing"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    def test_load_workflow_from_yaml(self):
        """Test loading workflow definition from YAML"""
        workflow_yaml = """
        name: "test_workflow"
        description: "Test workflow for unit testing"
        target_protection: "test"
        tasks:
          - id: "task1"
            component: "memory_framework"
            method: "allocate_memory"
            parameters:
              size: 4096
            dependencies: []
          - id: "task2"
            component: "universal_unpacker"
            method: "unpack_binary"
            parameters:
              binary_path: "/test/path"
            dependencies: ["task1"]
        """
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as tmp_file:
            tmp_file.write(workflow_yaml)
            tmp_file.flush()
            
            try:
                result = self.orchestrator.load_workflow_definition(tmp_file.name)
                assert isinstance(result, (WorkflowDefinition, type(None)))
                if result:
                    assert result.name == "test_workflow"
                    assert len(result.tasks) == 2
            finally:
                os.unlink(tmp_file.name)
    
    def test_workflow_validation(self):
        """Test workflow definition validation"""
        valid_workflow = WorkflowDefinition(
            name="valid_test",
            description="Valid test workflow",
            target_protection="test",
            tasks=[
                TaskDefinition(
                    id="task1",
                    component="memory_framework",
                    method="allocate_memory",
                    parameters={"size": 4096},
                    dependencies=[]
                )
            ]
        )
        
        result = self.orchestrator.validate_workflow_definition(valid_workflow)
        assert isinstance(result, bool)
        assert result is True
    
    def test_circular_dependency_detection(self):
        """Test detection of circular dependencies in workflows"""
        circular_workflow = WorkflowDefinition(
            name="circular_test",
            description="Workflow with circular dependencies",
            target_protection="test",
            tasks=[
                TaskDefinition(
                    id="task1",
                    component="test",
                    method="test",
                    parameters={},
                    dependencies=["task2"]
                ),
                TaskDefinition(
                    id="task2",
                    component="test",
                    method="test",
                    parameters={},
                    dependencies=["task1"]
                )
            ]
        )
        
        result = self.orchestrator.detect_circular_dependencies(circular_workflow)
        assert isinstance(result, bool)
        assert result is True  # Should detect circular dependency
    
    def test_default_workflows_loading(self):
        """Test loading of default workflow configurations"""
        result = self.orchestrator.load_default_workflows()
        assert isinstance(result, bool)
        # Should not crash regardless of whether default workflows exist


class TestWorkflowExecution:
    """Test suite for workflow execution capabilities"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    @pytest.mark.asyncio
    async def test_simple_workflow_execution(self):
        """Test execution of simple workflow"""
        simple_workflow = WorkflowDefinition(
            name="simple_test",
            description="Simple test workflow",
            target_protection="test",
            tasks=[
                TaskDefinition(
                    id="simple_task",
                    component="test_component",
                    method="test_method",
                    parameters={"test_param": "value"},
                    dependencies=[]
                )
            ]
        )
        
        # Mock the component method
        with patch.object(self.orchestrator.task_executor, 'execute_task', new_callable=AsyncMock) as mock_execute:
            mock_execute.return_value = {"success": True, "result": "test_result"}
            
            execution_id = await self.orchestrator.execute_workflow("simple_test", execution_context={"test": True})
            assert isinstance(execution_id, str)
            assert execution_id in self.orchestrator.active_executions
    
    @pytest.mark.asyncio
    async def test_multi_task_workflow_execution(self):
        """Test execution of multi-task workflow with dependencies"""
        multi_task_workflow = WorkflowDefinition(
            name="multi_task_test",
            description="Multi-task test workflow",
            target_protection="test",
            tasks=[
                TaskDefinition(
                    id="task1",
                    component="memory_framework",
                    method="allocate_memory",
                    parameters={"size": 4096},
                    dependencies=[]
                ),
                TaskDefinition(
                    id="task2",
                    component="universal_unpacker",
                    method="detect_packer",
                    parameters={"binary_path": "/test/path"},
                    dependencies=["task1"]
                ),
                TaskDefinition(
                    id="task3",
                    component="titan_hide_engine",
                    method="setup_bypass",
                    parameters={"process_id": 1234},
                    dependencies=["task1", "task2"]
                )
            ]
        )
        
        self.orchestrator.workflow_definitions["multi_task_test"] = multi_task_workflow
        
        with patch.object(self.orchestrator.task_executor, 'execute_task', new_callable=AsyncMock) as mock_execute:
            mock_execute.return_value = {"success": True, "result": "test_result"}
            
            execution_id = await self.orchestrator.execute_workflow("multi_task_test")
            assert isinstance(execution_id, str)
    
    def test_workflow_state_management(self):
        """Test workflow state management"""
        execution = WorkflowExecution(
            execution_id="test_exec_001",
            workflow_definition=WorkflowDefinition(
                name="state_test",
                description="State test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.PENDING,
            execution_context={},
            start_time=0.0
        )
        
        # Test state transitions
        execution.state = WorkflowState.RUNNING
        assert execution.state == WorkflowState.RUNNING
        
        execution.state = WorkflowState.COMPLETED
        assert execution.state == WorkflowState.COMPLETED
    
    def test_execution_context_management(self):
        """Test execution context management"""
        context = {
            "target_binary": "/path/to/binary.exe",
            "analysis_mode": "comprehensive",
            "stealth_level": "high"
        }
        
        execution = WorkflowExecution(
            execution_id="context_test_001",
            workflow_definition=WorkflowDefinition(
                name="context_test",
                description="Context test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.PENDING,
            execution_context=context,
            start_time=0.0
        )
        
        assert execution.execution_context["target_binary"] == "/path/to/binary.exe"
        assert execution.execution_context["stealth_level"] == "high"


class TestTaskExecution:
    """Test suite for individual task execution"""
    
    def setup_method(self):
        """Setup test environment"""
        self.executor = TaskExecutor()
    
    @pytest.mark.asyncio
    async def test_memory_framework_task_execution(self):
        """Test memory framework task execution"""
        task = TaskDefinition(
            id="memory_task",
            component="memory_framework",
            method="allocate_memory",
            parameters={"size": 4096, "permissions": "READ_WRITE"},
            dependencies=[]
        )
        
        with patch('intellicrack.core.exploitation.memory_framework.AdvancedMemoryOperations.allocate_memory') as mock_allocate:
            mock_allocate.return_value = 0x10000000
            
            result = await self.executor.execute_task(task, {})
            assert isinstance(result, dict)
            assert "success" in result
    
    @pytest.mark.asyncio
    async def test_universal_unpacker_task_execution(self):
        """Test universal unpacker task execution"""
        task = TaskDefinition(
            id="unpacker_task",
            component="universal_unpacker",
            method="unpack_binary",
            parameters={"binary_path": "/test/binary.exe"},
            dependencies=[]
        )
        
        with patch('intellicrack.core.exploitation.universal_unpacker.UniversalUnpacker.unpack_binary') as mock_unpack:
            mock_unpack.return_value = Mock(success=True, unpacked_data=b'test_data')
            
            result = await self.executor.execute_task(task, {})
            assert isinstance(result, dict)
            assert "success" in result
    
    @pytest.mark.asyncio
    async def test_titan_hide_task_execution(self):
        """Test TitanHide engine task execution"""
        task = TaskDefinition(
            id="titan_hide_task",
            component="titan_hide_engine",
            method="bypass_isdebugger_present",
            parameters={"process_id": 1234},
            dependencies=[]
        )
        
        with patch('intellicrack.core.exploitation.titan_hide_engine.TitanHideEngine.bypass_isdebugger_present') as mock_bypass:
            mock_bypass.return_value = Mock(success=True, bypass_type="DEBUGGER_DETECTION")
            
            result = await self.executor.execute_task(task, {})
            assert isinstance(result, dict)
            assert "success" in result
    
    @pytest.mark.asyncio
    async def test_task_error_handling(self):
        """Test task execution error handling"""
        invalid_task = TaskDefinition(
            id="invalid_task",
            component="nonexistent_component",
            method="nonexistent_method",
            parameters={},
            dependencies=[]
        )
        
        result = await self.executor.execute_task(invalid_task, {})
        assert isinstance(result, dict)
        assert result["success"] is False
        assert "error" in result
    
    def test_task_dependency_resolution(self):
        """Test task dependency resolution"""
        tasks = [
            TaskDefinition(id="task1", component="test", method="test", parameters={}, dependencies=[]),
            TaskDefinition(id="task2", component="test", method="test", parameters={}, dependencies=["task1"]),
            TaskDefinition(id="task3", component="test", method="test", parameters={}, dependencies=["task1", "task2"])
        ]
        
        resolved_order = self.executor.resolve_task_dependencies(tasks)
        assert isinstance(resolved_order, list)
        assert len(resolved_order) == 3
        
        # task1 should come before task2 and task3
        task1_index = next(i for i, task in enumerate(resolved_order) if task.id == "task1")
        task2_index = next(i for i, task in enumerate(resolved_order) if task.id == "task2")
        task3_index = next(i for i, task in enumerate(resolved_order) if task.id == "task3")
        
        assert task1_index < task2_index
        assert task1_index < task3_index
        assert task2_index < task3_index


class TestWorkflowMonitoring:
    """Test suite for workflow monitoring and status tracking"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    def test_execution_status_tracking(self):
        """Test execution status tracking"""
        execution_id = "test_execution_001"
        
        # Create mock execution
        execution = WorkflowExecution(
            execution_id=execution_id,
            workflow_definition=WorkflowDefinition(
                name="status_test",
                description="Status test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.RUNNING,
            execution_context={},
            start_time=1000.0
        )
        
        self.orchestrator.active_executions[execution_id] = execution
        
        status = self.orchestrator.get_execution_status(execution_id)
        assert isinstance(status, dict)
        assert status["execution_id"] == execution_id
        assert status["state"] == WorkflowState.RUNNING
    
    def test_execution_progress_tracking(self):
        """Test execution progress tracking"""
        execution_id = "progress_test_001"
        
        # Create execution with multiple tasks
        tasks = [
            TaskDefinition(id=f"task{i}", component="test", method="test", parameters={}, dependencies=[])
            for i in range(5)
        ]
        
        execution = WorkflowExecution(
            execution_id=execution_id,
            workflow_definition=WorkflowDefinition(
                name="progress_test",
                description="Progress test workflow",
                target_protection="test",
                tasks=tasks
            ),
            state=WorkflowState.RUNNING,
            execution_context={},
            start_time=1000.0
        )
        
        # Mark some tasks as completed
        execution.task_states = {
            "task0": TaskState.COMPLETED,
            "task1": TaskState.COMPLETED,
            "task2": TaskState.RUNNING,
            "task3": TaskState.PENDING,
            "task4": TaskState.PENDING
        }
        
        self.orchestrator.active_executions[execution_id] = execution
        
        progress = self.orchestrator.get_execution_progress(execution_id)
        assert isinstance(progress, dict)
        assert progress["completed_tasks"] == 2
        assert progress["total_tasks"] == 5
        assert progress["progress_percentage"] == 40.0
    
    def test_active_executions_listing(self):
        """Test listing of active executions"""
        # Create multiple mock executions
        for i in range(3):
            execution_id = f"active_test_{i:03d}"
            execution = WorkflowExecution(
                execution_id=execution_id,
                workflow_definition=WorkflowDefinition(
                    name=f"active_test_{i}",
                    description=f"Active test workflow {i}",
                    target_protection="test",
                    tasks=[]
                ),
                state=WorkflowState.RUNNING,
                execution_context={},
                start_time=1000.0 + i
            )
            self.orchestrator.active_executions[execution_id] = execution
        
        active_list = self.orchestrator.list_active_executions()
        assert isinstance(active_list, list)
        assert len(active_list) == 3


class TestWorkflowControl:
    """Test suite for workflow control operations"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    @pytest.mark.asyncio
    async def test_workflow_pause_resume(self):
        """Test workflow pause and resume functionality"""
        execution_id = "pause_test_001"
        
        # Create running execution
        execution = WorkflowExecution(
            execution_id=execution_id,
            workflow_definition=WorkflowDefinition(
                name="pause_test",
                description="Pause test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.RUNNING,
            execution_context={},
            start_time=1000.0
        )
        
        self.orchestrator.active_executions[execution_id] = execution
        
        # Test pause
        pause_result = await self.orchestrator.pause_execution(execution_id)
        assert isinstance(pause_result, bool)
        if pause_result:
            assert execution.state == WorkflowState.PAUSED
        
        # Test resume
        resume_result = await self.orchestrator.resume_execution(execution_id)
        assert isinstance(resume_result, bool)
    
    @pytest.mark.asyncio
    async def test_workflow_cancellation(self):
        """Test workflow cancellation"""
        execution_id = "cancel_test_001"
        
        execution = WorkflowExecution(
            execution_id=execution_id,
            workflow_definition=WorkflowDefinition(
                name="cancel_test",
                description="Cancel test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.RUNNING,
            execution_context={},
            start_time=1000.0
        )
        
        self.orchestrator.active_executions[execution_id] = execution
        
        cancel_result = await self.orchestrator.cancel_execution(execution_id)
        assert isinstance(cancel_result, bool)
        if cancel_result:
            assert execution.state == WorkflowState.CANCELLED
    
    def test_execution_cleanup(self):
        """Test execution cleanup after completion"""
        completed_executions = []
        
        for i in range(3):
            execution_id = f"cleanup_test_{i:03d}"
            execution = WorkflowExecution(
                execution_id=execution_id,
                workflow_definition=WorkflowDefinition(
                    name=f"cleanup_test_{i}",
                    description=f"Cleanup test workflow {i}",
                    target_protection="test",
                    tasks=[]
                ),
                state=WorkflowState.COMPLETED,
                execution_context={},
                start_time=1000.0 + i,
                end_time=2000.0 + i
            )
            completed_executions.append(execution_id)
            self.orchestrator.active_executions[execution_id] = execution
        
        cleanup_result = self.orchestrator.cleanup_completed_executions()
        assert isinstance(cleanup_result, int)
        assert cleanup_result >= 0


class TestWorkflowTemplates:
    """Test suite for workflow templates and presets"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    def test_vmprotect_workflow_template(self):
        """Test VMProtect workflow template"""
        template = self.orchestrator.get_workflow_template("vmprotect")
        assert isinstance(template, (WorkflowDefinition, type(None)))
        if template:
            assert template.target_protection == "vmprotect"
            assert len(template.tasks) > 0
    
    def test_themida_workflow_template(self):
        """Test Themida workflow template"""
        template = self.orchestrator.get_workflow_template("themida")
        assert isinstance(template, (WorkflowDefinition, type(None)))
        if template:
            assert template.target_protection == "themida"
            assert len(template.tasks) > 0
    
    def test_denuvo_workflow_template(self):
        """Test Denuvo workflow template"""
        template = self.orchestrator.get_workflow_template("denuvo")
        assert isinstance(template, (WorkflowDefinition, type(None)))
        if template:
            assert template.target_protection == "denuvo"
            assert len(template.tasks) > 0
    
    def test_generic_workflow_template(self):
        """Test generic software workflow template"""
        template = self.orchestrator.get_workflow_template("generic")
        assert isinstance(template, (WorkflowDefinition, type(None)))
        if template:
            assert template.target_protection == "generic"
            assert len(template.tasks) > 0
    
    def test_custom_workflow_creation(self):
        """Test custom workflow creation from template"""
        base_template = WorkflowDefinition(
            name="base_template",
            description="Base template for customization",
            target_protection="custom",
            tasks=[
                TaskDefinition(
                    id="base_task",
                    component="memory_framework",
                    method="allocate_memory",
                    parameters={"size": 4096},
                    dependencies=[]
                )
            ]
        )
        
        custom_params = {
            "name": "custom_workflow",
            "description": "Customized workflow",
            "additional_tasks": [
                {
                    "id": "custom_task",
                    "component": "universal_unpacker",
                    "method": "detect_packer",
                    "parameters": {"binary_path": "/custom/path"},
                    "dependencies": ["base_task"]
                }
            ]
        }
        
        custom_workflow = self.orchestrator.create_custom_workflow(base_template, custom_params)
        assert isinstance(custom_workflow, (WorkflowDefinition, type(None)))
        if custom_workflow:
            assert custom_workflow.name == "custom_workflow"
            assert len(custom_workflow.tasks) >= 1


class TestErrorHandlingAndRobustness:
    """Test suite for error handling and robustness"""
    
    def setup_method(self):
        """Setup test environment"""
        self.orchestrator = WorkflowOrchestrator()
    
    @pytest.mark.asyncio
    async def test_invalid_workflow_execution(self):
        """Test execution of invalid workflow"""
        result = await self.orchestrator.execute_workflow("nonexistent_workflow")
        assert result is None
    
    def test_invalid_execution_id_handling(self):
        """Test handling of invalid execution IDs"""
        invalid_ids = ["", "nonexistent", None, 123]
        
        for invalid_id in invalid_ids:
            if invalid_id is not None:
                status = self.orchestrator.get_execution_status(invalid_id)
                assert status is None or isinstance(status, dict)
    
    @pytest.mark.asyncio
    async def test_task_failure_recovery(self):
        """Test task failure recovery mechanisms"""
        failing_workflow = WorkflowDefinition(
            name="failing_test",
            description="Workflow with failing task",
            target_protection="test",
            tasks=[
                TaskDefinition(
                    id="failing_task",
                    component="nonexistent",
                    method="nonexistent",
                    parameters={},
                    dependencies=[]
                ),
                TaskDefinition(
                    id="recovery_task",
                    component="memory_framework",
                    method="allocate_memory",
                    parameters={"size": 4096},
                    dependencies=[]
                )
            ]
        )
        
        self.orchestrator.workflow_definitions["failing_test"] = failing_workflow
        
        execution_id = await self.orchestrator.execute_workflow("failing_test")
        # Should handle failures gracefully
        assert isinstance(execution_id, (str, type(None)))
    
    def test_resource_cleanup_on_failure(self):
        """Test resource cleanup when execution fails"""
        orchestrator = WorkflowOrchestrator()
        
        # Simulate failed execution
        execution = WorkflowExecution(
            execution_id="failed_test_001",
            workflow_definition=WorkflowDefinition(
                name="failed_test",
                description="Failed test workflow",
                target_protection="test",
                tasks=[]
            ),
            state=WorkflowState.FAILED,
            execution_context={},
            start_time=1000.0,
            error_message="Simulated failure"
        )
        
        orchestrator.active_executions["failed_test_001"] = execution
        
        # Cleanup should not crash
        cleanup_result = orchestrator.cleanup_failed_executions()
        assert isinstance(cleanup_result, int)
    
    def test_concurrent_execution_safety(self):
        """Test safety of concurrent workflow executions"""
        import threading
        
        results = []
        
        async def run_workflow():
            workflow = WorkflowDefinition(
                name="concurrent_test",
                description="Concurrent test workflow",
                target_protection="test",
                tasks=[]
            )
            self.orchestrator.workflow_definitions["concurrent_test"] = workflow
            
            execution_id = await self.orchestrator.execute_workflow("concurrent_test")
            results.append(execution_id)
        
        # This is a simplified test - in practice, would need proper async handling
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            tasks = [run_workflow() for _ in range(3)]
            loop.run_until_complete(asyncio.gather(*tasks))
        finally:
            loop.close()
        
        assert len(results) == 3
        assert all(isinstance(r, (str, type(None))) for r in results)


if __name__ == "__main__":
    pytest.main([__file__])