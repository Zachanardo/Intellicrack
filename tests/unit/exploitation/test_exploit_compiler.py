"""
Unit tests for Exploit Compiler with REAL exploit compilation.
Tests REAL exploit generation from vulnerability analysis to working code.
NO MOCKS - ALL TESTS USE REAL BINARIES AND PRODUCE REAL RESULTS.
"""

import pytest
from pathlib import Path
import tempfile
import subprocess

from intellicrack.core.exploitation.exploit_compiler import ExploitCompiler
from tests.base_test import IntellicrackTestBase


class TestExploitCompiler(IntellicrackTestBase):
    """Test exploit compilation with REAL working exploits."""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test with real exploit compiler."""
        self.compiler = ExploitCompiler()
        self.test_dir = Path(__file__).parent.parent.parent / 'fixtures' / 'binaries'
        
        # Vulnerable test binaries
        self.buffer_overflow = self.test_dir / 'vulnerable' / 'buffer_overflow_0.exe'
        self.format_string = self.test_dir / 'vulnerable' / 'format_string_0.exe'
        self.heap_overflow = self.test_dir / 'vulnerable' / 'heap_overflow_0.exe'
        
    def test_stack_overflow_exploit_compilation(self):
        """Test compiling stack buffer overflow exploit."""
        if not self.buffer_overflow.exists():
            pytest.skip("Vulnerable binary not found")
            
        # Analyze vulnerability
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,  # Offset to EIP
            'bad_chars': b'\x00\x0a\x0d',
            'target': str(self.buffer_overflow)
        }
        
        # Compile exploit
        exploit = self.compiler.compile_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'code' in exploit
        assert 'language' in exploit
        assert 'payload' in exploit
        assert 'instructions' in exploit
        
        # Validate exploit code
        code = exploit['code']
        assert len(code) > 100  # Real exploit code
        assert 'payload' in code
        assert str(vuln_info['offset']) in code
        
    def test_format_string_exploit_compilation(self):
        """Test compiling format string exploit."""
        if not self.format_string.exists():
            pytest.skip("Format string binary not found")
            
        vuln_info = {
            'type': 'format_string',
            'offset': 7,  # Stack offset
            'got_address': 0x08049a1c,  # printf@GOT
            'target_function': 0x08048516,  # win()
            'target': str(self.format_string)
        }
        
        exploit = self.compiler.compile_format_string_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert len(exploit['payload']) > 0
        assert b'%' in exploit['payload']  # Format specifiers
        assert exploit['exploit_type'] == 'format_string'
        
        # Should have calculated writes
        assert 'writes' in exploit
        for write in exploit['writes']:
            assert 'address' in write
            assert 'value' in write
            
    def test_heap_overflow_exploit_compilation(self):
        """Test compiling heap overflow exploit."""
        if not self.heap_overflow.exists():
            pytest.skip("Heap overflow binary not found")
            
        vuln_info = {
            'type': 'heap_overflow',
            'overflow_size': 256,
            'chunk_size': 64,
            'target': str(self.heap_overflow)
        }
        
        exploit = self.compiler.compile_heap_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'heap_layout' in exploit
        assert 'overflow_data' in exploit
        assert len(exploit['payload']) > vuln_info['overflow_size']
        
    def test_rop_exploit_compilation(self):
        """Test compiling ROP-based exploit."""
        if not self.buffer_overflow.exists():
            pytest.skip("Vulnerable binary not found")
            
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'dep_enabled': True,  # Need ROP
            'gadgets': [
                {'address': 0x080484f1, 'instructions': ['pop eax', 'ret']},
                {'address': 0x080484f3, 'instructions': ['pop ebx', 'ret']},
            ],
            'target': str(self.buffer_overflow)
        }
        
        exploit = self.compiler.compile_rop_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'rop_chain' in exploit
        assert len(exploit['rop_chain']) > 0
        assert 'shellcode' in exploit
        
        # Validate ROP chain encoding
        code = exploit['code']
        assert 'rop_chain' in code
        assert 'pack' in code  # Struct packing
        
    def test_exploit_template_generation(self):
        """Test exploit template generation for different languages."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 100,
            'target': 'test.exe'
        }
        
        # Python exploit
        python_exploit = self.compiler.generate_python_exploit(vuln_info)
        self.assert_real_output(python_exploit)
        assert 'import struct' in python_exploit
        assert 'socket' in python_exploit
        assert 'def exploit()' in python_exploit
        
        # C exploit
        c_exploit = self.compiler.generate_c_exploit(vuln_info)
        assert '#include' in c_exploit
        assert 'main(' in c_exploit
        
        # Ruby exploit  
        ruby_exploit = self.compiler.generate_ruby_exploit(vuln_info)
        assert 'require' in ruby_exploit
        assert 'Rex::' in ruby_exploit or 'Metasploit' in ruby_exploit
        
    def test_remote_exploit_compilation(self):
        """Test compiling remote exploit with networking."""
        vuln_info = {
            'type': 'remote_buffer_overflow',
            'offset': 200,
            'host': '192.168.1.100',
            'port': 9999,
            'protocol': 'tcp'
        }
        
        exploit = self.compiler.compile_remote_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'socket' in exploit['code']
        assert str(vuln_info['port']) in exploit['code']
        assert vuln_info['host'] in exploit['code']
        
        # Should have connection code
        assert 'connect' in exploit['code']
        assert 'send' in exploit['code'] or 'sendall' in exploit['code']
        
    def test_multi_stage_exploit_compilation(self):
        """Test compiling multi-stage exploits."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'space_limit': 100,  # Limited space, need staging
            'target': str(self.buffer_overflow)
        }
        
        exploit = self.compiler.compile_staged_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'stage1' in exploit
        assert 'stage2' in exploit
        assert len(exploit['stage1']) <= vuln_info['space_limit']
        assert len(exploit['stage2']) > vuln_info['space_limit']
        
    def test_egg_hunter_exploit_compilation(self):
        """Test compiling egg hunter exploits."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 70,  # Small space
            'additional_buffer': True,  # Can place shellcode elsewhere
            'target': str(self.buffer_overflow)
        }
        
        exploit = self.compiler.compile_egghunter_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'egg' in exploit
        assert 'hunter' in exploit
        assert len(exploit['hunter']) < 50  # Egg hunters are tiny
        assert exploit['egg'] in exploit['shellcode_with_egg']
        
    def test_unicode_exploit_compilation(self):
        """Test compiling unicode/alphanumeric exploits."""
        vuln_info = {
            'type': 'unicode_overflow',
            'offset': 200,
            'encoding': 'unicode',
            'target': 'unicode_app.exe'
        }
        
        exploit = self.compiler.compile_unicode_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'encoded_payload' in exploit
        
        # Check encoding
        payload = exploit['encoded_payload']
        if isinstance(payload, str):
            # All chars should be alphanumeric
            assert all(c.isalnum() for c in payload)
            
    def test_seh_exploit_compilation(self):
        """Test compiling SEH overwrite exploits."""
        vuln_info = {
            'type': 'seh_overwrite',
            'offset_to_seh': 1000,
            'pop_pop_ret': 0x10011234,  # PPR gadget
            'target': 'seh_app.exe'
        }
        
        exploit = self.compiler.compile_seh_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'seh_record' in exploit
        assert 'nseh' in exploit
        
        # Should have jump over SEH
        nseh = exploit['nseh']
        assert len(nseh) == 4
        assert nseh[0] == 0xEB  # Short jump
        
    def test_integer_overflow_exploit_compilation(self):
        """Test compiling integer overflow exploits."""
        vuln_info = {
            'type': 'integer_overflow',
            'vulnerable_calculation': 'size * count',
            'overflow_value': 0x100000001,
            'target': str(self.heap_overflow)
        }
        
        exploit = self.compiler.compile_integer_overflow_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'trigger_values' in exploit
        assert exploit['trigger_values']['result'] < exploit['trigger_values']['intended']
        
    def test_use_after_free_exploit_compilation(self):
        """Test compiling use-after-free exploits."""
        vuln_info = {
            'type': 'use_after_free',
            'object_size': 0x40,
            'spray_count': 1000,
            'target': 'uaf_app.exe'
        }
        
        exploit = self.compiler.compile_uaf_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        assert 'heap_spray' in exploit
        assert 'fake_object' in exploit
        assert len(exploit['fake_object']) == vuln_info['object_size']
        
    def test_exploit_reliability_features(self):
        """Test exploit reliability improvements."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'target': str(self.buffer_overflow),
            'reliability_features': ['heap_spray', 'nop_sled', 'egg_hunter']
        }
        
        exploit = self.compiler.compile_reliable_exploit(vuln_info)
        
        self.assert_real_output(exploit)
        
        # Check reliability features
        assert 'nop_sled' in exploit
        assert len(exploit['nop_sled']) >= 100
        assert 'heap_spray' in exploit
        assert 'success_rate' in exploit
        assert exploit['success_rate'] > 0.7  # Should be reliable
        
    def test_exploit_obfuscation(self):
        """Test exploit code obfuscation."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'target': str(self.buffer_overflow)
        }
        
        # Generate normal exploit
        normal = self.compiler.compile_exploit(vuln_info)
        
        # Generate obfuscated exploit
        obfuscated = self.compiler.compile_exploit(vuln_info, obfuscate=True)
        
        self.assert_real_output(obfuscated)
        
        # Should be different but functionally equivalent
        assert normal['code'] != obfuscated['code']
        assert normal['payload'] == obfuscated['payload']
        
        # Check obfuscation applied
        assert 'obfuscation' in obfuscated
        assert len(obfuscated['obfuscation']) > 0
        
    def test_exploit_encoding_options(self):
        """Test different payload encoding options."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'bad_chars': b'\x00\x0a\x0d\x20',
            'target': str(self.buffer_overflow)
        }
        
        # Test different encoders
        encoders = ['xor', 'alpha_mixed', 'unicode_mixed', 'base64']
        
        for encoder in encoders:
            exploit = self.compiler.compile_exploit(
                vuln_info,
                encoder=encoder
            )
            
            self.assert_real_output(exploit)
            assert exploit['encoder'] == encoder
            
            # Check bad chars avoided
            payload = exploit['encoded_payload']
            for bad in vuln_info['bad_chars']:
                assert bytes([bad]) not in payload
                
    def test_platform_specific_exploits(self):
        """Test platform-specific exploit generation."""
        # Windows exploit
        win_exploit = self.compiler.compile_windows_exploit({
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'target': 'windows_app.exe'
        })
        
        self.assert_real_output(win_exploit)
        assert 'VirtualProtect' in win_exploit['code'] or 'kernel32' in win_exploit['code']
        
        # Linux exploit
        linux_exploit = self.compiler.compile_linux_exploit({
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'target': 'linux_app'
        })
        
        assert 'mprotect' in linux_exploit['code'] or '/bin/sh' in linux_exploit['code']
        
    def test_exploit_validation(self):
        """Test exploit validation before deployment."""
        vuln_info = {
            'type': 'stack_buffer_overflow',
            'offset': 140,
            'target': str(self.buffer_overflow)
        }
        
        exploit = self.compiler.compile_exploit(vuln_info)
        
        # Validate exploit
        validation = self.compiler.validate_exploit(exploit, vuln_info)
        
        self.assert_real_output(validation)
        assert 'valid' in validation
        assert 'warnings' in validation
        assert 'payload_size' in validation
        
        # Check validation passed
        if not validation['valid']:
            assert len(validation['errors']) > 0
            
    def test_metasploit_module_generation(self):
        """Test generating Metasploit modules."""
        vuln_info = {
            'type': 'remote_buffer_overflow',
            'offset': 200,
            'host': '192.168.1.100',
            'port': 9999,
            'service_name': 'TestService',
            'target': 'test_service.exe'
        }
        
        msf_module = self.compiler.generate_metasploit_module(vuln_info)
        
        self.assert_real_output(msf_module)
        assert 'Msf::Exploit::Remote' in msf_module
        assert 'def exploit' in msf_module
        assert "'Name'" in msf_module
        assert str(vuln_info['port']) in msf_module