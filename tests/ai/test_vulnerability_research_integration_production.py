"""Production tests for vulnerability research integration.

Tests AI-powered licensing protection analysis and bypass strategy generation.
"""

import json
import os
import tempfile
from pathlib import Path
from typing import Any

import pytest

from intellicrack.ai.vulnerability_research_integration import LicensingProtectionAnalyzer


@pytest.fixture
def analyzer() -> LicensingProtectionAnalyzer:
    """Create licensing protection analyzer."""
    return LicensingProtectionAnalyzer()


@pytest.fixture
def test_binary() -> str:
    """Create test binary with licensing strings."""
    with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as f:
        f.write(b"MZ")
        f.write(b"\x00" * 100)
        f.write(b"license_key_validation")
        f.write(b"\x00" * 50)
        f.write(b"trial_expired")
        f.write(b"\x00" * 50)
        f.write(b"activate_product")
        f.write(b"\x00" * 50)
        f.write(b"hardware_fingerprint")
        return f.name


def test_analyzer_initialization(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test analyzer initializes with correct configuration."""
    assert analyzer.config["auto_analysis_threshold"] == 0.7
    assert analyzer.config["pattern_confidence_threshold"] == 0.8
    assert analyzer.config["max_analysis_attempts"] == 3
    assert analyzer.config["adaptive_strategy_enabled"] is True

    assert len(analyzer.protection_patterns) > 0  # type: ignore[unreachable]
    assert "serial_validation" in analyzer.protection_patterns
    assert "trial_limitations" in analyzer.protection_patterns
    assert "online_activation" in analyzer.protection_patterns


def test_analyze_licensing_protection_success(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test successful licensing protection analysis."""
    try:
        result = analyzer.analyze_licensing_protection(test_binary)

        assert result["success"] is True
        assert result["target_path"] == test_binary
        assert "analysis_results" in result
        assert "protection_mechanisms" in result
        assert "ai_recommendations" in result
        assert "bypass_strategies" in result
        assert "risk_assessment" in result
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_analyze_nonexistent_file(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test handling of non-existent files."""
    result = analyzer.analyze_licensing_protection("/nonexistent/file.exe")

    assert result["success"] is False
    assert "not found" in result["error"]


def test_extract_licensing_strings(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test licensing string extraction."""
    try:
        strings = analyzer._extract_licensing_strings(test_binary)

        assert isinstance(strings, list)
        assert any("license" in s.lower() for s in strings)
        assert any("trial" in s.lower() for s in strings)
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_categorize_strings(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test string categorization."""
    test_strings = [
        "license_key",
        "serial_number",
        "trial_expired",
        "activate_online",
        "hardware_id",
    ]

    categories = analyzer._categorize_strings(test_strings)

    assert "serial_validation" in categories
    assert "trial_limitations" in categories
    assert "online_activation" in categories
    assert "hardware_binding" in categories


def test_detect_licensing_patterns_with_ai(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test AI pattern detection."""
    try:
        initial_analysis = analyzer._perform_initial_licensing_analysis(test_binary, None)
        ai_patterns = analyzer._detect_licensing_patterns_with_ai(test_binary, initial_analysis)

        assert ai_patterns["success"] is True
        assert isinstance(ai_patterns["detected_patterns"], list)
        assert isinstance(ai_patterns["confidence_scores"], dict)
        assert isinstance(ai_patterns["insights"], list)
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_classify_protection_mechanisms(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test protection mechanism classification."""
    initial_analysis: dict[str, list[str]] = {"licensing_indicators": []}
    ai_patterns = {
        "detected_patterns": ["serial_key_validation", "trial_period_check"],
        "confidence_scores": {
            "serial_key_validation": 0.9,
            "trial_period_check": 0.85,
        },
    }

    mechanisms = analyzer._classify_protection_mechanisms(initial_analysis, ai_patterns)

    assert len(mechanisms) == 2
    assert mechanisms[0]["confidence"] >= mechanisms[1]["confidence"]

    assert any(m["type"] == "Serial Key Protection" for m in mechanisms)
    assert any(m["type"] == "Trial Period Limitation" for m in mechanisms)


def test_generate_bypass_recommendations(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test bypass recommendation generation."""
    protection_mechanisms = [
        {
            "type": "Serial Key Protection",
            "confidence": 0.9,
            "complexity": "medium",
        },
        {
            "type": "Online Activation",
            "confidence": 0.85,
            "complexity": "high",
        },
    ]

    recommendations = analyzer._generate_bypass_recommendations({}, {}, protection_mechanisms)

    assert len(recommendations) > 0
    assert any("serial" in r.lower() for r in recommendations)
    assert any("online activation" in r.lower() or "activation" in r.lower() for r in recommendations)


def test_perform_bypass_risk_assessment(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test bypass risk assessment."""
    try:
        protection_mechanisms = [
            {"type": "Serial Key Protection", "complexity": "medium", "confidence": 0.9},
            {"type": "Online Activation", "complexity": "high", "confidence": 0.8},
        ]

        risk = analyzer._perform_bypass_risk_assessment(test_binary, protection_mechanisms)

        assert "overall_risk" in risk
        assert risk["overall_risk"] in ["low", "medium", "high"]
        assert "risk_score" in risk
        assert 0.0 <= risk["risk_score"] <= 1.0
        assert "bypass_difficulty" in risk
        assert isinstance(risk["risk_factors"], list)
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_generate_bypass_strategies(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test bypass strategy generation."""
    try:
        protection_mechanisms = [
            {
                "type": "Serial Key Protection",
                "complexity": "medium",
                "confidence": 0.9,
                "tools_required": ["IDA Pro", "x64dbg"],
            },
        ]

        risk_assessment = {"overall_risk": "medium", "risk_score": 0.5}

        strategies = analyzer._generate_bypass_strategies(test_binary, protection_mechanisms, risk_assessment)

        assert len(strategies) == 1
        assert strategies[0]["target_protection"] == "Serial Key Protection"
        assert "approach" in strategies[0]
        assert "estimated_time" in strategies[0]
        assert "steps" in strategies[0]
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_determine_bypass_approach(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test bypass approach determination."""
    mechanisms = [
        {"type": "Serial Key Protection"},
        {"type": "Trial Period Limitation"},
        {"type": "Online Activation"},
        {"type": "Hardware ID Binding"},
    ]

    for mech in mechanisms:
        approach = analyzer._determine_bypass_approach(mech)
        assert isinstance(approach, str)
        assert len(approach) > 0


def test_estimate_bypass_time(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test bypass time estimation."""
    mechanisms = [
        {"complexity": "low"},
        {"complexity": "medium"},
        {"complexity": "high"},
    ]

    for mech in mechanisms:
        time_estimate = analyzer._estimate_bypass_time(mech)
        assert isinstance(time_estimate, str)
        assert "hour" in time_estimate or "minute" in time_estimate


def test_generate_bypass_steps(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test bypass step generation."""
    mechanism = {"type": "Serial Key Protection"}

    steps = analyzer._generate_bypass_steps(mechanism)

    assert isinstance(steps, list)
    assert len(steps) > 0
    assert all(isinstance(step, str) for step in steps)


def test_get_analysis_insights(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test analysis insights generation."""
    insights = analyzer.get_analysis_insights()

    assert "global_insights" in insights
    assert "target_specific_insights" in insights
    assert "recommendations" in insights
    assert "trends" in insights


def test_get_analysis_insights_with_target_info(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test insights with target information."""
    target_info = {
        "platform": "windows",
        "file_size": 10 * 1024 * 1024,
    }

    insights = analyzer.get_analysis_insights(target_info)

    assert "target_specific_insights" in insights
    assert insights["target_specific_insights"]["platform"] == "windows"


def test_recommend_tools_for_target(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test tool recommendation."""
    windows_target = {"platform": "windows"}
    linux_target = {"platform": "linux"}
    other_target = {"platform": "macos"}

    windows_tools = analyzer._recommend_tools_for_target(windows_target)
    linux_tools = analyzer._recommend_tools_for_target(linux_target)
    other_tools = analyzer._recommend_tools_for_target(other_target)

    assert isinstance(windows_tools, list)
    assert isinstance(linux_tools, list)
    assert isinstance(other_tools, list)


def test_analyze_protection_trends(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test protection trend analysis."""
    trends = analyzer._analyze_protection_trends()

    assert isinstance(trends, list)
    assert all("trend" in t and "direction" in t for t in trends)


def test_generate_strategic_recommendations(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test strategic recommendation generation."""
    insights = {
        "global_insights": {
            "common_protections": ["Online Activation", "Hardware ID Binding"],
            "success_rate": 0.6,
        },
    }

    recommendations = analyzer._generate_strategic_recommendations(insights)

    assert isinstance(recommendations, list)
    assert len(recommendations) > 0


def test_generate_optimization_suggestions(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test optimization suggestion generation."""
    suggestions = analyzer._generate_optimization_suggestions()

    assert isinstance(suggestions, list)
    assert len(suggestions) > 0


def test_analysis_workflow_logging(analyzer: LicensingProtectionAnalyzer, test_binary: str) -> None:
    """Test analysis workflow is logged."""
    try:
        initial_count = len(analyzer.ai_recommendations)

        result = analyzer.analyze_licensing_protection(test_binary)

        assert len(analyzer.ai_recommendations) == initial_count + 1

        log_entry = analyzer.ai_recommendations[-1]
        assert "timestamp" in log_entry
        assert "target_path" in log_entry
        assert log_entry["target_path"] == test_binary
    finally:
        Path(test_binary).unlink(missing_ok=True)


def test_protection_pattern_database(analyzer: LicensingProtectionAnalyzer) -> None:
    """Test protection pattern database completeness."""
    assert "serial_validation" in analyzer.protection_patterns
    assert "trial_limitations" in analyzer.protection_patterns
    assert "online_activation" in analyzer.protection_patterns
    assert "hardware_binding" in analyzer.protection_patterns
    assert "subscription" in analyzer.protection_patterns

    for pattern_type, keywords in analyzer.protection_patterns.items():
        assert isinstance(keywords, list)
        assert len(keywords) > 0
