"""
Tests for Automated Exploit Chain Builder

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import pytest
from unittest.mock import Mock, patch

from intellicrack.ai.exploit_chain_builder import (
    AutomatedExploitChainBuilder,
    ExploitChainFramework,
    ExploitPrimitiveLibrary,
    SafetyVerificationSystem,
    Vulnerability,
    ExploitType,
    ExploitPrimitive,
    ExploitStep,
    ExploitChain,
    ChainComplexity
)
from intellicrack.ai.llm_backends import LLMManager, LLMResponse


class TestExploitPrimitiveLibrary:
    """Test exploit primitive library."""

    def setup_method(self):
        """Set up test instance."""
        self.library = ExploitPrimitiveLibrary()

    def test_initialization(self):
        """Test library initialization."""
        assert len(self.library.primitives) > 0
        assert ExploitPrimitive.MEMORY_CORRUPTION in self.library.primitives
        assert ExploitPrimitive.CONTROL_FLOW_HIJACK in self.library.primitives
        assert len(self.library.primitives[ExploitPrimitive.MEMORY_CORRUPTION]) > 0

    def test_get_primitive_without_requirements(self):
        """Test getting primitive without requirements."""
        primitive = self.library.get_primitive(ExploitPrimitive.MEMORY_CORRUPTION)
        assert primitive is not None
        assert "name" in primitive
        assert "template" in primitive
        assert "reliability" in primitive

    def test_get_primitive_with_requirements(self):
        """Test getting primitive with specific requirements."""
        requirements = ["buffer_size_known", "return_address_offset"]
        primitive = self.library.get_primitive(
            ExploitPrimitive.MEMORY_CORRUPTION, 
            requirements
        )
        assert primitive is not None
        # Should return stack_buffer_overflow which matches requirements
        assert "stack_buffer_overflow" in primitive["name"]

    def test_get_primitive_nonexistent(self):
        """Test getting non-existent primitive type."""
        # Create a new enum value for testing (this would normally not exist)
        result = self.library.get_primitive(ExploitPrimitive.TIMING_ATTACK)
        assert result is None

    def test_add_primitive(self):
        """Test adding new primitive."""
        new_primitive = {
            "name": "test_primitive",
            "description": "Test primitive",
            "template": "test code",
            "reliability": 0.8
        }

        initial_count = len(self.library.primitives[ExploitPrimitive.MEMORY_CORRUPTION])
        self.library.add_primitive(ExploitPrimitive.MEMORY_CORRUPTION, new_primitive)

        assert len(self.library.primitives[ExploitPrimitive.MEMORY_CORRUPTION]) == initial_count + 1
        assert new_primitive in self.library.primitives[ExploitPrimitive.MEMORY_CORRUPTION]

    def test_score_primitive(self):
        """Test primitive scoring algorithm."""
        primitive = {
            "prerequisites": ["req1", "req2"],
            "reliability": 0.8
        }
        requirements = ["req1", "req2", "req3"]

        score = self.library._score_primitive(primitive, requirements)
        assert 0.0 <= score <= 1.0
        # Should score high since 2/2 prerequisites are met
        assert score > 0.7


class TestExploitChainFramework:
    """Test exploit chain framework."""

    def setup_method(self):
        """Set up test instance."""
        self.framework = ExploitChainFramework()

    def test_initialization(self):
        """Test framework initialization."""
        assert len(self.framework.chain_templates) > 0
        assert "simple_buffer_overflow" in self.framework.chain_templates
        assert "rop_exploitation" in self.framework.chain_templates

    def test_build_exploit_chain_buffer_overflow(self):
        """Test building chain for buffer overflow."""
        vulnerability = Vulnerability(
            vuln_id="test_vuln_001",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Stack buffer overflow in input parser",
            location={"function": "parse_input", "line": 42}
        )

        chain = self.framework.build_exploit_chain(vulnerability)
        assert chain is not None
        assert chain.target_vulnerability == vulnerability.vuln_id
        assert len(chain.steps) > 0
        assert chain.complexity in ChainComplexity
        assert 0.0 <= chain.success_probability <= 1.0

    def test_build_exploit_chain_heap_vuln(self):
        """Test building chain for heap vulnerability."""
        vulnerability = Vulnerability(
            vuln_id="test_vuln_002",
            vuln_type=ExploitType.USE_AFTER_FREE,
            severity="critical",
            description="Use-after-free in object destructor",
            location={"function": "~Object", "line": 123}
        )

        chain = self.framework.build_exploit_chain(vulnerability)
        assert chain is not None
        assert chain.complexity != ChainComplexity.SIMPLE  # Heap exploits are more complex

    def test_select_chain_template(self):
        """Test chain template selection."""
        vuln = Vulnerability(
            vuln_id="test",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Test",
            location={}
        )

        template = self.framework._select_chain_template(vuln)
        assert template is not None
        assert ExploitPrimitive.MEMORY_CORRUPTION in template

    def test_calculate_complexity(self):
        """Test complexity calculation."""
        # Simple chain
        simple_steps = [
            ExploitStep("1", ExploitPrimitive.MEMORY_CORRUPTION, "step1", "code1", reliability=0.9),
            ExploitStep("2", ExploitPrimitive.SHELLCODE_INJECTION, "step2", "code2", reliability=0.8)
        ]
        complexity = self.framework._calculate_complexity(simple_steps)
        assert complexity in [ChainComplexity.SIMPLE, ChainComplexity.MODERATE]

        # Complex chain
        complex_steps = [ExploitStep(f"{i}", ExploitPrimitive.MEMORY_CORRUPTION, f"step{i}", f"code{i}", reliability=0.5) 
                        for i in range(8)]
        complexity = self.framework._calculate_complexity(complex_steps)
        assert complexity == ChainComplexity.EXPERT

    def test_calculate_success_probability(self):
        """Test success probability calculation."""
        steps = [
            ExploitStep("1", ExploitPrimitive.MEMORY_CORRUPTION, "step1", "code1", reliability=0.8),
            ExploitStep("2", ExploitPrimitive.CONTROL_FLOW_HIJACK, "step2", "code2", reliability=0.9)
        ]

        prob = self.framework._calculate_success_probability(steps)
        assert prob == 0.8 * 0.9  # Product of reliabilities
        assert 0.0 <= prob <= 1.0


class TestSafetyVerificationSystem:
    """Test safety verification system."""

    def setup_method(self):
        """Set up test instance."""
        self.safety_system = SafetyVerificationSystem()

    def test_initialization(self):
        """Test safety system initialization."""
        assert len(self.safety_system.safety_rules) > 0
        assert "no_destructive_operations" in [rule["rule_id"] for rule in self.safety_system.safety_rules]

    def test_verify_safe_chain(self):
        """Test verification of safe chain."""
        safe_steps = [
            ExploitStep(
                "1", 
                ExploitPrimitive.INFORMATION_DISCLOSURE, 
                "Safe information disclosure", 
                "printf('leaked: %p', ptr);",
                reliability=0.8
            )
        ]

        safe_chain = ExploitChain(
            chain_id="safe_chain",
            name="Safe Chain",
            target_vulnerability="vuln_001",
            steps=safe_steps,
            complexity=ChainComplexity.SIMPLE,
            success_probability=0.8,
            total_execution_time=1.0,
            memory_footprint=1024,
            stealth_rating=0.9,
            stability_rating=0.8
        )

        report = self.safety_system.verify_chain_safety(safe_chain)
        assert report["is_safe"] == True
        assert report["risk_level"] == "low"
        assert len(report["violations"]) == 0

    def test_verify_unsafe_chain(self):
        """Test verification of unsafe chain."""
        unsafe_steps = [
            ExploitStep(
                "1",
                ExploitPrimitive.MEMORY_CORRUPTION,
                "Destructive operation",
                "system('rm -rf /'); // Destructive!",
                reliability=0.8
            )
        ]

        unsafe_chain = ExploitChain(
            chain_id="unsafe_chain",
            name="Unsafe Chain",
            target_vulnerability="vuln_002",
            steps=unsafe_steps,
            complexity=ChainComplexity.SIMPLE,
            success_probability=0.8,
            total_execution_time=1.0,
            memory_footprint=1024,
            stealth_rating=0.1,
            stability_rating=0.8
        )

        report = self.safety_system.verify_chain_safety(unsafe_chain)
        assert report["is_safe"] == False
        assert report["risk_level"] == "critical"
        assert len(report["violations"]) > 0

    def test_check_step_safety(self):
        """Test individual step safety checking."""
        unsafe_step = ExploitStep(
            "1",
            ExploitPrimitive.MEMORY_CORRUPTION,
            "Registry modification",
            "RegSetValueEx(HKEY_LOCAL_MACHINE, ...);",
            reliability=0.8
        )

        violations = self.safety_system._check_step_safety(unsafe_step)
        assert len(violations) > 0
        assert any(v["rule_id"] == "no_system_modification" for v in violations)


class TestAutomatedExploitChainBuilder:
    """Test automated exploit chain builder."""

    def setup_method(self):
        """Set up test instance."""
        self.mock_llm = Mock(spec=LLMManager)
        self.builder = AutomatedExploitChainBuilder(self.mock_llm)

    def test_initialization(self):
        """Test builder initialization."""
        assert self.builder.llm_manager is not None
        assert self.builder.primitive_lib is not None
        assert self.builder.chain_framework is not None
        assert self.builder.safety_system is not None
        assert len(self.builder.built_chains) == 0

    def test_build_exploit_chain_success(self):
        """Test successful exploit chain building."""
        vulnerability = Vulnerability(
            vuln_id="test_vuln_003",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Buffer overflow in network parser",
            location={"function": "parse_packet", "line": 156}
        )

        # Mock LLM response
        self.mock_llm.generate_response.return_value = LLMResponse(
            content="Suggestions: Improve reliability with error checking",
            metadata={}
        )

        chain = self.builder.build_exploit_chain(vulnerability)
        assert chain is not None
        assert chain.target_vulnerability == vulnerability.vuln_id
        assert chain.chain_id in self.builder.built_chains
        assert chain.safety_verified in [True, False]  # Should be set

    def test_build_exploit_chain_caching(self):
        """Test exploit chain caching."""
        vulnerability = Vulnerability(
            vuln_id="test_vuln_004",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="medium",
            description="Identical vulnerability for caching test",
            location={"function": "test_func", "line": 1}
        )

        # Mock LLM response
        self.mock_llm.generate_response.return_value = LLMResponse(
            content="Test response",
            metadata={}
        )

        # Build first chain
        chain1 = self.builder.build_exploit_chain(vulnerability)
        assert chain1 is not None

        # Build second chain (should use cache)
        chain2 = self.builder.build_exploit_chain(vulnerability)
        assert chain2 is not None
        assert chain1.chain_id == chain2.chain_id

    def test_validate_chain(self):
        """Test chain validation."""
        # Create test chain
        steps = [
            ExploitStep(
                "1",
                ExploitPrimitive.MEMORY_CORRUPTION,
                "Test step",
                "test code",
                prerequisites=["req1"],
                outputs=["out1"],
                reliability=0.8
            ),
            ExploitStep(
                "2",
                ExploitPrimitive.CONTROL_FLOW_HIJACK,
                "Second step",
                "test code 2",
                prerequisites=["out1"],  # Should be satisfied by previous step
                reliability=0.7
            )
        ]

        chain = ExploitChain(
            chain_id="test_validation",
            name="Test Chain",
            target_vulnerability="vuln_001",
            steps=steps,
            complexity=ChainComplexity.MODERATE,
            success_probability=0.56,  # 0.8 * 0.7
            total_execution_time=2.0,
            memory_footprint=2048,
            stealth_rating=0.5,
            stability_rating=0.56
        )

        self.builder.built_chains[chain.chain_id] = chain

        result = self.builder.validate_chain(chain.chain_id)
        assert result.is_valid == True
        assert result.confidence > 0.5
        assert len(result.issues) == 0

    def test_validate_chain_missing_prerequisites(self):
        """Test validation with missing prerequisites."""
        steps = [
            ExploitStep(
                "1",
                ExploitPrimitive.CONTROL_FLOW_HIJACK,
                "Step with missing prereqs",
                "test code",
                prerequisites=["missing_req"],  # This requirement is not satisfied
                reliability=0.8
            )
        ]

        chain = ExploitChain(
            chain_id="test_invalid",
            name="Invalid Chain",
            target_vulnerability="vuln_002",
            steps=steps,
            complexity=ChainComplexity.SIMPLE,
            success_probability=0.8,
            total_execution_time=1.0,
            memory_footprint=1024,
            stealth_rating=0.5,
            stability_rating=0.8
        )

        self.builder.built_chains[chain.chain_id] = chain

        result = self.builder.validate_chain(chain.chain_id)
        assert result.is_valid == False
        assert len(result.issues) > 0
        assert "missing prerequisites" in result.issues[0].lower()

    def test_get_chain_statistics(self):
        """Test chain statistics."""
        # Add some test chains
        for i in range(3):
            chain = ExploitChain(
                chain_id=f"test_stats_{i}",
                name=f"Test Chain {i}",
                target_vulnerability=f"vuln_{i}",
                steps=[],
                complexity=ChainComplexity.SIMPLE,
                success_probability=0.7 + (i * 0.1),
                total_execution_time=1.0,
                memory_footprint=1024,
                stealth_rating=0.5,
                stability_rating=0.7,
                safety_verified=(i % 2 == 0),
                tested=(i == 2)
            )
            self.builder.built_chains[chain.chain_id] = chain

        stats = self.builder.get_chain_statistics()
        assert stats["total_chains"] == 3
        assert 0.7 <= stats["avg_success_probability"] <= 1.0
        assert stats["safety_verified"] == 2  # chains 0 and 2
        assert stats["tested_chains"] == 1   # only chain 2
        assert "simple" in stats["complexity_distribution"]

    def test_hash_vulnerability(self):
        """Test vulnerability hashing for caching."""
        vuln1 = Vulnerability(
            vuln_id="test_hash_1",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Test vulnerability",
            location={"function": "test", "line": 1}
        )

        vuln2 = Vulnerability(
            vuln_id="test_hash_2",  # Different ID
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Test vulnerability",  # Same description and location
            location={"function": "test", "line": 1}
        )

        hash1 = self.builder._hash_vulnerability(vuln1)
        hash2 = self.builder._hash_vulnerability(vuln2)

        # Should be same hash since type, description, location are same
        assert hash1 == hash2
        assert len(hash1) == 32  # MD5 hash length

    @patch('intellicrack.ai.exploit_chain_builder.learning_engine')
    def test_learning_integration(self, mock_learning):
        """Test integration with learning engine."""
        vulnerability = Vulnerability(
            vuln_id="test_learning",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="high",
            description="Learning test vulnerability",
            location={"function": "test_learning", "line": 1}
        )

        # Mock LLM response
        self.mock_llm.generate_response.return_value = LLMResponse(
            content="Test response",
            metadata={}
        )

        chain = self.builder.build_exploit_chain(vulnerability)
        assert chain is not None

        # Verify learning engine was called
        mock_learning.record_exploit_chain_creation.assert_called_once()
        call_args = mock_learning.record_exploit_chain_creation.call_args
        assert call_args[1]["vulnerability"] == vulnerability
        assert call_args[1]["chain"] == chain
        assert call_args[1]["success"] == True


@pytest.mark.integration
class TestExploitChainBuilderIntegration:
    """Integration tests for exploit chain builder."""

    def test_full_workflow(self):
        """Test complete exploit chain building workflow."""
        # Create real vulnerability
        vulnerability = Vulnerability(
            vuln_id="integration_test_001",
            vuln_type=ExploitType.BUFFER_OVERFLOW,
            severity="critical",
            description="Stack buffer overflow in authentication module",
            location={
                "file": "auth.c",
                "function": "validate_credentials",
                "line": 89
            },
            prerequisites=["network_access", "valid_username"],
            impact={"confidentiality": "high", "integrity": "high", "availability": "medium"},
            confidence=0.95,
            exploitability=0.85
        )

        # Build exploit chain
        builder = AutomatedExploitChainBuilder()
        chain = builder.build_exploit_chain(vulnerability)

        # Verify chain was built
        assert chain is not None
        assert len(chain.steps) > 0
        assert chain.target_vulnerability == vulnerability.vuln_id

        # Validate the chain
        validation = builder.validate_chain(chain.chain_id)
        assert validation is not None

        # Get statistics
        stats = builder.get_chain_statistics()
        assert stats["total_chains"] >= 1

        # Test safety verification was performed
        assert hasattr(chain, 'safety_verified')
        assert hasattr(chain, 'safety_report')

        print(f"Built chain: {chain.name}")
        print(f"Steps: {len(chain.steps)}")
        print(f"Success probability: {chain.success_probability:.2f}")
        print(f"Complexity: {chain.complexity.value}")
        print(f"Safety verified: {chain.safety_verified}")