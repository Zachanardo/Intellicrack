"""Production tests for vulnerability research integration helper.

Tests strategy weight learning and pattern recognition updates.
"""

import json
import os
import tempfile
from pathlib import Path

import pytest

from intellicrack.ai.vulnerability_research_integration_helper import (
    update_pattern_recognition,
    update_strategy_weights,
)


@pytest.fixture
def temp_data_dir() -> str:
    """Create temporary data directory."""
    temp_dir = tempfile.mkdtemp()
    yield temp_dir

    import shutil

    shutil.rmtree(temp_dir, ignore_errors=True)


def test_update_strategy_weights_success(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test strategy weight updates for successful operation."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "success": True,
        "exploit_type": "buffer_overflow",
        "evasion_level": "high",
        "platform": "windows",
    }

    update_strategy_weights(learning_entry)

    weights_path = Path(temp_data_dir) / "strategy_weights.json"
    assert weights_path.exists()

    with open(weights_path) as f:
        weights = json.load(f)

    assert "exploit_types" in weights
    assert "buffer_overflow" in weights["exploit_types"]
    assert weights["exploit_types"]["buffer_overflow"] > 1.0


def test_update_strategy_weights_failure(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test strategy weight updates for failed operation."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "success": False,
        "exploit_type": "use_after_free",
        "evasion_level": "medium",
        "platform": "linux",
    }

    update_strategy_weights(learning_entry)

    weights_path = Path(temp_data_dir) / "strategy_weights.json"
    with open(weights_path) as f:
        weights = json.load(f)

    assert weights["exploit_types"]["use_after_free"] < 1.0


def test_update_strategy_weights_normalization(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test weight normalization prevents drift."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    for _ in range(50):
        learning_entry = {
            "success": True,
            "exploit_type": "format_string",
            "evasion_level": "low",
            "platform": "windows",
        }
        update_strategy_weights(learning_entry)

    weights_path = Path(temp_data_dir) / "strategy_weights.json"
    with open(weights_path) as f:
        weights = json.load(f)

    assert weights["exploit_types"]["format_string"] <= 2.0


def test_update_pattern_recognition_success(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test pattern recognition updates for successful attacks."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "timestamp": 1234567890,
        "success": True,
        "platform": "windows",
        "protections": ["ASLR", "DEP"],
        "exploit_type": "rop_chain",
        "evasion_level": "high",
        "phases_succeeded": ["recon", "exploit", "post"],
        "phases_failed": [],
        "execution_time": 15.5,
    }

    update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    assert patterns_path.exists()

    with open(patterns_path) as f:
        patterns = json.load(f)

    assert "successful_combinations" in patterns
    assert len(patterns["successful_combinations"]) == 1
    assert patterns["successful_combinations"][0]["platform"] == "windows"


def test_update_pattern_recognition_failure(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test pattern recognition updates for failed attacks."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "timestamp": 1234567890,
        "success": False,
        "platform": "linux",
        "protections": ["PIE", "Stack canary"],
        "exploit_type": "stack_overflow",
        "evasion_level": "medium",
        "phases_succeeded": ["recon"],
        "phases_failed": ["exploit"],
        "execution_time": 8.2,
    }

    update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    with open(patterns_path) as f:
        patterns = json.load(f)

    assert len(patterns["failed_combinations"]) == 1


def test_update_pattern_recognition_protection_bypass_tracking(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test protection bypass tracking."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "timestamp": 1234567890,
        "success": True,
        "platform": "windows",
        "protections": ["VMProtect", "Themida"],
        "exploit_type": "virtualization_bypass",
        "evasion_level": "critical",
        "phases_succeeded": ["analyze", "bypass"],
        "phases_failed": [],
        "execution_time": 120.0,
    }

    update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    with open(patterns_path) as f:
        patterns = json.load(f)

    assert "protection_bypasses" in patterns
    assert "VMProtect" in patterns["protection_bypasses"]
    assert "Themida" in patterns["protection_bypasses"]


def test_pattern_history_limit(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test pattern history is limited."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    for i in range(6000):
        learning_entry = {
            "timestamp": i,
            "success": True,
            "platform": "windows",
            "protections": [],
            "exploit_type": "test",
            "evasion_level": "low",
            "phases_succeeded": [],
            "phases_failed": [],
            "execution_time": 1.0,
        }
        update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    with open(patterns_path) as f:
        patterns = json.load(f)

    assert len(patterns["successful_combinations"]) == 5000


def test_protection_bypass_history_limit(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test protection bypass history is limited."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    for i in range(150):
        learning_entry = {
            "timestamp": i,
            "success": True,
            "platform": "windows",
            "protections": ["TestProtection"],
            "exploit_type": "test",
            "evasion_level": "low",
            "phases_succeeded": [],
            "phases_failed": [],
            "execution_time": 1.0,
        }
        update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    with open(patterns_path) as f:
        patterns = json.load(f)

    assert len(patterns["protection_bypasses"]["TestProtection"]) == 100


def test_weights_initialization(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test weights are initialized if file doesn't exist."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "success": True,
        "exploit_type": "heap_spray",
        "evasion_level": "medium",
        "platform": "windows",
    }

    update_strategy_weights(learning_entry)

    weights_path = Path(temp_data_dir) / "strategy_weights.json"
    with open(weights_path) as f:
        weights = json.load(f)

    assert "exploit_types" in weights
    assert "evasion_levels" in weights
    assert "platforms" in weights


def test_patterns_initialization(temp_data_dir: str, monkeypatch: pytest.MonkeyPatch) -> None:
    """Test patterns are initialized if file doesn't exist."""
    monkeypatch.setattr("intellicrack.ai.vulnerability_research_integration_helper.os.path.dirname", lambda x: temp_data_dir)

    learning_entry = {
        "timestamp": 1234567890,
        "success": True,
        "platform": "windows",
        "protections": [],
        "exploit_type": "test",
        "evasion_level": "low",
        "phases_succeeded": [],
        "phases_failed": [],
        "execution_time": 1.0,
    }

    update_pattern_recognition(learning_entry)

    patterns_path = Path(temp_data_dir) / "ai_patterns.json"
    with open(patterns_path) as f:
        patterns = json.load(f)

    assert "successful_combinations" in patterns
    assert "failed_combinations" in patterns
    assert "protection_bypasses" in patterns
