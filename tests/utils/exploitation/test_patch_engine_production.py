"""Production tests for binary patch engine.

Tests real binary patching operations for defeating software licensing protections.
NO mocks - validates actual binary modification and license check bypassing.

Copyright (C) 2025 Zachary Flint
"""

import hashlib
import os
import shutil
import tempfile
from collections.abc import Generator
from pathlib import Path
from typing import Any

import pytest

from intellicrack.utils.exploitation.patch_engine import (
    BinaryPatchEngine,
    run_patch_validation,
    show_analysis_results,
)


@pytest.fixture
def temp_dir() -> Generator[Path, None, None]:
    """Create temporary directory for test binaries."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def simple_pe_binary(temp_dir: Path) -> Path:
    """Create a simple PE binary for patching tests."""
    binary_path = temp_dir / "test.exe"

    # Minimal PE header + code section with licensing checks
    pe_data = bytearray()

    # DOS header
    pe_data.extend(b'MZ')  # DOS signature
    pe_data.extend(b'\x90' * 58)  # DOS stub
    pe_data.extend(b'\x3C\x00\x00\x00')  # PE offset at 0x3C

    # Padding to PE header
    pe_data.extend(b'\x00' * (0x80 - len(pe_data)))

    # PE signature
    pe_data.extend(b'PE\x00\x00')

    # COFF header (minimal)
    pe_data.extend(b'\x4C\x01')  # Machine (x86)
    pe_data.extend(b'\x01\x00')  # NumberOfSections
    pe_data.extend(b'\x00' * 12)  # Timestamp, etc
    pe_data.extend(b'\xE0\x00')  # SizeOfOptionalHeader
    pe_data.extend(b'\x0F\x01')  # Characteristics

    # Optional header (minimal)
    pe_data.extend(b'\x0B\x01')  # Magic (PE32)
    pe_data.extend(b'\x00' * 222)  # Rest of optional header

    # Section header
    pe_data.extend(b'.text\x00\x00\x00')  # Name
    pe_data.extend(b'\x00\x10\x00\x00')  # VirtualSize
    pe_data.extend(b'\x00\x10\x00\x00')  # VirtualAddress
    pe_data.extend(b'\x00\x02\x00\x00')  # SizeOfRawData
    pe_data.extend(b'\x00\x02\x00\x00')  # PointerToRawData
    pe_data.extend(b'\x00' * 12)  # Relocations, etc
    pe_data.extend(b'\x20\x00\x00\x60')  # Characteristics (CODE | EXECUTE | READ)

    # Padding to code section
    code_offset = 0x200
    pe_data.extend(b'\x00' * (code_offset - len(pe_data)))

    # Code section with licensing patterns
    # Pattern 1: Registration check (TEST AL, AL; JE)
    pe_data.extend(b'\x84\xC0')  # TEST AL, AL
    pe_data.extend(b'\x74\x05')  # JE +5 (jump if not registered)
    pe_data.extend(b'\xB8\x01\x00\x00\x00')  # MOV EAX, 1 (success)
    pe_data.extend(b'\xC3')  # RET

    # Pattern 2: License valid check (TEST EAX, EAX; JE)
    pe_data.extend(b'\x85\xC0')  # TEST EAX, EAX
    pe_data.extend(b'\x74\x05')  # JE +5 (jump if invalid)
    pe_data.extend(b'\xB8\x01\x00\x00\x00')  # MOV EAX, 1
    pe_data.extend(b'\xC3')  # RET

    # Pattern 3: Days remaining check (CMP EAX, 30)
    pe_data.extend(b'\x83\xF8\x1E')  # CMP EAX, 30
    pe_data.extend(b'\x7C\x05')  # JL +5 (jump if less than 30 days)
    pe_data.extend(b'\xB8\x00\x00\x00\x00')  # MOV EAX, 0 (trial expired)
    pe_data.extend(b'\xC3')  # RET

    # Pattern 4: Long conditional jump
    pe_data.extend(b'\x0F\x84\x00\x00\x00\x00')  # JE (long)
    pe_data.extend(b'\x90\x90')  # NOP NOP

    # Fill rest with NOPs
    pe_data.extend(b'\x90' * (0x400 - len(pe_data)))

    binary_path.write_bytes(bytes(pe_data))
    return binary_path


@pytest.fixture
def patch_engine() -> BinaryPatchEngine:
    """Create patch engine instance."""
    return BinaryPatchEngine()


class TestBinaryPatchEngineInitialization:
    """Test patch engine initialization and instruction sets."""

    def test_engine_initializes_with_x86_instructions(self, patch_engine: BinaryPatchEngine) -> None:
        """Patch engine loads x86/x64 instruction opcodes."""
        assert patch_engine.instructions["nop"] == b"\x90"
        assert patch_engine.instructions["ret"] == b"\xc3"
        assert patch_engine.instructions["mov_eax_1"] == b"\xb8\x01\x00\x00\x00"
        assert patch_engine.instructions["xor_eax_eax"] == b"\x31\xc0"

    def test_engine_has_conditional_jump_conversions(self, patch_engine: BinaryPatchEngine) -> None:
        """Patch engine has complete jump conversion tables."""
        assert 0x74 in patch_engine.jmp_conversions  # JE
        assert 0x75 in patch_engine.jmp_conversions  # JNE
        assert patch_engine.jmp_conversions[0x74] == 0xEB  # -> JMP

        assert b"\x0f\x84" in patch_engine.long_jmp_conversions  # Long JE
        assert patch_engine.long_jmp_conversions[b"\x0f\x84"] == b"\xe9"  # -> JMP


class TestLicensePatternDetection:
    """Test detection of licensing check patterns in binaries."""

    def test_finds_registration_check_pattern(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Detects TEST AL, AL; JE registration check pattern."""
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))

        registration_patterns = [p for p in patterns if p["type"] == "registration"]
        assert registration_patterns

        pattern = registration_patterns[0]
        assert pattern["name"] == "IsRegistered check"
        assert pattern["offset"] >= 0x200  # In code section

    def test_finds_license_valid_pattern(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Detects TEST EAX, EAX; JE license validation pattern."""
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))

        license_patterns = [p for p in patterns if p["type"] == "license"]
        assert license_patterns

        pattern = license_patterns[0]
        assert pattern["name"] == "License valid check"
        assert "offset" in pattern

    def test_finds_trial_check_pattern(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Detects CMP EAX, 30 trial period check."""
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))

        trial_patterns = [p for p in patterns if p["type"] == "trial"]
        assert trial_patterns

        pattern = trial_patterns[0]
        assert pattern["name"] == "Days remaining check"
        assert "context" in pattern  # Has surrounding bytes


class TestDirectBinaryPatching:
    """Test direct binary modification operations."""

    def test_nop_patch_zeros_out_instructions(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """NOP patch replaces instructions with no-ops."""
        patches = [
            {
                "offset": 0x200,  # First instruction in code
                "type": "nop",
                "size": 5,
                "description": "NOP out registration check"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        assert result["patches_applied"] == 1
        assert result["backup_created"] is True

        # Verify bytes were NOPped
        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[0x200:0x205] == b"\x90" * 5

    def test_ret_patch_forces_early_return(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """RET patch forces function to return early."""
        patches = [
            {
                "offset": 0x210,
                "type": "ret",
                "size": 3,
                "description": "Force early return"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[0x210] == 0xC3  # RET opcode
        assert patched_data[0x211:0x213] == b"\x90\x90"  # NOPs

    def test_success_patch_returns_always_true(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Success patch makes function always return 1."""
        patches = [
            {
                "offset": 0x220,
                "type": "success",
                "add_ret": True,
                "description": "Always succeed"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        patched_data = simple_pe_binary.read_bytes()
        # MOV EAX, 1
        assert patched_data[0x220:0x225] == b"\xb8\x01\x00\x00\x00"
        assert patched_data[0x225] == 0xC3  # RET


class TestConditionalJumpConversion:
    """Test conversion of conditional jumps to unconditional for license bypassing."""

    def test_converts_short_conditional_jump(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Converts JE short jump to unconditional JMP."""
        # Find JE instruction
        data = simple_pe_binary.read_bytes()
        je_offset = data.find(b'\x74\x05')  # JE +5
        assert je_offset >= 0

        patches = [
            {
                "offset": je_offset,
                "type": "jmp",
                "description": "Convert JE to JMP"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        assert result["details"][0]["conversion"]  # Has conversion info

        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[je_offset] == 0xEB  # JMP opcode

    def test_converts_long_conditional_jump(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Converts long JE (0F 84) to unconditional JMP."""
        data = simple_pe_binary.read_bytes()
        long_je_offset = data.find(b'\x0F\x84')
        assert long_je_offset >= 0

        patches = [
            {
                "offset": long_je_offset,
                "type": "jmp",
                "description": "Convert long JE to JMP"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[long_je_offset] == 0xE9  # Long JMP opcode


class TestBypassCheckPatching:
    """Test complete license check bypass patching."""

    def test_bypass_check_replaces_function_with_success(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Bypass patch replaces entire function with MOV EAX, 1; RET."""
        patches = [
            {
                "offset": 0x200,
                "type": "bypass_check",
                "size": 20,
                "description": "Bypass entire license check function"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        patched_data = simple_pe_binary.read_bytes()

        # Should be MOV EAX, 1; RET; NOPs
        assert patched_data[0x200:0x205] == b"\xb8\x01\x00\x00\x00"  # MOV EAX, 1
        assert patched_data[0x205] == 0xC3  # RET
        # Rest should be NOPs
        assert all(b == 0x90 for b in patched_data[0x206:0x214])


class TestPatternSearchPatching:
    """Test pattern-based search and replace patching."""

    def test_finds_and_patches_pattern(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Searches for pattern and replaces it."""
        patches = [
            {
                "offset": 0x200,  # Starting search point
                "type": "pattern",
                "pattern": "84C0",  # TEST AL, AL
                "replacement": "9090",  # NOP NOP
                "search_range": 0x100,
                "description": "Replace TEST AL, AL with NOPs"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        assert result["details"][0]["pattern_found_at"]

        patched_data = simple_pe_binary.read_bytes()
        # Verify pattern was replaced
        assert b"\x84\xC0" not in patched_data[0x200:0x300]


class TestBatchPatching:
    """Test applying multiple patches in sequence."""

    def test_applies_multiple_patches_successfully(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Applies multiple license bypass patches in one operation."""
        patches = [
            {
                "offset": 0x200,
                "type": "nop",
                "size": 2,
                "description": "NOP first check"
            },
            {
                "offset": 0x210,
                "type": "jmp",
                "description": "Convert second check"
            },
            {
                "offset": 0x220,
                "type": "success",
                "description": "Force third check success"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        assert result["patches_applied"] == 3
        assert result["patches_failed"] == 0
        assert len(result["details"]) == 3

    def test_tracks_successful_and_failed_patches(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Continues applying patches even if some fail."""
        patches = [
            {
                "offset": 0x200,
                "type": "nop",
                "size": 2,
                "description": "Valid patch"
            },
            {
                "offset": 0xFFFFFF,  # Invalid offset
                "type": "nop",
                "size": 2,
                "description": "Invalid patch"
            },
            {
                "offset": 0x210,
                "type": "ret",
                "description": "Another valid patch"
            }
        ]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["patches_applied"] == 2
        assert result["patches_failed"] == 1
        assert result["details"][1]["error"]  # Second patch failed


class TestBackupAndHashVerification:
    """Test backup creation and binary hash verification."""

    def test_creates_backup_before_patching(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Creates backup file before modifying binary."""
        backup_path = Path(f"{str(simple_pe_binary)}.backup")
        assert not backup_path.exists()

        patches = [{"offset": 0x200, "type": "nop", "size": 1, "description": "Test"}]
        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["backup_created"] is True
        assert backup_path.exists()

        # Verify backup is identical to original
        original_hash = result["original_hash"]
        backup_hash = hashlib.sha256(backup_path.read_bytes()).hexdigest()
        assert original_hash == backup_hash

    def test_preserves_existing_backup(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Does not overwrite existing backup file."""
        backup_path = Path(f"{str(simple_pe_binary)}.backup")
        backup_path.write_bytes(b"existing backup")

        patches = [{"offset": 0x200, "type": "nop", "size": 1, "description": "Test"}]
        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert backup_path.read_bytes() == b"existing backup"

    def test_records_original_and_patched_hashes(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Records SHA256 hashes before and after patching."""
        original_bytes = simple_pe_binary.read_bytes()
        original_hash = hashlib.sha256(original_bytes).hexdigest()

        patches = [{"offset": 0x200, "type": "nop", "size": 5, "description": "Patch"}]
        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["original_hash"] == original_hash
        assert result["patched_hash"] != original_hash  # Changed

        # Verify patched hash matches current file
        patched_hash = hashlib.sha256(simple_pe_binary.read_bytes()).hexdigest()
        assert result["patched_hash"] == patched_hash


class TestPatchConfigGeneration:
    """Test automatic patch configuration generation."""

    def test_generates_patches_for_detected_patterns(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Automatically generates patch configurations from detected patterns."""
        patches = patch_engine.generate_patch_config(str(simple_pe_binary), auto_detect=True)

        assert len(patches) > 0
        for patch in patches:
            assert "offset" in patch
            assert "type" in patch
            assert "description" in patch

    def test_generates_bypass_for_registration_checks(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Generates JMP patches for registration checks."""
        patches = patch_engine.generate_patch_config(str(simple_pe_binary), auto_detect=True)

        registration_patches = [p for p in patches if "registration" in p["description"].lower()]
        assert registration_patches
        assert any(p["type"] == "jmp" for p in registration_patches)

    def test_generates_nop_for_trial_checks(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Generates NOP patches for trial checks."""
        patches = patch_engine.generate_patch_config(str(simple_pe_binary), auto_detect=True)

        trial_patches = [p for p in patches if "trial" in p.get("description", "").lower() or "days" in p.get("description", "").lower()]
        assert trial_patches
        assert any(p["type"] == "nop" for p in trial_patches)


class TestPatchValidation:
    """Test patch validation and test mode."""

    def test_validation_mode_finds_patterns_without_patching(self, simple_pe_binary: Path) -> None:
        """Test mode finds patterns but does not modify binary."""
        original_bytes = simple_pe_binary.read_bytes()

        result = run_patch_validation(
            str(simple_pe_binary),
            [],
            test_mode=True
        )

        assert result["success"] is True
        assert result["test_mode"] is True
        assert result["patterns_found"] > 0
        assert "patterns" in result

        # Binary unchanged
        assert simple_pe_binary.read_bytes() == original_bytes

    def test_applies_patches_in_normal_mode(self, simple_pe_binary: Path) -> None:
        """Normal mode applies patches to binary."""
        patches = [{"offset": 0x200, "type": "nop", "size": 2, "description": "Test"}]

        result = run_patch_validation(
            str(simple_pe_binary),
            patches,
            test_mode=False
        )

        assert result["success"] is True
        assert result["patches_applied"] == 1


class TestResultsDisplay:
    """Test patch analysis results display."""

    def test_displays_console_output(self, simple_pe_binary: Path, capsys: pytest.CaptureFixture[str]) -> None:
        """Displays formatted console output for results."""
        result = {
            "success": True,
            "binary_path": str(simple_pe_binary),
            "patches_applied": 3,
            "patches_failed": 1,
            "backup_path": f"{str(simple_pe_binary)}.backup",
            "original_hash": "abcd1234" * 8,
            "patched_hash": "ef567890" * 8,
            "details": [
                {
                    "success": True,
                    "offset": 0x200,
                    "type": "nop",
                    "description": "NOP license check",
                    "bytes_patched": 5,
                }
            ],
        }

        show_analysis_results(result, display_mode="console")

        captured = capsys.readouterr()
        assert "SUCCESS" in captured.out
        assert "Patches Applied: 3" in captured.out
        assert "Backup Created:" in captured.out

    def test_displays_json_output(self, simple_pe_binary: Path, capsys: pytest.CaptureFixture[str]) -> None:
        """Displays JSON-formatted output."""
        result = {
            "success": True,
            "binary_path": str(simple_pe_binary),
            "patches_applied": 1
        }

        show_analysis_results(result, display_mode="json")

        captured = capsys.readouterr()
        assert '"success": true' in captured.out
        assert '"patches_applied": 1' in captured.out


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_handles_missing_binary_file(self, patch_engine: BinaryPatchEngine, temp_dir: Path) -> None:
        """Handles non-existent binary file gracefully."""
        fake_path = temp_dir / "nonexistent.exe"
        patches = [{"offset": 0, "type": "nop", "size": 1, "description": "Test"}]

        result = patch_engine.apply_patches(str(fake_path), patches)

        assert result["success"] is False
        assert "not found" in result["error"].lower()

    def test_handles_invalid_offset(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Handles patches with invalid offsets."""
        patches = [{"offset": 0xFFFFFFFF, "type": "nop", "size": 1, "description": "Invalid"}]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["patches_failed"] == 1
        assert result["details"][0]["error"]

    def test_handles_empty_patch_list(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Handles empty patch list gracefully."""
        result = patch_engine.apply_patches(str(simple_pe_binary), [])

        assert result["patches_applied"] == 0
        assert result["success"] is False or result["patches_applied"] == 0

    def test_handles_corrupted_binary(self, patch_engine: BinaryPatchEngine, temp_dir: Path) -> None:
        """Handles corrupted binary files."""
        corrupted = temp_dir / "corrupted.exe"
        corrupted.write_bytes(b"\x00" * 100)  # Invalid PE

        # Should still be able to patch bytes
        patches = [{"offset": 10, "type": "direct", "bytes": "AABBCCDD", "description": "Test"}]
        result = patch_engine.apply_patches(str(corrupted), patches)

        # Can patch but pattern detection might fail
        assert "original_hash" in result


class TestRealWorldScenarios:
    """Test realistic license cracking scenarios."""

    def test_cracks_trial_period_check(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Bypasses 30-day trial period enforcement."""
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))
        trial_pattern = [p for p in patterns if "Days remaining" in p["name"]][0]

        patches = [{
            "offset": trial_pattern["offset"],
            "type": "nop",
            "size": 3,
            "description": "Remove trial check"
        }]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        # Verify CMP instruction removed
        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[trial_pattern["offset"]:trial_pattern["offset"]+3] == b"\x90\x90\x90"

    def test_forces_registration_success(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Makes IsRegistered() always return true."""
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))
        reg_pattern = [p for p in patterns if "IsRegistered" in p["name"]][0]

        # Convert JE to JMP at the conditional check
        patches = [{
            "offset": reg_pattern["offset"] + 2,  # Skip TEST, patch JE
            "type": "jmp",
            "description": "Bypass registration check"
        }]

        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        patched_data = simple_pe_binary.read_bytes()
        assert patched_data[reg_pattern["offset"] + 2] == 0xEB  # JMP

    def test_full_automatic_crack_workflow(self, patch_engine: BinaryPatchEngine, simple_pe_binary: Path) -> None:
        """Complete automatic cracking workflow: detect patterns, generate patches, apply."""
        # Step 1: Find patterns
        patterns = patch_engine.find_licensing_patterns(str(simple_pe_binary))
        assert len(patterns) >= 3  # Found multiple protection patterns

        # Step 2: Generate patches
        patches = patch_engine.generate_patch_config(str(simple_pe_binary), auto_detect=True)
        assert len(patches) > 0

        # Step 3: Apply patches
        result = patch_engine.apply_patches(str(simple_pe_binary), patches)

        assert result["success"] is True
        assert result["patches_applied"] > 0
        assert result["backup_created"] is True

        # Verify binary was modified
        assert result["original_hash"] != result["patched_hash"]
