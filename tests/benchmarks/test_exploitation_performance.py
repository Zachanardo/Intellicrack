"""
Performance benchmarks for Intellicrack's exploitation and payload generation capabilities.

This module contains comprehensive performance tests for exploitation and payload generation in Intellicrack,
including shellcode generation performance benchmarks, payload encoding operations benchmarks,
polymorphic code generation benchmarks, assembly compilation speed benchmarks,
comprehensive bypass engine operations benchmarks, exploitation module stress tests,
exploitation error handling performance tests, and exploitation module consistency checks.
These tests ensure the exploitation components maintain high performance under various conditions.
"""

import os
import tempfile
import threading
import time
from collections.abc import Generator
from typing import Any

import psutil
import pytest

from intellicrack.core.exploitation.bypass_engine import BypassEngine
from intellicrack.core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator


class TestExploitationPerformance:
    """Performance benchmarks for exploitation and payload generation."""

    @pytest.fixture
    def sample_shellcode(self) -> bytes:
        """Generate REAL shellcode for testing."""
        return b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

    @pytest.fixture
    def vulnerable_binary_path(self) -> Generator[str, None, None]:
        """Create test vulnerable binary."""
        with tempfile.NamedTemporaryFile(suffix='.exe', delete=False) as temp_file:
            dos_header = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'
            dos_header += b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00'
            dos_header += b'\x00' * 40
            dos_header += b'\x80\x00\x00\x00'
            dos_header += b'\x00' * 60

            pe_signature = b'PE\x00\x00'
            coff_header = b'\x4c\x01\x03\x00' + b'\x00' * 16

            optional_header = b'\x0b\x01\x0e\x00' + b'\x00' * 220

            temp_file.write(dos_header + pe_signature + coff_header + optional_header)
            temp_file.flush()
            yield temp_file.name

        try:
            os.unlink(temp_file.name)
        except OSError:
            pass

    @pytest.fixture
    def process_memory(self) -> psutil._pswindows.pmem:
        """Monitor process memory usage."""
        process = psutil.Process()
        return process.memory_info()

    @pytest.mark.benchmark
    def test_shellcode_generation_performance(
        self, benchmark: Any, sample_shellcode: bytes
    ) -> None:
        """Benchmark REAL shellcode generation performance."""
        def generate_shellcode() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_license_check_bypass(0x401000)

        result = benchmark(generate_shellcode)

        assert result is not None, "Shellcode generation must return actual shellcode"
        assert len(result) > 0, "Generated shellcode must not be empty"
        assert benchmark.stats.mean < 0.1, "Shellcode generation should be under 100ms"

    @pytest.mark.benchmark
    def test_license_bypass_generation_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL license bypass code generation."""
        def generate_bypass() -> bytes | None:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_license_bypass(
                architecture="x64",
                bypass_type="license_check",
                options={"return_value": 1, "preserve_stack": True}
            )

        result = benchmark(generate_bypass)

        assert result is not None, "License bypass must be generated"
        assert len(result) > 0, "Bypass code must not be empty"
        assert benchmark.stats.mean < 0.05, "License bypass should be under 50ms"

    @pytest.mark.benchmark
    def test_trial_extension_patch_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL trial extension patch generation."""
        def generate_trial_patch() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_trial_extension_patch(0x402000)

        result = benchmark(generate_trial_patch)

        assert result is not None, "Trial extension patch must be generated"
        assert len(result) > 0, "Patch must not be empty"
        assert benchmark.stats.mean < 0.05, "Trial patch should be under 50ms"

    @pytest.mark.benchmark
    def test_activation_bypass_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL activation bypass generation."""
        def generate_activation_bypass() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_activation_bypass(0x403000)

        result = benchmark(generate_activation_bypass)

        assert result is not None, "Activation bypass must be generated"
        assert len(result) > 0, "Bypass code must not be empty"
        assert benchmark.stats.mean < 0.05, "Activation bypass should be under 50ms"

    @pytest.mark.benchmark
    def test_serial_validation_bypass_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL serial validation bypass generation."""
        def generate_serial_bypass() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_serial_validation_bypass(0x404000)

        result = benchmark(generate_serial_bypass)

        assert result is not None, "Serial validation bypass must be generated"
        assert len(result) > 0, "Bypass code must not be empty"
        assert benchmark.stats.mean < 0.05, "Serial bypass should be under 50ms"

    @pytest.mark.benchmark
    def test_hardware_id_spoof_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL hardware ID spoof generation."""
        def generate_hwid_spoof() -> bytes:
            generator = LicenseBypassCodeGenerator()
            spoofed_hwid = b"ABCD1234EFGH5678"
            return generator.generate_hardware_id_spoof(0x405000, spoofed_hwid)

        result = benchmark(generate_hwid_spoof)

        assert result is not None, "HWID spoof must be generated"
        assert len(result) > 0, "Spoof code must not be empty"
        assert benchmark.stats.mean < 0.1, "HWID spoof should be under 100ms"

    @pytest.mark.benchmark
    def test_bypass_engine_payload_generation(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL bypass engine payload generation."""
        def generate_bypass_payload() -> dict[str, Any]:
            engine = BypassEngine()
            return engine.generate_payload(
                payload_type="license_check",
                architecture="x64",
                target_info={"platform": "windows", "return_value": 1},
                options={"preserve_stack": True}
            )

        result = benchmark(generate_bypass_payload)

        assert result is not None, "Bypass payload must be generated"
        assert isinstance(result, dict), "Payload must be a dict"
        assert benchmark.stats.mean < 0.1, "Payload generation should be under 100ms"

    @pytest.mark.benchmark
    def test_nop_patch_generation_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL NOP patch generation."""
        def generate_nop_patch() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_nop_patch(0x406000, 16)

        result = benchmark(generate_nop_patch)

        assert result is not None, "NOP patch must be generated"
        assert len(result) == 16, "NOP patch must be correct size"
        assert benchmark.stats.mean < 0.01, "NOP patch should be under 10ms"

    @pytest.mark.benchmark
    def test_conditional_jump_patch_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL conditional jump patch generation."""
        def generate_jump_patch() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_conditional_jump_patch(0x407000, always_jump=True)

        result = benchmark(generate_jump_patch)

        assert result is not None, "Jump patch must be generated"
        assert len(result) > 0, "Jump patch must not be empty"
        assert benchmark.stats.mean < 0.01, "Jump patch should be under 10ms"

    @pytest.mark.benchmark
    def test_return_value_patch_performance(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL return value patch generation."""
        def generate_return_patch() -> bytes:
            generator = LicenseBypassCodeGenerator()
            return generator.generate_return_value_patch(0x408000, 1)

        result = benchmark(generate_return_patch)

        assert result is not None, "Return patch must be generated"
        assert len(result) > 0, "Return patch must not be empty"
        assert benchmark.stats.mean < 0.01, "Return patch should be under 10ms"

    def test_bypass_generation_memory_usage(
        self, process_memory: psutil._pswindows.pmem
    ) -> None:
        """Test REAL bypass generation memory efficiency."""
        initial_memory = process_memory.rss

        generator = LicenseBypassCodeGenerator()

        for i in range(100):
            bypass = generator.generate_license_check_bypass(0x401000 + i * 0x100)
            assert bypass is not None, f"Bypass generation {i} failed"
            assert len(bypass) > 0, f"Generated bypass {i} is empty"

        current_process = psutil.Process()
        final_memory = current_process.memory_info().rss
        memory_increase = final_memory - initial_memory

        assert memory_increase < 50 * 1024 * 1024, "Memory increase should be under 50MB for 100 bypasses"

    def test_concurrent_bypass_generation(self) -> None:
        """Test REAL concurrent bypass generation performance."""
        results: list[tuple[int, bytes]] = []
        errors: list[tuple[int, str]] = []

        def generate_bypass(thread_id: int) -> None:
            try:
                generator = LicenseBypassCodeGenerator()
                bypass = generator.generate_license_check_bypass(0x401000 + thread_id * 0x100)
                results.append((thread_id, bypass))
            except Exception as e:
                errors.append((thread_id, str(e)))

        threads: list[threading.Thread] = []
        start_time = time.time()

        for i in range(10):
            thread = threading.Thread(target=generate_bypass, args=(i,))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join(timeout=5.0)

        end_time = time.time()

        assert not errors, f"Concurrent generation errors: {errors}"
        assert len(results) == 10, f"Expected 10 results, got {len(results)}"
        assert end_time - start_time < 2.0, "Concurrent generation should complete under 2 seconds"

        for thread_id, bypass in results:
            assert bypass is not None, f"Thread {thread_id} returned None"
            assert len(bypass) > 0, f"Thread {thread_id} returned empty bypass"

    def test_exploitation_module_stress_test(self) -> None:
        """Stress test REAL exploitation modules under load."""
        generator = LicenseBypassCodeGenerator()

        start_time = time.time()

        for i in range(20):
            license_bypass = generator.generate_license_check_bypass(0x401000 + i * 0x100)
            assert license_bypass is not None, f"License bypass {i} failed"

            trial_patch = generator.generate_trial_extension_patch(0x402000 + i * 0x100)
            assert trial_patch is not None, f"Trial patch {i} failed"

            activation_bypass = generator.generate_activation_bypass(0x403000 + i * 0x100)
            assert activation_bypass is not None, f"Activation bypass {i} failed"

        end_time = time.time()

        assert end_time - start_time < 5.0, "Stress test should complete under 5 seconds"

    @pytest.mark.benchmark
    def test_bypass_engine_capabilities_analysis(
        self, benchmark: Any
    ) -> None:
        """Benchmark REAL bypass engine capabilities analysis."""
        def analyze_capabilities() -> dict[str, Any]:
            engine = BypassEngine()
            target_info: dict[str, Any] = {
                'architecture': 'x64',
                'platform': 'windows',
                'protections': ['license_check', 'trial_limit']
            }
            return engine.analyze_bypass_capabilities(target_info)

        result = benchmark(analyze_capabilities)

        assert result is not None, "Capabilities analysis must return results"
        assert isinstance(result, dict), "Result must be a dictionary"
        assert benchmark.stats.mean < 0.1, "Capabilities analysis should be under 100ms"

    def test_exploitation_error_handling_performance(self) -> None:
        """Test REAL exploitation error handling performance."""
        generator = LicenseBypassCodeGenerator()

        start_time = time.time()

        invalid_inputs: list[int | None] = [
            0,
            -1,
            None,
        ]

        for invalid_input in invalid_inputs:
            try:
                if invalid_input is not None:
                    generator.generate_license_check_bypass(invalid_input)
            except (ValueError, TypeError):
                pass

        end_time = time.time()

        assert end_time - start_time < 1.0, "Error handling should be fast (under 1 second)"

    def test_exploitation_consistency_check(self) -> None:
        """Test REAL exploitation module consistency across multiple runs."""
        generator = LicenseBypassCodeGenerator()

        addresses = [0x401000, 0x402000, 0x403000]

        for address in addresses:
            results: list[bytes] = []

            for _ in range(5):
                bypass = generator.generate_license_check_bypass(address)
                results.append(bypass)

            for result in results:
                assert result is not None, f"Bypass generation failed for 0x{address:x}"
                assert len(result) > 0, f"Empty bypass for 0x{address:x}"

    def test_available_bypasses_performance(self) -> None:
        """Test REAL bypass availability check performance."""
        engine = BypassEngine()

        start_time = time.time()

        for _ in range(100):
            available = engine.get_available_bypasses()
            assert isinstance(available, list), "Available bypasses must be a list"

        end_time = time.time()

        assert end_time - start_time < 0.5, "Availability check should be fast (under 500ms for 100 calls)"

    def test_bypass_info_retrieval_performance(self) -> None:
        """Test REAL bypass info retrieval performance."""
        engine = BypassEngine()
        available = engine.get_available_bypasses()

        start_time = time.time()

        for bypass_type in available:
            info = engine.get_bypass_info(bypass_type)
            assert isinstance(info, dict), f"Bypass info for {bypass_type} must be a dict"

        end_time = time.time()

        assert end_time - start_time < 0.5, "Info retrieval should be fast"

    def test_recommended_bypasses_performance(self) -> None:
        """Test REAL recommended bypasses performance."""
        engine = BypassEngine()

        start_time = time.time()

        target_info: dict[str, Any] = {
            'architecture': 'x64',
            'platform': 'windows',
            'protections': ['license_check', 'trial_limit', 'activation']
        }

        for _ in range(50):
            recommended = engine.get_recommended_bypasses(target_info, min_reliability=5)
            assert isinstance(recommended, list), "Recommendations must be a list"

        end_time = time.time()

        assert end_time - start_time < 1.0, "Recommendations should be fast (under 1s for 50 calls)"

    def test_patch_export_performance(self) -> None:
        """Test REAL patch export performance."""
        generator = LicenseBypassCodeGenerator()

        generator.generate_license_check_bypass(0x401000)
        generator.generate_trial_extension_patch(0x402000)
        generator.generate_activation_bypass(0x403000)

        start_time = time.time()

        for format_type in ["binary", "hex", "c_array"]:
            try:
                exported = generator.export_patches(format_type)
                assert isinstance(exported, dict), f"Export for {format_type} must be a dict"
            except ValueError:
                pass

        end_time = time.time()

        assert end_time - start_time < 0.1, "Export should be fast (under 100ms)"
