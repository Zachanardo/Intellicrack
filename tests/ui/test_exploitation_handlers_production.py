"""Production tests for exploitation handlers.

This module validates UI handler functions for exploitation operations including
cleanup and output saving functionality.

Copyright (C) 2025 Zachary Flint
"""

from pathlib import Path
from typing import Any
from unittest.mock import Mock, patch

import pytest

from intellicrack.handlers.pyqt6_handler import QApplication
from intellicrack.ui.exploitation_handlers import (
    cleanup_exploitation,
    save_exploitation_output,
)


@pytest.fixture
def qapp() -> QApplication:
    """Provide QApplication instance for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


class MockExploitationWidget:
    """Mock widget with exploitation-related attributes."""

    def __init__(self) -> None:
        """Initialize mock exploitation widget."""
        from intellicrack.handlers.pyqt6_handler import QTextEdit

        self.exploit_output = QTextEdit()
        self.binary_path = "D:\\test\\sample.exe"
        self.current_payload = b"\x90\x90\x90\x90"
        self.current_payload_metadata = {"type": "shellcode", "size": 4}
        self.payload_engine = Mock()


class TestCleanupExploitation:
    """Test cleanup_exploitation functionality."""

    def test_cleanup_clears_current_payload(self, qapp: QApplication) -> None:
        """Cleanup clears current payload data."""
        widget = MockExploitationWidget()

        assert hasattr(widget, "current_payload")
        cleanup_exploitation(widget)

        assert not hasattr(widget, "current_payload")

    def test_cleanup_clears_payload_metadata(self, qapp: QApplication) -> None:
        """Cleanup clears payload metadata."""
        widget = MockExploitationWidget()

        assert hasattr(widget, "current_payload_metadata")
        cleanup_exploitation(widget)

        assert not hasattr(widget, "current_payload_metadata")

    def test_cleanup_outputs_status_messages(self, qapp: QApplication) -> None:
        """Cleanup outputs status messages to exploit output."""
        widget = MockExploitationWidget()

        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Cleaning Up Exploitation Resources" in output_text
        assert "Cleared payload data" in output_text
        assert "Cleared payload metadata" in output_text
        assert "Cleanup completed successfully" in output_text

    def test_cleanup_handles_missing_attributes(self, qapp: QApplication) -> None:
        """Cleanup handles missing attributes gracefully."""
        from intellicrack.handlers.pyqt6_handler import QTextEdit

        widget = Mock()
        widget.exploit_output = QTextEdit()

        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Cleaning Up Exploitation Resources" in output_text

    def test_cleanup_handles_exceptions(self, qapp: QApplication) -> None:
        """Cleanup handles exceptions during cleanup."""
        widget = Mock()
        widget.exploit_output = Mock()
        widget.exploit_output.append = Mock(side_effect=Exception("Test error"))

        cleanup_exploitation(widget)

    def test_cleanup_resets_payload_engine(self, qapp: QApplication) -> None:
        """Cleanup resets payload engine reference."""
        widget = MockExploitationWidget()

        assert hasattr(widget, "payload_engine")
        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Reset payload engine" in output_text


class TestSaveExploitationOutput:
    """Test save_exploitation_output functionality."""

    def test_save_opens_file_dialog(self, qapp: QApplication) -> None:
        """Save opens file dialog with default filename."""
        widget = MockExploitationWidget()

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = ("", "")

            save_exploitation_output(widget)

            mock_dialog.assert_called_once()
            args = mock_dialog.call_args[0]
            assert "exploitation_report_" in args[2]

    def test_save_writes_file_with_header(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save writes file with report header."""
        widget = MockExploitationWidget()
        widget.exploit_output.setText("Test exploitation output")

        output_file = tmp_path / "test_report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            assert output_file.exists()
            content = output_file.read_text(encoding="utf-8")

            assert "Intellicrack Exploitation Report" in content
            assert "Generated:" in content
            assert "Target Binary:" in content
            assert "Test exploitation output" in content

    def test_save_includes_binary_path_in_report(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save includes binary path in report header."""
        widget = MockExploitationWidget()
        widget.binary_path = "D:\\test\\target.exe"
        widget.exploit_output.setText("Output")

        output_file = tmp_path / "report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            content = output_file.read_text(encoding="utf-8")
            assert "D:\\test\\target.exe" in content

    def test_save_handles_missing_binary_path(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save handles missing binary path gracefully."""
        from intellicrack.handlers.pyqt6_handler import QTextEdit

        widget = Mock()
        widget.exploit_output = QTextEdit()
        widget.exploit_output.setText("Output")

        output_file = tmp_path / "report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            content = output_file.read_text(encoding="utf-8")
            assert "Not specified" in content

    def test_save_shows_success_message(self, qapp: QApplication, tmp_path: Path) -> None:
        """Save shows success message after saving."""
        widget = MockExploitationWidget()

        output_file = tmp_path / "report.txt"

        with (
            patch(
                "intellicrack.ui.exploitation_handlers.QFileDialog.getSaveFileName"
            ) as mock_dialog,
            patch(
                "intellicrack.handlers.pyqt6_handler.QMessageBox.information"
            ) as mock_info,
        ):
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            mock_info.assert_called_once()
            args = mock_info.call_args[0]
            assert "Saved" in str(args)

    def test_save_appends_success_to_output(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save appends success message to exploit output."""
        widget = MockExploitationWidget()

        output_file = tmp_path / "report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            output_text = widget.exploit_output.toPlainText()
            assert "Output saved to:" in output_text
            assert str(output_file) in output_text

    def test_save_handles_cancelled_dialog(self, qapp: QApplication) -> None:
        """Save handles cancelled file dialog gracefully."""
        widget = MockExploitationWidget()
        initial_output = widget.exploit_output.toPlainText()

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = ("", "")

            save_exploitation_output(widget)

    def test_save_handles_file_write_errors(self, qapp: QApplication) -> None:
        """Save handles file write errors with error message."""
        widget = MockExploitationWidget()

        with (
            patch(
                "intellicrack.ui.exploitation_handlers.QFileDialog.getSaveFileName"
            ) as mock_dialog,
            patch("builtins.open", side_effect=PermissionError("Access denied")),
            patch(
                "intellicrack.ui.exploitation_handlers.QMessageBox.critical"
            ) as mock_critical,
        ):
            mock_dialog.return_value = ("D:\\protected\\report.txt", "Text Files (*.txt)")

            save_exploitation_output(widget)

            mock_critical.assert_called_once()
            output_text = widget.exploit_output.toPlainText()
            assert "Save error:" in output_text

    def test_save_preserves_output_content(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save preserves all output content in saved file."""
        widget = MockExploitationWidget()
        test_content = "Line 1\nLine 2\nLine 3\nSpecial chars: <>&\""
        widget.exploit_output.setText(test_content)

        output_file = tmp_path / "report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            content = output_file.read_text(encoding="utf-8")
            assert test_content in content
            assert "Line 1" in content
            assert "Line 2" in content
            assert "Line 3" in content
            assert "Special chars: <>&\"" in content

    def test_save_uses_utf8_encoding(
        self, qapp: QApplication, tmp_path: Path
    ) -> None:
        """Save uses UTF-8 encoding for international characters."""
        widget = MockExploitationWidget()
        unicode_content = "Test: ñ é ü 中文 日本語 한국어"
        widget.exploit_output.setText(unicode_content)

        output_file = tmp_path / "report.txt"

        with patch(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName"
        ) as mock_dialog:
            mock_dialog.return_value = (str(output_file), "Text Files (*.txt)")

            save_exploitation_output(widget)

            content = output_file.read_text(encoding="utf-8")
            assert unicode_content in content
