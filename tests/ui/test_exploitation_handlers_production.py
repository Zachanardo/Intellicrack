"""Production tests for exploitation handlers.

This module validates UI handler functions for exploitation operations including
cleanup and output saving functionality.

Copyright (C) 2025 Zachary Flint
"""

from pathlib import Path
from typing import Any, Optional

import pytest

from intellicrack.handlers.pyqt6_handler import QApplication
from intellicrack.ui.exploitation_handlers import (
    cleanup_exploitation,
    save_exploitation_output,
)


class FakePayloadEngine:
    """Real test double for payload engine."""

    def __init__(self) -> None:
        """Initialize fake payload engine."""
        self.reset_called: bool = False
        self.method_calls: list[str] = []

    def reset(self) -> None:
        """Track reset calls."""
        self.reset_called = True
        self.method_calls.append("reset")


class FakeFileDialog:
    """Real test double for QFileDialog.getSaveFileName."""

    def __init__(self) -> None:
        """Initialize fake file dialog."""
        self.return_value: tuple[str, str] = ("", "")
        self.call_count: int = 0
        self.last_call_args: Optional[tuple[Any, ...]] = None
        self.last_call_kwargs: Optional[dict[str, Any]] = None

    def __call__(
        self, parent: Any = None, caption: str = "", directory: str = "", filter: str = ""
    ) -> tuple[str, str]:
        """Simulate getSaveFileName call."""
        self.call_count += 1
        self.last_call_args = (parent, caption, directory, filter)
        return self.return_value

    def set_return_value(self, filepath: str, filter: str = "Text Files (*.txt)") -> None:
        """Configure return value."""
        self.return_value = (filepath, filter)


class FakeMessageBox:
    """Real test double for QMessageBox information and critical dialogs."""

    def __init__(self) -> None:
        """Initialize fake message box."""
        self.information_calls: list[tuple[Any, ...]] = []
        self.critical_calls: list[tuple[Any, ...]] = []

    def information(self, *args: Any, **kwargs: Any) -> None:
        """Track information dialog calls."""
        self.information_calls.append(args)

    def critical(self, *args: Any, **kwargs: Any) -> None:
        """Track critical dialog calls."""
        self.critical_calls.append(args)


class FakeQTextEdit:
    """Real test double for QTextEdit that tracks append calls."""

    def __init__(self) -> None:
        """Initialize fake text edit."""
        self._text: str = ""
        self.append_calls: list[str] = []
        self.should_raise: bool = False

    def setText(self, text: str) -> None:
        """Set text content."""
        self._text = text

    def toPlainText(self) -> str:
        """Get plain text content."""
        return self._text

    def append(self, text: str) -> None:
        """Track append calls."""
        if self.should_raise:
            raise Exception("Test error")
        self.append_calls.append(text)
        if self._text:
            self._text += "\n" + text
        else:
            self._text = text


class FakeExploitationWidget:
    """Real widget test double with exploitation-related attributes."""

    def __init__(self) -> None:
        """Initialize fake exploitation widget."""
        from intellicrack.handlers.pyqt6_handler import QTextEdit

        self.exploit_output: QTextEdit = QTextEdit()
        self.binary_path: str = "D:\\test\\sample.exe"
        self.current_payload: bytes = b"\x90\x90\x90\x90"
        self.current_payload_metadata: dict[str, Any] = {"type": "shellcode", "size": 4}
        self.payload_engine: FakePayloadEngine = FakePayloadEngine()


class FakeMinimalWidget:
    """Minimal widget with only exploit_output attribute."""

    def __init__(self) -> None:
        """Initialize minimal widget."""
        from intellicrack.handlers.pyqt6_handler import QTextEdit

        self.exploit_output: QTextEdit = QTextEdit()


class FakeExceptionWidget:
    """Widget that raises exceptions on append."""

    def __init__(self) -> None:
        """Initialize exception widget."""
        self.exploit_output: FakeQTextEdit = FakeQTextEdit()
        self.exploit_output.should_raise = True


@pytest.fixture
def qapp() -> QApplication:
    """Provide QApplication instance for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    return app


class TestCleanupExploitation:
    """Test cleanup_exploitation functionality."""

    def test_cleanup_clears_current_payload(self, qapp: QApplication) -> None:
        """Cleanup clears current payload data."""
        widget = FakeExploitationWidget()

        assert hasattr(widget, "current_payload")
        cleanup_exploitation(widget)

        assert not hasattr(widget, "current_payload")

    def test_cleanup_clears_payload_metadata(self, qapp: QApplication) -> None:
        """Cleanup clears payload metadata."""
        widget = FakeExploitationWidget()

        assert hasattr(widget, "current_payload_metadata")
        cleanup_exploitation(widget)

        assert not hasattr(widget, "current_payload_metadata")

    def test_cleanup_outputs_status_messages(self, qapp: QApplication) -> None:
        """Cleanup outputs status messages to exploit output."""
        widget = FakeExploitationWidget()

        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Cleaning Up Exploitation Resources" in output_text
        assert "Cleared payload data" in output_text
        assert "Cleared payload metadata" in output_text
        assert "Cleanup completed successfully" in output_text

    def test_cleanup_handles_missing_attributes(self, qapp: QApplication) -> None:
        """Cleanup handles missing attributes gracefully."""
        widget = FakeMinimalWidget()

        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Cleaning Up Exploitation Resources" in output_text

    def test_cleanup_handles_exceptions(self, qapp: QApplication) -> None:
        """Cleanup handles exceptions during cleanup."""
        widget = FakeExceptionWidget()

        cleanup_exploitation(widget)

    def test_cleanup_resets_payload_engine(self, qapp: QApplication) -> None:
        """Cleanup resets payload engine reference."""
        widget = FakeExploitationWidget()

        assert hasattr(widget, "payload_engine")
        cleanup_exploitation(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Reset payload engine" in output_text


class TestSaveExploitationOutput:
    """Test save_exploitation_output functionality."""

    def test_save_opens_file_dialog(self, qapp: QApplication, monkeypatch: pytest.MonkeyPatch) -> None:
        """Save opens file dialog with default filename."""
        widget = FakeExploitationWidget()
        fake_dialog = FakeFileDialog()

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        assert fake_dialog.call_count == 1
        assert fake_dialog.last_call_args is not None
        assert "exploitation_report_" in fake_dialog.last_call_args[2]

    def test_save_writes_file_with_header(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save writes file with report header."""
        widget = FakeExploitationWidget()
        widget.exploit_output.setText("Test exploitation output")

        output_file = tmp_path / "test_report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        assert output_file.exists()
        content = output_file.read_text(encoding="utf-8")

        assert "Intellicrack Exploitation Report" in content
        assert "Generated:" in content
        assert "Target Binary:" in content
        assert "Test exploitation output" in content

    def test_save_includes_binary_path_in_report(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save includes binary path in report header."""
        widget = FakeExploitationWidget()
        widget.binary_path = "D:\\test\\target.exe"
        widget.exploit_output.setText("Output")

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        content = output_file.read_text(encoding="utf-8")
        assert "D:\\test\\target.exe" in content

    def test_save_handles_missing_binary_path(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save handles missing binary path gracefully."""
        widget = FakeMinimalWidget()
        widget.exploit_output.setText("Output")

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        content = output_file.read_text(encoding="utf-8")
        assert "Not specified" in content

    def test_save_shows_success_message(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save shows success message after saving."""
        widget = FakeExploitationWidget()

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))
        fake_msgbox = FakeMessageBox()

        monkeypatch.setattr(
            "intellicrack.ui.exploitation_handlers.QFileDialog.getSaveFileName",
            fake_dialog
        )
        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QMessageBox.information",
            fake_msgbox.information
        )

        save_exploitation_output(widget)

        assert len(fake_msgbox.information_calls) == 1
        args = fake_msgbox.information_calls[0]
        assert "Saved" in str(args)

    def test_save_appends_success_to_output(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save appends success message to exploit output."""
        widget = FakeExploitationWidget()

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        output_text = widget.exploit_output.toPlainText()
        assert "Output saved to:" in output_text
        assert str(output_file) in output_text

    def test_save_handles_cancelled_dialog(
        self, qapp: QApplication, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save handles cancelled file dialog gracefully."""
        widget = FakeExploitationWidget()
        initial_output = widget.exploit_output.toPlainText()

        fake_dialog = FakeFileDialog()

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

    def test_save_handles_file_write_errors(
        self, qapp: QApplication, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save handles file write errors with error message."""
        widget = FakeExploitationWidget()

        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value("D:\\protected\\report.txt")
        fake_msgbox = FakeMessageBox()

        def fake_open(*args: Any, **kwargs: Any) -> None:
            raise PermissionError("Access denied")

        monkeypatch.setattr(
            "intellicrack.ui.exploitation_handlers.QFileDialog.getSaveFileName",
            fake_dialog
        )
        monkeypatch.setattr("builtins.open", fake_open)
        monkeypatch.setattr(
            "intellicrack.ui.exploitation_handlers.QMessageBox.critical",
            fake_msgbox.critical
        )

        save_exploitation_output(widget)

        assert len(fake_msgbox.critical_calls) == 1
        output_text = widget.exploit_output.toPlainText()
        assert "Save error:" in output_text

    def test_save_preserves_output_content(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save preserves all output content in saved file."""
        widget = FakeExploitationWidget()
        test_content = "Line 1\nLine 2\nLine 3\nSpecial chars: <>&\""
        widget.exploit_output.setText(test_content)

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        content = output_file.read_text(encoding="utf-8")
        assert test_content in content
        assert "Line 1" in content
        assert "Line 2" in content
        assert "Line 3" in content
        assert "Special chars: <>&\"" in content

    def test_save_uses_utf8_encoding(
        self, qapp: QApplication, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        """Save uses UTF-8 encoding for international characters."""
        widget = FakeExploitationWidget()
        unicode_content = "Test: ñ é ü 中文 日本語 한국어"
        widget.exploit_output.setText(unicode_content)

        output_file = tmp_path / "report.txt"
        fake_dialog = FakeFileDialog()
        fake_dialog.set_return_value(str(output_file))

        monkeypatch.setattr(
            "intellicrack.handlers.pyqt6_handler.QFileDialog.getSaveFileName",
            fake_dialog
        )

        save_exploitation_output(widget)

        content = output_file.read_text(encoding="utf-8")
        assert unicode_content in content
