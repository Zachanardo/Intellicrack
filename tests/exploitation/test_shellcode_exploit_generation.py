"""
Comprehensive test suite for shellcode and exploit generation capabilities.
Tests validate production-ready exploit generation and shellcode creation functionality.
These tests assume sophisticated binary analysis and exploitation capabilities exist.
"""

import pytest
import os
import tempfile
import struct
import re
from pathlib import Path
from typing import Dict, Any, List

from intellicrack.utils.exploitation.exploitation import (
    generate_exploit,
    generate_exploit_strategy,
    generate_chains,
    exploit,
    _generate_bof_shellcode_x86,
    _generate_bof_shellcode_x64,
    _generate_rop_chain_x86,
    _generate_rop_chain_x64,
    _generate_ret2libc_x86,
    _generate_format_string_x86,
    _generate_integer_overflow,
    _analyze_target_vulnerabilities,
    _select_best_exploit,
    _exploit_buffer_overflow,
    _exploit_format_string,
    _exploit_rop_chain,
    _exploit_dll_hijacking,
    _generate_basic_rop_chain,
    _find_dll_hijack_opportunities,
    _execute_buffer_overflow_exploit,
    _execute_format_string_exploit,
    _execute_rop_chain_exploit,
    _generate_reflective_loader_shellcode
)


class TestShellcodeGeneration:
    """Test suite for shellcode generation functions."""

    def test_generate_bof_shellcode_x86(self):
        """Test buffer overflow shellcode generation for x86 architecture."""
        result = _generate_bof_shellcode_x86()

        assert isinstance(result, str)
        assert len(result) > 20  # Substantive shellcode

        # Should be hex-encoded shellcode or assembly
        if result.startswith("\\x"):
            # Hex-encoded format
            hex_pattern = re.compile(r'(\\x[0-9a-fA-F]{2})+')
            assert hex_pattern.search(result)
        else:
            # Assembly format - should contain x86 instructions
            x86_instructions = ["push", "pop", "mov", "call", "ret", "jmp", "int"]
            assert any(instr in result.lower() for instr in x86_instructions)

        # Should not contain placeholder text
        assert "TODO" not in result.upper()
        assert "PLACEHOLDER" not in result.upper()
        assert "STUB" not in result.upper()

    def test_generate_bof_shellcode_x64(self):
        """Test buffer overflow shellcode generation for x64 architecture."""
        result = _generate_bof_shellcode_x64()

        assert isinstance(result, str)
        assert len(result) > 20  # Substantive shellcode

        # x64 shellcode should be different from x86
        x86_shellcode = _generate_bof_shellcode_x86()
        assert result != x86_shellcode  # Different architectures

        # Should contain x64-specific elements
        if not result.startswith("\\x"):
            # Assembly format should have x64 registers or instructions
            x64_elements = ["rax", "rbx", "rcx", "rdx", "rsp", "rbp", "r8", "r9", "syscall"]
            has_x64_elements = any(elem in result.lower() for elem in x64_elements)
            # Note: hex shellcode may not show registers explicitly
            if "push" in result.lower() or "mov" in result.lower():
                assert has_x64_elements

    def test_generate_rop_chain_x86(self):
        """Test ROP chain generation for x86 architecture."""
        result = _generate_rop_chain_x86()

        assert isinstance(result, str)
        assert len(result) > 30  # Substantive ROP chain

        # ROP chain should contain addresses or gadget references
        address_patterns = [
            r'0x[0-9a-fA-F]+',  # Hex addresses
            r'gadget_\d+',       # Gadget references
            r'pop.*ret',         # Common ROP gadgets
            r'add.*ret'
        ]

        has_addresses = any(re.search(pattern, result, re.IGNORECASE)
                           for pattern in address_patterns)
        assert has_addresses

        # Should not be placeholder
        assert "PLACEHOLDER" not in result.upper()
        assert len(result.split()) > 3  # Multiple components

    def test_generate_rop_chain_x64(self):
        """Test ROP chain generation for x64 architecture."""
        result = _generate_rop_chain_x64()

        assert isinstance(result, str)
        assert len(result) > 30

        # x64 ROP chain should differ from x86
        x86_rop = _generate_rop_chain_x86()
        assert result != x86_rop

        # Should contain x64 elements if in assembly format
        if "pop" in result.lower() or "ret" in result.lower():
            x64_regs = ["rax", "rbx", "rcx", "rdx", "rsp", "rbp", "rdi", "rsi"]
            has_x64_regs = any(reg in result.lower() for reg in x64_regs)
            # x64 ROP chains should use 64-bit registers
            if not result.startswith("0x"):  # If not just addresses
                assert has_x64_regs

    def test_generate_ret2libc_x86(self):
        """Test ret2libc exploit generation for x86."""
        result = _generate_ret2libc_x86()

        assert isinstance(result, str)
        assert len(result) > 20

        # ret2libc should reference libc functions
        libc_functions = ["system", "execve", "printf", "strcpy", "gets"]
        libc_references = ["/bin/sh", "libc", "plt", "got"]

        content_lower = result.lower()
        has_libc_elements = (
            any(func in content_lower for func in libc_functions) or
            any(ref in content_lower for ref in libc_references)
        )
        assert has_libc_elements

    def test_generate_format_string_x86(self):
        """Test format string exploit generation for x86."""
        result = _generate_format_string_x86()

        assert isinstance(result, str)
        assert len(result) > 15

        # Format string exploits should contain format specifiers
        format_specifiers = ["%n", "%p", "%x", "%s", "%d", "%c"]
        has_format_specs = any(spec in result for spec in format_specifiers)
        assert has_format_specs

        # Should not be simple placeholder
        assert result.count("%") > 1  # Multiple format specifiers expected

    def test_generate_integer_overflow(self):
        """Test integer overflow exploit generation."""
        result = _generate_integer_overflow()

        assert isinstance(result, str)
        assert len(result) > 20

        # Should reference integer overflow concepts
        overflow_keywords = [
            "overflow", "integer", "wrap", "max", "min",
            "boundary", "size", "length", "malloc", "calloc"
        ]

        content_lower = result.lower()
        has_overflow_elements = any(keyword in content_lower
                                  for keyword in overflow_keywords)
        assert has_overflow_elements

    def test_generate_reflective_loader_shellcode(self):
        """Test reflective DLL loader shellcode generation."""
        result = _generate_reflective_loader_shellcode()

        assert isinstance(result, bytes)
        assert len(result) > 50  # Substantial shellcode

        # Should be binary shellcode data
        assert isinstance(result, bytes)

        # Should not be all zeros or simple pattern
        unique_bytes = set(result)
        assert len(unique_bytes) > 5  # Diverse byte values

        # Should not be placeholder text encoded
        assert b"PLACEHOLDER" not in result
        assert b"TODO" not in result


class TestExploitGeneration:
    """Test suite for exploit generation functions."""

    def test_generate_exploit_buffer_overflow_comprehensive(self):
        """Test comprehensive buffer overflow exploit generation."""
        architectures = ["x86", "x64"]
        payload_types = ["shellcode", "rop_chain", "ret2libc"]

        for arch in architectures:
            for payload in payload_types:
                result = generate_exploit(
                    vulnerability="buffer_overflow",
                    target_arch=arch,
                    payload_type=payload
                )

                assert isinstance(result, dict)
                assert "exploit_code" in result
                assert "success" in result
                assert "architecture" in result

                if result["success"]:
                    assert result["architecture"] == arch

                    exploit_code = result["exploit_code"]
                    assert isinstance(exploit_code, str)
                    assert len(exploit_code) > 50

                    # Should contain architecture-specific elements
                    if arch == "x86":
                        # x86 exploits might reference 32-bit addresses
                        assert not all(c in "0123456789" for c in exploit_code[:10])

                    # Should contain payload-specific elements
                    if payload == "shellcode":
                        assert "shellcode" in result
                        shellcode = result["shellcode"]
                        assert isinstance(shellcode, (str, bytes))
                        assert len(str(shellcode)) > 10
                    elif payload == "rop_chain":
                        # ROP chain exploits should reference gadgets or addresses
                        assert any(keyword in exploit_code.lower()
                                 for keyword in ["rop", "gadget", "0x", "ret"])

    def test_generate_exploit_format_string_comprehensive(self):
        """Test comprehensive format string exploit generation."""
        result = generate_exploit(
            vulnerability="format_string",
            target_arch="x86",
            payload_type="direct_write"
        )

        assert isinstance(result, dict)

        if result.get("success"):
            exploit_code = result["exploit_code"]

            # Format string exploits should use format specifiers
            format_specs = ["%n", "%p", "%x", "%s"]
            has_format_specs = any(spec in exploit_code for spec in format_specs)
            assert has_format_specs

            # Should have multiple format specifiers for sophisticated exploit
            format_count = sum(exploit_code.count(spec) for spec in format_specs)
            assert format_count >= 2

    def test_generate_exploit_integer_overflow(self):
        """Test integer overflow exploit generation."""
        result = generate_exploit(
            vulnerability="integer_overflow",
            target_arch="x64",
            payload_type="heap_spray"
        )

        assert isinstance(result, dict)

        if result.get("success"):
            exploit_code = result["exploit_code"]

            # Integer overflow exploits should reference size calculations
            size_keywords = ["size", "length", "malloc", "calloc", "realloc"]
            has_size_refs = any(keyword in exploit_code.lower()
                               for keyword in size_keywords)
            assert has_size_refs

    def test_generate_exploit_use_after_free(self):
        """Test use-after-free exploit generation."""
        result = generate_exploit(
            vulnerability="use_after_free",
            target_arch="x64",
            payload_type="controlled_write"
        )

        assert isinstance(result, dict)

        if result.get("success"):
            exploit_code = result["exploit_code"]

            # UAF exploits should reference heap management
            heap_keywords = ["free", "malloc", "heap", "chunk", "allocation"]
            has_heap_refs = any(keyword in exploit_code.lower()
                               for keyword in heap_keywords)
            assert has_heap_refs


class TestRopChainGeneration:
    """Test suite for ROP chain generation and analysis."""

    def test_generate_chains_rop_x86_comprehensive(self):
        """Test comprehensive ROP chain generation for x86."""
        result = generate_chains(
            chain_type="rop",
            architecture="x86"
        )

        assert isinstance(result, dict)
        assert "chain" in result
        assert "gadgets" in result
        assert "success" in result

        if result["success"]:
            chain = result["chain"]
            gadgets = result["gadgets"]

            assert isinstance(chain, list)
            assert isinstance(gadgets, list)
            assert len(chain) > 0
            assert len(gadgets) > 0

            # Chain elements should be addresses or references
            for element in chain:
                assert isinstance(element, (int, str))
                if isinstance(element, str):
                    # Should be hex address or gadget reference
                    is_hex = element.startswith("0x") or element.isdigit()
                    is_gadget_ref = "gadget" in element.lower()
                    assert is_hex or is_gadget_ref
                elif isinstance(element, int):
                    # Should be valid memory address
                    assert element > 0

            # Gadgets should have descriptions or addresses
            for gadget in gadgets:
                assert isinstance(gadget, (str, dict))
                if isinstance(gadget, dict):
                    assert "address" in gadget or "instruction" in gadget
                elif isinstance(gadget, str):
                    assert len(gadget) > 3

    def test_generate_chains_jop_x64(self):
        """Test JOP (Jump-Oriented Programming) chain generation for x64."""
        result = generate_chains(
            chain_type="jop",
            architecture="x64"
        )

        assert isinstance(result, dict)

        if result.get("success"):
            chain = result["chain"]

            # JOP chains should contain jump-based gadgets
            chain_str = str(chain)
            jump_instructions = ["jmp", "call", "jne", "je", "jz", "jnz"]
            has_jump_instr = any(instr in chain_str.lower()
                               for instr in jump_instructions)

            # JOP chains are less common, so success is not guaranteed
            # but if successful, should contain jump elements
            if has_jump_instr:
                assert has_jump_instr

    def test_generate_basic_rop_chain_target_specific(self):
        """Test basic ROP chain generation for specific target."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            # Create minimal binary for testing
            temp_target.write(b'MZ' + b'\x00' * 100)
            temp_target.flush()

            try:
                result = _generate_basic_rop_chain(temp_target.name)

                assert isinstance(result, list)
                assert len(result) > 0

                # ROP chain should contain multiple elements
                assert len(result) >= 3  # Minimum viable ROP chain

                # Elements should be strings or addresses
                for element in result:
                    assert isinstance(element, str)
                    assert len(element) > 0

            finally:
                os.unlink(temp_target.name)


class TestVulnerabilityAnalysis:
    """Test suite for vulnerability analysis and exploit selection."""

    def test_analyze_target_vulnerabilities_comprehensive(self):
        """Test comprehensive vulnerability analysis of target binary."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            # Create binary with various vulnerability patterns
            vuln_binary = self._create_vulnerable_binary()
            temp_target.write(vuln_binary)
            temp_target.flush()

            try:
                result = _analyze_target_vulnerabilities(temp_target.name)

                assert isinstance(result, list)

                # Should find some vulnerabilities in our crafted binary
                if len(result) > 0:
                    for vulnerability in result:
                        assert isinstance(vulnerability, dict)
                        assert "type" in vulnerability
                        assert "severity" in vulnerability or "confidence" in vulnerability

                        # Vulnerability types should be recognized
                        vuln_type = vulnerability["type"]
                        known_types = [
                            "buffer_overflow", "format_string", "integer_overflow",
                            "use_after_free", "double_free", "stack_overflow",
                            "heap_overflow", "null_pointer_dereference"
                        ]
                        assert vuln_type in known_types or "unknown" in vuln_type.lower()

            finally:
                os.unlink(temp_target.name)

    def test_select_best_exploit_strategy(self):
        """Test exploit strategy selection based on vulnerabilities."""
        sample_vulnerabilities = [
            {
                "type": "buffer_overflow",
                "severity": "high",
                "confidence": 0.9,
                "exploitability": "easy"
            },
            {
                "type": "format_string",
                "severity": "medium",
                "confidence": 0.7,
                "exploitability": "medium"
            },
            {
                "type": "integer_overflow",
                "severity": "low",
                "confidence": 0.5,
                "exploitability": "hard"
            }
        ]

        result = _select_best_exploit(sample_vulnerabilities)

        assert isinstance(result, str)

        # Should select the most viable exploit
        expected_exploits = [
            "buffer_overflow", "format_string", "integer_overflow",
            "rop_chain", "shellcode_injection", "none"
        ]
        assert result in expected_exploits

        # With our sample data, should prefer buffer_overflow (highest severity/confidence)
        if result != "none":
            # Should not select the lowest confidence/severity option
            assert result != "integer_overflow"

    def test_find_dll_hijack_opportunities(self):
        """Test DLL hijacking opportunity detection."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            # Create binary with DLL import patterns
            dll_binary = self._create_dll_dependent_binary()
            temp_target.write(dll_binary)
            temp_target.flush()

            try:
                result = _find_dll_hijack_opportunities(temp_target.name)

                assert isinstance(result, list)

                # Should find DLL hijacking opportunities
                if len(result) > 0:
                    for opportunity in result:
                        assert isinstance(opportunity, str)
                        assert len(opportunity) > 3

                        # Should be DLL names or paths
                        dll_indicators = [".dll", "kernel32", "user32", "ntdll", "library"]
                        has_dll_indicator = any(indicator in opportunity.lower()
                                              for indicator in dll_indicators)
                        assert has_dll_indicator

            finally:
                os.unlink(temp_target.name)

    def _create_vulnerable_binary(self) -> bytes:
        """Create binary with vulnerability patterns for testing."""
        return (
            b'MZ' + b'\x00' * 60 +  # DOS header
            b'PE\x00\x00' + b'\x00' * 100 +  # PE headers
            b'strcpy\x00strcat\x00gets\x00' +  # Vulnerable functions
            b'sprintf\x00printf\x00scanf\x00' +  # Format string functions
            b'malloc\x00free\x00realloc\x00' +  # Heap functions
            b'BUFFER_OVERFLOW_VULN\x00' +
            b'FORMAT_STRING_%s_%d\x00' +
            b'\x00' * 200
        )

    def _create_dll_dependent_binary(self) -> bytes:
        """Create binary with DLL dependencies for hijacking tests."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 100 +
            b'kernel32.dll\x00user32.dll\x00' +
            b'advapi32.dll\x00shell32.dll\x00' +
            b'LoadLibraryA\x00GetProcAddress\x00' +
            b'customlib.dll\x00thirdparty.dll\x00' +
            b'\x00' * 100
        )


class TestExploitExecution:
    """Test suite for exploit execution functions."""

    def test_execute_buffer_overflow_exploit(self):
        """Test buffer overflow exploit execution."""
        vuln_info = {
            "type": "buffer_overflow",
            "buffer_size": 256,
            "return_address_offset": 268,
            "target_function": "vulnerable_function"
        }

        payload = "A" * 268 + "\\x41\\x42\\x43\\x44"  # Overwrite return address

        result = _execute_buffer_overflow_exploit(
            target="test_vulnerable.exe",
            payload=payload,
            vuln_info=vuln_info
        )

        assert isinstance(result, dict)
        assert "success" in result
        assert "execution_result" in result
        assert "payload_delivered" in result

        # Should attempt execution even if target doesn't exist
        execution_result = result["execution_result"]
        assert isinstance(execution_result, str)

        payload_delivered = result["payload_delivered"]
        assert isinstance(payload_delivered, bool)

    def test_execute_format_string_exploit(self):
        """Test format string exploit execution."""
        vuln_info = {
            "type": "format_string",
            "vulnerable_function": "printf",
            "control_string_offset": 4,
            "target_address": "0x08048000"
        }

        payload = "%x%x%x%n"  # Format string payload

        result = _execute_format_string_exploit(
            target="test_format_vuln.exe",
            payload=payload,
            vuln_info=vuln_info
        )

        assert isinstance(result, dict)
        assert "success" in result
        assert "execution_result" in result

        # Format string exploit should reference the payload
        execution_result = result["execution_result"]
        assert isinstance(execution_result, str)

    def test_execute_rop_chain_exploit(self):
        """Test ROP chain exploit execution."""
        rop_chain = [
            "0x08048123",  # pop eax; ret
            "0x0804a000",  # data value
            "0x08048456",  # pop ebx; ret
            "0x00000000",  # null
            "0x08048789"   # system call
        ]

        result = _execute_rop_chain_exploit(
            target="test_rop_vuln.exe",
            rop_chain=rop_chain
        )

        assert isinstance(result, dict)
        assert "success" in result
        assert "chain_executed" in result

        chain_executed = result["chain_executed"]
        assert isinstance(chain_executed, bool)

        # Should reference the ROP chain
        if "execution_details" in result:
            details = result["execution_details"]
            assert isinstance(details, str)
            rop_addresses = [addr for addr in rop_chain if addr.startswith("0x")]
            # Should reference some of the ROP addresses
            has_addresses = any(addr in details for addr in rop_addresses[:2])


class TestExploitStrategyGeneration:
    """Test suite for exploit strategy and planning functions."""

    def test_generate_exploit_strategy_comprehensive(self):
        """Test comprehensive exploit strategy generation."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create realistic vulnerable binary
            vuln_binary = self._create_comprehensive_vulnerable_binary()
            temp_binary.write(vuln_binary)
            temp_binary.flush()

            try:
                vulnerability_types = [
                    "buffer_overflow", "format_string", "integer_overflow",
                    "memory_corruption", "injection"
                ]

                for vuln_type in vulnerability_types:
                    result = generate_exploit_strategy(
                        binary_path=temp_binary.name,
                        vulnerability_type=vuln_type
                    )

                    assert isinstance(result, dict)
                    assert "strategy" in result
                    assert "success" in result

                    if result["success"]:
                        strategy = result["strategy"]
                        assert isinstance(strategy, str)
                        assert len(strategy) > 100  # Detailed strategy

                        # Strategy should reference vulnerability type
                        assert vuln_type.replace("_", " ") in strategy.lower()

                        # Should contain strategic elements
                        strategy_keywords = [
                            "exploit", "payload", "target", "vulnerability",
                            "technique", "approach", "method"
                        ]
                        has_strategy_elements = any(keyword in strategy.lower()
                                                  for keyword in strategy_keywords)
                        assert has_strategy_elements

                        # Should have technical depth
                        technical_keywords = [
                            "address", "memory", "register", "stack", "heap",
                            "instruction", "assembly", "shellcode"
                        ]
                        has_technical_depth = any(keyword in strategy.lower()
                                                for keyword in technical_keywords)
                        assert has_technical_depth

            finally:
                os.unlink(temp_binary.name)

    def test_exploit_function_auto_selection(self):
        """Test main exploit function with automatic exploit selection."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            temp_target.write(self._create_comprehensive_vulnerable_binary())
            temp_target.flush()

            try:
                result = exploit(
                    target=temp_target.name,
                    exploit_type="auto",
                    payload=None
                )

                assert isinstance(result, dict)
                assert "success" in result
                assert "exploit_type_used" in result

                if result["success"]:
                    exploit_type_used = result["exploit_type_used"]
                    known_exploit_types = [
                        "buffer_overflow", "format_string", "rop_chain",
                        "dll_hijacking", "license_bypass", "shellcode_injection"
                    ]
                    assert exploit_type_used in known_exploit_types

                    # Should provide execution details
                    assert "execution_result" in result or "payload_delivered" in result

            finally:
                os.unlink(temp_target.name)

    def test_exploit_function_specific_types(self):
        """Test exploit function with specific exploit types."""
        exploit_types_to_test = [
            "buffer_overflow", "format_string", "rop_chain", "dll_hijacking"
        ]

        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            temp_target.write(self._create_comprehensive_vulnerable_binary())
            temp_target.flush()

            try:
                for exploit_type in exploit_types_to_test:
                    result = exploit(
                        target=temp_target.name,
                        exploit_type=exploit_type,
                        payload="test_payload"
                    )

                    assert isinstance(result, dict)
                    assert "success" in result

                    if result["success"]:
                        # Should use the specified exploit type
                        assert result.get("exploit_type_used") == exploit_type

                        # Should reference the provided payload
                        assert result.get("payload_delivered") is True

            finally:
                os.unlink(temp_target.name)

    def _create_comprehensive_vulnerable_binary(self) -> bytes:
        """Create comprehensive vulnerable binary for strategy testing."""
        return (
            b'MZ' + b'\x00' * 60 +  # DOS header
            b'PE\x00\x00' + b'\x00' * 100 +  # PE headers

            # Vulnerable functions
            b'strcpy\x00strcat\x00gets\x00sprintf\x00' +
            b'memcpy\x00strncpy\x00scanf\x00vsprintf\x00' +

            # Format string vulnerabilities
            b'printf\x00fprintf\x00syslog\x00snprintf\x00' +

            # Memory management
            b'malloc\x00free\x00realloc\x00calloc\x00' +

            # System functions
            b'system\x00exec\x00CreateProcess\x00' +

            # DLL imports
            b'kernel32.dll\x00user32.dll\x00ntdll.dll\x00' +
            b'LoadLibraryA\x00GetProcAddress\x00' +

            # Vulnerability indicators
            b'BUFFER_OVERFLOW_FUNCTION\x00' +
            b'FORMAT_STRING_VULN_%s_%d\x00' +
            b'HEAP_OVERFLOW_DETECTED\x00' +
            b'INTEGER_OVERFLOW_CHECK\x00' +

            # License/registration patterns
            b'LICENSE_CHECK\x00REGISTRATION_KEY\x00' +
            b'TRIAL_EXPIRED\x00INVALID_KEY\x00' +

            b'\x00' * 300
        )


class TestArchitectureSpecificExploits:
    """Test suite for architecture-specific exploit generation."""

    def test_cross_architecture_exploit_generation(self):
        """Test exploit generation across different architectures."""
        architectures = ["x86", "x64", "arm", "mips"]
        vulnerabilities = ["buffer_overflow", "format_string", "rop_chain"]

        successful_exploits = 0
        total_tests = len(architectures) * len(vulnerabilities)

        for arch in architectures:
            for vuln in vulnerabilities:
                try:
                    result = generate_exploit(
                        vulnerability=vuln,
                        target_arch=arch,
                        payload_type="shellcode"
                    )

                    if result.get("success"):
                        successful_exploits += 1

                        # Validate architecture-specific adaptations
                        assert result["architecture"] == arch

                        exploit_code = result["exploit_code"]
                        assert len(exploit_code) > 20

                        # Architecture-specific validations
                        if arch in ["x86", "x64"]:
                            # Intel architectures should have certain characteristics
                            intel_elements = ["eax", "ebx", "ecx", "esp", "ebp",
                                            "rax", "rbx", "rcx", "rsp", "rbp",
                                            "push", "pop", "mov", "call", "ret"]

                            if any(elem in exploit_code.lower() for elem in intel_elements):
                                # If assembly format, should be Intel-like
                                has_intel = any(elem in exploit_code.lower()
                                              for elem in intel_elements[:5] + intel_elements[10:])
                                assert has_intel

                        elif arch == "arm":
                            # ARM architecture might have different characteristics
                            if "r0" in exploit_code.lower() or "r1" in exploit_code.lower():
                                arm_regs = ["r0", "r1", "r2", "r3", "sp", "lr", "pc"]
                                has_arm_regs = any(reg in exploit_code.lower()
                                                 for reg in arm_regs)
                                assert has_arm_regs

                except Exception as e:
                    # Some architecture/vulnerability combinations might not be supported
                    continue

        # Should successfully generate exploits for reasonable percentage
        success_rate = successful_exploits / total_tests if total_tests > 0 else 0
        assert success_rate > 0.3  # At least 30% success rate expected

        # Should support at least x86 and x64
        x86_x64_tests = len(vulnerabilities) * 2  # x86 + x64
        x86_x64_successes = 0

        for arch in ["x86", "x64"]:
            for vuln in vulnerabilities:
                try:
                    result = generate_exploit(vulnerability=vuln, target_arch=arch)
                    if result.get("success"):
                        x86_x64_successes += 1
                except:
                    continue

        x86_x64_success_rate = x86_x64_successes / x86_x64_tests if x86_x64_tests > 0 else 0
        assert x86_x64_success_rate > 0.5  # Higher success rate for common architectures


class TestIntegrationScenarios:
    """Integration tests for complete exploit generation workflows."""

    def test_end_to_end_exploit_development_workflow(self):
        """Test complete exploit development from analysis to execution."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            vuln_binary = self._create_realistic_vulnerable_target()
            temp_target.write(vuln_binary)
            temp_target.flush()

            try:
                # Step 1: Analyze target for vulnerabilities
                vulnerabilities = _analyze_target_vulnerabilities(temp_target.name)
                assert isinstance(vulnerabilities, list)

                if len(vulnerabilities) > 0:
                    # Step 2: Select best exploit strategy
                    best_exploit = _select_best_exploit(vulnerabilities)
                    assert isinstance(best_exploit, str)

                    if best_exploit != "none":
                        # Step 3: Generate exploit strategy
                        strategy = generate_exploit_strategy(
                            binary_path=temp_target.name,
                            vulnerability_type=best_exploit
                        )
                        assert strategy.get("success") is True

                        # Step 4: Generate specific exploit
                        exploit_result = generate_exploit(
                            vulnerability=best_exploit,
                            target_arch="x86",
                            payload_type="shellcode"
                        )

                        if exploit_result.get("success"):
                            # Step 5: Execute exploit (simulation)
                            execution_result = exploit(
                                target=temp_target.name,
                                exploit_type=best_exploit,
                                payload=exploit_result.get("shellcode", "test_payload")
                            )

                            assert isinstance(execution_result, dict)
                            assert "success" in execution_result

                            # Workflow should be consistent
                            assert execution_result.get("exploit_type_used") == best_exploit

            finally:
                os.unlink(temp_target.name)

    def test_multi_stage_exploit_generation(self):
        """Test multi-stage exploit generation process."""
        # Stage 1: Information gathering
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_target:
            temp_target.write(self._create_realistic_vulnerable_target())
            temp_target.flush()

            try:
                # Stage 2: Initial exploit
                initial_exploit = generate_exploit(
                    vulnerability="buffer_overflow",
                    target_arch="x86",
                    payload_type="stage1"
                )

                if initial_exploit.get("success"):
                    # Stage 3: ROP chain for ASLR bypass
                    rop_chain = generate_chains(
                        chain_type="rop",
                        architecture="x86"
                    )

                    if rop_chain.get("success"):
                        # Stage 4: Final shellcode delivery
                        final_exploit = generate_exploit(
                            vulnerability="buffer_overflow",
                            target_arch="x86",
                            payload_type="shellcode"
                        )

                        assert final_exploit.get("success") is True

                        # Multi-stage should be more sophisticated
                        final_code = final_exploit["exploit_code"]
                        assert len(final_code) > len(initial_exploit["exploit_code"])

            finally:
                os.unlink(temp_target.name)

    def _create_realistic_vulnerable_target(self) -> bytes:
        """Create realistic vulnerable target for integration testing."""
        return (
            b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xFF\xFF\x00\x00' +  # DOS header start
            b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00' +
            b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' +
            b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00' +  # DOS header end

            b'PE\x00\x00' +  # PE signature
            b'\x4c\x01\x03\x00' +  # Machine type + number of sections
            b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' +  # Timestamp + symbol table
            b'\xe0\x00\x0f\x01' +  # Size of optional header + characteristics

            b'\x0b\x01\x08\x00' +  # Optional header magic + linker version
            b'\x00\x10\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00' +  # Code/data sizes
            b'\x10\x10\x00\x00\x00\x10\x00\x00\x00\x00\x40\x00' +  # Entry point + base addresses

            b'\x00' * 100 +  # Padding for optional header

            # Import table with vulnerable functions
            b'kernel32.dll\x00' +
            b'GetCommandLineA\x00GetStartupInfoA\x00ExitProcess\x00' +
            b'lstrcpyA\x00lstrcatA\x00lstrlenA\x00' +  # Vulnerable string functions

            # C runtime vulnerable functions
            b'msvcrt.dll\x00' +
            b'strcpy\x00strcat\x00gets\x00sprintf\x00' +
            b'printf\x00scanf\x00malloc\x00free\x00' +

            # Vulnerability patterns
            b'VULNERABLE_FUNCTION_BUFFER[256]\x00' +
            b'FORMAT_STRING_VULN_%s_%d_%x\x00' +
            b'INTEGER_OVERFLOW_SIZE_CALC\x00' +
            b'HEAP_OVERFLOW_ALLOCATION\x00' +

            # Stack canary patterns (indicating modern protections)
            b'__stack_chk_fail\x00__security_cookie\x00' +

            # Exception handling
            b'_except_handler\x00RtlUnwind\x00' +

            b'\x00' * 200  # Padding
        )


@pytest.mark.performance
class TestPerformanceAndScalability:
    """Performance tests for exploit generation functions."""

    def test_exploit_generation_performance(self):
        """Test exploit generation performance under load."""
        import time

        start_time = time.time()

        # Generate multiple exploits in sequence
        exploit_count = 20
        successful_generations = 0

        for i in range(exploit_count):
            result = generate_exploit(
                vulnerability="buffer_overflow",
                target_arch="x86" if i % 2 == 0 else "x64",
                payload_type="shellcode"
            )

            if result.get("success"):
                successful_generations += 1

        end_time = time.time()
        total_time = end_time - start_time

        # Performance requirements
        assert total_time < 60.0  # Should complete within 60 seconds

        if successful_generations > 0:
            avg_time_per_exploit = total_time / successful_generations
            assert avg_time_per_exploit < 5.0  # Max 5 seconds per exploit

        # Should have reasonable success rate
        success_rate = successful_generations / exploit_count
        assert success_rate > 0.5  # At least 50% should succeed

    def test_large_rop_chain_generation(self):
        """Test generation of large ROP chains."""
        import time

        start_time = time.time()

        result = generate_chains(
            chain_type="rop",
            architecture="x86"
        )

        end_time = time.time()
        generation_time = end_time - start_time

        # Should complete within reasonable time
        assert generation_time < 10.0

        if result.get("success"):
            chain = result["chain"]

            # Large ROP chain should have substantial content
            assert len(chain) >= 5  # Minimum viable chain
            assert len(chain) <= 1000  # Reasonable upper limit

            # Performance: should generate at least 1 gadget per second
            if generation_time > 0:
                gadgets_per_second = len(chain) / generation_time
                assert gadgets_per_second >= 1
