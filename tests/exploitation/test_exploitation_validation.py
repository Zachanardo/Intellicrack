"""Exploitation Validation Tests for Intellicrack.

This module tests actual license bypass generation, patch effectiveness,
and protection defeat mechanisms against real binaries.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

import os
import struct
import sys
import tempfile
import unittest
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from intellicrack.core.analysis.binary_analyzer import BinaryAnalyzer
from intellicrack.core.exploitation.license_bypass_generator import LicenseBypassGenerator
from intellicrack.core.exploitation.patch_engine import PatchEngine
from intellicrack.core.protection.anti_tamper_defeater import AntiTamperDefeater
from intellicrack.core.protection.hwid_spoofer import HWIDSpoofer
from intellicrack.core.protection.time_protection_bypasser import TimeProtectionBypasser
from intellicrack.core.protection.network_license_emulator import NetworkLicenseEmulator


class ExploitationValidationTest(unittest.TestCase):
    """Test suite for exploitation validation."""

    @classmethod
    def setUpClass(cls):
        """Set up test fixtures."""
        cls.test_dir = Path(tempfile.mkdtemp(prefix="intellicrack_test_"))
        cls.sample_binaries = cls._create_test_binaries()

    @classmethod
    def tearDownClass(cls):
        """Clean up test fixtures."""
        import shutil
        if cls.test_dir.exists():
            shutil.rmtree(cls.test_dir)

    @classmethod
    def _create_test_binaries(cls) -> dict[str, Path]:
        """Create test binaries with various protection schemes.

        Returns:
            Dictionary of test binary paths
        """
        # Create simple license check binary
        license_check_code = bytes([
            # PE header
            0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
            0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            # ... minimal PE structure ...
            # License check routine
            0x55,                    # push ebp
            0x89, 0xE5,             # mov ebp, esp
            0x81, 0xEC, 0x20, 0x00, # sub esp, 0x20
            # Check license key
            0x68, 0x00, 0x10, 0x40, 0x00,  # push license_string
            0xE8, 0x00, 0x00, 0x00, 0x00,  # call check_license
            0x85, 0xC0,                    # test eax, eax
            0x74, 0x05,                    # jz invalid_license
            0xB8, 0x01, 0x00, 0x00, 0x00, # mov eax, 1 (valid)
            0xEB, 0x03,                    # jmp done
            0xB8, 0x00, 0x00, 0x00, 0x00, # mov eax, 0 (invalid)
            0x89, 0xEC,                    # mov esp, ebp
            0x5D,                          # pop ebp
            0xC3                           # ret
        ])

        license_binary = cls.test_dir / "license_check.exe"
        license_binary.write_bytes(license_check_code)
        binaries = {"license_check": license_binary}
        # Create time-locked binary
        time_lock_code = bytes([
            # PE header (minimal)
            0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
            # Time check routine
            0x55,                          # push ebp
            0x89, 0xE5,                   # mov ebp, esp
            0xFF, 0x15, 0x00, 0x20, 0x40, 0x00,  # call GetSystemTime
            0x81, 0x3D, 0x00, 0x30, 0x40, 0x00,  # cmp [timestamp],
            0x00, 0x00, 0x00, 0x00,             # expiry_date
            0x7C, 0x05,                         # jl not_expired
            0xB8, 0x00, 0x00, 0x00, 0x00,      # mov eax, 0 (expired)
            0xEB, 0x03,                         # jmp done
            0xB8, 0x01, 0x00, 0x00, 0x00,      # mov eax, 1 (valid)
            0x89, 0xEC,                         # mov esp, ebp
            0x5D,                               # pop ebp
            0xC3                                # ret
        ])

        time_binary = cls.test_dir / "time_lock.exe"
        time_binary.write_bytes(time_lock_code)
        binaries["time_lock"] = time_binary

        # Create hardware ID check binary
        hwid_check_code = bytes([
            # PE header (minimal)
            0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
            # HWID check routine
            0x55,                               # push ebp
            0x89, 0xE5,                        # mov ebp, esp
            0x0F, 0xA2,                        # cpuid
            0x89, 0x45, 0xFC,                 # mov [ebp-4], eax
            0x89, 0x5D, 0xF8,                 # mov [ebp-8], ebx
            0x89, 0x4D, 0xF4,                 # mov [ebp-12], ecx
            0x89, 0x55, 0xF0,                 # mov [ebp-16], edx
            # Compare with stored HWID
            0x8B, 0x45, 0xFC,                 # mov eax, [ebp-4]
            0x3B, 0x05, 0x00, 0x40, 0x40, 0x00,  # cmp eax, [stored_hwid]
            0x75, 0x05,                          # jne invalid_hwid
            0xB8, 0x01, 0x00, 0x00, 0x00,       # mov eax, 1 (valid)
            0xEB, 0x03,                          # jmp done
            0xB8, 0x00, 0x00, 0x00, 0x00,       # mov eax, 0 (invalid)
            0x89, 0xEC,                          # mov esp, ebp
            0x5D,                                # pop ebp
            0xC3                                 # ret
        ])

        hwid_binary = cls.test_dir / "hwid_check.exe"
        hwid_binary.write_bytes(hwid_check_code)
        binaries["hwid_check"] = hwid_binary

        return binaries

    def test_license_bypass_generation(self):
        """Test actual license bypass generation."""
        generator = LicenseBypassGenerator()
        binary_path = self.sample_binaries["license_check"]

        # Analyze the binary
        analyzer = BinaryAnalyzer(str(binary_path))
        analysis = analyzer.analyze()

        # Generate bypass
        bypass = generator.generate_bypass(
            binary_path=str(binary_path),
            analysis_data=analysis,
            bypass_type="patch"
        )

        # Verify bypass structure
        self.assertIn("type", bypass)
        self.assertIn("patches", bypass)
        self.assertIn("success", bypass)
        self.assertTrue(bypass["success"])

        # Verify patches contain actual modifications
        for patch in bypass["patches"]:
            self.assertIn("offset", patch)
            self.assertIn("original", patch)
            self.assertIn("replacement", patch)
            self.assertIsInstance(patch["offset"], int)
            self.assertIsInstance(patch["original"], bytes)
            self.assertIsInstance(patch["replacement"], bytes)

        # Test keygen generation
        keygen_bypass = generator.generate_bypass(
            binary_path=str(binary_path),
            analysis_data=analysis,
            bypass_type="keygen"
        )

        self.assertIn("algorithm", keygen_bypass)
        self.assertIn("constraints", keygen_bypass)
        self.assertIn("generator", keygen_bypass)

        # Generate and validate a key
        key = keygen_bypass["generator"]()
        self.assertIsInstance(key, str)
        self.assertTrue(len(key) > 0)

    def test_patch_effectiveness(self):
        """Test effectiveness of generated patches."""
        engine = PatchEngine()
        binary_path = self.sample_binaries["license_check"]

        # Create a backup
        backup_path = binary_path.with_suffix('.bak')
        backup_path.write_bytes(binary_path.read_bytes())

        try:
            # Generate patch to bypass license check
            patches = [
                {
                    "offset": 0x40,  # License check JZ instruction
                    "original": bytes([0x74, 0x05]),  # jz
                    "replacement": bytes([0x90, 0x90])  # nop nop
                },
                {
                    "offset": 0x47,  # Return value
                    "original": bytes([0xB8, 0x00, 0x00, 0x00, 0x00]),
                    "replacement": bytes([0xB8, 0x01, 0x00, 0x00, 0x00])  # Always return 1
                }
            ]

            # Apply patches
            result = engine.apply_patches(str(binary_path), patches)
            self.assertTrue(result["success"])
            self.assertEqual(len(result["applied"]), 2)

            # Verify patches were applied
            patched_data = binary_path.read_bytes()
            self.assertEqual(patched_data[0x40:0x42], bytes([0x90, 0x90]))
            self.assertEqual(patched_data[0x47:0x4C], bytes([0xB8, 0x01, 0x00, 0x00, 0x00]))

            # Test patch reversal
            revert_result = engine.revert_patches(str(binary_path), patches)
            self.assertTrue(revert_result["success"])

            # Verify original state restored
            reverted_data = binary_path.read_bytes()
            original_data = backup_path.read_bytes()
            self.assertEqual(reverted_data[:0x50], original_data[:0x50])

        finally:
            # Restore original
            if backup_path.exists():
                binary_path.write_bytes(backup_path.read_bytes())
                backup_path.unlink()

    def test_anti_tamper_defeat(self):
        """Test defeating anti-tamper protections."""
        defeater = AntiTamperDefeater()

        # Create binary with checksum verification
        protected_binary = self.test_dir / "protected.exe"

        # Simple PE with embedded checksum
        data = bytearray([
            # PE header
            0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
            # ... rest of PE ...
        ])

        # Add checksum at known location
        checksum = sum(data) & 0xFFFFFFFF
        data.extend(struct.pack("<I", checksum))

        protected_binary.write_bytes(bytes(data))

        # Analyze protections
        protections = defeater.analyze_protections(str(protected_binary))
        self.assertIn("checksum", protections)
        self.assertIn("integrity_checks", protections)

        # Defeat protections
        defeat_result = defeater.defeat_protections(
            binary_path=str(protected_binary),
            protections=protections
        )

        self.assertTrue(defeat_result["success"])
        self.assertIn("defeated", defeat_result)
        self.assertIn("checksum", defeat_result["defeated"])

        # Verify checksum was neutralized
        modified_data = protected_binary.read_bytes()
        # The defeater should have patched the checksum verification
        self.assertNotEqual(modified_data, data)

    def test_hardware_id_spoofing(self):
        """Test hardware ID spoofing functionality."""
        spoofer = HWIDSpoofer()
        binary_path = self.sample_binaries["hwid_check"]

        # Detect HWID checks
        checks = spoofer.detect_hwid_checks(str(binary_path))
        self.assertGreater(len(checks), 0)

        for check in checks:
            self.assertIn("type", check)
            self.assertIn("offset", check)
            self.assertIn("method", check)

        # Generate spoof patches with actual hardware identifier
        spoof_hwid = "BFEBFBFF000906EA-C0A80164-WD1234567890"  # Real CPU ID + MAC + Serial format
        patches = spoofer.generate_spoof_patches(
            binary_path=str(binary_path),
            target_hwid=spoof_hwid,
            checks=checks
        )

        self.assertGreater(len(patches), 0)

        for patch in patches:
            self.assertIn("offset", patch)
            self.assertIn("original", patch)
            self.assertIn("replacement", patch)
            self.assertIn("description", patch)

        # Test dynamic spoofing hook
        hook = spoofer.generate_dynamic_hook(
            checks=checks,
            target_hwid=spoof_hwid
        )

        self.assertIn("hook_code", hook)
        self.assertIn("injection_point", hook)
        self.assertIn("detour_size", hook)

    def test_time_based_protection_bypass(self):
        """Test bypassing time-based protections."""
        bypasser = TimeProtectionBypasser()
        binary_path = self.sample_binaries["time_lock"]

        # Detect time checks
        time_checks = bypasser.detect_time_checks(str(binary_path))
        self.assertGreater(len(time_checks), 0)

        for check in time_checks:
            self.assertIn("type", check)  # trial, expiry, time_bomb
            self.assertIn("offset", check)
            self.assertIn("api_call", check)

        # Generate bypass
        bypass = bypasser.generate_bypass(
            binary_path=str(binary_path),
            time_checks=time_checks,
            bypass_method="patch"  # or "hook"
        )

        self.assertTrue(bypass["success"])
        self.assertIn("patches", bypass)
        self.assertIn("description", bypass)

        # Test time freeze hook
        freeze_hook = bypasser.generate_time_freeze_hook(
            target_time="2025-01-01 00:00:00",
            api_calls=["GetSystemTime", "time", "GetLocalTime"]
        )

        self.assertIn("hook_code", freeze_hook)
        self.assertIn("target_timestamp", freeze_hook)
        self.assertEqual(freeze_hook["target_timestamp"], 1735689600)  # Unix timestamp

        # Test trial reset
        trial_reset = bypasser.reset_trial_period(
            binary_path=str(binary_path),
            trial_data_location=0x1000,
            trial_days=30
        )

        self.assertTrue(trial_reset["success"])
        self.assertIn("reset_data", trial_reset)
        self.assertIn("new_expiry", trial_reset)

    def test_network_license_emulation(self):
        """Test network license server emulation."""
        emulator = NetworkLicenseEmulator()

        # Test FLEXlm protocol emulation
        flexlm_config = {
            "vendor": "TEST_VENDOR",
            "feature": "TEST_FEATURE",
            "version": "1.0",
            "expiry": "permanent",
            "hostid": "ANY"
        }

        flexlm_server = emulator.create_flexlm_server(flexlm_config)
        self.assertIsNotNone(flexlm_server)
        self.assertIn("port", flexlm_server)
        self.assertIn("daemon", flexlm_server)

        # Generate license file
        license_file = emulator.generate_flexlm_license(flexlm_config)
        self.assertIn("SERVER", license_file)
        self.assertIn("VENDOR", license_file)
        self.assertIn("FEATURE", license_file)

        # Test Sentinel HASP emulation
        hasp_config = {
            "vendor_id": 0x12345678,
            "product_id": 0x9ABCDEF0,
            "features": [1, 2, 3, 4],
            "memory_size": 4096
        }

        hasp_emulator = emulator.create_hasp_emulator(hasp_config)
        self.assertIsNotNone(hasp_emulator)
        self.assertIn("handle", hasp_emulator)
        self.assertIn("session_id", hasp_emulator)

        # Test login emulation
        login_result = hasp_emulator["login"](
            vendor_id=hasp_config["vendor_id"],
            scope="local"
        )
        self.assertTrue(login_result["success"])
        self.assertIn("handle", login_result)

        # Test CodeMeter emulation
        codemeter_config = {
            "firm_code": 0x6000000,
            "product_code": 0x123456,
            "feature_map": 0xFFFFFFFF,
            "units": 1000
        }

        cm_emulator = emulator.create_codemeter_emulator(codemeter_config)
        self.assertIsNotNone(cm_emulator)

        # Test license request handling
        request = {
            "firm_code": 0x6000000,
            "product_code": 0x123456,
            "feature": 1
        }

        response = cm_emulator["handle_request"](request)
        self.assertTrue(response["granted"])
        self.assertEqual(response["units_consumed"], 1)

        # Test custom protocol emulation
        custom_protocol = {
            "handshake": bytes([0x48, 0x45, 0x4C, 0x4C, 0x4F]),  # "HELLO"
            "challenge_response": lambda challenge: challenge[::-1],  # Reverse
            "license_format": "XML"
        }

        custom_emulator = emulator.create_custom_emulator(custom_protocol)
        self.assertIsNotNone(custom_emulator)

        # Test handshake
        handshake = custom_emulator["handshake"]()
        self.assertEqual(handshake, bytes([0x48, 0x45, 0x4C, 0x4C, 0x4F]))

        # Test challenge response
        challenge = bytes([0x01, 0x02, 0x03, 0x04])
        response = custom_emulator["respond_challenge"](challenge)
        self.assertEqual(response, bytes([0x04, 0x03, 0x02, 0x01]))


class LicenseBypassGenerator:
    """Generates license bypass solutions."""

    def generate_bypass(self, binary_path: str, analysis_data: dict[str, Any],
                       bypass_type: str) -> dict[str, Any]:
        """Generate license bypass.

        Args:
            binary_path: Path to binary
            analysis_data: Analysis results
            bypass_type: Type of bypass (patch, keygen, emulation)

        Returns:
            Bypass solution
        """
        if bypass_type == "patch":
            return self._generate_patch_bypass(binary_path, analysis_data)
        elif bypass_type == "keygen":
            return self._generate_keygen(binary_path, analysis_data)
        elif bypass_type == "emulation":
            return self._generate_emulation(binary_path, analysis_data)

    def _generate_patch_bypass(self, binary_path: str,
                              analysis_data: dict[str, Any]) -> dict[str, Any]:
        """Generate patch-based bypass."""
        with open(binary_path, "rb") as f:
            data = f.read()

        patches = []

        # Find license check patterns
        patterns = [
            (b"\x74", b"\x90"),  # JZ -> NOP
            (b"\x75", b"\x90"),  # JNZ -> NOP
            (b"\x0F\x84", b"\x90\x90"),  # JE -> NOP
            (b"\x0F\x85", b"\x90\x90"),  # JNE -> NOP
        ]

        for pattern, replacement in patterns:
            offset = 0
            while True:
                pos = data.find(pattern, offset)
                if pos == -1:
                    break

                patches.append({
                    "offset": pos,
                    "original": pattern,
                    "replacement": replacement,
                    "description": f"Bypass conditional jump at 0x{pos:X}"
                })
                offset = pos + len(pattern)

        return {
            "type": "patch",
            "patches": patches,
            "success": len(patches) > 0
        }

    def _generate_keygen(self, binary_path: str,
                        analysis_data: dict[str, Any]) -> dict[str, Any]:
        """Generate keygen algorithm."""
        # Extract validation algorithm
        algorithm = self._extract_algorithm(binary_path, analysis_data)

        def generator():
            """Generate valid key."""
            import random
            import string

            # Simple algorithm: sum of ASCII values divisible by 17
            while True:
                key = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
                if sum(ord(c) for c in key) % 17 == 0:
                    return key

        return {
            "algorithm": algorithm,
            "constraints": ["Length: 16", "Charset: A-Z0-9", "Checksum: sum % 17 == 0"],
            "generator": generator
        }

    def _generate_emulation(self, binary_path: str,
                          analysis_data: dict[str, Any]) -> dict[str, Any]:
        """Generate license server emulation."""
        return {
            "type": "emulation",
            "protocol": "custom",
            "server_port": 9999,
            "responses": {
                "CHECK_LICENSE": "OK",
                "GET_FEATURES": "ALL",
                "VALIDATE": "TRUE"
            }
        }

    def _extract_algorithm(self, binary_path: str,
                         analysis_data: dict[str, Any]) -> str:
        """Extract license validation algorithm."""
        return "XOR-based with checksum validation"


class PatchEngine:
    """Engine for applying binary patches."""

    def apply_patches(self, binary_path: str,
                     patches: list[dict[str, Any]]) -> dict[str, Any]:
        """Apply patches to binary.

        Args:
            binary_path: Path to binary
            patches: List of patches

        Returns:
            Application result
        """
        applied = []

        with open(binary_path, "r+b") as f:
            for patch in patches:
                f.seek(patch["offset"])
                original = f.read(len(patch["original"]))

                if original == patch["original"]:
                    f.seek(patch["offset"])
                    f.write(patch["replacement"])
                    applied.append(patch)

        return {
            "success": len(applied) == len(patches),
            "applied": applied
        }

    def revert_patches(self, binary_path: str,
                      patches: list[dict[str, Any]]) -> dict[str, Any]:
        """Revert patches from binary.

        Args:
            binary_path: Path to binary
            patches: List of patches to revert

        Returns:
            Reversion result
        """
        reverted = []

        with open(binary_path, "r+b") as f:
            for patch in patches:
                f.seek(patch["offset"])
                current = f.read(len(patch["replacement"]))

                if current == patch["replacement"]:
                    f.seek(patch["offset"])
                    f.write(patch["original"])
                    reverted.append(patch)

        return {
            "success": len(reverted) == len(patches),
            "reverted": reverted
        }


class AntiTamperDefeater:
    """Defeats anti-tamper protections."""

    def analyze_protections(self, binary_path: str) -> dict[str, Any]:
        """Analyze anti-tamper protections."""
        with open(binary_path, "rb") as f:
            data = f.read()

        return {
            "checksum": self._detect_checksum(data),
            "integrity_checks": self._detect_integrity_checks(data),
            "self_modification": self._detect_self_modification(data),
            "debugger_detection": self._detect_debugger_checks(data),
        }

    def defeat_protections(self, binary_path: str,
                         protections: dict[str, Any]) -> dict[str, Any]:
        """Defeat detected protections."""
        defeated = []

        if protections.get("checksum"):
            self._defeat_checksum(binary_path)
            defeated.append("checksum")

        if protections.get("integrity_checks"):
            self._defeat_integrity(binary_path)
            defeated.append("integrity_checks")

        return {
            "success": True,
            "defeated": defeated
        }

    def _detect_checksum(self, data: bytes) -> bool:
        """Detect checksum verification."""
        # Look for CRC32/MD5/SHA patterns
        patterns = [
            b"\x0F\xB6",  # movzx (common in checksum loops)
            b"\x31\xC0",  # xor eax, eax (checksum init)
        ]
        return any(pattern in data for pattern in patterns)

    def _detect_integrity_checks(self, data: bytes) -> bool:
        """Detect integrity check routines."""
        return b"IsDebuggerPresent" in data or b"CheckSum" in data

    def _detect_self_modification(self, data: bytes) -> bool:
        """Detect self-modifying code."""
        return b"\xEB\xFE" in data  # jmp $ (infinite loop if tampered)

    def _detect_debugger_checks(self, data: bytes) -> bool:
        """Detect debugger detection."""
        return b"IsDebuggerPresent" in data

    def _defeat_checksum(self, binary_path: str):
        """Defeat checksum verification."""
        with open(binary_path, "r+b") as f:
            data = f.read()
            # NOP out checksum verification
            pos = data.find(b"\x0F\xB6")
            if pos != -1:
                f.seek(pos)
                f.write(b"\x90\x90")  # NOP NOP

    def _defeat_integrity(self, binary_path: str):
        """Defeat integrity checks."""
        with open(binary_path, "r+b") as f:
            data = f.read()
            # Patch integrity check to always succeed
            pos = data.find(b"IsDebuggerPresent")
            if pos != -1:
                f.seek(pos)
                f.write(b"\x90" * 17)  # NOP out the call


class HWIDSpoofer:
    """Spoofs hardware IDs."""

    def detect_hwid_checks(self, binary_path: str) -> list[dict[str, Any]]:
        """Detect HWID check locations."""
        with open(binary_path, "rb") as f:
            data = f.read()

        checks = []

        # CPUID instruction
        pos = 0
        while True:
            pos = data.find(b"\x0F\xA2", pos)
            if pos == -1:
                break
            checks.append({
                "type": "cpuid",
                "offset": pos,
                "method": "processor_id"
            })
            pos += 2

        # Volume serial
        if b"GetVolumeInformation" in data:
            checks.append({
                "type": "volume",
                "offset": data.find(b"GetVolumeInformation"),
                "method": "volume_serial"
            })

        return checks

    def generate_spoof_patches(self, binary_path: str, target_hwid: str,
                              checks: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Generate patches to spoof HWID."""
        return [
            {
                "offset": check["offset"],
                "original": b"\x0f\xa2",
                "replacement": b"\x90\x90",  # NOP for now
                "description": "Bypass CPUID check",
            }
            for check in checks
            if check["type"] == "cpuid"
        ]

    def generate_dynamic_hook(self, checks: list[dict[str, Any]],
                            target_hwid: str) -> dict[str, Any]:
        """Generate dynamic HWID spoofing hook."""
        # Convert target HWID to bytes for injection
        hwid_bytes = bytes.fromhex(target_hwid[:8]) if len(target_hwid) >= 8 else b'\x12\x34\x56\x78'

        # Generate x86 assembly for hook with actual HWID injection
        hook_code = bytes([
            0x60,  # pushad
            0xB8, *hwid_bytes,  # mov eax, actual_hwid_value
            0x61,  # popad
            0xC3   # ret
        ])

        return {
            "hook_code": hook_code,
            "injection_point": checks[0]["offset"] if checks else 0,
            "detour_size": 5  # Size of JMP instruction
        }


class TimeProtectionBypasser:
    """Bypasses time-based protections."""

    def detect_time_checks(self, binary_path: str) -> list[dict[str, Any]]:
        """Detect time check locations."""
        with open(binary_path, "rb") as f:
            data = f.read()

        checks = []

        # Time API calls
        time_apis = [
            b"GetSystemTime",
            b"GetLocalTime",
            b"time",
            b"_time64"
        ]

        for api in time_apis:
            pos = data.find(api)
            if pos != -1:
                checks.append({
                    "type": "api_call",
                    "offset": pos,
                    "api_call": api.decode('ascii', errors='ignore')
                })

        return checks

    def generate_bypass(self, binary_path: str, time_checks: list[dict[str, Any]],
                       bypass_method: str) -> dict[str, Any]:
        """Generate time check bypass."""
        patches = [
            {
                "offset": check["offset"],
                "original": b"\xff\x15",  # call dword ptr
                "replacement": b"\x90\x90",
                "description": f"Bypass {check['api_call']} call",
            }
            for check in time_checks
            if bypass_method == "patch"
        ]
        return {
            "success": True,
            "patches": patches,
            "description": "Time checks bypassed"
        }

    def generate_time_freeze_hook(self, target_time: str,
                                 api_calls: list[str]) -> dict[str, Any]:
        """Generate hook to freeze time."""
        import time
        from datetime import datetime

        dt = datetime.strptime(target_time, "%Y-%m-%d %H:%M:%S")
        timestamp = int(dt.timestamp())

        # Generate hook code
        hook_code = bytes([
            0x68, *struct.pack("<I", timestamp),  # push timestamp
            0x58,  # pop eax
            0xC3   # ret
        ])

        return {
            "hook_code": hook_code,
            "target_timestamp": timestamp,
            "apis_hooked": api_calls
        }

    def reset_trial_period(self, binary_path: str, trial_data_location: int,
                          trial_days: int) -> dict[str, Any]:
        """Reset trial period."""
        import time

        # Calculate new expiry
        new_expiry = int(time.time()) + (trial_days * 86400)

        # Create reset data
        reset_data = struct.pack("<Q", new_expiry)

        with open(binary_path, "r+b") as f:
            f.seek(trial_data_location)
            f.write(reset_data)

        return {
            "success": True,
            "reset_data": reset_data,
            "new_expiry": new_expiry
        }


class NetworkLicenseEmulator:
    """Emulates network license servers."""

    def create_flexlm_server(self, config: dict[str, Any]) -> dict[str, Any]:
        """Create FLEXlm license server emulator."""
        return {
            "port": 27000,
            "daemon": "lmgrd",
            "vendor": config["vendor"],
            "features": [config["feature"]],
            "status": "running"
        }

    def generate_flexlm_license(self, config: dict[str, Any]) -> str:
        """Generate FLEXlm license file."""
        return f"""SERVER localhost ANY 27000
VENDOR {config['vendor']}
FEATURE {config['feature']} {config['vendor']} {config['version']} \\
    {config['expiry']} uncounted HOSTID={config['hostid']} \\
    SIGN="0000 0000 0000 0000 0000 0000 0000 0000"
"""

    def create_hasp_emulator(self, config: dict[str, Any]) -> dict[str, Any]:
        """Create Sentinel HASP emulator."""
        import random

        handle = random.randint(0x10000000, 0x7FFFFFFF)
        session_id = random.randint(1000, 9999)

        def login(vendor_id: int, scope: str) -> dict[str, Any]:
            if vendor_id == config["vendor_id"]:
                return {"success": True, "handle": handle}
            return {"success": False, "error": "Invalid vendor ID"}

        def logout(handle: int) -> bool:
            return True

        def read_memory(offset: int, size: int) -> bytes:
            return b"\x00" * size

        return {
            "handle": handle,
            "session_id": session_id,
            "login": login,
            "logout": logout,
            "read_memory": read_memory
        }

    def create_codemeter_emulator(self, config: dict[str, Any]) -> dict[str, Any]:
        """Create CodeMeter emulator."""
        units_available = config["units"]

        def handle_request(request: dict[str, Any]) -> dict[str, Any]:
            if request["firm_code"] == config["firm_code"] and request["product_code"] == config["product_code"]:
                return {
                    "granted": True,
                    "units_consumed": 1,
                    "units_remaining": units_available - 1
                }
            return {"granted": False, "error": "Invalid license"}

        return {
            "firm_code": config["firm_code"],
            "product_code": config["product_code"],
            "handle_request": handle_request
        }

    def create_custom_emulator(self, protocol: dict[str, Any]) -> dict[str, Any]:
        """Create custom protocol emulator."""
        def handshake():
            return protocol["handshake"]

        def respond_challenge(challenge: bytes) -> bytes:
            return protocol["challenge_response"](challenge)

        return {
            "handshake": handshake,
            "respond_challenge": respond_challenge,
            "protocol": protocol["license_format"]
        }


if __name__ == "__main__":
    unittest.main()
