"""
Comprehensive test suite for license key generation and validation capabilities.
Tests validate production-ready license analysis and key generation functionality.
These tests assume sophisticated pattern recognition and cryptographic capabilities exist.
"""

import pytest
import os
import tempfile
import struct
import re
from pathlib import Path
from typing import Dict, Any, List

from intellicrack.utils.exploitation.exploitation import (
    generate_license_key,
    generate_keygen_batch,
    analyze_existing_keys,
    _detect_license_algorithm,
    _detect_key_format,
    _generate_key_by_algorithm,
    _validate_generated_key,
    _analyze_key_patterns,
    _validate_key_checksum,
    _validate_key_format,
    _validate_key_charset,
    _validate_key_mathematics,
    _luhn_checksum,
    _modulo_checksum,
    _xor_checksum
)


class TestLicenseKeyGeneration:
    """Test suite for license key generation with algorithm detection."""

    def test_generate_license_key_auto_algorithm_detection(self):
        """Test automatic algorithm detection from binary analysis."""
        # Create binary with embedded license validation patterns
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create realistic binary with license check patterns
            binary_data = self._create_realistic_license_binary()
            temp_binary.write(binary_data)
            temp_binary.flush()

            try:
                result = generate_license_key(
                    binary_path=temp_binary.name,
                    algorithm="auto",
                    format_type="auto",
                    target_software="TestApp_Pro_v3.2"
                )

                assert isinstance(result, dict)
                assert "license_key" in result
                assert "algorithm_detected" in result
                assert "format_detected" in result
                assert "validation_passed" in result
                assert "confidence_score" in result

                # Validate key generation success
                assert result.get("validation_passed") is True

                # Validate detected algorithm is realistic
                algorithm = result["algorithm_detected"]
                assert algorithm in [
                    "custom", "md5", "sha1", "sha256", "crc32", "luhn",
                    "modulo", "xor", "base64", "rsa", "aes"
                ]

                # Validate key format detection
                format_detected = result["format_detected"]
                assert isinstance(format_detected, str)
                assert len(format_detected) > 0

                # Validate generated key characteristics
                license_key = result["license_key"]
                assert isinstance(license_key, str)
                assert len(license_key) >= 5  # Minimum reasonable key length
                assert len(license_key) <= 100  # Maximum reasonable key length

                # Confidence score should indicate detection quality
                confidence = result["confidence_score"]
                assert isinstance(confidence, (int, float))
                assert 0.0 <= confidence <= 1.0

            finally:
                os.unlink(temp_binary.name)

    def test_generate_license_key_specific_algorithms(self):
        """Test license key generation with specific algorithm types."""
        algorithms_to_test = [
            ("luhn", "XXXXX-XXXXX-XXXXX-XXXXX"),
            ("md5", "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"),
            ("sha256", "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"),
            ("custom", "XXXX-XXXX-XXXX-XXXX"),
            ("base64", "xxxxxxxxxxxxxxxxx==")
        ]

        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_realistic_license_binary())
            temp_binary.flush()

            try:
                for algorithm, expected_format in algorithms_to_test:
                    result = generate_license_key(
                        binary_path=temp_binary.name,
                        algorithm=algorithm,
                        format_type="auto",
                        target_software=f"TestApp_{algorithm}"
                    )

                    assert isinstance(result, dict)
                    assert result.get("validation_passed") is True

                    # Algorithm-specific validations
                    license_key = result["license_key"]

                    if algorithm == "luhn":
                        # Luhn algorithm keys should pass checksum validation
                        assert self._validate_luhn_pattern(license_key)

                    elif algorithm == "md5":
                        # MD5 keys should be 32 hex characters
                        assert len(license_key) == 32
                        assert all(c in "0123456789abcdefABCDEF" for c in license_key)

                    elif algorithm == "sha256":
                        # SHA256 keys should be 64 hex characters
                        assert len(license_key) == 64
                        assert all(c in "0123456789abcdefABCDEF" for c in license_key)

                    elif algorithm == "base64":
                        # Base64 keys should follow base64 pattern
                        import base64
                        try:
                            base64.b64decode(license_key)
                            base64_valid = True
                        except:
                            base64_valid = False
                        assert base64_valid or license_key.endswith("=")

            finally:
                os.unlink(temp_binary.name)

    def test_generate_license_key_custom_length_formats(self):
        """Test key generation with custom length specifications."""
        custom_lengths = [8, 16, 20, 25, 32, 40]

        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_realistic_license_binary())
            temp_binary.flush()

            try:
                for length in custom_lengths:
                    result = generate_license_key(
                        binary_path=temp_binary.name,
                        algorithm="custom",
                        format_type="alphanumeric",
                        custom_length=length,
                        target_software="CustomLengthApp"
                    )

                    if result.get("validation_passed"):
                        license_key = result["license_key"]

                        # Remove common separators for length validation
                        key_chars = license_key.replace("-", "").replace("_", "")

                        # Should approximately match requested length (Â±2 chars for formatting)
                        assert abs(len(key_chars) - length) <= 2

            finally:
                os.unlink(temp_binary.name)

    def test_generate_license_key_real_world_software_patterns(self):
        """Test key generation for real-world software patterns."""
        software_patterns = [
            ("Adobe_Creative_Suite", "XXXX-XXXX-XXXX-XXXX-XXXX-XXXX"),
            ("Microsoft_Office", "XXXXX-XXXXX-XXXXX-XXXXX-XXXXX"),
            ("WinRAR", "XXXXXX-XXXXXX-XXXXXX-XXXXXX"),
            ("VMware_Workstation", "XXXXX-XXXXX-XXXXX-XXXXX-XXXXX"),
            ("JetBrains_IntelliJ", "XXXXXXXXXX-XXXXXXXXXX")
        ]

        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_realistic_license_binary())
            temp_binary.flush()

            try:
                for software, expected_pattern in software_patterns:
                    result = generate_license_key(
                        binary_path=temp_binary.name,
                        algorithm="auto",
                        format_type="auto",
                        target_software=software
                    )

                    if result.get("validation_passed"):
                        license_key = result["license_key"]

                        # Validate key follows expected software patterns
                        assert len(license_key) > 10

                        # Should contain typical separators for commercial software
                        if "-" in expected_pattern:
                            assert "-" in license_key or "_" in license_key

            finally:
                os.unlink(temp_binary.name)

    def _create_realistic_license_binary(self) -> bytes:
        """Create binary with realistic license validation patterns."""
        return (
            b'MZ' + b'\x00' * 60 +  # DOS header
            b'PE\x00\x00' + b'\x00' * 100 +  # PE headers
            b'LICENSE_KEY_VALIDATION\x00' +
            b'INVALID_LICENSE\x00' +
            b'TRIAL_EXPIRED\x00' +
            b'CHECKSUM_FAILED\x00' +
            b'GetUserNameA\x00GetComputerNameA\x00' +
            b'RegQueryValueA\x00RegSetValueA\x00' +
            b'CryptHashData\x00CryptCreateHash\x00' +
            b'\x00' * 200
        )

    def _validate_luhn_pattern(self, key: str) -> bool:
        """Validate if key follows Luhn algorithm pattern."""
        # Remove non-digit characters
        digits = ''.join(c for c in key if c.isdigit())
        if len(digits) < 4:
            return False

        # Basic Luhn validation
        def luhn_check(card_num):
            def digits_of(n):
                return [int(d) for d in str(n)]
            digits = digits_of(card_num)
            odd_digits = digits[-1::-2]
            even_digits = digits[-2::-2]
            checksum = sum(odd_digits)
            for d in even_digits:
                checksum += sum(digits_of(d*2))
            return checksum % 10 == 0

        return luhn_check(digits)


class TestKeygenBatchGeneration:
    """Test suite for batch license key generation capabilities."""

    def test_generate_keygen_batch_standard_count(self):
        """Test batch generation with standard count."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_test_binary())
            temp_binary.flush()

            try:
                counts_to_test = [1, 5, 10, 25, 50]

                for count in counts_to_test:
                    result = generate_keygen_batch(
                        binary_path=temp_binary.name,
                        count=count,
                        algorithm="auto",
                        format_type="auto"
                    )

                    assert isinstance(result, list)
                    assert len(result) == count

                    # All generated keys should be unique
                    keys = [item["license_key"] if isinstance(item, dict) else item
                           for item in result]
                    assert len(set(keys)) == count  # All unique

                    # All keys should be valid
                    for key in keys:
                        assert isinstance(key, str)
                        assert len(key) >= 5
                        assert len(key) <= 100

            finally:
                os.unlink(temp_binary.name)

    def test_generate_keygen_batch_algorithm_consistency(self):
        """Test batch generation maintains algorithm consistency."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_test_binary())
            temp_binary.flush()

            try:
                result = generate_keygen_batch(
                    binary_path=temp_binary.name,
                    count=10,
                    algorithm="luhn",
                    format_type="standard"
                )

                assert isinstance(result, list)
                assert len(result) == 10

                # All keys should follow the same algorithm pattern
                keys = [item["license_key"] if isinstance(item, dict) else item
                       for item in result]

                # For Luhn algorithm, all keys should have similar format
                key_lengths = [len(key.replace("-", "")) for key in keys]
                length_variance = max(key_lengths) - min(key_lengths)
                assert length_variance <= 2  # Minimal variation in length

            finally:
                os.unlink(temp_binary.name)

    def test_generate_keygen_batch_performance(self):
        """Test batch generation performance with large counts."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_test_binary())
            temp_binary.flush()

            try:
                import time
                start_time = time.time()

                result = generate_keygen_batch(
                    binary_path=temp_binary.name,
                    count=100,
                    algorithm="custom",
                    format_type="alphanumeric"
                )

                end_time = time.time()
                generation_time = end_time - start_time

                # Should complete within reasonable time (10 seconds)
                assert generation_time < 10.0

                # Should generate requested count
                assert len(result) == 100

                # Performance: should generate at least 10 keys per second
                keys_per_second = len(result) / generation_time
                assert keys_per_second >= 10

            finally:
                os.unlink(temp_binary.name)

    def _create_test_binary(self) -> bytes:
        """Create test binary for batch generation tests."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'LICENSE_CHECK\x00KEYGEN_TEST\x00' +
            b'\x00' * 100
        )


class TestExistingKeyAnalysis:
    """Test suite for analyzing existing license key patterns."""

    def test_analyze_existing_keys_pattern_detection(self):
        """Test pattern detection in existing license keys."""
        test_key_sets = [
            # Microsoft Office style
            {
                "keys": [
                    "ABCDE-12345-FGHIJ-67890-KLMNO",
                    "PQRST-23456-UVWXY-78901-ZABCD",
                    "EFGHI-34567-JKLMN-89012-OPQRS"
                ],
                "expected_pattern": "XXXXX-XXXXX-XXXXX-XXXXX-XXXXX"
            },
            # Adobe style
            {
                "keys": [
                    "1234-5678-9012-3456-7890-1234",
                    "2345-6789-0123-4567-8901-2345",
                    "3456-7890-1234-5678-9012-3456"
                ],
                "expected_pattern": "XXXX-XXXX-XXXX-XXXX-XXXX-XXXX"
            },
            # Short format
            {
                "keys": [
                    "ABC123XYZ",
                    "DEF456UVW",
                    "GHI789RST"
                ],
                "expected_pattern": "XXXXXXXXX"
            }
        ]

        for test_set in test_key_sets:
            result = analyze_existing_keys(test_set["keys"])

            assert isinstance(result, dict)
            assert "pattern_detected" in result
            assert "algorithm_probability" in result
            assert "format_structure" in result
            assert "recommendations" in result

            # Should detect pattern successfully
            assert result["pattern_detected"] is True

            # Format structure should be reasonable
            format_structure = result["format_structure"]
            assert isinstance(format_structure, str)
            assert len(format_structure) >= len(test_set["keys"][0]) // 2

            # Algorithm probability should be a mapping
            algorithm_prob = result["algorithm_probability"]
            assert isinstance(algorithm_prob, dict)
            assert len(algorithm_prob) > 0

            # Should have recommendations
            recommendations = result["recommendations"]
            assert isinstance(recommendations, (str, list))

    def test_analyze_existing_keys_checksum_detection(self):
        """Test detection of checksum algorithms in keys."""
        # Keys with Luhn algorithm pattern
        luhn_keys = [
            "4532015112830366",  # Valid credit card number (Luhn)
            "4556737586899855",
            "4539148803436467"
        ]

        result = analyze_existing_keys(luhn_keys)

        if result["pattern_detected"]:
            algorithm_prob = result["algorithm_probability"]
            # Should detect Luhn or checksum-based algorithm
            checksum_algorithms = ["luhn", "checksum", "modulo", "crc"]
            detected_checksums = [alg for alg in checksum_algorithms
                                if alg in algorithm_prob]
            assert len(detected_checksums) > 0

    def test_analyze_existing_keys_entropy_analysis(self):
        """Test entropy analysis of license keys."""
        high_entropy_keys = [
            "7g8H9kL2mN4pQ5rS",
            "X3vB6nM8zC1wE4qA",
            "F9jK2tY5uI7oP0lD"
        ]

        low_entropy_keys = [
            "1111-1111-1111-1111",
            "AAAA-AAAA-AAAA-AAAA",
            "1234-5678-9012-3456"
        ]

        high_entropy_result = analyze_existing_keys(high_entropy_keys)
        low_entropy_result = analyze_existing_keys(low_entropy_keys)

        # High entropy keys should indicate stronger algorithms
        if "entropy_score" in high_entropy_result:
            assert high_entropy_result["entropy_score"] > 0.5

        if "entropy_score" in low_entropy_result:
            assert low_entropy_result["entropy_score"] < 0.5

    def test_analyze_existing_keys_insufficient_data(self):
        """Test analysis with insufficient key samples."""
        insufficient_keys = ["ABC123"]  # Single key

        result = analyze_existing_keys(insufficient_keys)

        assert isinstance(result, dict)
        # Should handle insufficient data gracefully
        if "pattern_detected" in result:
            assert result["pattern_detected"] is False
        if "error" in result:
            assert "insufficient" in result["error"].lower()


class TestChecksumValidationFunctions:
    """Test suite for checksum validation functions."""

    def test_luhn_checksum_validation(self):
        """Test Luhn checksum validation function."""
        # Valid Luhn numbers
        valid_luhn = [
            "4532015112830366",  # Credit card number
            "4556737586899855",
            "79927398713"
        ]

        # Invalid Luhn numbers
        invalid_luhn = [
            "4532015112830365",  # Last digit changed
            "4556737586899856",
            "79927398712"
        ]

        for valid_key in valid_luhn:
            assert _luhn_checksum(valid_key) is True

        for invalid_key in invalid_luhn:
            assert _luhn_checksum(invalid_key) is False

    def test_modulo_checksum_validation(self):
        """Test modulo-based checksum validation."""
        # Test with various modulo patterns
        test_keys = [
            "123456789",
            "987654321",
            "555666777",
            "111222333"
        ]

        for key in test_keys:
            result = _modulo_checksum(key)
            assert isinstance(result, bool)
            # Result should be consistent for the same input
            assert _modulo_checksum(key) == result

    def test_xor_checksum_validation(self):
        """Test XOR-based checksum validation."""
        test_keys = [
            "ABCDEF123456",
            "XYZ789ABC123",
            "123ABC789XYZ"
        ]

        for key in test_keys:
            result = _xor_checksum(key)
            assert isinstance(result, bool)
            # Should be deterministic
            assert _xor_checksum(key) == result

    def test_checksum_functions_edge_cases(self):
        """Test checksum functions with edge cases."""
        edge_cases = [
            "",  # Empty string
            "0",  # Single character
            "1234567890123456789012345678901234567890",  # Very long
            "ABC",  # Non-numeric
            "!@#$%"  # Special characters
        ]

        for edge_case in edge_cases:
            # Functions should handle edge cases without crashing
            try:
                luhn_result = _luhn_checksum(edge_case)
                modulo_result = _modulo_checksum(edge_case)
                xor_result = _xor_checksum(edge_case)

                # Results should be boolean
                assert isinstance(luhn_result, bool)
                assert isinstance(modulo_result, bool)
                assert isinstance(xor_result, bool)

            except Exception as e:
                # If exceptions occur, they should be handled gracefully
                assert isinstance(e, (ValueError, TypeError))


class TestKeyValidationFunctions:
    """Test suite for key validation functions."""

    def test_validate_key_format_comprehensive(self):
        """Test comprehensive key format validation."""
        format_tests = [
            ("XXXXX-XXXXX-XXXXX", "ABC12-DEF34-GHI56", True),
            ("XXXXXXXXXX", "ABCDEFGHIJ", True),
            ("XXX-XXX-XXX", "A1B-C2D-E3F", True),
            ("XXXXX-XXXXX-XXXXX", "ABC1-DEF34-GHI56", False),  # Wrong format
        ]

        for expected_format, test_key, should_pass in format_tests:
            # Create mock software name
            software = f"TestApp_{expected_format.replace('-', '_')}"

            result = _validate_key_format(test_key, software)
            assert isinstance(result, bool)

            # Note: Actual validation depends on implementation
            # This test validates the function exists and returns boolean

    def test_validate_key_charset_compliance(self):
        """Test key character set validation."""
        charset_tests = [
            ("ABCDEFGHIJ1234567890", "alphanumeric", True),
            ("abcdefghij1234567890", "alphanumeric", True),
            ("ABCD-EFGH-1234", "alphanumeric_with_separators", True),
            ("ABC!@#DEF", "alphanumeric", False),  # Special chars
        ]

        for test_key, charset_type, should_pass in charset_tests:
            software = f"TestApp_{charset_type}"

            result = _validate_key_charset(test_key, software)
            assert isinstance(result, bool)

    def test_validate_key_mathematics_consistency(self):
        """Test mathematical validation of keys."""
        math_test_keys = [
            "123456789",
            "987654321",
            "555444333",
            "111222333"
        ]

        for test_key in math_test_keys:
            result = _validate_key_mathematics(test_key, "MathTestApp")
            assert isinstance(result, bool)

            # Should be consistent across multiple calls
            assert _validate_key_mathematics(test_key, "MathTestApp") == result


class TestAlgorithmDetectionFunctions:
    """Test suite for algorithm detection functions."""

    def test_detect_license_algorithm_comprehensive(self):
        """Test comprehensive license algorithm detection."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with various algorithm hints
            binary_data = (
                b'MZ' + b'\x00' * 60 +
                b'PE\x00\x00' + b'\x00' * 50 +
                b'CryptHashData\x00MD5\x00SHA256\x00' +
                b'ChecksumValidate\x00LuhnCheck\x00' +
                b'LICENSE_KEY_VALIDATION\x00' +
                b'\x00' * 100
            )
            temp_binary.write(binary_data)
            temp_binary.flush()

            try:
                result = _detect_license_algorithm(temp_binary.name)

                # Should return tuple with algorithm info
                assert isinstance(result, tuple)
                assert len(result) >= 2

                algorithm, confidence = result[:2]
                assert isinstance(algorithm, str)
                assert isinstance(confidence, (int, float))
                assert 0.0 <= confidence <= 1.0

                # Algorithm should be recognized type
                known_algorithms = [
                    "custom", "md5", "sha1", "sha256", "luhn", "modulo",
                    "xor", "crc32", "base64", "rsa", "aes", "unknown"
                ]
                assert algorithm in known_algorithms

            finally:
                os.unlink(temp_binary.name)

    def test_detect_key_format_patterns(self):
        """Test key format pattern detection."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with format patterns
            binary_data = (
                b'MZ' + b'\x00' * 60 +
                b'PE\x00\x00' + b'\x00' * 50 +
                b'XXXXX-XXXXX-XXXXX-XXXXX\x00' +
                b'Key Format: XXXX-XXXX-XXXX\x00' +
                b'\x00' * 100
            )
            temp_binary.write(binary_data)
            temp_binary.flush()

            try:
                result = _detect_key_format(temp_binary.name)

                assert isinstance(result, str)
                assert len(result) > 0

                # Should contain format indicators
                assert any(char in result for char in ['X', '#', '?', '-', '_'])

            finally:
                os.unlink(temp_binary.name)


@pytest.mark.integration
class TestLicenseKeyIntegrationScenarios:
    """Integration tests for license key generation workflows."""

    def test_end_to_end_key_generation_workflow(self):
        """Test complete key generation workflow from detection to validation."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_comprehensive_license_binary())
            temp_binary.flush()

            try:
                # Step 1: Generate single key with auto-detection
                single_key_result = generate_license_key(
                    binary_path=temp_binary.name,
                    algorithm="auto",
                    format_type="auto",
                    target_software="IntegratedTestApp"
                )

                assert single_key_result.get("validation_passed") is True

                # Step 2: Generate batch using detected parameters
                detected_algorithm = single_key_result.get("algorithm_detected", "custom")
                detected_format = single_key_result.get("format_detected", "standard")

                batch_result = generate_keygen_batch(
                    binary_path=temp_binary.name,
                    count=5,
                    algorithm=detected_algorithm,
                    format_type=detected_format
                )

                assert len(batch_result) == 5

                # Step 3: Analyze generated keys for consistency
                generated_keys = [item["license_key"] if isinstance(item, dict) else item
                                for item in batch_result]
                generated_keys.append(single_key_result["license_key"])

                analysis_result = analyze_existing_keys(generated_keys)

                # Generated keys should show consistent patterns
                assert analysis_result["pattern_detected"] is True

                # Step 4: Validate all generated keys
                for key in generated_keys:
                    validation_result = _validate_generated_key(
                        temp_binary.name, key, "IntegratedTestApp"
                    )
                    assert validation_result.get("is_valid") is True

            finally:
                os.unlink(temp_binary.name)

    def test_cross_platform_key_generation(self):
        """Test key generation for different platform patterns."""
        platform_patterns = [
            ("Windows", "XXXXX-XXXXX-XXXXX-XXXXX-XXXXX"),
            ("Linux", "XXXXXXXXXXXXXXXXXXXXXXXX"),
            ("macOS", "XXXX-XXXX-XXXX-XXXX"),
            ("Mobile", "XXXXXXXXXX")
        ]

        for platform, expected_pattern in platform_patterns:
            with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
                platform_binary = self._create_platform_specific_binary(platform)
                temp_binary.write(platform_binary)
                temp_binary.flush()

                try:
                    result = generate_license_key(
                        binary_path=temp_binary.name,
                        algorithm="auto",
                        format_type="auto",
                        target_software=f"{platform}_TestApp"
                    )

                    if result.get("validation_passed"):
                        license_key = result["license_key"]

                        # Validate platform-appropriate key characteristics
                        if platform == "Windows":
                            # Windows keys often use dashes
                            assert "-" in license_key or len(license_key) > 15
                        elif platform == "Linux":
                            # Linux keys might be longer alphanumeric
                            assert len(license_key) >= 16

                finally:
                    os.unlink(temp_binary.name)

    def _create_comprehensive_license_binary(self) -> bytes:
        """Create comprehensive binary with extensive license patterns."""
        return (
            b'MZ' + b'\x00' * 60 +  # DOS header
            b'PE\x00\x00' + b'\x00' * 100 +  # PE headers
            b'LICENSE_KEY_VALIDATION_SYSTEM\x00' +
            b'CHECKSUM_ALGORITHM_MD5\x00' +
            b'FORMAT_XXXXX_XXXXX_XXXXX\x00' +
            b'TRIAL_PERIOD_EXPIRED\x00' +
            b'INVALID_LICENSE_KEY\x00' +
            b'REGISTRATION_SUCCESS\x00' +
            b'CryptHashData\x00CryptVerifySignature\x00' +
            b'RegQueryValueEx\x00RegSetValueEx\x00' +
            b'GetVolumeInformation\x00GetComputerName\x00' +
            b'InternetOpen\x00InternetConnect\x00' +
            b'\x00' * 200
        )

    def _create_platform_specific_binary(self, platform: str) -> bytes:
        """Create binary with platform-specific license patterns."""
        platform_patterns = {
            "Windows": b'RegQueryValue\x00HKEY_LOCAL_MACHINE\x00SOFTWARE\x00',
            "Linux": b'/etc/license\x00/var/lib/app\x00~/.config/\x00',
            "macOS": b'CFPreferences\x00~/Library/\x00/Applications/\x00',
            "Mobile": b'SharedPreferences\x00keychain\x00sqlite\x00'
        }

        specific_pattern = platform_patterns.get(platform, b'GENERIC_PATTERN\x00')

        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'LICENSE_CHECK\x00' +
            specific_pattern +
            b'\x00' * 100
        )


class TestEdgeCasesAndRobustness:
    """Test suite for edge cases and robustness validation."""

    def test_malformed_binary_handling(self):
        """Test handling of malformed or corrupted binaries."""
        malformed_binaries = [
            b"NOT_A_PE_FILE",  # Invalid format
            b"MZ" + b"\x00" * 10,  # Truncated PE
            b"",  # Empty file
            b"MZ" + b"\xFF" * 1000  # Corrupted data
        ]

        for malformed_data in malformed_binaries:
            with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_file:
                temp_file.write(malformed_data)
                temp_file.flush()

                try:
                    result = generate_license_key(
                        binary_path=temp_file.name,
                        algorithm="auto",
                        format_type="auto"
                    )

                    # Should handle malformed files gracefully
                    assert isinstance(result, dict)
                    if not result.get("validation_passed"):
                        assert "error" in result or "message" in result

                finally:
                    os.unlink(temp_file.name)

    def test_extreme_parameter_values(self):
        """Test handling of extreme parameter values."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(b'MZ' + b'\x00' * 100)
            temp_binary.flush()

            try:
                # Test extreme batch counts
                extreme_counts = [0, 1, 1000, -1]

                for count in extreme_counts:
                    if count > 0:
                        result = generate_keygen_batch(
                            binary_path=temp_binary.name,
                            count=count,
                            algorithm="custom"
                        )

                        if isinstance(result, list):
                            assert len(result) <= 1000  # Reasonable upper limit

                # Test extreme custom lengths
                extreme_lengths = [1, 2, 500, 0, -1]

                for length in extreme_lengths:
                    if length > 0:
                        result = generate_license_key(
                            binary_path=temp_binary.name,
                            custom_length=length
                        )

                        assert isinstance(result, dict)

            finally:
                os.unlink(temp_binary.name)

    def test_concurrent_key_generation(self):
        """Test concurrent key generation scenarios."""
        import threading
        import queue

        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(b'MZ' + b'LICENSE_CHECK\x00' + b'\x00' * 100)
            temp_binary.flush()

            try:
                results_queue = queue.Queue()

                def generate_key_worker():
                    result = generate_license_key(
                        binary_path=temp_binary.name,
                        algorithm="custom",
                        target_software="ConcurrentApp"
                    )
                    results_queue.put(result)

                # Create multiple threads
                threads = []
                for _ in range(5):
                    thread = threading.Thread(target=generate_key_worker)
                    threads.append(thread)
                    thread.start()

                # Wait for all threads
                for thread in threads:
                    thread.join(timeout=10)  # 10 second timeout

                # Collect results
                results = []
                while not results_queue.empty():
                    results.append(results_queue.get())

                # Should handle concurrent access
                assert len(results) <= 5

                # Generated keys should be unique
                valid_keys = [r["license_key"] for r in results
                            if r.get("validation_passed")]
                if len(valid_keys) > 1:
                    assert len(set(valid_keys)) == len(valid_keys)

            finally:
                os.unlink(temp_binary.name)
