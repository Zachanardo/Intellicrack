"""
Comprehensive test suite for patch analysis and automation capabilities.
Tests validate production-ready binary patching and automated patch generation functionality.
These tests assume sophisticated binary analysis and modification capabilities exist.
"""

import pytest
import os
import tempfile
import struct
import hashlib
import shutil
from pathlib import Path
from typing import Dict, Any, List

from intellicrack.utils.exploitation.exploitation import (
    patch_selected,
    run_automated_patch_agent,
    verify_patches_without_applying,
    analyze_for_patches,
    run_simulate_patch,
    _test_windows_pe,
    _test_linux_elf,
    _test_macos_macho,
    _test_cross_platform,
    _generate_patch_instructions
)


class TestBinaryPatchingCore:
    """Test suite for core binary patching functionality."""

    def test_patch_selected_single_patch(self):
        """Test applying a single patch to binary."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with known content for patching
            original_content = (
                b'MZ' + b'\x00' * 60 +  # DOS header
                b'PE\x00\x00' + b'\x00' * 50 +  # PE header
                b'LICENSE_CHECK_ENABLED' +  # Target for patching
                b'\x00' * 100
            )
            temp_binary.write(original_content)
            temp_binary.flush()

            output_path = f"{temp_binary.name}_patched.exe"

            try:
                patches = [
                    {
                        "offset": original_content.find(b'LICENSE_CHECK_ENABLED'),
                        "original_bytes": b'LICENSE_CHECK_ENABLED',
                        "new_bytes": b'LICENSE_CHECK_DISABLE',  # Same length
                        "description": "Disable license check",
                        "type": "license_bypass"
                    }
                ]

                result = patch_selected(
                    binary_path=temp_binary.name,
                    patches=patches,
                    output_path=output_path
                )

                assert isinstance(result, dict)
                assert "success" in result
                assert "patches_applied" in result
                assert "output_file" in result

                if result["success"]:
                    assert result["patches_applied"] == 1
                    assert os.path.exists(result["output_file"])

                    # Verify patch was applied correctly
                    with open(result["output_file"], "rb") as patched_file:
                        patched_content = patched_file.read()
                        assert b'LICENSE_CHECK_DISABLE' in patched_content
                        assert b'LICENSE_CHECK_ENABLED' not in patched_content

                    # Verify file size consistency
                    assert len(patched_content) == len(original_content)

            finally:
                os.unlink(temp_binary.name)
                if os.path.exists(output_path):
                    os.unlink(output_path)

    def test_patch_selected_multiple_patches(self):
        """Test applying multiple patches simultaneously."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            original_content = (
                b'MZ' + b'\x00' * 60 +
                b'PE\x00\x00' + b'\x00' * 50 +
                b'TRIAL_CHECK_ON\x00' +
                b'DEBUG_MODE_OFF\x00' +
                b'VALIDATION_STRICT\x00' +
                b'\x00' * 100
            )
            temp_binary.write(original_content)
            temp_binary.flush()

            output_path = f"{temp_binary.name}_multi_patched.exe"

            try:
                patches = [
                    {
                        "offset": original_content.find(b'TRIAL_CHECK_ON'),
                        "original_bytes": b'TRIAL_CHECK_ON',
                        "new_bytes": b'TRIAL_CHECK_NO',  # Same length
                        "description": "Disable trial check"
                    },
                    {
                        "offset": original_content.find(b'VALIDATION_STRICT'),
                        "original_bytes": b'VALIDATION_STRICT',
                        "new_bytes": b'VALIDATION_BYPASS',  # Same length
                        "description": "Bypass validation"
                    }
                ]

                result = patch_selected(
                    binary_path=temp_binary.name,
                    patches=patches,
                    output_path=output_path
                )

                if result.get("success"):
                    assert result["patches_applied"] == 2

                    # Verify both patches applied
                    with open(result["output_file"], "rb") as patched_file:
                        patched_content = patched_file.read()
                        assert b'TRIAL_CHECK_NO' in patched_content
                        assert b'VALIDATION_BYPASS' in patched_content
                        assert b'TRIAL_CHECK_ON' not in patched_content
                        assert b'VALIDATION_STRICT' not in patched_content

            finally:
                os.unlink(temp_binary.name)
                if os.path.exists(output_path):
                    os.unlink(output_path)

    def test_patch_selected_instruction_level_patches(self):
        """Test applying instruction-level patches (assembly modifications)."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with x86 assembly patterns
            original_content = (
                b'MZ' + b'\x00' * 60 +
                b'PE\x00\x00' + b'\x00' * 50 +
                b'\x75\x0A'  # JNZ instruction (jump if not zero)
                + b'\x00' * 10 +
                b'\x74\x05'  # JZ instruction (jump if zero)
                + b'\x00' * 100
            )
            temp_binary.write(original_content)
            temp_binary.flush()

            output_path = f"{temp_binary.name}_asm_patched.exe"

            try:
                patches = [
                    {
                        "offset": original_content.find(b'\x75\x0A'),
                        "original_bytes": b'\x75\x0A',  # JNZ
                        "new_bytes": b'\x90\x90',       # NOP NOP
                        "description": "NOP out conditional jump",
                        "type": "instruction_patch"
                    }
                ]

                result = patch_selected(
                    binary_path=temp_binary.name,
                    patches=patches,
                    output_path=output_path
                )

                if result.get("success"):
                    with open(result["output_file"], "rb") as patched_file:
                        patched_content = patched_file.read()
                        # Should contain NOP instructions
                        assert b'\x90\x90' in patched_content
                        # Should not contain original JNZ
                        nop_offset = original_content.find(b'\x75\x0A')
                        assert patched_content[nop_offset:nop_offset+2] == b'\x90\x90'

            finally:
                os.unlink(temp_binary.name)
                if os.path.exists(output_path):
                    os.unlink(output_path)

    def test_patch_selected_error_conditions(self):
        """Test patch application error handling."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(b'MZ' + b'\x00' * 100)
            temp_binary.flush()

            try:
                # Test invalid offset
                invalid_patches = [
                    {
                        "offset": 99999,  # Beyond file size
                        "original_bytes": b'INVALID',
                        "new_bytes": b'PATCHED',
                        "description": "Invalid offset patch"
                    }
                ]

                result = patch_selected(
                    binary_path=temp_binary.name,
                    patches=invalid_patches
                )

                # Should handle invalid patches gracefully
                if not result.get("success"):
                    assert "error" in result or "patches_applied" in result
                    assert result.get("patches_applied", 0) == 0

            finally:
                os.unlink(temp_binary.name)


class TestAutomatedPatchAgent:
    """Test suite for automated patch agent functionality."""

    def test_run_automated_patch_agent_license_removal(self):
        """Test automated patch agent for license removal."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with license check patterns
            license_binary = self._create_license_protected_binary()
            temp_binary.write(license_binary)
            temp_binary.flush()

            try:
                # Mock app instance for testing
                class MockAppInstance:
                    def __init__(self):
                        self.binary_path = temp_binary.name
                        self.results = []

                    def update_status(self, status):
                        self.results.append(status)

                mock_app = MockAppInstance()

                result = run_automated_patch_agent(
                    app_instance=mock_app,
                    target_behavior="remove_license"
                )

                assert isinstance(result, dict)
                assert "success" in result
                assert "patches_identified" in result
                assert "automation_strategy" in result

                if result["success"]:
                    patches_identified = result["patches_identified"]
                    assert isinstance(patches_identified, list)
                    assert len(patches_identified) > 0

                    # Should identify license-related patches
                    for patch in patches_identified:
                        assert isinstance(patch, dict)
                        assert "description" in patch
                        assert "confidence" in patch

                        # Patch descriptions should reference license concepts
                        description = patch["description"].lower()
                        license_keywords = ["license", "trial", "check", "validation", "key"]
                        has_license_keyword = any(keyword in description
                                                for keyword in license_keywords)
                        assert has_license_keyword

                    # Automation strategy should be comprehensive
                    strategy = result["automation_strategy"]
                    assert isinstance(strategy, str)
                    assert len(strategy) > 100  # Detailed strategy

            finally:
                os.unlink(temp_binary.name)

    def test_run_automated_patch_agent_anti_debug_removal(self):
        """Test automated patch agent for anti-debug removal."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            antidebug_binary = self._create_antidebug_protected_binary()
            temp_binary.write(antidebug_binary)
            temp_binary.flush()

            try:
                class MockAppInstance:
                    def __init__(self):
                        self.binary_path = temp_binary.name

                mock_app = MockAppInstance()

                result = run_automated_patch_agent(
                    app_instance=mock_app,
                    target_behavior="remove_anti_debug"
                )

                if result.get("success"):
                    patches = result["patches_identified"]

                    # Should identify anti-debug patches
                    antidebug_keywords = ["debug", "debugger", "isdebuggerpresent", "breakpoint"]
                    has_antidebug_patches = False

                    for patch in patches:
                        description = patch.get("description", "").lower()
                        if any(keyword in description for keyword in antidebug_keywords):
                            has_antidebug_patches = True
                            break

                    assert has_antidebug_patches

            finally:
                os.unlink(temp_binary.name)

    def test_run_automated_patch_agent_comprehensive_analysis(self):
        """Test automated patch agent comprehensive analysis capabilities."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            comprehensive_binary = self._create_comprehensive_protected_binary()
            temp_binary.write(comprehensive_binary)
            temp_binary.flush()

            try:

                class MockAppInstance:
                    def __init__(self):
                        self.binary_path = temp_binary.name

                mock_app = MockAppInstance()

                result = run_automated_patch_agent(
                    app_instance=mock_app,
                    target_behavior="comprehensive_bypass"
                )

                if result.get("success"):
                    # Should identify multiple types of patches
                    patches = result["patches_identified"]
                    patch_types = set()

                    for patch in patches:
                        patch_type = patch.get("type", "unknown")
                        patch_types.add(patch_type)

                    # Should identify various protection types
                    expected_types = ["license", "anti_debug", "trial", "validation"]
                    identified_types = [
                        t
                        for t in expected_types
                        if any(t in str(patch_types).lower() for _ in patches)
                    ]
                    assert len(identified_types) > 1  # Multiple protection types

            finally:
                os.unlink(temp_binary.name)

    def _create_license_protected_binary(self) -> bytes:
        """Create binary with license protection patterns."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'LICENSE_KEY_VALIDATION_FUNCTION\x00' +
            b'TRIAL_PERIOD_CHECK\x00' +
            b'REGISTRATION_VERIFICATION\x00' +
            b'INVALID_LICENSE_MESSAGE\x00' +
            b'EXPIRED_TRIAL_WARNING\x00' +
            b'GetUserNameA\x00GetComputerNameA\x00' +
            b'RegQueryValueExA\x00RegSetValueExA\x00' +
            b'CryptHashData\x00CryptVerifySignatureA\x00' +
            b'\x75\x20'  # JNZ instruction (conditional jump)
            + b'\x00' * 10 +
            b'\x74\x15'  # JZ instruction
            + b'\x00' * 100
        )

    def _create_antidebug_protected_binary(self) -> bytes:
        """Create binary with anti-debug protection patterns."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'IsDebuggerPresent\x00' +
            b'CheckRemoteDebuggerPresent\x00' +
            b'NtQueryInformationProcess\x00' +
            b'OutputDebugStringA\x00' +
            b'DEBUGGER_DETECTED\x00' +
            b'ANTI_DEBUG_TRIGGER\x00' +
            b'ntdll.dll\x00kernel32.dll\x00' +
            b'\xCC'  # INT3 breakpoint
            + b'\x00' * 10 +
            b'\x85\xC0\x75\x05'  # TEST EAX,EAX; JNZ
            + b'\x00' * 100
        )

    def _create_comprehensive_protected_binary(self) -> bytes:
        """Create binary with comprehensive protection mechanisms."""
        return (
            # Basic PE structure
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +

            # License protection
            b'LICENSE_VALIDATION_SUBSYSTEM\x00' +
            b'TRIAL_EXPIRATION_CHECK\x00' +
            b'HARDWARE_ID_VERIFICATION\x00' +

            # Anti-debug
            b'IsDebuggerPresent\x00NtQueryInformationProcess\x00' +
            b'DEBUGGER_DETECTION_ACTIVE\x00' +

            # Anti-VM
            b'VIRTUAL_MACHINE_DETECTED\x00' +
            b'VMWARE_DETECTION\x00VIRTUALBOX_CHECK\x00' +

            # Code obfuscation indicators
            b'OBFUSCATED_CODE_SECTION\x00' +
            b'DYNAMIC_DECRYPTION_KEY\x00' +

            # Protection library imports
            b'kernel32.dll\x00ntdll.dll\x00advapi32.dll\x00' +
            b'GetTickCount\x00GetSystemTime\x00' +
            b'VirtualProtect\x00VirtualAlloc\x00' +

            # Assembly patterns
            b'\x75\x10'  # JNZ (license check)
            + b'\x00' * 5 +
            b'\x85\xC0\x74\x08'  # TEST EAX,EAX; JZ (anti-debug)
            + b'\x00' * 5 +
            b'\xCC\x90\x90'  # INT3, NOP, NOP (protection)
            + b'\x00' * 200
        )


class TestPatchVerificationAndSimulation:
    """Test suite for patch verification and simulation capabilities."""

    def test_verify_patches_without_applying(self):
        """Test patch verification without actual modification."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            # Create binary with known patchable content
            original_content = (
                b'MZ' + b'\x00' * 60 +
                b'PE\x00\x00' + b'\x00' * 50 +
                b'PATCHABLE_SECTION_HERE' +
                b'\x00' * 100
            )
            temp_binary.write(original_content)
            temp_binary.flush()

            try:
                patches = [
                    {
                        "offset": original_content.find(b'PATCHABLE_SECTION_HERE'),
                        "original_bytes": b'PATCHABLE_SECTION_HERE',
                        "new_bytes": b'PATCHED__SECTION_HERE',  # Same length
                        "description": "Test verification patch"
                    },
                    {
                        "offset": 500,  # Invalid offset for testing
                        "original_bytes": b'NONEXISTENT',
                        "new_bytes": b'REPLACEMENT',
                        "description": "Invalid patch for testing"
                    }
                ]

                result = verify_patches_without_applying(
                    binary_path=temp_binary.name,
                    patches=patches
                )

                assert isinstance(result, dict)
                assert "verification_results" in result
                assert "all_patches_valid" in result

                verification_results = result["verification_results"]
                assert isinstance(verification_results, list)
                assert len(verification_results) == len(patches)

                # First patch should be valid, second should be invalid
                assert verification_results[0].get("valid") is True
                assert verification_results[1].get("valid") is False

                # Overall result should indicate mixed results
                assert result["all_patches_valid"] is False

                # Original file should be unchanged
                with open(temp_binary.name, "rb") as unchanged_file:
                    unchanged_content = unchanged_file.read()
                    assert unchanged_content == original_content

            finally:
                os.unlink(temp_binary.name)

    def test_run_simulate_patch_comprehensive(self):
        """Test comprehensive patch simulation functionality."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_simulation_test_binary())
            temp_binary.flush()

            try:
                patches = [
                    {
                        "type": "license_bypass",
                        "target_function": "ValidateLicense",
                        "method": "nop_instruction",
                        "confidence": 0.9,
                        "description": "Bypass license validation"
                    },
                    {
                        "type": "trial_removal",
                        "target_function": "CheckTrialExpiry",
                        "method": "return_success",
                        "confidence": 0.8,
                        "description": "Remove trial expiry check"
                    }
                ]

                result = run_simulate_patch(
                    patches=patches,
                    target_binary=temp_binary.name
                )

                assert isinstance(result, dict)
                assert "simulation_results" in result
                assert "success" in result

                if result["success"]:
                    simulation_results = result["simulation_results"]
                    assert isinstance(simulation_results, list)
                    assert len(simulation_results) == len(patches)

                    for sim_result in simulation_results:
                        assert isinstance(sim_result, dict)
                        assert "patch_type" in sim_result or "status" in sim_result
                        assert "simulation_outcome" in sim_result or "predicted_result" in sim_result

                        # Simulation should predict patch effectiveness
                        if "effectiveness_score" in sim_result:
                            score = sim_result["effectiveness_score"]
                            assert isinstance(score, (int, float))
                            assert 0.0 <= score <= 1.0

            finally:
                os.unlink(temp_binary.name)

    def test_run_simulate_patch_behavioral_analysis(self):
        """Test patch simulation with behavioral analysis."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_behavioral_test_binary())
            temp_binary.flush()

            try:
                behavioral_patches = [
                    {
                        "type": "behavioral_modification",
                        "target_behavior": "license_check_bypass",
                        "expected_outcome": "allow_execution_without_license",
                        "risk_assessment": "low"
                    }
                ]

                result = run_simulate_patch(
                    patches=behavioral_patches,
                    target_binary=temp_binary.name
                )

                if result.get("success"):
                    # Should include behavioral analysis
                    assert "behavioral_analysis" in result or "behavior_prediction" in result

                    # Should analyze impact on program behavior
                    if "behavioral_analysis" in result:
                        behavioral_analysis = result["behavioral_analysis"]
                        assert isinstance(behavioral_analysis, (dict, list))

            finally:
                os.unlink(temp_binary.name)

    def _create_simulation_test_binary(self) -> bytes:
        """Create binary for patch simulation testing."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'ValidateLicense\x00CheckTrialExpiry\x00' +
            b'LICENSE_VALIDATION_ROUTINE\x00' +
            b'TRIAL_EXPIRY_CHECK_FUNCTION\x00' +
            b'SUCCESS_PATH\x00FAILURE_PATH\x00' +
            b'\x75\x08'  # JNZ success
            + b'\x00' * 5 +
            b'\x74\x10'  # JZ failure
            + b'\x00' * 100
        )

    def _create_behavioral_test_binary(self) -> bytes:
        """Create binary for behavioral testing."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'BEHAVIORAL_ANALYSIS_TARGET\x00' +
            b'EXECUTION_FLOW_CONTROL\x00' +
            b'STATE_MACHINE_LOGIC\x00' +
            b'CONDITIONAL_EXECUTION\x00' +
            b'\x00' * 150
        )


class TestPlatformSpecificPatching:
    """Test suite for platform-specific patching capabilities."""

    def test_windows_pe_patching(self):
        """Test Windows PE-specific patching functionality."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_pe:
            pe_binary = self._create_windows_pe_binary()
            temp_pe.write(pe_binary)
            temp_pe.flush()

            try:
                patch_info = {
                    "type": "pe_modification",
                    "target_section": ".text",
                    "modification": "license_bypass"
                }

                result = _test_windows_pe(
                    original_binary=temp_pe.name,
                    patched_binary=f"{temp_pe.name}_patched",
                    patch=patch_info,
                )

                assert isinstance(result, dict)
                assert "success" in result
                assert "pe_analysis" in result

                if result["success"]:
                    pe_analysis = result["pe_analysis"]
                    assert isinstance(pe_analysis, dict)

                    # Should analyze PE-specific elements
                    pe_elements = ["headers", "sections", "imports", "exports"]
                    if has_pe_analysis := any(
                        element in pe_analysis for element in pe_elements
                    ):
                        assert has_pe_analysis

            finally:
                os.unlink(temp_pe.name)
                if os.path.exists(f"{temp_pe.name}_patched"):
                    os.unlink(f"{temp_pe.name}_patched")

    def test_linux_elf_patching(self):
        """Test Linux ELF-specific patching functionality."""
        with tempfile.NamedTemporaryFile(delete=False) as temp_elf:
            elf_binary = self._create_linux_elf_binary()
            temp_elf.write(elf_binary)
            temp_elf.flush()

            try:
                patch_info = {
                    "type": "elf_modification",
                    "target_section": ".text",
                    "modification": "license_bypass"
                }

                result = _test_linux_elf(
                    original_binary=temp_elf.name,
                    patched_binary=f"{temp_elf.name}_patched",
                    patch=patch_info,
                )

                assert isinstance(result, dict)
                assert "success" in result

                if result["success"]:
                    # Should handle ELF-specific format
                    assert "elf_analysis" in result or "format_analysis" in result

            finally:
                os.unlink(temp_elf.name)
                if os.path.exists(f"{temp_elf.name}_patched"):
                    os.unlink(f"{temp_elf.name}_patched")

    def test_macos_macho_patching(self):
        """Test macOS Mach-O-specific patching functionality."""
        with tempfile.NamedTemporaryFile(delete=False) as temp_macho:
            macho_binary = self._create_macos_macho_binary()
            temp_macho.write(macho_binary)
            temp_macho.flush()

            try:
                patch_info = {
                    "type": "macho_modification",
                    "target_section": "__TEXT",
                    "modification": "license_bypass"
                }

                result = _test_macos_macho(
                    original_binary=temp_macho.name,
                    patched_binary=f"{temp_macho.name}_patched",
                    patch=patch_info,
                )

                assert isinstance(result, dict)
                assert "success" in result

                if result["success"]:
                    # Should handle Mach-O-specific format
                    assert "macho_analysis" in result or "format_analysis" in result

            finally:
                os.unlink(temp_macho.name)
                if os.path.exists(f"{temp_macho.name}_patched"):
                    os.unlink(f"{temp_macho.name}_patched")

    def test_cross_platform_patching(self):
        """Test cross-platform patching capabilities."""
        test_binaries = [
            ("windows.exe", self._create_windows_pe_binary()),
            ("linux", self._create_linux_elf_binary()),
            ("macos", self._create_macos_macho_binary())
        ]

        for filename, binary_data in test_binaries:
            with tempfile.NamedTemporaryFile(suffix=filename, delete=False) as temp_binary:
                temp_binary.write(binary_data)
                temp_binary.flush()

                try:
                    patch_info = {
                        "type": "universal_license_bypass",
                        "platform_agnostic": True
                    }

                    result = _test_cross_platform(
                        original_binary=temp_binary.name,
                        patched_binary=f"{temp_binary.name}_cross_patched",
                        patch=patch_info,
                    )

                    assert isinstance(result, dict)
                    assert "success" in result

                    if result["success"]:
                        # Should identify platform and adapt accordingly
                        assert "detected_platform" in result or "format_detected" in result

                finally:
                    os.unlink(temp_binary.name)
                    if os.path.exists(f"{temp_binary.name}_cross_patched"):
                        os.unlink(f"{temp_binary.name}_cross_patched")

    def _create_windows_pe_binary(self) -> bytes:
        """Create minimal Windows PE binary for testing."""
        return (
            b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xFF\xFF\x00\x00' +
            b'\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00' +
            b'\x00' * 32 +
            b'\x80\x00\x00\x00' +  # e_lfanew

            b'PE\x00\x00' +  # PE signature
            b'\x4c\x01\x01\x00' +  # Machine + sections
            b'\x00' * 16 +  # Timestamps, etc.
            b'\xe0\x00\x0f\x01' +  # Characteristics

            b'\x0b\x01\x08\x00' +  # Optional header
            b'\x00' * 220 +  # Rest of optional header

            # Section header
            b'.text\x00\x00\x00' +  # Name
            b'\x00\x10\x00\x00' +  # Virtual size
            b'\x00\x10\x00\x00' +  # Virtual address
            b'\x00\x10\x00\x00' +  # Size of raw data
            b'\x00\x02\x00\x00' +  # Pointer to raw data
            b'\x00' * 12 +  # Relocations, line numbers
            b'\x60\x00\x00\x20' +  # Characteristics

            b'\x00' * 200  # Code section
        )

    def _create_linux_elf_binary(self) -> bytes:
        """Create minimal Linux ELF binary for testing."""
        return (
            b'\x7fELF' +  # ELF magic
            b'\x02\x01\x01\x00' +  # 64-bit, little endian, version, ABI
            b'\x00' * 8 +  # Padding
            b'\x02\x00\x3e\x00' +  # Type, machine (x86-64)
            b'\x01\x00\x00\x00' +  # Version
            b'\x78\x00\x40\x00\x00\x00\x00\x00' +  # Entry point
            b'\x40\x00\x00\x00\x00\x00\x00\x00' +  # Program header offset
            b'\x00\x00\x00\x00\x00\x00\x00\x00' +  # Section header offset
            b'\x00\x00\x00\x00' +  # Flags
            b'\x40\x00\x38\x00\x01\x00\x40\x00\x00\x00\x00\x00' +  # Header sizes
            b'\x00' * 200  # Code and data
        )

    def _create_macos_macho_binary(self) -> bytes:
        """Create minimal macOS Mach-O binary for testing."""
        return (
            b'\xfe\xed\xfa\xce' +  # Mach-O 32-bit magic (big endian)
            b'\x00\x00\x00\x0c' +  # CPU type (x86)
            b'\x00\x00\x00\x09' +  # CPU subtype
            b'\x00\x00\x00\x02' +  # File type (executable)
            b'\x00\x00\x00\x03' +  # Number of load commands
            b'\x00\x00\x00\xf0' +  # Size of load commands
            b'\x00\x00\x00\x85' +  # Flags
            b'\x00' * 200  # Load commands and code
        )


class TestPatchInstructionGeneration:
    """Test suite for patch instruction generation."""

    def test_generate_patch_instructions_software_specific(self):
        """Test patch instruction generation for specific software."""
        software_types = [
            "Generic_Trial_Software",
            "Adobe_Creative_Suite",
            "Microsoft_Office",
            "WinRAR_Archiver",
            "Custom_Enterprise_App"
        ]

        for software in software_types:
            result = _generate_patch_instructions(software)

            assert isinstance(result, list)
            assert len(result) > 0

            # Each instruction should be a dictionary with required fields
            for instruction in result:
                assert isinstance(instruction, dict)
                assert "type" in instruction
                assert "description" in instruction

                # Should have specific targeting information
                assert "target" in instruction or "offset" in instruction or "pattern" in instruction

                # Confidence should be specified
                if "confidence" in instruction:
                    confidence = instruction["confidence"]
                    assert isinstance(confidence, (int, float))
                    assert 0.0 <= confidence <= 1.0

                # Instruction type should be recognized
                instruction_type = instruction["type"]
                known_types = [
                    "license_bypass", "trial_removal", "anti_debug_disable",
                    "validation_skip", "registration_bypass", "nop_instruction",
                    "return_modification", "jump_patch"
                ]
                assert instruction_type in known_types or "custom" in instruction_type.lower()

    def test_generate_patch_instructions_complexity_levels(self):
        """Test patch instruction generation for different complexity levels."""
        complexity_tests = [
            ("Simple_Shareware", 1, 3),    # Simple software, 1-3 patches
            ("Enterprise_Software", 5, 15), # Complex software, 5-15 patches
            ("Gaming_DRM", 3, 10),         # DRM-protected, 3-10 patches
            ("Security_Software", 8, 20)   # Security software, 8-20 patches
        ]

        for software, min_patches, max_patches in complexity_tests:
            result = _generate_patch_instructions(software)

            if len(result) > 0:  # If patches were generated
                assert min_patches <= len(result) <= max_patches

                # More complex software should have more sophisticated patches
                if "Enterprise" in software or "Security" in software:
                    # Should include multiple patch types
                    patch_types = {instr.get("type", "") for instr in result}
                    assert len(patch_types) >= 2  # Multiple patch types

                    # Should include high-confidence patches
                    high_confidence_patches = [
                        instr for instr in result
                        if instr.get("confidence", 0) > 0.7
                    ]
                    assert high_confidence_patches


class TestPatchAnalysisComprehensive:
    """Test suite for comprehensive patch analysis functionality."""

    def test_analyze_for_patches_comprehensive_analysis(self):
        """Test comprehensive binary analysis for patching opportunities."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            comprehensive_binary = self._create_comprehensive_analysis_binary()
            temp_binary.write(comprehensive_binary)
            temp_binary.flush()

            try:
                result = analyze_for_patches(temp_binary.name)

                assert isinstance(result, dict)
                assert "patches_found" in result
                assert "analysis_summary" in result
                assert "confidence_scores" in result

                patches_found = result["patches_found"]
                assert isinstance(patches_found, list)

                if len(patches_found) > 0:
                    # Should find various types of patches
                    patch_categories = set()

                    for patch in patches_found:
                        assert isinstance(patch, dict)
                        assert "offset" in patch or "pattern" in patch
                        assert "description" in patch
                        assert "confidence" in patch

                        # Categorize patch types
                        description = patch["description"].lower()
                        if "license" in description:
                            patch_categories.add("license")
                        elif "trial" in description:
                            patch_categories.add("trial")
                        elif "debug" in description:
                            patch_categories.add("anti_debug")
                        elif "validation" in description:
                            patch_categories.add("validation")

                    # Should find multiple categories
                    assert len(patch_categories) >= 2

                # Analysis summary should be comprehensive
                analysis_summary = result["analysis_summary"]
                assert isinstance(analysis_summary, str)
                assert len(analysis_summary) > 100

                # Confidence scores should be provided
                confidence_scores = result["confidence_scores"]
                assert isinstance(confidence_scores, dict)

            finally:
                os.unlink(temp_binary.name)

    def test_analyze_for_patches_detection_accuracy(self):
        """Test patch detection accuracy with known patterns."""
        test_cases = [
            {
                "name": "license_check_binary",
                "binary_func": self._create_license_check_binary,
                "expected_patches": ["license_bypass", "trial_removal"]
            },
            {
                "name": "antidebug_binary",
                "binary_func": self._create_antidebug_binary,
                "expected_patches": ["anti_debug_disable", "debugger_bypass"]
            },
            {
                "name": "validation_binary",
                "binary_func": self._create_validation_binary,
                "expected_patches": ["validation_skip", "check_bypass"]
            }
        ]

        for test_case in test_cases:
            with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
                binary_data = test_case["binary_func"]()
                temp_binary.write(binary_data)
                temp_binary.flush()

                try:
                    result = analyze_for_patches(temp_binary.name)

                    if result.get("patches_found"):
                        patches = result["patches_found"]
                        patch_descriptions = [p.get("description", "").lower()
                                            for p in patches]

                        # Should detect expected patch types
                        expected_patches = test_case["expected_patches"]
                        detected_types = []

                        for expected in expected_patches:
                            for desc in patch_descriptions:
                                if any(keyword in desc for keyword in expected.split("_")):
                                    detected_types.append(expected)
                                    break

                        # Should detect at least one expected type
                        assert detected_types

                finally:
                    os.unlink(temp_binary.name)

    def test_analyze_for_patches_performance(self):
        """Test patch analysis performance with various binary sizes."""
        import time

        binary_sizes = [
            (1024, "small"),      # 1KB
            (10240, "medium"),    # 10KB
            (102400, "large")     # 100KB
        ]

        for size, size_name in binary_sizes:
            with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
                # Create binary of specified size
                binary_data = self._create_sized_binary(size)
                temp_binary.write(binary_data)
                temp_binary.flush()

                try:
                    start_time = time.time()
                    result = analyze_for_patches(temp_binary.name)
                    end_time = time.time()

                    analysis_time = end_time - start_time

                    # Performance requirements based on size
                    if size_name == "small":
                        assert analysis_time < 5.0  # 5 seconds max for small
                    elif size_name == "medium":
                        assert analysis_time < 15.0  # 15 seconds max for medium
                    elif size_name == "large":
                        assert analysis_time < 30.0  # 30 seconds max for large

                    # Should complete successfully regardless of size
                    assert isinstance(result, dict)

                finally:
                    os.unlink(temp_binary.name)

    def _create_comprehensive_analysis_binary(self) -> bytes:
        """Create binary with comprehensive protection patterns for analysis."""
        return (
            b'MZ' + b'\x00' * 60 +  # DOS header
            b'PE\x00\x00' + b'\x00' * 50 +  # PE header

            # License protection patterns
            b'LICENSE_KEY_VALIDATION_SYSTEM\x00' +
            b'TRIAL_PERIOD_MANAGEMENT\x00' +
            b'REGISTRATION_VERIFICATION\x00' +
            b'HARDWARE_ID_BINDING\x00' +

            # Anti-debug patterns
            b'IsDebuggerPresent\x00CheckRemoteDebuggerPresent\x00' +
            b'NtQueryInformationProcess\x00ZwQueryInformationProcess\x00' +
            b'OutputDebugStringA\x00SetUnhandledExceptionFilter\x00' +

            # Anti-VM patterns
            b'VIRTUAL_MACHINE_DETECTION\x00' +
            b'VMWARE_HYPERVISOR_CHECK\x00' +
            b'VIRTUALBOX_ARTIFACTS\x00' +

            # Code integrity patterns
            b'CHECKSUM_VERIFICATION\x00' +
            b'SIGNATURE_VALIDATION\x00' +
            b'TAMPER_DETECTION\x00' +

            # Common vulnerable functions
            b'strcpy\x00strcat\x00sprintf\x00printf\x00' +
            b'malloc\x00free\x00memcpy\x00' +

            # System APIs
            b'kernel32.dll\x00ntdll.dll\x00advapi32.dll\x00' +
            b'RegQueryValueEx\x00RegSetValueEx\x00' +
            b'CryptHashData\x00CryptVerifySignature\x00' +
            b'GetUserName\x00GetComputerName\x00' +
            b'GetVolumeInformation\x00GetSystemInfo\x00' +

            # Assembly patterns for patching
            b'\x75\x10'  # JNZ (conditional jump)
            + b'\x00' * 8 +
            b'\x74\x0C'  # JZ (conditional jump)
            + b'\x00' * 6 +
            b'\x85\xC0\x75\x08'  # TEST EAX,EAX; JNZ
            + b'\x00' * 4 +
            b'\xCC'  # INT3 (breakpoint)
            + b'\x90\x90\x90'  # NOP padding
            + b'\x00' * 200
        )

    def _create_license_check_binary(self) -> bytes:
        """Create binary focused on license checking patterns."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'ValidateLicenseKey\x00CheckTrialPeriod\x00' +
            b'LICENSE_EXPIRED\x00INVALID_KEY\x00' +
            b'TRIAL_PERIOD_ENDED\x00' +
            b'\x75\x15'  # JNZ license_valid
            + b'\x00' * 100
        )

    def _create_antidebug_binary(self) -> bytes:
        """Create binary focused on anti-debug patterns."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'IsDebuggerPresent\x00' +
            b'DEBUGGER_DETECTED\x00' +
            b'\x85\xC0\x75\x05'  # TEST EAX,EAX; JNZ debugger_found
            + b'\x00' * 100
        )

    def _create_validation_binary(self) -> bytes:
        """Create binary focused on validation patterns."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'ValidateInput\x00VerifyChecksum\x00' +
            b'VALIDATION_FAILED\x00CHECKSUM_ERROR\x00' +
            b'\x74\x08'  # JZ validation_passed
            + b'\x00' * 100
        )

    def _create_sized_binary(self, size: int) -> bytes:
        """Create binary of specified size for performance testing."""
        base_size = 200  # Base PE structure
        pattern_size = size - base_size if size > base_size else 0

        base_binary = (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'LICENSE_CHECK\x00TRIAL_CHECK\x00' +
            b'\x00' * 80
        )

        # Add pattern data to reach desired size
        pattern_data = (b'PATTERN_DATA_' + b'\x00' * 20) * (pattern_size // 33 + 1)
        return base_binary + pattern_data[:pattern_size]


@pytest.mark.integration
class TestPatchingIntegrationScenarios:
    """Integration tests for complete patching workflows."""

    def test_end_to_end_patching_workflow(self):
        """Test complete patching workflow from analysis to application."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            original_binary = self._create_workflow_test_binary()
            temp_binary.write(original_binary)
            temp_binary.flush()

            output_file = f"{temp_binary.name}_workflow_patched.exe"

            try:
                # Step 1: Analyze for patches
                analysis_result = analyze_for_patches(temp_binary.name)
                assert analysis_result.get("patches_found") is not None

                patches_found = analysis_result["patches_found"]

                if len(patches_found) > 0:
                    # Step 2: Verify patches without applying
                    verification_result = verify_patches_without_applying(
                        binary_path=temp_binary.name,
                        patches=patches_found
                    )
                    assert verification_result.get("all_patches_valid") is not None

                    if valid_patches := [
                        patch
                        for patch, result in zip(
                            patches_found,
                            verification_result["verification_results"],
                        )
                        if result.get("valid")
                    ]:
                        # Step 3: Apply valid patches
                        patch_result = patch_selected(
                            binary_path=temp_binary.name,
                            patches=valid_patches,
                            output_path=output_file
                        )

                        if patch_result.get("success"):
                            # Step 4: Verify patched binary
                            assert os.path.exists(output_file)

                            # File should be modified
                            with open(temp_binary.name, "rb") as orig:
                                with open(output_file, "rb") as patched:
                                    orig_data = orig.read()
                                    patched_data = patched.read()

                            # Should be different but same size (for simple patches)
                            if len(orig_data) == len(patched_data):
                                assert orig_data != patched_data

            finally:
                os.unlink(temp_binary.name)
                if os.path.exists(output_file):
                    os.unlink(output_file)

    def test_automated_patching_workflow(self):
        """Test automated patching workflow with agent assistance."""
        with tempfile.NamedTemporaryFile(suffix=".exe", delete=False) as temp_binary:
            temp_binary.write(self._create_automated_test_binary())
            temp_binary.flush()

            try:
                class MockAutomatedApp:
                    def __init__(self):
                        self.binary_path = temp_binary.name
                        self.status_updates = []

                    def update_status(self, status):
                        self.status_updates.append(status)

                mock_app = MockAutomatedApp()

                # Run automated patch agent
                agent_result = run_automated_patch_agent(
                    app_instance=mock_app,
                    target_behavior="comprehensive_bypass"
                )

                if agent_result.get("success"):
                    identified_patches = agent_result["patches_identified"]

                    # Simulate patch application from agent recommendations
                    simulation_result = run_simulate_patch(
                        patches=identified_patches,
                        target_binary=temp_binary.name
                    )

                    assert simulation_result.get("success") is not None

                    # Should provide meaningful automation results
                    assert len(mock_app.status_updates) > 0

            finally:
                os.unlink(temp_binary.name)

    def _create_workflow_test_binary(self) -> bytes:
        """Create binary for end-to-end workflow testing."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'WORKFLOW_LICENSE_CHECK' +  # Patchable pattern
            b'\x00' * 10 +
            b'TRIAL_EXPIRY_VALIDATION' +  # Another patchable pattern
            b'\x00' * 10 +
            b'\x75\x08'  # JNZ - patchable instruction
            + b'\x00' * 100
        )

    def _create_automated_test_binary(self) -> bytes:
        """Create binary for automated workflow testing."""
        return (
            b'MZ' + b'\x00' * 60 +
            b'PE\x00\x00' + b'\x00' * 50 +
            b'AUTOMATED_PATCH_TARGET_1\x00' +
            b'AUTOMATED_PATCH_TARGET_2\x00' +
            b'COMPREHENSIVE_PROTECTION\x00' +
            b'IsDebuggerPresent\x00' +
            b'LICENSE_VALIDATION\x00' +
            b'\x00' * 100
        )
