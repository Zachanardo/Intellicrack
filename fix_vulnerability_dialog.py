"""Fix indentation and complexity issues in vulnerability_research_dialog.py"""
import re


def fix_indentation_and_complexity():
    """Fix indentation issues and reduce complexity by extracting methods."""

    with open('intellicrack/ui/dialogs/vulnerability_research_dialog.py', 'r', encoding='utf-8') as f:
        lines = f.readlines()

    fixed_lines = []
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped = line.strip()

        # Skip empty lines
        if not stripped:
            fixed_lines.append(line)
            i += 1
            continue

        # Fix _execute_testcase indentation
        if 'def _execute_testcase(self, target_path, test_case):' in line:
            fixed_lines.append('    def _execute_testcase(self, target_path, test_case):\n')
            i += 1
            # Fix the body indentation
            while i < len(lines) and not lines[i].strip().startswith('def '):
                content = lines[i].strip()
                if content:
                    if content.startswith('"""'):
                        fixed_lines.append('        ' + content + '\n')
                    elif content.startswith('import ') or content.startswith('return '):
                        fixed_lines.append('        ' + content + '\n')
                    elif content.startswith('try:') or content.startswith('except'):
                        fixed_lines.append('        ' + content + '\n')
                    elif content.startswith('with ') or content.startswith('if '):
                        fixed_lines.append('            ' + content + '\n')
                    elif content.startswith('#'):
                        fixed_lines.append('            ' + content + '\n')
                    elif content.startswith('result = '):
                        fixed_lines.append('                ' + content + '\n')
                    elif content.startswith('['):
                        fixed_lines.append('                    ' + content + '\n')
                    elif content.startswith('"'):
                        fixed_lines.append('                    ' + content + '\n')
                    else:
                        # Default to 12 spaces for method body content
                        if lines[i].startswith('        '):
                            fixed_lines.append(lines[i])
                        else:
                            fixed_lines.append('            ' + content + '\n')
                else:
                    fixed_lines.append(lines[i])
                i += 1
            continue

        # Fix other method definitions
        if re.match(r'^\s*def\s+_', line):
            # Check if it's a class method or module function
            if 'self' in line:
                # Class method - should have 4 spaces
                fixed_lines.append('    ' + stripped + '\n')
            else:
                # Module function - no indentation
                fixed_lines.append(stripped + '\n')
            i += 1
            continue

        # Fix try/except/finally blocks
        if stripped == 'try:':
            # Count current indentation
            current_indent = len(line) - len(line.lstrip())
            fixed_lines.append(' ' * current_indent + 'try:\n')
            i += 1
            continue

        # Fix return statements
        if stripped.startswith('return '):
            # Use proper indentation based on context
            if i > 0 and 'except' in lines[i-1]:
                fixed_lines.append('            ' + stripped + '\n')
            else:
                fixed_lines.append('        ' + stripped + '\n')
            i += 1
            continue

        # Fix logger statements
        if stripped.startswith('logger.'):
            # Count proper indentation
            if i > 0:
                prev = lines[i-1]
                if 'except' in prev:
                    fixed_lines.append('            ' + stripped + '\n')
                else:
                    fixed_lines.append('        ' + stripped + '\n')
            else:
                fixed_lines.append('        ' + stripped + '\n')
            i += 1
            continue

        # Default - keep as is
        fixed_lines.append(line)
        i += 1

    # Write the fixed content
    with open('intellicrack/ui/dialogs/vulnerability_research_dialog.py', 'w', encoding='utf-8') as f:
        f.writelines(fixed_lines)

    print("Fixed indentation issues")

    # Now refactor complex methods by extracting helper methods
    refactor_complex_methods()

def refactor_complex_methods():
    """Extract helper methods to reduce complexity."""

    # Read the file again
    with open('intellicrack/ui/dialogs/vulnerability_research_dialog.py', 'r', encoding='utf-8') as f:
        content = f.read()

    # Extract AFL coverage logic into separate method
    afl_coverage_method = '''
    def _get_afl_coverage(self, target_binary, test_input_file, coverage_data):
        """Get coverage using AFL++ showmap."""
        import shutil
        import subprocess

        afl_showmap = shutil.which("afl-showmap")
        if not afl_showmap or not self._is_afl_instrumented(target_binary):
            return None

        try:
            result = subprocess.run(
                [afl_showmap, "-o", "-", "-q", "--", target_binary, test_input_file],
                check=False,
                capture_output=True,
                timeout=5,
                text=True,
            )

            if result.returncode == 0:
                coverage_lines = result.stdout.strip().split("\\n")
                coverage_data["basic_blocks"] = len(coverage_lines)
                coverage_data["functions"] = coverage_data["basic_blocks"] // 10
                coverage_data["branches"] = coverage_data["basic_blocks"] // 2
                return coverage_data
        except Exception:
            pass
        return None
'''

    # Extract gcov coverage logic
    gcov_coverage_method = '''
    def _get_gcov_coverage(self, target_binary, test_input_file, coverage_data):
        """Get coverage using gcov."""
        import os
        import subprocess
        import tempfile

        with tempfile.TemporaryDirectory() as temp_dir:
            gcov_env = os.environ.copy()
            gcov_env["GCOV_PREFIX"] = temp_dir
            gcov_env["GCOV_PREFIX_STRIP"] = "0"

            try:
                subprocess.run(
                    [target_binary, test_input_file],
                    check=False,
                    env=gcov_env,
                    capture_output=True,
                    timeout=5,
                )
            except Exception:
                pass

            try:
                gcov_result = subprocess.run(
                    ["gcov", "-b", "-c", target_binary],
                    check=False,
                    cwd=temp_dir,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )

                if gcov_result.returncode == 0:
                    detailed_coverage = self._parse_gcov_data(temp_dir)
                    if detailed_coverage and detailed_coverage.get("summary"):
                        summary = detailed_coverage["summary"]
                        coverage_data.update({
                            "basic_blocks": summary["executed_lines"],
                            "functions": summary["executed_functions"],
                            "branches": summary["taken_branches"],
                            "detailed_coverage": detailed_coverage,
                        })
                        return coverage_data

                    # Parse simple gcov output
                    return self._parse_simple_gcov(gcov_result.stdout, coverage_data)
            except Exception:
                pass
        return None
'''

    # Extract objdump coverage logic
    objdump_coverage_method = '''
    def _get_objdump_coverage(self, target_binary, coverage_data):
        """Get coverage estimation using objdump."""
        import re
        import subprocess

        try:
            result = subprocess.run(
                ["objdump", "-d", target_binary],
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
            )

            if result.returncode == 0:
                functions = len(re.findall(r"^[0-9a-f]+ <\\w+>:", result.stdout, re.MULTILINE))
                basic_blocks = len(re.findall(r"^\\s*[0-9a-f]+:", result.stdout, re.MULTILINE))
                branches = len(re.findall(r"\\s+j[a-z]+\\s+", result.stdout))

                coverage_data["functions"] = min(functions, 100)
                coverage_data["basic_blocks"] = min(basic_blocks // 10, 100)
                coverage_data["branches"] = min(branches // 10, 50)
                return coverage_data
        except Exception:
            pass
        return None
'''

    # Find where to insert the new methods (after _get_real_coverage)
    insert_pos = content.find('def _parse_gcov_data')
    if insert_pos > 0:
        # Insert the new helper methods
        content = content[:insert_pos] + afl_coverage_method + '\n' + gcov_coverage_method + '\n' + objdump_coverage_method + '\n' + content[insert_pos:]

    # Now simplify _get_real_coverage to use these helpers
    simplified_get_real_coverage = '''    def _get_real_coverage(self, target_binary, test_input_file):
        """Get real code coverage data using gcov or AFL++."""
        coverage_data = {
            "basic_blocks": 0,
            "functions": 0,
            "branches": 0,
            "detailed_coverage": None,
        }

        # Try AFL++ coverage first
        result = self._get_afl_coverage(target_binary, test_input_file, coverage_data)
        if result:
            return result

        # Try gcov coverage
        result = self._get_gcov_coverage(target_binary, test_input_file, coverage_data)
        if result:
            return result

        # Fallback to objdump estimation
        result = self._get_objdump_coverage(target_binary, coverage_data)
        if result:
            return result

        # Return minimal coverage if all methods fail
        return {"basic_blocks": 1, "functions": 1, "branches": 0, "detailed_coverage": None}
'''

    # Replace the complex _get_real_coverage method
    pattern = r'def _get_real_coverage\(self.*?\n(?:.*?\n)*?return \{"basic_blocks": 1, "functions": 1, "branches": 0, "detailed_coverage": None\}'
    content = re.sub(pattern, simplified_get_real_coverage.strip(), content, flags=re.DOTALL)

    # Write the refactored content
    with open('intellicrack/ui/dialogs/vulnerability_research_dialog.py', 'w', encoding='utf-8') as f:
        f.write(content)

    print("Refactored complex methods")

if __name__ == "__main__":
    fix_indentation_and_complexity()
