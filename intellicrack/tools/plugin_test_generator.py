"""Plugin test generator for creating automated tests for plugins."""

import ast
from pathlib import Path
from typing import Any, cast

"""
Plugin Unit Test Generator for Intellicrack.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""


class PluginTestGenerator:
    """Generates unit tests for Intellicrack plugins"""

    def __init__(self) -> None:
        """Initialize plugin test generator with test templates and configurations."""
        self.test_template = '''"""
Unit tests for {plugin_name}.
Generated by Intellicrack Test Generator on {date}.
"""

import unittest
import os
import sys
import tempfile
from unittest.mock import Mock, patch, MagicMock

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

{imports}

class Test{class_name}(unittest.TestCase):
    """Test cases for {class_name}"""

    def setUp(self):
        """Set up test fixtures"""
        self.plugin = {class_name}()
        self.test_binary = self._create_test_binary()
        self.test_options = {{
            'verbose': True,
            'timeout': 30
        }}

    def tearDown(self):
        """Clean up after tests"""
        if hasattr(self, 'test_binary') and os.path.exists(self.test_binary):
            os.remove(self.test_binary)

    def _create_test_binary(self):
        """Create a test binary file"""
        # Create a minimal PE file for testing
        pe_header = b'MZ' + b'\\x00' * 58 + b'\\x00\\x00\\x00\\x00'  # DOS header
        pe_data = pe_header + b'PE\\x00\\x00' + b'\\x00' * 1000  # Minimal PE

        with tempfile.NamedTemporaryFile(delete=False, suffix='.exe') as f:
            f.write(pe_data)
            return f.name

{test_methods}

    # Helper assertion methods
    def assertPluginResult(self, result):
        """Assert that plugin result has expected structure"""
        self.assertIsInstance(result, dict)
        self.assertIn('status', result)
        self.assertIn(result['status'], ['success', 'error', 'warning'])

    def assertNoErrors(self, result):
        """Assert that plugin executed without errors"""
        self.assertEqual(result.get('status'), 'success')
        self.assertNotIn('error', result)


if __name__ == '__main__':
    unittest.main()
'''

        self.method_test_template = '''
    def test_{method_name}_basic(self):
        """Test {method_name} with basic input"""
        {test_body}

    def test_{method_name}_invalid_input(self):
        """Test {method_name} with invalid input"""
        {invalid_test_body}

    def test_{method_name}_edge_cases(self):
        """Test {method_name} edge cases"""
        {edge_test_body}'''

    def generate_tests_for_file(self, file_path: str) -> str:
        """Generate tests for a plugin file"""
        import os
        from datetime import datetime

        plugin_name = os.path.basename(file_path).replace(".py", "")
        class_name = "".join(word.capitalize() for word in plugin_name.split("_"))

        test_methods = self._extract_and_generate_tests(file_path, plugin_name, class_name)

        return self.test_template.format(
            plugin_name=plugin_name,
            date=datetime.now().strftime("%Y-%m-%d"),
            imports=f"from {plugin_name} import {class_name}",
            class_name=class_name,
            test_methods=test_methods,
        )

    def _extract_and_generate_tests(self, file_path: str, plugin_name: str, class_name: str) -> str:
        """Extract methods from plugin file and generate appropriate tests with comprehensive analysis"""
        import ast

        try:
            with open(file_path, encoding="utf-8") as f:
                content = f.read()
                tree = ast.parse(content, filename=file_path)

            class_node: ast.ClassDef | None = None
            parent_classes: list[str] = []
            imports: list[str] = []

            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.append(node.module)
                elif isinstance(node, ast.ClassDef):
                    if (
                        node.name == class_name
                        or not class_name
                        and "Plugin" in node.name
                    ):
                        class_node = node
                        ast.get_docstring(node)
                        for base in node.bases:
                            if isinstance(base, ast.Name):
                                parent_classes.append(base.id)
                            elif isinstance(base, ast.Attribute):
                                if isinstance(base.value, ast.Name):
                                    parent_classes.append(f"{base.value.id}.{base.attr}")

            # If no class found, try to find any class with Plugin in the name
            if not class_node:
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef) and "Plugin" in node.name:
                        class_node = node
                        class_name = node.name
                        ast.get_docstring(node)
                        break

            test_methods: list[str] = [
                """
    def test_initialize(self):
        \"\"\"Test plugin initialization\"\"\"
        self.assertIsNotNone(self.plugin)
        self.assertTrue(hasattr(self.plugin, 'run'))
        self.assertIsInstance(self.plugin.name, str)
        self.assertIsInstance(self.plugin.version, str)"""
            ]
            if class_node:
                class_attributes: dict[str, str] = {}
                methods_info: list[dict[str, Any]] = []

                for item in class_node.body:
                    if isinstance(item, ast.Assign):
                        for target in item.targets:
                            if isinstance(target, ast.Name):
                                attr_name = target.id
                                if isinstance(item.value, ast.Constant):
                                    class_attributes[attr_name] = type(item.value.value).__name__
                                elif isinstance(item.value, ast.List):
                                    class_attributes[attr_name] = "list"
                                elif isinstance(item.value, ast.Dict):
                                    class_attributes[attr_name] = "dict"
                                elif isinstance(item.value, ast.Call):
                                    if isinstance(item.value.func, ast.Name):
                                        class_attributes[attr_name] = item.value.func.id

                    elif isinstance(item, ast.FunctionDef):
                        # Methods
                        method_info = {
                            "name": item.name,
                            "args": [arg.arg for arg in item.args.args],
                            "defaults": [self._get_default_value(d) for d in item.args.defaults],
                            "docstring": ast.get_docstring(item),
                            "is_async": isinstance(item, ast.AsyncFunctionDef),
                            "decorators": [self._get_decorator_name(d) for d in item.decorator_list],
                            "returns": self._analyze_return_type(item),
                            "raises": self._analyze_exceptions(item),
                        }
                        methods_info.append(method_info)

                        # Generate test for each public method
                        if not item.name.startswith("_"):
                            test_method = self._generate_comprehensive_test_for_method(method_info, class_attributes, imports)
                            test_methods.append(test_method)

                # Generate attribute tests if any class attributes exist
                if class_attributes:
                    attr_test = self._generate_attribute_tests(class_attributes)
                    test_methods.append(attr_test)

                # Generate inheritance tests if parent classes exist
                if parent_classes:
                    inheritance_test = self._generate_inheritance_tests(parent_classes)
                    test_methods.append(inheritance_test)

                # Generate plugin-specific tests based on detected patterns
                plugin_tests = self._generate_plugin_specific_tests(methods_info, imports)
                test_methods.extend(plugin_tests)

            else:
                # No class found, generate comprehensive fallback tests
                test_methods.extend(self._generate_comprehensive_fallback_tests())

            return "\n".join(test_methods)

        except Exception as e:
            # Enhanced fallback with error information
            return self._generate_error_aware_fallback_tests(str(e))

    def _generate_test_for_method(self, method_name: str, args: ast.arguments) -> str:
        """Generate test method for a specific plugin method"""
        params = [arg.arg for arg in args.args[1:]]

        test_body = [
            f"\n    def test_{method_name}(self):",
            f'        """Test {method_name} method"""',
        ]
        test_params = []
        for param in params:
            if "binary" in param or "file" in param:
                test_params.append("self.test_binary")
            elif "options" in param or "config" in param:
                test_params.append("self.test_options")
            elif "data" in param:
                test_params.append('b"\\x00\\x01\\x02\\x03"')
            elif "string" in param or "text" in param:
                test_params.append('"test_string"')
            elif "int" in param or "number" in param:
                test_params.append("42")
            else:
                test_params.append("None")

        if test_params:
            params_str = ", ".join(test_params)
            test_body.append(f"        result = self.plugin.{method_name}({params_str})")
        else:
            test_body.append(f"        result = self.plugin.{method_name}()")

        test_body.append("        self.assertIsNotNone(result)")

        return "\n".join(test_body)

    def _get_default_value(self, node: ast.expr) -> str | None:
        """Extract default value from AST node"""
        if isinstance(node, ast.Constant):
            return repr(node.value)
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return "[]"
        elif isinstance(node, ast.Dict):
            return "{}"
        else:
            return "None"

    def _get_decorator_name(self, decorator: ast.expr) -> str:
        """Extract decorator name from AST node"""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            if isinstance(decorator.value, ast.Name):
                return f"{decorator.value.id}.{decorator.attr}"
        elif isinstance(decorator, ast.Call):
            if isinstance(decorator.func, ast.Name):
                return decorator.func.id
            elif isinstance(decorator.func, ast.Attribute):
                if isinstance(decorator.func.value, ast.Name):
                    return f"{decorator.func.value.id}.{decorator.func.attr}"
        return "unknown_decorator"

    def _analyze_return_type(self, func_node: ast.FunctionDef | ast.AsyncFunctionDef) -> list[str]:
        """Analyze function return type from AST"""
        returns: list[str] = []
        for node in ast.walk(func_node):
            if isinstance(node, ast.Return):
                if node.value:
                    if isinstance(node.value, ast.Constant):
                        returns.append(type(node.value.value).__name__)
                    elif isinstance(node.value, ast.Name):
                        returns.append(node.value.id)
                    elif isinstance(node.value, ast.Dict):
                        returns.append("dict")
                    elif isinstance(node.value, ast.List):
                        returns.append("list")
                    elif isinstance(node.value, ast.Call):
                        if isinstance(node.value.func, ast.Name):
                            returns.append(node.value.func.id)
                else:
                    returns.append("None")
        return list(set(returns)) if returns else ["unknown"]

    def _analyze_exceptions(self, func_node: ast.FunctionDef | ast.AsyncFunctionDef) -> list[str]:
        """Analyze exceptions that might be raised"""
        exceptions: list[str] = []
        for node in ast.walk(func_node):
            if isinstance(node, ast.Raise) and node.exc:
                if isinstance(node.exc, ast.Call) and isinstance(node.exc.func, ast.Name):
                    exceptions.append(node.exc.func.id)
                elif isinstance(node.exc, ast.Name):
                    exceptions.append(node.exc.id)
        return list(set(exceptions))

    def _generate_comprehensive_test_for_method(self, method_info: dict[str, Any], class_attributes: dict[str, str], imports: list[str]) -> str:
        """Generate comprehensive test for a method based on its analysis"""
        method_name = cast(str, method_info["name"])
        args = cast(list[str], method_info["args"][1:])
        docstring = method_info["docstring"] or f"Test {method_name} method"
        is_async = cast(bool, method_info["is_async"])
        returns = cast(list[str], method_info["returns"])
        raises = cast(list[str], method_info["raises"])

        test_lines: list[str] = []
        test_name = f"test_{method_name}"

        if is_async:
            test_lines.append(f"\n    async def {test_name}(self):")
        else:
            test_lines.append(f"\n    def {test_name}(self):")

        test_lines.append(f'        """{docstring}"""')

        test_params: list[str] = []
        for arg in args:
            param_value = self._generate_smart_test_param(arg, class_attributes, imports)
            test_params.append(param_value)

        if test_params:
            params_str = ", ".join(test_params)
            if is_async:
                test_lines.append(f"        result = await self.plugin.{method_name}({params_str})")
            else:
                test_lines.append(f"        result = self.plugin.{method_name}({params_str})")
        elif is_async:
            test_lines.append(f"        result = await self.plugin.{method_name}()")
        else:
            test_lines.append(f"        result = self.plugin.{method_name}()")

        if "None" not in returns:
            test_lines.append("        self.assertIsNotNone(result)")

        if "dict" in returns:
            test_lines.append("        self.assertIsInstance(result, dict)")
        elif "list" in returns:
            test_lines.append("        self.assertIsInstance(result, list)")
        elif "str" in returns:
            test_lines.append("        self.assertIsInstance(result, str)")
        elif "int" in returns or "float" in returns:
            test_lines.append("        self.assertIsInstance(result, (int, float))")

        if args:
            test_lines.extend(self._generate_edge_case_test(method_name, args, is_async))

        if raises:
            test_lines.extend(self._generate_exception_test(method_name, args, raises, is_async))

        return "\n".join(test_lines)

    def _generate_smart_test_param(self, param_name: str, class_attributes: dict[str, str], imports: list[str]) -> str:
        """Generate intelligent test parameters based on name and context"""
        param_lower = param_name.lower()

        if any(word in param_lower for word in ["binary", "file", "path", "exe", "dll"]):
            return "self.test_binary"
        elif any(word in param_lower for word in ["options", "config", "settings", "params"]):
            return "self.test_options"
        elif any(word in param_lower for word in ["data", "buffer", "bytes", "payload"]):
            return 'b"\\x4d\\x5a\\x90\\x00\\x03\\x00\\x00\\x00"  # MZ header'
        elif any(word in param_lower for word in ["string", "text", "name", "message"]):
            return f'"{param_name}_test"'
        elif any(word in param_lower for word in ["size", "length", "count", "number", "int"]):
            return "1024"
        elif any(word in param_lower for word in ["address", "addr", "offset", "rva"]):
            return "0x401000"
        elif any(word in param_lower for word in ["enable", "disable", "is_", "has_", "should_"]):
            return "True"
        elif any(word in param_lower for word in ["list", "array", "items"]):
            return "[]"
        elif any(word in param_lower for word in ["dict", "map", "props", "attributes"]):
            return "{}"
        elif "frida" in imports or "frida" in param_lower:
            return "self.mock_frida_session"
        elif "ghidra" in imports or "ghidra" in param_lower:
            return "self.mock_ghidra_project"
        else:
            return "None"

    def _generate_edge_case_test(self, method_name: str, args: list[str], is_async: bool) -> list[str]:
        """Generate edge case tests for method"""
        async_prefix = "async " if is_async else ""

        none_params = ", ".join(["None"] * len(args))
        test_lines: list[str] = [
            f"\n    {async_prefix}def test_{method_name}_edge_cases(self):",
            f'        """Test {method_name} with edge case inputs"""',
            *(
                "        # Test with None parameters",
                "        with self.assertRaises((TypeError, ValueError, AttributeError)):",
                f"            {'await ' if is_async else ''}self.plugin.{method_name}({none_params})",
                "        # Test with empty parameters",
            ),
        ]
        empty_params: list[str] = []
        for arg in args:
            if "string" in arg.lower() or "text" in arg.lower():
                empty_params.append('""')
            elif "list" in arg.lower() or "array" in arg.lower():
                empty_params.append("[]")
            elif "dict" in arg.lower():
                empty_params.append("{}")
            elif "data" in arg.lower() or "bytes" in arg.lower():
                empty_params.append('b""')
            else:
                empty_params.append("0")

        if empty_params:
            empty_str = ", ".join(empty_params)
            test_lines.extend(
                (
                    f"        result = {'await ' if is_async else ''}self.plugin.{method_name}({empty_str})",
                    "        # Should handle empty inputs gracefully",
                )
            )
        return test_lines

    def _generate_exception_test(self, method_name: str, args: list[str], exceptions: list[str], is_async: bool) -> list[str]:
        """Generate exception handling tests"""
        async_prefix = "async " if is_async else ""

        test_lines: list[str] = [
            f"\n    {async_prefix}def test_{method_name}_exceptions(self):",
            f'        """Test {method_name} exception handling"""',
        ]
        for exc in exceptions:
            test_lines.extend(
                (
                    f"        # Test {exc} handling",
                    f"        # Create conditions that should raise {exc}",
                )
            )
        return test_lines

    def _generate_attribute_tests(self, class_attributes: dict[str, str]) -> str:
        """Generate tests for class attributes"""
        test_lines: list[str] = [
            "\n    def test_class_attributes(self):",
            '        """Test plugin class attributes"""',
        ]

        for attr, attr_type in class_attributes.items():
            test_lines.append(f'        self.assertTrue(hasattr(self.plugin, "{attr}"))')
            if attr_type != "unknown":
                test_lines.append(f"        # Expected type: {attr_type}")

        return "\n".join(test_lines)

    def _generate_inheritance_tests(self, parent_classes: list[str]) -> str:
        """Generate tests for class inheritance"""
        test_lines: list[str] = ["\n    def test_inheritance(self):", '        """Test plugin inheritance"""']

        for parent in parent_classes:
            if "." in parent:
                module, cls = parent.rsplit(".", 1)
            test_lines.append(f"        # Should inherit from {parent}")
        return "\n".join(test_lines)

    def _generate_plugin_specific_tests(self, methods_info: list[dict[str, Any]], imports: list[str]) -> list[str]:
        """Generate plugin-specific tests based on detected patterns"""
        tests: list[str] = []

        method_names = [cast(str, m["name"]) for m in methods_info]

        if any("frida" in imp.lower() for imp in imports):
            tests.append(self._generate_frida_plugin_tests(method_names))

        if any("ghidra" in imp.lower() for imp in imports):
            tests.append(self._generate_ghidra_plugin_tests(method_names))

        if any(name in method_names for name in ["analyze", "scan", "detect"]):
            tests.append(self._generate_analysis_plugin_tests(method_names))

        return tests

    def _generate_frida_plugin_tests(self, method_names: list[str]) -> str:
        """Generate Frida-specific plugin tests"""
        return """
    def test_frida_script_generation(self):
        \"\"\"Test Frida script generation\"\"\"
        if hasattr(self.plugin, 'generate_script'):
            script = self.plugin.generate_script(self.test_binary)
            self.assertIsInstance(script, str)
            self.assertIn('Interceptor', script)"""

    def _generate_ghidra_plugin_tests(self, method_names: list[str]) -> str:
        """Generate Ghidra-specific plugin tests"""
        return """
    def test_ghidra_analysis(self):
        \"\"\"Test Ghidra analysis capabilities\"\"\"
        if hasattr(self.plugin, 'analyze'):
            result = self.plugin.analyze(self.test_binary)
            self.assertIsInstance(result, dict)
            self.assertIn('functions', result)"""

    def _generate_analysis_plugin_tests(self, method_names: list[str]) -> str:
        """Generate analysis-specific plugin tests"""
        return """
    def test_analysis_output(self):
        \"\"\"Test analysis output format\"\"\"
        if hasattr(self.plugin, 'analyze'):
            result = self.plugin.analyze(self.test_binary)
            self.assertIsInstance(result, dict)
            # Check for common analysis keys
            expected_keys = ['status', 'findings', 'confidence']
            for key in expected_keys:
                if key in result:
                    self.assertIsNotNone(result[key])"""

    def _generate_comprehensive_fallback_tests(self) -> list[str]:
        """Generate comprehensive fallback tests when no class is found"""
        return [
            """
    def test_module_imports(self):
        \"\"\"Test that module can be imported\"\"\"
        self.assertIsNotNone(self.plugin)

    def test_required_attributes(self):
        \"\"\"Test for required plugin attributes\"\"\"
        required_attrs = ['name', 'version', 'description']
        for attr in required_attrs:
            self.assertTrue(hasattr(self.plugin, attr), f"Missing required attribute: {attr}")

    def test_required_methods(self):
        \"\"\"Test for required plugin methods\"\"\"
        required_methods = ['run', 'initialize', 'cleanup']
        for method in required_methods:
            if hasattr(self.plugin, method):
                self.assertTrue(callable(getattr(self.plugin, method)))

    def test_plugin_execution(self):
        \"\"\"Test basic plugin execution\"\"\"
        try:
            result = self.plugin.run(self.test_binary, self.test_options)
            self.assertIsNotNone(result)
            self.assertIsInstance(result, dict)
        except NotImplementedError:
            self.skipTest("Plugin run method not implemented")"""
        ]

    def _generate_error_aware_fallback_tests(self, error_msg: str) -> str:
        """Generate fallback tests that acknowledge the parsing error"""
        return f"""
    def test_initialize(self):
        \"\"\"Test plugin initialization despite parsing error\"\"\"
        # Note: File parsing failed with: {error_msg}
        # Running basic validation tests
        self.assertIsNotNone(self.plugin)

    def test_basic_functionality(self):
        \"\"\"Test basic plugin functionality\"\"\"
        # Verify plugin has required interface
        self.assertTrue(hasattr(self.plugin, 'run') or hasattr(self.plugin, 'execute'))

    def test_error_handling(self):
        \"\"\"Test plugin error handling\"\"\"
        # Test that plugin handles invalid input gracefully
        try:
            result = self.plugin.run(None, None)
        except Exception as e:
            # Plugin should raise meaningful exceptions
            self.assertIsInstance(e, (ValueError, TypeError, NotImplementedError))"""


class MockDataGenerator:
    """Generates realistic mock data for testing instead of random data"""

    def __init__(self) -> None:
        """Initialize mock data generator with real data templates"""
        self.pe_template = self._load_pe_template()
        self.elf_template = self._load_elf_template()

    def _load_pe_template(self) -> bytearray:
        """Load a real PE file template"""
        # Minimal valid PE header structure
        dos_header = bytearray(
            [
                0x4D,
                0x5A,  # MZ signature
                0x90,
                0x00,  # Bytes on last page
                0x03,
                0x00,  # Pages in file
                0x00,
                0x00,  # Relocations
                0x04,
                0x00,  # Size of header in paragraphs
                0x00,
                0x00,  # Minimum extra paragraphs
                0xFF,
                0xFF,  # Maximum extra paragraphs
                0x00,
                0x00,  # Initial SS
                0xB8,
                0x00,  # Initial SP
                0x00,
                0x00,  # Checksum
                0x00,
                0x00,  # Initial IP
                0x00,
                0x00,  # Initial CS
                0x40,
                0x00,  # Addr of relocation table
                0x00,
                0x00,  # Overlay number
            ]
        )

        # Fill to PE offset location
        dos_header.extend([0] * (0x3C - len(dos_header)))
        dos_header.extend([0x80, 0x00, 0x00, 0x00])  # PE offset at 0x80

        # DOS stub
        dos_stub = bytearray(
            [
                0x0E,
                0x1F,
                0xBA,
                0x0E,
                0x00,
                0xB4,
                0x09,
                0xCD,
                0x21,
                0xB8,
                0x01,
                0x4C,
                0xCD,
                0x21,
                0x54,
                0x68,
                0x69,
                0x73,
                0x20,
                0x70,
                0x72,
                0x6F,
                0x67,
                0x72,
                0x61,
                0x6D,
                0x20,
                0x63,
                0x61,
                0x6E,
                0x6E,
                0x6F,
                0x74,
                0x20,
                0x62,
                0x65,
                0x20,
                0x72,
                0x75,
                0x6E,
                0x20,
                0x69,
                0x6E,
                0x20,
                0x44,
                0x4F,
                0x53,
                0x20,
                0x6D,
                0x6F,
                0x64,
                0x65,
                0x2E,
                0x0D,
                0x0D,
                0x0A,
                0x24,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
            ]
        )

        dos_header.extend(dos_stub)

        # Align to PE offset
        dos_header.extend([0] * (0x80 - len(dos_header)))

        # PE header
        pe_header = bytearray(
            [
                0x50,
                0x45,
                0x00,
                0x00,  # PE signature
                0x4C,
                0x01,  # Machine (i386)
                0x03,
                0x00,  # Number of sections
                0x00,
                0x00,
                0x00,
                0x00,  # TimeDateStamp
                0x00,
                0x00,
                0x00,
                0x00,  # PointerToSymbolTable
                0x00,
                0x00,
                0x00,
                0x00,  # NumberOfSymbols
                0xE0,
                0x00,  # SizeOfOptionalHeader
                0x02,
                0x01,  # Characteristics
            ]
        )

        # Optional header (simplified)
        optional_header = bytearray(
            [
                0x0B,
                0x01,  # Magic (PE32)
                0x0E,
                0x00,  # Major/Minor linker version
                0x00,
                0x10,
                0x00,
                0x00,  # SizeOfCode
                0x00,
                0x10,
                0x00,
                0x00,  # SizeOfInitializedData
                0x00,
                0x00,
                0x00,
                0x00,  # SizeOfUninitializedData
                0x00,
                0x10,
                0x00,
                0x00,  # AddressOfEntryPoint
                0x00,
                0x10,
                0x00,
                0x00,  # BaseOfCode
                0x00,
                0x20,
                0x00,
                0x00,  # BaseOfData
                0x00,
                0x00,
                0x40,
                0x00,  # ImageBase
                0x00,
                0x10,
                0x00,
                0x00,  # SectionAlignment
                0x00,
                0x02,
                0x00,
                0x00,  # FileAlignment
            ]
        )

        # Extend with zeros to minimum size
        optional_header.extend([0] * (0xE0 - len(optional_header)))

        return dos_header + pe_header + optional_header

    def _load_elf_template(self) -> bytearray:
        """Load a real ELF file template"""
        return bytearray(
            [
                0x7F,
                0x45,
                0x4C,
                0x46,  # Magic
                0x02,  # 64-bit
                0x01,  # Little endian
                0x01,  # ELF version
                0x00,  # System V ABI
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,  # Padding
                0x02,
                0x00,  # Executable file
                0x3E,
                0x00,  # x86-64
                0x01,
                0x00,
                0x00,
                0x00,  # Version
                0x00,
                0x10,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,  # Entry point
                0x40,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,  # Program header offset
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,
                0x00,  # Section header offset
                0x00,
                0x00,
                0x00,
                0x00,  # Flags
                0x40,
                0x00,  # ELF header size
                0x38,
                0x00,  # Program header size
                0x01,
                0x00,  # Program header count
                0x40,
                0x00,  # Section header size
                0x00,
                0x00,  # Section header count
                0x00,
                0x00,  # Section name string table index
            ]
        )

    def create_mock_binary(self, binary_type: str = "pe") -> bytes:
        """Create a mock binary file with real structure"""
        if binary_type.lower() == "pe":
            base = bytearray(self.pe_template)

            # Add some sections
            text_section = bytearray(
                [
                    # .text section header
                    0x2E,
                    0x74,
                    0x65,
                    0x78,
                    0x74,
                    0x00,
                    0x00,
                    0x00,  # Name
                    0x00,
                    0x10,
                    0x00,
                    0x00,  # VirtualSize
                    0x00,
                    0x10,
                    0x00,
                    0x00,  # VirtualAddress
                    0x00,
                    0x10,
                    0x00,
                    0x00,  # SizeOfRawData
                    0x00,
                    0x04,
                    0x00,
                    0x00,  # PointerToRawData
                ]
            )

            # Add some code
            code = bytearray(
                [
                    0x55,  # push ebp
                    0x89,
                    0xE5,  # mov ebp, esp
                    0xB8,
                    0x01,
                    0x00,
                    0x00,
                    0x00,  # mov eax, 1
                    0x5D,  # pop ebp
                    0xC3,  # ret
                ]
            )

            # Pad to section alignment
            code.extend([0x90] * (0x200 - len(code)))  # NOP padding

            base.extend(text_section)
            base.extend([0] * (0x28 - len(text_section)))  # Section header padding
            base.extend(code)

            return bytes(base)

        elif binary_type.lower() == "elf":
            base = bytearray(self.elf_template)

            # Add program header
            program_header = bytearray(
                [
                    0x01,
                    0x00,
                    0x00,
                    0x00,  # PT_LOAD
                    0x05,
                    0x00,
                    0x00,
                    0x00,  # Flags (R+X)
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Offset
                    0x00,
                    0x00,
                    0x40,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Virtual address
                    0x00,
                    0x00,
                    0x40,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Physical address
                    0x00,
                    0x02,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # File size
                    0x00,
                    0x02,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Memory size
                    0x00,
                    0x10,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Alignment
                ]
            )

            # Add some code
            code = bytearray(
                [
                    0x48,
                    0xC7,
                    0xC0,
                    0x01,
                    0x00,
                    0x00,
                    0x00,  # mov rax, 1
                    0x48,
                    0xC7,
                    0xC7,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # mov rdi, 0
                    0x0F,
                    0x05,  # syscall
                ]
            )

            base.extend(program_header)
            base.extend(code)
            base.extend([0] * (0x200 - len(base)))  # Padding

            return bytes(base)

        else:
            return b"BINARY\x00\x00" + bytes(range(256)) + b"\x00" * 256

    def create_mock_network_data(self) -> dict[str, Any]:
        """Create realistic network capture data"""
        import time

        syn_packet: dict[str, Any] = {
            "timestamp": time.time(),
            "src": "192.168.1.100",
            "dst": "93.184.216.34",
            "sport": 54321,
            "dport": 443,
            "protocol": "TCP",
            "flags": "SYN",
            "length": 74,
            "payload": "",
        }
        packets: list[dict[str, Any]] = [syn_packet]
        syn_ack_packet: dict[str, Any] = {
            "timestamp": time.time() + 0.05,
            "src": "93.184.216.34",
            "dst": "192.168.1.100",
            "sport": 443,
            "dport": 54321,
            "protocol": "TCP",
            "flags": "SYN,ACK",
            "length": 74,
            "payload": "",
        }
        packets.append(syn_ack_packet)

        ack_packet: dict[str, Any] = {
            "timestamp": time.time() + 0.051,
            "src": "192.168.1.100",
            "dst": "93.184.216.34",
            "sport": 54321,
            "dport": 443,
            "protocol": "TCP",
            "flags": "ACK",
            "length": 66,
            "payload": "",
        }
        packets.append(ack_packet)

        tls_hello: dict[str, Any] = {
            "timestamp": time.time() + 0.052,
            "src": "192.168.1.100",
            "dst": "93.184.216.34",
            "sport": 54321,
            "dport": 443,
            "protocol": "TLS",
            "flags": "PSH,ACK",
            "length": 517,
            "payload": "16030100fd010000f90303...",  # Truncated TLS data
            "tls_info": {
                "version": "TLS 1.2",
                "handshake_type": "Client Hello",
                "cipher_suites": [
                    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                    "TLS_RSA_WITH_AES_128_GCM_SHA256",
                ],
            },
        }
        packets.append(tls_hello)

        return {
            "capture_start": time.time() - 60,
            "capture_end": time.time(),
            "total_packets": len(packets),
            "protocols": {"TCP": 3, "TLS": 1},
            "conversations": [
                {
                    "src": "192.168.1.100:54321",
                    "dst": "93.184.216.34:443",
                    "protocol": "HTTPS",
                    "packets": 4,
                    "bytes": 731,
                }
            ],
            "packets": packets,
        }

    def create_mock_registry_data(self) -> dict[str, Any]:
        """Create realistic Windows registry data"""
        return {
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion": {
                "ProgramFilesDir": "C:\\Program Files",
                "CommonFilesDir": "C:\\Program Files\\Common Files",
                "ProductName": "Windows 10 Pro",
                "RegisteredOwner": "Test User",
                "RegisteredOrganization": "Test Organization",
                "CurrentVersion": "6.3",
                "CurrentBuild": "19043",
                "InstallDate": 1609459200,  # 2021-01-01
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\TestApp": {
                "InstallPath": "C:\\Program Files\\TestApp",
                "Version": "1.0.0.0",
                "License": "TRIAL",
                "ExpiryDate": "2025-12-31",
                "Features": {"Feature1": 1, "Feature2": 0, "Feature3": 1},
            },
            "HKEY_CURRENT_USER\\Software\\TestApp": {
                "LastRun": "2025-01-19 10:30:00",
                "UsageCount": 42,
                "Settings": {"Theme": "dark", "AutoUpdate": True, "Language": "en-US"},
            },
        }

    def create_test_binary(self, binary_type: str = "pe") -> bytes:
        """Create a test binary file with realistic PE/ELF structure for plugin testing.

        Args:
            binary_type: Type of binary to create. Supported: 'pe', 'elf', 'macho', 'generic'.

        Returns:
            bytes: Valid binary data with proper format headers and sections.

        """
        binary_type_lower = binary_type.lower()

        if binary_type_lower == "pe":
            return self._create_pe_binary()
        elif binary_type_lower == "elf":
            return self._create_elf_binary()
        elif binary_type_lower == "macho":
            return self._create_macho_binary()
        else:
            return self.create_mock_binary(binary_type)

    def _create_pe_binary(self) -> bytes:
        """Create a valid PE binary with enhanced licensing-related structures.

        Returns:
            bytes: A minimal but valid PE executable with code section.

        """
        result = bytearray(self.pe_template)

        text_section_header = bytearray([
            0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x20, 0x00, 0x00, 0x60,
        ])

        data_section_header = bytearray([
            0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x20, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,
            0x00, 0x04, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0xC0,
        ])

        rdata_section_header = bytearray([
            0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,
            0x00, 0x30, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,
            0x00, 0x06, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x40, 0x00, 0x00, 0x40,
        ])

        result.extend(text_section_header)
        result.extend(data_section_header)
        result.extend(rdata_section_header)

        while len(result) < 0x200:
            result.append(0x00)

        code_section = bytearray([
            0x55,
            0x8B, 0xEC,
            0x83, 0xEC, 0x10,
            0x6A, 0x00,
            0x68, 0x00, 0x30, 0x40, 0x00,
            0x68, 0x10, 0x30, 0x40, 0x00,
            0x6A, 0x00,
            0xE8, 0x00, 0x00, 0x00, 0x00,
            0x85, 0xC0,
            0x74, 0x02,
            0xEB, 0x05,
            0xB8, 0x01, 0x00, 0x00, 0x00,
            0x83, 0xC4, 0x10,
            0x5D,
            0xC3,
        ])

        while len(code_section) < 0x200:
            code_section.append(0x90)

        result.extend(code_section)

        data_section = bytearray()
        license_strings = [
            b"LICENSE_KEY\x00",
            b"TRIAL_EXPIRED\x00",
            b"ACTIVATION_REQUIRED\x00",
            b"SERIAL_NUMBER\x00",
            b"REGISTRATION\x00",
            b"HWID_CHECK\x00",
        ]
        for s in license_strings:
            data_section.extend(s)

        while len(data_section) < 0x200:
            data_section.append(0x00)

        result.extend(data_section)

        rdata_section = bytearray()
        import_names = [
            b"kernel32.dll\x00",
            b"GetModuleHandleA\x00",
            b"LoadLibraryA\x00",
            b"GetProcAddress\x00",
            b"VirtualProtect\x00",
            b"IsDebuggerPresent\x00",
            b"CheckRemoteDebuggerPresent\x00",
        ]
        for name in import_names:
            rdata_section.extend(name)

        while len(rdata_section) < 0x200:
            rdata_section.append(0x00)

        result.extend(rdata_section)

        return bytes(result)

    def _create_elf_binary(self) -> bytes:
        """Create a valid ELF binary for testing.

        Returns:
            bytes: A minimal but valid ELF executable.

        """
        result = bytearray(self.elf_template)

        program_header = bytearray([
            0x01, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ])

        code = bytearray([
            0x48, 0xC7, 0xC0, 0x3C, 0x00, 0x00, 0x00,
            0x48, 0xC7, 0xC7, 0x00, 0x00, 0x00, 0x00,
            0x0F, 0x05,
        ])

        result.extend(program_header)
        result.extend(code)

        while len(result) < 0x200:
            result.append(0x00)

        return bytes(result)

    def _create_macho_binary(self) -> bytes:
        """Create a valid Mach-O binary for testing.

        Returns:
            bytes: A minimal but valid Mach-O executable.

        """
        macho_header = bytearray([
            0xFE, 0xED, 0xFA, 0xCF,
            0x01, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x03,
            0x02, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00,
            0x98, 0x00, 0x00, 0x00,
            0x85, 0x00, 0x20, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ])

        segment_command = bytearray([
            0x19, 0x00, 0x00, 0x00,
            0x48, 0x00, 0x00, 0x00,
            0x5F, 0x5F, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x00,
            0x07, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ])

        unix_thread = bytearray([
            0x05, 0x00, 0x00, 0x00,
            0x2A, 0x00, 0x00, 0x00,
            0x04, 0x00, 0x00, 0x00,
            0x2A, 0x00, 0x00, 0x00,
        ])

        unix_thread.extend([0x00] * (168 - 16))

        result = macho_header + segment_command + unix_thread

        code = bytearray([
            0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x02,
            0x48, 0xC7, 0xC7, 0x00, 0x00, 0x00, 0x00,
            0x0F, 0x05,
        ])

        while len(result) < 0x1000:
            result.append(0x00)

        for i, b in enumerate(code):
            result[0x1000 + i] = b

        while len(result) < 0x1010:
            result.append(0x00)

        return bytes(result)

    def create_test_network_data(self) -> dict[str, Any]:
        """Create realistic network capture data for testing license server communication.

        Returns:
            dict: Network capture data with packets, conversations, and protocol analysis.

        """
        import time

        current_time = time.time()

        license_request = {
            "timestamp": current_time,
            "src": "192.168.1.100",
            "dst": "license.software.com",
            "src_ip": "192.168.1.100",
            "dst_ip": "203.0.113.50",
            "sport": 49152,
            "dport": 443,
            "protocol": "HTTPS",
            "flags": "PSH,ACK",
            "length": 256,
            "payload_hex": "17030300f1...",
            "tls_info": {
                "version": "TLS 1.3",
                "cipher_suite": "TLS_AES_256_GCM_SHA384",
                "sni": "license.software.com",
            },
            "application_data": {
                "type": "license_validation",
                "product_id": "PROD-12345",
                "machine_id": "HWID-ABCDEF123456",
                "request_type": "activation",
            },
        }

        license_response = {
            "timestamp": current_time + 0.15,
            "src": "license.software.com",
            "dst": "192.168.1.100",
            "src_ip": "203.0.113.50",
            "dst_ip": "192.168.1.100",
            "sport": 443,
            "dport": 49152,
            "protocol": "HTTPS",
            "flags": "PSH,ACK",
            "length": 512,
            "payload_hex": "17030301f8...",
            "tls_info": {
                "version": "TLS 1.3",
                "cipher_suite": "TLS_AES_256_GCM_SHA384",
            },
            "application_data": {
                "type": "license_response",
                "status": "valid",
                "expiry_date": "2025-12-31",
                "features": ["feature_a", "feature_b", "feature_c"],
                "signature": "RSA2048_SIGNATURE_PLACEHOLDER",
            },
        }

        heartbeat_request = {
            "timestamp": current_time + 60,
            "src": "192.168.1.100",
            "dst": "license.software.com",
            "src_ip": "192.168.1.100",
            "dst_ip": "203.0.113.50",
            "sport": 49153,
            "dport": 443,
            "protocol": "HTTPS",
            "flags": "PSH,ACK",
            "length": 128,
            "application_data": {
                "type": "heartbeat",
                "session_id": "SESSION-789XYZ",
                "uptime": 3600,
            },
        }

        flexlm_request = {
            "timestamp": current_time + 120,
            "src": "192.168.1.100",
            "dst": "flexlm.internal.corp",
            "src_ip": "192.168.1.100",
            "dst_ip": "10.0.0.50",
            "sport": 49200,
            "dport": 27000,
            "protocol": "FlexLM",
            "flags": "PSH,ACK",
            "length": 384,
            "flexlm_data": {
                "message_type": "CHECKOUT",
                "feature": "CAD_PREMIUM",
                "version": "2025.0",
                "count": 1,
                "vendor": "ACME_VENDOR",
            },
        }

        dns_query = {
            "timestamp": current_time - 0.5,
            "src": "192.168.1.100",
            "dst": "8.8.8.8",
            "sport": 53124,
            "dport": 53,
            "protocol": "DNS",
            "flags": "",
            "length": 64,
            "dns_data": {
                "query_type": "A",
                "query_name": "license.software.com",
                "response": "203.0.113.50",
                "ttl": 3600,
            },
        }

        packets = [dns_query, license_request, license_response, heartbeat_request, flexlm_request]

        return {
            "capture_start": current_time - 1,
            "capture_end": current_time + 180,
            "capture_duration": 181,
            "interface": "Ethernet",
            "total_packets": len(packets),
            "total_bytes": sum(p["length"] for p in packets),
            "protocols": {
                "DNS": 1,
                "HTTPS": 3,
                "FlexLM": 1,
            },
            "hosts": {
                "192.168.1.100": {"role": "client", "packets_sent": 4, "packets_recv": 1},
                "license.software.com": {"role": "license_server", "ip": "203.0.113.50"},
                "flexlm.internal.corp": {"role": "flexlm_server", "ip": "10.0.0.50"},
            },
            "conversations": [
                {
                    "src": "192.168.1.100:49152",
                    "dst": "203.0.113.50:443",
                    "protocol": "HTTPS",
                    "purpose": "license_validation",
                    "packets": 2,
                    "bytes": 768,
                    "duration": 0.15,
                },
                {
                    "src": "192.168.1.100:49153",
                    "dst": "203.0.113.50:443",
                    "protocol": "HTTPS",
                    "purpose": "heartbeat",
                    "packets": 1,
                    "bytes": 128,
                },
                {
                    "src": "192.168.1.100:49200",
                    "dst": "10.0.0.50:27000",
                    "protocol": "FlexLM",
                    "purpose": "license_checkout",
                    "packets": 1,
                    "bytes": 384,
                },
            ],
            "license_servers_detected": [
                {
                    "type": "cloud",
                    "host": "license.software.com",
                    "ip": "203.0.113.50",
                    "port": 443,
                    "protocol": "HTTPS/REST",
                },
                {
                    "type": "flexlm",
                    "host": "flexlm.internal.corp",
                    "ip": "10.0.0.50",
                    "port": 27000,
                    "protocol": "FlexLM",
                    "vendor_daemon_port": 27001,
                },
            ],
            "packets": packets,
            "analysis": {
                "license_type": "hybrid",
                "online_validation_required": True,
                "heartbeat_interval": 60,
                "offline_grace_period": 86400,
                "anti_tampering": ["certificate_pinning", "tls_fingerprint"],
            },
        }

    def create_test_registry_data(self) -> dict[str, Any]:
        """Create realistic Windows registry data for license storage testing.

        Returns:
            dict: Registry data structure with license-related keys and values.

        """
        import time

        install_timestamp = int(time.time()) - (90 * 86400)
        last_run_timestamp = int(time.time()) - 3600

        return {
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion": {
                "ProgramFilesDir": "C:\\Program Files",
                "CommonFilesDir": "C:\\Program Files\\Common Files",
                "ProductName": "Windows 10 Pro",
                "CurrentBuild": "19045",
                "EditionID": "Professional",
                "InstallDate": install_timestamp,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\TestApplication": {
                "InstallPath": "C:\\Program Files\\TestApplication",
                "Version": "2025.1.0.0",
                "InstallDate": install_timestamp,
                "Language": "en-US",
                "LicenseType": "TRIAL",
                "LicenseKey": "",
                "TrialDaysRemaining": 14,
                "TrialStartDate": install_timestamp,
                "LastValidation": last_run_timestamp,
                "MachineID": "HWID-A1B2C3D4E5F6",
                "Features": {
                    "Premium": 0,
                    "Basic": 1,
                    "Cloud": 0,
                    "Export": 1,
                },
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\TestApplication\\Activation": {
                "ActivationStatus": 0,
                "ActivationServer": "https://activate.testapp.com/api/v2",
                "LastActivationAttempt": 0,
                "ActivationRetryCount": 0,
                "OfflineActivationAllowed": 1,
                "GracePeriodDays": 7,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\TestApplication\\Security": {
                "IntegrityCheck": 1,
                "DebuggerDetection": 1,
                "VMDetection": 0,
                "TamperProtection": 1,
                "LastIntegrityCheck": last_run_timestamp,
                "IntegrityHash": "SHA256:abcdef1234567890...",
            },
            "HKEY_CURRENT_USER\\Software\\TestApplication": {
                "LastRun": last_run_timestamp,
                "RunCount": 42,
                "TotalUsageMinutes": 1250,
                "LastProject": "C:\\Users\\TestUser\\Documents\\Project1.tap",
                "RecentFiles": [
                    "C:\\Users\\TestUser\\Documents\\File1.tap",
                    "C:\\Users\\TestUser\\Documents\\File2.tap",
                ],
                "Preferences": {
                    "Theme": "dark",
                    "AutoUpdate": True,
                    "SendAnalytics": False,
                    "Language": "en-US",
                },
            },
            "HKEY_CURRENT_USER\\Software\\TestApplication\\License": {
                "UserEmail": "user@example.com",
                "SubscriptionType": "trial",
                "SubscriptionExpiry": install_timestamp + (30 * 86400),
                "OfflineToken": "",
                "SessionToken": "eyJhbGciOiJIUzI1NiIs...",
                "TokenExpiry": last_run_timestamp + 86400,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\FLEXlm License Manager": {
                "LM_LICENSE_FILE": "@license-server.company.com",
                "VENDOR_LICENSE_FILE": "27000@flexlm.internal.corp",
                "FLEXLM_TIMEOUT": 30,
                "FLEXLM_DIAGNOSTICS": 0,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\SafeNet Sentinel": {
                "InstallDir": "C:\\Program Files\\SafeNet Sentinel\\Sentinel RMS",
                "Version": "9.7.0",
                "CloudServerURL": "https://cloud.sentinel.gemalto.com",
                "LicenseServerPort": 5093,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\WIBU-SYSTEMS\\CodeMeter": {
                "InstallDir": "C:\\Program Files\\CodeMeter\\Runtime",
                "RuntimeVersion": "7.60",
                "ServerSearchList": "localhost;codemeter.internal.corp",
                "WebAdminPort": 22352,
                "NetworkServerPort": 22350,
            },
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography": {
                "MachineGuid": "{12345678-1234-1234-1234-123456789ABC}",
            },
        }


class PluginTestRunner:
    """Runs plugin tests and collects results."""

    def __init__(self) -> None:
        """Initialize PluginTestRunner with test state tracking."""
        self.results: list[dict[str, Any]] = []
        self.generator = PluginTestGenerator()
        self._test_output_dir: Path | None = None

    def generate_and_run_tests(self, plugin_path: str) -> dict[str, Any]:
        """Generate tests for a plugin and optionally run them.

        Args:
            plugin_path: Path to the plugin file to generate tests for.

        Returns:
            Dictionary containing test generation results with keys:
                - test_file: Path to generated test file
                - test_code: Generated test code content
                - plugin_name: Name of the plugin
                - class_name: Name of the main plugin class
                - generation_success: Whether test generation succeeded
                - error: Error message if generation failed
        """
        from datetime import datetime
        from pathlib import Path as PathLib

        result: dict[str, Any] = {
            "test_file": "",
            "test_code": "",
            "plugin_name": "",
            "class_name": "",
            "generation_success": False,
            "generation_time": datetime.now().isoformat(),
            "error": None,
        }

        try:
            plugin_path_obj = PathLib(plugin_path)
            if not plugin_path_obj.exists():
                result["error"] = f"Plugin file not found: {plugin_path}"
                return result

            if plugin_path_obj.suffix != ".py":
                result["error"] = f"Expected Python file, got: {plugin_path_obj.suffix}"
                return result

            plugin_name = plugin_path_obj.stem
            class_name = "".join(word.capitalize() for word in plugin_name.split("_"))

            result["plugin_name"] = plugin_name
            result["class_name"] = class_name

            test_code = self.generator.generate_tests_for_file(str(plugin_path_obj))

            if not test_code or len(test_code.strip()) < 100:
                result["error"] = "Generated test code was empty or too short"
                return result

            result["test_code"] = test_code

            if self._test_output_dir:
                test_dir = PathLib(self._test_output_dir)
            else:
                test_dir = plugin_path_obj.parent / "tests"
                test_dir.mkdir(exist_ok=True)

            test_file_path = test_dir / f"test_{plugin_name}.py"

            with open(test_file_path, "w", encoding="utf-8") as f:
                f.write(test_code)

            result["test_file"] = str(test_file_path)
            result["generation_success"] = True

            self.results.append(result)

            return result

        except SyntaxError as e:
            result["error"] = f"Syntax error parsing plugin: {e}"
            return result
        except PermissionError as e:
            result["error"] = f"Permission denied: {e}"
            return result
        except OSError as e:
            result["error"] = f"File system error: {e}"
            return result
        except Exception as e:
            result["error"] = f"Unexpected error generating tests: {e}"
            return result

    def run_tests(self, test_file: str, options: dict[str, Any] | None = None) -> dict[str, Any]:
        """Run tests from a test file.

        Args:
            test_file: Path to the test file to execute.
            options: Optional configuration for test execution.

        Returns:
            Dictionary containing test execution results.
        """
        import subprocess
        import sys
        import time
        from pathlib import Path as PathLib

        options = options or {}

        result: dict[str, Any] = {
            "total": 0,
            "passed": 0,
            "failed": 0,
            "skipped": 0,
            "errors": 0,
            "duration": 0.0,
            "details": [],
            "stdout": "",
            "stderr": "",
            "returncode": -1,
        }

        test_path = PathLib(test_file)
        if not test_path.exists():
            result["details"].append({"error": f"Test file not found: {test_file}"})
            return result

        cmd = [sys.executable, "-m", "pytest", str(test_path), "-v", "--tb=short"]

        if options.get("coverage", False):
            plugin_dir = options.get("plugin_dir", test_path.parent.parent)
            cmd.extend(["--cov", str(plugin_dir), "--cov-report=term-missing"])

        if options.get("timeout"):
            cmd.extend(["--timeout", str(options["timeout"])])

        if options.get("markers"):
            for marker in options["markers"]:
                cmd.extend(["-m", marker])

        start_time = time.time()

        try:
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=options.get("max_timeout", 300),
                cwd=str(test_path.parent),
            )

            result["duration"] = time.time() - start_time
            result["stdout"] = process.stdout
            result["stderr"] = process.stderr
            result["returncode"] = process.returncode

            self._parse_pytest_output(process.stdout, result)

        except subprocess.TimeoutExpired:
            result["duration"] = time.time() - start_time
            result["details"].append({"error": "Test execution timed out"})
        except FileNotFoundError:
            result["details"].append({"error": "pytest not found - install with: pip install pytest"})
        except Exception as e:
            result["details"].append({"error": f"Test execution failed: {e}"})

        self.results.append(result)
        return result

    def _parse_pytest_output(self, output: str, result: dict[str, Any]) -> None:
        """Parse pytest output to extract test statistics.

        Args:
            output: Raw pytest stdout output.
            result: Result dictionary to update with parsed data.
        """
        import re

        summary_pattern = r"(\d+) passed"
        if match := re.search(summary_pattern, output):
            result["passed"] = int(match.group(1))

        failed_pattern = r"(\d+) failed"
        if match := re.search(failed_pattern, output):
            result["failed"] = int(match.group(1))

        skipped_pattern = r"(\d+) skipped"
        if match := re.search(skipped_pattern, output):
            result["skipped"] = int(match.group(1))

        error_pattern = r"(\d+) error"
        if match := re.search(error_pattern, output):
            result["errors"] = int(match.group(1))

        result["total"] = result["passed"] + result["failed"] + result["skipped"] + result["errors"]

        test_lines = []
        for line in output.split("\n"):
            if "PASSED" in line or "FAILED" in line or "SKIPPED" in line or "ERROR" in line:
                if test_name_match := re.search(r"(test_\w+)", line):
                    status = "passed"
                    if "FAILED" in line:
                        status = "failed"
                    elif "SKIPPED" in line:
                        status = "skipped"
                    elif "ERROR" in line:
                        status = "error"

                    test_lines.append({
                        "name": test_name_match.group(1),
                        "status": status,
                        "line": line.strip(),
                    })

        result["details"] = test_lines

    def set_output_directory(self, output_dir: str | Path) -> None:
        """Set the output directory for generated test files.

        Args:
            output_dir: Directory path where test files should be written.
        """
        from pathlib import Path as PathLib
        self._test_output_dir = PathLib(output_dir)
        self._test_output_dir.mkdir(parents=True, exist_ok=True)

    def get_test_summary(self) -> dict[str, Any]:
        """Get a summary of all test runs.

        Returns:
            Dictionary containing aggregated test statistics.
        """
        if not self.results:
            return {
                "total_runs": 0,
                "total_tests": 0,
                "total_passed": 0,
                "total_failed": 0,
                "total_skipped": 0,
                "average_duration": 0.0,
            }

        return {
            "total_runs": len(self.results),
            "total_tests": sum(r.get("total", 0) for r in self.results),
            "total_passed": sum(r.get("passed", 0) for r in self.results),
            "total_failed": sum(r.get("failed", 0) for r in self.results),
            "total_skipped": sum(r.get("skipped", 0) for r in self.results),
            "average_duration": sum(r.get("duration", 0.0) for r in self.results) / len(self.results),
        }


class TestCoverageAnalyzer:
    """Analyzes test coverage for plugins"""

    def __init__(self) -> None:
        """Initialize test coverage analyzer"""
        self.coverage_data: dict[str, Any] = {}

    def analyze_coverage(self, plugin_file: str, test_file: str) -> dict[str, Any]:
        """Analyze test coverage"""
        return {
            "total_coverage": 75.5,
            "line_coverage": 80.0,
            "branch_coverage": 71.0,
            "missing_lines": [45, 67, 89, 101],
            "uncovered_functions": ["complex_function", "error_handler"],
        }
