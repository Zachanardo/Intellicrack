digraph "classes_Intellicrack" {
rankdir=BT
charset="utf-8"
"intellicrack.ai.ai_tools.AIAssistant" [color="black", fontcolor="black", label=<{AIAssistant|llm_manager : NoneType<br ALIGN="LEFT"/>|analyze_code(code: str, language: str): Dict[str, Any]<br ALIGN="LEFT"/>ask_question(question: str): str<br ALIGN="LEFT"/>get_suggestions(context: str): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.ai_assistant_tab.AIAssistantTab" [color="black", fontcolor="black", label=<{AIAssistantTab|ai_chat_widget<br ALIGN="LEFT"/>ai_subtabs<br ALIGN="LEFT"/>analysis_binary_edit<br ALIGN="LEFT"/>analysis_completed<br ALIGN="LEFT"/>analysis_depth_combo<br ALIGN="LEFT"/>analysis_focus_combo<br ALIGN="LEFT"/>analysis_history : list<br ALIGN="LEFT"/>analysis_results<br ALIGN="LEFT"/>analysis_started<br ALIGN="LEFT"/>api_key_edit<br ALIGN="LEFT"/>chat_history<br ALIGN="LEFT"/>chat_input<br ALIGN="LEFT"/>current_model : NoneType, str<br ALIGN="LEFT"/>data_source_combo<br ALIGN="LEFT"/>dataset_path_edit<br ALIGN="LEFT"/>epochs_spin<br ALIGN="LEFT"/>generated_scripts_widget<br ALIGN="LEFT"/>include_comments_cb<br ALIGN="LEFT"/>include_disasm_cb<br ALIGN="LEFT"/>include_error_handling_cb<br ALIGN="LEFT"/>include_exports_cb<br ALIGN="LEFT"/>include_imports_cb<br ALIGN="LEFT"/>include_logging_cb<br ALIGN="LEFT"/>include_strings_cb<br ALIGN="LEFT"/>learning_rate_edit<br ALIGN="LEFT"/>max_tokens_spin<br ALIGN="LEFT"/>model_combo<br ALIGN="LEFT"/>model_loaded<br ALIGN="LEFT"/>model_progress<br ALIGN="LEFT"/>model_status_label<br ALIGN="LEFT"/>optimize_code_cb<br ALIGN="LEFT"/>performance_table<br ALIGN="LEFT"/>performance_widget<br ALIGN="LEFT"/>provider_combo<br ALIGN="LEFT"/>requirements_edit<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>script_content<br ALIGN="LEFT"/>script_generated<br ALIGN="LEFT"/>script_target_edit<br ALIGN="LEFT"/>script_type_combo<br ALIGN="LEFT"/>scripts_list<br ALIGN="LEFT"/>temperature_label<br ALIGN="LEFT"/>temperature_slider<br ALIGN="LEFT"/>template_combo<br ALIGN="LEFT"/>training_progress<br ALIGN="LEFT"/>training_status_label<br ALIGN="LEFT"/>training_thread : NoneType<br ALIGN="LEFT"/>training_type_combo<br ALIGN="LEFT"/>|browse_analysis_binary()<br ALIGN="LEFT"/>browse_training_dataset()<br ALIGN="LEFT"/>create_ai_controls_panel()<br ALIGN="LEFT"/>create_analysis_tab()<br ALIGN="LEFT"/>create_model_selection_tab()<br ALIGN="LEFT"/>create_results_panel()<br ALIGN="LEFT"/>create_script_generation_tab()<br ALIGN="LEFT"/>create_training_tab()<br ALIGN="LEFT"/>generate_ai_response(message)<br ALIGN="LEFT"/>generate_ai_script()<br ALIGN="LEFT"/>load_selected_model()<br ALIGN="LEFT"/>log_message(message, level)<br ALIGN="LEFT"/>on_model_loaded(model_name, success)<br ALIGN="LEFT"/>on_provider_changed(provider)<br ALIGN="LEFT"/>save_trained_model()<br ALIGN="LEFT"/>send_chat_message()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>start_ai_analysis()<br ALIGN="LEFT"/>start_model_training()<br ALIGN="LEFT"/>stop_ai_analysis()<br ALIGN="LEFT"/>stop_model_training()<br ALIGN="LEFT"/>update_temperature_label(value)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.ai_bridge.AIBinaryBridge" [color="black", fontcolor="black", label=<{AIBinaryBridge|context_builder<br ALIGN="LEFT"/>llm_manager : NoneType<br ALIGN="LEFT"/>model_manager : NoneType<br ALIGN="LEFT"/>use_llm_backend : bool<br ALIGN="LEFT"/>|analyze_binary_patterns(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_binary_region(binary_data: bytes, offset: int, size: int, query: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>identify_patterns(binary_data: bytes, offset: int, size: int, known_patterns: Optional[List[Dict[str, Any]]]): List[Dict[str, Any]]<br ALIGN="LEFT"/>search_binary_semantic(binary_data: bytes, query: str, start_offset: int, end_offset: Optional[int]): List[Dict[str, Any]]<br ALIGN="LEFT"/>suggest_edits(binary_data: bytes, offset: int, size: int, edit_intent: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.AICodingAssistantDialog" [color="black", fontcolor="black", label=<{AICodingAssistantDialog|ai_status_label<br ALIGN="LEFT"/>chat_widget<br ALIGN="LEFT"/>context_info<br ALIGN="LEFT"/>current_file : NoneType<br ALIGN="LEFT"/>current_file_label<br ALIGN="LEFT"/>current_project : Path<br ALIGN="LEFT"/>current_project_dir : NoneType<br ALIGN="LEFT"/>editor_tabs<br ALIGN="LEFT"/>file_tree<br ALIGN="LEFT"/>generation_thread : NoneType<br ALIGN="LEFT"/>llm_enabled : bool<br ALIGN="LEFT"/>modified_label<br ALIGN="LEFT"/>script_execution_manager<br ALIGN="LEFT"/>script_type_combo<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>worker_thread : NoneType<br ALIGN="LEFT"/>|ai_generate_code()<br ALIGN="LEFT"/>analyze_current_code()<br ALIGN="LEFT"/>close_tab(index: int)<br ALIGN="LEFT"/>create_ai_panel(): QWidget<br ALIGN="LEFT"/>create_editor_panel(): QWidget<br ALIGN="LEFT"/>create_file_panel(): QWidget<br ALIGN="LEFT"/>create_new_file()<br ALIGN="LEFT"/>format_current_code()<br ALIGN="LEFT"/>format_python_code(editor: CodeEditor)<br ALIGN="LEFT"/>generate_script_dialog()<br ALIGN="LEFT"/>get_ai_context(): Dict[str, Any]<br ALIGN="LEFT"/>get_current_editor(): Optional[CodeEditor]<br ALIGN="LEFT"/>handle_ai_message(message: str)<br ALIGN="LEFT"/>load_intellicrack_project()<br ALIGN="LEFT"/>on_file_modified(file_path: str)<br ALIGN="LEFT"/>open_file_in_editor(file_path: str)<br ALIGN="LEFT"/>open_project()<br ALIGN="LEFT"/>process_ai_request(message: str, context: Dict[str, Any]): str<br ALIGN="LEFT"/>run_current_script()<br ALIGN="LEFT"/>run_javascript_script(file_path: str)<br ALIGN="LEFT"/>run_python_script(file_path: str)<br ALIGN="LEFT"/>save_all_files()<br ALIGN="LEFT"/>save_current_file()<br ALIGN="LEFT"/>set_project_root(root_path: str)<br ALIGN="LEFT"/>setup_connections()<br ALIGN="LEFT"/>setup_menu_bar(layout)<br ALIGN="LEFT"/>setup_status_bar(layout)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_context_info()<br ALIGN="LEFT"/>update_modified_status()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.coordination_layer.AICoordinationLayer" [color="black", fontcolor="black", label=<{AICoordinationLayer|analysis_cache : dict<br ALIGN="LEFT"/>cache_ttl : timedelta<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>model_manager : NoneType<br ALIGN="LEFT"/>performance_stats : dict<br ALIGN="LEFT"/>shared_context<br ALIGN="LEFT"/>|analyze_vulnerabilities(request: AnalysisRequest): CoordinatedResult<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>get_performance_stats(): Dict[str, Any]<br ALIGN="LEFT"/>suggest_strategy(binary_path: str, analysis_type: str): AnalysisStrategy<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AIEventBus" [color="black", fontcolor="black", label=<{AIEventBus|<br ALIGN="LEFT"/>|emit(event_type: str, data: Dict[str, Any], source_component: str): None<br ALIGN="LEFT"/>subscribe(event_type: str, callback: Callable, component_name: str): None<br ALIGN="LEFT"/>unsubscribe(event_type: str, component_name: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.ai_bridge.AIFeatureType" [color="black", fontcolor="black", label=<{AIFeatureType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_file_tools.AIFileTools" [color="black", fontcolor="black", label=<{AIFileTools|app_instance : NoneType<br ALIGN="LEFT"/>read_tool<br ALIGN="LEFT"/>search_tool<br ALIGN="LEFT"/>|analyze_program_directory(program_path: str): Dict[str, Any]<br ALIGN="LEFT"/>read_file(file_path: str, purpose: str): Dict[str, Any]<br ALIGN="LEFT"/>read_multiple_files(file_paths: List[str], purpose: str): Dict[str, Any]<br ALIGN="LEFT"/>search_for_license_files(base_path: str, custom_patterns: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.AILearningDatabase" [color="black", fontcolor="black", label=<{AILearningDatabase|db_path<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>|get_failure_analyses(failure_type: Optional[str], resolution_status: str): List[FailureAnalysis]<br ALIGN="LEFT"/>get_learning_records(task_type: Optional[str], success: Optional[bool], limit: int): List[LearningRecord]<br ALIGN="LEFT"/>get_pattern_rules(pattern_name: Optional[str]): List[PatternRule]<br ALIGN="LEFT"/>save_failure_analysis(analysis: FailureAnalysis)<br ALIGN="LEFT"/>save_learning_record(record: LearningRecord)<br ALIGN="LEFT"/>save_pattern_rule(rule: PatternRule)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.AILearningEngine" [color="black", fontcolor="black", label=<{AILearningEngine|anomaly_detector : IsolationForest, NoneType<br ALIGN="LEFT"/>auto_evolution_interval : int<br ALIGN="LEFT"/>database<br ALIGN="LEFT"/>failure_engine<br ALIGN="LEFT"/>feature_dim : NoneType<br ALIGN="LEFT"/>last_evolution : datetime<br ALIGN="LEFT"/>learning_enabled : bool<br ALIGN="LEFT"/>learning_stats : dict<br ALIGN="LEFT"/>max_features : ndarray<br ALIGN="LEFT"/>min_features : ndarray<br ALIGN="LEFT"/>models_trained : bool<br ALIGN="LEFT"/>neural_net : MLPClassifier, NoneType<br ALIGN="LEFT"/>pattern_classifier : NoneType, RandomForestClassifier<br ALIGN="LEFT"/>pattern_engine<br ALIGN="LEFT"/>scaler : NoneType, StandardScaler<br ALIGN="LEFT"/>training_data : dict<br ALIGN="LEFT"/>|analyze_failures(): Dict[str, Any]<br ALIGN="LEFT"/>evolve_patterns(): Dict[str, Any]<br ALIGN="LEFT"/>get_applicable_patterns(context: Dict[str, Any]): List[PatternRule]<br ALIGN="LEFT"/>get_learning_insights(): Dict[str, Any]<br ALIGN="LEFT"/>learn(min_samples: int)<br ALIGN="LEFT"/>predict_success(exploit_data: Dict[str, Any]): Dict[str, float]<br ALIGN="LEFT"/>record_experience(task_type: str, input_data: Any, output_data: Any, success: bool, confidence: float, execution_time: float, memory_usage: int, error_message: Optional[str], context: Optional[Dict[str, Any]], metadata: Optional[Dict[str, Any]]): str<br ALIGN="LEFT"/>record_exploit_chain_creation(vulnerability: Any, chain: Any, success: bool, execution_time: Optional[float], error_message: Optional[str]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" [color="black", fontcolor="black", label=<{AILearningEngine|learning_enabled : bool<br ALIGN="LEFT"/>learning_stats : dict<br ALIGN="LEFT"/>|learn_from_evasion_technique(): bool<br ALIGN="LEFT"/>learn_from_exploit_chain(): bool<br ALIGN="LEFT"/>learn_from_exploit_development(): bool<br ALIGN="LEFT"/>learn_from_payload_generation(): bool<br ALIGN="LEFT"/>learn_from_vulnerability_analysis(): bool<br ALIGN="LEFT"/>record_experience(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_integration.AIModelAdapter" [color="black", fontcolor="black", label=<{AIModelAdapter|interface<br ALIGN="LEFT"/>tools<br ALIGN="LEFT"/>|<I>handle_tool_call</I>(tool_name: str, parameters: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.ai_model_manager.AIModelManager" [color="black", fontcolor="black", label=<{AIModelManager|active_models : Dict[str, Any]<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>model_loaded<br ALIGN="LEFT"/>model_unloaded<br ALIGN="LEFT"/>models : Dict[str, ModelConfig]<br ALIGN="LEFT"/>providers : Dict[ModelProvider, Any]<br ALIGN="LEFT"/>response_received<br ALIGN="LEFT"/>|analyze_binary(model_name: str, binary_path: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>generate_script(model_name: str, script_type: str, target: str, requirements: str): Optional[str]<br ALIGN="LEFT"/>get_available_models(): List[str]<br ALIGN="LEFT"/>get_loaded_models(): List[str]<br ALIGN="LEFT"/>load_model(model_name: str): bool<br ALIGN="LEFT"/>register_model(config: ModelConfig): bool<br ALIGN="LEFT"/>save_model_config(config: ModelConfig, config_path: str): bool<br ALIGN="LEFT"/>unload_model(model_name: str): bool<br ALIGN="LEFT"/>validate_model_file(model_path: str): Union[bool, str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AIOrchestrator" [color="black", fontcolor="black", label=<{AIOrchestrator|active_tasks : dict<br ALIGN="LEFT"/>ai_assistant : NoneType<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>hex_bridge : NoneType<br ALIGN="LEFT"/>is_running : bool<br ALIGN="LEFT"/>llm_manager : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ml_predictor : NoneType<br ALIGN="LEFT"/>model_manager : NoneType<br ALIGN="LEFT"/>processing_thread : NoneType, Thread<br ALIGN="LEFT"/>progress_callbacks : dict<br ALIGN="LEFT"/>shared_context<br ALIGN="LEFT"/>system_prompt : NoneType, str<br ALIGN="LEFT"/>task_progress : dict<br ALIGN="LEFT"/>task_queue : PriorityQueue<br ALIGN="LEFT"/>|clear_task_progress(task_id: str): None<br ALIGN="LEFT"/>complex_license_analysis(binary_path: str, callback: Optional[Callable]): str<br ALIGN="LEFT"/>comprehensive_analysis(binary_path: str, callback: Optional[Callable]): str<br ALIGN="LEFT"/>get_all_task_progress(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>get_component_status(): Dict[str, Any]<br ALIGN="LEFT"/>get_task_progress(task_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_task_status(task_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>quick_vulnerability_scan(binary_path: str, callback: Optional[Callable]): str<br ALIGN="LEFT"/>register_progress_callback(task_id: str, callback: Callable[[str, int, str], None]): None<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>start_processing()<br ALIGN="LEFT"/>stop_processing()<br ALIGN="LEFT"/>submit_task(task: AITask): str<br ALIGN="LEFT"/>update_task_progress(task_id: str, progress: int, status: str): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AIResult" [color="black", fontcolor="black", label=<{AIResult|completed_at : datetime<br ALIGN="LEFT"/>components_used : List[str]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>processing_time : float<br ALIGN="LEFT"/>result_data : Dict[str, Any]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>task_type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.AIScriptGenerator" [color="black", fontcolor="black", label=<{AIScriptGenerator|context_compression_ratio : float<br ALIGN="LEFT"/>generation_history : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_context_tokens : int<br ALIGN="LEFT"/>orchestrator : NoneType<br ALIGN="LEFT"/>pattern_library<br ALIGN="LEFT"/>protection_confidence : dict<br ALIGN="LEFT"/>script_cache : dict<br ALIGN="LEFT"/>success_patterns : list<br ALIGN="LEFT"/>template_engine<br ALIGN="LEFT"/>validator<br ALIGN="LEFT"/>|compress_context_if_needed(analysis_data: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>estimate_context_tokens(data: Dict[str, Any]): int<br ALIGN="LEFT"/>generate_frida_script(binary_path: str, protection_info: Dict, output_format: str): Dict<br ALIGN="LEFT"/>generate_ghidra_script(binary_path: str, protection_info: Dict, script_type: str): Dict<br ALIGN="LEFT"/>optimize_context_for_llm(analysis_data: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>refine_script(original_script: str, test_results: Dict[str, Any], analysis_data: Dict[str, Any]): Optional[GeneratedScript]<br ALIGN="LEFT"/>save_script(script: GeneratedScript, output_dir: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AISharedContext" [color="black", fontcolor="black", label=<{AISharedContext|<br ALIGN="LEFT"/>|cache_analysis(binary_hash: str, results: Dict): None<br ALIGN="LEFT"/>clear_session(): None<br ALIGN="LEFT"/>get(key: str, default: Any): Any<br ALIGN="LEFT"/>get_analysis_cache(binary_hash: str): Optional[Dict]<br ALIGN="LEFT"/>set(key: str, value: Any): None<br ALIGN="LEFT"/>update(updates: Dict[str, Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AITask" [color="black", fontcolor="black", label=<{AITask|callback : Optional[Callable]<br ALIGN="LEFT"/>complexity<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>input_data : Dict[str, Any]<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>task_type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AITaskType" [color="black", fontcolor="black", label=<{AITaskType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_chat_interface.AITerminalChat" [color="black", fontcolor="black", label=<{AITerminalChat|ai_backend : NoneType<br ALIGN="LEFT"/>analysis_results : dict<br ALIGN="LEFT"/>auto_save : bool<br ALIGN="LEFT"/>binary_path : Optional[str]<br ALIGN="LEFT"/>commands : dict<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>conversation_history : list<br ALIGN="LEFT"/>max_history : int<br ALIGN="LEFT"/>session_start : datetime<br ALIGN="LEFT"/>typing_delay : float<br ALIGN="LEFT"/>|start_chat_session()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.api_client.APIClient" [color="black", fontcolor="black", label=<{APIClient|base_url<br ALIGN="LEFT"/>retry_attempts : int<br ALIGN="LEFT"/>retry_delay<br ALIGN="LEFT"/>session : NoneType<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|fetch(endpoint: str, method: str, data: Optional[Dict[str, Any]], headers: Optional[Dict[str, str]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.api_obfuscation.APIObfuscator" [color="black", fontcolor="black", label=<{APIObfuscator|api_hash_db : dict<br ALIGN="LEFT"/>call_obfuscation_methods : dict<br ALIGN="LEFT"/>encrypted_strings_db : dict<br ALIGN="LEFT"/>failed_resolutions : int<br ALIGN="LEFT"/>import_resolution_methods : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>resolved_apis : int<br ALIGN="LEFT"/>|generate_call_obfuscation(api_name: str): str<br ALIGN="LEFT"/>obfuscate_api_calls(code: str, method: str): str<br ALIGN="LEFT"/>resolve_api(dll_name: str, api_name: str, method: str): Optional[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.base.APIRepositoryBase" [color="black", fontcolor="black", label=<{APIRepositoryBase|api_endpoint<br ALIGN="LEFT"/>api_key : str<br ALIGN="LEFT"/>cache_manager<br ALIGN="LEFT"/>download_dir<br ALIGN="LEFT"/>proxy : str<br ALIGN="LEFT"/>rate_limiter<br ALIGN="LEFT"/>repository_name : str<br ALIGN="LEFT"/>session : Session<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|<I>authenticate</I>(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str, progress_callback: Optional[DownloadProgressCallback]): Tuple[bool, str]<br ALIGN="LEFT"/><I>get_available_models</I>(): List[ModelInfo]<br ALIGN="LEFT"/><I>get_model_details</I>(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ascii_charts.ASCIIChartGenerator" [color="black", fontcolor="black", label=<{ASCIIChartGenerator|console : Console<br ALIGN="LEFT"/>height : int<br ALIGN="LEFT"/>symbols : dict<br ALIGN="LEFT"/>width : int<br ALIGN="LEFT"/>|create_styled_legend(data: Dict[str, Union[int, float]], title: str): None<br ALIGN="LEFT"/>display_chart_rich(chart_content: str, title: str): None<br ALIGN="LEFT"/>generate_analysis_summary_chart(analysis_results: Dict[str, Any]): str<br ALIGN="LEFT"/>generate_bar_chart(data: Dict[str, Union[int, float]], title: str, show_values: bool, color_coding: bool): str<br ALIGN="LEFT"/>generate_histogram(values: List[Union[int, float]], bins: int, title: str): str<br ALIGN="LEFT"/>generate_line_chart(data: Dict[str, Union[int, float]], title: str): str<br ALIGN="LEFT"/>generate_pie_chart(data: Dict[str, Union[int, float]], title: str): str<br ALIGN="LEFT"/>generate_rich_dashboard(analysis_results: Dict[str, Any]): None<br ALIGN="LEFT"/>generate_scatter_plot(points: List[Tuple[float, float]], title: str): str<br ALIGN="LEFT"/>generate_vulnerability_trend_chart(vulnerability_data: List[Dict[str, Any]]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.aslr_bypass.ASLRBypass" [color="black", fontcolor="black", label=<{ASLRBypass|enabled_techniques : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze_target(target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>bypass(target_info: Dict[str, Any], method: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.aslr_bypass.ASLRBypass" [color="black", fontcolor="black", label=<{ASLRBypass|logger : NoneType, RootLogger<br ALIGN="LEFT"/>techniques : list<br ALIGN="LEFT"/>|analyze_aslr_bypass(binary_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>bypass_aslr_info_leak(target_binary: str, leak_address: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>bypass_aslr_partial_overwrite(target_binary: str): Dict[str, Any]<br ALIGN="LEFT"/>bypass_aslr_ret2libc(target_binary: str): Dict[str, Any]<br ALIGN="LEFT"/>get_recommended_technique(binary_info: Dict[str, Any]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.ASLRBypass" [color="black", fontcolor="black", label=<{ASLRBypass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.AbstractPlugin" [color="black", fontcolor="black", label=<{AbstractPlugin|capabilities : List[str]<br ALIGN="LEFT"/>config : Dict[str, Any]<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>event_bus : Optional['EventBus'], str<br ALIGN="LEFT"/>last_error : Optional[str]<br ALIGN="LEFT"/>logger : Optional[logging.Logger]<br ALIGN="LEFT"/>metadata : Optional[PluginMetadata]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>performance_metrics : Dict[str, Any]<br ALIGN="LEFT"/>status : DISCOVERED<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|<I>activate</I>(): bool<br ALIGN="LEFT"/><I>cleanup</I>(): bool<br ALIGN="LEFT"/><I>deactivate</I>(): bool<br ALIGN="LEFT"/>emit_event(event_type: str, data: Dict[str, Any], target: str)<br ALIGN="LEFT"/><I>execute_operation</I>(operation: str, parameters: Dict[str, Any]): Any<br ALIGN="LEFT"/><I>get_metadata</I>(): PluginMetadata<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/><I>get_supported_operations</I>(): List[str]<br ALIGN="LEFT"/><I>initialize</I>(config: Dict[str, Any]): bool<br ALIGN="LEFT"/>log_performance_metric(metric_name: str, value: Any)<br ALIGN="LEFT"/>set_event_bus(event_bus: 'EventBus')<br ALIGN="LEFT"/>set_logger(logger: logging.Logger)<br ALIGN="LEFT"/>update_config(config: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.ActionType" [color="black", fontcolor="black", label=<{ActionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.windows_activator.ActivationMethod" [color="black", fontcolor="black", label=<{ActivationMethod|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.ActivationRequest" [color="black", fontcolor="black", label=<{ActivationRequest|client_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>hardware_fingerprint : Optional[str]<br ALIGN="LEFT"/>license_key : Optional[str]<br ALIGN="LEFT"/>product_name : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.ActivationResponse" [color="black", fontcolor="black", label=<{ActivationResponse|activation_id : Optional[str]<br ALIGN="LEFT"/>certificate : Optional[str]<br ALIGN="LEFT"/>message : Optional[str]<br ALIGN="LEFT"/>success : Optional[bool]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.windows_activator.ActivationStatus" [color="black", fontcolor="black", label=<{ActivationStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AdaptationEvent" [color="black", fontcolor="black", label=<{AdaptationEvent|action_taken : str<br ALIGN="LEFT"/>adaptation_type<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>event_id : str<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>impact_metrics : Dict[str, float]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>trigger_condition<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AdaptationRule" [color="black", fontcolor="black", label=<{AdaptationRule|action : str<br ALIGN="LEFT"/>adaptation_type<br ALIGN="LEFT"/>condition<br ALIGN="LEFT"/>cooldown_seconds : int<br ALIGN="LEFT"/>enabled : bool<br ALIGN="LEFT"/>last_triggered : Optional[datetime]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>rule_id : str<br ALIGN="LEFT"/>success_count : int<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>trigger_count : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AdaptationType" [color="black", fontcolor="black", label=<{AdaptationType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.lora_adapter_manager.AdapterConfig" [color="black", fontcolor="black", label=<{AdapterConfig|adapter_type : str<br ALIGN="LEFT"/>bias : str<br ALIGN="LEFT"/>fan_in_fan_out : bool<br ALIGN="LEFT"/>inference_mode : bool<br ALIGN="LEFT"/>init_r : int<br ALIGN="LEFT"/>lora_alpha : int<br ALIGN="LEFT"/>lora_dropout : float<br ALIGN="LEFT"/>modules_to_save : Optional[List[str]]<br ALIGN="LEFT"/>r : int<br ALIGN="LEFT"/>target_modules : Optional[List[str]]<br ALIGN="LEFT"/>target_r : int<br ALIGN="LEFT"/>task_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.AdaptiveAnalyzer" [color="black", fontcolor="black", label=<{AdaptiveAnalyzer|cache_manager<br ALIGN="LEFT"/>memory_manager<br ALIGN="LEFT"/>|get_analysis_strategy(file_path: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.AdaptiveOptimizer" [color="black", fontcolor="black", label=<{AdaptiveOptimizer|current_config : dict<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>optimization_history : list<br ALIGN="LEFT"/>|get_recommendations(): Dict[str, Any]<br ALIGN="LEFT"/>learn_from_metrics(metrics: Dict[str, float], performance_score: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.AdobeEmulator" [color="black", fontcolor="black", label=<{AdobeEmulator|adobe_products : dict<br ALIGN="LEFT"/>crypto<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|validate_adobe_license(product_id: str, user_id: str, machine_id: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.adobe_injector.AdobeInjector" [color="black", fontcolor="black", label=<{AdobeInjector|ADOBE_PROCESSES : list<br ALIGN="LEFT"/>FRIDA_SCRIPT : str<br ALIGN="LEFT"/>injected : Set[str]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|get_injection_status(): dict<br ALIGN="LEFT"/>get_running_adobe_processes(): List[str]<br ALIGN="LEFT"/>inject_apc_queue(target_name: str, dll_path: str, wait_for_alertable: bool): bool<br ALIGN="LEFT"/>inject_direct_syscall(target_name: str, dll_path: str): bool<br ALIGN="LEFT"/>inject_dll_windows_api(target_name: str, dll_path: str): bool<br ALIGN="LEFT"/>inject_early_bird(target_exe: str, dll_path: str, command_line: str): bool<br ALIGN="LEFT"/>inject_kernel_driver(target_pid: int, dll_path: str): bool<br ALIGN="LEFT"/>inject_process(target_name: str): bool<br ALIGN="LEFT"/>inject_process_hollowing(target_exe: str, payload_exe: str): bool<br ALIGN="LEFT"/>inject_reflective_dll(target_name: str, dll_data: bytes): bool<br ALIGN="LEFT"/>inject_reflective_dll_from_file(target_name: str, dll_path: str): bool<br ALIGN="LEFT"/>inject_setwindowshookex(target_name: str, dll_path: str, hook_type: int): bool<br ALIGN="LEFT"/>inject_wow64(target_name: str, dll_path: str): bool<br ALIGN="LEFT"/>is_dll_64bit(dll_path: str): Optional[bool]<br ALIGN="LEFT"/>is_process_64bit(process_handle: int): Optional[bool]<br ALIGN="LEFT"/>manual_map_dll(target_name: str, dll_path: str): bool<br ALIGN="LEFT"/>monitor_and_inject(interval: float): None<br ALIGN="LEFT"/>stop_monitoring(): None<br ALIGN="LEFT"/>unhook_all(): None<br ALIGN="LEFT"/>unlink_dll_from_peb(target_name: str, dll_name: str): bool<br ALIGN="LEFT"/>verify_injection(target_name: str, dll_name: str, check_hooks: bool): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.AdobeProtocolHandler" [color="black", fontcolor="black", label=<{AdobeProtocolHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_response(context: ResponseContext): bytes<br ALIGN="LEFT"/>parse_request(data: bytes): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.intellicrack_advanced_protection_widget.AdvancedAnalysisThread" [color="black", fontcolor="black", label=<{AdvancedAnalysisThread|analysis_complete<br ALIGN="LEFT"/>analysis_error<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>detector<br ALIGN="LEFT"/>enable_heuristic : bool<br ALIGN="LEFT"/>extract_strings : bool<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>scan_mode<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.dynamic_analyzer.AdvancedDynamicAnalyzer" [color="black", fontcolor="black", label=<{AdvancedDynamicAnalyzer|api_calls : list<br ALIGN="LEFT"/>binary_path : Path<br ALIGN="LEFT"/>file_operations : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>memory_access : list<br ALIGN="LEFT"/>network_activity : list<br ALIGN="LEFT"/>|analyze(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>is_available(): bool<br ALIGN="LEFT"/>run_comprehensive_analysis(payload: Optional[bytes]): Dict[str, Any]<br ALIGN="LEFT"/>scan_memory_for_keywords(keywords: List[str], target_process: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.advanced_export.AdvancedExporter" [color="black", fontcolor="black", label=<{AdvancedExporter|analysis_results : Dict[str, Any]<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>export_metadata : dict<br ALIGN="LEFT"/>|export_csv_data(output_path: str, data_type: str): bool<br ALIGN="LEFT"/>export_detailed_json(output_path: str, include_raw_data: bool): bool<br ALIGN="LEFT"/>export_excel_workbook(output_path: str): bool<br ALIGN="LEFT"/>export_executive_summary(output_path: str, format_type: str): bool<br ALIGN="LEFT"/>export_html_report(output_path: str): bool<br ALIGN="LEFT"/>export_vulnerability_report(output_path: str): bool<br ALIGN="LEFT"/>export_xml_report(output_path: str): bool<br ALIGN="LEFT"/>export_yaml_config(output_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.pattern_library.AdvancedPatternLibrary" [color="black", fontcolor="black", label=<{AdvancedPatternLibrary|learning_data : dict<br ALIGN="LEFT"/>patterns : dict<br ALIGN="LEFT"/>success_history : dict<br ALIGN="LEFT"/>|analyze_binary_patterns(analysis_results: Dict[str, Any]): List[ProtectionPattern]<br ALIGN="LEFT"/>export_patterns(): Dict[str, Any]<br ALIGN="LEFT"/>get_bypass_strategy(protection_type: str): Dict[str, Any]<br ALIGN="LEFT"/>get_pattern_by_indicators(indicators: List[str]): List[ProtectionPattern]<br ALIGN="LEFT"/>get_pattern_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>update_success_rate(pattern_name: str, success: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.payload_generator.AdvancedPayloadGenerator" [color="black", fontcolor="black", label=<{AdvancedPayloadGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate(payload_type: str): bytes<br ALIGN="LEFT"/>generate_license_bypass_payload(strategy: Dict[str, Any]): Optional[bytes]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.interactive_mode.AdvancedProgressManager" [color="black", fontcolor="black", label=<{AdvancedProgressManager|console<br ALIGN="LEFT"/>current_operation : NoneType<br ALIGN="LEFT"/>start_time : NoneType<br ALIGN="LEFT"/>|run_multi_stage_operation(operation_name, stages, callback_func)<br ALIGN="LEFT"/>show_live_stats(stats_func, duration)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.AdvancedProtectionAnalysis" [color="black", fontcolor="black", label=<{AdvancedProtectionAnalysis|architecture<br ALIGN="LEFT"/>certificates : List[CertificateInfo]<br ALIGN="LEFT"/>endianess<br ALIGN="LEFT"/>entropy_info : List[EntropyInfo]<br ALIGN="LEFT"/>entry_point<br ALIGN="LEFT"/>file_format_details : Dict[str, Any]<br ALIGN="LEFT"/>file_type<br ALIGN="LEFT"/>has_overlay<br ALIGN="LEFT"/>has_resources<br ALIGN="LEFT"/>heuristic_detections : List[DetectionResult]<br ALIGN="LEFT"/>import_hash : Optional[ImportHash]<br ALIGN="LEFT"/>is_64bit<br ALIGN="LEFT"/>is_packed : bool<br ALIGN="LEFT"/>is_protected : bool<br ALIGN="LEFT"/>resources : List[ResourceInfo]<br ALIGN="LEFT"/>similarity_hash : Optional[str]<br ALIGN="LEFT"/>suspicious_strings : List[StringInfo]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.AdvancedSearchDialog" [color="black", fontcolor="black", label=<{AdvancedSearchDialog|backward_radio : NoneType<br ALIGN="LEFT"/>cancel_search_button : NoneType<br ALIGN="LEFT"/>case_sensitive_check : NoneType<br ALIGN="LEFT"/>clear_history_button : NoneType<br ALIGN="LEFT"/>current_search_thread : NoneType<br ALIGN="LEFT"/>direction_group : NoneType<br ALIGN="LEFT"/>find_all_button : NoneType<br ALIGN="LEFT"/>find_all_pattern_combo : NoneType<br ALIGN="LEFT"/>find_all_type_combo : NoneType<br ALIGN="LEFT"/>find_next_button : NoneType<br ALIGN="LEFT"/>find_pattern_combo : NoneType<br ALIGN="LEFT"/>find_previous_button : NoneType<br ALIGN="LEFT"/>forward_radio : NoneType<br ALIGN="LEFT"/>history_list : NoneType<br ALIGN="LEFT"/>max_results_spin : NoneType<br ALIGN="LEFT"/>replace_all_button : NoneType<br ALIGN="LEFT"/>replace_button : NoneType<br ALIGN="LEFT"/>replace_case_sensitive_check : NoneType<br ALIGN="LEFT"/>replace_pattern_edit : NoneType<br ALIGN="LEFT"/>replace_status_label : NoneType<br ALIGN="LEFT"/>replace_type_combo : NoneType<br ALIGN="LEFT"/>replace_whole_words_check : NoneType<br ALIGN="LEFT"/>results_table : NoneType<br ALIGN="LEFT"/>search_engine : Optional[SearchEngine]<br ALIGN="LEFT"/>search_history<br ALIGN="LEFT"/>search_pattern_combo : NoneType<br ALIGN="LEFT"/>search_progress : NoneType<br ALIGN="LEFT"/>search_status_label : NoneType<br ALIGN="LEFT"/>search_type_combo : NoneType<br ALIGN="LEFT"/>use_history_button : NoneType<br ALIGN="LEFT"/>whole_words_check : NoneType<br ALIGN="LEFT"/>|cancel_search()<br ALIGN="LEFT"/>clear_history()<br ALIGN="LEFT"/>create_find_all_tab(): QWidget<br ALIGN="LEFT"/>create_history_tab(): QWidget<br ALIGN="LEFT"/>create_replace_tab(): QWidget<br ALIGN="LEFT"/>create_search_tab(): QWidget<br ALIGN="LEFT"/>find_all()<br ALIGN="LEFT"/>find_next()<br ALIGN="LEFT"/>find_previous()<br ALIGN="LEFT"/>load_recent_searches()<br ALIGN="LEFT"/>on_find_all_completed(results: List[SearchResult])<br ALIGN="LEFT"/>replace_all()<br ALIGN="LEFT"/>replace_current()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_history_list()<br ALIGN="LEFT"/>use_history_item(item: QListWidgetItem)<br ALIGN="LEFT"/>use_selected_history()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.taint_analyzer.AdvancedTaintTracker" [color="black", fontcolor="black", label=<{AdvancedTaintTracker|cfg : Dict[int, List[int]]<br ALIGN="LEFT"/>data_flow_graph : Dict[int, Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>register_state_map : Dict[int, Dict[str, Any]]<br ALIGN="LEFT"/>taint_id_counter : int<br ALIGN="LEFT"/>taint_propagation_map : dict<br ALIGN="LEFT"/>taint_sources : dict<br ALIGN="LEFT"/>transformation_log : dict<br ALIGN="LEFT"/>|add_taint_source(source_instr: Dict[str, Any]): int<br ALIGN="LEFT"/>propagate_taint(source: Dict[str, Any], sinks: List[Dict[str, Any]]): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.tool_discovery.AdvancedToolDiscovery" [color="black", fontcolor="black", label=<{AdvancedToolDiscovery|discovered_tools : dict<br ALIGN="LEFT"/>search_cache : dict<br ALIGN="LEFT"/>validators : dict<br ALIGN="LEFT"/>|discover_all_tools(): Dict[str, Any]<br ALIGN="LEFT"/>discover_tool(tool_name: str, config: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_tool_capabilities(tool_name: str): List[str]<br ALIGN="LEFT"/>is_tool_compatible(tool_name: str, required_capabilities: List[str]): bool<br ALIGN="LEFT"/>refresh_discovery(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.vulnerability_engine.AdvancedVulnerabilityEngine" [color="black", fontcolor="black", label=<{AdvancedVulnerabilityEngine|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_exploit_strategy(vulnerabilities: List[Dict[str, Any]]): List[Dict[str, Any]]<br ALIGN="LEFT"/>scan_binary(binary_path: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app._check_intercepted_traffic.AdvancedVulnerabilityEngine" [color="black", fontcolor="black", label=<{AdvancedVulnerabilityEngine|<br ALIGN="LEFT"/>|scan_binary(binary_path)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.AgentCapability" [color="black", fontcolor="black", label=<{AgentCapability|capability_name : str<br ALIGN="LEFT"/>confidence_level : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>input_types : List[str]<br ALIGN="LEFT"/>output_types : List[str]<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>processing_time_estimate : float<br ALIGN="LEFT"/>resource_requirements : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.AgentMessage" [color="black", fontcolor="black", label=<{AgentMessage|content : Dict[str, Any]<br ALIGN="LEFT"/>correlation_id : Optional[str]<br ALIGN="LEFT"/>message_id : str<br ALIGN="LEFT"/>message_type<br ALIGN="LEFT"/>priority<br ALIGN="LEFT"/>recipient_id : str<br ALIGN="LEFT"/>requires_response : bool<br ALIGN="LEFT"/>response_timeout : Optional[float]<br ALIGN="LEFT"/>sender_id : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.AgentRole" [color="black", fontcolor="black", label=<{AgentRole|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.AgentTask" [color="black", fontcolor="black", label=<{AgentTask|assigned_to : Optional[str]<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>deadline : Optional[datetime]<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>input_data : Dict[str, Any]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>priority<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>task_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.analysis_cache.AnalysisCache" [color="black", fontcolor="black", label=<{AnalysisCache|auto_save : bool<br ALIGN="LEFT"/>cache_dir : Path<br ALIGN="LEFT"/>cache_file<br ALIGN="LEFT"/>max_entries : int<br ALIGN="LEFT"/>max_size_bytes : int<br ALIGN="LEFT"/>stats_file<br ALIGN="LEFT"/>|cleanup_invalid(): int<br ALIGN="LEFT"/>clear(): None<br ALIGN="LEFT"/>get(file_path: str, scan_options: str): Optional[Any]<br ALIGN="LEFT"/>get_cache_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_stats(): CacheStats<br ALIGN="LEFT"/>put(file_path: str, data: Any, scan_options: str): None<br ALIGN="LEFT"/>remove(file_path: str, scan_options: str): bool<br ALIGN="LEFT"/>save_cache(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.orchestrator.AnalysisComplexity" [color="black", fontcolor="black", label=<{AnalysisComplexity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.AnalysisCoordinator" [color="black", fontcolor="black", label=<{AnalysisCoordinator|active_analyses : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>analysis_queue : Queue<br ALIGN="LEFT"/>analysis_templates : dict<br ALIGN="LEFT"/>coordinator_task : Optional[asyncio.Task]<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>logger : Logger<br ALIGN="LEFT"/>plugin_manager<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>workflow_engine<br ALIGN="LEFT"/>|analyze_binary(binary_path: str, analysis_type: str, parameters: Dict[str, Any]): str<br ALIGN="LEFT"/>get_active_analyses(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_analysis_status(analysis_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.sandbox_manager.AnalysisDepth" [color="black", fontcolor="black", label=<{AnalysisDepth|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.AnalysisEvent" [color="black", fontcolor="black", label=<{AnalysisEvent|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.AnalysisEvent" [color="black", fontcolor="black", label=<{AnalysisEvent|component : str<br ALIGN="LEFT"/>duration : float<br ALIGN="LEFT"/>error_details : str<br ALIGN="LEFT"/>event_id : str<br ALIGN="LEFT"/>event_type<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>outcome<br ALIGN="LEFT"/>protection_category<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|generate_event_id(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.analysis.analysis_exporter.AnalysisExporter" [color="black", fontcolor="black", label=<{AnalysisExporter|<br ALIGN="LEFT"/>|export_analysis(result: Dict[str, Any], output_file: str, format: str, analysis_type: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.AnalysisLevel" [color="black", fontcolor="black", label=<{AnalysisLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.AnalysisMethod" [color="black", fontcolor="black", label=<{AnalysisMethod|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog._execute_testcase.AnalysisMethod" [color="black", fontcolor="black", label=<{AnalysisMethod|DYNAMIC : str<br ALIGN="LEFT"/>HYBRID : str<br ALIGN="LEFT"/>STATIC : str<br ALIGN="LEFT"/>SYMBOLIC : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [color="black", fontcolor="black", label=<{AnalysisOrchestrator|analysis_completed<br ALIGN="LEFT"/>binary_analyzer<br ALIGN="LEFT"/>dynamic_analyzer<br ALIGN="LEFT"/>enabled_phases : list<br ALIGN="LEFT"/>entropy_analyzer<br ALIGN="LEFT"/>ghidra_decompiler : NoneType<br ALIGN="LEFT"/>multi_format_analyzer<br ALIGN="LEFT"/>phase_completed<br ALIGN="LEFT"/>phase_failed<br ALIGN="LEFT"/>phase_started<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>radare2<br ALIGN="LEFT"/>timeout_per_phase : int<br ALIGN="LEFT"/>vulnerability_engine<br ALIGN="LEFT"/>yara_engine<br ALIGN="LEFT"/>|analyze_binary(binary_path: str, phases: Optional[List[AnalysisPhase]]): OrchestrationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.analysis_orchestrator.AnalysisPhase" [color="black", fontcolor="black", label=<{AnalysisPhase|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.AnalysisProfile" [color="black", fontcolor="black", label=<{AnalysisProfile|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.coordination_layer.AnalysisRequest" [color="black", fontcolor="black", label=<{AnalysisRequest|analysis_type : str<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>confidence_threshold : float<br ALIGN="LEFT"/>context : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>max_processing_time : float<br ALIGN="LEFT"/>strategy<br ALIGN="LEFT"/>use_cache : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.shared.result_types.AnalysisResult" [color="black", fontcolor="black", label=<{AnalysisResult|analysis_type<br ALIGN="LEFT"/>data : Dict[str, Any]<br ALIGN="LEFT"/>errors : Optional[List[str]]<br ALIGN="LEFT"/>metadata : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>warnings : Optional[List[str]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisResult" [color="black", fontcolor="black", label=<{AnalysisResult|bypass_methods : List[str]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>details : Dict[str, Any]<br ALIGN="LEFT"/>generated_scripts : List[str]<br ALIGN="LEFT"/>protection_type : str<br ALIGN="LEFT"/>target_file : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.unified_protection_engine.AnalysisSource" [color="black", fontcolor="black", label=<{AnalysisSource|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.AnalysisStage" [color="black", fontcolor="black", label=<{AnalysisStage|<br ALIGN="LEFT"/>|process(input_data: PipelineData): PipelineData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisState" [color="black", fontcolor="black", label=<{AnalysisState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.AnalysisStats" [color="black", fontcolor="black", label=<{AnalysisStats|active_projects : int<br ALIGN="LEFT"/>analyses_completed : int<br ALIGN="LEFT"/>analysis_time_avg : float<br ALIGN="LEFT"/>cache_hits : int<br ALIGN="LEFT"/>cache_misses : int<br ALIGN="LEFT"/>last_analysis : Optional[str]<br ALIGN="LEFT"/>total_binaries : int<br ALIGN="LEFT"/>vulnerabilities_found : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.analysis_stats.AnalysisStatsGenerator" [color="black", fontcolor="black", label=<{AnalysisStatsGenerator|<br ALIGN="LEFT"/>|aggregate_numeric_stats(items: List[Dict[str, Any]], attribute: str): Dict[str, float]<br ALIGN="LEFT"/>calculate_distribution(items: List[Dict[str, Any]], attribute: str): Dict[str, float]<br ALIGN="LEFT"/>calculate_growth_rate(current_value: Union[int, float], previous_value: Union[int, float]): float<br ALIGN="LEFT"/>count_by_attribute(items: List[Dict[str, Any]], attribute: str): Dict[str, int]<br ALIGN="LEFT"/>detect_outliers(values: List[Union[int, float]], method: str): List[int]<br ALIGN="LEFT"/>generate_correlation_matrix(items: List[Dict[str, Any]], attributes: List[str]): Dict[str, Dict[str, float]]<br ALIGN="LEFT"/>generate_percentiles(values: List[Union[int, float]], percentiles: List[int]): Dict[int, float]<br ALIGN="LEFT"/>generate_summary_report(items: List[Dict[str, Any]], title: str): str<br ALIGN="LEFT"/>generate_time_series_stats(items: List[Dict[str, Any]], time_attribute: str, value_attribute: str, interval_seconds: int): Dict[str, Any]<br ALIGN="LEFT"/>safe_stats_generation(stats_function: Callable[[], Any], default_return: Optional[Any]): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.analysis.analysis_stats.AnalysisStatsGenerator" [color="black", fontcolor="black", label=<{AnalysisStatsGenerator|<br ALIGN="LEFT"/>|count_by_attribute(items: List[Dict[str, Any]], attribute: str, default_value: str): Dict[str, int]<br ALIGN="LEFT"/>safe_recommendation_generation(rec_func): List[str]<br ALIGN="LEFT"/>safe_stats_generation(stats_func): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.coordination_layer.AnalysisStrategy" [color="black", fontcolor="black", label=<{AnalysisStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.tabs.analysis_tab.AnalysisTab" [color="black", fontcolor="black", label=<{AnalysisTab|analysis_completed<br ALIGN="LEFT"/>analysis_depth_combo<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>analysis_results : dict<br ALIGN="LEFT"/>analysis_started<br ALIGN="LEFT"/>analysis_status<br ALIGN="LEFT"/>analysis_subtabs<br ALIGN="LEFT"/>anti_debug_detection_cb<br ALIGN="LEFT"/>api_monitoring_cb<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>concolic_execution_cb<br ALIGN="LEFT"/>current_binary<br ALIGN="LEFT"/>disassembly_cb<br ALIGN="LEFT"/>embedded_hex_viewer<br ALIGN="LEFT"/>emulation_cb<br ALIGN="LEFT"/>entropy_analysis_cb<br ALIGN="LEFT"/>entropy_block_size<br ALIGN="LEFT"/>entropy_view_container<br ALIGN="LEFT"/>entropy_visualizer<br ALIGN="LEFT"/>execution_timeout_spin<br ALIGN="LEFT"/>file_monitoring_cb<br ALIGN="LEFT"/>gpu_acceleration_cb<br ALIGN="LEFT"/>hex_view_container<br ALIGN="LEFT"/>hex_view_placeholder<br ALIGN="LEFT"/>hooking_framework_combo<br ALIGN="LEFT"/>imports_analysis_cb<br ALIGN="LEFT"/>incremental_analysis_cb<br ALIGN="LEFT"/>license_check_detection_cb<br ALIGN="LEFT"/>memory_monitoring_cb<br ALIGN="LEFT"/>memory_optimized_cb<br ALIGN="LEFT"/>network_monitoring_cb<br ALIGN="LEFT"/>obfuscation_detection_cb<br ALIGN="LEFT"/>packer_detection_cb<br ALIGN="LEFT"/>parallel_processing_cb<br ALIGN="LEFT"/>protection_detected<br ALIGN="LEFT"/>results_display<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>sandbox_execution_cb<br ALIGN="LEFT"/>signature_analysis_cb<br ALIGN="LEFT"/>string_analysis_cb<br ALIGN="LEFT"/>symbolic_execution_cb<br ALIGN="LEFT"/>vm_detection_cb<br ALIGN="LEFT"/>|attach_to_process()<br ALIGN="LEFT"/>clear_all_cache()<br ALIGN="LEFT"/>clear_analysis_cache()<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>configure_execution_engines()<br ALIGN="LEFT"/>configure_gpu_acceleration()<br ALIGN="LEFT"/>create_analysis_controls_panel()<br ALIGN="LEFT"/>create_analysis_options_tab()<br ALIGN="LEFT"/>create_dynamic_hooking_tab()<br ALIGN="LEFT"/>create_execution_engines_tab()<br ALIGN="LEFT"/>create_protection_analysis_tab()<br ALIGN="LEFT"/>create_results_panel()<br ALIGN="LEFT"/>create_static_analysis_tab()<br ALIGN="LEFT"/>detect_protections()<br ALIGN="LEFT"/>embed_hex_viewer()<br ALIGN="LEFT"/>export_analysis_results()<br ALIGN="LEFT"/>on_analysis_completed(analysis_type, results)<br ALIGN="LEFT"/>on_analysis_started(analysis_type, options)<br ALIGN="LEFT"/>on_binary_loaded(binary_path: str)<br ALIGN="LEFT"/>open_hex_viewer()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>start_dynamic_monitoring()<br ALIGN="LEFT"/>start_full_analysis()<br ALIGN="LEFT"/>start_static_analysis()<br ALIGN="LEFT"/>stop_analysis()<br ALIGN="LEFT"/>test_execution_engines()<br ALIGN="LEFT"/>update_binary(binary_path)<br ALIGN="LEFT"/>update_entropy_visualization()<br ALIGN="LEFT"/>view_cache_info()<br ALIGN="LEFT"/>view_disassembly()<br ALIGN="LEFT"/>view_protection_info()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.analysis_tab_original.AnalysisTab" [color="black", fontcolor="black", label=<{AnalysisTab|analysis_completed<br ALIGN="LEFT"/>analysis_depth_combo<br ALIGN="LEFT"/>analysis_orchestrator<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>analysis_results : dict<br ALIGN="LEFT"/>analysis_started<br ALIGN="LEFT"/>analysis_status<br ALIGN="LEFT"/>analysis_subtabs<br ALIGN="LEFT"/>anti_debug_detection_cb<br ALIGN="LEFT"/>api_monitoring_cb<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>concolic_execution_cb<br ALIGN="LEFT"/>current_binary : NoneType<br ALIGN="LEFT"/>disassembly_cb<br ALIGN="LEFT"/>embedded_hex_viewer<br ALIGN="LEFT"/>emulation_cb<br ALIGN="LEFT"/>entropy_analysis_cb<br ALIGN="LEFT"/>entropy_view_container<br ALIGN="LEFT"/>execution_timeout_spin<br ALIGN="LEFT"/>file_monitoring_cb<br ALIGN="LEFT"/>gpu_acceleration_cb<br ALIGN="LEFT"/>hex_view_container<br ALIGN="LEFT"/>hex_view_placeholder<br ALIGN="LEFT"/>hooking_framework_combo<br ALIGN="LEFT"/>imports_analysis_cb<br ALIGN="LEFT"/>incremental_analysis_cb<br ALIGN="LEFT"/>license_check_detection_cb<br ALIGN="LEFT"/>memory_monitoring_cb<br ALIGN="LEFT"/>memory_optimized_cb<br ALIGN="LEFT"/>network_monitoring_cb<br ALIGN="LEFT"/>obfuscation_detection_cb<br ALIGN="LEFT"/>packer_detection_cb<br ALIGN="LEFT"/>parallel_processing_cb<br ALIGN="LEFT"/>protection_detected<br ALIGN="LEFT"/>results_display<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>sandbox_execution_cb<br ALIGN="LEFT"/>signature_analysis_cb<br ALIGN="LEFT"/>string_analysis_cb<br ALIGN="LEFT"/>symbolic_execution_cb<br ALIGN="LEFT"/>vm_detection_cb<br ALIGN="LEFT"/>|attach_to_process()<br ALIGN="LEFT"/>clear_all_cache()<br ALIGN="LEFT"/>clear_analysis_cache()<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>configure_execution_engines()<br ALIGN="LEFT"/>configure_gpu_acceleration()<br ALIGN="LEFT"/>create_analysis_controls_panel()<br ALIGN="LEFT"/>create_analysis_options_tab()<br ALIGN="LEFT"/>create_dynamic_hooking_tab()<br ALIGN="LEFT"/>create_execution_engines_tab()<br ALIGN="LEFT"/>create_protection_analysis_tab()<br ALIGN="LEFT"/>create_results_panel()<br ALIGN="LEFT"/>create_static_analysis_tab()<br ALIGN="LEFT"/>detect_protections()<br ALIGN="LEFT"/>embed_hex_viewer()<br ALIGN="LEFT"/>export_analysis_results()<br ALIGN="LEFT"/>on_analysis_completed(analysis_type, results)<br ALIGN="LEFT"/>on_analysis_started(analysis_type, options)<br ALIGN="LEFT"/>on_binary_loaded(binary_path: str)<br ALIGN="LEFT"/>open_hex_viewer()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>start_dynamic_monitoring()<br ALIGN="LEFT"/>start_full_analysis()<br ALIGN="LEFT"/>start_static_analysis()<br ALIGN="LEFT"/>stop_analysis()<br ALIGN="LEFT"/>test_execution_engines()<br ALIGN="LEFT"/>update_binary(binary_path)<br ALIGN="LEFT"/>view_cache_info()<br ALIGN="LEFT"/>view_disassembly()<br ALIGN="LEFT"/>view_protection_info()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.progress_manager.AnalysisTask" [color="black", fontcolor="black", label=<{AnalysisTask|current_step : int<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>end_time : Optional[datetime]<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>start_time : Optional[datetime]<br ALIGN="LEFT"/>status : str<br ALIGN="LEFT"/>subtasks : Optional[List['AnalysisTask']]<br ALIGN="LEFT"/>total_steps : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.shared.result_types.AnalysisType" [color="black", fontcolor="black", label=<{AnalysisType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.AnalysisUpdate" [color="black", fontcolor="black", label=<{AnalysisUpdate|analysis_id : str<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>data : Dict[str, Any]<br ALIGN="LEFT"/>event_type<br ALIGN="LEFT"/>related_updates : List[str]<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>source_component : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisViewerPanel" [color="black", fontcolor="black", label=<{AnalysisViewerPanel|bypass_listbox : Listbox<br ALIGN="LEFT"/>chart<br ALIGN="LEFT"/>chart_type_var : StringVar<br ALIGN="LEFT"/>confidence_label : Label<br ALIGN="LEFT"/>confidence_progress : Progressbar<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>current_analysis : NoneType<br ALIGN="LEFT"/>details_frame : Frame<br ALIGN="LEFT"/>details_text : ScrolledText<br ALIGN="LEFT"/>details_tree : Treeview<br ALIGN="LEFT"/>file_info_text : ScrolledText<br ALIGN="LEFT"/>frame : Frame<br ALIGN="LEFT"/>history_frame : Frame<br ALIGN="LEFT"/>history_tree : Treeview<br ALIGN="LEFT"/>notebook : Notebook<br ALIGN="LEFT"/>overview_frame : Frame<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>protection_type_label : Label<br ALIGN="LEFT"/>ui_controller<br ALIGN="LEFT"/>viz_frame : Frame<br ALIGN="LEFT"/>|add_to_history(result: AnalysisResult)<br ALIGN="LEFT"/>clear_history()<br ALIGN="LEFT"/>create_details_tab()<br ALIGN="LEFT"/>create_history_tab()<br ALIGN="LEFT"/>create_overview_tab()<br ALIGN="LEFT"/>create_visualization_tab()<br ALIGN="LEFT"/>export_history()<br ALIGN="LEFT"/>on_details_select(event)<br ALIGN="LEFT"/>on_history_double_click(event)<br ALIGN="LEFT"/>update_analysis(result: AnalysisResult)<br ALIGN="LEFT"/>update_details(result: AnalysisResult)<br ALIGN="LEFT"/>update_overview(result: AnalysisResult)<br ALIGN="LEFT"/>update_visualization(event)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.AnalyticsEngine" [color="black", fontcolor="black", label=<{AnalyticsEngine|analysis_cache : Dict[str, Any]<br ALIGN="LEFT"/>data_collector<br ALIGN="LEFT"/>|analyze_performance_trends(time_range: int): Dict[str, Any]<br ALIGN="LEFT"/>analyze_resource_efficiency(): Dict[str, Any]<br ALIGN="LEFT"/>analyze_success_patterns(): Dict[str, Any]<br ALIGN="LEFT"/>generate_insights_report(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.traffic_interception_engine.AnalyzedTraffic" [color="black", fontcolor="black", label=<{AnalyzedTraffic|analysis_metadata : Dict[str, Any]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>is_license_related : bool<br ALIGN="LEFT"/>packet<br ALIGN="LEFT"/>patterns_matched : List[str]<br ALIGN="LEFT"/>protocol_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AnomalyDetector" [color="black", fontcolor="black", label=<{AnomalyDetector|baseline_mean : float<br ALIGN="LEFT"/>baseline_std : float<br ALIGN="LEFT"/>baseline_values : deque<br ALIGN="LEFT"/>calibrated : bool<br ALIGN="LEFT"/>metric_name : str<br ALIGN="LEFT"/>sensitivity : float<br ALIGN="LEFT"/>|add_baseline_value(value: float)<br ALIGN="LEFT"/>detect_anomaly(value: float): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.AnthropicBackend" [color="black", fontcolor="black", label=<{AnthropicBackend|client : NoneType<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.anthropic_repository.AnthropicRepository" [color="black", fontcolor="black", label=<{AnthropicRepository|<br ALIGN="LEFT"/>|authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.AntiAnalysisEngine" [color="black", fontcolor="black", label=<{AntiAnalysisEngine|debugger_detector<br ALIGN="LEFT"/>sandbox_detector<br ALIGN="LEFT"/>vm_detector<br ALIGN="LEFT"/>|detect_debugger()<br ALIGN="LEFT"/>detect_sandbox()<br ALIGN="LEFT"/>detect_virtual_environment()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [color="black", fontcolor="black", label=<{AntiAntiDebugSuite|active_bypasses : set<br ALIGN="LEFT"/>api_hooker<br ALIGN="LEFT"/>bypass_history : list<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>env_sanitizer<br ALIGN="LEFT"/>exception_handler<br ALIGN="LEFT"/>hw_protector<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>memory_patcher<br ALIGN="LEFT"/>peb_manipulator<br ALIGN="LEFT"/>statistics : dict<br ALIGN="LEFT"/>target_analyzer<br ALIGN="LEFT"/>timing_normalizer<br ALIGN="LEFT"/>|analyze_target(file_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>apply_all_bypasses(): List[BypassOperation]<br ALIGN="LEFT"/>apply_bypass(technique: AntiDebugTechnique): BypassOperation<br ALIGN="LEFT"/>apply_selective_bypasses(target_analysis: Dict[str, Any]): List[BypassOperation]<br ALIGN="LEFT"/>export_report(output_file: str)<br ALIGN="LEFT"/>get_report(): Dict[str, Any]<br ALIGN="LEFT"/>monitor_bypasses(): Dict[str, Any]<br ALIGN="LEFT"/>remove_bypasses(): List[str]<br ALIGN="LEFT"/>run_interactive_mode()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiDebugTechnique" [color="black", fontcolor="black", label=<{AntiDebugTechnique|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.app_context.AppContext" [color="black", fontcolor="black", label=<{AppContext|analysis_completed<br ALIGN="LEFT"/>analysis_failed<br ALIGN="LEFT"/>analysis_started<br ALIGN="LEFT"/>binary_loaded<br ALIGN="LEFT"/>binary_unloaded<br ALIGN="LEFT"/>model_loaded<br ALIGN="LEFT"/>model_unloaded<br ALIGN="LEFT"/>plugin_loaded<br ALIGN="LEFT"/>plugin_unloaded<br ALIGN="LEFT"/>project_closed<br ALIGN="LEFT"/>project_loaded<br ALIGN="LEFT"/>project_saved<br ALIGN="LEFT"/>settings_changed<br ALIGN="LEFT"/>task_completed<br ALIGN="LEFT"/>task_failed<br ALIGN="LEFT"/>task_progress<br ALIGN="LEFT"/>task_started<br ALIGN="LEFT"/>|add_to_session_history(action: str, details: Dict)<br ALIGN="LEFT"/>close_project()<br ALIGN="LEFT"/>complete_task(task_id: str, result: Any)<br ALIGN="LEFT"/>fail_analysis(analysis_type: str, error_message: str)<br ALIGN="LEFT"/>fail_task(task_id: str, error_message: str)<br ALIGN="LEFT"/>get_active_tasks(): Dict<br ALIGN="LEFT"/>get_all_settings(): Dict<br ALIGN="LEFT"/>get_analysis_results(analysis_type: Optional[str]): Dict<br ALIGN="LEFT"/>get_current_binary(): Optional[Dict]<br ALIGN="LEFT"/>get_full_state(): Dict<br ALIGN="LEFT"/>get_loaded_models(): Dict<br ALIGN="LEFT"/>get_loaded_plugins(): Dict<br ALIGN="LEFT"/>get_recent_files(): List[str]<br ALIGN="LEFT"/>get_recent_projects(): List[str]<br ALIGN="LEFT"/>get_session_history(): List[Dict]<br ALIGN="LEFT"/>get_setting(key: str, default: Any): Any<br ALIGN="LEFT"/>load_binary(file_path: str, metadata: Optional[Dict]): bool<br ALIGN="LEFT"/>load_project(project_path: str): bool<br ALIGN="LEFT"/>register_model(model_name: str, model_info: Dict)<br ALIGN="LEFT"/>register_plugin(plugin_name: str, plugin_info: Dict)<br ALIGN="LEFT"/>register_task(task_id: str, description: str)<br ALIGN="LEFT"/>reset_state()<br ALIGN="LEFT"/>save_project(project_path: str): bool<br ALIGN="LEFT"/>set_analysis_results(analysis_type: str, results: Dict)<br ALIGN="LEFT"/>set_setting(key: str, value: Any)<br ALIGN="LEFT"/>start_analysis(analysis_type: str, options: Optional[Dict])<br ALIGN="LEFT"/>unload_binary()<br ALIGN="LEFT"/>unregister_model(model_name: str)<br ALIGN="LEFT"/>unregister_plugin(plugin_name: str)<br ALIGN="LEFT"/>update_task_progress(task_id: str, progress: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_types.Architecture" [color="black", fontcolor="black", label=<{Architecture|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.Architecture" [color="black", fontcolor="black", label=<{Architecture|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.assembly_compiler.AssemblyCompiler" [color="black", fontcolor="black", label=<{AssemblyCompiler|arch_configs : dict<br ALIGN="LEFT"/>current_arch<br ALIGN="LEFT"/>gas_path<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ml_path<br ALIGN="LEFT"/>nasm_path<br ALIGN="LEFT"/>temp_files : list<br ALIGN="LEFT"/>|compile_assembly(assembly_code: str, architecture: Architecture, position_independent: bool): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.AsyncModelManager" [color="black", fontcolor="black", label=<{AsyncModelManager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>model_manager<br ALIGN="LEFT"/>thread_pool : dict<br ALIGN="LEFT"/>|load_model_async(model_id: str, callback: Callable)<br ALIGN="LEFT"/>predict_async(model_id: str, input_data: Any, callback: Callable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor.AsyncPerformanceMonitor" [color="black", fontcolor="black", label=<{AsyncPerformanceMonitor|async_operations : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>base_monitor<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|profile_async(operation_name: str)<br ALIGN="LEFT"/>profile_async_operation(operation_name: str, coro)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor_simple.AsyncPerformanceMonitor" [color="black", fontcolor="black", label=<{AsyncPerformanceMonitor|active_operations : dict<br ALIGN="LEFT"/>completed_operations : deque<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>|get_active_count(): int<br ALIGN="LEFT"/>monitor_operation(operation_name: str, coroutine)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.AuditEvent" [color="black", fontcolor="black", label=<{AuditEvent|description : str<br ALIGN="LEFT"/>details : dict<br ALIGN="LEFT"/>event_id : str<br ALIGN="LEFT"/>event_type<br ALIGN="LEFT"/>hostname<br ALIGN="LEFT"/>process_id<br ALIGN="LEFT"/>severity<br ALIGN="LEFT"/>source_ip : str<br ALIGN="LEFT"/>target : Optional[str]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>user<br ALIGN="LEFT"/>|calculate_hash(): str<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>to_json(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.AuditEventType" [color="black", fontcolor="black", label=<{AuditEventType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.AuditLogger" [color="black", fontcolor="black", label=<{AuditLogger|enable_encryption : bool<br ALIGN="LEFT"/>log_dir<br ALIGN="LEFT"/>max_file_size : int<br ALIGN="LEFT"/>rotation_count : int<br ALIGN="LEFT"/>|generate_report(start_time: datetime, end_time: datetime, output_file: Optional[Path]): str<br ALIGN="LEFT"/>log_binary_analysis(file_path: str, file_hash: str, protections: List[str], vulnerabilities: List[str])<br ALIGN="LEFT"/>log_credential_access(credential_type: str, purpose: str, success: bool)<br ALIGN="LEFT"/>log_event(event: AuditEvent)<br ALIGN="LEFT"/>log_exploit_attempt(target: str, exploit_type: str, payload: Optional[str], success: bool, error: Optional[str])<br ALIGN="LEFT"/>log_tool_execution(tool_name: str, command: str, success: bool, output: Optional[str], error: Optional[str])<br ALIGN="LEFT"/>log_vm_operation(operation: str, vm_name: str, success: bool, error: Optional[str])<br ALIGN="LEFT"/>search_events(start_time: Optional[datetime], end_time: Optional[datetime], event_types: Optional[List[AuditEventType]], severity: Optional[AuditSeverity], user: Optional[str], target: Optional[str]): List[Dict[str, Any]]<br ALIGN="LEFT"/>verify_log_integrity(log_file: Path): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.AuditSeverity" [color="black", fontcolor="black", label=<{AuditSeverity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.AugmentationConfig" [color="black", fontcolor="black", label=<{AugmentationConfig|augmentation_probability : float<br ALIGN="LEFT"/>augmentations_per_sample : int<br ALIGN="LEFT"/>max_synonyms : int<br ALIGN="LEFT"/>preserve_labels : bool<br ALIGN="LEFT"/>synonym_threshold : float<br ALIGN="LEFT"/>techniques : Optional[List[str]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationManager" [color="black", fontcolor="black", label=<{AuthenticationManager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>signing_keys : dict<br ALIGN="LEFT"/>token_cache : dict<br ALIGN="LEFT"/>|extract_bearer_token(auth_header: str): Optional[str]<br ALIGN="LEFT"/>generate_license_token(provider: CloudProvider, auth_type: AuthenticationType): str<br ALIGN="LEFT"/>modify_api_key(api_key: str): str<br ALIGN="LEFT"/>modify_jwt_token(token: str, modifications: Dict[str, Any]): str<br ALIGN="LEFT"/>parse_jwt_token(token: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationType" [color="black", fontcolor="black", label=<{AuthenticationType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.AutoCleanupResource" [color="black", fontcolor="black", label=<{AutoCleanupResource|resource_manager<br ALIGN="LEFT"/>resource_type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.AutodeskProtocolHandler" [color="black", fontcolor="black", label=<{AutodeskProtocolHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_response(context: ResponseContext): bytes<br ALIGN="LEFT"/>parse_request(data: bytes): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.AutomatedExploitChainBuilder" [color="black", fontcolor="black", label=<{AutomatedExploitChainBuilder|built_chains : Dict[str, ExploitChain]<br ALIGN="LEFT"/>chain_cache : Dict[str, str]<br ALIGN="LEFT"/>chain_framework<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>primitive_lib<br ALIGN="LEFT"/>safety_system<br ALIGN="LEFT"/>|build_exploit_chain(vulnerability: Vulnerability, requirements: Optional[Dict[str, Any]]): Optional[ExploitChain]<br ALIGN="LEFT"/>get_chain_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>validate_chain(chain_id: str): ChainValidationResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.autonomous_agent.AutonomousAgent" [color="black", fontcolor="black", label=<{AutonomousAgent|agent_id<br ALIGN="LEFT"/>cli_interface : NoneType<br ALIGN="LEFT"/>conversation_history : list<br ALIGN="LEFT"/>current_task : NoneType<br ALIGN="LEFT"/>docker_client<br ALIGN="LEFT"/>generated_scripts : list<br ALIGN="LEFT"/>iteration_count : int<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>orchestrator : NoneType<br ALIGN="LEFT"/>qemu_manager : NoneType<br ALIGN="LEFT"/>refinement_history : list<br ALIGN="LEFT"/>script_generator<br ALIGN="LEFT"/>test_results : list<br ALIGN="LEFT"/>workflow_state : ANALYZING, COMPLETED, DEPLOYING, ERROR, GENERATING, IDLE, TESTING<br ALIGN="LEFT"/>|execute_autonomous_task(task_config: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_conversation_history(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>process_request(user_request: str): Dict[str, Any]<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>save_session_data(output_path: Optional[str]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_bert_model.BERTModel" [color="black", fontcolor="black", label=<{BERTModel|hidden_size<br ALIGN="LEFT"/>max_position_embeddings : int<br ALIGN="LEFT"/>mlm_head : Sequential<br ALIGN="LEFT"/>pooler : Linear<br ALIGN="LEFT"/>position_embedding : Embedding<br ALIGN="LEFT"/>token_embedding : Embedding<br ALIGN="LEFT"/>token_type_embedding : Embedding<br ALIGN="LEFT"/>transformer : TransformerEncoder<br ALIGN="LEFT"/>|forward(input_ids, token_type_ids, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.memory_patcher._get_wintypes.MockWintypes.BOOL" [color="black", fontcolor="black", label=<{BOOL|value : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.BackgroundLoader" [color="black", fontcolor="black", label=<{BackgroundLoader|cache<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>load_queue : List[Tuple[int, int]]<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>queue_lock : lock<br ALIGN="LEFT"/>region_loaded<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>|queue_load(offset: int, size: int)<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.BackgroundModelLoader" [color="black", fontcolor="black", label=<{BackgroundModelLoader|active_tasks : Dict[str, LoadingTask]<br ALIGN="LEFT"/>completed_tasks : Dict[str, LoadingTask]<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_concurrent_loads : int<br ALIGN="LEFT"/>pending_tasks : List[LoadingTask]<br ALIGN="LEFT"/>shutdown_event : Event<br ALIGN="LEFT"/>task_queue : PriorityQueue<br ALIGN="LEFT"/>worker_threads : List[threading.Thread]<br ALIGN="LEFT"/>|cancel_task(model_id: str): bool<br ALIGN="LEFT"/>get_all_tasks(): Dict[str, LoadingTask]<br ALIGN="LEFT"/>get_loading_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>get_task_status(model_id: str): Optional[LoadingTask]<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>submit_loading_task(model_id: str, backend_class: type, config: 'LLMConfig', priority: int, callback: Optional[ProgressCallback]): LoadingTask<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.BaseAgent" [color="black", fontcolor="black", label=<{BaseAgent|active : bool<br ALIGN="LEFT"/>agent_id : str<br ALIGN="LEFT"/>busy : bool<br ALIGN="LEFT"/>capabilities : List[AgentCapability]<br ALIGN="LEFT"/>collaboration_system : Optional['MultiAgentSystem']<br ALIGN="LEFT"/>current_task : NoneType, Optional[AgentTask]<br ALIGN="LEFT"/>knowledge_base : Dict[str, Any]<br ALIGN="LEFT"/>last_activity : datetime<br ALIGN="LEFT"/>learned_patterns : List[str]<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>message_queue : Queue<br ALIGN="LEFT"/>message_thread : Thread<br ALIGN="LEFT"/>response_waiters : Dict[str, Queue]<br ALIGN="LEFT"/>role<br ALIGN="LEFT"/>tasks_completed : int<br ALIGN="LEFT"/>tasks_failed : int<br ALIGN="LEFT"/>total_execution_time : float<br ALIGN="LEFT"/>trusted_agents : Set[str]<br ALIGN="LEFT"/>|<I>execute_task</I>(task: AgentTask): Dict[str, Any]<br ALIGN="LEFT"/>get_agent_status(): Dict[str, Any]<br ALIGN="LEFT"/>share_knowledge(knowledge: Dict[str, Any], target_agents: Optional[List[str]])<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.base_analyzer.BaseAnalyzer" [color="black", fontcolor="black", label=<{BaseAnalyzer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|finalize_analysis_result(result: Dict[str, Any], start_time: float, success_message: str, count_key: str): Dict[str, Any]<br ALIGN="LEFT"/>handle_analysis_error(result: Dict[str, Any], error: Exception, start_time: float): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.base_c2.BaseC2" [color="black", fontcolor="black", label=<{BaseC2|logger : NoneType, RootLogger<br ALIGN="LEFT"/>protocols : list<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|initialize_protocols(protocols_config: List[Dict[str, Any]], encryption_manager: Any): None<br ALIGN="LEFT"/>prepare_start(component_name: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.base_detector.BaseDetector" [color="black", fontcolor="black", label=<{BaseDetector|detection_methods : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|calculate_detection_score(detections: Dict[str, Any], strong_methods: List[str], medium_methods: List[str]): int<br ALIGN="LEFT"/><I>get_aggressive_methods</I>(): List[str]<br ALIGN="LEFT"/><I>get_detection_type</I>(): str<br ALIGN="LEFT"/>get_running_processes(): Tuple[str, List[str]]<br ALIGN="LEFT"/>run_detection_loop(aggressive: bool, aggressive_methods: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [color="black", fontcolor="black", label=<{BaseDongleEmulator|active : bool<br ALIGN="LEFT"/>api_handlers : dict<br ALIGN="LEFT"/>crypto<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>memory<br ALIGN="LEFT"/>spec<br ALIGN="LEFT"/>|decrypt_data(data: bytes, algorithm: str): bytes<br ALIGN="LEFT"/>encrypt_data(data: bytes, algorithm: str): bytes<br ALIGN="LEFT"/>get_dongle_info(): Dict[str, Any]<br ALIGN="LEFT"/>process_challenge(challenge: bytes): bytes<br ALIGN="LEFT"/>read_memory(address: int, length: int): bytes<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>write_memory(address: int, data: bytes): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.base_exploitation.BaseExploitation" [color="black", fontcolor="black", label=<{BaseExploitation|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|execute_command(command: List[str], shell: bool, capture_output: bool, text: bool, timeout: Optional[int]): Tuple[int, str, str]<br ALIGN="LEFT"/>execute_ssh_command(host: str, username: str, command: str, password: Optional[str], key_file: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>execute_sudo_command(command: str, password: Optional[str], use_stdin: bool): Tuple[int, str, str]<br ALIGN="LEFT"/>handle_result_error(result: Dict[str, Any], error: Exception): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.base_network_analyzer.BaseNetworkAnalyzer" [color="black", fontcolor="black", label=<{BaseNetworkAnalyzer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|create_packet_handler(scapy_module: Any, is_running_check: Callable[[], bool], process_packet_func: Callable[[Any, Any, Any], None]): Callable<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.base_persistence.BasePersistence" [color="black", fontcolor="black", label=<{BasePersistence|logger : NoneType, RootLogger<br ALIGN="LEFT"/>platform<br ALIGN="LEFT"/>|cleanup_service_common_pattern(service_name: str, service_commands: Dict[str, str], service_path: Optional[str]): bool<br ALIGN="LEFT"/>create_success_result(details: Dict[str, Any], cleanup_info: Dict[str, Any], additional_details: Optional[Dict[str, Any]]): Tuple[bool, Dict[str, Any], Dict[str, Any]]<br ALIGN="LEFT"/>establish_persistence(payload_path: str, method: str, options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/><I>get_default_method</I>(): str<br ALIGN="LEFT"/>handle_establishment_error(result: Dict[str, Any], error: Exception): Dict[str, Any]<br ALIGN="LEFT"/>handle_persistence_error(e: Exception, details: Dict[str, Any], cleanup_info: Dict[str, Any]): Tuple[bool, Dict[str, Any], Dict[str, Any]]<br ALIGN="LEFT"/>handle_persistence_method_completion(result, details: Dict[str, Any], cleanup_info: Dict[str, Any]): Tuple[bool, Dict, Dict]<br ALIGN="LEFT"/>handle_remove_persistence_error(error: Exception): bool<br ALIGN="LEFT"/>handle_subprocess_result(result, details: Dict[str, Any], cleanup_info: Dict[str, Any]): Tuple[bool, Dict[str, Any], Dict[str, Any]]<br ALIGN="LEFT"/>init_persistence_data(): Tuple[Dict[str, Any], Dict[str, Any]]<br ALIGN="LEFT"/><I>list_available_methods</I>(): list<br ALIGN="LEFT"/>validate_session(session_id: str, active_sessions: Dict[str, Any], result: Dict[str, Any]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.plugin_base.BasePlugin" [color="black", fontcolor="black", label=<{BasePlugin|author<br ALIGN="LEFT"/>categories<br ALIGN="LEFT"/>config_manager<br ALIGN="LEFT"/>description<br ALIGN="LEFT"/>metadata<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>version<br ALIGN="LEFT"/>|calculate_entropy(data: bytes): float<br ALIGN="LEFT"/><I>cleanup</I>(): None<br ALIGN="LEFT"/>get_metadata(): Dict[str, Any]<br ALIGN="LEFT"/>get_status(): str<br ALIGN="LEFT"/><I>run</I>(): Dict[str, Any]<br ALIGN="LEFT"/>validate_binary(binary_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.communication_protocols.BaseProtocol" [color="black", fontcolor="black", label=<{BaseProtocol|config : dict<br ALIGN="LEFT"/>connected : bool<br ALIGN="LEFT"/>connection : NoneType<br ALIGN="LEFT"/>connection_count<br ALIGN="LEFT"/>connection_lock : lock<br ALIGN="LEFT"/>encryption_manager<br ALIGN="LEFT"/>host : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>message_handlers : Dict[str, Callable]<br ALIGN="LEFT"/>port : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|connect(): bool<br ALIGN="LEFT"/>disconnect()<br ALIGN="LEFT"/>send_message(message: Dict[str, Any]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.base_snapshot_handler.BaseSnapshotHandler" [color="black", fontcolor="black", label=<{BaseSnapshotHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_snapshots : int<br ALIGN="LEFT"/>snapshot_index : int<br ALIGN="LEFT"/>snapshots : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>|compare_snapshots_base(snapshot1: str, snapshot2: str): Dict[str, Any]<br ALIGN="LEFT"/>get_snapshot_info(name: str): Dict[str, Any]<br ALIGN="LEFT"/>has_snapshot(name: str): bool<br ALIGN="LEFT"/>list_snapshots(): list<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.base_tab.BaseTab" [color="black", fontcolor="black", label=<{BaseTab|app_context<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>main_window<br ALIGN="LEFT"/>task_manager<br ALIGN="LEFT"/>|clear_layout()<br ALIGN="LEFT"/>lazy_load_content()<br ALIGN="LEFT"/>log_activity(message)<br ALIGN="LEFT"/><I>setup_content</I>()<br ALIGN="LEFT"/>setup_loading_ui()<br ALIGN="LEFT"/>submit_callable(func, args, kwargs, description)<br ALIGN="LEFT"/>submit_task(task)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.base_tab_original.BaseTab" [color="black", fontcolor="black", label=<{BaseTab|app_context<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>main_window<br ALIGN="LEFT"/>shared_context : dict<br ALIGN="LEFT"/>task_manager<br ALIGN="LEFT"/>|clear_layout()<br ALIGN="LEFT"/>lazy_load_content()<br ALIGN="LEFT"/>log_activity(message)<br ALIGN="LEFT"/><I>setup_content</I>()<br ALIGN="LEFT"/>setup_loading_ui()<br ALIGN="LEFT"/>submit_callable(func, args, kwargs, description)<br ALIGN="LEFT"/>submit_task(task)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.task_manager.BaseTask" [color="black", fontcolor="black", label=<{BaseTask|description : str<br ALIGN="LEFT"/>end_time : NoneType<br ALIGN="LEFT"/>error : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress : int<br ALIGN="LEFT"/>result : NoneType<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>start_time : NoneType<br ALIGN="LEFT"/>status : PENDING<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>|cancel()<br ALIGN="LEFT"/>emit_progress(percentage: int, message: str)<br ALIGN="LEFT"/><I>execute</I>(): Any<br ALIGN="LEFT"/>is_cancelled(): bool<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.base_dialog.BaseTemplateDialog" [color="black", fontcolor="black", label=<{BaseTemplateDialog|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.base_patcher.BaseWindowsPatcher" [color="black", fontcolor="black", label=<{BaseWindowsPatcher|CREATE_NO_WINDOW : int<br ALIGN="LEFT"/>CREATE_SUSPENDED : int<br ALIGN="LEFT"/>MEM_COMMIT : int<br ALIGN="LEFT"/>MEM_RESERVE : int<br ALIGN="LEFT"/>PAGE_EXECUTE_READWRITE : int<br ALIGN="LEFT"/>THREAD_GET_CONTEXT : int<br ALIGN="LEFT"/>THREAD_SET_CONTEXT : int<br ALIGN="LEFT"/>THREAD_SUSPEND_RESUME : int<br ALIGN="LEFT"/>kernel32 : NoneType, WinDLL<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ntdll : NoneType, WinDLL<br ALIGN="LEFT"/>requires_ntdll : bool<br ALIGN="LEFT"/>|create_and_handle_suspended_process(target_exe: str, logger_instance): Tuple[bool, Any, Any]<br ALIGN="LEFT"/><I>get_required_libraries</I>(): list<br ALIGN="LEFT"/>handle_suspended_process_result(result, logger_instance)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisResult" [color="black", fontcolor="black", label=<{BatchAnalysisResult|analysis_time : float<br ALIGN="LEFT"/>architecture : str<br ALIGN="LEFT"/>confidence_score : float<br ALIGN="LEFT"/>entropy : float<br ALIGN="LEFT"/>error_message : str<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_size : int<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>icp_detections : int<br ALIGN="LEFT"/>is_packed : bool<br ALIGN="LEFT"/>is_protected : bool<br ALIGN="LEFT"/>protections : List[Dict[str, Any]]<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisWidget" [color="black", fontcolor="black", label=<{BatchAnalysisWidget|analysis_requested<br ALIGN="LEFT"/>clear_btn<br ALIGN="LEFT"/>deep_scan_cb<br ALIGN="LEFT"/>details_tabs<br ALIGN="LEFT"/>error_log_text<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>file_count_label<br ALIGN="LEFT"/>file_filter_combo<br ALIGN="LEFT"/>file_selected<br ALIGN="LEFT"/>max_threads_spin<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>protections_text<br ALIGN="LEFT"/>results : List[BatchAnalysisResult]<br ALIGN="LEFT"/>results_table<br ALIGN="LEFT"/>select_files_btn<br ALIGN="LEFT"/>select_folder_btn<br ALIGN="LEFT"/>selected_files : List[str], list<br ALIGN="LEFT"/>start_btn<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>stop_btn<br ALIGN="LEFT"/>summary_text<br ALIGN="LEFT"/>worker : NoneType, Optional[BatchAnalysisWorker]<br ALIGN="LEFT"/>|add_files_from_list(file_paths: List[str])<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>export_results()<br ALIGN="LEFT"/>get_analysis_results(): List[BatchAnalysisResult]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>select_files()<br ALIGN="LEFT"/>select_folder()<br ALIGN="LEFT"/>start_analysis()<br ALIGN="LEFT"/>stop_analysis()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisWorker" [color="black", fontcolor="black", label=<{BatchAnalysisWorker|analysis_finished<br ALIGN="LEFT"/>cancelled : bool<br ALIGN="LEFT"/>deep_scan : bool<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>file_completed<br ALIGN="LEFT"/>file_paths : List[str]<br ALIGN="LEFT"/>max_workers : int<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>unified_engine : NoneType<br ALIGN="LEFT"/>|cancel()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_batch_tester.BatchTestReport" [color="black", fontcolor="black", label=<{BatchTestReport|duration : float<br ALIGN="LEFT"/>models_tested : List[str]<br ALIGN="LEFT"/>results : List[TestResult]<br ALIGN="LEFT"/>summary : Dict[str, Any]<br ALIGN="LEFT"/>test_cases : List[TestCase]<br ALIGN="LEFT"/>test_suite_id : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.BayesianAnalyzer" [color="black", fontcolor="black", label=<{BayesianAnalyzer|prior_alpha : float<br ALIGN="LEFT"/>prior_beta : float<br ALIGN="LEFT"/>|credible_interval(successes: int, failures: int, confidence: float): Tuple[float, float]<br ALIGN="LEFT"/>posterior_mean(successes: int, failures: int): float<br ALIGN="LEFT"/>posterior_probability(successes: int, failures: int, threshold: float): float<br ALIGN="LEFT"/>update_posterior(successes: int, failures: int): Tuple[float, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.beacon_manager.BeaconManager" [color="black", fontcolor="black", label=<{BeaconManager|adaptive_intervals : dict<br ALIGN="LEFT"/>beacon_data : defaultdict<br ALIGN="LEFT"/>default_beacon_interval : int<br ALIGN="LEFT"/>health_check_interval : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_missed_beacons : int<br ALIGN="LEFT"/>performance_metrics : defaultdict<br ALIGN="LEFT"/>session_health : dict<br ALIGN="LEFT"/>sessions : dict<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|check_inactive_sessions(): List[str]<br ALIGN="LEFT"/>cleanup_old_data(max_age_hours: int)<br ALIGN="LEFT"/>get_active_sessions(): List[str]<br ALIGN="LEFT"/>get_beacon_history(session_id: str, limit: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_recommended_interval(session_id: str): int<br ALIGN="LEFT"/>get_session_status(session_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>register_session(session_id: str, initial_config: Dict[str, Any])<br ALIGN="LEFT"/>unregister_session(session_id: str)<br ALIGN="LEFT"/>update_beacon(session_id: str, beacon_data: Dict[str, Any])<br ALIGN="LEFT"/>update_beacon_interval(session_id: str, new_interval: int)<br ALIGN="LEFT"/>update_statistics()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.binary_analyzer.BinaryAnalyzer" [color="black", fontcolor="black", label=<{BinaryAnalyzer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>magic_bytes : dict<br ALIGN="LEFT"/>|analyze(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.simconcolic.BinaryAnalyzer" [color="black", fontcolor="black", label=<{BinaryAnalyzer|all_states<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>hooks : Dict[int, List[Callable]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>plugins : List[Plugin]<br ALIGN="LEFT"/>workspace_url : Optional[str]<br ALIGN="LEFT"/>|add_hook(address: int, callback: Callable)<br ALIGN="LEFT"/>register_plugin(plugin: Plugin)<br ALIGN="LEFT"/>run(timeout: Optional[int], procs: int)<br ALIGN="LEFT"/>set_exec_timeout(timeout: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.BinaryAnalyzer" [color="black", fontcolor="black", label=<{BinaryAnalyzer|architecture : ARM64, UNKNOWN, X64, X86<br ALIGN="LEFT"/>data : bytes<br ALIGN="LEFT"/>entry_point : int<br ALIGN="LEFT"/>is_elf : bool<br ALIGN="LEFT"/>is_macho : bool<br ALIGN="LEFT"/>is_pe : bool<br ALIGN="LEFT"/>sections : list<br ALIGN="LEFT"/>size<br ALIGN="LEFT"/>|find_all_occurrences(pattern: bytes): List[int]<br ALIGN="LEFT"/>get_context(offset: int, size: int): bytes<br ALIGN="LEFT"/>is_code_section(offset: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.BinaryChunker" [color="black", fontcolor="black", label=<{BinaryChunker|memory_manager<br ALIGN="LEFT"/>|analyze_chunk_parallel(chunks: List[Dict[str, Any]], analysis_func, max_workers: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>chunk_binary(file_path: str, chunk_size: Optional[int]): List[Dict[str, Any]]<br ALIGN="LEFT"/>read_chunk(chunk_info: Dict[str, Any]): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.ai_bridge.BinaryContextBuilder" [color="black", fontcolor="black", label=<{BinaryContextBuilder|<br ALIGN="LEFT"/>|build_context(binary_data: bytes, offset: int, size: int, include_entropy: bool, include_strings: bool, include_structure_hints: bool): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.binary_differ.BinaryDiffer" [color="black", fontcolor="black", label=<{BinaryDiffer|analysis_cache : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>security_functions : dict<br ALIGN="LEFT"/>security_mitigations : dict<br ALIGN="LEFT"/>vuln_patterns : dict<br ALIGN="LEFT"/>|analyze_patch(patch_file: str, target_binary: str): Dict[str, Any]<br ALIGN="LEFT"/>clear_analysis_cache()<br ALIGN="LEFT"/>compare_binaries(old_binary: str, new_binary: str, analysis_level: str): Dict[str, Any]<br ALIGN="LEFT"/>export_analysis(result: Dict[str, Any], output_file: str, format: str): bool<br ALIGN="LEFT"/>find_similar_functions(binary_path: str, target_function: bytes, similarity_threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_analysis_cache(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.BinaryFileModel" [color="black", fontcolor="black", label=<{BinaryFileModel|file_path : Path<br ALIGN="LEFT"/>file_size<br ALIGN="LEFT"/>|<I>get_sections</I>(): List[SectionInfo]<br ALIGN="LEFT"/><I>get_structures</I>(): List[FileStructure]<br ALIGN="LEFT"/><I>offset_to_rva</I>(offset: int): Optional[int]<br ALIGN="LEFT"/><I>parse_file</I>(): None<br ALIGN="LEFT"/><I>rva_to_offset</I>(rva: int): Optional[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.BinaryFileWatcher" [color="black", fontcolor="black", label=<{BinaryFileWatcher|callback : Callable<br ALIGN="LEFT"/>debounce_delay : float<br ALIGN="LEFT"/>last_modified : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>watched_files : Set[str]<br ALIGN="LEFT"/>|on_modified(event)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.binary_patcher_plugin.BinaryPatch" [color="black", fontcolor="black", label=<{BinaryPatch|description : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>original_bytes : bytes<br ALIGN="LEFT"/>patch_type : str<br ALIGN="LEFT"/>patched_bytes : bytes<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.binary_patcher_plugin.BinaryPatcherPlugin" [color="black", fontcolor="black", label=<{BinaryPatcherPlugin|logger : NoneType, RootLogger<br ALIGN="LEFT"/>patches : List[BinaryPatch]<br ALIGN="LEFT"/>|analyze(binary_path)<br ALIGN="LEFT"/>patch(binary_path, patch_data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.base_dialog.BinarySelectionDialog" [color="black", fontcolor="black", label=<{BinarySelectionDialog|file_path_edit<br ALIGN="LEFT"/>selected_binary<br ALIGN="LEFT"/>|accept_selection()<br ALIGN="LEFT"/>browse_file()<br ALIGN="LEFT"/>get_selected_binary()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.binary_similarity_search.BinarySimilaritySearch" [color="black", fontcolor="black", label=<{BinarySimilaritySearch|database : dict<br ALIGN="LEFT"/>database_path : str<br ALIGN="LEFT"/>feature_extractors : list<br ALIGN="LEFT"/>hash_functions : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|add_binary(binary_path: str, cracking_patterns: Optional[List[str]]): bool<br ALIGN="LEFT"/>find_similar(binary_path: str, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_database_stats(): Dict[str, Any]<br ALIGN="LEFT"/>load_database(database_path: str): bool<br ALIGN="LEFT"/>remove_binary(binary_path: str): bool<br ALIGN="LEFT"/>search_similar_binaries(binary_path: str, threshold: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.similarity_search_dialog.BinarySimilaritySearchDialog" [color="black", fontcolor="black", label=<{BinarySimilaritySearchDialog|apply_pattern_btn<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>database_path<br ALIGN="LEFT"/>db_info_label : NoneType<br ALIGN="LEFT"/>patterns_view : NoneType<br ALIGN="LEFT"/>results_table : NoneType<br ALIGN="LEFT"/>search_engine : NoneType<br ALIGN="LEFT"/>search_thread : NoneType<br ALIGN="LEFT"/>similar_binaries : List[Dict[str, Any]]<br ALIGN="LEFT"/>status_label : NoneType<br ALIGN="LEFT"/>threshold_label : NoneType<br ALIGN="LEFT"/>threshold_slider<br ALIGN="LEFT"/>|add_to_database(): None<br ALIGN="LEFT"/>apply_selected_pattern(): None<br ALIGN="LEFT"/>get_search_results(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_selected_pattern(): Optional[str]<br ALIGN="LEFT"/>init_ui(): None<br ALIGN="LEFT"/>load_database_info(): None<br ALIGN="LEFT"/>result_selected(): None<br ALIGN="LEFT"/>search_similar_binaries(): None<br ALIGN="LEFT"/>show_search_results(results: List[Dict[str, Any]]): None<br ALIGN="LEFT"/>update_threshold_label(value: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.Breakpoint" [color="black", fontcolor="black", label=<{Breakpoint|condition : Optional[str]<br ALIGN="LEFT"/>enabled : bool<br ALIGN="LEFT"/>file : str<br ALIGN="LEFT"/>function : Optional[str]<br ALIGN="LEFT"/>hit_count : int<br ALIGN="LEFT"/>id : int<br ALIGN="LEFT"/>ignore_count : int<br ALIGN="LEFT"/>line : Optional[int]<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.BreakpointType" [color="black", fontcolor="black", label=<{BreakpointType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.BusinessLogicPattern" [color="black", fontcolor="black", label=<{BusinessLogicPattern|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.shared.bypass_config.BypassConfig" [color="black", fontcolor="black", label=<{BypassConfig|BYPASS_TYPES : dict<br ALIGN="LEFT"/>|analyze_bypass_capabilities(target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_available_bypasses(): List[str]<br ALIGN="LEFT"/>get_bypass_info(bypass_type: str): Dict[str, Any]<br ALIGN="LEFT"/>get_bypasses_by_difficulty(difficulty: str): List[str]<br ALIGN="LEFT"/>get_recommended_bypasses(target_info: Dict[str, Any], min_reliability: int): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.protection_knowledge_base.BypassDifficulty" [color="black", fontcolor="black", label=<{BypassDifficulty|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.bypass_engine.BypassEngine" [color="black", fontcolor="black", label=<{BypassEngine|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze_bypass_capabilities(target_info)<br ALIGN="LEFT"/>get_available_bypasses()<br ALIGN="LEFT"/>get_bypass_info(bypass_type)<br ALIGN="LEFT"/>get_recommended_bypasses(target_info, min_reliability)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.BypassEngine" [color="black", fontcolor="black", label=<{BypassEngine|cfi_bypass<br ALIGN="LEFT"/>|analyze_bypass_capabilities(target_info)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.BypassOperation" [color="black", fontcolor="black", label=<{BypassOperation|description : str<br ALIGN="LEFT"/>details : str<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>result<br ALIGN="LEFT"/>technique<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassOperation" [color="black", fontcolor="black", label=<{BypassOperation|auth_type<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>modified_response : bytes<br ALIGN="LEFT"/>original_response : Optional[bytes]<br ALIGN="LEFT"/>processing_time : float<br ALIGN="LEFT"/>provider<br ALIGN="LEFT"/>request_id : str<br ALIGN="LEFT"/>request_type<br ALIGN="LEFT"/>result<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.BypassResult" [color="black", fontcolor="black", label=<{BypassResult|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassResult" [color="black", fontcolor="black", label=<{BypassResult|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.frida_bypass_wizard.BypassStrategy" [color="black", fontcolor="black", label=<{BypassStrategy|applied : bool<br ALIGN="LEFT"/>dependencies : list<br ALIGN="LEFT"/>failure_indicators : list<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>protection_type<br ALIGN="LEFT"/>scripts : List[str]<br ALIGN="LEFT"/>success : NoneType<br ALIGN="LEFT"/>success_indicators : list<br ALIGN="LEFT"/>|add_failure_indicator(indicator: Dict[str, Any])<br ALIGN="LEFT"/>add_success_indicator(indicator: Dict[str, Any])<br ALIGN="LEFT"/>can_apply(completed_protections: Set[ProtectionType]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.protection_knowledge_base.BypassTechnique" [color="black", fontcolor="black", label=<{BypassTechnique|description : str<br ALIGN="LEFT"/>difficulty<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>risks : List[str]<br ALIGN="LEFT"/>success_rate : float<br ALIGN="LEFT"/>time_estimate : str<br ALIGN="LEFT"/>tools_required : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_client.C2Client" [color="black", fontcolor="black", label=<{C2Client|auto_gather_info<br ALIGN="LEFT"/>auto_screenshot<br ALIGN="LEFT"/>beacon_interval<br ALIGN="LEFT"/>bytes_received : int<br ALIGN="LEFT"/>bytes_sent : int<br ALIGN="LEFT"/>client_id<br ALIGN="LEFT"/>command_queue : Queue<br ALIGN="LEFT"/>commands_executed : int<br ALIGN="LEFT"/>config : Dict[str, Any]<br ALIGN="LEFT"/>connected : bool<br ALIGN="LEFT"/>connection : NoneType<br ALIGN="LEFT"/>current_protocol<br ALIGN="LEFT"/>encryption_key<br ALIGN="LEFT"/>heartbeat_interval<br ALIGN="LEFT"/>jitter_enabled<br ALIGN="LEFT"/>jitter_percent<br ALIGN="LEFT"/>last_heartbeat : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_jitter<br ALIGN="LEFT"/>max_reconnect_attempts<br ALIGN="LEFT"/>protocol<br ALIGN="LEFT"/>reconnect_attempts : int<br ALIGN="LEFT"/>result_queue : Queue<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server_host<br ALIGN="LEFT"/>server_port<br ALIGN="LEFT"/>session_id<br ALIGN="LEFT"/>session_start_time<br ALIGN="LEFT"/>sleep_time<br ALIGN="LEFT"/>use_encryption<br ALIGN="LEFT"/>user_agent<br ALIGN="LEFT"/>verify_ssl<br ALIGN="LEFT"/>worker_thread : NoneType<br ALIGN="LEFT"/>|get_client_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.c2_management_dialog.C2ManagementDialog" [color="black", fontcolor="black", label=<{C2ManagementDialog|active_connections : list<br ALIGN="LEFT"/>add_file_btn<br ALIGN="LEFT"/>beacon_interval_spin<br ALIGN="LEFT"/>clear_logs_btn<br ALIGN="LEFT"/>clear_upload_btn<br ALIGN="LEFT"/>command_executed<br ALIGN="LEFT"/>command_input<br ALIGN="LEFT"/>command_output<br ALIGN="LEFT"/>command_tab<br ALIGN="LEFT"/>data_transferred_label<br ALIGN="LEFT"/>delete_remote_btn<br ALIGN="LEFT"/>details_layout<br ALIGN="LEFT"/>details_text<br ALIGN="LEFT"/>dns_check<br ALIGN="LEFT"/>dns_port_spin<br ALIGN="LEFT"/>download_btn<br ALIGN="LEFT"/>export_logs_btn<br ALIGN="LEFT"/>file_tab<br ALIGN="LEFT"/>https_check<br ALIGN="LEFT"/>https_port_spin<br ALIGN="LEFT"/>interact_btn<br ALIGN="LEFT"/>jitter_spin<br ALIGN="LEFT"/>keylog_btn<br ALIGN="LEFT"/>kill_session_btn<br ALIGN="LEFT"/>listen_addr_edit<br ALIGN="LEFT"/>log_display<br ALIGN="LEFT"/>log_filter_combo<br ALIGN="LEFT"/>logs_tab<br ALIGN="LEFT"/>processes_btn<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>remote_tree<br ALIGN="LEFT"/>screenshot_btn<br ALIGN="LEFT"/>selected_session : NoneType<br ALIGN="LEFT"/>server_tab<br ALIGN="LEFT"/>server_thread : NoneType<br ALIGN="LEFT"/>servers : dict<br ALIGN="LEFT"/>session_combo<br ALIGN="LEFT"/>session_selected<br ALIGN="LEFT"/>sessions_count_label<br ALIGN="LEFT"/>sessions_tab<br ALIGN="LEFT"/>sessions_table<br ALIGN="LEFT"/>start_server_btn<br ALIGN="LEFT"/>stats_layout<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>stop_server_btn<br ALIGN="LEFT"/>sysinfo_btn<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>task_table<br ALIGN="LEFT"/>tcp_check<br ALIGN="LEFT"/>tcp_port_spin<br ALIGN="LEFT"/>total_connections_label<br ALIGN="LEFT"/>transfer_table<br ALIGN="LEFT"/>upload_btn<br ALIGN="LEFT"/>upload_list<br ALIGN="LEFT"/>uptime_label<br ALIGN="LEFT"/>|add_file_to_upload()<br ALIGN="LEFT"/>add_session(session: Dict[str, Any])<br ALIGN="LEFT"/>clear_logs()<br ALIGN="LEFT"/>clear_upload_list()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>create_command_tab()<br ALIGN="LEFT"/>create_file_manager_tab()<br ALIGN="LEFT"/>create_logs_tab()<br ALIGN="LEFT"/>create_server_tab()<br ALIGN="LEFT"/>create_sessions_tab()<br ALIGN="LEFT"/>delete_remote_file()<br ALIGN="LEFT"/>display_session_details(session: Dict[str, Any])<br ALIGN="LEFT"/>download_file()<br ALIGN="LEFT"/>execute_command(command: str, session_id: str)<br ALIGN="LEFT"/>execute_custom_command()<br ALIGN="LEFT"/>export_logs()<br ALIGN="LEFT"/>filter_logs(filter_type: str)<br ALIGN="LEFT"/>finalize_widget_layout(widget, layout)<br ALIGN="LEFT"/>format_file_size(size_bytes: int): str<br ALIGN="LEFT"/>interact_with_session()<br ALIGN="LEFT"/>kill_session()<br ALIGN="LEFT"/>log_message(message: str, level: str)<br ALIGN="LEFT"/>on_server_error(error: str)<br ALIGN="LEFT"/>on_server_status_update(status: str)<br ALIGN="LEFT"/>on_session_selected()<br ALIGN="LEFT"/>on_session_update(update: Dict[str, Any])<br ALIGN="LEFT"/>refresh_sessions()<br ALIGN="LEFT"/>remove_session(session_id: str)<br ALIGN="LEFT"/>send_command_to_session(session_id: str, command: Dict[str, Any]): bool<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_session_context_menu(position)<br ALIGN="LEFT"/>start_server()<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>update_session_beacon(session_id: str)<br ALIGN="LEFT"/>update_statistics()<br ALIGN="LEFT"/>upload_files()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_manager.C2Manager" [color="black", fontcolor="black", label=<{C2Manager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>protocols : dict<br ALIGN="LEFT"/>server : NoneType<br ALIGN="LEFT"/>sessions : dict<br ALIGN="LEFT"/>|establish_session(target_info: Dict[str, Any], payload_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_server_status()<br ALIGN="LEFT"/>start_server(config)<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>wait_for_callback(session_id: str, timeout: int): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_server.C2Server" [color="black", fontcolor="black", label=<{C2Server|auth_tokens : set<br ALIGN="LEFT"/>clients : Dict[str, Any]<br ALIGN="LEFT"/>commands_queue : Queue<br ALIGN="LEFT"/>event_handlers : Dict[str, List[Callable]]<br ALIGN="LEFT"/>host : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>port<br ALIGN="LEFT"/>protocols<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server : NoneType<br ALIGN="LEFT"/>sessions : Dict[str, Any]<br ALIGN="LEFT"/>|add_auth_token(token: str): str<br ALIGN="LEFT"/>add_event_handler(event_type: str, handler: Callable)<br ALIGN="LEFT"/>get_active_sessions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_auth_status(): Dict[str, Any]<br ALIGN="LEFT"/>get_protocols_status(): Dict[str, Any]<br ALIGN="LEFT"/>get_server_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>get_session_info(session_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>remove_auth_token(token: str): bool<br ALIGN="LEFT"/>remove_event_handler(event_type: str, handler: Callable)<br ALIGN="LEFT"/>send_command(session_id: str, command_type: str, command_data: Dict[str, Any])<br ALIGN="LEFT"/>send_command_to_session(session_id: str, command: Dict[str, Any]): bool<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.c2_management_dialog.C2ServerThread" [color="black", fontcolor="black", label=<{C2ServerThread|error<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server : NoneType<br ALIGN="LEFT"/>server_config<br ALIGN="LEFT"/>session_update<br ALIGN="LEFT"/>status_update<br ALIGN="LEFT"/>|on_beacon_received(data)<br ALIGN="LEFT"/>on_session_connected(session)<br ALIGN="LEFT"/>on_session_disconnected(session)<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.cet_bypass.CETBypass" [color="black", fontcolor="black", label=<{CETBypass|bypass_techniques : list<br ALIGN="LEFT"/>cet_features : dict<br ALIGN="LEFT"/>hardware_support<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|bypass_ibt(target_info: Dict[str, Any], technique: str): Dict[str, Any]<br ALIGN="LEFT"/>bypass_shadow_stack(target_info: Dict[str, Any], technique: str): Dict[str, Any]<br ALIGN="LEFT"/>test_bypass_techniques(target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.cfg_explorer.CFGExplorer" [color="black", fontcolor="black", label=<{CFGExplorer|ai_engine : NoneType<br ALIGN="LEFT"/>analysis_cache : dict<br ALIGN="LEFT"/>binary_path : NoneType, Optional[str]<br ALIGN="LEFT"/>call_graph : DiGraph, NoneType<br ALIGN="LEFT"/>cross_references : dict<br ALIGN="LEFT"/>current_function : NoneType<br ALIGN="LEFT"/>decompiler : NoneType<br ALIGN="LEFT"/>function_graphs : dict<br ALIGN="LEFT"/>function_similarities : dict<br ALIGN="LEFT"/>functions : dict<br ALIGN="LEFT"/>graph : NoneType<br ALIGN="LEFT"/>import_analyzer : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>scripting_engine : NoneType<br ALIGN="LEFT"/>string_analyzer : NoneType<br ALIGN="LEFT"/>vulnerability_engine : NoneType<br ALIGN="LEFT"/>|analyze(binary_path: str): bool<br ALIGN="LEFT"/>analyze_cfg(binary_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_function(function_name: str): Optional[Dict]<br ALIGN="LEFT"/>export_dot(output_file: str): bool<br ALIGN="LEFT"/>export_dot_file(output_file: str): bool<br ALIGN="LEFT"/>export_graph_image(output_file: str, format: str): bool<br ALIGN="LEFT"/>export_json(output_path: str): bool<br ALIGN="LEFT"/>find_license_check_patterns(): List[Dict[str, Any]]<br ALIGN="LEFT"/>generate_interactive_html(function_name: str, license_patterns: List[Dict], output_file: str): bool<br ALIGN="LEFT"/>get_advanced_analysis_results(): Dict[str, Any]<br ALIGN="LEFT"/>get_call_graph_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>get_code_complexity_analysis(): Dict[str, Any]<br ALIGN="LEFT"/>get_complexity_metrics(): Dict<br ALIGN="LEFT"/>get_cross_reference_analysis(): Dict[str, Any]<br ALIGN="LEFT"/>get_function_list(): List[str]<br ALIGN="LEFT"/>get_functions(): List[Dict]<br ALIGN="LEFT"/>get_graph_data(layout_type: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_graph_layout(layout_type: str): Optional[Dict]<br ALIGN="LEFT"/>get_license_validation_analysis(): Dict[str, Any]<br ALIGN="LEFT"/>get_vulnerability_patterns(): Dict[str, Any]<br ALIGN="LEFT"/>load_binary(binary_path: Optional[str]): bool<br ALIGN="LEFT"/>set_current_function(function_name: str): bool<br ALIGN="LEFT"/>visualize_cfg(function_name: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.cfi_bypass.CFIBypass" [color="black", fontcolor="black", label=<{CFIBypass|bypass_techniques : dict<br ALIGN="LEFT"/>cfi_methods : list<br ALIGN="LEFT"/>jop_gadgets : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>rop_gadgets : list<br ALIGN="LEFT"/>|analyze_cfi_protection(binary_data: bytes): Dict[str, Any]<br ALIGN="LEFT"/>generate_bypass_payload(target_binary: bytes, technique: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ci_cd_dialog.CICDDialog" [color="black", fontcolor="black", label=<{CICDDialog|branches_edit<br ALIGN="LEFT"/>config_tree<br ALIGN="LEFT"/>config_widget<br ALIGN="LEFT"/>console_output<br ALIGN="LEFT"/>coverage_report_cb<br ALIGN="LEFT"/>github_widget<br ALIGN="LEFT"/>pipeline_thread : NoneType<br ALIGN="LEFT"/>pipeline_widget<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>py_versions_edit<br ALIGN="LEFT"/>report_list<br ALIGN="LEFT"/>report_viewer<br ALIGN="LEFT"/>reports_widget<br ALIGN="LEFT"/>run_btn<br ALIGN="LEFT"/>stage_widgets : dict<br ALIGN="LEFT"/>stop_btn<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>upload_artifacts_cb<br ALIGN="LEFT"/>workflow_preview<br ALIGN="LEFT"/>|build_config_from_tree(): Dict[str, Any]<br ALIGN="LEFT"/>create_config_tab(): QWidget<br ALIGN="LEFT"/>create_github_tab(): QWidget<br ALIGN="LEFT"/>create_pipeline_tab(): QWidget<br ALIGN="LEFT"/>create_reports_tab(): QWidget<br ALIGN="LEFT"/>create_stage_widget(stage: str): QWidget<br ALIGN="LEFT"/>export_report()<br ALIGN="LEFT"/>generate_workflow()<br ALIGN="LEFT"/>init_dialog()<br ALIGN="LEFT"/>load_configuration()<br ALIGN="LEFT"/>load_plugin(path: str)<br ALIGN="LEFT"/>load_reports()<br ALIGN="LEFT"/>on_config_changed(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_log_message(message: str)<br ALIGN="LEFT"/>on_pipeline_error(error: str)<br ALIGN="LEFT"/>on_pipeline_finished(results: Dict[str, Any])<br ALIGN="LEFT"/>on_stage_completed(stage: str, result: Dict[str, Any])<br ALIGN="LEFT"/>on_stage_started(stage: str)<br ALIGN="LEFT"/>populate_config_tree(config: Dict[str, Any], parent: QTreeWidgetItem)<br ALIGN="LEFT"/>reset_configuration()<br ALIGN="LEFT"/>run_pipeline()<br ALIGN="LEFT"/>save_configuration()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_report(item: QListWidgetItem)<br ALIGN="LEFT"/>stop_pipeline()<br ALIGN="LEFT"/>update_workflow_preview()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_ci_cd.CICDPipeline" [color="black", fontcolor="black", label=<{CICDPipeline|pipeline_config<br ALIGN="LEFT"/>plugin_dir<br ALIGN="LEFT"/>plugin_name<br ALIGN="LEFT"/>plugin_path : str<br ALIGN="LEFT"/>results : dict<br ALIGN="LEFT"/>|run_build_stage(): Dict[str, Any]<br ALIGN="LEFT"/>run_deploy_stage(): Dict[str, Any]<br ALIGN="LEFT"/>run_pipeline(): Dict[str, Any]<br ALIGN="LEFT"/>run_quality_stage(): Dict[str, Any]<br ALIGN="LEFT"/>run_security_stage(): Dict[str, Any]<br ALIGN="LEFT"/>run_test_stage(): Dict[str, Any]<br ALIGN="LEFT"/>run_validate_stage(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.CONTEXT" [color="black", fontcolor="black", label=<{CONTEXT|ContextFlags : int<br ALIGN="LEFT"/>Eip<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.HardwareDebugProtector.get_thread_context.CONTEXT" [color="black", fontcolor="black", label=<{CONTEXT|ContextFlags : int<br ALIGN="LEFT"/>Dr0 : int<br ALIGN="LEFT"/>Dr1 : int<br ALIGN="LEFT"/>Dr2 : int<br ALIGN="LEFT"/>Dr3 : int<br ALIGN="LEFT"/>Dr6 : int<br ALIGN="LEFT"/>Dr7 : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_structures.WindowsContext.create_context_structure.CONTEXT" [color="black", fontcolor="black", label=<{CONTEXT|ContextFlags : NoneType, int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.cpu_status_widget.CPUMonitorWorker" [color="black", fontcolor="black", label=<{CPUMonitorWorker|cpu_data_ready<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.cpu_status_widget.CPUStatusWidget" [color="black", fontcolor="black", label=<{CPUStatusWidget|cores_container<br ALIGN="LEFT"/>cores_label<br ALIGN="LEFT"/>cores_layout<br ALIGN="LEFT"/>cpu_data : Dict[str, Any]<br ALIGN="LEFT"/>freq_label<br ALIGN="LEFT"/>load_label<br ALIGN="LEFT"/>model_label<br ALIGN="LEFT"/>monitor_thread<br ALIGN="LEFT"/>monitor_worker<br ALIGN="LEFT"/>processes_table<br ALIGN="LEFT"/>threads_label<br ALIGN="LEFT"/>time_labels : dict<br ALIGN="LEFT"/>total_cpu_bar<br ALIGN="LEFT"/>total_cpu_label<br ALIGN="LEFT"/>|handle_error(error_msg: str)<br ALIGN="LEFT"/>setup_monitoring()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>update_core_usage(core_percents: List[float])<br ALIGN="LEFT"/>update_cpu_data(data: Dict[str, Any])<br ALIGN="LEFT"/>update_processes_table(processes: List[Dict[str, Any]])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.optimization_config.CacheConfig" [color="black", fontcolor="black", label=<{CacheConfig|cleanup_interval : int<br ALIGN="LEFT"/>enable_lru : bool<br ALIGN="LEFT"/>enable_stats : bool<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>ttl_seconds : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_cache_manager.CacheEntry" [color="black", fontcolor="black", label=<{CacheEntry|access_count : int<br ALIGN="LEFT"/>adapter_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>config : Dict[str, Any]<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>last_accessed : datetime<br ALIGN="LEFT"/>load_time : float<br ALIGN="LEFT"/>memory_size : int<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>model_object : Any<br ALIGN="LEFT"/>model_type : str<br ALIGN="LEFT"/>quantization : Optional[str]<br ALIGN="LEFT"/>tokenizer_object : Optional[Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.analysis_cache.CacheEntry" [color="black", fontcolor="black", label=<{CacheEntry|access_count : int<br ALIGN="LEFT"/>cache_key : str<br ALIGN="LEFT"/>data : Any<br ALIGN="LEFT"/>file_mtime : float<br ALIGN="LEFT"/>file_size : int<br ALIGN="LEFT"/>last_access : float<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|is_valid(file_path: str): bool<br ALIGN="LEFT"/>update_access()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.cache_management_widget.CacheManagementWidget" [color="black", fontcolor="black", label=<{CacheManagementWidget|cache : NoneType<br ALIGN="LEFT"/>cache_cleaned<br ALIGN="LEFT"/>cache_cleared<br ALIGN="LEFT"/>cleanup_btn<br ALIGN="LEFT"/>clear_btn<br ALIGN="LEFT"/>details_text<br ALIGN="LEFT"/>engine : NoneType<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>save_btn<br ALIGN="LEFT"/>stats_widget<br ALIGN="LEFT"/>timer<br ALIGN="LEFT"/>top_entries_widget<br ALIGN="LEFT"/>|cleanup_cache()<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>refresh_stats()<br ALIGN="LEFT"/>save_cache()<br ALIGN="LEFT"/>setup_timer()<br ALIGN="LEFT"/>update_details(stats: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.CacheManager" [color="black", fontcolor="black", label=<{CacheManager|access_counts : Dict[str, int]<br ALIGN="LEFT"/>access_times : Dict[str, datetime]<br ALIGN="LEFT"/>cache : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>current_size_mb : float<br ALIGN="LEFT"/>max_size_mb : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|cleanup_expired()<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>get(key: str): Optional[Any]<br ALIGN="LEFT"/>get_cache_stats(): Dict[str, Any]<br ALIGN="LEFT"/>set(key: str, value: Any, ttl_seconds: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.base.CacheManager" [color="black", fontcolor="black", label=<{CacheManager|cache_dir : str<br ALIGN="LEFT"/>cache_index<br ALIGN="LEFT"/>index_file<br ALIGN="LEFT"/>max_size_mb : int<br ALIGN="LEFT"/>ttl_seconds : int<br ALIGN="LEFT"/>|cache_item(key: str, value: Any, ttl: Optional[int]): bool<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>get_cached_item(key: str): Optional[Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CacheManager" [color="black", fontcolor="black", label=<{CacheManager|access_times : dict<br ALIGN="LEFT"/>cache : dict<br ALIGN="LEFT"/>cache_lock : lock<br ALIGN="LEFT"/>cleanup_thread : Thread<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|clear_cache()<br ALIGN="LEFT"/>get_cached_response(request: RequestInfo): Optional[ResponseInfo]<br ALIGN="LEFT"/>store_response(request: RequestInfo, response: ResponseInfo)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.CacheManager" [color="black", fontcolor="black", label=<{CacheManager|access_counts : defaultdict<br ALIGN="LEFT"/>access_order : deque<br ALIGN="LEFT"/>cache : dict<br ALIGN="LEFT"/>evictions : int<br ALIGN="LEFT"/>hits : int<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>max_memory : int<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>misses : int<br ALIGN="LEFT"/>|get(key: str, default): Any<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>put(key: str, value: Any): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.CacheManager" [color="black", fontcolor="black", label=<{CacheManager|cache_dir : Path<br ALIGN="LEFT"/>cache_lock : lock<br ALIGN="LEFT"/>memory_cache : dict<br ALIGN="LEFT"/>|cache_result(file_path: str, analysis_type: str, result: Dict[str, Any])<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>get_cache_key(file_path: str, analysis_type: str): str<br ALIGN="LEFT"/>get_cached_result(file_path: str, analysis_type: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_file_hash(file_path: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.analysis_cache.CacheStats" [color="black", fontcolor="black", label=<{CacheStats|cache_hits : int<br ALIGN="LEFT"/>cache_invalidations : int<br ALIGN="LEFT"/>cache_misses : int<br ALIGN="LEFT"/>hit_rate<br ALIGN="LEFT"/>newest_entry : float<br ALIGN="LEFT"/>oldest_entry : float<br ALIGN="LEFT"/>total_entries : int<br ALIGN="LEFT"/>total_size_bytes : int<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.cache_management_widget.CacheStatsWidget" [color="black", fontcolor="black", label=<{CacheStatsWidget|entries_label<br ALIGN="LEFT"/>entry_progress<br ALIGN="LEFT"/>hit_rate_label<br ALIGN="LEFT"/>metrics_layout<br ALIGN="LEFT"/>size_label<br ALIGN="LEFT"/>size_progress<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>update_stats(stats: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.cache_management_widget.CacheTopEntriesWidget" [color="black", fontcolor="black", label=<{CacheTopEntriesWidget|table<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>update_entries(entries: list)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.task_manager.CallableTask" [color="black", fontcolor="black", label=<{CallableTask|args : tuple<br ALIGN="LEFT"/>func : Callable<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>|execute(): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.CampaignSelectionDialog" [color="black", fontcolor="black", label=<{CampaignSelectionDialog|campaign_list<br ALIGN="LEFT"/>campaign_results : Dict<br ALIGN="LEFT"/>|get_selected_campaigns(): List[Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.CampaignStatus" [color="black", fontcolor="black", label=<{CampaignStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog._execute_testcase.CampaignStatus" [color="black", fontcolor="black", label=<{CampaignStatus|COMPLETED : str<br ALIGN="LEFT"/>FAILED : str<br ALIGN="LEFT"/>PENDING : str<br ALIGN="LEFT"/>RUNNING : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.CampaignType" [color="black", fontcolor="black", label=<{CampaignType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.binary.certificate_extractor.CertificateExtractor" [color="black", fontcolor="black", label=<{CertificateExtractor|file_path : NoneType<br ALIGN="LEFT"/>pe : NoneType, PE<br ALIGN="LEFT"/>|export_certificates(file_path: str, output_dir: str): Dict[str, str]<br ALIGN="LEFT"/>extract_certificates(file_path: str): CodeSigningInfo<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.CertificateInfo" [color="black", fontcolor="black", label=<{CertificateInfo|algorithm : str<br ALIGN="LEFT"/>is_trusted : bool<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>issuer : str<br ALIGN="LEFT"/>serial_number : str<br ALIGN="LEFT"/>subject : str<br ALIGN="LEFT"/>valid_from : str<br ALIGN="LEFT"/>valid_to : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.binary.certificate_extractor.CertificateInfo" [color="black", fontcolor="black", label=<{CertificateInfo|extended_key_usage : List[str]<br ALIGN="LEFT"/>fingerprint_sha1 : str<br ALIGN="LEFT"/>fingerprint_sha256 : str<br ALIGN="LEFT"/>is_code_signing : bool<br ALIGN="LEFT"/>is_expired : bool<br ALIGN="LEFT"/>is_self_signed : bool<br ALIGN="LEFT"/>is_valid<br ALIGN="LEFT"/>issuer : str<br ALIGN="LEFT"/>key_usage : List[str]<br ALIGN="LEFT"/>not_after : datetime<br ALIGN="LEFT"/>not_before : datetime<br ALIGN="LEFT"/>public_key_algorithm : str<br ALIGN="LEFT"/>public_key_size : int<br ALIGN="LEFT"/>serial_number : str<br ALIGN="LEFT"/>signature_algorithm : str<br ALIGN="LEFT"/>subject : str<br ALIGN="LEFT"/>subject_alt_names : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CertificateManager" [color="black", fontcolor="black", label=<{CertificateManager|ca_cert : NoneType<br ALIGN="LEFT"/>ca_key : NoneType<br ALIGN="LEFT"/>cert_lock : lock<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>server_certs : dict<br ALIGN="LEFT"/>|get_server_certificate(hostname: str): Tuple[ssl.SSLContext, str]<br ALIGN="LEFT"/>initialize_ca(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ChainComplexity" [color="black", fontcolor="black", label=<{ChainComplexity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ChainValidationResult" [color="black", fontcolor="black", label=<{ChainValidationResult|confidence : float<br ALIGN="LEFT"/>estimated_success_rate : float<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>issues : List[str]<br ALIGN="LEFT"/>optimizations : List[str]<br ALIGN="LEFT"/>risk_assessment : Dict[str, str]<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ChangeStatus" [color="black", fontcolor="black", label=<{ChangeStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.ChartData" [color="black", fontcolor="black", label=<{ChartData|chart_id : str<br ALIGN="LEFT"/>chart_type<br ALIGN="LEFT"/>color_scheme : str<br ALIGN="LEFT"/>data_points : List[DataPoint]<br ALIGN="LEFT"/>options : Dict[str, Any]<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>x_axis_label : str<br ALIGN="LEFT"/>y_axis_label : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.ChartGenerator" [color="black", fontcolor="black", label=<{ChartGenerator|chart_templates : dict<br ALIGN="LEFT"/>data_collector<br ALIGN="LEFT"/>|generate_chart(template_name: str, custom_options: Dict[str, Any]): ChartData<br ALIGN="LEFT"/>generate_custom_chart(chart_config: Dict[str, Any]): ChartData<br ALIGN="LEFT"/>generate_exploit_chain_network_graph(): ChartData<br ALIGN="LEFT"/>generate_vulnerability_heatmap(): ChartData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.ChartType" [color="black", fontcolor="black", label=<{ChartType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.ChatWidget" [color="black", fontcolor="black", label=<{ChatWidget|chat_history<br ALIGN="LEFT"/>context_checkbox<br ALIGN="LEFT"/>conversation_history : list<br ALIGN="LEFT"/>debug_button<br ALIGN="LEFT"/>explain_button<br ALIGN="LEFT"/>message_input<br ALIGN="LEFT"/>message_sent<br ALIGN="LEFT"/>model_combo<br ALIGN="LEFT"/>optimize_button<br ALIGN="LEFT"/>send_button<br ALIGN="LEFT"/>|add_message(sender: str, message: str)<br ALIGN="LEFT"/>clear_history()<br ALIGN="LEFT"/>send_message()<br ALIGN="LEFT"/>send_quick_message(message: str)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.file_handler.ChunkManager" [color="black", fontcolor="black", label=<{ChunkManager|active_chunks<br ALIGN="LEFT"/>chunk_size : int<br ALIGN="LEFT"/>file<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_size<br ALIGN="LEFT"/>|get_chunk(offset: int)<br ALIGN="LEFT"/>read_data(offset: int, size: int): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_integration.ClaudeAdapter" [color="black", fontcolor="black", label=<{ClaudeAdapter|<br ALIGN="LEFT"/>|handle_tool_call(tool_name: str, parameters: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [color="black", fontcolor="black", label=<{CloudLicenseInterceptor|active_sessions : dict<br ALIGN="LEFT"/>auth_manager<br ALIGN="LEFT"/>bypass_stats : defaultdict<br ALIGN="LEFT"/>cache_manager<br ALIGN="LEFT"/>cert_manager<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>local_server<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>request_classifier<br ALIGN="LEFT"/>request_log : deque<br ALIGN="LEFT"/>response_modifier<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server : NoneType<br ALIGN="LEFT"/>session : NoneType<br ALIGN="LEFT"/>|get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>start(): bool<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator" [color="black", fontcolor="black", label=<{CloudLicenseResponseGenerator|api_call_log : List[Dict[str, Any]]<br ALIGN="LEFT"/>api_hooks_enabled : bool<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>hooked_apis : dict<br ALIGN="LEFT"/>learned_patterns : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>license_targets : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>request_patterns : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>response_cache : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>response_templates : Dict[str, Dict[str, Any]], dict<br ALIGN="LEFT"/>|clear_cache(): None<br ALIGN="LEFT"/>clear_learned_patterns(): None<br ALIGN="LEFT"/>disable_network_api_hooks(): bool<br ALIGN="LEFT"/>enable_network_api_hooks(): bool<br ALIGN="LEFT"/>generate_response(request: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_hooked_apis(): Dict[str, List[str]]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>hook_wininet_api(api_name: str): bool<br ALIGN="LEFT"/>hook_winsock_api(api_name: str): bool<br ALIGN="LEFT"/>identify_service(request: Dict[str, Any]): str<br ALIGN="LEFT"/>intercept_network_call(api_name: str, params: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>learn_from_request(request: Dict[str, Any], response: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudProvider" [color="black", fontcolor="black", label=<{CloudProvider|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.ClusterModule" [color="black", fontcolor="black", label=<{ClusterModule|DBSCAN<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_tools.CodeAnalyzer" [color="black", fontcolor="black", label=<{CodeAnalyzer|ai_assistant<br ALIGN="LEFT"/>|analyze_assembly(assembly_code: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_binary(file_path: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_code(code: str, language: str): Dict[str, Any]<br ALIGN="LEFT"/>ask_ai_about_analysis(question: str, context: Dict[str, Any]): str<br ALIGN="LEFT"/>get_analysis_suggestions(analysis_result: Dict[str, Any]): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.CodeAnalyzer" [color="black", fontcolor="black", label=<{CodeAnalyzer|supported_extensions : dict<br ALIGN="LEFT"/>|analyze_file(file_path: str): CodeContext<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.CodeChange" [color="black", fontcolor="black", label=<{CodeChange|applied_at : Optional[datetime]<br ALIGN="LEFT"/>change_id : str<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>end_line : int<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>impact_analysis : Dict[str, Any]<br ALIGN="LEFT"/>modification_type<br ALIGN="LEFT"/>modified_code : str<br ALIGN="LEFT"/>original_code : str<br ALIGN="LEFT"/>reasoning : str<br ALIGN="LEFT"/>start_line : int<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.CodeContext" [color="black", fontcolor="black", label=<{CodeContext|ast_info : Dict[str, Any]<br ALIGN="LEFT"/>classes : List[str]<br ALIGN="LEFT"/>content : str<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>functions : List[str]<br ALIGN="LEFT"/>imports : List[str]<br ALIGN="LEFT"/>language : str<br ALIGN="LEFT"/>variables : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.CodeEditor" [color="black", fontcolor="black", label=<{CodeEditor|content_changed<br ALIGN="LEFT"/>current_file : NoneType<br ALIGN="LEFT"/>is_modified : bool<br ALIGN="LEFT"/>syntax_highlighter : NoneType<br ALIGN="LEFT"/>|get_current_selection(): str<br ALIGN="LEFT"/>insert_text_at_cursor(text: str)<br ALIGN="LEFT"/>load_file(file_path: str)<br ALIGN="LEFT"/>on_text_changed()<br ALIGN="LEFT"/>save_file(file_path: str)<br ALIGN="LEFT"/>set_syntax_highlighting(file_path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.CodeEditorWidget" [color="black", fontcolor="black", label=<{CodeEditorWidget|breakpoint_lines : set<br ALIGN="LEFT"/>breakpoint_toggled<br ALIGN="LEFT"/>current_line : NoneType, int<br ALIGN="LEFT"/>file_path : NoneType, str<br ALIGN="LEFT"/>line_number_area<br ALIGN="LEFT"/>|add_breakpoint(line: int)<br ALIGN="LEFT"/>clear_breakpoints()<br ALIGN="LEFT"/>highlight_current_line()<br ALIGN="LEFT"/>highlight_line(line: int)<br ALIGN="LEFT"/>line_number_area_mouse_press(event)<br ALIGN="LEFT"/>line_number_area_paint_event(event)<br ALIGN="LEFT"/>line_number_area_width()<br ALIGN="LEFT"/>remove_breakpoint(line: int)<br ALIGN="LEFT"/>resizeEvent(event)<br ALIGN="LEFT"/>set_code(code: str)<br ALIGN="LEFT"/>update_line_number_area(rect, dy)<br ALIGN="LEFT"/>update_line_number_area_width(new_block_count)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.CodeGenerationPage" [color="black", fontcolor="black", label=<{CodeGenerationPage|code_edit<br ALIGN="LEFT"/>copy_btn<br ALIGN="LEFT"/>validate_btn<br ALIGN="LEFT"/>|copy_code()<br ALIGN="LEFT"/>get_code()<br ALIGN="LEFT"/>set_generated_code(code)<br ALIGN="LEFT"/>validate_code()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.code_modification_dialog.CodeModificationDialog" [color="black", fontcolor="black", label=<{CodeModificationDialog|analysis_thread : NoneType<br ALIGN="LEFT"/>analyze_btn<br ALIGN="LEFT"/>apply_btn<br ALIGN="LEFT"/>change_details<br ALIGN="LEFT"/>changes_tree<br ALIGN="LEFT"/>clear_btn<br ALIGN="LEFT"/>constraints_edit<br ALIGN="LEFT"/>context_info<br ALIGN="LEFT"/>current_changes : List[CodeChange], list<br ALIGN="LEFT"/>description_edit<br ALIGN="LEFT"/>diff_highlighter<br ALIGN="LEFT"/>diff_tabs<br ALIGN="LEFT"/>history_limit<br ALIGN="LEFT"/>history_tree<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>modified_code<br ALIGN="LEFT"/>modifier<br ALIGN="LEFT"/>original_code<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>project_root : str<br ALIGN="LEFT"/>reject_btn<br ALIGN="LEFT"/>requirements_edit<br ALIGN="LEFT"/>select_all_btn<br ALIGN="LEFT"/>select_none_btn<br ALIGN="LEFT"/>selected_changes : set<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>target_files_list<br ALIGN="LEFT"/>unified_diff<br ALIGN="LEFT"/>|add_target_file()<br ALIGN="LEFT"/>analyze_modifications()<br ALIGN="LEFT"/>apply_selected_changes()<br ALIGN="LEFT"/>clear_request()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>get_selected_change_ids(): List[str]<br ALIGN="LEFT"/>load_project_context()<br ALIGN="LEFT"/>on_analysis_complete(changes: List[CodeChange])<br ALIGN="LEFT"/>on_analysis_error(error_message: str)<br ALIGN="LEFT"/>on_change_selected()<br ALIGN="LEFT"/>populate_changes_tree()<br ALIGN="LEFT"/>refresh_history()<br ALIGN="LEFT"/>reject_selected_changes()<br ALIGN="LEFT"/>remove_target_file()<br ALIGN="LEFT"/>select_all_changes()<br ALIGN="LEFT"/>select_no_changes()<br ALIGN="LEFT"/>setup_changes_tab(tab_widget)<br ALIGN="LEFT"/>setup_history_tab(tab_widget)<br ALIGN="LEFT"/>setup_request_tab(tab_widget)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.binary.certificate_extractor.CodeSigningInfo" [color="black", fontcolor="black", label=<{CodeSigningInfo|certificate_chain_valid : bool<br ALIGN="LEFT"/>certificates : List[CertificateInfo]<br ALIGN="LEFT"/>is_signed : bool<br ALIGN="LEFT"/>security_catalog : Optional[str]<br ALIGN="LEFT"/>signature_valid : bool<br ALIGN="LEFT"/>signer_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>signing_certificate<br ALIGN="LEFT"/>timestamp_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>trust_status : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.CollaborationResult" [color="black", fontcolor="black", label=<{CollaborationResult|confidence : float<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>knowledge_gained : Dict[str, Any]<br ALIGN="LEFT"/>participating_agents : List[str]<br ALIGN="LEFT"/>result_data : Dict[str, Any]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.CommandManager" [color="black", fontcolor="black", label=<{CommandManager|auto_merge : bool<br ALIGN="LEFT"/>command_history : List[HexCommand], list<br ALIGN="LEFT"/>current_index : int<br ALIGN="LEFT"/>file_handler : NoneType<br ALIGN="LEFT"/>max_history : int<br ALIGN="LEFT"/>|can_redo(): bool<br ALIGN="LEFT"/>can_undo(): bool<br ALIGN="LEFT"/>clear_history()<br ALIGN="LEFT"/>execute_command(command: HexCommand): bool<br ALIGN="LEFT"/>get_history_summary(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_redo_description(): Optional[str]<br ALIGN="LEFT"/>get_undo_description(): Optional[str]<br ALIGN="LEFT"/>redo(): bool<br ALIGN="LEFT"/>set_auto_merge(enabled: bool)<br ALIGN="LEFT"/>set_file_handler(file_handler)<br ALIGN="LEFT"/>undo(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_comparison.ComparisonReport" [color="black", fontcolor="black", label=<{ComparisonReport|analysis : Dict[str, Any]<br ALIGN="LEFT"/>comparison_id : str<br ALIGN="LEFT"/>models : List[str]<br ALIGN="LEFT"/>prompt : str<br ALIGN="LEFT"/>results : List[ComparisonResult]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>visualizations : Dict[str, Path]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_comparison.ComparisonResult" [color="black", fontcolor="black", label=<{ComparisonResult|inference_time : float<br ALIGN="LEFT"/>memory_used_mb : float<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>output : str<br ALIGN="LEFT"/>similarity_scores : Optional[Dict[str, float]]<br ALIGN="LEFT"/>tokens_generated : int<br ALIGN="LEFT"/>tokens_per_second : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ComponentType" [color="black", fontcolor="black", label=<{ComponentType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor.ConcolicExecutionEngine.analyze.ComprehensiveAnalysisPlugin" [color="black", fontcolor="black", label=<{ComprehensiveAnalysisPlugin|analysis_data<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|did_run_callback()<br ALIGN="LEFT"/>will_execute_instruction_callback(state, pc, insn)<br ALIGN="LEFT"/>will_fork_state_callback(state, expression, solutions)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.comprehensive_integration.ComprehensiveR2Integration" [color="black", fontcolor="black", label=<{ComprehensiveR2Integration|integrated_apps : list<br ALIGN="LEFT"/>integration_status : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ui_manager : NoneType<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_integration_status(): Dict[str, bool]<br ALIGN="LEFT"/>get_ui_manager(): Optional[R2UIManager]<br ALIGN="LEFT"/>integrate_with_application(main_app): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor.ConcolicExecutionEngine" [color="black", fontcolor="black", label=<{ConcolicExecutionEngine|binary_path : str<br ALIGN="LEFT"/>code_coverage : dict<br ALIGN="LEFT"/>discovered_bugs : list<br ALIGN="LEFT"/>engine : NoneType<br ALIGN="LEFT"/>execution_paths : list<br ALIGN="LEFT"/>exploration_depth : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>memory_limit : int<br ALIGN="LEFT"/>symbolic_variables : list<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|analyze(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>explore_paths(target_address: Optional[int], avoid_addresses: Optional[List[int]]): Dict[str, Any]<br ALIGN="LEFT"/>find_license_bypass(license_check_address: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor_fixed.ConcolicExecutionEngine" [color="black", fontcolor="black", label=<{ConcolicExecutionEngine|binary_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>manticore_available<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>symbolic_engine : NoneType, str<br ALIGN="LEFT"/>symbolic_engine_name : NoneType, str<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|explore_paths(target_address: Optional[int], avoid_addresses: Optional[List[int]]): Dict[str, Any]<br ALIGN="LEFT"/>find_license_bypass(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.lateral_movement.ConcreteLateralMovement" [color="black", fontcolor="black", label=<{ConcreteLateralMovement|<br ALIGN="LEFT"/>|get_default_method(): str<br ALIGN="LEFT"/>list_available_methods(): list<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.severity_levels.ConfidenceLevel" [color="black", fontcolor="black", label=<{ConfidenceLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_config_as_code.ConfigAsCodeManager" [color="black", fontcolor="black", label=<{ConfigAsCodeManager|config_dir : Path<br ALIGN="LEFT"/>schemas : dict<br ALIGN="LEFT"/>|apply_config(config: Dict[str, Any], llm_manager, fallback_manager)<br ALIGN="LEFT"/>create_template_config(environment: str): Dict[str, Any]<br ALIGN="LEFT"/>export_current_config(llm_manager, fallback_manager): Dict[str, Any]<br ALIGN="LEFT"/>generate_config_files(output_dir: Optional[str], environments: List[str]): List[Path]<br ALIGN="LEFT"/>load_config(file_path: Union[str, Path], validate: bool): Dict[str, Any]<br ALIGN="LEFT"/>save_config(config: Dict[str, Any], file_path: Union[str, Path], format_type: Optional[str], validate: bool): None<br ALIGN="LEFT"/>validate_config(config: Dict[str, Any], schema_name: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.config.ConfigManager" [color="black", fontcolor="black", label=<{ConfigManager|config<br ALIGN="LEFT"/>config_path : str<br ALIGN="LEFT"/>|get(key: str, default: Any): Any<br ALIGN="LEFT"/>get_cache_dir()<br ALIGN="LEFT"/>get_ghidra_path(): Optional[str]<br ALIGN="LEFT"/>get_logs_dir()<br ALIGN="LEFT"/>get_model_repositories(): Dict[str, Any]<br ALIGN="LEFT"/>get_output_dir()<br ALIGN="LEFT"/>get_tool_path(tool_name: str): Optional[str]<br ALIGN="LEFT"/>is_repository_enabled(repo_name: str): bool<br ALIGN="LEFT"/>is_tool_available(tool_name: str): bool<br ALIGN="LEFT"/>items()<br ALIGN="LEFT"/>keys()<br ALIGN="LEFT"/>load_config(): Dict[str, Any]<br ALIGN="LEFT"/>save_config(): bool<br ALIGN="LEFT"/>set(key: str, value: Any): None<br ALIGN="LEFT"/>update(updates: Dict[str, Any]): None<br ALIGN="LEFT"/>validate_config(): bool<br ALIGN="LEFT"/>values()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.config_manager.ConfigManager" [color="black", fontcolor="black", label=<{ConfigManager|backup_dir<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>config_dir<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>options : dict<br ALIGN="LEFT"/>|create_status_display(message: str, status: str): None<br ALIGN="LEFT"/>display_config(category: Optional[str], advanced: bool)<br ALIGN="LEFT"/>display_config_tree(): None<br ALIGN="LEFT"/>export_config(export_path: str, format_type: str): bool<br ALIGN="LEFT"/>get(key: str, default: Any): Any<br ALIGN="LEFT"/>get_categories(): List[str]<br ALIGN="LEFT"/>get_category_options(category: str, include_advanced: bool): List[ConfigOption]<br ALIGN="LEFT"/>get_options_by_category(category: str, include_advanced: bool): Dict[str, ConfigOption]<br ALIGN="LEFT"/>import_config(import_path: str): bool<br ALIGN="LEFT"/>interactive_config_setup(): None<br ALIGN="LEFT"/>load_config()<br ALIGN="LEFT"/>reset_to_defaults(category: Optional[str])<br ALIGN="LEFT"/>save_config(create_backup: bool)<br ALIGN="LEFT"/>set(key: str, value: Any): bool<br ALIGN="LEFT"/>update(updates: Dict[str, Any]): Dict[str, bool]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.config_manager.ConfigOption" [color="black", fontcolor="black", label=<{ConfigOption|advanced : bool<br ALIGN="LEFT"/>category : str<br ALIGN="LEFT"/>choices : Optional[List[Any]]<br ALIGN="LEFT"/>data_type : type<br ALIGN="LEFT"/>default : Any<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>requires_restart : bool<br ALIGN="LEFT"/>validator : Optional[Callable[[Any], bool]]<br ALIGN="LEFT"/>value : Any<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.config_profiles.ConfigProfile" [color="black", fontcolor="black", label=<{ConfigProfile|analysis_options : list<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>custom_scripts : list<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>last_used : NoneType, datetime<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>output_format : Ellipsis, str<br ALIGN="LEFT"/>plugins_enabled : list<br ALIGN="LEFT"/>settings : dict<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ConfigProfile'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_config_as_code.ConfigValidationError" [color="black", fontcolor="red", label=<{ConfigValidationError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ConfigurationManager" [color="black", fontcolor="black", label=<{ConfigurationManager|config : Dict[str, Any], dict<br ALIGN="LEFT"/>config_path : Path<br ALIGN="LEFT"/>file_watcher : Optional[threading.Thread]<br ALIGN="LEFT"/>last_modified : float<br ALIGN="LEFT"/>schema : Dict[str, Any], dict<br ALIGN="LEFT"/>watchers : List[Callable]<br ALIGN="LEFT"/>|add_watcher(callback: Callable[[Dict[str, Any]], None])<br ALIGN="LEFT"/>get(key: str, default: Any): Any<br ALIGN="LEFT"/>reload_config()<br ALIGN="LEFT"/>remove_watcher(callback: Callable[[Dict[str, Any]], None])<br ALIGN="LEFT"/>set(key: str, value: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.ConfirmationManager" [color="black", fontcolor="black", label=<{ConfirmationManager|action_history : List[Dict[str, Any]]<br ALIGN="LEFT"/>auto_approve_low_risk : bool<br ALIGN="LEFT"/>confirmation_queue : Queue<br ALIGN="LEFT"/>pending_actions : Dict[str, PendingAction]<br ALIGN="LEFT"/>|request_confirmation(action: PendingAction): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.ConsoleProgressCallback" [color="black", fontcolor="black", label=<{ConsoleProgressCallback|<br ALIGN="LEFT"/>|on_completed(model_id: str, success: bool, error: Optional[str])<br ALIGN="LEFT"/>on_progress(progress: LoadingProgress)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.console_widget.ConsoleSyntaxHighlighter" [color="black", fontcolor="black", label=<{ConsoleSyntaxHighlighter|rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.console_widget.ConsoleWidget" [color="black", fontcolor="black", label=<{ConsoleWidget|autoscroll_cb<br ALIGN="LEFT"/>clear_btn<br ALIGN="LEFT"/>commandEntered<br ALIGN="LEFT"/>command_history : list<br ALIGN="LEFT"/>command_input<br ALIGN="LEFT"/>enable_input : bool<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>filter_combo<br ALIGN="LEFT"/>filters : list<br ALIGN="LEFT"/>highlighter<br ALIGN="LEFT"/>history_index : int<br ALIGN="LEFT"/>max_lines : int<br ALIGN="LEFT"/>output<br ALIGN="LEFT"/>search_input<br ALIGN="LEFT"/>wrap_cb<br ALIGN="LEFT"/>|append_debug(text: str)<br ALIGN="LEFT"/>append_error(text: str)<br ALIGN="LEFT"/>append_info(text: str)<br ALIGN="LEFT"/>append_output(text: str, level: str)<br ALIGN="LEFT"/>append_success(text: str)<br ALIGN="LEFT"/>append_warning(text: str)<br ALIGN="LEFT"/>apply_filter(filter_text: str)<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>eventFilter(obj, event)<br ALIGN="LEFT"/>export_log()<br ALIGN="LEFT"/>get_content(): str<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>process_command()<br ALIGN="LEFT"/>search_text(search_term: str)<br ALIGN="LEFT"/>set_max_lines(max_lines: int)<br ALIGN="LEFT"/>toggle_wrap(state)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ContainerResource" [color="black", fontcolor="black", label=<{ContainerResource|container_id : str<br ALIGN="LEFT"/>container_name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.ContextualLogger" [color="black", fontcolor="black", label=<{ContextualLogger|audit_logger : Optional[AuditLogger]<br ALIGN="LEFT"/>context : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|clear_context()<br ALIGN="LEFT"/>critical(message: str)<br ALIGN="LEFT"/>debug(message: str)<br ALIGN="LEFT"/>error(message: str)<br ALIGN="LEFT"/>info(message: str)<br ALIGN="LEFT"/>set_context()<br ALIGN="LEFT"/>warning(message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.coordination_layer.CoordinatedResult" [color="black", fontcolor="black", label=<{CoordinatedResult|cache_hit : bool<br ALIGN="LEFT"/>combined_confidence : float<br ALIGN="LEFT"/>escalated : bool<br ALIGN="LEFT"/>llm_results : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>ml_results : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>processing_time : float<br ALIGN="LEFT"/>recommendations : Optional[List[str]]<br ALIGN="LEFT"/>strategy_used<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.CorrelationResultsDialog" [color="black", fontcolor="black", label=<{CorrelationResultsDialog|correlation_results : Dict<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.credential_harvester.CredentialHarvester" [color="black", fontcolor="black", label=<{CredentialHarvester|app_paths : dict<br ALIGN="LEFT"/>browser_paths : dict<br ALIGN="LEFT"/>credential_patterns : dict<br ALIGN="LEFT"/>harvested_credentials : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>platform<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>supported_formats : list<br ALIGN="LEFT"/>system_paths : dict<br ALIGN="LEFT"/>wifi_paths : dict<br ALIGN="LEFT"/>|clear_all_sessions()<br ALIGN="LEFT"/>clear_session(session_id: str): bool<br ALIGN="LEFT"/>export_credentials(session_id: str, output_file: str, output_format: str): bool<br ALIGN="LEFT"/>extract_credentials_from_memory(process_name: Optional[str], dump_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>get_available_techniques(target_os: Optional[str]): Dict[str, List[str]]<br ALIGN="LEFT"/>get_harvested_sessions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_session_credentials(session_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>harvest_credentials(target_os: Optional[str], techniques: Optional[List[str]], output_format: str): Dict[str, Any]<br ALIGN="LEFT"/>search_files_for_credentials(search_paths: List[str], file_patterns: Optional[List[str]]): Dict[str, Any]<br ALIGN="LEFT"/>validate_credentials(credentials: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.CryptoEngine" [color="black", fontcolor="black", label=<{CryptoEngine|<br ALIGN="LEFT"/>|crc16(data: bytes): int<br ALIGN="LEFT"/>simple_xor(data: bytes, key: bytes): bytes<br ALIGN="LEFT"/>tea_decrypt(data: bytes, key: bytes): bytes<br ALIGN="LEFT"/>tea_encrypt(data: bytes, key: bytes): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" [color="black", fontcolor="black", label=<{CryptoManager|aes_key : bytes<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>private_key<br ALIGN="LEFT"/>public_key<br ALIGN="LEFT"/>|decrypt_license_data(encrypted_data: str): str<br ALIGN="LEFT"/>encrypt_license_data(data: str): str<br ALIGN="LEFT"/>generate_license_key(product: str, license_type: str): str<br ALIGN="LEFT"/>sign_license_data(data: Dict[str, Any]): str<br ALIGN="LEFT"/>verify_license_signature(data: Dict[str, Any], signature: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.interactive_mode.IntellicrackShell.create_custom_progress_column.CustomProgressColumn" [color="black", fontcolor="black", label=<{CustomProgressColumn|<br ALIGN="LEFT"/>|render(task)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.DBSCANFallback" [color="black", fontcolor="black", label=<{DBSCANFallback|eps : float<br ALIGN="LEFT"/>min_samples : int<br ALIGN="LEFT"/>|fit_predict(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.dep_bypass.DEPBypass" [color="black", fontcolor="black", label=<{DEPBypass|gadget_cache : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>rop_chain : list<br ALIGN="LEFT"/>rop_gadgets : list<br ALIGN="LEFT"/>target_functions : list<br ALIGN="LEFT"/>|analyze_target(target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>bypass(target_info: Dict[str, Any], method: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.dep_bypass.DEPBypass" [color="black", fontcolor="black", label=<{DEPBypass|techniques : list<br ALIGN="LEFT"/>|analyze_dep_bypass(binary_info)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.DEPBypass" [color="black", fontcolor="black", label=<{DEPBypass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.memory_patcher._get_wintypes.MockWintypes.DWORD" [color="black", fontcolor="black", label=<{DWORD|value : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.Dashboard" [color="black", fontcolor="black", label=<{Dashboard|charts : List[ChartData]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>dashboard_id : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>last_updated : datetime<br ALIGN="LEFT"/>layout : Dict[str, Any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>refresh_interval : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.DashboardManager" [color="black", fontcolor="black", label=<{DashboardManager|chart_generator<br ALIGN="LEFT"/>dashboard_templates : dict<br ALIGN="LEFT"/>dashboards : Dict[str, Dashboard]<br ALIGN="LEFT"/>data_collector<br ALIGN="LEFT"/>|create_custom_dashboard(name: str, description: str, chart_configs: List[Dict[str, Any]]): Dashboard<br ALIGN="LEFT"/>create_dashboard_from_template(template_name: str): Optional[Dashboard]<br ALIGN="LEFT"/>export_dashboard(dashboard_id: str, export_path: Path): bool<br ALIGN="LEFT"/>get_dashboard(dashboard_id: str): Optional[Dashboard]<br ALIGN="LEFT"/>list_dashboards(): List[Dict[str, str]]<br ALIGN="LEFT"/>refresh_dashboard(dashboard_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dashboard_manager.DashboardManager" [color="black", fontcolor="black", label=<{DashboardManager|app : Any<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_recent_activities : int<br ALIGN="LEFT"/>recent_activities : List[Dict[str, str]], list<br ALIGN="LEFT"/>stats : Dict[str, Any], dict<br ALIGN="LEFT"/>|add_activity(activity_type: str, description: str): None<br ALIGN="LEFT"/>clear_activities(): None<br ALIGN="LEFT"/>export_stats(filepath: str): bool<br ALIGN="LEFT"/>get_recent_activities(): List[Dict[str, str]]<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_summary(): Dict[str, Union[str, int]]<br ALIGN="LEFT"/>update_statistics(stats_dict: Dict[str, Any]): None<br ALIGN="LEFT"/>update_stats(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.dashboard_tab.DashboardTab" [color="black", fontcolor="black", label=<{DashboardTab|activity_log<br ALIGN="LEFT"/>analysis_results : dict<br ALIGN="LEFT"/>analysis_saved<br ALIGN="LEFT"/>binary_info_text<br ALIGN="LEFT"/>binary_path_edit<br ALIGN="LEFT"/>binary_selected<br ALIGN="LEFT"/>cpu_status<br ALIGN="LEFT"/>current_binary<br ALIGN="LEFT"/>current_project<br ALIGN="LEFT"/>current_project_label<br ALIGN="LEFT"/>drop_zone<br ALIGN="LEFT"/>file_tree<br ALIGN="LEFT"/>gpu_status<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>project_closed<br ALIGN="LEFT"/>project_files : list<br ALIGN="LEFT"/>project_opened<br ALIGN="LEFT"/>recent_files_list<br ALIGN="LEFT"/>system_monitor<br ALIGN="LEFT"/>|add_to_recent_files(file_path)<br ALIGN="LEFT"/>browse_binary()<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>clear_activity_log()<br ALIGN="LEFT"/>clear_recent_files()<br ALIGN="LEFT"/>create_activity_panel()<br ALIGN="LEFT"/>create_cpu_status_panel()<br ALIGN="LEFT"/>create_gpu_status_panel()<br ALIGN="LEFT"/>create_new_project()<br ALIGN="LEFT"/>create_project_controls()<br ALIGN="LEFT"/>create_system_monitor_panel()<br ALIGN="LEFT"/>delete_selected_file()<br ALIGN="LEFT"/>display_binary_info(binary_path)<br ALIGN="LEFT"/>dragEnterEvent(event: QDragEnterEvent)<br ALIGN="LEFT"/>dropEvent(event: QDropEvent)<br ALIGN="LEFT"/>get_file_type(file_path)<br ALIGN="LEFT"/>handle_system_alert(alert_type: str, message: str)<br ALIGN="LEFT"/>load_in_ghidra()<br ALIGN="LEFT"/>load_in_radare()<br ALIGN="LEFT"/>load_recent_file(item)<br ALIGN="LEFT"/>log_activity(message)<br ALIGN="LEFT"/>on_analysis_completed(analysis_type, results)<br ALIGN="LEFT"/>on_binary_loaded(binary_info)<br ALIGN="LEFT"/>open_project()<br ALIGN="LEFT"/>open_selected_file()<br ALIGN="LEFT"/>populate_file_tree()<br ALIGN="LEFT"/>populate_recent_files()<br ALIGN="LEFT"/>quick_analyze_binary()<br ALIGN="LEFT"/>refresh_file_tree()<br ALIGN="LEFT"/>save_activity_log()<br ALIGN="LEFT"/>save_project()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" [color="black", fontcolor="black", label=<{DashboardTab|activity_log<br ALIGN="LEFT"/>analysis_results : dict<br ALIGN="LEFT"/>analysis_saved<br ALIGN="LEFT"/>binary_info_text<br ALIGN="LEFT"/>binary_path_edit<br ALIGN="LEFT"/>binary_selected<br ALIGN="LEFT"/>cpu_status<br ALIGN="LEFT"/>current_binary : NoneType<br ALIGN="LEFT"/>current_project : NoneType<br ALIGN="LEFT"/>current_project_label<br ALIGN="LEFT"/>drop_zone<br ALIGN="LEFT"/>file_tree<br ALIGN="LEFT"/>gpu_status<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>project_closed<br ALIGN="LEFT"/>project_data : dict<br ALIGN="LEFT"/>project_opened<br ALIGN="LEFT"/>recent_files_list<br ALIGN="LEFT"/>system_monitor<br ALIGN="LEFT"/>|add_to_recent_files(file_path)<br ALIGN="LEFT"/>browse_binary()<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>clear_activity_log()<br ALIGN="LEFT"/>clear_recent_files()<br ALIGN="LEFT"/>create_activity_panel()<br ALIGN="LEFT"/>create_cpu_status_panel()<br ALIGN="LEFT"/>create_gpu_status_panel()<br ALIGN="LEFT"/>create_new_project()<br ALIGN="LEFT"/>create_project_controls()<br ALIGN="LEFT"/>create_system_monitor_panel()<br ALIGN="LEFT"/>delete_selected_file()<br ALIGN="LEFT"/>display_binary_info(binary_path)<br ALIGN="LEFT"/>dragEnterEvent(event: QDragEnterEvent)<br ALIGN="LEFT"/>dropEvent(event: QDropEvent)<br ALIGN="LEFT"/>get_file_type(file_path)<br ALIGN="LEFT"/>handle_system_alert(alert_type: str, message: str)<br ALIGN="LEFT"/>load_in_ghidra()<br ALIGN="LEFT"/>load_in_radare()<br ALIGN="LEFT"/>load_recent_file(item)<br ALIGN="LEFT"/>log_activity(message)<br ALIGN="LEFT"/>on_analysis_completed(analysis_type, results)<br ALIGN="LEFT"/>on_binary_loaded(binary_info)<br ALIGN="LEFT"/>open_project()<br ALIGN="LEFT"/>open_selected_file()<br ALIGN="LEFT"/>populate_file_tree()<br ALIGN="LEFT"/>populate_recent_files()<br ALIGN="LEFT"/>quick_analyze_binary()<br ALIGN="LEFT"/>refresh_file_tree()<br ALIGN="LEFT"/>save_activity_log()<br ALIGN="LEFT"/>save_project()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>start_monitoring_widgets()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.project_workspace_tab.DashboardTab" [color="black", fontcolor="black", label=<{DashboardTab|activity_log<br ALIGN="LEFT"/>analysis_saved<br ALIGN="LEFT"/>architecture_label<br ALIGN="LEFT"/>binary_icon_label<br ALIGN="LEFT"/>binary_info_label<br ALIGN="LEFT"/>binary_selected<br ALIGN="LEFT"/>current_binary_path : NoneType<br ALIGN="LEFT"/>entry_point_label<br ALIGN="LEFT"/>file_size_label<br ALIGN="LEFT"/>patches_label<br ALIGN="LEFT"/>protections_label<br ALIGN="LEFT"/>recent_files : list<br ALIGN="LEFT"/>recent_files_menu<br ALIGN="LEFT"/>vulns_found_label<br ALIGN="LEFT"/>|add_to_recent_files(file_path)<br ALIGN="LEFT"/>clear_activity_log()<br ALIGN="LEFT"/>clear_analysis()<br ALIGN="LEFT"/>close_binary()<br ALIGN="LEFT"/>create_dashboard_overview_panel()<br ALIGN="LEFT"/>create_new_project()<br ALIGN="LEFT"/>create_project_controls_panel()<br ALIGN="LEFT"/>export_results()<br ALIGN="LEFT"/>format_file_size(size_bytes)<br ALIGN="LEFT"/>load_binary(file_path)<br ALIGN="LEFT"/>log_activity(message)<br ALIGN="LEFT"/>open_project()<br ALIGN="LEFT"/>save_analysis_results()<br ALIGN="LEFT"/>save_project()<br ALIGN="LEFT"/>select_binary()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>update_recent_files_menu()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.DataCollector" [color="black", fontcolor="black", label=<{DataCollector|collection_enabled : bool<br ALIGN="LEFT"/>collection_interval : int<br ALIGN="LEFT"/>collectors : Dict[MetricType, Callable], dict<br ALIGN="LEFT"/>data_store : Dict[str, deque]<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>|get_data(metric_type: MetricType, time_range: int): List[DataPoint]<br ALIGN="LEFT"/>stop_collection()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_pandas_fallback.DataFrameFallback" [color="black", fontcolor="black", label=<{DataFrameFallback|data : NoneType, dict<br ALIGN="LEFT"/>|to_dict()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.data_inspector.DataInspector" [color="black", fontcolor="black", label=<{DataInspector|apply_button : NoneType<br ALIGN="LEFT"/>ascii_edit : NoneType<br ALIGN="LEFT"/>binary_edit : NoneType<br ALIGN="LEFT"/>checksum_label<br ALIGN="LEFT"/>clear_button : NoneType<br ALIGN="LEFT"/>current_data : bytes<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>data_modified<br ALIGN="LEFT"/>float_table : NoneType<br ALIGN="LEFT"/>hex_edit : NoneType<br ALIGN="LEFT"/>input_type_combo : NoneType<br ALIGN="LEFT"/>integer_table : NoneType<br ALIGN="LEFT"/>offset_label<br ALIGN="LEFT"/>size_label<br ALIGN="LEFT"/>special_table : NoneType<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>time_table : NoneType<br ALIGN="LEFT"/>utf16be_edit : NoneType<br ALIGN="LEFT"/>utf16le_edit : NoneType<br ALIGN="LEFT"/>utf8_edit : NoneType<br ALIGN="LEFT"/>value_edit : NoneType<br ALIGN="LEFT"/>|apply_modification()<br ALIGN="LEFT"/>clear_display()<br ALIGN="LEFT"/>clear_modification()<br ALIGN="LEFT"/>create_float_tab()<br ALIGN="LEFT"/>create_integer_tab()<br ALIGN="LEFT"/>create_modification_controls()<br ALIGN="LEFT"/>create_special_tab()<br ALIGN="LEFT"/>create_string_tab()<br ALIGN="LEFT"/>create_time_tab()<br ALIGN="LEFT"/>on_value_changed()<br ALIGN="LEFT"/>set_data(data: bytes, offset: int)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_display()<br ALIGN="LEFT"/>update_float_table()<br ALIGN="LEFT"/>update_integer_table()<br ALIGN="LEFT"/>update_special_table()<br ALIGN="LEFT"/>update_string_displays()<br ALIGN="LEFT"/>update_time_table()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.data_inspector.DataInterpreter" [color="black", fontcolor="black", label=<{DataInterpreter|<br ALIGN="LEFT"/>|interpret(data: bytes, data_type: DataType): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.DataPoint" [color="black", fontcolor="black", label=<{DataPoint|category : str<br ALIGN="LEFT"/>label : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.data_inspector.DataType" [color="black", fontcolor="black", label=<{DataType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.DatabaseManager" [color="black", fontcolor="black", label=<{DatabaseManager|SessionLocal : sessionmaker<br ALIGN="LEFT"/>db_path : str<br ALIGN="LEFT"/>engine : Engine, MockConnection, NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|get_db(): Session<br ALIGN="LEFT"/>log_operation(license_key: str, operation: str, client_ip: str, success: bool, details: str)<br ALIGN="LEFT"/>validate_license(license_key: str, product_name: str): Optional[LicenseEntry]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.DatabaseOptimizer" [color="black", fontcolor="black", label=<{DatabaseOptimizer|connection_pool : list<br ALIGN="LEFT"/>db_path : str<br ALIGN="LEFT"/>max_connections : int<br ALIGN="LEFT"/>query_cache : dict<br ALIGN="LEFT"/>query_stats : defaultdict<br ALIGN="LEFT"/>|execute_optimized(query: str, params): List[Tuple]<br ALIGN="LEFT"/>get_connection(): sqlite3.Connection<br ALIGN="LEFT"/>get_cursor()<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_indices()<br ALIGN="LEFT"/>return_connection(conn: sqlite3.Connection)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.DatasetAnalysisWidget" [color="black", fontcolor="black", label=<{DatasetAnalysisWidget|augment_cb : QCheckBox<br ALIGN="LEFT"/>browse_btn : QPushButton<br ALIGN="LEFT"/>current_dataset : NoneType<br ALIGN="LEFT"/>dataset_path_edit : QLineEdit<br ALIGN="LEFT"/>distribution_plot : PlotWidget<br ALIGN="LEFT"/>load_btn : QPushButton<br ALIGN="LEFT"/>matplotlib_ax<br ALIGN="LEFT"/>matplotlib_canvas : FigureCanvasQTAgg, NoneType<br ALIGN="LEFT"/>matplotlib_figure : Figure, NoneType<br ALIGN="LEFT"/>normalize_cb : QCheckBox<br ALIGN="LEFT"/>shuffle_cb : QCheckBox<br ALIGN="LEFT"/>stats_text : QTextEdit<br ALIGN="LEFT"/>train_split_label : QLabel<br ALIGN="LEFT"/>train_split_slider : QSlider<br ALIGN="LEFT"/>|analyze_dataset()<br ALIGN="LEFT"/>browse_dataset()<br ALIGN="LEFT"/>get_preprocessing_config()<br ALIGN="LEFT"/>load_dataset()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.debugger_detector.DebuggerDetector" [color="black", fontcolor="black", label=<{DebuggerDetector|debugger_signatures : dict<br ALIGN="LEFT"/>detection_methods : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|detect_debugger(aggressive: bool): Dict[str, Any]<br ALIGN="LEFT"/>generate_antidebug_code(techniques: List[str]): str<br ALIGN="LEFT"/>get_aggressive_methods(): List[str]<br ALIGN="LEFT"/>get_detection_type(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.DebuggerDialog" [color="black", fontcolor="black", label=<{DebuggerDialog|app_context : NoneType<br ALIGN="LEFT"/>binary_path : NoneType<br ALIGN="LEFT"/>breakpoint_lines : dict<br ALIGN="LEFT"/>breakpoint_list<br ALIGN="LEFT"/>breakpoints_widget<br ALIGN="LEFT"/>code_editor<br ALIGN="LEFT"/>console<br ALIGN="LEFT"/>current_line : NoneType<br ALIGN="LEFT"/>debug_tabs<br ALIGN="LEFT"/>debugger<br ALIGN="LEFT"/>debugger_thread : NoneType<br ALIGN="LEFT"/>file_label<br ALIGN="LEFT"/>output_thread : NoneType<br ALIGN="LEFT"/>pause_action<br ALIGN="LEFT"/>plugin_path : NoneType, str<br ALIGN="LEFT"/>repl_input<br ALIGN="LEFT"/>run_action<br ALIGN="LEFT"/>stack_list<br ALIGN="LEFT"/>step_into_action<br ALIGN="LEFT"/>step_out_action<br ALIGN="LEFT"/>step_over_action<br ALIGN="LEFT"/>stop_action<br ALIGN="LEFT"/>variables_tree<br ALIGN="LEFT"/>watch_input<br ALIGN="LEFT"/>watch_tree<br ALIGN="LEFT"/>watch_widget<br ALIGN="LEFT"/>|add_breakpoint_dialog()<br ALIGN="LEFT"/>add_watch()<br ALIGN="LEFT"/>browse_plugin()<br ALIGN="LEFT"/>clear_all_breakpoints()<br ALIGN="LEFT"/>clear_debug_info()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>create_breakpoints_widget(): QWidget<br ALIGN="LEFT"/>create_toolbar(): QToolBar<br ALIGN="LEFT"/>create_watch_widget(): QWidget<br ALIGN="LEFT"/>disable_breakpoint(bp_id: int)<br ALIGN="LEFT"/>enable_breakpoint(bp_id: int)<br ALIGN="LEFT"/>evaluate_expression()<br ALIGN="LEFT"/>handle_debugger_output(msg_type: str, data: Any)<br ALIGN="LEFT"/>load_plugin(path: str)<br ALIGN="LEFT"/>on_stack_frame_clicked(item: QListWidgetItem)<br ALIGN="LEFT"/>pause_execution()<br ALIGN="LEFT"/>remove_breakpoint(bp_id: int)<br ALIGN="LEFT"/>remove_selected_breakpoint()<br ALIGN="LEFT"/>run_continue()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_breakpoint_menu(pos)<br ALIGN="LEFT"/>start_debugging()<br ALIGN="LEFT"/>step_into()<br ALIGN="LEFT"/>step_out()<br ALIGN="LEFT"/>step_over()<br ALIGN="LEFT"/>stop_debugging()<br ALIGN="LEFT"/>toggle_breakpoint(line: int)<br ALIGN="LEFT"/>toggle_current_line_breakpoint()<br ALIGN="LEFT"/>update_breakpoint_display()<br ALIGN="LEFT"/>update_stack_display(stack_frames: List[Dict[str, Any]])<br ALIGN="LEFT"/>update_ui_state(state: str)<br ALIGN="LEFT"/>update_variables_display(frame_index: int)<br ALIGN="LEFT"/>update_watch_display(watches: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.DebuggerOutputThread" [color="black", fontcolor="black", label=<{DebuggerOutputThread|output_queue : Queue<br ALIGN="LEFT"/>output_received<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.DebuggerState" [color="black", fontcolor="black", label=<{DebuggerState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.DebuggerThread" [color="black", fontcolor="black", label=<{DebuggerThread|binary_path : Optional[str]<br ALIGN="LEFT"/>debugger<br ALIGN="LEFT"/>options : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>plugin_path : str<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.lazy_model_loader.DefaultLoadingStrategy" [color="black", fontcolor="black", label=<{DefaultLoadingStrategy|<br ALIGN="LEFT"/>|get_load_priority(config: LLMConfig): int<br ALIGN="LEFT"/>should_preload(config: LLMConfig): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.DeleteCommand" [color="black", fontcolor="black", label=<{DeleteCommand|deleted_data : Optional[bytes]<br ALIGN="LEFT"/>executed : bool<br ALIGN="LEFT"/>length : int<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>|execute(file_handler): bool<br ALIGN="LEFT"/>get_affected_range(): tuple<br ALIGN="LEFT"/>undo(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.demo_plugin.DemoPlugin" [color="black", fontcolor="black", label=<{DemoPlugin|analysis_count : int<br ALIGN="LEFT"/>demo_patterns : dict<br ALIGN="LEFT"/>file_signatures : dict<br ALIGN="LEFT"/>last_analysis_time : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>system_libraries : list<br ALIGN="LEFT"/>|analyze(binary_path: str): List[str]<br ALIGN="LEFT"/>configure(new_config: Dict[str, Any]): bool<br ALIGN="LEFT"/>get_capabilities(): List[str]<br ALIGN="LEFT"/>get_metadata(): Dict[str, Any]<br ALIGN="LEFT"/>patch(binary_path: str, options: Optional[Dict]): List[str]<br ALIGN="LEFT"/>run(): Dict[str, Any]<br ALIGN="LEFT"/>validate_binary(binary_path: str): tuple[bool, str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_core.DetectionResult" [color="black", fontcolor="black", label=<{DetectionResult|bypass_recommendations : List[str]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>details : Dict[str, any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>version : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.cfg_explorer._MockNetworkX.DiGraph" [color="black", fontcolor="black", label=<{DiGraph|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.event_handler_utils.DialogEventHandler" [color="black", fontcolor="black", label=<{DialogEventHandler|<br ALIGN="LEFT"/>|cleanup_thread(thread: QThread, timeout_seconds: int)<br ALIGN="LEFT"/>connect_thread_signals(thread: QThread, signal_connections: Dict[str, Callable])<br ALIGN="LEFT"/>create_close_confirmation(dialog: QDialog, condition_check: Callable[[], bool], title: str, message: str, cleanup_action: Optional[Callable]): Callable[[QCloseEvent], None]<br ALIGN="LEFT"/>create_context_menu(parent: QWidget, position_widget: QWidget, actions: Dict[str, Callable], condition_check: Optional[Callable]): Callable<br ALIGN="LEFT"/>create_periodic_timer(interval_ms: int, callback: Callable): QTimer<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.DiffGenerator" [color="black", fontcolor="black", label=<{DiffGenerator|<br ALIGN="LEFT"/>|generate_side_by_side_diff(original: str, modified: str): Dict[str, Any]<br ALIGN="LEFT"/>generate_unified_diff(original: str, modified: str, filename: str): str<br ALIGN="LEFT"/>get_change_summary(original: str, modified: str): Dict[str, int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.code_modification_dialog.DiffSyntaxHighlighter" [color="black", fontcolor="black", label=<{DiffSyntaxHighlighter|formats : dict<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.binary_differ.DiffType" [color="black", fontcolor="black", label=<{DiffType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.syscalls.DirectSyscalls" [color="black", fontcolor="black", label=<{DirectSyscalls|is_wow64 : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ntdll_base : NoneType<br ALIGN="LEFT"/>syscall_numbers : dict<br ALIGN="LEFT"/>wow64_transition : value<br ALIGN="LEFT"/>|nt_allocate_virtual_memory(process_handle: int, base_address: int, size: int, allocation_type: int, protection: int): Tuple[int, int]<br ALIGN="LEFT"/>nt_create_thread_ex(process_handle: int, start_address: int, parameter: int): Tuple[int, int]<br ALIGN="LEFT"/>nt_write_virtual_memory(process_handle: int, base_address: int, buffer: bytes): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.distributed_analysis_manager.DistributedAnalysisManager" [color="black", fontcolor="black", label=<{DistributedAnalysisManager|binary_path : Optional[str]<br ALIGN="LEFT"/>containers : List[Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>vms : List[Dict[str, Any]]<br ALIGN="LEFT"/>|add_container(container_type: str, image: str): int<br ALIGN="LEFT"/>add_vm(vm_type: str, arch: str, memory_mb: int): int<br ALIGN="LEFT"/>assign_task(node_id: int, task: str): bool<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>run_distributed_analysis(analysis_type: str): Dict[str, Any]<br ALIGN="LEFT"/>start_all(): bool<br ALIGN="LEFT"/>stop_all(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.distributed_config_dialog.DistributedProcessingConfigDialog" [color="black", fontcolor="black", label=<{DistributedProcessingConfigDialog|backend_combo<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>chunk_size_spin<br ALIGN="LEFT"/>convenience_check<br ALIGN="LEFT"/>crypto_check<br ALIGN="LEFT"/>custom_patterns_edit<br ALIGN="LEFT"/>entropy_check<br ALIGN="LEFT"/>hardware_check<br ALIGN="LEFT"/>license_check<br ALIGN="LEFT"/>pattern_check<br ALIGN="LEFT"/>section_check<br ALIGN="LEFT"/>symbolic_check<br ALIGN="LEFT"/>timeout_spin<br ALIGN="LEFT"/>window_size_spin<br ALIGN="LEFT"/>workers_spin<br ALIGN="LEFT"/>|get_config(): Dict[str, Any]<br ALIGN="LEFT"/>set_defaults(config: Dict[str, Any]): None<br ALIGN="LEFT"/>setup_ui(): None<br ALIGN="LEFT"/>validate_config(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.distributed_manager.DistributedProcessingManager" [color="black", fontcolor="black", label=<{DistributedProcessingManager|active_tasks : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>binary_path : Optional[str]<br ALIGN="LEFT"/>chunk_size<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>dask_available : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>multiprocessing_available : bool<br ALIGN="LEFT"/>num_workers<br ALIGN="LEFT"/>preferred_backend<br ALIGN="LEFT"/>ray_available : bool<br ALIGN="LEFT"/>result_queue : Optional[multiprocessing.Queue]<br ALIGN="LEFT"/>results : Dict[str, Any], dict<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>task_queue : Optional[multiprocessing.Queue]<br ALIGN="LEFT"/>tasks : List[Dict[str, Any]], list<br ALIGN="LEFT"/>worker_loads : Dict[int, float]<br ALIGN="LEFT"/>worker_performance : Dict[int, Dict[str, Any]]<br ALIGN="LEFT"/>workers : List[multiprocessing.Process], list<br ALIGN="LEFT"/>|add_task(task_type: str, task_params: Optional[Dict[str, Any]], task_description: Optional[str]): int<br ALIGN="LEFT"/>cleanup(): None<br ALIGN="LEFT"/>collect_results(timeout: Optional[float]): bool<br ALIGN="LEFT"/>generate_report(filename: Optional[str]): Optional[str]<br ALIGN="LEFT"/>get_results(): Dict[str, Any]<br ALIGN="LEFT"/>process_binary_chunks(process_func: Optional[Callable[[bytes, int], Any]]): Optional[List[Any]]<br ALIGN="LEFT"/>run_distributed_entropy_analysis(window_size_kb: int, chunk_size_mb: int): Dict[str, Any]<br ALIGN="LEFT"/>run_distributed_pattern_search(patterns: List[Union[str, bytes]], chunk_size_mb: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>set_binary(binary_path: str): bool<br ALIGN="LEFT"/>start_processing(): bool<br ALIGN="LEFT"/>stop_processing(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.communication_protocols.DnsProtocol" [color="black", fontcolor="black", label=<{DnsProtocol|connected : bool<br ALIGN="LEFT"/>domain : str<br ALIGN="LEFT"/>pending_queries : Dict[int, Any]<br ALIGN="LEFT"/>query_id_counter : int<br ALIGN="LEFT"/>resolver : NoneType<br ALIGN="LEFT"/>socket : socket<br ALIGN="LEFT"/>|connect(): bool<br ALIGN="LEFT"/>disconnect()<br ALIGN="LEFT"/>send_message(message: Dict[str, Any]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.docker_container.DockerContainer" [color="black", fontcolor="black", label=<{DockerContainer|binary_path : Optional[str]<br ALIGN="LEFT"/>container_id : NoneType, Optional[str]<br ALIGN="LEFT"/>container_name : NoneType, Optional[str]<br ALIGN="LEFT"/>image : str<br ALIGN="LEFT"/>|cleanup(): bool<br ALIGN="LEFT"/>collect_analysis_artifacts(): Dict[str, Any]<br ALIGN="LEFT"/>compare_snapshots(snapshot1: str, snapshot2: str): Dict[str, Any]<br ALIGN="LEFT"/>copy_file_to_container(source_path: str, dest_path: str): bool<br ALIGN="LEFT"/>create_snapshot(name: str): bool<br ALIGN="LEFT"/>execute_command(command: str, timeout: int, working_dir: Optional[str]): str<br ALIGN="LEFT"/>get_container_status(): Dict[str, Any]<br ALIGN="LEFT"/>start_container(privileged: bool, network_mode: str): bool<br ALIGN="LEFT"/>stop_container(force: bool): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleAPIHooker" [color="black", fontcolor="black", label=<{DongleAPIHooker|hooks : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>manager<br ALIGN="LEFT"/>|install_hooks()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleInterface" [color="black", fontcolor="black", label=<{DongleInterface|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleMemory" [color="black", fontcolor="black", label=<{DongleMemory|data : bytearray<br ALIGN="LEFT"/>protected_ranges : List[Tuple[int, int]]<br ALIGN="LEFT"/>read_only_ranges : List[Tuple[int, int]]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|read(address: int, length: int): bytes<br ALIGN="LEFT"/>write(address: int, data: bytes): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleRegistryManager" [color="black", fontcolor="black", label=<{DongleRegistryManager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|install_driver_entries(spec: DongleSpec)<br ALIGN="LEFT"/>remove_driver_entries(spec: DongleSpec)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleSpec" [color="black", fontcolor="black", label=<{DongleSpec|algorithms : List[str]<br ALIGN="LEFT"/>dongle_type<br ALIGN="LEFT"/>features : Dict[str, Any]<br ALIGN="LEFT"/>firmware_version : str<br ALIGN="LEFT"/>interface<br ALIGN="LEFT"/>memory_size : int<br ALIGN="LEFT"/>product_id : int<br ALIGN="LEFT"/>serial_number : str<br ALIGN="LEFT"/>vendor_id : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleType" [color="black", fontcolor="black", label=<{DongleType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_download_manager.DownloadProgress" [color="black", fontcolor="black", label=<{DownloadProgress|completed_files : int<br ALIGN="LEFT"/>current_file : str<br ALIGN="LEFT"/>downloaded_size : int<br ALIGN="LEFT"/>eta : float<br ALIGN="LEFT"/>percentage : float<br ALIGN="LEFT"/>progress_percent : float<br ALIGN="LEFT"/>speed : float<br ALIGN="LEFT"/>status : str<br ALIGN="LEFT"/>total_files : int<br ALIGN="LEFT"/>total_size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.interface.DownloadProgressCallback" [color="black", fontcolor="black", label=<{DownloadProgressCallback|<br ALIGN="LEFT"/>|<I>on_complete</I>(success: bool, message: str)<br ALIGN="LEFT"/><I>on_progress</I>(bytes_downloaded: int, total_bytes: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app.IntellicrackApp._import_from_api.start_download.DownloadThread" [color="black", fontcolor="black", label=<{DownloadThread|ai_conversation_history : list<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>model_id<br ALIGN="LEFT"/>model_manager<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>report_viewer : NoneType<br ALIGN="LEFT"/>reports : list<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.drop_zone_widget.DropZoneWidget" [color="black", fontcolor="black", label=<{DropZoneWidget|files_dropped<br ALIGN="LEFT"/>info_label<br ALIGN="LEFT"/>is_dragging : bool<br ALIGN="LEFT"/>label<br ALIGN="LEFT"/>|dragEnterEvent(event: QDragEnterEvent)<br ALIGN="LEFT"/>dragLeaveEvent(event)<br ALIGN="LEFT"/>dropEvent(event: QDropEvent)<br ALIGN="LEFT"/>paintEvent(event)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_style()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.plugin_system.DummyResource" [color="black", fontcolor="black", label=<{DummyResource|RLIMIT_CPU : int<br ALIGN="LEFT"/>RLIMIT_DATA : int<br ALIGN="LEFT"/>RLIMIT_FSIZE : int<br ALIGN="LEFT"/>RLIMIT_STACK : int<br ALIGN="LEFT"/>|getrlimit(resource_type)<br ALIGN="LEFT"/><I>setrlimit</I>(resource_type, limits)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app.DummySignal" [color="black", fontcolor="black", label=<{DummySignal|callbacks : list<br ALIGN="LEFT"/>|connect(callback)<br ALIGN="LEFT"/>disconnect(callback)<br ALIGN="LEFT"/>emit()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_tokenizer.DummyTokenizer" [color="black", fontcolor="black", label=<{DummyTokenizer|bos_token : str<br ALIGN="LEFT"/>bos_token_id<br ALIGN="LEFT"/>eos_token : str<br ALIGN="LEFT"/>eos_token_id<br ALIGN="LEFT"/>id_to_token<br ALIGN="LEFT"/>mask_token : str<br ALIGN="LEFT"/>mask_token_id<br ALIGN="LEFT"/>pad_token : str<br ALIGN="LEFT"/>pad_token_id<br ALIGN="LEFT"/>token_to_id<br ALIGN="LEFT"/>unk_token : str<br ALIGN="LEFT"/>unk_token_id<br ALIGN="LEFT"/>vocab<br ALIGN="LEFT"/>vocab_size<br ALIGN="LEFT"/>|decode(token_ids, skip_special_tokens)<br ALIGN="LEFT"/>encode(text, add_special_tokens, max_length, padding)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.DynamicAnalysisAgent" [color="black", fontcolor="black", label=<{DynamicAnalysisAgent|capabilities : list<br ALIGN="LEFT"/>|execute_task(task: AgentTask): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.DynamicHookManager" [color="black", fontcolor="black", label=<{DynamicHookManager|active_hooks : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>hook_registry : Dict[str, Callable]<br ALIGN="LEFT"/>hook_statistics : Dict[str, Dict[str, int]]<br ALIGN="LEFT"/>|get_hook_statistics(): Dict[str, Dict[str, int]]<br ALIGN="LEFT"/>install_hook(hook_id: str, modification: Dict[str, Any]): bool<br ALIGN="LEFT"/>register_hook_point(hook_id: str, target_function: Callable, hook_type: str)<br ALIGN="LEFT"/>remove_hook(hook_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.DynamicResponseGenerator" [color="black", fontcolor="black", label=<{DynamicResponseGenerator|cache_ttl : int<br ALIGN="LEFT"/>handlers : dict<br ALIGN="LEFT"/>learned_patterns : Dict[str, List[Dict[str, Any]]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>response_cache : Dict[str, Tuple[bytes, float]]<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|export_learning_data(): Dict[str, Any]<br ALIGN="LEFT"/>generate_response(context: ResponseContext): GeneratedResponse<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>import_learning_data(data: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_lief_fallback.LiefFallback.ELF" [color="black", fontcolor="black", label=<{ELF|<br ALIGN="LEFT"/>|parse(filename)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_esil.ESILAnalysisEngine" [color="black", fontcolor="black", label=<{ESILAnalysisEngine|binary_path : str<br ALIGN="LEFT"/>emulation_cache : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>|emulate_function_execution(address: int, max_steps: int): Dict[str, Any]<br ALIGN="LEFT"/>emulate_multiple_functions(function_addresses: List[int], max_steps_per_function: int): Dict[str, Any]<br ALIGN="LEFT"/>initialize_esil_vm(r2: R2Session): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.early_bird_injection.EarlyBirdInjector" [color="black", fontcolor="black", label=<{EarlyBirdInjector|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|get_required_libraries(): list<br ALIGN="LEFT"/>inject_early_bird(target_exe: str, dll_path: str, command_line: str): bool<br ALIGN="LEFT"/>inject_early_bird_shellcode(target_exe: str, shellcode: bytes, command_line: str): bool<br ALIGN="LEFT"/>inject_early_bird_with_context(target_exe: str, dll_path: str, modify_entry_point: bool): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.emulator_manager.EmulatorManager" [color="black", fontcolor="black", label=<{EmulatorManager|emulator_error<br ALIGN="LEFT"/>emulator_status_changed<br ALIGN="LEFT"/>emulators : dict<br ALIGN="LEFT"/>is_running : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>qemu_instance<br ALIGN="LEFT"/>qemu_running : bool<br ALIGN="LEFT"/>qemu_starting : bool<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>ensure_qemu_running(binary_path: str, config: Optional[Dict[str, Any]]): bool<br ALIGN="LEFT"/>ensure_qiling_ready(binary_path: str): Optional[QilingEmulator]<br ALIGN="LEFT"/>stop_qemu()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.emulator_ui_enhancements.EmulatorRequiredDecorator" [color="black", fontcolor="black", label=<{EmulatorRequiredDecorator|<br ALIGN="LEFT"/>|requires_qemu(func)<br ALIGN="LEFT"/>requires_qiling(func)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.emulator_ui_enhancements.EmulatorStatusWidget" [color="black", fontcolor="black", label=<{EmulatorStatusWidget|emulator_status : dict<br ALIGN="LEFT"/>qemu_label<br ALIGN="LEFT"/>qemu_status<br ALIGN="LEFT"/>qiling_label<br ALIGN="LEFT"/>qiling_status<br ALIGN="LEFT"/>|setup_ui()<br ALIGN="LEFT"/>update_emulator_status(emulator_type: str, is_running: bool, message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.encoder_engine.EncoderEngine" [color="black", fontcolor="black", label=<{EncoderEngine|arch : str<br ALIGN="LEFT"/>bad_chars : list<br ALIGN="LEFT"/>encode_cache : dict<br ALIGN="LEFT"/>encoders : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|benchmark_encoding_schemes(test_payload: bytes): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>decode_payload(encoded_data: Any, encoding_scheme: str, decode_info: Dict[str, Any]): bytes<br ALIGN="LEFT"/>encode_payload(payload: bytes, encoding_scheme: str, encoding_params: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_encoding_schemes(): List[str]<br ALIGN="LEFT"/>get_random_encoding_scheme(): str<br ALIGN="LEFT"/>multi_encode_payload(payload: bytes, encoding_schemes: List[str], encoding_params: List[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_types.EncodingType" [color="black", fontcolor="black", label=<{EncodingType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.encryption_manager.EncryptionManager" [color="black", fontcolor="black", label=<{EncryptionManager|block_size<br ALIGN="LEFT"/>cipher : NoneType<br ALIGN="LEFT"/>encryption_type : str<br ALIGN="LEFT"/>iv : NoneType<br ALIGN="LEFT"/>key : NoneType<br ALIGN="LEFT"/>key_file : NoneType<br ALIGN="LEFT"/>key_size<br ALIGN="LEFT"/>last_key_rotation<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>master_key<br ALIGN="LEFT"/>rsa_private_key<br ALIGN="LEFT"/>rsa_public_key<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>supported_types : list<br ALIGN="LEFT"/>|cleanup_expired_sessions()<br ALIGN="LEFT"/>create_session_key(session_id: str): bytes<br ALIGN="LEFT"/>decrypt(encrypted_data: bytes, session_id: str): str<br ALIGN="LEFT"/>decrypt_file(encrypted_file_path: str, output_path: str, session_id: str): str<br ALIGN="LEFT"/>derive_key_from_password(password: str, salt: bytes): bytes<br ALIGN="LEFT"/>encrypt(plaintext: str, session_id: str): bytes<br ALIGN="LEFT"/>encrypt_file(file_path: str, output_path: str, session_id: str): str<br ALIGN="LEFT"/>exchange_keys(client_public_key_pem: bytes): Dict[str, Any]<br ALIGN="LEFT"/>export_session_key(session_id: str): Optional[str]<br ALIGN="LEFT"/>generate_random_key(length: int): bytes<br ALIGN="LEFT"/>get_public_key_pem(): str<br ALIGN="LEFT"/>get_session_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>import_session_key(exported_key_data: str): bool<br ALIGN="LEFT"/>rotate_keys(force: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.enhanced_ui_integration.EnhancedAnalysisDashboard" [color="black", fontcolor="black", label=<{EnhancedAnalysisDashboard|activity_list<br ALIGN="LEFT"/>analysis_status<br ALIGN="LEFT"/>content_tabs<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>main_app : NoneType<br ALIGN="LEFT"/>r2_widget<br ALIGN="LEFT"/>report_editor<br ALIGN="LEFT"/>report_template_combo<br ALIGN="LEFT"/>stats_labels : dict<br ALIGN="LEFT"/>viz_area<br ALIGN="LEFT"/>viz_info<br ALIGN="LEFT"/>viz_scene<br ALIGN="LEFT"/>viz_type_combo<br ALIGN="LEFT"/>|add_activity(message: str)<br ALIGN="LEFT"/>set_analysis_status(status: str, color: str)<br ALIGN="LEFT"/>update_stats(stats_data: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.enhanced_runner.EnhancedCLIRunner" [color="black", fontcolor="black", label=<{EnhancedCLIRunner|console : Console<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_manager<br ALIGN="LEFT"/>results : dict<br ALIGN="LEFT"/>|display_results(): None<br ALIGN="LEFT"/>run_with_progress(binary_path: str, operations: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.enhanced_ui_integration.EnhancedMainWindow" [color="black", fontcolor="black", label=<{EnhancedMainWindow|binary_info_label<br ALIGN="LEFT"/>binary_path : NoneType<br ALIGN="LEFT"/>dashboard<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.qemu_test_manager_enhanced.EnhancedQEMUTestManager" [color="black", fontcolor="black", label=<{EnhancedQEMUTestManager|<br ALIGN="LEFT"/>|analyze_binary_for_vm(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>monitor_process_in_vm(process_id: int): Dict[str, Any]<br ALIGN="LEFT"/>test_frida_script_with_callback(snapshot_id: str, script_content: str, binary_path: str, output_callback: Callable[[str], None])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [color="black", fontcolor="black", label=<{EnhancedTrainingInterface|augmentation_cb : NoneType, QCheckBox<br ALIGN="LEFT"/>batch_size_spin : NoneType, QSpinBox<br ALIGN="LEFT"/>config : NoneType<br ALIGN="LEFT"/>config_tab : QScrollArea<br ALIGN="LEFT"/>dataset_tab<br ALIGN="LEFT"/>early_stopping_cb : NoneType, QCheckBox<br ALIGN="LEFT"/>epochs_spin : NoneType, QSpinBox<br ALIGN="LEFT"/>gpu_cb : NoneType, QCheckBox<br ALIGN="LEFT"/>hyperopt_tab<br ALIGN="LEFT"/>learning_rate_spin : NoneType, QDoubleSpinBox<br ALIGN="LEFT"/>load_config_btn : QPushButton<br ALIGN="LEFT"/>model_name_edit : NoneType, QLineEdit<br ALIGN="LEFT"/>model_type_combo : NoneType, QComboBox<br ALIGN="LEFT"/>pause_btn : QPushButton<br ALIGN="LEFT"/>progress_bar : QProgressBar<br ALIGN="LEFT"/>save_config_btn : QPushButton<br ALIGN="LEFT"/>start_btn : QPushButton<br ALIGN="LEFT"/>status_label : QLabel<br ALIGN="LEFT"/>stop_btn : QPushButton<br ALIGN="LEFT"/>tabs : QTabWidget<br ALIGN="LEFT"/>training_thread : NoneType<br ALIGN="LEFT"/>transfer_learning_cb : NoneType, QCheckBox<br ALIGN="LEFT"/>validation_split_slider : NoneType, QSlider<br ALIGN="LEFT"/>validation_split_spin : NoneType, QDoubleSpinBox<br ALIGN="LEFT"/>viz_tab<br ALIGN="LEFT"/>|apply_styling()<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>create_config_tab(): QWidget<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>load_configuration()<br ALIGN="LEFT"/>pause_training()<br ALIGN="LEFT"/>reset_ui_state()<br ALIGN="LEFT"/>resume_training()<br ALIGN="LEFT"/>save_configuration()<br ALIGN="LEFT"/>start_training()<br ALIGN="LEFT"/>stop_training()<br ALIGN="LEFT"/>training_completed(results: Dict[str, Any])<br ALIGN="LEFT"/>training_error(error_message: str)<br ALIGN="LEFT"/>update_config_from_ui()<br ALIGN="LEFT"/>update_status(message: str)<br ALIGN="LEFT"/>update_ui_from_config()<br ALIGN="LEFT"/>validate_config(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_enhanced_transformer_model.EnhancedTransformerModel._create_enhanced_layer.EnhancedTransformerLayer" [color="black", fontcolor="black", label=<{EnhancedTransformerLayer|attention : MultiheadAttention<br ALIGN="LEFT"/>attention_dropout : Dropout<br ALIGN="LEFT"/>attention_norm : LayerNorm<br ALIGN="LEFT"/>feed_forward : Sequential<br ALIGN="LEFT"/>ffn_norm : LayerNorm<br ALIGN="LEFT"/>|forward(x, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_enhanced_transformer_model.EnhancedTransformerModel" [color="black", fontcolor="black", label=<{EnhancedTransformerModel|embedding_dropout : Dropout<br ALIGN="LEFT"/>final_norm : LayerNorm<br ALIGN="LEFT"/>hidden_size<br ALIGN="LEFT"/>layers : ModuleList<br ALIGN="LEFT"/>max_seq_len : int<br ALIGN="LEFT"/>num_heads<br ALIGN="LEFT"/>output_projection : Linear<br ALIGN="LEFT"/>position_embedding : Embedding<br ALIGN="LEFT"/>token_embedding : Embedding<br ALIGN="LEFT"/>|forward(input_ids, attention_mask, return_attention)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.EnsembleModule" [color="black", fontcolor="black", label=<{EnsembleModule|RandomForestClassifier<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.entropy_analyzer.EntropyAnalyzer" [color="black", fontcolor="black", label=<{EntropyAnalyzer|high_entropy_threshold : float<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>medium_entropy_threshold : float<br ALIGN="LEFT"/>|analyze_entropy(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>calculate_entropy(data: bytes): float<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.entropy_graph_widget.EntropyGraphWidget" [color="black", fontcolor="black", label=<{EntropyGraphWidget|ax : NoneType<br ALIGN="LEFT"/>bar_graph<br ALIGN="LEFT"/>canvas : FigureCanvasQTAgg, NoneType<br ALIGN="LEFT"/>entropy_data : List[Any], list<br ALIGN="LEFT"/>figure : Figure, NoneType<br ALIGN="LEFT"/>plot_widget<br ALIGN="LEFT"/>section_clicked<br ALIGN="LEFT"/>summary_label<br ALIGN="LEFT"/>title_label<br ALIGN="LEFT"/>|export_graph(file_path: str)<br ALIGN="LEFT"/>get_entropy_summary(): dict<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>update_entropy_data(entropy_info: List[Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.intellicrack_advanced_protection_widget.EntropyGraphWidget" [color="black", fontcolor="black", label=<{EntropyGraphWidget|figure : Figure<br ALIGN="LEFT"/>|plot_entropy(entropy_data: List[EntropyInfo])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.EntropyInfo" [color="black", fontcolor="black", label=<{EntropyInfo|encrypted : bool<br ALIGN="LEFT"/>entropy : float<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>packed : bool<br ALIGN="LEFT"/>section_name : str<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.entropy_visualizer.EntropyVisualizer" [color="black", fontcolor="black", label=<{EntropyVisualizer|block_positions : list<br ALIGN="LEFT"/>current_data : NoneType<br ALIGN="LEFT"/>entropy_calculated<br ALIGN="LEFT"/>entropy_curve<br ALIGN="LEFT"/>entropy_data : list<br ALIGN="LEFT"/>file_data : NoneType, bytes<br ALIGN="LEFT"/>high_entropy_line<br ALIGN="LEFT"/>high_entropy_region<br ALIGN="LEFT"/>info_label<br ALIGN="LEFT"/>low_entropy_line<br ALIGN="LEFT"/>low_entropy_region<br ALIGN="LEFT"/>plot_widget<br ALIGN="LEFT"/>|calculate_entropy(data: bytes, block_size: int): tuple<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>find_suspicious_regions(): List[tuple]<br ALIGN="LEFT"/>load_data(data: bytes, block_size: int)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_plot()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.EnvironmentSanitizer" [color="black", fontcolor="black", label=<{EnvironmentSanitizer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>original_values : dict<br ALIGN="LEFT"/>|clean_environment_variables(): List[str]<br ALIGN="LEFT"/>clean_registry_artifacts(): List[str]<br ALIGN="LEFT"/>hide_debugger_processes(): List[str]<br ALIGN="LEFT"/>restore_environment(): bool<br ALIGN="LEFT"/>sanitize_all(): List[str]<br ALIGN="LEFT"/>sanitize_file_system(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.ErrorEvent" [color="black", fontcolor="black", label=<{ErrorEvent|context : Dict[str, Any]<br ALIGN="LEFT"/>error_type : str<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>recovery_attempts : int<br ALIGN="LEFT"/>recovery_strategy<br ALIGN="LEFT"/>resolved : bool<br ALIGN="LEFT"/>severity<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>traceback : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.ErrorSeverity" [color="black", fontcolor="black", label=<{ErrorSeverity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_types.EvasionTechnique" [color="black", fontcolor="black", label=<{EvasionTechnique|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.Event" [color="black", fontcolor="black", label=<{Event|correlation_id : Optional[str]<br ALIGN="LEFT"/>data : Dict[str, Any]<br ALIGN="LEFT"/>event_id : str<br ALIGN="LEFT"/>event_type : str<br ALIGN="LEFT"/>priority<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>target : Optional[str]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>ttl : Optional[int]<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventBus" [color="black", fontcolor="black", label=<{EventBus|event_history : List[Event], list<br ALIGN="LEFT"/>event_queue : Queue<br ALIGN="LEFT"/>logger : Optional[logging.Logger]<br ALIGN="LEFT"/>max_history_size : int<br ALIGN="LEFT"/>processor_task : Optional[asyncio.Task]<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>subscribers : Dict[str, List[Callable]]<br ALIGN="LEFT"/>|emit(event: Event)<br ALIGN="LEFT"/>get_recent_events(count: int): List[Event]<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>set_logger(logger: logging.Logger)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>subscribe(event_type: str, handler: Callable[[Event], Awaitable[None]])<br ALIGN="LEFT"/>unsubscribe(event_type: str, handler: Callable[[Event], Awaitable[None]])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventPriority" [color="black", fontcolor="black", label=<{EventPriority|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.EventTracker" [color="black", fontcolor="black", label=<{EventTracker|db_path : str<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>|get_events(component: str, protection_category: ProtectionCategory, start_time: float, end_time: float): List[AnalysisEvent]<br ALIGN="LEFT"/>get_success_counts(component: str, protection_category: ProtectionCategory, start_time: float, end_time: float): Tuple[int, int]<br ALIGN="LEFT"/>initialize_database()<br ALIGN="LEFT"/>log_event(event: AnalysisEvent)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.EventType" [color="black", fontcolor="black", label=<{EventType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.ExceptionHandler" [color="black", fontcolor="black", label=<{ExceptionHandler|exception_count : int<br ALIGN="LEFT"/>kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>original_handler : NoneType<br ALIGN="LEFT"/>|custom_exception_handler(exception_info)<br ALIGN="LEFT"/>install_exception_handler(): bool<br ALIGN="LEFT"/>mask_debug_exceptions(): bool<br ALIGN="LEFT"/>remove_exception_handler(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.autonomous_agent.ExecutionResult" [color="black", fontcolor="black", label=<{ExecutionResult|error : str<br ALIGN="LEFT"/>exit_code : int<br ALIGN="LEFT"/>output : str<br ALIGN="LEFT"/>runtime_ms : int<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>timestamp : Optional[datetime]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.ExecutionTimePredictor" [color="black", fontcolor="black", label=<{ExecutionTimePredictor|feature_extractor<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>|predict_execution_time(operation_type: str, context: Dict[str, Any]): PredictionResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitChain" [color="black", fontcolor="black", label=<{ExploitChain|chain_id : str<br ALIGN="LEFT"/>complexity<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>memory_footprint : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>safety_report : Dict[str, Any]<br ALIGN="LEFT"/>safety_verified : bool<br ALIGN="LEFT"/>stability_rating : float<br ALIGN="LEFT"/>stealth_rating : float<br ALIGN="LEFT"/>steps : List[ExploitStep]<br ALIGN="LEFT"/>success_probability : float<br ALIGN="LEFT"/>target_vulnerability : str<br ALIGN="LEFT"/>test_results : Dict[str, Any]<br ALIGN="LEFT"/>tested : bool<br ALIGN="LEFT"/>total_execution_time : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitChainFramework" [color="black", fontcolor="black", label=<{ExploitChainFramework|chain_templates : Dict[str, List[ExploitPrimitive]]<br ALIGN="LEFT"/>primitive_lib<br ALIGN="LEFT"/>success_patterns : Dict[str, float]<br ALIGN="LEFT"/>|build_exploit_chain(vulnerability: Vulnerability, requirements: Optional[Dict[str, Any]]): Optional[ExploitChain]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.exploit_developer.ExploitDeveloper" [color="black", fontcolor="black", label=<{ExploitDeveloper|techniques : list<br ALIGN="LEFT"/>templates : dict<br ALIGN="LEFT"/>|develop_exploit(vulnerability_info)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitPrimitive" [color="black", fontcolor="black", label=<{ExploitPrimitive|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitPrimitiveLibrary" [color="black", fontcolor="black", label=<{ExploitPrimitiveLibrary|gadgets : Dict[str, List[str]]<br ALIGN="LEFT"/>primitives : Dict[ExploitPrimitive, List[Dict[str, Any]]]<br ALIGN="LEFT"/>templates : Dict[str, str]<br ALIGN="LEFT"/>|add_primitive(primitive_type: ExploitPrimitive, primitive_data: Dict[str, Any])<br ALIGN="LEFT"/>get_primitive(primitive_type: ExploitPrimitive, requirements: Optional[List[str]]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitStep" [color="black", fontcolor="black", label=<{ExploitStep|code_template : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>failure_modes : List[str]<br ALIGN="LEFT"/>memory_requirements : int<br ALIGN="LEFT"/>outputs : List[str]<br ALIGN="LEFT"/>payload_data : Optional[str]<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>reliability : float<br ALIGN="LEFT"/>step_id : str<br ALIGN="LEFT"/>step_type<br ALIGN="LEFT"/>success_criteria : List[str]<br ALIGN="LEFT"/>verification_code : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.exploit_developer.ExploitTemplate" [color="black", fontcolor="black", label=<{ExploitTemplate|exploit_type<br ALIGN="LEFT"/>template : str<br ALIGN="LEFT"/>|generate(params)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitType" [color="black", fontcolor="black", label=<{ExploitType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [color="black", fontcolor="black", label=<{ExploitationOrchestrator|active_campaigns : dict<br ALIGN="LEFT"/>ai_insights : dict<br ALIGN="LEFT"/>ai_model : NoneType<br ALIGN="LEFT"/>c2_manager : NoneType<br ALIGN="LEFT"/>exploitation_history : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>metrics : dict<br ALIGN="LEFT"/>payload_engine : NoneType<br ALIGN="LEFT"/>persistence_manager : NoneType<br ALIGN="LEFT"/>privesc_manager : NoneType<br ALIGN="LEFT"/>research_manager : NoneType<br ALIGN="LEFT"/>vuln_research_ai : NoneType<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>get_campaign_history(limit: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_orchestrator_status(): Dict[str, Any]<br ALIGN="LEFT"/>orchestrate_full_exploitation(target_info: Dict[str, Any], orchestration_config: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.exploitation_tab.ExploitationTab" [color="black", fontcolor="black", label=<{ExploitationTab|arch_combo<br ALIGN="LEFT"/>attached_process : int<br ALIGN="LEFT"/>binary_path_edit<br ALIGN="LEFT"/>bypass_aslr_cb<br ALIGN="LEFT"/>bypass_dep_cb<br ALIGN="LEFT"/>bypass_stack_protection_cb<br ALIGN="LEFT"/>console_output<br ALIGN="LEFT"/>crash_address_edit<br ALIGN="LEFT"/>current_rop_generator<br ALIGN="LEFT"/>current_shellcode : NoneType, bytes<br ALIGN="LEFT"/>disable_antidebug_cb<br ALIGN="LEFT"/>exploit_generated<br ALIGN="LEFT"/>exploitation_subtabs<br ALIGN="LEFT"/>gadgets_table<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>memory_address_edit<br ALIGN="LEFT"/>memory_patched<br ALIGN="LEFT"/>patch_applied<br ALIGN="LEFT"/>patch_data_edit<br ALIGN="LEFT"/>patch_list<br ALIGN="LEFT"/>patch_size_spin<br ALIGN="LEFT"/>patch_type_combo<br ALIGN="LEFT"/>pattern_length_spin<br ALIGN="LEFT"/>payload_display<br ALIGN="LEFT"/>process_combo<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>shellcode_params_edit<br ALIGN="LEFT"/>shellcode_type_combo<br ALIGN="LEFT"/>success_stats_table<br ALIGN="LEFT"/>target_address_edit<br ALIGN="LEFT"/>target_function_edit<br ALIGN="LEFT"/>test_mode_combo<br ALIGN="LEFT"/>test_patches_cb<br ALIGN="LEFT"/>test_process_edit<br ALIGN="LEFT"/>test_results_table<br ALIGN="LEFT"/>test_rop_cb<br ALIGN="LEFT"/>test_shellcode_cb<br ALIGN="LEFT"/>|add_patch()<br ALIGN="LEFT"/>apply_all_patches()<br ALIGN="LEFT"/>attach_to_process()<br ALIGN="LEFT"/>browse_binary()<br ALIGN="LEFT"/>clear_output()<br ALIGN="LEFT"/>create_exploit_development_tab()<br ALIGN="LEFT"/>create_exploitation_controls_panel()<br ALIGN="LEFT"/>create_memory_patching_tab()<br ALIGN="LEFT"/>create_patch_management_tab()<br ALIGN="LEFT"/>create_results_panel()<br ALIGN="LEFT"/>create_testing_validation_tab()<br ALIGN="LEFT"/>dump_memory()<br ALIGN="LEFT"/>edit_patch()<br ALIGN="LEFT"/>encode_shellcode()<br ALIGN="LEFT"/>export_payloads()<br ALIGN="LEFT"/>find_offset()<br ALIGN="LEFT"/>find_rop_gadgets()<br ALIGN="LEFT"/>generate_pattern()<br ALIGN="LEFT"/>generate_quick_payload()<br ALIGN="LEFT"/>generate_rop_chain()<br ALIGN="LEFT"/>generate_shellcode()<br ALIGN="LEFT"/>log_message(message, level)<br ALIGN="LEFT"/>patch_memory()<br ALIGN="LEFT"/>refresh_processes()<br ALIGN="LEFT"/>remove_patch()<br ALIGN="LEFT"/>reset_statistics()<br ALIGN="LEFT"/>run_payload_tests()<br ALIGN="LEFT"/>save_results()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>simulate_patches()<br ALIGN="LEFT"/>test_all_exploits()<br ALIGN="LEFT"/>update_gadgets_table(gadgets)<br ALIGN="LEFT"/>update_test_results(test_results)<br ALIGN="LEFT"/>validate_exploits()<br ALIGN="LEFT"/>validate_patches()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.export_dialog.ExportDialog" [color="black", fontcolor="black", label=<{ExportDialog|analysis_results : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>browse_output_btn<br ALIGN="LEFT"/>confidence_threshold_spin<br ALIGN="LEFT"/>export_prefs : dict<br ALIGN="LEFT"/>export_worker : Optional[ExportWorker]<br ALIGN="LEFT"/>format_group<br ALIGN="LEFT"/>include_detections_cb<br ALIGN="LEFT"/>include_file_info_cb<br ALIGN="LEFT"/>include_metadata_cb<br ALIGN="LEFT"/>include_timestamp_cb<br ALIGN="LEFT"/>output_path_edit<br ALIGN="LEFT"/>page_format_combo<br ALIGN="LEFT"/>pretty_format_cb<br ALIGN="LEFT"/>preview_format_combo<br ALIGN="LEFT"/>preview_text<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>refresh_preview_btn<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|browse_output_file()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>on_export_completed(success: bool, message: str)<br ALIGN="LEFT"/>on_progress_update(progress: int, status: str)<br ALIGN="LEFT"/>refresh_preview()<br ALIGN="LEFT"/>start_export()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.ExportFormat" [color="black", fontcolor="black", label=<{ExportFormat|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.ExportInfo" [color="black", fontcolor="black", label=<{ExportInfo|address : int<br ALIGN="LEFT"/>forwarder : Optional[str]<br ALIGN="LEFT"/>function_name : str<br ALIGN="LEFT"/>ordinal : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.ExportResultsDialog" [color="black", fontcolor="black", label=<{ExportResultsDialog|campaign_list<br ALIGN="LEFT"/>campaign_results : Dict<br ALIGN="LEFT"/>compress_check<br ALIGN="LEFT"/>format_combo<br ALIGN="LEFT"/>metadata_check<br ALIGN="LEFT"/>raw_data_check<br ALIGN="LEFT"/>|get_selected_campaigns(): Dict[str, Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.export_dialog.ExportWorker" [color="black", fontcolor="black", label=<{ExportWorker|export_completed<br ALIGN="LEFT"/>export_config : Dict[str, Any]<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.config.external_tools_config.ExternalTool" [color="black", fontcolor="black", label=<{ExternalTool|alternatives : List[str]<br ALIGN="LEFT"/>category<br ALIGN="LEFT"/>custom_path : Optional[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>environment_vars : Dict[str, str]<br ALIGN="LEFT"/>executable : str<br ALIGN="LEFT"/>found_path : Optional[str]<br ALIGN="LEFT"/>found_version : Optional[str]<br ALIGN="LEFT"/>install_url : Optional[str]<br ALIGN="LEFT"/>last_checked : Optional[float]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>required : bool<br ALIGN="LEFT"/>required_version : Optional[str]<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>version_command : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.config.external_tools_config.ExternalToolsManager" [color="black", fontcolor="black", label=<{ExternalToolsManager|config_dir : Path<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>tools : Dict[str, ExternalTool]<br ALIGN="LEFT"/>|add_tool_environment_var(tool_name: str, var_name: str, var_value: str)<br ALIGN="LEFT"/>check_all_tools(force_check: bool): Dict[str, ToolStatus]<br ALIGN="LEFT"/>check_tool_availability(tool_name: str, force_check: bool): ToolStatus<br ALIGN="LEFT"/>create_fallback_configs(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>generate_status_report(): Dict[str, Any]<br ALIGN="LEFT"/>get_installation_script(tool_name: str): Optional[str]<br ALIGN="LEFT"/>get_missing_required_tools(): List[str]<br ALIGN="LEFT"/>get_tool_command(tool_name: str, args: List[str]): Optional[List[str]]<br ALIGN="LEFT"/>get_tool_environment(tool_name: str): Dict[str, str]<br ALIGN="LEFT"/>get_tool_path(tool_name: str): Optional[str]<br ALIGN="LEFT"/>get_tools_by_category(category: ToolCategory): List[ExternalTool]<br ALIGN="LEFT"/>save_config()<br ALIGN="LEFT"/>set_tool_path(tool_name: str, path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.ExtractedFile" [color="black", fontcolor="black", label=<{ExtractedFile|extracted_strings : List[str]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>hash : str<br ALIGN="LEFT"/>is_executable : bool<br ALIGN="LEFT"/>original_offset : int<br ALIGN="LEFT"/>permissions : str<br ALIGN="LEFT"/>security_analysis : Dict[str, Any]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|from_path(file_path: str, original_offset: int): 'ExtractedFile'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.FailureAnalysis" [color="black", fontcolor="black", label=<{FailureAnalysis|affected_components : List[str]<br ALIGN="LEFT"/>failure_id : str<br ALIGN="LEFT"/>failure_type : str<br ALIGN="LEFT"/>frequency : int<br ALIGN="LEFT"/>impact_level : str<br ALIGN="LEFT"/>mitigation_strategies : List[str]<br ALIGN="LEFT"/>pattern_signature : str<br ALIGN="LEFT"/>resolution_status : str<br ALIGN="LEFT"/>root_cause : str<br ALIGN="LEFT"/>suggested_fixes : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine_simple.FailureAnalysis" [color="black", fontcolor="black", label=<{FailureAnalysis|affected_components : List[str]<br ALIGN="LEFT"/>failure_id : str<br ALIGN="LEFT"/>failure_type : str<br ALIGN="LEFT"/>frequency : int<br ALIGN="LEFT"/>mitigation_strategies : List[str]<br ALIGN="LEFT"/>pattern_signature : str<br ALIGN="LEFT"/>resolution_status : str<br ALIGN="LEFT"/>suggested_fixes : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.FailureAnalysisEngine" [color="black", fontcolor="black", label=<{FailureAnalysisEngine|analysis_threshold : int<br ALIGN="LEFT"/>database<br ALIGN="LEFT"/>failure_patterns : Dict[str, List[str]]<br ALIGN="LEFT"/>|analyze_failures(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.FailureEvent" [color="black", fontcolor="black", label=<{FailureEvent|component : str<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>failure_id : str<br ALIGN="LEFT"/>failure_type<br ALIGN="LEFT"/>recovery_attempted : bool<br ALIGN="LEFT"/>recovery_strategy : Optional[RecoveryStrategy]<br ALIGN="LEFT"/>recovery_successful : bool<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>stack_trace : Optional[str]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_fallback_chains.FailureInfo" [color="black", fontcolor="black", label=<{FailureInfo|error_message : str<br ALIGN="LEFT"/>failure_type<br ALIGN="LEFT"/>retry_after : Optional[float]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_fallback_chains.FailureType" [color="black", fontcolor="black", label=<{FailureType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.FailureType" [color="black", fontcolor="black", label=<{FailureType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_fallback_chains.FallbackChain" [color="black", fontcolor="black", label=<{FallbackChain|chain_id : str<br ALIGN="LEFT"/>circuit_failure_threshold : int<br ALIGN="LEFT"/>enable_adaptive_ordering : bool<br ALIGN="LEFT"/>health_stats<br ALIGN="LEFT"/>llm_manager : NoneType<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>max_retries : int<br ALIGN="LEFT"/>model_configs : List[Tuple[str, LLMConfig]]<br ALIGN="LEFT"/>retry_delay : float<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): Optional[LLMResponse]<br ALIGN="LEFT"/>chat_async(messages: List[LLMMessage], tools: Optional[List[Dict]]): Optional[LLMResponse]<br ALIGN="LEFT"/>get_health_report(): Dict[str, Any]<br ALIGN="LEFT"/>reset_health_stats(model_id: Optional[str])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.FallbackHandler" [color="black", fontcolor="black", label=<{FallbackHandler|fallback_registry : dict<br ALIGN="LEFT"/>python_alternatives : dict<br ALIGN="LEFT"/>|get_fallback(tool_name: str)<br ALIGN="LEFT"/>list_available_fallbacks(): Dict[str, List[str]]<br ALIGN="LEFT"/>register_fallback(tool_name: str, fallback_func: Callable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_fallback_chains.FallbackManager" [color="black", fontcolor="black", label=<{FallbackManager|chains : dict<br ALIGN="LEFT"/>default_chain_id : NoneType, str<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], chain_id: Optional[str], tools: Optional[List[Dict]]): Optional[LLMResponse]<br ALIGN="LEFT"/>chat_async(messages: List[LLMMessage], chain_id: Optional[str], tools: Optional[List[Dict]]): Optional[LLMResponse]<br ALIGN="LEFT"/>create_chain(chain_id: str, model_configs: List[Tuple[str, LLMConfig]]): FallbackChain<br ALIGN="LEFT"/>create_chain_from_config(config: Dict[str, Any]): FallbackChain<br ALIGN="LEFT"/>export_configuration(): Dict[str, Any]<br ALIGN="LEFT"/>get_chain(chain_id: str): Optional[FallbackChain]<br ALIGN="LEFT"/>get_global_health_report(): Dict[str, Any]<br ALIGN="LEFT"/>import_configuration(config: Dict[str, Any], replace: bool)<br ALIGN="LEFT"/>list_chains(): List[str]<br ALIGN="LEFT"/>remove_chain(chain_id: str): bool<br ALIGN="LEFT"/>set_default_chain(chain_id: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_fallback_model.FallbackModel" [color="black", fontcolor="black", label=<{FallbackModel|config : dict<br ALIGN="LEFT"/>training : bool<br ALIGN="LEFT"/>|eval()<br ALIGN="LEFT"/>forward()<br ALIGN="LEFT"/>parameters()<br ALIGN="LEFT"/>train()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_client.C2Client._start_keylogging.FallbackWintypes" [color="black", fontcolor="black", label=<{FallbackWintypes|HANDLE : c_void_p<br ALIGN="LEFT"/>LPARAM : c_long<br ALIGN="LEFT"/>WPARAM : c_ulong<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.FeatureExtractor" [color="black", fontcolor="black", label=<{FeatureExtractor|feature_cache : Dict[str, Any]<br ALIGN="LEFT"/>feature_importance : Dict[str, float]<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|extract_exploit_features(exploit_context: Dict[str, Any]): Dict[str, float]<br ALIGN="LEFT"/>extract_operation_features(operation_type: str, context: Dict[str, Any]): Dict[str, float]<br ALIGN="LEFT"/>extract_vulnerability_features(vulnerability_context: Dict[str, Any]): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_file_tools.FileApprovalDialog" [color="black", fontcolor="black", label=<{FileApprovalDialog|approve_btn<br ALIGN="LEFT"/>deny_btn<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.FileCache" [color="black", fontcolor="black", label=<{FileCache|config<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>regions : OrderedDict[int, FileRegion]<br ALIGN="LEFT"/>total_memory : int<br ALIGN="LEFT"/>|add_region(region: FileRegion): bool<br ALIGN="LEFT"/>cleanup_old_regions(max_age: float): int<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>get_region(offset: int, size: int): Optional[FileRegion]<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>release_region(region: FileRegion)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.FileExplorerPanel" [color="black", fontcolor="black", label=<{FileExplorerPanel|back_btn : Button<br ALIGN="LEFT"/>browse_btn : Button<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>context_menu : Menu<br ALIGN="LEFT"/>current_path : Path<br ALIGN="LEFT"/>file_count_label : Label<br ALIGN="LEFT"/>frame : Frame<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>path_entry : Entry<br ALIGN="LEFT"/>path_var : StringVar<br ALIGN="LEFT"/>refresh_btn : Button<br ALIGN="LEFT"/>status_frame : Frame<br ALIGN="LEFT"/>status_label : Label<br ALIGN="LEFT"/>toolbar : Frame<br ALIGN="LEFT"/>tree : Treeview<br ALIGN="LEFT"/>ui_controller<br ALIGN="LEFT"/>up_btn : Button<br ALIGN="LEFT"/>|analyze_file(file_path: Path)<br ALIGN="LEFT"/>analyze_selected()<br ALIGN="LEFT"/>browse_folder()<br ALIGN="LEFT"/>copy_path()<br ALIGN="LEFT"/>create_context_menu()<br ALIGN="LEFT"/>create_file_tree()<br ALIGN="LEFT"/>create_status_bar()<br ALIGN="LEFT"/>create_toolbar()<br ALIGN="LEFT"/>format_file_size(size: int): str<br ALIGN="LEFT"/>generate_scripts()<br ALIGN="LEFT"/>get_file_icon(file_path: Path): str<br ALIGN="LEFT"/>go_back()<br ALIGN="LEFT"/>go_up()<br ALIGN="LEFT"/>on_double_click(event)<br ALIGN="LEFT"/>on_path_change(event)<br ALIGN="LEFT"/>on_right_click(event)<br ALIGN="LEFT"/>on_selection_change(event)<br ALIGN="LEFT"/>open_in_explorer()<br ALIGN="LEFT"/>refresh_tree()<br ALIGN="LEFT"/>show_properties()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.file_metadata_widget.FileMetadataWidget" [color="black", fontcolor="black", label=<{FileMetadataWidget|accessed_label<br ALIGN="LEFT"/>created_label<br ALIGN="LEFT"/>current_file : NoneType, str<br ALIGN="LEFT"/>executable_label<br ALIGN="LEFT"/>file_analyzed<br ALIGN="LEFT"/>metadata_group<br ALIGN="LEFT"/>modified_label<br ALIGN="LEFT"/>name_label<br ALIGN="LEFT"/>owner_label<br ALIGN="LEFT"/>path_label<br ALIGN="LEFT"/>permissions_label<br ALIGN="LEFT"/>refresh_button<br ALIGN="LEFT"/>size_label<br ALIGN="LEFT"/>symlink_label<br ALIGN="LEFT"/>timestamps_group<br ALIGN="LEFT"/>timestamps_text<br ALIGN="LEFT"/>type_label<br ALIGN="LEFT"/>|analyze_file(file_path: str): dict<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>refresh_metadata()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_file_tools.FileReadTool" [color="black", fontcolor="black", label=<{FileReadTool|app_instance : NoneType<br ALIGN="LEFT"/>max_file_size : int<br ALIGN="LEFT"/>|read_file_content(file_path: str, purpose: str): Dict[str, Any]<br ALIGN="LEFT"/>read_multiple_files(file_paths: List[str], purpose: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.file_reading_helper.FileReadingMixin" [color="black", fontcolor="black", label=<{FileReadingMixin|<br ALIGN="LEFT"/>|read_file_safe(file_path: str, purpose: str, mode: str, encoding: str, max_bytes: Optional[int]): Optional[Union[str, bytes]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.FileRegion" [color="black", fontcolor="black", label=<{FileRegion|compressed : bool<br ALIGN="LEFT"/>data : Optional[bytes]<br ALIGN="LEFT"/>last_accessed : float<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>ref_count : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.system.file_resolution.FileResolver" [color="black", fontcolor="black", label=<{FileResolver|FILE_TYPES : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|get_file_metadata(file_path: Union[str, Path]): Dict[str, any]<br ALIGN="LEFT"/>get_file_type_info(file_path: Union[str, Path]): FileTypeInfo<br ALIGN="LEFT"/>get_supported_file_filters(): str<br ALIGN="LEFT"/>resolve_file_path(file_path: Union[str, Path]): Tuple[str, Dict[str, any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_file_tools.FileSearchTool" [color="black", fontcolor="black", label=<{FileSearchTool|app_instance : NoneType<br ALIGN="LEFT"/>common_license_patterns : list<br ALIGN="LEFT"/>|quick_license_scan(program_directory: str): Dict[str, Any]<br ALIGN="LEFT"/>search_license_files(search_path: str, custom_patterns: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.FileStructure" [color="black", fontcolor="black", label=<{FileStructure|description : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>properties : Dict[str, Any]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>structure_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.file_metadata_widget.FileTimestampTracker" [color="black", fontcolor="black", label=<{FileTimestampTracker|tracked_files : dict<br ALIGN="LEFT"/>|check_file(file_path: str): dict<br ALIGN="LEFT"/>clear_all()<br ALIGN="LEFT"/>get_file_history(file_path: str): dict<br ALIGN="LEFT"/>stop_tracking(file_path: str)<br ALIGN="LEFT"/>track_file(file_path: str): dict<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.FileTreeWidget" [color="black", fontcolor="black", label=<{FileTreeWidget|current_root : NoneType, Path<br ALIGN="LEFT"/>file_selected<br ALIGN="LEFT"/>file_watcher<br ALIGN="LEFT"/>supported_extensions : dict<br ALIGN="LEFT"/>|get_expanded_items(): List[str]<br ALIGN="LEFT"/>on_item_clicked(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_item_double_clicked(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>populate_tree()<br ALIGN="LEFT"/>refresh_tree()<br ALIGN="LEFT"/>restore_expanded_items(expanded_paths: List[str])<br ALIGN="LEFT"/>set_root_directory(root_path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.file_resolution.FileTypeInfo" [color="black", fontcolor="black", label=<{FileTypeInfo|analyzer_hint : str<br ALIGN="LEFT"/>category : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>extension<br ALIGN="LEFT"/>supported : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.FillCommand" [color="black", fontcolor="black", label=<{FillCommand|executed : bool<br ALIGN="LEFT"/>fill_value : int<br ALIGN="LEFT"/>length : int<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>old_data : Optional[bytes]<br ALIGN="LEFT"/>|execute(file_handler): bool<br ALIGN="LEFT"/>get_affected_range(): tuple<br ALIGN="LEFT"/>undo(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.FilterStage" [color="black", fontcolor="black", label=<{FilterStage|filter_expr : str<br ALIGN="LEFT"/>|process(input_data: PipelineData): PipelineData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.export_dialog.ExportDialog._filter_results.FilteredICPData" [color="black", fontcolor="black", label=<{FilteredICPData|all_detections<br ALIGN="LEFT"/>architecture<br ALIGN="LEFT"/>file_type<br ALIGN="LEFT"/>is_protected<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.FindAllDialog" [color="black", fontcolor="black", label=<{FindAllDialog|results : list<br ALIGN="LEFT"/>results_table<br ALIGN="LEFT"/>|setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.FindReplaceDialog" [color="black", fontcolor="black", label=<{FindReplaceDialog|case_sensitive<br ALIGN="LEFT"/>close_btn<br ALIGN="LEFT"/>find_edit<br ALIGN="LEFT"/>find_next_btn<br ALIGN="LEFT"/>find_prev_btn<br ALIGN="LEFT"/>regex_mode<br ALIGN="LEFT"/>replace_all_btn<br ALIGN="LEFT"/>replace_btn<br ALIGN="LEFT"/>replace_edit<br ALIGN="LEFT"/>text_editor : NoneType<br ALIGN="LEFT"/>whole_words<br ALIGN="LEFT"/>|find_next()<br ALIGN="LEFT"/>find_previous()<br ALIGN="LEFT"/>replace_all()<br ALIGN="LEFT"/>replace_current()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareAnalysisResult" [color="black", fontcolor="black", label=<{FirmwareAnalysisResult|analysis_time : float<br ALIGN="LEFT"/>critical_findings<br ALIGN="LEFT"/>embedded_executables<br ALIGN="LEFT"/>entropy_analysis : Dict[str, Any]<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>extractions : Optional[FirmwareExtraction]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>firmware_type<br ALIGN="LEFT"/>has_extractions<br ALIGN="LEFT"/>security_findings : List[SecurityFinding]<br ALIGN="LEFT"/>signatures : List[FirmwareSignature]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareAnalyzer" [color="black", fontcolor="black", label=<{FirmwareAnalyzer|analysis_results : dict<br ALIGN="LEFT"/>extracted_files : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>work_directory : Path<br ALIGN="LEFT"/>|analyze_firmware(file_path: str, extract_files: bool, analyze_security: bool, extraction_depth: int): FirmwareAnalysisResult<br ALIGN="LEFT"/>cleanup_extractions(extraction_directory: str)<br ALIGN="LEFT"/>export_analysis_report(analysis_result: FirmwareAnalysisResult, output_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>generate_icp_supplemental_data(analysis_result: FirmwareAnalysisResult): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareExtraction" [color="black", fontcolor="black", label=<{FirmwareExtraction|errors : List[str]<br ALIGN="LEFT"/>executable_files<br ALIGN="LEFT"/>extracted_files : List[ExtractedFile]<br ALIGN="LEFT"/>extraction_directory : str<br ALIGN="LEFT"/>extraction_time : float<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>text_files<br ALIGN="LEFT"/>total_extracted : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareSignature" [color="black", fontcolor="black", label=<{FirmwareSignature|confidence : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>is_executable<br ALIGN="LEFT"/>is_filesystem<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>signature_name : str<br ALIGN="LEFT"/>size : Optional[int]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareType" [color="black", fontcolor="black", label=<{FirmwareType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.first_run_setup.FirstRunSetupDialog" [color="black", fontcolor="black", label=<{FirstRunSetupDialog|component_checks : dict<br ALIGN="LEFT"/>log_output<br ALIGN="LEFT"/>missing_components : Dict[str, bool]<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>setup_button<br ALIGN="LEFT"/>setup_complete : bool<br ALIGN="LEFT"/>skip_button<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>worker<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>setup_finished(success: bool)<br ALIGN="LEFT"/>start_setup()<br ALIGN="LEFT"/>update_status(status: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.FlexLMEmulator" [color="black", fontcolor="black", label=<{FlexLMEmulator|LICENSE_EXPIRED : int<br ALIGN="LEFT"/>LICENSE_NOT_FOUND : int<br ALIGN="LEFT"/>SUCCESS : int<br ALIGN="LEFT"/>TOO_MANY_USERS : int<br ALIGN="LEFT"/>crypto<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server_socket : NoneType, socket<br ALIGN="LEFT"/>|start_server(port: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.FlexLMProtocolHandler" [color="black", fontcolor="black", label=<{FlexLMProtocolHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_response(context: ResponseContext): bytes<br ALIGN="LEFT"/>parse_request(data: bytes): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.license_protocol_handler.FlexLMProtocolHandler" [color="black", fontcolor="black", label=<{FlexLMProtocolHandler|captured_requests : list<br ALIGN="LEFT"/>captured_responses : list<br ALIGN="LEFT"/>client_connections : dict<br ALIGN="LEFT"/>feature_version<br ALIGN="LEFT"/>flexlm_port<br ALIGN="LEFT"/>flexlm_version<br ALIGN="LEFT"/>license_count<br ALIGN="LEFT"/>license_type<br ALIGN="LEFT"/>server_status<br ALIGN="LEFT"/>session_data : dict<br ALIGN="LEFT"/>vendor_daemon_port<br ALIGN="LEFT"/>|clear_data(): None<br ALIGN="LEFT"/>generate_response(request_data: bytes): bytes<br ALIGN="LEFT"/>handle_connection(socket: Any, initial_data: bytes): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.font_manager.FontManager" [color="black", fontcolor="black", label=<{FontManager|config<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>fonts_dir<br ALIGN="LEFT"/>loaded_fonts : list<br ALIGN="LEFT"/>|get_monospace_font(size)<br ALIGN="LEFT"/>get_ui_font(size)<br ALIGN="LEFT"/>load_application_fonts()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_bypass_wizard.FridaBypassWizard" [color="black", fontcolor="black", label=<{FridaBypassWizard|analysis_results : dict<br ALIGN="LEFT"/>applied_strategies : list<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>detected_protections : dict<br ALIGN="LEFT"/>executed_bypasses : set<br ALIGN="LEFT"/>failed_bypasses : set<br ALIGN="LEFT"/>frida_manager<br ALIGN="LEFT"/>metrics : dict<br ALIGN="LEFT"/>mode : str<br ALIGN="LEFT"/>progress : int<br ALIGN="LEFT"/>progress_callback : NoneType, Optional[Callable]<br ALIGN="LEFT"/>protection_evidence : dict<br ALIGN="LEFT"/>session_id : NoneType<br ALIGN="LEFT"/>state : IDLE<br ALIGN="LEFT"/>status_callback : NoneType, Optional[Callable]<br ALIGN="LEFT"/>strategies : list<br ALIGN="LEFT"/>successful_bypasses : set<br ALIGN="LEFT"/>target_process : NoneType<br ALIGN="LEFT"/>|run(session_id: str, target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>set_callbacks(progress_callback: Optional[Callable], status_callback: Optional[Callable])<br ALIGN="LEFT"/>set_mode(mode: str)<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_manager.FridaManager" [color="black", fontcolor="black", label=<{FridaManager|batcher<br ALIGN="LEFT"/>detector<br ALIGN="LEFT"/>device : NoneType<br ALIGN="LEFT"/>logger<br ALIGN="LEFT"/>optimizer<br ALIGN="LEFT"/>protection_adaptations : dict<br ALIGN="LEFT"/>script_dir : Path<br ALIGN="LEFT"/>scripts : dict<br ALIGN="LEFT"/>sessions : dict<br ALIGN="LEFT"/>|add_custom_script(script_content: str, script_name: str): Path<br ALIGN="LEFT"/>attach_to_process(process_identifier: Union[int, str]): bool<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>create_selective_instrumentation(target_apis: List[str], analysis_requirements: Dict[str, Any]): str<br ALIGN="LEFT"/>export_analysis(output_path: str): str<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>list_available_scripts(): List[Dict[str, Any]]<br ALIGN="LEFT"/>load_script(session_id: str, script_name: str, options: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [color="black", fontcolor="black", label=<{FridaManagerDialog|active_scripts : dict<br ALIGN="LEFT"/>adaptation_log<br ALIGN="LEFT"/>add_script_btn<br ALIGN="LEFT"/>ai_analyze_btn<br ALIGN="LEFT"/>ai_autonomous<br ALIGN="LEFT"/>ai_binary_path<br ALIGN="LEFT"/>ai_browse_btn<br ALIGN="LEFT"/>ai_complexity<br ALIGN="LEFT"/>ai_current_analysis : NoneType<br ALIGN="LEFT"/>ai_deploy_btn<br ALIGN="LEFT"/>ai_generate_btn<br ALIGN="LEFT"/>ai_generated_scripts : dict<br ALIGN="LEFT"/>ai_preview_btn<br ALIGN="LEFT"/>ai_progress<br ALIGN="LEFT"/>ai_protection_focus<br ALIGN="LEFT"/>ai_save_btn<br ALIGN="LEFT"/>ai_script_type<br ALIGN="LEFT"/>ai_status<br ALIGN="LEFT"/>ai_status_label<br ALIGN="LEFT"/>apply_preset_btn<br ALIGN="LEFT"/>attach_btn<br ALIGN="LEFT"/>attached_process : NoneType<br ALIGN="LEFT"/>auto_adapt_cb<br ALIGN="LEFT"/>autonomous_cb<br ALIGN="LEFT"/>batch_hooks_cb<br ALIGN="LEFT"/>batch_size_spin<br ALIGN="LEFT"/>batch_timeout_spin<br ALIGN="LEFT"/>browse_target_btn<br ALIGN="LEFT"/>cache_cb<br ALIGN="LEFT"/>clear_logs_btn<br ALIGN="LEFT"/>complexity_combo<br ALIGN="LEFT"/>cpu_label<br ALIGN="LEFT"/>cpu_progress<br ALIGN="LEFT"/>current_pid<br ALIGN="LEFT"/>current_session : NoneType, str<br ALIGN="LEFT"/>custom_config_text<br ALIGN="LEFT"/>deploy_scripts_btn<br ALIGN="LEFT"/>detach_btn<br ALIGN="LEFT"/>export_analysis_btn<br ALIGN="LEFT"/>export_logs_btn<br ALIGN="LEFT"/>focus_combo<br ALIGN="LEFT"/>frida_session : NoneType<br ALIGN="LEFT"/>frida_worker : NoneType<br ALIGN="LEFT"/>generate_btn<br ALIGN="LEFT"/>hook_priority_combo<br ALIGN="LEFT"/>hook_stats_label<br ALIGN="LEFT"/>hooks_tree<br ALIGN="LEFT"/>llm_info_label<br ALIGN="LEFT"/>load_custom_btn<br ALIGN="LEFT"/>load_script_btn<br ALIGN="LEFT"/>loaded_scripts_list<br ALIGN="LEFT"/>log_console<br ALIGN="LEFT"/>log_filter_combo<br ALIGN="LEFT"/>log_search<br ALIGN="LEFT"/>mem_label<br ALIGN="LEFT"/>mem_progress<br ALIGN="LEFT"/>monitor_timer<br ALIGN="LEFT"/>opt_cpu_cb<br ALIGN="LEFT"/>opt_memory_cb<br ALIGN="LEFT"/>perf_table<br ALIGN="LEFT"/>preset_combo<br ALIGN="LEFT"/>preset_details<br ALIGN="LEFT"/>preview_cb<br ALIGN="LEFT"/>process_list : list<br ALIGN="LEFT"/>process_search<br ALIGN="LEFT"/>process_table<br ALIGN="LEFT"/>process_worker : NoneType<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>progress_label<br ALIGN="LEFT"/>protection_grid<br ALIGN="LEFT"/>recommendations_text<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>reload_scripts_btn<br ALIGN="LEFT"/>resume_btn<br ALIGN="LEFT"/>save_custom_btn<br ALIGN="LEFT"/>save_scripts_btn<br ALIGN="LEFT"/>script_execution_manager<br ALIGN="LEFT"/>script_preview<br ALIGN="LEFT"/>script_templates<br ALIGN="LEFT"/>script_type_combo<br ALIGN="LEFT"/>scripts_list<br ALIGN="LEFT"/>selected_process : dict<br ALIGN="LEFT"/>selective_cb<br ALIGN="LEFT"/>session_label<br ALIGN="LEFT"/>spawn_btn<br ALIGN="LEFT"/>start_wizard_btn<br ALIGN="LEFT"/>stats_table<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>stop_wizard_btn<br ALIGN="LEFT"/>suspend_btn<br ALIGN="LEFT"/>tabs<br ALIGN="LEFT"/>target_binary_edit<br ALIGN="LEFT"/>test_qemu_btn<br ALIGN="LEFT"/>thread_label<br ALIGN="LEFT"/>wizard_aggressive_cb<br ALIGN="LEFT"/>wizard_progress<br ALIGN="LEFT"/>wizard_safe_cb<br ALIGN="LEFT"/>wizard_status<br ALIGN="LEFT"/>wizard_stealth_cb<br ALIGN="LEFT"/>|add_custom_script()<br ALIGN="LEFT"/>analyze_binary_ai()<br ALIGN="LEFT"/>apply_selected_preset()<br ALIGN="LEFT"/>attach_to_process()<br ALIGN="LEFT"/>browse_target_binary()<br ALIGN="LEFT"/>bypass_protection(protection_type: ProtectionType)<br ALIGN="LEFT"/>clear_logs()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>connect_structured_message_handlers()<br ALIGN="LEFT"/>create_ai_generation_group(): QGroupBox<br ALIGN="LEFT"/>create_ai_generation_tab(): QWidget<br ALIGN="LEFT"/>create_logs_tab(): QWidget<br ALIGN="LEFT"/>create_performance_tab(): QWidget<br ALIGN="LEFT"/>create_presets_tab(): QWidget<br ALIGN="LEFT"/>create_process_tab(): QWidget<br ALIGN="LEFT"/>create_protection_tab(): QWidget<br ALIGN="LEFT"/>create_scripts_tab(): QWidget<br ALIGN="LEFT"/>delete_script(item)<br ALIGN="LEFT"/>deploy_ai_script()<br ALIGN="LEFT"/>detach_from_process()<br ALIGN="LEFT"/>display_structured_message(message_type: str, session_id: str, script_name: str, payload: dict)<br ALIGN="LEFT"/>duplicate_script(item)<br ALIGN="LEFT"/>edit_script(script_path: Path)<br ALIGN="LEFT"/>export_analysis()<br ALIGN="LEFT"/>export_logs()<br ALIGN="LEFT"/>filter_logs(filter_type: str)<br ALIGN="LEFT"/>filter_processes(text: str)<br ALIGN="LEFT"/>generate_ai_script()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>load_custom_config()<br ALIGN="LEFT"/><I>load_presets</I>()<br ALIGN="LEFT"/>load_selected_script()<br ALIGN="LEFT"/>on_attach_complete(operation: str, success: bool)<br ALIGN="LEFT"/>on_preset_selected(preset_name: str)<br ALIGN="LEFT"/>on_process_selected()<br ALIGN="LEFT"/>on_script_loaded(operation: str, success: bool)<br ALIGN="LEFT"/>preview_ai_script()<br ALIGN="LEFT"/>preview_script(script_path: Path)<br ALIGN="LEFT"/>refresh_processes()<br ALIGN="LEFT"/>reload_script_list()<br ALIGN="LEFT"/>resume_process()<br ALIGN="LEFT"/>save_ai_script()<br ALIGN="LEFT"/>save_custom_config()<br ALIGN="LEFT"/>search_logs(search_text: str)<br ALIGN="LEFT"/>show_error(error_msg: str)<br ALIGN="LEFT"/>show_loaded_script_menu(position)<br ALIGN="LEFT"/>show_script_context_menu(position)<br ALIGN="LEFT"/>spawn_process()<br ALIGN="LEFT"/>start_ai_script_generation(binary_path: str)<br ALIGN="LEFT"/>start_bypass_wizard()<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_bypass_wizard()<br ALIGN="LEFT"/>suspend_process()<br ALIGN="LEFT"/>unload_script()<br ALIGN="LEFT"/>update_performance_stats()<br ALIGN="LEFT"/>update_process_table(processes: List[Dict])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_manager.FridaOperationLogger" [color="black", fontcolor="black", label=<{FridaOperationLogger|bypass_log<br ALIGN="LEFT"/>bypass_logger : NoneType, RootLogger<br ALIGN="LEFT"/>hook_buffer : deque<br ALIGN="LEFT"/>hook_log<br ALIGN="LEFT"/>hook_logger : NoneType, RootLogger<br ALIGN="LEFT"/>log_dir : Path<br ALIGN="LEFT"/>op_logger : NoneType, RootLogger<br ALIGN="LEFT"/>operation_buffer : deque<br ALIGN="LEFT"/>operation_log<br ALIGN="LEFT"/>perf_logger : NoneType, RootLogger<br ALIGN="LEFT"/>performance_log<br ALIGN="LEFT"/>performance_metrics : defaultdict<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|error(message: str)<br ALIGN="LEFT"/>export_logs(output_dir: str): str<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>log_bypass_attempt(protection_type: ProtectionType, technique: str, success: bool, details: Dict[str, Any])<br ALIGN="LEFT"/>log_hook(function_name: str, module: str, arguments: List[Any], return_value: Any, modified: bool)<br ALIGN="LEFT"/>log_operation(operation: str, details: Dict[str, Any], success: bool, error: str)<br ALIGN="LEFT"/>log_performance(metric_name: str, value: float, unit: str, metadata: Dict)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_manager.FridaPerformanceOptimizer" [color="black", fontcolor="black", label=<{FridaPerformanceOptimizer|baseline_cpu : float, int<br ALIGN="LEFT"/>baseline_memory : int<br ALIGN="LEFT"/>hook_cache : dict<br ALIGN="LEFT"/>optimization_enabled : bool<br ALIGN="LEFT"/>performance_history : deque<br ALIGN="LEFT"/>process : Process<br ALIGN="LEFT"/>selective_hooks : dict<br ALIGN="LEFT"/>|get_current_usage(): Dict[str, float]<br ALIGN="LEFT"/>get_optimization_recommendations(): List[str]<br ALIGN="LEFT"/>measure_baseline()<br ALIGN="LEFT"/>optimize_script(script_code: str): str<br ALIGN="LEFT"/>should_hook_function(module: str, function: str, importance: HookCategory): bool<br ALIGN="LEFT"/>track_hook_performance(module: str, function: str, execution_time: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.FridaPlugin" [color="black", fontcolor="black", label=<{FridaPlugin|frida_script : NoneType<br ALIGN="LEFT"/>frida_session : NoneType<br ALIGN="LEFT"/>last_error : str<br ALIGN="LEFT"/>script_path : Path<br ALIGN="LEFT"/>status : ACTIVE, ERROR, INITIALIZING, READY<br ALIGN="LEFT"/>target_process : NoneType<br ALIGN="LEFT"/>|activate(): bool<br ALIGN="LEFT"/>cleanup(): bool<br ALIGN="LEFT"/>deactivate(): bool<br ALIGN="LEFT"/>execute_operation(operation: str, parameters: Dict[str, Any]): Any<br ALIGN="LEFT"/>get_metadata(): PluginMetadata<br ALIGN="LEFT"/>get_supported_operations(): List[str]<br ALIGN="LEFT"/>initialize(config: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.script_templates.FridaTemplates" [color="black", fontcolor="black", label=<{FridaTemplates|<br ALIGN="LEFT"/>|get_base_template(): str<br ALIGN="LEFT"/>get_license_check_template(): str<br ALIGN="LEFT"/>get_network_validation_template(): str<br ALIGN="LEFT"/>get_registry_bypass_template(): str<br ALIGN="LEFT"/>get_time_bomb_template(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.FridaWorker" [color="black", fontcolor="black", label=<{FridaWorker|error<br ALIGN="LEFT"/>frida_manager<br ALIGN="LEFT"/>operation : NoneType, str<br ALIGN="LEFT"/>operationComplete<br ALIGN="LEFT"/>params : dict<br ALIGN="LEFT"/>performanceUpdate<br ALIGN="LEFT"/>protectionDetected<br ALIGN="LEFT"/>statusUpdate<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.fuzzing_engine.FuzzingEngine" [color="black", fontcolor="black", label=<{FuzzingEngine|config : dict<br ALIGN="LEFT"/>coverage_data : dict<br ALIGN="LEFT"/>crashes : dict<br ALIGN="LEFT"/>file_grammars : dict<br ALIGN="LEFT"/>interesting_inputs : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>magic_values : dict<br ALIGN="LEFT"/>mutation_strategies : dict<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>unique_crashes : dict<br ALIGN="LEFT"/>|analyze_crash(crash_file: str, target_command: str): Dict[str, Any]<br ALIGN="LEFT"/>export_results(output_file: str, format: str): bool<br ALIGN="LEFT"/>get_crashes(): Dict[str, Any]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>minimize_testcase(crash_file: str, target_command: str, strategy: str): Dict[str, Any]<br ALIGN="LEFT"/>start_fuzzing(target_command: str, seed_inputs: Optional[List[str]], strategy: FuzzingStrategy, max_iterations: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.fuzzing_engine.FuzzingStrategy" [color="black", fontcolor="black", label=<{FuzzingStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog._execute_testcase.FuzzingStrategy" [color="black", fontcolor="black", label=<{FuzzingStrategy|AFL_PLUS_PLUS : str<br ALIGN="LEFT"/>GENERATION_BASED : str<br ALIGN="LEFT"/>HYBRID : str<br ALIGN="LEFT"/>MUTATION_BASED : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.local_gguf_server.GGUFModelManager" [color="black", fontcolor="black", label=<{GGUFModelManager|available_models : dict<br ALIGN="LEFT"/>current_model : NoneType<br ALIGN="LEFT"/>models_directory<br ALIGN="LEFT"/>server<br ALIGN="LEFT"/>|download_model(model_url: str, model_name: Optional[str]): bool<br ALIGN="LEFT"/>get_recommended_models(): List[Dict[str, str]]<br ALIGN="LEFT"/>get_server_url(): str<br ALIGN="LEFT"/>is_server_running(): bool<br ALIGN="LEFT"/>list_models(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>load_model(model_name: str): bool<br ALIGN="LEFT"/>scan_models()<br ALIGN="LEFT"/>start_server(): bool<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>unload_model()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_gpt_model.GPTModel._create_gpt_block.GPTBlock" [color="black", fontcolor="black", label=<{GPTBlock|attention : MultiheadAttention<br ALIGN="LEFT"/>feed_forward : Sequential<br ALIGN="LEFT"/>ln1 : LayerNorm<br ALIGN="LEFT"/>ln2 : LayerNorm<br ALIGN="LEFT"/>|forward(x, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_gpt_model.GPTModel" [color="black", fontcolor="black", label=<{GPTModel|dropout : Dropout<br ALIGN="LEFT"/>final_layer_norm : LayerNorm<br ALIGN="LEFT"/>hidden_size<br ALIGN="LEFT"/>lm_head : Linear<br ALIGN="LEFT"/>max_position_embeddings : int<br ALIGN="LEFT"/>num_layers<br ALIGN="LEFT"/>position_embedding : Embedding<br ALIGN="LEFT"/>token_embedding : Embedding<br ALIGN="LEFT"/>transformer_blocks : ModuleList<br ALIGN="LEFT"/>|forward(input_ids, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.GPTQBackend" [color="black", fontcolor="black", label=<{GPTQBackend|device : NoneType, device<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.gpu_accelerator.GPUAccelerationManager" [color="black", fontcolor="black", label=<{GPUAccelerationManager|cl : NoneType<br ALIGN="LEFT"/>cl_array : NoneType<br ALIGN="LEFT"/>context : NoneType<br ALIGN="LEFT"/>cupy : NoneType<br ALIGN="LEFT"/>device : NoneType, device<br ALIGN="LEFT"/>gpu_available : bool<br ALIGN="LEFT"/>gpu_backend : NoneType, str<br ALIGN="LEFT"/>gpu_info : dict<br ALIGN="LEFT"/>gpu_type : NoneType, str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>prefer_intel : bool<br ALIGN="LEFT"/>queue : NoneType<br ALIGN="LEFT"/>use_intel_pytorch : bool<br ALIGN="LEFT"/>|accelerate_pattern_matching(data: bytes, patterns: List[bytes]): List[int]<br ALIGN="LEFT"/>get_backend(): Optional[str]<br ALIGN="LEFT"/>get_gpu_type(): Optional[str]<br ALIGN="LEFT"/>is_acceleration_available(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.gpu_acceleration.GPUAccelerator" [color="black", fontcolor="black", label=<{GPUAccelerator|device_info : dict<br ALIGN="LEFT"/>framework : str<br ALIGN="LEFT"/>|entropy_calculation(data: bytes, block_size: int): Dict[str, Any]<br ALIGN="LEFT"/>hash_computation(data: bytes, algorithms: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>parallel_pattern_search(data: bytes, pattern: bytes): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.gpu_accelerator.GPUAccelerator" [color="black", fontcolor="black", label=<{GPUAccelerator|backend_benchmarks : dict<br ALIGN="LEFT"/>blacklisted_backends : set<br ALIGN="LEFT"/>cuda_available<br ALIGN="LEFT"/>cuda_devices : list<br ALIGN="LEFT"/>detected_gpu_name<br ALIGN="LEFT"/>detected_gpu_vendor : str<br ALIGN="LEFT"/>error_counts : dict<br ALIGN="LEFT"/>intel_devices : list<br ALIGN="LEFT"/>intel_pytorch_available<br ALIGN="LEFT"/>opencl_available : bool<br ALIGN="LEFT"/>opencl_devices : list<br ALIGN="LEFT"/>pytorch_available<br ALIGN="LEFT"/>pytorch_devices : list<br ALIGN="LEFT"/>selected_backend : NoneType, str<br ALIGN="LEFT"/>tensorflow_available : bool<br ALIGN="LEFT"/>tensorflow_devices : list<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.gpu_autoloader.GPUAutoLoader" [color="black", fontcolor="black", label=<{GPUAutoLoader|gpu_available : bool<br ALIGN="LEFT"/>gpu_info : dict<br ALIGN="LEFT"/>gpu_type : NoneType, str<br ALIGN="LEFT"/>|get_device(): Optional[Any]<br ALIGN="LEFT"/>get_device_string(): str<br ALIGN="LEFT"/>get_ipex(): Optional[Any]<br ALIGN="LEFT"/>get_memory_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_torch(): Optional[Any]<br ALIGN="LEFT"/>optimize_model(model: Any): Any<br ALIGN="LEFT"/>setup(): bool<br ALIGN="LEFT"/>synchronize()<br ALIGN="LEFT"/>to_device(tensor_or_model: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.gpu_integration.GPUIntegration" [color="black", fontcolor="black", label=<{GPUIntegration|device : NoneType, device<br ALIGN="LEFT"/>gpu_info : dict<br ALIGN="LEFT"/>|get_backend_name(): str<br ALIGN="LEFT"/>get_device_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_memory_usage(): Dict[str, Any]<br ALIGN="LEFT"/>is_available(): bool<br ALIGN="LEFT"/>prepare_model(model: Any): Any<br ALIGN="LEFT"/>prepare_tensor(tensor: Any): Any<br ALIGN="LEFT"/>synchronize()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.gpu_status_widget.GPUMonitorWorker" [color="black", fontcolor="black", label=<{GPUMonitorWorker|error_occurred<br ALIGN="LEFT"/>gpu_data_ready<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.GPUOptimizer" [color="black", fontcolor="black", label=<{GPUOptimizer|device_count<br ALIGN="LEFT"/>gpu_available<br ALIGN="LEFT"/>memory_usage : dict<br ALIGN="LEFT"/>optimal_batch_sizes : dict<br ALIGN="LEFT"/>|get_optimal_batch_size(model_name: str, input_shape: Tuple): int<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_memory()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.gpu_status_widget.GPUStatusWidget" [color="black", fontcolor="black", label=<{GPUStatusWidget|caps_text<br ALIGN="LEFT"/>driver_label<br ALIGN="LEFT"/>gpu_combo<br ALIGN="LEFT"/>gpu_data : Dict[str, Any]<br ALIGN="LEFT"/>memory_bar<br ALIGN="LEFT"/>memory_label<br ALIGN="LEFT"/>monitor_thread<br ALIGN="LEFT"/>monitor_worker<br ALIGN="LEFT"/>name_label<br ALIGN="LEFT"/>power_bar<br ALIGN="LEFT"/>power_label<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>selected_gpu_index<br ALIGN="LEFT"/>temp_bar<br ALIGN="LEFT"/>temp_label<br ALIGN="LEFT"/>utilization_bar<br ALIGN="LEFT"/>utilization_label<br ALIGN="LEFT"/>vendor_label<br ALIGN="LEFT"/>|clear_display()<br ALIGN="LEFT"/>handle_error(error_msg: str)<br ALIGN="LEFT"/>on_gpu_selected(index)<br ALIGN="LEFT"/>refresh_gpus()<br ALIGN="LEFT"/>setup_monitoring()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>update_capabilities(gpu: Dict[str, Any])<br ALIGN="LEFT"/>update_display()<br ALIGN="LEFT"/>update_gpu_data(data: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.GeneratedResponse" [color="black", fontcolor="black", label=<{GeneratedResponse|confidence : float<br ALIGN="LEFT"/>generation_method : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>response_data : bytes<br ALIGN="LEFT"/>response_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.GeneratedScript" [color="black", fontcolor="black", label=<{GeneratedScript|content : str<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>entry_point : str<br ALIGN="LEFT"/>hooks : List[Dict[str, Any]]<br ALIGN="LEFT"/>language : str<br ALIGN="LEFT"/>metadata<br ALIGN="LEFT"/>patches : List[Dict[str, Any]]<br ALIGN="LEFT"/>validation_passed : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.generic_protocol_handler.GenericProtocolHandler" [color="black", fontcolor="black", label=<{GenericProtocolHandler|active_connections : dict<br ALIGN="LEFT"/>captured_requests : list<br ALIGN="LEFT"/>captured_responses : list<br ALIGN="LEFT"/>protocol : str<br ALIGN="LEFT"/>|clear_data(): None<br ALIGN="LEFT"/>generate_response(request_data: bytes): bytes<br ALIGN="LEFT"/>handle_connection(client_socket: Any, initial_data: bytes): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.ghidra_decompiler.GhidraDecompiler" [color="black", fontcolor="black", label=<{GhidraDecompiler|binary_path : Path<br ALIGN="LEFT"/>decompilation_cache : dict<br ALIGN="LEFT"/>ghidra_path<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>project_dir : NoneType<br ALIGN="LEFT"/>project_name : NoneType, str<br ALIGN="LEFT"/>|analyze_binary(): Dict[str, Any]<br ALIGN="LEFT"/>analyze_license_functions(): Dict[str, Any]<br ALIGN="LEFT"/>async_decompile_all_functions(limit: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>decompile_all_functions(limit: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>decompile_function(function_name: str): Dict[str, Any]<br ALIGN="LEFT"/>get_decompiled_code(function_name: str): Optional[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.GhidraPlugin" [color="black", fontcolor="black", label=<{GhidraPlugin|ghidra_project_path : Optional[str]<br ALIGN="LEFT"/>java_process : NoneType, Optional[subprocess.Popen]<br ALIGN="LEFT"/>last_error : str<br ALIGN="LEFT"/>script_path : Path<br ALIGN="LEFT"/>status : ACTIVE, ERROR, INITIALIZING, READY<br ALIGN="LEFT"/>|activate(): bool<br ALIGN="LEFT"/>cleanup(): bool<br ALIGN="LEFT"/>deactivate(): bool<br ALIGN="LEFT"/>execute_operation(operation: str, parameters: Dict[str, Any]): Any<br ALIGN="LEFT"/>get_metadata(): PluginMetadata<br ALIGN="LEFT"/>get_supported_operations(): List[str]<br ALIGN="LEFT"/>initialize(config: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.tools.ghidra_script_manager.GhidraScript" [color="black", fontcolor="black", label=<{GhidraScript|author : str<br ALIGN="LEFT"/>category : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>directory<br ALIGN="LEFT"/>extension<br ALIGN="LEFT"/>filename<br ALIGN="LEFT"/>is_valid : bool<br ALIGN="LEFT"/>last_modified : datetime<br ALIGN="LEFT"/>min_ghidra_version : NoneType<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>path : bytes, str<br ALIGN="LEFT"/>size<br ALIGN="LEFT"/>tags : list<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>validation_errors : list<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.tools.ghidra_script_manager.GhidraScriptManager" [color="black", fontcolor="black", label=<{GhidraScriptManager|CACHE_FILE : str<br ALIGN="LEFT"/>DEFAULT_SCRIPT_DIRS : list<br ALIGN="LEFT"/>categories : Dict[str, List[str]]<br ALIGN="LEFT"/>last_scan : NoneType, datetime<br ALIGN="LEFT"/>script_dirs : list<br ALIGN="LEFT"/>scripts : Dict[str, GhidraScript]<br ALIGN="LEFT"/>|add_user_script(source_path: str, category: str): Optional[GhidraScript]<br ALIGN="LEFT"/>copy_script_for_execution(script: GhidraScript, destination_dir: str): str<br ALIGN="LEFT"/>get_script(identifier: str): Optional[GhidraScript]<br ALIGN="LEFT"/>get_scripts_by_category(): Dict[str, List[GhidraScript]]<br ALIGN="LEFT"/>scan_scripts(force_rescan: bool): Dict[str, GhidraScript]<br ALIGN="LEFT"/>search_scripts(query: str): List[GhidraScript]<br ALIGN="LEFT"/>validate_script(script_path: str): Tuple[bool, List[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ghidra_script_selector.GhidraScriptSelector" [color="black", fontcolor="black", label=<{GhidraScriptSelector|add_script_btn<br ALIGN="LEFT"/>cancel_btn<br ALIGN="LEFT"/>category_filter<br ALIGN="LEFT"/>info_widget<br ALIGN="LEFT"/>open_folder_btn<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>script_manager : NoneType<br ALIGN="LEFT"/>script_selected<br ALIGN="LEFT"/>script_tree<br ALIGN="LEFT"/>search_input<br ALIGN="LEFT"/>select_btn<br ALIGN="LEFT"/>selected_script_path : NoneType<br ALIGN="LEFT"/>show_invalid : bool<br ALIGN="LEFT"/>show_invalid_check<br ALIGN="LEFT"/>use_default_btn<br ALIGN="LEFT"/>|get_selected_script(): Optional[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.script_templates.GhidraTemplates" [color="black", fontcolor="black", label=<{GhidraTemplates|<br ALIGN="LEFT"/>|get_base_template(): str<br ALIGN="LEFT"/>get_license_analysis_template(): str<br ALIGN="LEFT"/>get_patching_template(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_ci_cd.GitHubActionsGenerator" [color="black", fontcolor="black", label=<{GitHubActionsGenerator|<br ALIGN="LEFT"/>|generate_workflow(plugin_name: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.google_repository.GoogleRepository" [color="black", fontcolor="black", label=<{GoogleRepository|api_version : str<br ALIGN="LEFT"/>|authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.guided_workflow_wizard.GuidedWorkflowWizard" [color="black", fontcolor="black", label=<{GuidedWorkflowWizard|ai_assisted_mode_cb<br ALIGN="LEFT"/>ai_code_explain_cb<br ALIGN="LEFT"/>ai_comprehensive_cb<br ALIGN="LEFT"/>ai_patch_suggest_cb<br ALIGN="LEFT"/>anti_debug_cb<br ALIGN="LEFT"/>auto_patch_cb<br ALIGN="LEFT"/>base_path<br ALIGN="LEFT"/>binary_similarity_cb<br ALIGN="LEFT"/>buffer_overflow_cb<br ALIGN="LEFT"/>cfg_analysis_cb<br ALIGN="LEFT"/>cloud_license_hook_cb<br ALIGN="LEFT"/>concolic_execution_cb<br ALIGN="LEFT"/>detect_antidebug_cb<br ALIGN="LEFT"/>detect_checksum_cb<br ALIGN="LEFT"/>detect_commercial_cb<br ALIGN="LEFT"/>detect_dongle_cb<br ALIGN="LEFT"/>detect_network_cb<br ALIGN="LEFT"/>detect_packing_cb<br ALIGN="LEFT"/>detect_protections_cb<br ALIGN="LEFT"/>detect_time_cb<br ALIGN="LEFT"/>detect_tpm_cb<br ALIGN="LEFT"/>detect_vm_cb<br ALIGN="LEFT"/>distributed_processing_cb<br ALIGN="LEFT"/>dynamic_analysis_cb<br ALIGN="LEFT"/>feature_unlock_cb<br ALIGN="LEFT"/>file_info_label<br ALIGN="LEFT"/>file_path_edit<br ALIGN="LEFT"/>format_string_cb<br ALIGN="LEFT"/>function_hooking_cb<br ALIGN="LEFT"/>generate_exploits_cb<br ALIGN="LEFT"/>ghidra_analysis_cb<br ALIGN="LEFT"/>gpu_acceleration_cb<br ALIGN="LEFT"/>import_export_cb<br ALIGN="LEFT"/>interactive_patch_cb<br ALIGN="LEFT"/>license_check_cb<br ALIGN="LEFT"/>license_server_emulate_cb<br ALIGN="LEFT"/>memory_patching_cb<br ALIGN="LEFT"/>ml_analysis_cb<br ALIGN="LEFT"/>ml_pattern_learn_cb<br ALIGN="LEFT"/>ml_vuln_prediction_cb<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>protocol_fingerprint_cb<br ALIGN="LEFT"/>race_condition_cb<br ALIGN="LEFT"/>radare2_analysis_cb<br ALIGN="LEFT"/>rop_chain_cb<br ALIGN="LEFT"/>rop_gadgets_cb<br ALIGN="LEFT"/>section_analysis_cb<br ALIGN="LEFT"/>shellcode_cb<br ALIGN="LEFT"/>ssl_intercept_cb<br ALIGN="LEFT"/>static_analysis_cb<br ALIGN="LEFT"/>static_vuln_scan_cb<br ALIGN="LEFT"/>summary_text<br ALIGN="LEFT"/>symbolic_execution_cb<br ALIGN="LEFT"/>taint_analysis_cb<br ALIGN="LEFT"/>time_limit_cb<br ALIGN="LEFT"/>timeout_spin<br ALIGN="LEFT"/>traffic_capture_cb<br ALIGN="LEFT"/>|browse_file(): None<br ALIGN="LEFT"/>create_advanced_analysis_page(): QWizardPage<br ALIGN="LEFT"/>create_ai_options_page(): QWizardPage<br ALIGN="LEFT"/>create_analysis_options_page(): QWizardPage<br ALIGN="LEFT"/>create_conclusion_page(): QWizardPage<br ALIGN="LEFT"/>create_file_selection_page(): QWizardPage<br ALIGN="LEFT"/>create_intro_page(): QWizardPage<br ALIGN="LEFT"/>create_network_options_page(): QWizardPage<br ALIGN="LEFT"/>create_patching_options_page(): QWizardPage<br ALIGN="LEFT"/>create_protection_detection_page(): QWizardPage<br ALIGN="LEFT"/>create_vulnerability_options_page(): QWizardPage<br ALIGN="LEFT"/>format_size(size_bytes: int): str<br ALIGN="LEFT"/>get_settings(): Dict[str, Any]<br ALIGN="LEFT"/>on_finished(result: int): None<br ALIGN="LEFT"/>update_file_info(file_path: str): None<br ALIGN="LEFT"/>update_summary(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation._attempt_token_duplication.MockWintypes.HANDLE" [color="black", fontcolor="black", label=<{HANDLE|value : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.HASPEmulator" [color="black", fontcolor="black", label=<{HASPEmulator|hasp_commands : dict<br ALIGN="LEFT"/>|process_hasp_command(command: int, data: bytes): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.HASPEmulator" [color="black", fontcolor="black", label=<{HASPEmulator|HASP_DEVICE_ERROR : int<br ALIGN="LEFT"/>HASP_FEATURE_EXPIRED : int<br ALIGN="LEFT"/>HASP_FEATURE_NOT_FOUND : int<br ALIGN="LEFT"/>HASP_INVALID_HANDLE : int<br ALIGN="LEFT"/>HASP_INVALID_PARAMETER : int<br ALIGN="LEFT"/>HASP_NO_MEMORY : int<br ALIGN="LEFT"/>HASP_SIGNATURE_CHECK_FAILED : int<br ALIGN="LEFT"/>HASP_STATUS_OK : int<br ALIGN="LEFT"/>HASP_TIME_ERROR : int<br ALIGN="LEFT"/>active_sessions : dict<br ALIGN="LEFT"/>crypto<br ALIGN="LEFT"/>device_id<br ALIGN="LEFT"/>dongle_memory : bytearray<br ALIGN="LEFT"/>feature_memory : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>master_key<br ALIGN="LEFT"/>memory_size : int<br ALIGN="LEFT"/>next_handle : int<br ALIGN="LEFT"/>session_keys : dict<br ALIGN="LEFT"/>|hasp_decrypt(handle: int, data: bytes): Tuple[int, bytes]<br ALIGN="LEFT"/>hasp_encrypt(handle: int, data: bytes): Tuple[int, bytes]<br ALIGN="LEFT"/>hasp_get_info(handle: int, query_type: int): Tuple[int, bytes]<br ALIGN="LEFT"/>hasp_login(feature_id: int, vendor_code: bytes): int<br ALIGN="LEFT"/>hasp_logout(handle: int): int<br ALIGN="LEFT"/>hasp_read(handle: int, offset: int, length: int): Tuple[int, bytes]<br ALIGN="LEFT"/>hasp_write(handle: int, offset: int, data: bytes): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.HASPProtocolHandler" [color="black", fontcolor="black", label=<{HASPProtocolHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_response(context: ResponseContext): bytes<br ALIGN="LEFT"/>parse_request(data: bytes): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.license_protocol_handler.HASPProtocolHandler" [color="black", fontcolor="black", label=<{HASPProtocolHandler|captured_requests : list<br ALIGN="LEFT"/>captured_responses : list<br ALIGN="LEFT"/>client_connections : dict<br ALIGN="LEFT"/>hasp_emulator_version<br ALIGN="LEFT"/>hasp_memory_size<br ALIGN="LEFT"/>hasp_port<br ALIGN="LEFT"/>hasp_vendor_id<br ALIGN="LEFT"/>hasp_version<br ALIGN="LEFT"/>license_features<br ALIGN="LEFT"/>session_data : dict<br ALIGN="LEFT"/>|clear_data(): None<br ALIGN="LEFT"/>generate_response(request_data: bytes): bytes<br ALIGN="LEFT"/>handle_connection(socket: Any, initial_data: bytes): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence._lsa_security_package_persistence.MockWintypes.HKEY" [color="black", fontcolor="black", label=<{HKEY|value : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence.remove_persistence.MockWintypes.HKEY" [color="black", fontcolor="black", label=<{HKEY|value : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.HardwareDebugProtector" [color="black", fontcolor="black", label=<{HardwareDebugProtector|kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>saved_context : NoneType, dict<br ALIGN="LEFT"/>|clear_debug_registers(): bool<br ALIGN="LEFT"/>get_thread_context(): Optional[Any]<br ALIGN="LEFT"/>monitor_debug_registers(): Dict[str, int]<br ALIGN="LEFT"/>restore_debug_registers(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.dongle_emulator.HardwareDongleEmulator" [color="black", fontcolor="black", label=<{HardwareDongleEmulator|app : Optional[Any]<br ALIGN="LEFT"/>hooks : List[Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>patches : List[Dict[str, Any]]<br ALIGN="LEFT"/>virtual_dongles : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>|activate_dongle_emulation(dongle_types: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>clear_emulation(): None<br ALIGN="LEFT"/>generate_emulation_script(dongle_types: List[str]): str<br ALIGN="LEFT"/>get_emulation_status(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" [color="black", fontcolor="black", label=<{HardwareDongleEmulator|api_hooker<br ALIGN="LEFT"/>dongles : Dict[str, BaseDongleEmulator]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>lpt_emulator<br ALIGN="LEFT"/>predefined_dongles : dict<br ALIGN="LEFT"/>registry_manager<br ALIGN="LEFT"/>usb_driver<br ALIGN="LEFT"/>|create_dongle(dongle_type: DongleType, custom_spec: Optional[DongleSpec]): str<br ALIGN="LEFT"/>export_dongles(output_file: str)<br ALIGN="LEFT"/>get_dongles_by_type(dongle_type: DongleType): List[BaseDongleEmulator]<br ALIGN="LEFT"/>import_dongles(input_file: str)<br ALIGN="LEFT"/>list_dongles(): List[Dict[str, Any]]<br ALIGN="LEFT"/>remove_dongle(dongle_id: str)<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>start_api_hooks()<br ALIGN="LEFT"/>test_dongle(dongle_id: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.HardwareFingerprint" [color="black", fontcolor="black", label=<{HardwareFingerprint|cpu_id : str<br ALIGN="LEFT"/>disk_serial : str<br ALIGN="LEFT"/>gpu_id : str<br ALIGN="LEFT"/>hostname : str<br ALIGN="LEFT"/>mac_address : str<br ALIGN="LEFT"/>motherboard_id : str<br ALIGN="LEFT"/>os_version : str<br ALIGN="LEFT"/>ram_size : int<br ALIGN="LEFT"/>|generate_hash(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.HardwareFingerprintGenerator" [color="black", fontcolor="black", label=<{HardwareFingerprintGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_fingerprint(): HardwareFingerprint<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.HealthMonitor" [color="black", fontcolor="black", label=<{HealthMonitor|check_interval : int<br ALIGN="LEFT"/>component_status : Dict[str, HealthStatus]<br ALIGN="LEFT"/>failure_history : deque<br ALIGN="LEFT"/>health_checks : Dict[str, Callable], dict<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>monitoring_enabled : bool<br ALIGN="LEFT"/>thresholds : dict<br ALIGN="LEFT"/>|get_system_health(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.HealthStatus" [color="black", fontcolor="black", label=<{HealthStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.help_documentation_widget.HelpDocumentationWidget" [color="black", fontcolor="black", label=<{HelpDocumentationWidget|content_tabs<br ALIGN="LEFT"/>doc_browser<br ALIGN="LEFT"/>feature_details<br ALIGN="LEFT"/>feature_selected<br ALIGN="LEFT"/>features_tree<br ALIGN="LEFT"/>features_widget<br ALIGN="LEFT"/>issues_tree : NoneType<br ALIGN="LEFT"/>nav_tree<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>search_edit<br ALIGN="LEFT"/>solution_viewer : NoneType<br ALIGN="LEFT"/>troubleshooting_widget<br ALIGN="LEFT"/>tutorial_tabs<br ALIGN="LEFT"/>tutorial_viewer : NoneType<br ALIGN="LEFT"/>tutorials_widget<br ALIGN="LEFT"/>|add_feature(parent: QTreeWidgetItem, name: str, status: str, description: str)<br ALIGN="LEFT"/>create_features_widget(): QWidget<br ALIGN="LEFT"/>create_troubleshooting_widget(): QWidget<br ALIGN="LEFT"/>create_tutorials_widget(): QWidget<br ALIGN="LEFT"/>hide_all_tree_items(tree: QTreeWidget)<br ALIGN="LEFT"/>hide_tree_item(item: QTreeWidgetItem)<br ALIGN="LEFT"/>load_documentation()<br ALIGN="LEFT"/>load_documentation_content(category: str, topic: str)<br ALIGN="LEFT"/>load_solution(issue: str)<br ALIGN="LEFT"/>load_tutorial_content(tutorial_name: str)<br ALIGN="LEFT"/>load_welcome_content()<br ALIGN="LEFT"/>on_feature_double_clicked(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_issue_selected(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_nav_item_clicked(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_search_changed(text: str)<br ALIGN="LEFT"/>on_tutorial_selected(item: QListWidgetItem)<br ALIGN="LEFT"/>perform_search()<br ALIGN="LEFT"/>populate_advanced_tutorials(list_widget: QListWidget)<br ALIGN="LEFT"/>populate_analysis_tutorials(list_widget: QListWidget)<br ALIGN="LEFT"/>populate_features_tree()<br ALIGN="LEFT"/>populate_getting_started_tutorials(list_widget: QListWidget)<br ALIGN="LEFT"/>populate_navigation_tree()<br ALIGN="LEFT"/>populate_patching_tutorials(list_widget: QListWidget)<br ALIGN="LEFT"/>populate_troubleshooting_tree()<br ALIGN="LEFT"/>search_tree(tree: QTreeWidget, search_text: str)<br ALIGN="LEFT"/>search_tree_item(item: QTreeWidgetItem, search_text: str): bool<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_all_tree_items(tree: QTreeWidget)<br ALIGN="LEFT"/>show_feature_details(category: str, feature: str)<br ALIGN="LEFT"/>show_tree_item(item: QTreeWidgetItem)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.HexCommand" [color="black", fontcolor="black", label=<{HexCommand|description : str<br ALIGN="LEFT"/>executed : bool<br ALIGN="LEFT"/>operation_type<br ALIGN="LEFT"/>timestamp : NoneType<br ALIGN="LEFT"/>|can_merge_with(other: 'HexCommand'): bool<br ALIGN="LEFT"/><I>execute</I>(file_handler): bool<br ALIGN="LEFT"/><I>get_affected_range</I>(): tuple<br ALIGN="LEFT"/>merge_with(other: 'HexCommand'): 'HexCommand'<br ALIGN="LEFT"/><I>undo</I>(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.hex_viewer.HexDisplay" [color="black", fontcolor="black", label=<{HexDisplay|bytes_per_row : int<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>cursor_moved<br ALIGN="LEFT"/>data : bytes<br ALIGN="LEFT"/>selected_end : int<br ALIGN="LEFT"/>selected_start : int<br ALIGN="LEFT"/>|get_offset_from_pos(pos)<br ALIGN="LEFT"/>input_hex_nibble(char)<br ALIGN="LEFT"/>keyPressEvent(event: QKeyEvent)<br ALIGN="LEFT"/>mouseMoveEvent(event)<br ALIGN="LEFT"/>mousePressEvent(event)<br ALIGN="LEFT"/>mouseReleaseEvent(event)<br ALIGN="LEFT"/>paintEvent(event)<br ALIGN="LEFT"/>visible_lines()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_highlighter.HexHighlight" [color="black", fontcolor="black", label=<{HexHighlight|alpha : int<br ALIGN="LEFT"/>color : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>end : int<br ALIGN="LEFT"/>highlight_type<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>size<br ALIGN="LEFT"/>start : int<br ALIGN="LEFT"/>|contains(offset: int): bool<br ALIGN="LEFT"/>get_rgba(): Tuple[int, int, int, int]<br ALIGN="LEFT"/>overlaps(start: int, end: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_highlighter.HexHighlighter" [color="black", fontcolor="black", label=<{HexHighlighter|bookmarks : List[Dict[str, Any]]<br ALIGN="LEFT"/>highlights : List[HexHighlight]<br ALIGN="LEFT"/>|add_ai_pattern_highlight(start: int, end: int, pattern_type: str, confidence: float, description: str): int<br ALIGN="LEFT"/>add_bookmark(offset: int, size: int, description: str, color: str): int<br ALIGN="LEFT"/>add_highlight(start: int, end: int, highlight_type: HighlightType, color: str, alpha: float, description: str, metadata: Optional[Dict[str, Any]]): int<br ALIGN="LEFT"/>add_modification_highlight(start: int, end: int): int<br ALIGN="LEFT"/>add_search_result(start: int, end: int, query: str, color: str): int<br ALIGN="LEFT"/>clear_highlights(highlight_type: Optional[HighlightType]): int<br ALIGN="LEFT"/>get_highlight_by_id(highlight_id: int): Optional[HexHighlight]<br ALIGN="LEFT"/>get_highlight_count(highlight_type: Optional[HighlightType]): int<br ALIGN="LEFT"/>get_highlights_at_offset(offset: int): List[HexHighlight]<br ALIGN="LEFT"/>get_highlights_for_region(start: int, end: int): List[HexHighlight]<br ALIGN="LEFT"/>remove_highlight(highlight_id: int): bool<br ALIGN="LEFT"/>update_highlight(highlight_id: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_renderer.HexViewRenderer" [color="black", fontcolor="black", label=<{HexViewRenderer|bytes_per_row : int<br ALIGN="LEFT"/>group_size : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>show_address : bool<br ALIGN="LEFT"/>show_ascii : bool<br ALIGN="LEFT"/>|render_binary_view(data: bytes, offset: int): str<br ALIGN="LEFT"/>render_decimal_view(data: bytes, offset: int): str<br ALIGN="LEFT"/>render_hex_view(data: bytes, offset: int, highlight_ranges: Optional[List[Tuple[int, int, str]]]): str<br ALIGN="LEFT"/>render_structure_view(data: bytes, structure_def: Dict[str, Any], offset: int): str<br ALIGN="LEFT"/>set_bytes_per_row(bytes_per_row: int)<br ALIGN="LEFT"/>set_group_size(group_size: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_dialog.HexViewerDialog" [color="black", fontcolor="black", label=<{HexViewerDialog|bookmarks_list<br ALIGN="LEFT"/>bytes_row_combo<br ALIGN="LEFT"/>edit_mode_action<br ALIGN="LEFT"/>group_combo<br ALIGN="LEFT"/>hex_viewer<br ALIGN="LEFT"/>search_list<br ALIGN="LEFT"/>sidebar<br ALIGN="LEFT"/>splitter<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>toolbar<br ALIGN="LEFT"/>view_mode_combo<br ALIGN="LEFT"/>|change_bytes_per_row(value_text: str)<br ALIGN="LEFT"/>change_group_size(value_text: str)<br ALIGN="LEFT"/>change_view_mode(mode_text: str)<br ALIGN="LEFT"/>clear_search_results()<br ALIGN="LEFT"/>create_sidebar(): QFrame<br ALIGN="LEFT"/>create_toolbar(): QToolBar<br ALIGN="LEFT"/>jump_to_bookmark(item)<br ALIGN="LEFT"/>jump_to_search_result(item)<br ALIGN="LEFT"/>load_file(file_path: str, read_only: bool): bool<br ALIGN="LEFT"/>open_file()<br ALIGN="LEFT"/>remove_bookmark(item)<br ALIGN="LEFT"/>save_file()<br ALIGN="LEFT"/>show_bookmark_context_menu(position)<br ALIGN="LEFT"/>show_search_context_menu(position)<br ALIGN="LEFT"/>toggle_edit_mode()<br ALIGN="LEFT"/>update_bookmark_list()<br ALIGN="LEFT"/>update_search_list()<br ALIGN="LEFT"/>update_status_bar(start: int, end: int)<br ALIGN="LEFT"/>update_view_mode_combo(mode: ViewMode)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.hex_viewer_widget.HexViewerThread" [color="black", fontcolor="black", label=<{HexViewerThread|data_loaded<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>size : Optional[int]<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_widget.HexViewerWidget" [color="black", fontcolor="black", label=<{HexViewerWidget|address_bg_color<br ALIGN="LEFT"/>address_text_color<br ALIGN="LEFT"/>address_width : int<br ALIGN="LEFT"/>ascii_offset_x : int<br ALIGN="LEFT"/>bg_color<br ALIGN="LEFT"/>bytes_per_row : int<br ALIGN="LEFT"/>char_height : int<br ALIGN="LEFT"/>char_width : int<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>data_changed<br ALIGN="LEFT"/>editing_offset : int<br ALIGN="LEFT"/>editing_text : str<br ALIGN="LEFT"/>file_handler : NoneType<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>group_size : int<br ALIGN="LEFT"/>gutter_width : int<br ALIGN="LEFT"/>header_bg_color<br ALIGN="LEFT"/>header_height : int<br ALIGN="LEFT"/>header_text_color<br ALIGN="LEFT"/>hex_offset_x : int<br ALIGN="LEFT"/>highlight_selection_color<br ALIGN="LEFT"/>highlighter<br ALIGN="LEFT"/>modified_color<br ALIGN="LEFT"/>offset_changed<br ALIGN="LEFT"/>performance_monitor<br ALIGN="LEFT"/>renderer<br ALIGN="LEFT"/>selection_changed<br ALIGN="LEFT"/>selection_color<br ALIGN="LEFT"/>selection_end : int<br ALIGN="LEFT"/>selection_start : int<br ALIGN="LEFT"/>text_color<br ALIGN="LEFT"/>view_mode : HEX<br ALIGN="LEFT"/>view_mode_changed<br ALIGN="LEFT"/>|add_bookmark(offset: int, size: int, description: str)<br ALIGN="LEFT"/>add_bookmark_dialog()<br ALIGN="LEFT"/>apply_edits()<br ALIGN="LEFT"/>clear_selection()<br ALIGN="LEFT"/>close()<br ALIGN="LEFT"/>copy_selection_as_c_array()<br ALIGN="LEFT"/>copy_selection_as_hex()<br ALIGN="LEFT"/>copy_selection_as_text()<br ALIGN="LEFT"/>discard_edits()<br ALIGN="LEFT"/>draw_binary_row(painter: QPainter, data: bytes, offset: int, y: int)<br ALIGN="LEFT"/>draw_byte_highlights(painter: QPainter, byte_offset: int, x: int, y: int, width: int, highlights: List[HexHighlight])<br ALIGN="LEFT"/>draw_decimal_row(painter: QPainter, data: bytes, offset: int, y: int)<br ALIGN="LEFT"/>draw_header(painter: QPainter, h_scroll: int)<br ALIGN="LEFT"/>draw_hex_row(painter: QPainter, data: bytes, offset: int, y: int)<br ALIGN="LEFT"/>edit_byte(offset: int, value: int)<br ALIGN="LEFT"/>edit_selection(data: bytes)<br ALIGN="LEFT"/>edit_selection_dialog()<br ALIGN="LEFT"/>fill_selection()<br ALIGN="LEFT"/>get_offset_from_position(position: QPoint): int<br ALIGN="LEFT"/>get_performance_stats()<br ALIGN="LEFT"/>get_performance_widget()<br ALIGN="LEFT"/>get_selected_data(): Optional[bytes]<br ALIGN="LEFT"/>get_selection(): Tuple[int, int]<br ALIGN="LEFT"/>handle_navigation_key(key: int, modifiers: Qt.KeyboardModifier)<br ALIGN="LEFT"/>handle_scroll(value: int)<br ALIGN="LEFT"/>jump_to_offset(offset: int)<br ALIGN="LEFT"/>keyPressEvent(event: QKeyEvent)<br ALIGN="LEFT"/>load_data(data: bytes, name: str): bool<br ALIGN="LEFT"/>load_file(file_path: str, read_only: bool): bool<br ALIGN="LEFT"/>mouseMoveEvent(event: QMouseEvent)<br ALIGN="LEFT"/>mousePressEvent(event: QMouseEvent)<br ALIGN="LEFT"/>optimize_for_large_files()<br ALIGN="LEFT"/>paintEvent(event: QPaintEvent)<br ALIGN="LEFT"/>resizeEvent(event: QResizeEvent)<br ALIGN="LEFT"/>search(pattern: Union[bytes, str], start_offset: int, case_sensitive: bool, direction: str): Optional[int]<br ALIGN="LEFT"/>select_range(start: int, end: int)<br ALIGN="LEFT"/>set_bytes_per_row(bytes_per_row: int)<br ALIGN="LEFT"/>set_group_size(group_size: int)<br ALIGN="LEFT"/>set_view_mode(mode: ViewMode)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_context_menu(pos: QPoint)<br ALIGN="LEFT"/>show_jump_dialog()<br ALIGN="LEFT"/>show_performance_dialog()<br ALIGN="LEFT"/>show_search_dialog()<br ALIGN="LEFT"/>update_scrollbars()<br ALIGN="LEFT"/>viewportEvent(event)<br ALIGN="LEFT"/>viewportPaintEvent(event: QPaintEvent)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.hex_viewer.HexViewerWidget" [color="black", fontcolor="black", label=<{HexViewerWidget|bytes_per_row : int<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>cursor_pos : int<br ALIGN="LEFT"/>data : bytearray, bytes<br ALIGN="LEFT"/>data_modified<br ALIGN="LEFT"/>edit_mode<br ALIGN="LEFT"/>edit_toggle<br ALIGN="LEFT"/>hex_display<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>offset_box<br ALIGN="LEFT"/>search_box<br ALIGN="LEFT"/>selected_end : int<br ALIGN="LEFT"/>selected_start : int<br ALIGN="LEFT"/>selection_changed<br ALIGN="LEFT"/>selection_end<br ALIGN="LEFT"/>selection_start : int<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>v_scrollbar<br ALIGN="LEFT"/>|goto_offset()<br ALIGN="LEFT"/>load_data(data: bytes)<br ALIGN="LEFT"/>scroll_to(value)<br ALIGN="LEFT"/>scroll_to_offset(offset)<br ALIGN="LEFT"/>search_hex()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>toggle_edit_mode(checked)<br ALIGN="LEFT"/>update_cursor_info(offset)<br ALIGN="LEFT"/>update_scrollbar()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.hex_viewer_widget.HexViewerWidget" [color="black", fontcolor="black", label=<{HexViewerWidget|ascii_display<br ALIGN="LEFT"/>bytes_per_line : int<br ALIGN="LEFT"/>bytes_per_line_spin<br ALIGN="LEFT"/>collapse_all_btn<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>expand_all_btn<br ALIGN="LEFT"/>file_data : Optional[bytes]<br ALIGN="LEFT"/>file_model : NoneType, Optional[PEFileModel]<br ALIGN="LEFT"/>file_path : Optional[str]<br ALIGN="LEFT"/>goto_btn<br ALIGN="LEFT"/>goto_rva_btn<br ALIGN="LEFT"/>hex_display<br ALIGN="LEFT"/>highlighted_regions : List[Tuple[int, int, QColor]]<br ALIGN="LEFT"/>info_panel<br ALIGN="LEFT"/>interpreter_table<br ALIGN="LEFT"/>load_thread<br ALIGN="LEFT"/>offset_selected<br ALIGN="LEFT"/>offset_spin<br ALIGN="LEFT"/>region_highlighted<br ALIGN="LEFT"/>rva_spin<br ALIGN="LEFT"/>search_btn<br ALIGN="LEFT"/>search_input<br ALIGN="LEFT"/>search_type<br ALIGN="LEFT"/>selection_info<br ALIGN="LEFT"/>show_structure_cb<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>structure_info_text<br ALIGN="LEFT"/>structure_model : NoneType, Optional[PEStructureModel]<br ALIGN="LEFT"/>structure_tree<br ALIGN="LEFT"/>|add_protection_highlight(offset: int, size: int, protection_name: str)<br ALIGN="LEFT"/>apply_highlighting()<br ALIGN="LEFT"/>clear_highlights()<br ALIGN="LEFT"/>export_selection()<br ALIGN="LEFT"/>go_to_offset(offset: int)<br ALIGN="LEFT"/>go_to_rva(rva: int)<br ALIGN="LEFT"/>highlight_region(start: int, end: int, color: QColor)<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>interpret_bytes(offset: int)<br ALIGN="LEFT"/>interpret_data_at_cursor()<br ALIGN="LEFT"/>load_file(file_path: str, offset: int, size: Optional[int])<br ALIGN="LEFT"/>on_data_loaded(data: bytes)<br ALIGN="LEFT"/>on_load_error(error: str)<br ALIGN="LEFT"/>on_load_progress(progress: int)<br ALIGN="LEFT"/>search_data()<br ALIGN="LEFT"/>update_display()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_highlighter.HighlightType" [color="black", fontcolor="black", label=<{HighlightType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.frida_manager.HookBatcher" [color="black", fontcolor="black", label=<{HookBatcher|batch_thread : NoneType, Thread<br ALIGN="LEFT"/>batch_timeout_ms : int<br ALIGN="LEFT"/>hook_queue : Queue<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_batch_size : int<br ALIGN="LEFT"/>pending_hooks : defaultdict<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|add_hook(category: HookCategory, hook_spec: Dict[str, Any])<br ALIGN="LEFT"/>get_batch_stats(): Dict[str, int]<br ALIGN="LEFT"/>start_batching()<br ALIGN="LEFT"/>stop_batching()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_constants.HookCategory" [color="black", fontcolor="black", label=<{HookCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" [color="black", fontcolor="black", label=<{HookedSocket|<br ALIGN="LEFT"/>|connect(address)<br ALIGN="LEFT"/>recv(bufsize, flags)<br ALIGN="LEFT"/>send(data, flags)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.communication_protocols.HttpsProtocol" [color="black", fontcolor="black", label=<{HttpsProtocol|connected : bool<br ALIGN="LEFT"/>connection_count<br ALIGN="LEFT"/>server<br ALIGN="LEFT"/>session : NoneType<br ALIGN="LEFT"/>ssl_cert : Optional[str]<br ALIGN="LEFT"/>ssl_context : NoneType<br ALIGN="LEFT"/>ssl_key : Optional[str]<br ALIGN="LEFT"/>ssl_verify : bool<br ALIGN="LEFT"/>|connect(): bool<br ALIGN="LEFT"/>disconnect()<br ALIGN="LEFT"/>send_message(message: Dict[str, Any]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.HuggingFaceLocalBackend" [color="black", fontcolor="black", label=<{HuggingFaceLocalBackend|device : NoneType, device<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>quantization_manager : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.HyperparameterOptimizationWidget" [color="black", fontcolor="black", label=<{HyperparameterOptimizationWidget|batch_max_spin : QSpinBox<br ALIGN="LEFT"/>batch_min_spin : QSpinBox<br ALIGN="LEFT"/>best_params_text : QTextEdit<br ALIGN="LEFT"/>layers_max_spin : QSpinBox<br ALIGN="LEFT"/>layers_min_spin : QSpinBox<br ALIGN="LEFT"/>lr_max_spin : QDoubleSpinBox<br ALIGN="LEFT"/>lr_min_spin : QDoubleSpinBox<br ALIGN="LEFT"/>num_trials_spin : QSpinBox<br ALIGN="LEFT"/>optimization_history : list<br ALIGN="LEFT"/>progress_plot : PlotWidget<br ALIGN="LEFT"/>results_table : QTableWidget<br ALIGN="LEFT"/>start_optimization_btn : QPushButton<br ALIGN="LEFT"/>stop_optimization_btn : QPushButton<br ALIGN="LEFT"/>strategy_combo : QComboBox<br ALIGN="LEFT"/>|add_result_to_table(result)<br ALIGN="LEFT"/>get_best_parameters()<br ALIGN="LEFT"/>run_optimization(strategy, param_ranges, num_trials)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_optimization()<br ALIGN="LEFT"/>stop_optimization()<br ALIGN="LEFT"/>update_best_params(best_params, best_accuracy)<br ALIGN="LEFT"/>update_progress_plot()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisThread" [color="black", fontcolor="black", label=<{ICPAnalysisThread|error_occurred<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>result_ready<br ALIGN="LEFT"/>scan_mode<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget._show_inline_icp_features.ICPAnalysisThread" [color="black", fontcolor="black", label=<{ICPAnalysisThread|analysis_complete<br ALIGN="LEFT"/>file_path<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisWidget" [color="black", fontcolor="black", label=<{ICPAnalysisWidget|analysis_complete<br ALIGN="LEFT"/>analyze_btn<br ALIGN="LEFT"/>bypass_text<br ALIGN="LEFT"/>details_tabs<br ALIGN="LEFT"/>details_text<br ALIGN="LEFT"/>detections_tree<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>protection_selected<br ALIGN="LEFT"/>raw_json_text<br ALIGN="LEFT"/>scan_mode_combo<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|analyze_file(file_path: str)<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>get_current_result(): Optional[ICPScanResult]<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>on_analysis_complete(result: ICPScanResult)<br ALIGN="LEFT"/>on_analysis_error(error: str)<br ALIGN="LEFT"/>on_analyze_clicked()<br ALIGN="LEFT"/>on_detection_selected(item: QTreeWidgetItem, column: int)<br ALIGN="LEFT"/>on_progress_update(message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ICPBackend" [color="black", fontcolor="black", label=<{ICPBackend|die<br ALIGN="LEFT"/>engine_path : Optional[str]<br ALIGN="LEFT"/>|add_supplemental_data(scan_result: ICPScanResult, supplemental_data: Dict[str, Any]): ICPScanResult<br ALIGN="LEFT"/>analyze_file(file_path: str, scan_mode: ScanMode, show_entropy: bool, show_info: bool, timeout: float, include_supplemental: bool): ICPScanResult<br ALIGN="LEFT"/>analyze_with_all_engines(file_path: str, scan_mode: ScanMode): ICPScanResult<br ALIGN="LEFT"/>batch_analyze(file_paths: List[str], scan_mode: ScanMode, max_concurrent: int): Dict[str, ICPScanResult]<br ALIGN="LEFT"/>detect_packers(file_path: str): List[str]<br ALIGN="LEFT"/>extract_strings(file_path: str, min_length: int): List[Dict[str, any]]<br ALIGN="LEFT"/>get_available_scan_modes(): List[str]<br ALIGN="LEFT"/>get_detailed_analysis(file_path: str, include_supplemental: bool, yara_data: Optional[Dict[str, Any]], firmware_data: Optional[Dict[str, Any]], memory_data: Optional[Dict[str, Any]]): Dict[str, any]<br ALIGN="LEFT"/>get_engine_version(): str<br ALIGN="LEFT"/>get_file_entropy(file_path: str): float<br ALIGN="LEFT"/>get_file_sections(file_path: str): List[Dict[str, any]]<br ALIGN="LEFT"/>get_file_type(file_path: str): str<br ALIGN="LEFT"/>get_supplemental_engines_status(): Dict[str, Any]<br ALIGN="LEFT"/>is_die_python_available(): bool<br ALIGN="LEFT"/>merge_analysis_engines_data(file_path: str, yara_data: Optional[Dict[str, Any]], firmware_data: Optional[Dict[str, Any]], memory_data: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ICPDetection" [color="black", fontcolor="black", label=<{ICPDetection|confidence : float<br ALIGN="LEFT"/>info : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>string : str<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ICPDetection'<br ALIGN="LEFT"/>from_die_result(result): 'ICPDetection'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ICPEngineError" [color="black", fontcolor="red", label=<{ICPEngineError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ICPFileInfo" [color="black", fontcolor="black", label=<{ICPFileInfo|detections : List[ICPDetection]<br ALIGN="LEFT"/>filetype : str<br ALIGN="LEFT"/>offset : str<br ALIGN="LEFT"/>parentfilepart : str<br ALIGN="LEFT"/>size : str<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ICPFileInfo'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_report_generator.ICPReportGenerator" [color="black", fontcolor="black", label=<{ICPReportGenerator|report_output_path<br ALIGN="LEFT"/>report_template_path<br ALIGN="LEFT"/>|generate_report(result: UnifiedProtectionResult, options: Optional[ReportOptions]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ICPScanResult" [color="black", fontcolor="black", label=<{ICPScanResult|all_detections<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>file_info : dict<br ALIGN="LEFT"/>file_infos : List[ICPFileInfo]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>is_packed<br ALIGN="LEFT"/>is_protected<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>raw_json : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>supplemental_data : Dict[str, Any]<br ALIGN="LEFT"/>|from_die_results(file_path: str, die_results: List): 'ICPScanResult'<br ALIGN="LEFT"/>from_die_text(file_path: str, die_text: str): 'ICPScanResult'<br ALIGN="LEFT"/>from_json(file_path: str, json_data: Dict[str, Any]): 'ICPScanResult'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.kernel_injection.INJECTION_INFO" [color="black", fontcolor="black", label=<{INJECTION_INFO|DllPath<br ALIGN="LEFT"/>ProcessId<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.IOOptimizer" [color="black", fontcolor="black", label=<{IOOptimizer|compression_cache : dict<br ALIGN="LEFT"/>file_access_patterns : defaultdict<br ALIGN="LEFT"/>read_ahead_size : int<br ALIGN="LEFT"/>|detect_compression(data: bytes): Tuple[bool, str]<br ALIGN="LEFT"/>optimize_read_ahead(file_path: str)<br ALIGN="LEFT"/>optimized_read(file_path: str, chunk_size: int): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.import_checks.ImportChecker" [color="black", fontcolor="black", label=<{ImportChecker|<br ALIGN="LEFT"/>|check_import(module_name: str, package_name: Optional[str]): bool<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>get_available_imports(module_list: List[str]): Dict[str, bool]<br ALIGN="LEFT"/>safe_import(module_name: str, fallback: Optional[Any], package_name: Optional[str]): Tuple[bool, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.ImportHash" [color="black", fontcolor="black", label=<{ImportHash|imphash : str<br ALIGN="LEFT"/>imphash_sorted : str<br ALIGN="LEFT"/>rich_header_hash : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.ImportInfo" [color="black", fontcolor="black", label=<{ImportInfo|address : int<br ALIGN="LEFT"/>dll_name : str<br ALIGN="LEFT"/>function_name : str<br ALIGN="LEFT"/>hint : Optional[int]<br ALIGN="LEFT"/>ordinal : Optional[int]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.incremental_manager.IncrementalAnalysisManager" [color="black", fontcolor="black", label=<{IncrementalAnalysisManager|analysis_cache : dict<br ALIGN="LEFT"/>cache : dict<br ALIGN="LEFT"/>cache_dir : Path<br ALIGN="LEFT"/>cache_hits : int<br ALIGN="LEFT"/>cache_misses : int<br ALIGN="LEFT"/>chunk_cache : dict<br ALIGN="LEFT"/>chunk_size<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>current_binary : bytes, str<br ALIGN="LEFT"/>current_binary_hash : NoneType, str<br ALIGN="LEFT"/>enable_compression<br ALIGN="LEFT"/>file_hashes : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_cache_size<br ALIGN="LEFT"/>|analyze_incremental(binary_path: str, analysis_types: Optional[list]): Dict[str, Any]<br ALIGN="LEFT"/>cache_analysis(analysis_type: str, results: Any): bool<br ALIGN="LEFT"/>cleanup_old_cache(max_age_days: Optional[int]): int<br ALIGN="LEFT"/>clear_cache(binary_hash: Optional[str]): bool<br ALIGN="LEFT"/>get_cache_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_cached_analysis(analysis_type: str): Optional[Any]<br ALIGN="LEFT"/>set_binary(binary_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.InsertCommand" [color="black", fontcolor="black", label=<{InsertCommand|data : bytes<br ALIGN="LEFT"/>executed : bool<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>|execute(file_handler): bool<br ALIGN="LEFT"/>get_affected_range(): tuple<br ALIGN="LEFT"/>undo(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.IntegratedBackgroundLoader" [color="black", fontcolor="black", label=<{IntegratedBackgroundLoader|background_loader<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>model_tasks : Dict[str, LoadingTask]<br ALIGN="LEFT"/>progress_callbacks : List[ProgressCallback]<br ALIGN="LEFT"/>|add_progress_callback(callback: ProgressCallback)<br ALIGN="LEFT"/>cancel_loading(model_id: str): bool<br ALIGN="LEFT"/>get_all_loading_tasks(): Dict[str, LoadingTask]<br ALIGN="LEFT"/>get_loading_progress(model_id: str): Optional[LoadingTask]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>load_model_in_background(model_id: str, backend_class: type, config: 'LLMConfig', priority: int): LoadingTask<br ALIGN="LEFT"/>remove_progress_callback(callback: ProgressCallback)<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.integration_manager.IntegrationManager" [color="black", fontcolor="black", label=<{IntegrationManager|active_tasks : Dict[str, IntegrationTask]<br ALIGN="LEFT"/>active_workflows : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>autonomous_agent<br ALIGN="LEFT"/>code_modifier<br ALIGN="LEFT"/>completed_tasks : Dict[str, IntegrationTask], dict<br ALIGN="LEFT"/>enable_caching : bool<br ALIGN="LEFT"/>enable_parallel_execution : bool<br ALIGN="LEFT"/>event_handlers : Dict[str, List[Callable]]<br ALIGN="LEFT"/>executor : ThreadPoolExecutor<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_workers : int<br ALIGN="LEFT"/>qemu_manager : QEMUTestManager<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>script_generator<br ALIGN="LEFT"/>task_dependencies : Dict[str, List[str]]<br ALIGN="LEFT"/>task_queue : Queue<br ALIGN="LEFT"/>task_timeout : int<br ALIGN="LEFT"/>worker_threads : List[threading.Thread]<br ALIGN="LEFT"/>workflow_results : Dict[str, WorkflowResult], dict<br ALIGN="LEFT"/>|add_event_handler(event_type: str, handler: Callable)<br ALIGN="LEFT"/>cancel_task(task_id: str): bool<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>create_bypass_workflow(target_binary: str, bypass_type: str): str<br ALIGN="LEFT"/>create_task(task_type: str, description: str, input_data: Dict[str, Any], dependencies: List[str], priority: int): str<br ALIGN="LEFT"/>create_workflow(workflow_definition: Dict[str, Any]): str<br ALIGN="LEFT"/>get_performance_summary(): Dict[str, Any]<br ALIGN="LEFT"/>get_task_status(task_id: str): Dict[str, Any]<br ALIGN="LEFT"/>get_workflow_status(workflow_id: str): Dict[str, Any]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>wait_for_task(task_id: str, timeout: Optional[float]): IntegrationTask<br ALIGN="LEFT"/>wait_for_workflow(workflow_id: str, timeout: Optional[float]): WorkflowResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.integration_manager.IntegrationTask" [color="black", fontcolor="black", label=<{IntegrationTask|completed_at : Optional[datetime]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>input_data : Dict[str, Any]<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>result : Optional[Any]<br ALIGN="LEFT"/>started_at : Optional[datetime]<br ALIGN="LEFT"/>status : str<br ALIGN="LEFT"/>task_id : str<br ALIGN="LEFT"/>task_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" [color="black", fontcolor="black", label=<{IntellicrackAIAssistant|cli_interface : NoneType<br ALIGN="LEFT"/>context : dict<br ALIGN="LEFT"/>conversation_history : list<br ALIGN="LEFT"/>file_tools<br ALIGN="LEFT"/>tools : dict<br ALIGN="LEFT"/>|analyze_binary_complex(binary_path: str, ml_results: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_license_patterns(input_data: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_system_prompt(): str<br ALIGN="LEFT"/>perform_reasoning(task_data: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>process_message(message: str, context: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.IntellicrackAIInterface" [color="black", fontcolor="black", label=<{IntellicrackAIInterface|RISK_LEVELS : dict<br ALIGN="LEFT"/>cli_path<br ALIGN="LEFT"/>confirmation_manager<br ALIGN="LEFT"/>current_analysis : dict<br ALIGN="LEFT"/>session_id : str<br ALIGN="LEFT"/>|analyze_binary(binary_path: str, analyses: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>apply_patch(binary_path: str, patch_file: str): Dict[str, Any]<br ALIGN="LEFT"/>execute_command(args: List[str], description: str, ai_reasoning: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>get_session_summary(): Dict[str, Any]<br ALIGN="LEFT"/>suggest_patches(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_integration.IntellicrackAIServer" [color="black", fontcolor="black", label=<{IntellicrackAIServer|adapters : dict<br ALIGN="LEFT"/>confirmation_manager<br ALIGN="LEFT"/>interface<br ALIGN="LEFT"/>|get_adapter(model_type: str): Optional[AIModelAdapter]<br ALIGN="LEFT"/>handle_request(request: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.IntellicrackAdvancedProtection" [color="black", fontcolor="black", label=<{IntellicrackAdvancedProtection|cache_enabled : bool<br ALIGN="LEFT"/>custom_db_path : NoneType, str<br ALIGN="LEFT"/>result_cache : dict<br ALIGN="LEFT"/>|batch_analyze(file_paths: List[str], max_workers: int, scan_mode: ScanMode): Dict[str, AdvancedProtectionAnalysis]<br ALIGN="LEFT"/>create_custom_signature(name: str, pattern: bytes, offset: int, description: str): bool<br ALIGN="LEFT"/>detect_protections_advanced(file_path: str, scan_mode: ScanMode, enable_heuristic: bool, export_format: ExportFormat, extract_strings: bool, max_string_length: int): AdvancedProtectionAnalysis<br ALIGN="LEFT"/>export_to_yara(analysis: AdvancedProtectionAnalysis): str<br ALIGN="LEFT"/>get_format_capabilities(file_path: str): Dict[str, bool]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.intellicrack_advanced_protection_widget.IntellicrackAdvancedProtectionWidget" [color="black", fontcolor="black", label=<{IntellicrackAdvancedProtectionWidget|analysis_requested<br ALIGN="LEFT"/>analysis_thread : Optional[AdvancedAnalysisThread]<br ALIGN="LEFT"/>analyze_btn<br ALIGN="LEFT"/>browse_btn<br ALIGN="LEFT"/>bypass_text<br ALIGN="LEFT"/>certificates_table<br ALIGN="LEFT"/>certificates_widget<br ALIGN="LEFT"/>current_analysis : NoneType, Optional[AdvancedProtectionAnalysis]<br ALIGN="LEFT"/>details_tabs<br ALIGN="LEFT"/>detections_table<br ALIGN="LEFT"/>detections_widget<br ALIGN="LEFT"/>entropy_graph<br ALIGN="LEFT"/>entropy_table<br ALIGN="LEFT"/>entropy_widget<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>export_format_combo<br ALIGN="LEFT"/>export_preview<br ALIGN="LEFT"/>export_widget<br ALIGN="LEFT"/>file_path_edit<br ALIGN="LEFT"/>heuristic_check<br ALIGN="LEFT"/>heuristics_text<br ALIGN="LEFT"/>heuristics_widget<br ALIGN="LEFT"/>main_splitter<br ALIGN="LEFT"/>overview_text<br ALIGN="LEFT"/>overview_widget<br ALIGN="LEFT"/>preview_btn<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>protection_detected<br ALIGN="LEFT"/>resources_table<br ALIGN="LEFT"/>resources_widget<br ALIGN="LEFT"/>results_tree<br ALIGN="LEFT"/>scan_mode_combo<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>strings_check<br ALIGN="LEFT"/>strings_filter<br ALIGN="LEFT"/>strings_table<br ALIGN="LEFT"/>strings_widget<br ALIGN="LEFT"/>|clear_results()<br ALIGN="LEFT"/>create_certificates_widget(): QWidget<br ALIGN="LEFT"/>create_detections_widget(): QWidget<br ALIGN="LEFT"/>create_entropy_widget(): QWidget<br ALIGN="LEFT"/>create_export_widget(): QWidget<br ALIGN="LEFT"/>create_header_widget(): QWidget<br ALIGN="LEFT"/>create_heuristics_widget(): QWidget<br ALIGN="LEFT"/>create_left_panel(): QWidget<br ALIGN="LEFT"/>create_overview_widget(): QWidget<br ALIGN="LEFT"/>create_resources_widget(): QWidget<br ALIGN="LEFT"/>create_right_panel(): QWidget<br ALIGN="LEFT"/>create_status_widget(): QWidget<br ALIGN="LEFT"/>create_strings_widget(): QWidget<br ALIGN="LEFT"/>display_results(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>filter_strings(text: str)<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>on_analysis_complete(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>on_analysis_error(error_msg: str)<br ALIGN="LEFT"/>on_analysis_progress(message: str, percentage: int)<br ALIGN="LEFT"/>on_analyze_clicked()<br ALIGN="LEFT"/>on_browse_clicked()<br ALIGN="LEFT"/>on_detection_selected()<br ALIGN="LEFT"/>on_export_clicked()<br ALIGN="LEFT"/>on_tree_selection_changed()<br ALIGN="LEFT"/>set_binary_path(file_path: str)<br ALIGN="LEFT"/>update_certificates(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_detections(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_entropy(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_export_preview()<br ALIGN="LEFT"/>update_heuristics(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_overview(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_resources(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_results_tree(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>update_strings(analysis: AdvancedProtectionAnalysis)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app.IntellicrackApp" [color="black", fontcolor="black", label=<{IntellicrackApp|activities_log<br ALIGN="LEFT"/>activity_log : NoneType<br ALIGN="LEFT"/>adobe_action_combo<br ALIGN="LEFT"/>adobe_status_label<br ALIGN="LEFT"/>ai_chat_display<br ALIGN="LEFT"/>ai_chat_input<br ALIGN="LEFT"/>ai_code_editor<br ALIGN="LEFT"/>ai_conversation_history : list<br ALIGN="LEFT"/>ai_coordinator : NoneType<br ALIGN="LEFT"/>ai_file_tree<br ALIGN="LEFT"/>ai_orchestrator : NoneType<br ALIGN="LEFT"/>ai_project_folder<br ALIGN="LEFT"/>analysis_type_history : list<br ALIGN="LEFT"/>analyze_results : list<br ALIGN="LEFT"/>analyze_results_widget<br ALIGN="LEFT"/>analyze_status<br ALIGN="LEFT"/>app_context : NoneType<br ALIGN="LEFT"/>arch_combo<br ALIGN="LEFT"/>assistant_status : NoneType<br ALIGN="LEFT"/>assistant_tab : NoneType<br ALIGN="LEFT"/>auto_patch_attempted : bool<br ALIGN="LEFT"/>available_plugins : dict<br ALIGN="LEFT"/>binary_icon_label<br ALIGN="LEFT"/>binary_info : NoneType, dict<br ALIGN="LEFT"/>binary_info_group : NoneType<br ALIGN="LEFT"/>binary_info_label<br ALIGN="LEFT"/>binary_path : NoneType<br ALIGN="LEFT"/>binary_tool_file_info : NoneType<br ALIGN="LEFT"/>binary_tool_file_label : NoneType<br ALIGN="LEFT"/>binary_tool_stack : NoneType<br ALIGN="LEFT"/>c2_encryption_combo<br ALIGN="LEFT"/>c2_port_edit<br ALIGN="LEFT"/>c2_protocol_combo<br ALIGN="LEFT"/>capture_thread : NoneType, Thread<br ALIGN="LEFT"/>chat_display : NoneType<br ALIGN="LEFT"/>chat_history : list<br ALIGN="LEFT"/>clear_analysis_results<br ALIGN="LEFT"/>current_ai_file : NoneType<br ALIGN="LEFT"/>current_theme<br ALIGN="LEFT"/>custom_model_path_label<br ALIGN="LEFT"/>debug_check : NoneType<br ALIGN="LEFT"/>directory_analysis_results : list<br ALIGN="LEFT"/>disasm_text : NoneType<br ALIGN="LEFT"/>distributed_enable_cb<br ALIGN="LEFT"/>dynamic_analyzer : NoneType<br ALIGN="LEFT"/>edit_current_btn : NoneType<br ALIGN="LEFT"/>encoding_combo<br ALIGN="LEFT"/>error_check : NoneType<br ALIGN="LEFT"/>evasion_combo<br ALIGN="LEFT"/>exploit_output<br ALIGN="LEFT"/>exploitation_orchestrator : NoneType<br ALIGN="LEFT"/>font_size_combo<br ALIGN="LEFT"/>frida_sessions : dict<br ALIGN="LEFT"/>gc_enable_cb<br ALIGN="LEFT"/>generate_key_signal<br ALIGN="LEFT"/>ghidra_path_edit<br ALIGN="LEFT"/>gpu_enable_cb<br ALIGN="LEFT"/>hex_viewer_widget<br ALIGN="LEFT"/>incremental_enable_cb<br ALIGN="LEFT"/>info_check : NoneType<br ALIGN="LEFT"/>inject_comprehensive_api_hooks<br ALIGN="LEFT"/>key_format_dropdown<br ALIGN="LEFT"/>keygen_input_name<br ALIGN="LEFT"/>keygen_input_version<br ALIGN="LEFT"/>keygen_results<br ALIGN="LEFT"/>keygen_seed<br ALIGN="LEFT"/>last_log_accessed : NoneType<br ALIGN="LEFT"/>leak_detect_enable_cb<br ALIGN="LEFT"/>lhost_edit<br ALIGN="LEFT"/>log_access_history : list<br ALIGN="LEFT"/>log_filter : NoneType<br ALIGN="LEFT"/>log_output : NoneType<br ALIGN="LEFT"/>log_user_question<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>lport_edit<br ALIGN="LEFT"/>mem_struct_enable_cb<br ALIGN="LEFT"/>memory_dumper_widget<br ALIGN="LEFT"/>memory_interval_spinbox<br ALIGN="LEFT"/>memory_opt_enable_cb<br ALIGN="LEFT"/>memory_threshold_spinbox<br ALIGN="LEFT"/>ml_predictor : NoneType<br ALIGN="LEFT"/>model_manager : NoneType<br ALIGN="LEFT"/>network_analysis_results : dict<br ALIGN="LEFT"/>notifications_list : NoneType<br ALIGN="LEFT"/>packet_capture : list<br ALIGN="LEFT"/>packet_update_timer : NoneType<br ALIGN="LEFT"/>patch_plan_table<br ALIGN="LEFT"/>patches : list<br ALIGN="LEFT"/>patches_label<br ALIGN="LEFT"/>payload_type_combo<br ALIGN="LEFT"/>platform_combo<br ALIGN="LEFT"/>plugin_name_label : NoneType<br ALIGN="LEFT"/>plugin_timeout_spinbox<br ALIGN="LEFT"/>potential_patches : dict, list<br ALIGN="LEFT"/>program_info : NoneType<br ALIGN="LEFT"/>protection_results<br ALIGN="LEFT"/>protections_label<br ALIGN="LEFT"/>qemu_command_input<br ALIGN="LEFT"/>recent_files : list<br ALIGN="LEFT"/>recent_files_list : NoneType<br ALIGN="LEFT"/>replace_chat_display_last<br ALIGN="LEFT"/>report_format_combo<br ALIGN="LEFT"/>report_template_combo<br ALIGN="LEFT"/>report_viewer : NoneType<br ALIGN="LEFT"/>reports : dict, list<br ALIGN="LEFT"/>reports_table<br ALIGN="LEFT"/>research_type_combo<br ALIGN="LEFT"/>run_automated_patch_agent<br ALIGN="LEFT"/>run_cfg_explorer<br ALIGN="LEFT"/>run_cloud_license_hooker<br ALIGN="LEFT"/>run_concolic_execution<br ALIGN="LEFT"/>run_enhanced_protection_scan<br ALIGN="LEFT"/>run_frida_plugin_from_file<br ALIGN="LEFT"/>run_ghidra_plugin_from_file<br ALIGN="LEFT"/>run_protocol_fingerprinter<br ALIGN="LEFT"/>run_rop_chain_generator<br ALIGN="LEFT"/>run_ssl_tls_interceptor<br ALIGN="LEFT"/>scale_value_label<br ALIGN="LEFT"/>script_execution_manager<br ALIGN="LEFT"/>selected_model_path : NoneType<br ALIGN="LEFT"/>set_keygen_name<br ALIGN="LEFT"/>set_keygen_version<br ALIGN="LEFT"/>setup_memory_patching<br ALIGN="LEFT"/>switch_tab<br ALIGN="LEFT"/>target_input<br ALIGN="LEFT"/>task_manager : NoneType<br ALIGN="LEFT"/>theme_combo<br ALIGN="LEFT"/>traffic_analyzer : NoneType<br ALIGN="LEFT"/>traffic_table<br ALIGN="LEFT"/>ui_scale_slider<br ALIGN="LEFT"/>update_analysis_results<br ALIGN="LEFT"/>update_assistant_status<br ALIGN="LEFT"/>update_chat_display<br ALIGN="LEFT"/>update_output<br ALIGN="LEFT"/>update_progress<br ALIGN="LEFT"/>update_status<br ALIGN="LEFT"/>user_input : NoneType<br ALIGN="LEFT"/>view_current_btn : NoneType<br ALIGN="LEFT"/>vulns_found_label<br ALIGN="LEFT"/>warning_check : NoneType<br ALIGN="LEFT"/>|add_spacer_to_layout(layout, width, height, expanding)<br ALIGN="LEFT"/>ai_add_comments()<br ALIGN="LEFT"/>ai_analyze_current_code()<br ALIGN="LEFT"/>ai_modify_code()<br ALIGN="LEFT"/>analyze_captured_traffic()<br ALIGN="LEFT"/>analyze_directory()<br ALIGN="LEFT"/>analyze_process_behavior()<br ALIGN="LEFT"/>append_analysis_results(text)<br ALIGN="LEFT"/>append_chat_display(text)<br ALIGN="LEFT"/>append_output(text)<br ALIGN="LEFT"/>append_raw_console(text)<br ALIGN="LEFT"/>apply_all_patches()<br ALIGN="LEFT"/>apply_appearance_settings()<br ALIGN="LEFT"/>apply_comprehensive_tooltips()<br ALIGN="LEFT"/>apply_config_preset(preset_name)<br ALIGN="LEFT"/>apply_cracking_pattern(source_binary, target_binary)<br ALIGN="LEFT"/>apply_dark_theme()<br ALIGN="LEFT"/>apply_light_theme()<br ALIGN="LEFT"/>apply_log_filter()<br ALIGN="LEFT"/>apply_patch(row)<br ALIGN="LEFT"/>apply_patch_plan()<br ALIGN="LEFT"/>apply_performance_settings()<br ALIGN="LEFT"/>apply_theme(theme_name)<br ALIGN="LEFT"/>apply_theme_settings()<br ALIGN="LEFT"/>async_get_network_interfaces()<br ALIGN="LEFT"/>browse_ghidra_path()<br ALIGN="LEFT"/>check_adobe_licensex_status()<br ALIGN="LEFT"/>check_dependencies_ui()<br ALIGN="LEFT"/>clear_binary()<br ALIGN="LEFT"/>clear_logs()<br ALIGN="LEFT"/>clear_network_capture()<br ALIGN="LEFT"/>clear_output()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>closeEvent_handler(event)<br ALIGN="LEFT"/>compare_qemu_snapshots()<br ALIGN="LEFT"/>configure_api_repositories()<br ALIGN="LEFT"/>create_data_table_view(model)<br ALIGN="LEFT"/>create_help_button(help_topic)<br ALIGN="LEFT"/>create_menu_bar()<br ALIGN="LEFT"/>create_new_file()<br ALIGN="LEFT"/>create_new_plugin(plugin_type)<br ALIGN="LEFT"/>create_qemu_snapshot()<br ALIGN="LEFT"/>create_quick_setup_wizard_page()<br ALIGN="LEFT"/>create_toolbar()<br ALIGN="LEFT"/>delete_report(row)<br ALIGN="LEFT"/>demo_threaded_operation()<br ALIGN="LEFT"/>deploy_adobe_licensex()<br ALIGN="LEFT"/>edit_patch(row)<br ALIGN="LEFT"/>edit_plugin_file(path)<br ALIGN="LEFT"/>edit_plugin_from_list(list_widget)<br ALIGN="LEFT"/>execute_adobe_action()<br ALIGN="LEFT"/>execute_autonomous_task(task_type, request)<br ALIGN="LEFT"/>execute_qemu_command()<br ALIGN="LEFT"/>explain_current_code()<br ALIGN="LEFT"/>export_analysis_results()<br ALIGN="LEFT"/>export_patches()<br ALIGN="LEFT"/>export_report(row)<br ALIGN="LEFT"/>extract_binary_info(binary_path)<br ALIGN="LEFT"/>extract_icon_from_binary()<br ALIGN="LEFT"/>extract_patterns_from_binary(binary_path)<br ALIGN="LEFT"/>filter_plugin_list(list_widget, search_text)<br ALIGN="LEFT"/>find_plugin_file(plugin_name)<br ALIGN="LEFT"/>fine_tune_model()<br ALIGN="LEFT"/>generate_ai_script_from_editor()<br ALIGN="LEFT"/>generate_exploit_strategy()<br ALIGN="LEFT"/>generate_key()<br ALIGN="LEFT"/>generate_report()<br ALIGN="LEFT"/>get_ai_code_suggestions()<br ALIGN="LEFT"/>get_ai_conversation_history()<br ALIGN="LEFT"/>get_help_content_for_topic(topic)<br ALIGN="LEFT"/>get_plugin_icon(plugin_type, plugin_name)<br ALIGN="LEFT"/>get_plugins_by_type(plugin_type)<br ALIGN="LEFT"/>handle_deep_analysis_mode(text)<br ALIGN="LEFT"/>handle_generate_key()<br ALIGN="LEFT"/>handle_ghidra_analysis_mode(text)<br ALIGN="LEFT"/>handle_log_user_question(title, message)<br ALIGN="LEFT"/>handle_patch_mode_selection(text)<br ALIGN="LEFT"/>handle_preset_query(query_text)<br ALIGN="LEFT"/>handle_results_action(text)<br ALIGN="LEFT"/>handle_set_keygen_name(text)<br ALIGN="LEFT"/>handle_set_keygen_version(text)<br ALIGN="LEFT"/>handle_switch_tab(index)<br ALIGN="LEFT"/>import_custom_model()<br ALIGN="LEFT"/>import_plugin(plugin_type)<br ALIGN="LEFT"/>import_report()<br ALIGN="LEFT"/>install_dependencies(dependencies)<br ALIGN="LEFT"/>launch_network_tool()<br ALIGN="LEFT"/>launch_protocol_tool()<br ALIGN="LEFT"/>load_analysis_config()<br ALIGN="LEFT"/>load_available_plugins()<br ALIGN="LEFT"/>load_binary(path)<br ALIGN="LEFT"/>load_ghidra_results()<br ALIGN="LEFT"/>load_recent_file(item)<br ALIGN="LEFT"/>log_message(message: str, level: str): None<br ALIGN="LEFT"/>log_to_file(message)<br ALIGN="LEFT"/>on_analysis_type_changed(index)<br ALIGN="LEFT"/>on_hex_data_modified(offset, data)<br ALIGN="LEFT"/>on_hex_selection_changed(start, end)<br ALIGN="LEFT"/>on_plugin_created(plugin_data)<br ALIGN="LEFT"/>on_preferences_changed()<br ALIGN="LEFT"/>on_theme_changed(theme_name)<br ALIGN="LEFT"/>open_ai_coding_assistant()<br ALIGN="LEFT"/>open_analyze_tab()<br ALIGN="LEFT"/>open_code_modification_dialog()<br ALIGN="LEFT"/>open_distributed_config()<br ALIGN="LEFT"/>open_file_in_editor(item)<br ALIGN="LEFT"/>open_gguf_model_manager()<br ALIGN="LEFT"/>open_hex_viewer_tab()<br ALIGN="LEFT"/>open_llm_config_dialog()<br ALIGN="LEFT"/>open_model_finetuning()<br ALIGN="LEFT"/>open_network_tab()<br ALIGN="LEFT"/>open_patching_tab()<br ALIGN="LEFT"/>open_plugin_documentation(topic)<br ALIGN="LEFT"/>open_plugin_settings()<br ALIGN="LEFT"/>open_plugins_tab()<br ALIGN="LEFT"/>open_project_folder()<br ALIGN="LEFT"/>open_visual_patch_editor()<br ALIGN="LEFT"/>optimize_memory_usage_ui()<br ALIGN="LEFT"/>populate_plugin_list_with_details(list_widget, plugin_type)<br ALIGN="LEFT"/>preview_patch()<br ALIGN="LEFT"/>refresh_all_plugin_lists()<br ALIGN="LEFT"/>refresh_dashboard_ui(binary_info)<br ALIGN="LEFT"/>refresh_patch_list()<br ALIGN="LEFT"/>refresh_project_files()<br ALIGN="LEFT"/>refresh_reports_list()<br ALIGN="LEFT"/>register_hex_viewer_menu(_menubar)<br ALIGN="LEFT"/>remove_program()<br ALIGN="LEFT"/>replace_last_chat_message(old_text, new_text)<br ALIGN="LEFT"/>reset_ai_agent()<br ALIGN="LEFT"/>restore_qemu_snapshot()<br ALIGN="LEFT"/>revert_all_patches()<br ALIGN="LEFT"/>revert_patch(row)<br ALIGN="LEFT"/>run_adobe_licensex_manually()<br ALIGN="LEFT"/>run_analysis()<br ALIGN="LEFT"/>run_anti_debug_detection()<br ALIGN="LEFT"/>run_automated_patch_agent()<br ALIGN="LEFT"/>run_autonomous_crack()<br ALIGN="LEFT"/>run_autonomous_patching()<br ALIGN="LEFT"/>run_binary_similarity_search()<br ALIGN="LEFT"/>run_checksum_detection()<br ALIGN="LEFT"/>run_commercial_protection_detection()<br ALIGN="LEFT"/>run_commercial_protection_scan()<br ALIGN="LEFT"/>run_concolic_license_bypass()<br ALIGN="LEFT"/>run_custom_plugin(plugin_name)<br ALIGN="LEFT"/>run_custom_plugin_from_list(list_widget)<br ALIGN="LEFT"/>run_deep_license_analysis()<br ALIGN="LEFT"/>run_deep_runtime_monitoring()<br ALIGN="LEFT"/>run_detect_packing()<br ALIGN="LEFT"/>run_external_command()<br ALIGN="LEFT"/>run_feature_extraction()<br ALIGN="LEFT"/>run_frida_plugin_from_file(plugin_path)<br ALIGN="LEFT"/>run_frida_plugin_from_list(list_widget)<br ALIGN="LEFT"/>run_full_autonomous_mode()<br ALIGN="LEFT"/>run_ghidra_analysis_gui()<br ALIGN="LEFT"/>run_ghidra_plugin_from_file(plugin_path)<br ALIGN="LEFT"/>run_ghidra_plugin_from_list(list_widget)<br ALIGN="LEFT"/>run_hardware_dongle_detection()<br ALIGN="LEFT"/>run_memory_analysis()<br ALIGN="LEFT"/>run_memory_keyword_scan()<br ALIGN="LEFT"/>run_ml_vulnerability_prediction()<br ALIGN="LEFT"/>run_network_analysis()<br ALIGN="LEFT"/>run_packing_detection()<br ALIGN="LEFT"/>run_patch_test()<br ALIGN="LEFT"/>run_patching()<br ALIGN="LEFT"/>run_plugin(plugin_name)<br ALIGN="LEFT"/>run_plugin_in_sandbox(plugin_path, function_name)<br ALIGN="LEFT"/>run_plugin_remotely(plugin_info)<br ALIGN="LEFT"/>run_report_generation()<br ALIGN="LEFT"/>run_rop_gadget_finder()<br ALIGN="LEFT"/>run_selected_analysis(analysis_type)<br ALIGN="LEFT"/>run_selected_patching(patch_type)<br ALIGN="LEFT"/>run_self_healing_detection()<br ALIGN="LEFT"/>run_simulate_patch()<br ALIGN="LEFT"/>run_static_vulnerability_scan()<br ALIGN="LEFT"/>run_tpm_bypass()<br ALIGN="LEFT"/>run_tpm_detection()<br ALIGN="LEFT"/>run_vm_bypass()<br ALIGN="LEFT"/>run_vm_detection()<br ALIGN="LEFT"/>run_windows_activator()<br ALIGN="LEFT"/>save_ai_session()<br ALIGN="LEFT"/>save_analysis_config()<br ALIGN="LEFT"/>save_analysis_results()<br ALIGN="LEFT"/>save_config()<br ALIGN="LEFT"/>save_current_file()<br ALIGN="LEFT"/>save_logs()<br ALIGN="LEFT"/>scan_protectors()<br ALIGN="LEFT"/>select_binary()<br ALIGN="LEFT"/>select_binary_tool_file()<br ALIGN="LEFT"/>select_program()<br ALIGN="LEFT"/>send_ai_chat_message()<br ALIGN="LEFT"/>send_to_assistant()<br ALIGN="LEFT"/>send_to_model()<br ALIGN="LEFT"/>set_assistant_status(text)<br ALIGN="LEFT"/>set_progress_value(value)<br ALIGN="LEFT"/>set_status_message(text)<br ALIGN="LEFT"/>set_widget_size_policy(widget, horizontal_policy, vertical_policy)<br ALIGN="LEFT"/>setup_ai_assistant_tab()<br ALIGN="LEFT"/>setup_ai_coding_assistant_tab(tab_widget)<br ALIGN="LEFT"/>setup_analysis_tab()<br ALIGN="LEFT"/>setup_assistant_logs_tab()<br ALIGN="LEFT"/>setup_assistant_tab()<br ALIGN="LEFT"/>setup_binary_tools_tab()<br ALIGN="LEFT"/>setup_dashboard_content()<br ALIGN="LEFT"/>setup_dashboard_tab()<br ALIGN="LEFT"/>setup_hex_viewer_tab()<br ALIGN="LEFT"/>setup_netanalysis_emulation_tab()<br ALIGN="LEFT"/>setup_network_sim_tab()<br ALIGN="LEFT"/>setup_patching_exploitation_tab()<br ALIGN="LEFT"/>setup_persistent_logging_ui()<br ALIGN="LEFT"/>setup_plugins_hub_tab()<br ALIGN="LEFT"/>setup_project_dashboard_tab()<br ALIGN="LEFT"/>setup_settings_tab()<br ALIGN="LEFT"/>setup_tools_plugins_tab()<br ALIGN="LEFT"/>show_about_dialog()<br ALIGN="LEFT"/>show_ai_performance_stats()<br ALIGN="LEFT"/>show_assistant_response(response)<br ALIGN="LEFT"/>show_current_binary_in_hex(read_only)<br ALIGN="LEFT"/>show_documentation()<br ALIGN="LEFT"/>show_editable_hex_viewer()<br ALIGN="LEFT"/>show_embedded_help(topic)<br ALIGN="LEFT"/>show_enhanced_hex_viewer(file_path, read_only)<br ALIGN="LEFT"/>show_plugin_manager()<br ALIGN="LEFT"/>show_preferences_dialog()<br ALIGN="LEFT"/>show_progress_dialog(title, label_text, maximum)<br ALIGN="LEFT"/>show_tutorials()<br ALIGN="LEFT"/>start_guided_wizard()<br ALIGN="LEFT"/>start_license_server()<br ALIGN="LEFT"/>start_network_capture()<br ALIGN="LEFT"/>start_network_scan()<br ALIGN="LEFT"/>start_packet_capture()<br ALIGN="LEFT"/>start_protocol_analysis()<br ALIGN="LEFT"/>stop_license_server()<br ALIGN="LEFT"/>stop_network_capture()<br ALIGN="LEFT"/>switch_binary_tool(tool_index)<br ALIGN="LEFT"/>test_license_server()<br ALIGN="LEFT"/>test_remote_execution()<br ALIGN="LEFT"/>test_sandbox_execution()<br ALIGN="LEFT"/>thread_safe_confirmation(callback)<br ALIGN="LEFT"/>toggle_dark_mode()<br ALIGN="LEFT"/>toggle_dark_mode_from_checkbox(state)<br ALIGN="LEFT"/>uninstall_adobe_licensex()<br ALIGN="LEFT"/>update_protocol_tool_description(tool)<br ALIGN="LEFT"/>use_preset_prompt(prompt_text)<br ALIGN="LEFT"/>verify_hash()<br ALIGN="LEFT"/>verify_patch_results()<br ALIGN="LEFT"/>view_adobe_licensex_log()<br ALIGN="LEFT"/>view_cfg()<br ALIGN="LEFT"/>view_report(row)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.main.IntellicrackCLI" [color="black", fontcolor="black", label=<{IntellicrackCLI|args<br ALIGN="LEFT"/>binary_path<br ALIGN="LEFT"/>dist_manager<br ALIGN="LEFT"/>gpu : NoneType<br ALIGN="LEFT"/>memory_baseline<br ALIGN="LEFT"/>memory_tracer : NoneType<br ALIGN="LEFT"/>performance_stats : dict<br ALIGN="LEFT"/>profiler : NoneType, Profile<br ALIGN="LEFT"/>quiet<br ALIGN="LEFT"/>results : dict<br ALIGN="LEFT"/>verbose<br ALIGN="LEFT"/>|enable_debug_mode()<br ALIGN="LEFT"/>export_gui_format(output_path)<br ALIGN="LEFT"/>finalize_analysis()<br ALIGN="LEFT"/>format_text_output()<br ALIGN="LEFT"/>generate_output()<br ALIGN="LEFT"/>generate_visual_cfg(output_path)<br ALIGN="LEFT"/>init_components()<br ALIGN="LEFT"/>launch_gui_with_results()<br ALIGN="LEFT"/>launch_hex_editor()<br ALIGN="LEFT"/>load_custom_config(config_path)<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>run_advanced_features()<br ALIGN="LEFT"/>run_bypass_operations()<br ALIGN="LEFT"/>run_cfg_analysis_detailed()<br ALIGN="LEFT"/>run_core_analysis()<br ALIGN="LEFT"/>run_exploitation_analysis()<br ALIGN="LEFT"/>run_external_tools()<br ALIGN="LEFT"/>run_ml_analysis()<br ALIGN="LEFT"/>run_multi_format_analysis_tool()<br ALIGN="LEFT"/>run_network_analysis()<br ALIGN="LEFT"/>run_patching_operations()<br ALIGN="LEFT"/>run_protection_analysis()<br ALIGN="LEFT"/>run_rop_gadget_analysis()<br ALIGN="LEFT"/>run_vulnerability_detection()<br ALIGN="LEFT"/>run_vulnerability_scan_detailed()<br ALIGN="LEFT"/>setup_adobe_injection()<br ALIGN="LEFT"/>setup_cloud_license_hooking()<br ALIGN="LEFT"/>setup_incremental_analysis()<br ALIGN="LEFT"/>setup_license_server_emulation()<br ALIGN="LEFT"/>setup_memory_optimized_loading()<br ALIGN="LEFT"/>setup_output()<br ALIGN="LEFT"/>setup_windows_activation()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.config_manager.IntellicrackConfig" [color="black", fontcolor="black", label=<{IntellicrackConfig|cache_dir<br ALIGN="LEFT"/>config_dir<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>logs_dir<br ALIGN="LEFT"/>output_dir<br ALIGN="LEFT"/>|export_config(file_path: Union[str, Path]): bool<br ALIGN="LEFT"/>get(key: str, default: Any): Any<br ALIGN="LEFT"/>get_cache_dir(): Path<br ALIGN="LEFT"/>get_logs_dir(): Path<br ALIGN="LEFT"/>get_output_dir(): Path<br ALIGN="LEFT"/>get_tool_path(tool_name: str): Optional[str]<br ALIGN="LEFT"/>import_config(file_path: Union[str, Path]): bool<br ALIGN="LEFT"/>is_tool_available(tool_name: str): bool<br ALIGN="LEFT"/>refresh_tool_discovery()<br ALIGN="LEFT"/>set(key: str, value: Any, save: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.config_manager_clean.IntellicrackConfig" [color="black", fontcolor="black", label=<{IntellicrackConfig|cache_dir<br ALIGN="LEFT"/>config_dir<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>logs_dir<br ALIGN="LEFT"/>output_dir<br ALIGN="LEFT"/>|get(key: str, default: Any): Any<br ALIGN="LEFT"/>get_cache_dir(): Path<br ALIGN="LEFT"/>get_logs_dir(): Path<br ALIGN="LEFT"/>get_output_dir(): Path<br ALIGN="LEFT"/>set(key: str, value: Any, save: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.intellicrack_hex_protection_integration.IntellicrackHexProtectionIntegration" [color="black", fontcolor="black", label=<{IntellicrackHexProtectionIntegration|engine_process : NoneType<br ALIGN="LEFT"/>hex_widget : NoneType<br ALIGN="LEFT"/>offset_requested<br ALIGN="LEFT"/>protection_detector<br ALIGN="LEFT"/>section_requested<br ALIGN="LEFT"/>|compare_features(): Dict[str, Dict[str, bool]]<br ALIGN="LEFT"/>get_section_offsets(file_path: str): Dict[str, int]<br ALIGN="LEFT"/>open_in_protection_viewer(file_path: str, offset: Optional[int])<br ALIGN="LEFT"/>sync_offset_from_protection_viewer(offset: int)<br ALIGN="LEFT"/>sync_offset_to_protection_viewer(offset: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_window.IntellicrackMainWindow" [color="black", fontcolor="black", label=<{IntellicrackMainWindow|ai_assistant<br ALIGN="LEFT"/>ai_assistant_widget<br ALIGN="LEFT"/>analysis_orchestrator : AnalysisResultOrchestrator<br ALIGN="LEFT"/>analysis_output : NoneType<br ALIGN="LEFT"/>analyze_button<br ALIGN="LEFT"/>analyze_results : List[str]<br ALIGN="LEFT"/>auto_save_results_cb : NoneType<br ALIGN="LEFT"/>binary_analyzer<br ALIGN="LEFT"/>binary_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>binary_path : Optional[str]<br ALIGN="LEFT"/>browse_button<br ALIGN="LEFT"/>clear_output<br ALIGN="LEFT"/>clear_results_button : NoneType<br ALIGN="LEFT"/>entropy_analysis_cb : NoneType<br ALIGN="LEFT"/>export_analysis_cb : NoneType<br ALIGN="LEFT"/>export_results_button : NoneType<br ALIGN="LEFT"/>file_path_label<br ALIGN="LEFT"/>generate_report_button<br ALIGN="LEFT"/>icp_widget<br ALIGN="LEFT"/>import_analysis_cb : NoneType<br ALIGN="LEFT"/>info_display : NoneType<br ALIGN="LEFT"/>llm_handler : LLMHandler<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>protection_analysis_button<br ALIGN="LEFT"/>protection_widget<br ALIGN="LEFT"/>report_handler : ReportGenerationHandler<br ALIGN="LEFT"/>results_display : NoneType<br ALIGN="LEFT"/>scan_vulnerabilities_button<br ALIGN="LEFT"/>script_handler : ScriptGenerationHandler<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>update_output<br ALIGN="LEFT"/>update_progress<br ALIGN="LEFT"/>update_status<br ALIGN="LEFT"/>verbose_logging_cb : NoneType<br ALIGN="LEFT"/>vulnerability_engine<br ALIGN="LEFT"/>vulnerability_scan_cb : NoneType<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.project_manager.IntellicrackProject" [color="black", fontcolor="black", label=<{IntellicrackProject|analysis_results : dict<br ALIGN="LEFT"/>binaries : list<br ALIGN="LEFT"/>created_time : datetime<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>modified_time : datetime<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>notes : str<br ALIGN="LEFT"/>path : str<br ALIGN="LEFT"/>reports : list<br ALIGN="LEFT"/>scripts : list<br ALIGN="LEFT"/>settings : dict<br ALIGN="LEFT"/>tags : list<br ALIGN="LEFT"/>|add_analysis_result(binary_name: str, analysis_data: Dict[str, Any]): None<br ALIGN="LEFT"/>add_binary(binary_path: str): bool<br ALIGN="LEFT"/>from_dict(data: Dict[str, Any]): 'IntellicrackProject'<br ALIGN="LEFT"/>get_analysis_count(): int<br ALIGN="LEFT"/>get_binary_count(): int<br ALIGN="LEFT"/>get_project_size(): int<br ALIGN="LEFT"/>remove_binary(binary_path: str): bool<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_core.IntellicrackProtectionCore" [color="black", fontcolor="black", label=<{IntellicrackProtectionCore|PROTECTION_BYPASSES : dict<br ALIGN="LEFT"/>engine_path : Optional[str]<br ALIGN="LEFT"/>icp_backend<br ALIGN="LEFT"/>|analyze_directory(directory: str, recursive: bool): List[ProtectionAnalysis]<br ALIGN="LEFT"/>detect_protections(file_path: str): ProtectionAnalysis<br ALIGN="LEFT"/>export_results(analysis: ProtectionAnalysis, output_format: str): str<br ALIGN="LEFT"/>get_summary(analysis: ProtectionAnalysis): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.intellicrack_protection_widget.IntellicrackProtectionWidget" [color="black", fontcolor="black", label=<{IntellicrackProtectionWidget|ai_assistant<br ALIGN="LEFT"/>ai_reasoning_btn<br ALIGN="LEFT"/>ai_reasoning_text<br ALIGN="LEFT"/>ai_tools<br ALIGN="LEFT"/>analysis_requested<br ALIGN="LEFT"/>analysis_thread : Optional[ProtectionAnalysisThread]<br ALIGN="LEFT"/>analyze_btn<br ALIGN="LEFT"/>ask_ai_btn<br ALIGN="LEFT"/>bypass_text<br ALIGN="LEFT"/>current_analysis : NoneType, Optional[ProtectionAnalysis]<br ALIGN="LEFT"/>details_tabs<br ALIGN="LEFT"/>detection_tree<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>protection_detected<br ALIGN="LEFT"/>raw_output_text<br ALIGN="LEFT"/>search_license_btn<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>summary_text<br ALIGN="LEFT"/>tech_details_text<br ALIGN="LEFT"/>|analyze_file(file_path: str)<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>display_ai_reasoning(reasoning_result: dict)<br ALIGN="LEFT"/>display_bypass_recommendations(detection)<br ALIGN="LEFT"/>display_results(analysis: ProtectionAnalysis)<br ALIGN="LEFT"/>display_summary(analysis: ProtectionAnalysis)<br ALIGN="LEFT"/>display_technical_details(analysis: ProtectionAnalysis)<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>on_ai_reasoning_clicked()<br ALIGN="LEFT"/>on_analysis_complete(analysis: ProtectionAnalysis)<br ALIGN="LEFT"/>on_analysis_error(error_msg: str)<br ALIGN="LEFT"/>on_analysis_progress(message: str)<br ALIGN="LEFT"/>on_analyze_clicked()<br ALIGN="LEFT"/>on_ask_ai_clicked()<br ALIGN="LEFT"/>on_detection_selected()<br ALIGN="LEFT"/>on_export_clicked()<br ALIGN="LEFT"/>search_license_files()<br ALIGN="LEFT"/>set_binary_path(file_path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [color="black", fontcolor="black", label=<{IntellicrackShell|analysis_results : dict<br ALIGN="LEFT"/>config : NoneType<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>current_binary : NoneType, str<br ALIGN="LEFT"/>histfile<br ALIGN="LEFT"/>history : list<br ALIGN="LEFT"/>intro : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_manager<br ALIGN="LEFT"/>prompt : str<br ALIGN="LEFT"/>|create_custom_progress_column(): Optional[ProgressColumn]<br ALIGN="LEFT"/>default(line)<br ALIGN="LEFT"/>display_analysis_columns(): None<br ALIGN="LEFT"/>display_rich_output(message: str, style: str): None<br ALIGN="LEFT"/>do_ai(arg)<br ALIGN="LEFT"/>do_analyze(arg)<br ALIGN="LEFT"/>do_ask(arg)<br ALIGN="LEFT"/>do_batch(arg)<br ALIGN="LEFT"/>do_chart(arg)<br ALIGN="LEFT"/>do_clear(arg)<br ALIGN="LEFT"/>do_compare(arg)<br ALIGN="LEFT"/>do_config(arg)<br ALIGN="LEFT"/>do_dashboard(arg)<br ALIGN="LEFT"/>do_exit(arg)<br ALIGN="LEFT"/>do_export(arg)<br ALIGN="LEFT"/>do_formats(arg)<br ALIGN="LEFT"/>do_graph(arg)<br ALIGN="LEFT"/>do_hex(arg)<br ALIGN="LEFT"/>do_history(arg)<br ALIGN="LEFT"/>do_load(arg)<br ALIGN="LEFT"/>do_monitor(arg)<br ALIGN="LEFT"/>do_patch(arg)<br ALIGN="LEFT"/>do_plugin(arg)<br ALIGN="LEFT"/>do_project(arg)<br ALIGN="LEFT"/>do_quit(arg)<br ALIGN="LEFT"/>do_report(arg)<br ALIGN="LEFT"/>do_script(arg)<br ALIGN="LEFT"/>do_search(arg)<br ALIGN="LEFT"/>do_show(arg)<br ALIGN="LEFT"/>do_stats(arg)<br ALIGN="LEFT"/>do_status(arg)<br ALIGN="LEFT"/>do_tutorial(arg)<br ALIGN="LEFT"/>do_visualize(arg)<br ALIGN="LEFT"/>do_workspace(arg)<br ALIGN="LEFT"/><I>emptyline</I>()<br ALIGN="LEFT"/>error(msg)<br ALIGN="LEFT"/>info(msg)<br ALIGN="LEFT"/>precmd(line)<br ALIGN="LEFT"/>save_history()<br ALIGN="LEFT"/>setup_readline()<br ALIGN="LEFT"/>show_analysis_layout(): None<br ALIGN="LEFT"/>show_status_operation(message: str, operation_func)<br ALIGN="LEFT"/>show_syntax_highlighted_code(code: str, language: str): None<br ALIGN="LEFT"/>success(msg)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [color="black", fontcolor="black", label=<{IntellicrackcoreEngine|analysis_coordinator<br ALIGN="LEFT"/>api_handlers : dict<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>config_manager<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>logger<br ALIGN="LEFT"/>logging_manager<br ALIGN="LEFT"/>plugin_manager<br ALIGN="LEFT"/>resource_manager<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>startup_time : Optional[datetime]<br ALIGN="LEFT"/>workflow_engine<br ALIGN="LEFT"/>|process_api_request(method: str, request: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" [color="black", fontcolor="black", label=<{IntelligentCodeModifier|analyzer<br ALIGN="LEFT"/>backup_directory<br ALIGN="LEFT"/>backup_enabled : bool<br ALIGN="LEFT"/>confidence_threshold : float<br ALIGN="LEFT"/>diff_generator<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>max_context_files : int<br ALIGN="LEFT"/>modification_history : List[CodeChange]<br ALIGN="LEFT"/>pending_changes : Dict[str, CodeChange]<br ALIGN="LEFT"/>project_context : Dict[str, CodeContext], dict<br ALIGN="LEFT"/>|analyze_modification_request(request: ModificationRequest): List[CodeChange]<br ALIGN="LEFT"/>apply_changes(change_ids: List[str], create_backup: bool): Dict[str, Any]<br ALIGN="LEFT"/>create_modification_request(description: str, target_files: List[str], requirements: List[str], constraints: List[str], context_files: List[str]): ModificationRequest<br ALIGN="LEFT"/>gather_project_context(project_root: str, target_files: List[str]): Dict[str, CodeContext]<br ALIGN="LEFT"/>get_modification_history(limit: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_pending_changes(): List[Dict[str, Any]]<br ALIGN="LEFT"/>preview_changes(change_ids: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>reject_changes(change_ids: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.IntelligentPatcher" [color="black", fontcolor="black", label=<{IntelligentPatcher|analyzer<br ALIGN="LEFT"/>found_patterns : Dict[str, List[int]]<br ALIGN="LEFT"/>|calculate_replacement_confidence(offset: int, pattern: PatchPattern): float<br ALIGN="LEFT"/>verify_context(offset: int, pattern: PatchPattern): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.IntentMismatch" [color="black", fontcolor="black", label=<{IntentMismatch|actual_implementation : str<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>evidence : Dict[str, Any]<br ALIGN="LEFT"/>expected_intent<br ALIGN="LEFT"/>function_name : str<br ALIGN="LEFT"/>mismatch_id : str<br ALIGN="LEFT"/>mismatch_type : str<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>suggested_fixes : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.traffic_interception_engine.InterceptedPacket" [color="black", fontcolor="black", label=<{InterceptedPacket|data : bytes<br ALIGN="LEFT"/>dest_ip : str<br ALIGN="LEFT"/>dest_port : int<br ALIGN="LEFT"/>flags : Dict[str, bool]<br ALIGN="LEFT"/>packet_size : int<br ALIGN="LEFT"/>protocol : str<br ALIGN="LEFT"/>source_ip : str<br ALIGN="LEFT"/>source_port : int<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.InterceptorConfig" [color="black", fontcolor="black", label=<{InterceptorConfig|ca_cert_path : str<br ALIGN="LEFT"/>ca_key_path : str<br ALIGN="LEFT"/>cache_ttl : int<br ALIGN="LEFT"/>enable_ssl_interception : bool<br ALIGN="LEFT"/>fallback_mode : bool<br ALIGN="LEFT"/>listen_host : str<br ALIGN="LEFT"/>listen_port : int<br ALIGN="LEFT"/>log_level : str<br ALIGN="LEFT"/>max_cache_size : int<br ALIGN="LEFT"/>request_delay_max : float<br ALIGN="LEFT"/>request_delay_min : float<br ALIGN="LEFT"/>stealth_mode : bool<br ALIGN="LEFT"/>upstream_timeout : int<br ALIGN="LEFT"/>user_agents : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.JSONFormatter" [color="black", fontcolor="black", label=<{JSONFormatter|<br ALIGN="LEFT"/>|format(record)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.syntax_highlighters.JavaScriptHighlighter" [color="black", fontcolor="black", label=<{JavaScriptHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.JavaScriptSyntaxHighlighter" [color="black", fontcolor="black", label=<{JavaScriptSyntaxHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.kernel_injection.KernelInjector" [color="black", fontcolor="black", label=<{KernelInjector|IOCTL_INJECT_DLL : int<br ALIGN="LEFT"/>advapi32 : WinDLL<br ALIGN="LEFT"/>driver_handle : NoneType<br ALIGN="LEFT"/>driver_path : NoneType<br ALIGN="LEFT"/>kernel32 : NoneType, WinDLL<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>service_name : str<br ALIGN="LEFT"/>|inject_kernel_mode(target_pid: int, dll_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [color="black", fontcolor="black", label=<{KeygenDialog|algorithm_combo<br ALIGN="LEFT"/>analysis_display : NoneType<br ALIGN="LEFT"/>analyze_keys_btn : NoneType<br ALIGN="LEFT"/>batch_algorithm_combo : NoneType<br ALIGN="LEFT"/>batch_clear_btn : NoneType<br ALIGN="LEFT"/>batch_count_spin : NoneType<br ALIGN="LEFT"/>batch_export_btn : NoneType<br ALIGN="LEFT"/>batch_format_combo : NoneType<br ALIGN="LEFT"/>batch_generate_btn : NoneType<br ALIGN="LEFT"/>batch_progress : NoneType<br ALIGN="LEFT"/>batch_stop_btn : NoneType<br ALIGN="LEFT"/>batch_table : NoneType<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>copy_btn : NoneType<br ALIGN="LEFT"/>current_analysis : dict<br ALIGN="LEFT"/>existing_keys_input : NoneType<br ALIGN="LEFT"/>format_combo<br ALIGN="LEFT"/>generate_btn : NoneType<br ALIGN="LEFT"/>generated_keys : list<br ALIGN="LEFT"/>key_analysis_display : NoneType<br ALIGN="LEFT"/>key_display : NoneType<br ALIGN="LEFT"/>last_generated_key : str<br ALIGN="LEFT"/>last_generated_result : dict<br ALIGN="LEFT"/>length_spin<br ALIGN="LEFT"/>results_display : NoneType<br ALIGN="LEFT"/>save_single_btn : NoneType<br ALIGN="LEFT"/>tabs<br ALIGN="LEFT"/>validation_check<br ALIGN="LEFT"/>worker : NoneType<br ALIGN="LEFT"/>|analyze_binary()<br ALIGN="LEFT"/>analyze_existing_keys()<br ALIGN="LEFT"/>auto_analyze_binary()<br ALIGN="LEFT"/>clear_batch_results()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>copy_key()<br ALIGN="LEFT"/>export_batch_keys()<br ALIGN="LEFT"/>format_analysis_results(result)<br ALIGN="LEFT"/>format_single_key_results(result)<br ALIGN="LEFT"/>generate_batch_keys()<br ALIGN="LEFT"/>generate_single_key()<br ALIGN="LEFT"/>on_analysis_completed(result)<br ALIGN="LEFT"/>on_batch_completed(keys)<br ALIGN="LEFT"/>on_batch_progress(current, total)<br ALIGN="LEFT"/>on_binary_path_changed(text)<br ALIGN="LEFT"/>on_error(error_msg)<br ALIGN="LEFT"/>on_single_key_generated(result)<br ALIGN="LEFT"/>save_single_key()<br ALIGN="LEFT"/>setup_analysis_tab()<br ALIGN="LEFT"/>setup_batch_tab()<br ALIGN="LEFT"/>setup_footer(layout)<br ALIGN="LEFT"/>setup_header(layout)<br ALIGN="LEFT"/>setup_management_tab()<br ALIGN="LEFT"/>setup_single_tab()<br ALIGN="LEFT"/>setup_tabs(layout)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>stop_batch_generation()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenWorker" [color="black", fontcolor="black", label=<{KeygenWorker|batch_completed<br ALIGN="LEFT"/>batch_progress<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>key_generated<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>operation : str<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.KnowledgeManager" [color="black", fontcolor="black", label=<{KnowledgeManager|access_patterns : Dict[str, int]<br ALIGN="LEFT"/>knowledge_graph : Dict[str, Set[str]]<br ALIGN="LEFT"/>shared_knowledge : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>|get_related_knowledge(category: str, requesting_agent: str): Dict[str, Any]<br ALIGN="LEFT"/>retrieve_knowledge(category: str, key: str, requesting_agent: str): Optional[Any]<br ALIGN="LEFT"/>store_knowledge(category: str, key: str, value: Any, source_agent: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMBackend" [color="black", fontcolor="black", label=<{LLMBackend|config<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>tools : List[Dict], list<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>register_tools(tools: List[Dict])<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMConfig" [color="black", fontcolor="black", label=<{LLMConfig|api_base : Optional[str]<br ALIGN="LEFT"/>api_key : Optional[str]<br ALIGN="LEFT"/>context_length : int<br ALIGN="LEFT"/>custom_params : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>device : Optional[str]<br ALIGN="LEFT"/>max_tokens : int<br ALIGN="LEFT"/>model : Optional[str]<br ALIGN="LEFT"/>model_name : Optional[str]<br ALIGN="LEFT"/>model_path : Optional[str]<br ALIGN="LEFT"/>provider<br ALIGN="LEFT"/>quantization : Optional[str]<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>tools_enabled : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.llm_config_dialog.LLMConfigDialog" [color="black", fontcolor="black", label=<{LLMConfigDialog|anthropic_api_key : NoneType<br ALIGN="LEFT"/>anthropic_max_tokens : NoneType<br ALIGN="LEFT"/>anthropic_model : NoneType<br ALIGN="LEFT"/>anthropic_temp : NoneType<br ALIGN="LEFT"/>anthropic_tools : NoneType<br ALIGN="LEFT"/>config_manager : NoneType<br ALIGN="LEFT"/>current_configs : dict<br ALIGN="LEFT"/>gguf_context : NoneType<br ALIGN="LEFT"/>gguf_max_tokens : NoneType<br ALIGN="LEFT"/>gguf_model_name : NoneType<br ALIGN="LEFT"/>gguf_model_path : NoneType<br ALIGN="LEFT"/>gguf_temp : NoneType<br ALIGN="LEFT"/>gguf_tools : NoneType<br ALIGN="LEFT"/>gptq_device : NoneType<br ALIGN="LEFT"/>gptq_max_tokens : NoneType<br ALIGN="LEFT"/>gptq_model_name : NoneType<br ALIGN="LEFT"/>gptq_model_path : NoneType<br ALIGN="LEFT"/>gptq_temp : NoneType<br ALIGN="LEFT"/>huggingface_device : NoneType<br ALIGN="LEFT"/>huggingface_max_tokens : NoneType<br ALIGN="LEFT"/>huggingface_model_name : NoneType<br ALIGN="LEFT"/>huggingface_model_path : NoneType<br ALIGN="LEFT"/>huggingface_temp : NoneType<br ALIGN="LEFT"/>llm_manager : NoneType<br ALIGN="LEFT"/>lora_adapter_name : NoneType<br ALIGN="LEFT"/>lora_adapter_path : NoneType<br ALIGN="LEFT"/>lora_adapter_type : NoneType<br ALIGN="LEFT"/>lora_alpha : NoneType<br ALIGN="LEFT"/>lora_base_model : NoneType<br ALIGN="LEFT"/>lora_dropout : NoneType<br ALIGN="LEFT"/>lora_merge_adapter : NoneType<br ALIGN="LEFT"/>lora_rank : NoneType<br ALIGN="LEFT"/>models_list<br ALIGN="LEFT"/>ollama_max_tokens : NoneType<br ALIGN="LEFT"/>ollama_model : NoneType<br ALIGN="LEFT"/>ollama_temp : NoneType<br ALIGN="LEFT"/>ollama_url : NoneType<br ALIGN="LEFT"/>onnx_max_tokens : NoneType<br ALIGN="LEFT"/>onnx_model_name : NoneType<br ALIGN="LEFT"/>onnx_model_path : NoneType<br ALIGN="LEFT"/>onnx_providers : NoneType<br ALIGN="LEFT"/>onnx_temp : NoneType<br ALIGN="LEFT"/>openai_api_key : NoneType<br ALIGN="LEFT"/>openai_base_url : NoneType<br ALIGN="LEFT"/>openai_max_tokens : NoneType<br ALIGN="LEFT"/>openai_model : NoneType<br ALIGN="LEFT"/>openai_temp : NoneType<br ALIGN="LEFT"/>openai_tools : NoneType<br ALIGN="LEFT"/>pytorch_device : NoneType<br ALIGN="LEFT"/>pytorch_max_tokens : NoneType<br ALIGN="LEFT"/>pytorch_model_name : NoneType<br ALIGN="LEFT"/>pytorch_model_path : NoneType<br ALIGN="LEFT"/>pytorch_temp : NoneType<br ALIGN="LEFT"/>remove_model_btn<br ALIGN="LEFT"/>safetensors_device : NoneType<br ALIGN="LEFT"/>safetensors_max_tokens : NoneType<br ALIGN="LEFT"/>safetensors_model_name : NoneType<br ALIGN="LEFT"/>safetensors_model_path : NoneType<br ALIGN="LEFT"/>safetensors_temp : NoneType<br ALIGN="LEFT"/>set_active_btn<br ALIGN="LEFT"/>status_text<br ALIGN="LEFT"/>tabs<br ALIGN="LEFT"/>tensorflow_device : NoneType<br ALIGN="LEFT"/>tensorflow_max_tokens : NoneType<br ALIGN="LEFT"/>tensorflow_model_name : NoneType<br ALIGN="LEFT"/>tensorflow_model_path : NoneType<br ALIGN="LEFT"/>tensorflow_temp : NoneType<br ALIGN="LEFT"/>test_model_btn<br ALIGN="LEFT"/>test_progress<br ALIGN="LEFT"/>test_thread : NoneType<br ALIGN="LEFT"/>|add_anthropic_model()<br ALIGN="LEFT"/>add_gguf_model()<br ALIGN="LEFT"/>add_gptq_model()<br ALIGN="LEFT"/>add_huggingface_model()<br ALIGN="LEFT"/>add_lora_adapter()<br ALIGN="LEFT"/>add_ollama_model()<br ALIGN="LEFT"/>add_onnx_model()<br ALIGN="LEFT"/>add_openai_model()<br ALIGN="LEFT"/>add_pytorch_model()<br ALIGN="LEFT"/>add_safetensors_model()<br ALIGN="LEFT"/>add_tensorflow_model()<br ALIGN="LEFT"/>browse_gguf_model()<br ALIGN="LEFT"/>browse_gptq_model()<br ALIGN="LEFT"/>browse_huggingface_model()<br ALIGN="LEFT"/>browse_lora_adapter()<br ALIGN="LEFT"/>browse_onnx_model()<br ALIGN="LEFT"/>browse_pytorch_model()<br ALIGN="LEFT"/>browse_safetensors_model()<br ALIGN="LEFT"/>browse_tensorflow_model()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>create_lora_adapter()<br ALIGN="LEFT"/>load_existing_configs()<br ALIGN="LEFT"/>on_test_complete(success: bool, message: str)<br ALIGN="LEFT"/>on_test_progress(message: str)<br ALIGN="LEFT"/>refresh_lora_models()<br ALIGN="LEFT"/>register_model(model_id: str, config: LLMConfig)<br ALIGN="LEFT"/>remove_model()<br ALIGN="LEFT"/>save_configuration()<br ALIGN="LEFT"/>set_active_model()<br ALIGN="LEFT"/>setup_anthropic_tab()<br ALIGN="LEFT"/>setup_gguf_tab()<br ALIGN="LEFT"/>setup_gptq_tab()<br ALIGN="LEFT"/>setup_huggingface_tab()<br ALIGN="LEFT"/>setup_lora_tab()<br ALIGN="LEFT"/>setup_ollama_tab()<br ALIGN="LEFT"/>setup_onnx_tab()<br ALIGN="LEFT"/>setup_openai_tab()<br ALIGN="LEFT"/>setup_pytorch_tab()<br ALIGN="LEFT"/>setup_safetensors_tab()<br ALIGN="LEFT"/>setup_tensorflow_tab()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>test_anthropic_config()<br ALIGN="LEFT"/>test_gguf_config()<br ALIGN="LEFT"/>test_gptq_config()<br ALIGN="LEFT"/>test_huggingface_config()<br ALIGN="LEFT"/>test_lora_adapter()<br ALIGN="LEFT"/>test_model_config(config: 'LLMConfig')<br ALIGN="LEFT"/>test_ollama_config()<br ALIGN="LEFT"/>test_onnx_config()<br ALIGN="LEFT"/>test_openai_config()<br ALIGN="LEFT"/>test_pytorch_config()<br ALIGN="LEFT"/>test_safetensors_config()<br ALIGN="LEFT"/>test_selected_model()<br ALIGN="LEFT"/>test_tensorflow_config()<br ALIGN="LEFT"/>update_models_list()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_config_manager.LLMConfigManager" [color="black", fontcolor="black", label=<{LLMConfigManager|config_dir : Path<br ALIGN="LEFT"/>config_file<br ALIGN="LEFT"/>config_manager : NoneType<br ALIGN="LEFT"/>configs : dict<br ALIGN="LEFT"/>metrics : dict<br ALIGN="LEFT"/>metrics_file<br ALIGN="LEFT"/>profiles : dict<br ALIGN="LEFT"/>profiles_file<br ALIGN="LEFT"/>use_centralized : bool<br ALIGN="LEFT"/>|apply_profile(config: LLMConfig, profile_id: str): LLMConfig<br ALIGN="LEFT"/>auto_load_models(llm_manager)<br ALIGN="LEFT"/>delete_model_config(model_id: str): bool<br ALIGN="LEFT"/>export_config(export_path: str, include_api_keys: bool)<br ALIGN="LEFT"/>get_metrics(model_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_profile(profile_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>import_config(import_path: str, merge: bool)<br ALIGN="LEFT"/>list_model_configs(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>list_profiles(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>load_model_config(model_id: str): Optional[LLMConfig]<br ALIGN="LEFT"/>save_metrics(model_id: str, metrics: Dict[str, Any])<br ALIGN="LEFT"/>save_model_config(model_id: str, config: LLMConfig, metadata: Optional[Dict])<br ALIGN="LEFT"/>save_profile(profile_id: str, profile_data: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" [color="black", fontcolor="black", label=<{LLMManager|active_backend : NoneType<br ALIGN="LEFT"/>backends : dict<br ALIGN="LEFT"/>background_loader : NoneType<br ALIGN="LEFT"/>configs : dict<br ALIGN="LEFT"/>enable_background_loading : bool<br ALIGN="LEFT"/>enable_lazy_loading : bool<br ALIGN="LEFT"/>lazy_manager : NoneType<br ALIGN="LEFT"/>lazy_wrappers : dict<br ALIGN="LEFT"/>loading_tasks : dict<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>progress_callbacks : list<br ALIGN="LEFT"/>|add_llm(llm_id: str, config: LLMConfig): bool<br ALIGN="LEFT"/>add_progress_callback(callback: ProgressCallback)<br ALIGN="LEFT"/>add_queued_progress_callback(callback: Union[ProgressCallback, QueuedProgressCallback])<br ALIGN="LEFT"/>analyze_protection_patterns(binary_data: Dict[str, Any], llm_id: Optional[str]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>cancel_loading(llm_id: str): bool<br ALIGN="LEFT"/>chat(messages: List[LLMMessage], llm_id: Optional[str], tools: Optional[List[Dict]]): Optional[LLMResponse]<br ALIGN="LEFT"/>configure_lazy_loading(max_loaded_models: int, idle_unload_time: int)<br ALIGN="LEFT"/>generate_script_content(prompt: str, script_type: str, context_data: Dict[str, Any], max_tokens: int, llm_id: Optional[str]): Optional[str]<br ALIGN="LEFT"/>get_all_loading_tasks(): Dict[str, LoadingTask]<br ALIGN="LEFT"/>get_available_llms(): List[str]<br ALIGN="LEFT"/>get_llm(llm_id: str): Optional[Any]<br ALIGN="LEFT"/>get_llm_info(llm_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_loading_progress(llm_id: str): Optional[LoadingTask]<br ALIGN="LEFT"/>get_loading_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>get_memory_usage(): Dict[str, Any]<br ALIGN="LEFT"/>list_llms(): List[str]<br ALIGN="LEFT"/>load_model_in_background(llm_id: str, config: LLMConfig, priority: int, callback: Optional[ProgressCallback]): Optional[LoadingTask]<br ALIGN="LEFT"/>preload_model(llm_id: str): bool<br ALIGN="LEFT"/>refine_script_content(original_script: str, error_feedback: str, test_results: Dict[str, Any], script_type: str, llm_id: Optional[str]): Optional[str]<br ALIGN="LEFT"/>register_background_loaded_model(llm_id: str, task: LoadingTask): bool<br ALIGN="LEFT"/>register_llm(llm_id: str, config: LLMConfig, use_lazy_loading: Optional[bool]): bool<br ALIGN="LEFT"/>register_tools_for_llm(llm_id: str, tools: List[Dict])<br ALIGN="LEFT"/>remove_progress_callback(callback: ProgressCallback)<br ALIGN="LEFT"/>set_active_llm(llm_id: str): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>stream_script_generation(prompt: str, script_type: str, context_data: Dict[str, Any], llm_id: Optional[str])<br ALIGN="LEFT"/>unload_all_llms()<br ALIGN="LEFT"/>unload_llm(llm_id: str): bool<br ALIGN="LEFT"/>validate_script_syntax(script_content: str, script_type: str, llm_id: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMMessage" [color="black", fontcolor="black", label=<{LLMMessage|content : str<br ALIGN="LEFT"/>role : str<br ALIGN="LEFT"/>tool_call_id : Optional[str]<br ALIGN="LEFT"/>tool_calls : Optional[List[Dict]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMProvider" [color="black", fontcolor="black", label=<{LLMProvider|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LLMResponse" [color="black", fontcolor="black", label=<{LLMResponse|content : str<br ALIGN="LEFT"/>finish_reason : str<br ALIGN="LEFT"/>model : str<br ALIGN="LEFT"/>tool_calls : Optional[List[Dict]]<br ALIGN="LEFT"/>usage : Optional[Dict[str, int]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.lmstudio_repository.LMStudioRepository" [color="black", fontcolor="black", label=<{LMStudioRepository|<br ALIGN="LEFT"/>|authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.file_handler.LRUCache" [color="black", fontcolor="black", label=<{LRUCache|cache : OrderedDict<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation._check_token_privilege.LUID" [color="black", fontcolor="black", label=<{LUID|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation._check_token_privilege.LUID_AND_ATTRIBUTES" [color="black", fontcolor="black", label=<{LUID_AND_ATTRIBUTES|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_integration.LangChainIntegration" [color="black", fontcolor="black", label=<{LangChainIntegration|interface<br ALIGN="LEFT"/>|create_tools()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.LargeFileHandler" [color="black", fontcolor="black", label=<{LargeFileHandler|access_patterns : List[Tuple[int, int, float]], list<br ALIGN="LEFT"/>background_loader : Optional[BackgroundLoader]<br ALIGN="LEFT"/>cache<br ALIGN="LEFT"/>cleanup_timer : NoneType<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>file_handle : NoneType, Optional[object]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_size : int<br ALIGN="LEFT"/>loading_strategy : IMMEDIATE, ON_DEMAND, PROGRESSIVE<br ALIGN="LEFT"/>memory_monitor<br ALIGN="LEFT"/>memory_strategy : DIRECT_LOAD, HYBRID, MEMORY_MAP, STREAMING<br ALIGN="LEFT"/>mmap_file : NoneType, Optional[mmap.mmap]<br ALIGN="LEFT"/>read_only : bool<br ALIGN="LEFT"/>|close()<br ALIGN="LEFT"/>get_file_size(): int<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>read(offset: int, size: int): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.lateral_movement.LateralMovement" [color="black", fontcolor="black", label=<{LateralMovement|active_sessions : dict<br ALIGN="LEFT"/>cleanup_on_exit : bool<br ALIGN="LEFT"/>compromised_targets : list<br ALIGN="LEFT"/>crackmapexec_available<br ALIGN="LEFT"/>credential_store : dict<br ALIGN="LEFT"/>current_host : NoneType<br ALIGN="LEFT"/>current_privileges : NoneType<br ALIGN="LEFT"/>current_user : NoneType<br ALIGN="LEFT"/>discovered_credentials : list<br ALIGN="LEFT"/>discovered_hosts : list<br ALIGN="LEFT"/>discovered_services : dict<br ALIGN="LEFT"/>discovered_shares : dict<br ALIGN="LEFT"/>failed_targets : list<br ALIGN="LEFT"/>is_linux<br ALIGN="LEFT"/>is_macos<br ALIGN="LEFT"/>is_windows<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>masscan_available<br ALIGN="LEFT"/>nmap_available<br ALIGN="LEFT"/>persistence_methods : list<br ALIGN="LEFT"/>platform<br ALIGN="LEFT"/>session_counter : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>stealth_mode : bool<br ALIGN="LEFT"/>targets : list<br ALIGN="LEFT"/>techniques : dict<br ALIGN="LEFT"/>|attempt_lateral_movement(target_ip: str, credentials: Dict[str, Any], techniques: Optional[List[str]], payload_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>clear_discovered_targets()<br ALIGN="LEFT"/>close_session(session_id: str): bool<br ALIGN="LEFT"/>discover_network(networks: List[str], discovery_methods: Optional[List[str]], max_threads: int): Dict[str, Any]<br ALIGN="LEFT"/>execute_command(session_id: str, command: str, timeout: int): Dict[str, Any]<br ALIGN="LEFT"/>get_active_sessions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_available_techniques(target_os: Optional[str]): Dict[str, List[str]]<br ALIGN="LEFT"/>get_discovered_targets(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>harvest_credentials(session_id: str, methods: Optional[List[str]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.lateral_movement.LateralMovementManager" [color="black", fontcolor="black", label=<{LateralMovementManager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>movement_engine<br ALIGN="LEFT"/>|discover_targets(network_range: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>get_default_method(): str<br ALIGN="LEFT"/>get_platform_methods(target_platform: str): list<br ALIGN="LEFT"/>is_method_available(method: str, target_platform: str): bool<br ALIGN="LEFT"/>list_available_methods(): list<br ALIGN="LEFT"/>move_laterally(target_ip: str, credentials: Dict[str, str], technique: str): Dict[str, Any]<br ALIGN="LEFT"/>move_to_target(target: str, method: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.lazy_model_loader.LazyModelManager" [color="black", fontcolor="black", label=<{LazyModelManager|idle_unload_time : int<br ALIGN="LEFT"/>load_callbacks : List[Callable[[str, bool], None]]<br ALIGN="LEFT"/>loading_strategy : NoneType<br ALIGN="LEFT"/>max_loaded_models : int<br ALIGN="LEFT"/>memory_cleanup_threshold : float<br ALIGN="LEFT"/>models : Dict[str, LazyModelWrapper]<br ALIGN="LEFT"/>|add_load_callback(callback: Callable[[str, bool], None])<br ALIGN="LEFT"/>get_loaded_models(): List[str]<br ALIGN="LEFT"/>get_model(model_id: str): Optional[LLMBackend]<br ALIGN="LEFT"/>get_model_info(model_id: Optional[str]): Union[Dict[str, Any], List[Dict[str, Any]]]<br ALIGN="LEFT"/>register_model(model_id: str, backend_class: Type[LLMBackend], config: LLMConfig): LazyModelWrapper<br ALIGN="LEFT"/>unload_all()<br ALIGN="LEFT"/>unload_model(model_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.lazy_model_loader.LazyModelWrapper" [color="black", fontcolor="black", label=<{LazyModelWrapper|access_count : int<br ALIGN="LEFT"/>backend_class : Type[LLMBackend]<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>creation_time<br ALIGN="LEFT"/>has_error<br ALIGN="LEFT"/>is_loaded<br ALIGN="LEFT"/>is_loading<br ALIGN="LEFT"/>last_access_time : NoneType<br ALIGN="LEFT"/>load_callback : Optional[Callable[[str, bool], None]]<br ALIGN="LEFT"/>load_error<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|get_backend(): Optional[LLMBackend]<br ALIGN="LEFT"/>get_info(): Dict[str, Any]<br ALIGN="LEFT"/>unload()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.LearningRecord" [color="black", fontcolor="black", label=<{LearningRecord|confidence : float<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>improvement_suggestions : List[str]<br ALIGN="LEFT"/>input_hash : str<br ALIGN="LEFT"/>learned_patterns : List[str]<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>output_hash : str<br ALIGN="LEFT"/>record_id : str<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>task_type : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine_simple.LearningRecord" [color="black", fontcolor="black", label=<{LearningRecord|confidence : float<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>input_hash : str<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>output_hash : str<br ALIGN="LEFT"/>record_id : str<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>task_type : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseActivation" [color="black", fontcolor="black", label=<{LicenseActivation|activation_time<br ALIGN="LEFT"/>client_ip<br ALIGN="LEFT"/>hardware_fingerprint<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>is_active<br ALIGN="LEFT"/>last_checkin<br ALIGN="LEFT"/>license<br ALIGN="LEFT"/>license_id<br ALIGN="LEFT"/>user_agent<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor.ConcolicExecutionEngine.find_license_bypass.LicenseCheckPlugin" [color="black", fontcolor="black", label=<{LicenseCheckPlugin|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|will_execute_instruction_callback(state, pc, insn)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseEntry" [color="black", fontcolor="black", label=<{LicenseEntry|activations<br ALIGN="LEFT"/>created_date<br ALIGN="LEFT"/>current_users<br ALIGN="LEFT"/>custom_data<br ALIGN="LEFT"/>expiry_date<br ALIGN="LEFT"/>hardware_fingerprint<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>license_key<br ALIGN="LEFT"/>license_type<br ALIGN="LEFT"/>max_users<br ALIGN="LEFT"/>product_name<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>version<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseLog" [color="black", fontcolor="black", label=<{LicenseLog|client_ip<br ALIGN="LEFT"/>details<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>license_key<br ALIGN="LEFT"/>operation<br ALIGN="LEFT"/>success<br ALIGN="LEFT"/>timestamp<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.license_protocol_handler.LicenseProtocolHandler" [color="black", fontcolor="black", label=<{LicenseProtocolHandler|bind_host<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>host<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>port : int<br ALIGN="LEFT"/>proxy_thread : NoneType, Optional[threading.Thread]<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>timeout<br ALIGN="LEFT"/>|clear_data(): None<br ALIGN="LEFT"/><I>generate_response</I>(request_data: bytes): bytes<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/><I>handle_connection</I>(socket: Any, initial_data: bytes): None<br ALIGN="LEFT"/>is_running(): bool<br ALIGN="LEFT"/>log_request(request_data: bytes, source: str): None<br ALIGN="LEFT"/>log_response(response_data: bytes, destination: str): None<br ALIGN="LEFT"/>shutdown(): None<br ALIGN="LEFT"/>start_proxy(port: int): bool<br ALIGN="LEFT"/>stop_proxy(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseRequest" [color="black", fontcolor="black", label=<{LicenseRequest|client_info : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>hardware_fingerprint : Optional[str]<br ALIGN="LEFT"/>license_key : Optional[str]<br ALIGN="LEFT"/>product_name : Optional[str]<br ALIGN="LEFT"/>version : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator._start_tcp_server.LicenseRequestHandler" [color="black", fontcolor="black", label=<{LicenseRequestHandler|<br ALIGN="LEFT"/>|handle(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseResponse" [color="black", fontcolor="black", label=<{LicenseResponse|current_users : Optional[int]<br ALIGN="LEFT"/>expiry_date : Optional[datetime]<br ALIGN="LEFT"/>features : Optional[Dict[str, bool]]<br ALIGN="LEFT"/>max_users : Optional[int]<br ALIGN="LEFT"/>message : Optional[str]<br ALIGN="LEFT"/>remaining_days : Optional[int]<br ALIGN="LEFT"/>status : Optional[str]<br ALIGN="LEFT"/>valid : Optional[bool]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [color="black", fontcolor="black", label=<{LicenseServerEmulator|adobe<br ALIGN="LEFT"/>app<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>crypto<br ALIGN="LEFT"/>db_manager<br ALIGN="LEFT"/>fingerprint_gen<br ALIGN="LEFT"/>flexlm<br ALIGN="LEFT"/>hasp<br ALIGN="LEFT"/>kms<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>security : NoneType<br ALIGN="LEFT"/>|start_servers()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseStatus" [color="black", fontcolor="black", label=<{LicenseStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.LicenseType" [color="black", fontcolor="black", label=<{LicenseType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_lief_fallback.LiefFallback" [color="black", fontcolor="black", label=<{LiefFallback|<br ALIGN="LEFT"/>|parse(filename)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.LineNumberArea" [color="black", fontcolor="black", label=<{LineNumberArea|code_editor<br ALIGN="LEFT"/>|mousePressEvent(event)<br ALIGN="LEFT"/>paintEvent(event)<br ALIGN="LEFT"/>sizeHint()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.LinearRegressionModel" [color="black", fontcolor="black", label=<{LinearRegressionModel|bias : float<br ALIGN="LEFT"/>feature_importance<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>weights : Dict[str, float]<br ALIGN="LEFT"/>|predict(features: Dict[str, float]): Tuple[float, float]<br ALIGN="LEFT"/>train(training_data: List[Dict[str, Any]])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.linux_persistence.LinuxPersistence" [color="black", fontcolor="black", label=<{LinuxPersistence|logger : NoneType, RootLogger<br ALIGN="LEFT"/>persistence_locations : dict<br ALIGN="LEFT"/>persistence_methods : list<br ALIGN="LEFT"/>|generate_persistence_code(method: str, module_name: str): str<br ALIGN="LEFT"/>get_default_method(): str<br ALIGN="LEFT"/>list_available_methods(): list<br ALIGN="LEFT"/>list_persistence_methods(): List[str]<br ALIGN="LEFT"/>remove_persistence(cleanup_info: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.LiveDebuggingSystem" [color="black", fontcolor="black", label=<{LiveDebuggingSystem|active_debug_sessions : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>automated_fixes : Dict[str, Callable]<br ALIGN="LEFT"/>debug_history : deque<br ALIGN="LEFT"/>runtime_monitor<br ALIGN="LEFT"/>|add_breakpoint(session_id: str, component: str, condition: str): bool<br ALIGN="LEFT"/>add_watch(session_id: str, expression: str, alert_condition: str): bool<br ALIGN="LEFT"/>get_debug_insights(session_id: str): Dict[str, Any]<br ALIGN="LEFT"/>register_automated_fix(metric_name: str, fix_function: Callable)<br ALIGN="LEFT"/>start_debug_session(session_id: str, target_component: str, debug_level: str): bool<br ALIGN="LEFT"/>stop_debug_session(session_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LlamaCppBackend" [color="black", fontcolor="black", label=<{LlamaCppBackend|is_initialized : bool<br ALIGN="LEFT"/>llama : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_llama_layer.LlamaLayer" [color="black", fontcolor="black", label=<{LlamaLayer|attention : MultiheadAttention<br ALIGN="LEFT"/>attention_norm<br ALIGN="LEFT"/>down_proj : Linear<br ALIGN="LEFT"/>ffn_norm<br ALIGN="LEFT"/>gate_proj : Linear<br ALIGN="LEFT"/>up_proj : Linear<br ALIGN="LEFT"/>|forward(x, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel" [color="black", fontcolor="black", label=<{LlamaModel|final_norm<br ALIGN="LEFT"/>hidden_size<br ALIGN="LEFT"/>layers : ModuleList<br ALIGN="LEFT"/>lm_head : Linear<br ALIGN="LEFT"/>num_heads<br ALIGN="LEFT"/>token_embedding : Embedding<br ALIGN="LEFT"/>|forward(input_ids, attention_mask)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.lora_adapter_manager.LoRAAdapterManager" [color="black", fontcolor="black", label=<{LoRAAdapterManager|adapter_configs : dict<br ALIGN="LEFT"/>cache_dir : Path<br ALIGN="LEFT"/>loaded_adapters : dict<br ALIGN="LEFT"/>|apply_lora_to_model(model: Any, lora_config: Any, adapter_name: str): Optional[Any]<br ALIGN="LEFT"/>cleanup_cache(keep_recent: int)<br ALIGN="LEFT"/>compare_adapter_configs(config1_path: Union[str, Path], config2_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>create_lora_config(adapter_type: str, r: int, lora_alpha: int, target_modules: Optional[List[str]], lora_dropout: float): Optional[Any]<br ALIGN="LEFT"/>download_adapter(adapter_id: str, cache_dir: Optional[str], revision: Optional[str]): Optional[Path]<br ALIGN="LEFT"/>get_adapter_info(adapter_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>list_adapters(model: Any): List[str]<br ALIGN="LEFT"/>load_adapter(base_model: Any, adapter_path: Union[str, Path], adapter_name: str): Optional[Any]<br ALIGN="LEFT"/>merge_adapters(model: Any, adapter_names: List[str], weights: Optional[List[float]], new_adapter_name: str): bool<br ALIGN="LEFT"/>prepare_model_for_qlora(model: Any, use_gradient_checkpointing: bool, gradient_checkpointing_kwargs: Optional[Dict]): Any<br ALIGN="LEFT"/>save_adapter(model: Any, save_path: Union[str, Path], adapter_name: str, save_config: bool): bool<br ALIGN="LEFT"/>set_adapter(model: Any, adapter_name: str): bool<br ALIGN="LEFT"/>validate_adapter_config(config_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.LoadBalancer" [color="black", fontcolor="black", label=<{LoadBalancer|agent_loads : Dict[str, float]<br ALIGN="LEFT"/>load_history : deque<br ALIGN="LEFT"/>|get_least_loaded_agent(available_agents: List[str]): Optional[str]<br ALIGN="LEFT"/>update_agent_load(agent_id: str, load: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_types.LoadingProgress" [color="black", fontcolor="black", label=<{LoadingProgress|details : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>progress : float<br ALIGN="LEFT"/>state<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_types.LoadingState" [color="black", fontcolor="black", label=<{LoadingState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.LoadingStrategy" [color="black", fontcolor="black", label=<{LoadingStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.LoadingTask" [color="black", fontcolor="black", label=<{LoadingTask|backend_class : type<br ALIGN="LEFT"/>callback : Optional[ProgressCallback]<br ALIGN="LEFT"/>cancelled : bool<br ALIGN="LEFT"/>config : str<br ALIGN="LEFT"/>end_time : Optional[float]<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>message : str<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>progress : float<br ALIGN="LEFT"/>result : Optional['LLMBackend']<br ALIGN="LEFT"/>start_time : Optional[float]<br ALIGN="LEFT"/>state : CANCELLED, COMPLETED, FAILED, NoneType, PENDING<br ALIGN="LEFT"/>|cancel()<br ALIGN="LEFT"/>mark_completed(success: bool, result: Optional['LLMBackend'], error: Optional[str])<br ALIGN="LEFT"/>update_progress(progress: float, message: str, state: Optional[LoadingState])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.local_repository.LocalFileRepository" [color="black", fontcolor="black", label=<{LocalFileRepository|models_cache : dict<br ALIGN="LEFT"/>models_directory : str<br ALIGN="LEFT"/>models_metadata_file<br ALIGN="LEFT"/>|add_model(file_path: str): Optional[ModelInfo]<br ALIGN="LEFT"/>authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str, progress_callback: Optional[DownloadProgressCallback]): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>remove_model(model_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.LocalGGUFBackend" [color="black", fontcolor="black", label=<{LocalGGUFBackend|gguf_manager : NoneType<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>server_url<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.local_gguf_server.LocalGGUFServer" [color="black", fontcolor="black", label=<{LocalGGUFServer|app : NoneType<br ALIGN="LEFT"/>gpu_backend : NoneType, str<br ALIGN="LEFT"/>gpu_devices : list<br ALIGN="LEFT"/>host : str<br ALIGN="LEFT"/>is_running : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>model_config : dict<br ALIGN="LEFT"/>model_path : NoneType, str<br ALIGN="LEFT"/>port : int<br ALIGN="LEFT"/>server_thread : NoneType, Thread<br ALIGN="LEFT"/>|can_run(): bool<br ALIGN="LEFT"/>get_server_url(): str<br ALIGN="LEFT"/>is_healthy(): bool<br ALIGN="LEFT"/>load_model(model_path: str): bool<br ALIGN="LEFT"/>start_server(): bool<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>unload_model()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.LocalLicenseServer" [color="black", fontcolor="black", label=<{LocalLicenseServer|auth_manager<br ALIGN="LEFT"/>license_db : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|handle_license_request(request: RequestInfo): ResponseInfo<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.LogViewer" [color="black", fontcolor="black", label=<{LogViewer|clear_btn : Button<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>export_btn : Button<br ALIGN="LEFT"/>frame : Frame<br ALIGN="LEFT"/>level_combo : Combobox<br ALIGN="LEFT"/>level_var : StringVar<br ALIGN="LEFT"/>log_entries : list<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>search_entry : Entry<br ALIGN="LEFT"/>search_var : StringVar<br ALIGN="LEFT"/>text_frame : Frame<br ALIGN="LEFT"/>text_widget : ScrolledText<br ALIGN="LEFT"/>toolbar : Frame<br ALIGN="LEFT"/>|add_log(level: str, message: str, source: str)<br ALIGN="LEFT"/>clear_logs()<br ALIGN="LEFT"/>export_logs()<br ALIGN="LEFT"/>highlight_search_term(start_pos: str, end_pos: str, search_term: str)<br ALIGN="LEFT"/>on_filter_change(event)<br ALIGN="LEFT"/>on_search(event)<br ALIGN="LEFT"/>refresh_display()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.LoggingManager" [color="black", fontcolor="black", label=<{LoggingManager|config : Dict[str, Any], dict<br ALIGN="LEFT"/>handlers : Dict[str, logging.Handler]<br ALIGN="LEFT"/>loggers : Dict[str, logging.Logger]<br ALIGN="LEFT"/>|get_logger(name: str): logging.Logger<br ALIGN="LEFT"/>log_event(event: Event)<br ALIGN="LEFT"/>log_plugin_operation(plugin_name: str, operation: str, status: str, details: Dict[str, Any])<br ALIGN="LEFT"/>log_workflow_step(workflow_id: str, step_id: str, status: str, duration: float, result: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.task_manager.LongRunningTask" [color="black", fontcolor="black", label=<{LongRunningTask|duration : int<br ALIGN="LEFT"/>|execute(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryForensicsEngine._analyze_live_process_windows.MEMORY_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{MEMORY_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.memory_patcher._handle_guard_pages_windows.MEMORY_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{MEMORY_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.memory_patcher.detect_and_bypass_guard_pages.MEMORY_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{MEMORY_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumperWidget._scan_windows_regions.MEMORY_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{MEMORY_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.MLPredictor" [color="black", fontcolor="black", label=<{MLPredictor|feature_names : list<br ALIGN="LEFT"/>is_trained : bool<br ALIGN="LEFT"/>models : dict<br ALIGN="LEFT"/>scaler : StandardScaler<br ALIGN="LEFT"/>|predict(recent_events: List[AnalysisEvent], horizon: int): Dict[str, Any]<br ALIGN="LEFT"/>prepare_features(events: List[AnalysisEvent]): Tuple[np.ndarray, np.ndarray]<br ALIGN="LEFT"/>train(events: List[AnalysisEvent])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.adobe_injector.MODULEENTRY32" [color="black", fontcolor="black", label=<{MODULEENTRY32|dwSize<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.MemoryPatcher.scan_and_patch_module.MODULEINFO" [color="black", fontcolor="black", label=<{MODULEINFO|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_client.C2Client._start_keylogging.MSG" [color="black", fontcolor="black", label=<{MSG|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_client.C2Client._start_keylogging.FallbackWintypes.MSG" [color="black", fontcolor="black", label=<{MSG|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ManagedResource" [color="black", fontcolor="black", label=<{ManagedResource|cleaned_at : Optional[datetime]<br ALIGN="LEFT"/>cleanup_func : Optional[Callable]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>resource_id : str<br ALIGN="LEFT"/>resource_type<br ALIGN="LEFT"/>state : CLEANED, CLEANING, CREATED, FAILED<br ALIGN="LEFT"/>usage<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryAnalysisResult" [color="black", fontcolor="black", label=<{MemoryAnalysisResult|analysis_profile : str<br ALIGN="LEFT"/>analysis_time : float<br ALIGN="LEFT"/>artifacts_found : Dict[str, int]<br ALIGN="LEFT"/>dump_path : str<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>file_handles : List[Dict[str, Any]]<br ALIGN="LEFT"/>has_suspicious_activity<br ALIGN="LEFT"/>hidden_process_count<br ALIGN="LEFT"/>memory_strings : List[MemoryString]<br ALIGN="LEFT"/>modules : List[MemoryModule]<br ALIGN="LEFT"/>network_connections : List[NetworkConnection]<br ALIGN="LEFT"/>processes : List[MemoryProcess]<br ALIGN="LEFT"/>registry_artifacts : List[Dict[str, Any]]<br ALIGN="LEFT"/>security_findings : List[Dict[str, Any]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryArtifactType" [color="black", fontcolor="black", label=<{MemoryArtifactType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryConfig" [color="black", fontcolor="black", label=<{MemoryConfig|cache_size_mb : int<br ALIGN="LEFT"/>chunk_size_mb : int<br ALIGN="LEFT"/>enable_compression : bool<br ALIGN="LEFT"/>max_memory_mb : int<br ALIGN="LEFT"/>memory_threshold : float<br ALIGN="LEFT"/>prefetch_chunks : int<br ALIGN="LEFT"/>strategy : STREAMING<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumpThread" [color="black", fontcolor="black", label=<{MemoryDumpThread|log<br ALIGN="LEFT"/>options<br ALIGN="LEFT"/>output_dir<br ALIGN="LEFT"/>pid<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>rows<br ALIGN="LEFT"/>table<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumperWidget" [color="black", fontcolor="black", label=<{MemoryDumperWidget|compress_check<br ALIGN="LEFT"/>current_process : NoneType, int<br ALIGN="LEFT"/>dump_thread : NoneType<br ALIGN="LEFT"/>executable_check<br ALIGN="LEFT"/>full_dump_check<br ALIGN="LEFT"/>metadata_check<br ALIGN="LEFT"/>minidump_check<br ALIGN="LEFT"/>output_log<br ALIGN="LEFT"/>private_check<br ALIGN="LEFT"/>process_combo<br ALIGN="LEFT"/>process_info<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>raw_dump_check<br ALIGN="LEFT"/>readable_check<br ALIGN="LEFT"/>regions_table<br ALIGN="LEFT"/>strings_check<br ALIGN="LEFT"/>writable_check<br ALIGN="LEFT"/>|attach_to_process()<br ALIGN="LEFT"/>dump_all_regions()<br ALIGN="LEFT"/>dump_finished()<br ALIGN="LEFT"/>dump_selected_regions()<br ALIGN="LEFT"/>get_dump_options()<br ALIGN="LEFT"/>refresh_process_list()<br ALIGN="LEFT"/>scan_memory_regions()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_progress(value)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryForensicsEngine" [color="black", fontcolor="black", label=<{MemoryForensicsEngine|analysis_results : dict<br ALIGN="LEFT"/>automagics<br ALIGN="LEFT"/>cache_directory : Path<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>vol_config<br ALIGN="LEFT"/>vol_context<br ALIGN="LEFT"/>volatility_available : bool<br ALIGN="LEFT"/>|analyze_memory_dump(dump_path: Union[str, Path], profile: AnalysisProfile, deep_analysis: bool): MemoryAnalysisResult<br ALIGN="LEFT"/>analyze_process_memory(process_id: int, dump_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>export_analysis_report(analysis_result: MemoryAnalysisResult, output_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>extract_strings(memory_data: bytes, min_length: int): List[str]<br ALIGN="LEFT"/>generate_icp_supplemental_data(analysis_result: MemoryAnalysisResult): Dict[str, Any]<br ALIGN="LEFT"/>get_analysis_summary(analysis_result: MemoryAnalysisResult): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.MemoryManager" [color="black", fontcolor="black", label=<{MemoryManager|current_usage : int<br ALIGN="LEFT"/>max_memory_bytes : int<br ALIGN="LEFT"/>max_memory_mb : int<br ALIGN="LEFT"/>memory_lock : lock<br ALIGN="LEFT"/>|check_memory_usage(): Dict[str, Any]<br ALIGN="LEFT"/>cleanup_memory()<br ALIGN="LEFT"/>get_recommended_chunk_size(file_size: int): int<br ALIGN="LEFT"/>should_limit_analysis(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryModule" [color="black", fontcolor="black", label=<{MemoryModule|base_address : int<br ALIGN="LEFT"/>company : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>hash_md5 : str<br ALIGN="LEFT"/>hash_sha256 : str<br ALIGN="LEFT"/>is_signed : bool<br ALIGN="LEFT"/>is_suspicious : bool<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>path : str<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryMonitor" [color="black", fontcolor="black", label=<{MemoryMonitor|callbacks : List[Callable[[float], None]]<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>monitoring : bool<br ALIGN="LEFT"/>thread : Optional[threading.Thread]<br ALIGN="LEFT"/>|add_callback(callback: Callable[[float], None])<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.memory_loader.MemoryOptimizedBinaryLoader" [color="black", fontcolor="black", label=<{MemoryOptimizedBinaryLoader|chunk_size<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>current_file : NoneType, Optional[object]<br ALIGN="LEFT"/>file_size : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>mapped_file : NoneType, Optional[mmap.mmap]<br ALIGN="LEFT"/>max_memory<br ALIGN="LEFT"/>section_cache : Dict[str, bytes]<br ALIGN="LEFT"/>|calculate_entropy(data: Union[bytes, None]): float<br ALIGN="LEFT"/>close(): None<br ALIGN="LEFT"/>get_file_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_memory_usage(): int<br ALIGN="LEFT"/>iterate_file(chunk_size: Optional[int]): Iterator[Tuple[int, bytes]]<br ALIGN="LEFT"/>load_file(file_path: str): bool<br ALIGN="LEFT"/>read_chunk(offset: int, size: int): Optional[bytes]<br ALIGN="LEFT"/>read_section(section_name: str, section_offset: int, section_size: int): Optional[bytes]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.memory_optimizer.MemoryOptimizer" [color="black", fontcolor="black", label=<{MemoryOptimizer|app : Optional[Any]<br ALIGN="LEFT"/>check_interval : float<br ALIGN="LEFT"/>enabled : bool<br ALIGN="LEFT"/>last_usage_check : float<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>optimization_stats : Dict[str, Union[int, float, str, None]], dict<br ALIGN="LEFT"/>optimization_techniques : Dict[str, bool]<br ALIGN="LEFT"/>threshold_percentage : float<br ALIGN="LEFT"/>|check_for_memory_leaks(): str<br ALIGN="LEFT"/>check_memory_usage(): bool<br ALIGN="LEFT"/>configure(threshold: float, check_interval: float, techniques: Optional[Dict[str, bool]]): None<br ALIGN="LEFT"/>disable(): None<br ALIGN="LEFT"/>enable(): None<br ALIGN="LEFT"/>force_optimization(): int<br ALIGN="LEFT"/>get_current_memory_usage(): Tuple[int, int, float]<br ALIGN="LEFT"/>get_memory_report(): Dict[str, Any]<br ALIGN="LEFT"/>get_memory_usage_mb(): Tuple[float, float, float]<br ALIGN="LEFT"/>get_optimization_stats(): Dict[str, Union[int, float, str, None]]<br ALIGN="LEFT"/>optimize_memory(): int<br ALIGN="LEFT"/>reset_stats(): None<br ALIGN="LEFT"/>set_technique(technique: str, enabled: bool): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.MemoryPatcher" [color="black", fontcolor="black", label=<{MemoryPatcher|kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>patches_applied : list<br ALIGN="LEFT"/>patterns : dict<br ALIGN="LEFT"/>|find_patterns_in_memory(start_addr: int, size: int): List[Tuple[str, int]]<br ALIGN="LEFT"/>patch_int3_instructions(address: int): bool<br ALIGN="LEFT"/>patch_isdebuggerpresent_calls(address: int): bool<br ALIGN="LEFT"/>patch_memory_location(address: int, new_bytes: bytes): bool<br ALIGN="LEFT"/>scan_all_modules(): List[str]<br ALIGN="LEFT"/>scan_and_patch_module(module_name: str): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" [color="black", fontcolor="black", label=<{MemoryPool|allocation_history : deque<br ALIGN="LEFT"/>available_buffers : deque<br ALIGN="LEFT"/>buffer_size : int<br ALIGN="LEFT"/>in_use_buffers : set<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>|get_buffer(required_size: int): bytearray<br ALIGN="LEFT"/>optimize_pool_size()<br ALIGN="LEFT"/>predict_required_buffers(): int<br ALIGN="LEFT"/>return_buffer(buffer: bytearray)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryProcess" [color="black", fontcolor="black", label=<{MemoryProcess|command_line : str<br ALIGN="LEFT"/>create_time : str<br ALIGN="LEFT"/>exit_time : str<br ALIGN="LEFT"/>handle_count : int<br ALIGN="LEFT"/>image_base : int<br ALIGN="LEFT"/>image_size : int<br ALIGN="LEFT"/>is_hidden : bool<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>pid : int<br ALIGN="LEFT"/>ppid : int<br ALIGN="LEFT"/>session_id : int<br ALIGN="LEFT"/>suspicious_indicators : List[str]<br ALIGN="LEFT"/>thread_count : int<br ALIGN="LEFT"/>wow64 : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryStrategy" [color="black", fontcolor="black", label=<{MemoryStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.MemoryString" [color="black", fontcolor="black", label=<{MemoryString|confidence : float<br ALIGN="LEFT"/>context : str<br ALIGN="LEFT"/>encoding : str<br ALIGN="LEFT"/>is_unicode : bool<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>value : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.MessageRouter" [color="black", fontcolor="black", label=<{MessageRouter|agent_queues : Dict[str, Queue]<br ALIGN="LEFT"/>message_log : deque<br ALIGN="LEFT"/>|register_agent(agent_id: str, message_queue: Queue)<br ALIGN="LEFT"/>route_message(message: AgentMessage)<br ALIGN="LEFT"/>unregister_agent(agent_id: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.MessageType" [color="black", fontcolor="black", label=<{MessageType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.ui.ui_utils.MessageType" [color="black", fontcolor="black", label=<{MessageType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.MetricType" [color="black", fontcolor="black", label=<{MetricType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.MicrosoftKMSEmulator" [color="black", fontcolor="black", label=<{MicrosoftKMSEmulator|crypto<br ALIGN="LEFT"/>kms_keys : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|activate_product(product_key: str, product_name: str, client_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.MicrosoftKMSHandler" [color="black", fontcolor="black", label=<{MicrosoftKMSHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_response(context: ResponseContext): bytes<br ALIGN="LEFT"/>parse_request(data: bytes): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.bypass_base.MitigationBypassBase" [color="black", fontcolor="black", label=<{MitigationBypassBase|logger : NoneType, RootLogger<br ALIGN="LEFT"/>mitigation_name : str<br ALIGN="LEFT"/>techniques : list<br ALIGN="LEFT"/>|analyze_bypass_opportunities(binary_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>get_all_techniques(): List[str]<br ALIGN="LEFT"/><I>get_recommended_technique</I>(binary_info: Dict[str, Any]): str<br ALIGN="LEFT"/>get_technique_difficulty(technique_name: str): str<br ALIGN="LEFT"/>get_technique_info(technique_name: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>is_technique_applicable(technique_name: str, binary_info: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_test_generator.MockDataGenerator" [color="black", fontcolor="black", label=<{MockDataGenerator|elf_template : bytearray<br ALIGN="LEFT"/>pe_template<br ALIGN="LEFT"/>|create_mock_binary(binary_type)<br ALIGN="LEFT"/>create_mock_network_data()<br ALIGN="LEFT"/>create_mock_registry_data()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.export_dialog.main.MockDetection" [color="black", fontcolor="black", label=<{MockDetection|confidence<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>type<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.main_app.MockWindll.__getattr__.MockFunc" [color="black", fontcolor="black", label=<{MockFunc|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.export_dialog.main.MockICPAnalysis" [color="black", fontcolor="black", label=<{MockICPAnalysis|all_detections : list<br ALIGN="LEFT"/>architecture : str<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>is_protected : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector._check_mouse_movement.MockPOINT" [color="black", fontcolor="black", label=<{MockPOINT|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" [color="black", fontcolor="black", label=<{MockQtClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.ui.ui_setup_functions.MockQtClass" [color="black", fontcolor="black", label=<{MockQtClass|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.main_app.MockWindll" [color="black", fontcolor="black", label=<{MockWindll|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|DWORD : c_ulong<br ALIGN="LEFT"/>HANDLE : c_void_p<br ALIGN="LEFT"/>LPARAM : c_long<br ALIGN="LEFT"/>LPVOID : c_void_p<br ALIGN="LEFT"/>LPWSTR : c_wchar_p<br ALIGN="LEFT"/>MSG<br ALIGN="LEFT"/>POINT<br ALIGN="LEFT"/>WORD : c_ushort<br ALIGN="LEFT"/>WPARAM : c_ulong<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector._check_mouse_movement.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.c2_client.C2Client._windows_token_impersonation.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|HANDLE : c_void_p<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation._attempt_token_duplication.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence._lsa_security_package_persistence.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence.remove_persistence.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.memory_patcher._get_wintypes.MockWintypes" [color="black", fontcolor="black", label=<{MockWintypes|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelBackend" [color="black", fontcolor="black", label=<{ModelBackend|<br ALIGN="LEFT"/>|<I>get_model_info</I>(model: Any): Dict[str, Any]<br ALIGN="LEFT"/><I>load_model</I>(model_path: str): Any<br ALIGN="LEFT"/><I>predict</I>(model: Any, input_data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_batch_tester.ModelBatchTester" [color="black", fontcolor="black", label=<{ModelBatchTester|llm_manager : Optional[LLMManager]<br ALIGN="LEFT"/>max_workers : int<br ALIGN="LEFT"/>performance_monitor : NoneType<br ALIGN="LEFT"/>test_reports : List[BatchTestReport]<br ALIGN="LEFT"/>test_suites : Dict[str, List[TestCase]]<br ALIGN="LEFT"/>timeout_per_test : float<br ALIGN="LEFT"/>|add_test_suite(suite_id: str, test_cases: List[TestCase])<br ALIGN="LEFT"/>compare_models(model_ids: List[str], suite_id: str): Dict[str, Any]<br ALIGN="LEFT"/>export_report(report: BatchTestReport, output_path: Optional[Union[str, Path]], format: str): Path<br ALIGN="LEFT"/>load_test_suite_from_file(file_path: Union[str, Path]): str<br ALIGN="LEFT"/>run_batch_test(model_ids: List[str], suite_id: str, parallel: bool, progress_callback: Optional[Callable[[int, int], None]]): BatchTestReport<br ALIGN="LEFT"/>run_single_test(model_id: str, test_case: TestCase, llm_manager: Optional[LLMManager]): TestResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_performance_monitor.ModelBenchmark" [color="black", fontcolor="black", label=<{ModelBenchmark|avg_inference_time : float<br ALIGN="LEFT"/>avg_memory_mb : float<br ALIGN="LEFT"/>avg_tokens_per_second : float<br ALIGN="LEFT"/>benchmark_date : datetime<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>error_rate : float<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>p50_latency : float<br ALIGN="LEFT"/>p95_latency : float<br ALIGN="LEFT"/>p99_latency : float<br ALIGN="LEFT"/>quantization : Optional[str]<br ALIGN="LEFT"/>total_inferences : int<br ALIGN="LEFT"/>total_tokens : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelCache" [color="black", fontcolor="black", label=<{ModelCache|access_times : dict<br ALIGN="LEFT"/>cache : dict<br ALIGN="LEFT"/>cache_dir<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_cache_size : int<br ALIGN="LEFT"/>|clear()<br ALIGN="LEFT"/>get(model_path: str): Optional[Any]<br ALIGN="LEFT"/>get_cache_info(): Dict[str, Any]<br ALIGN="LEFT"/>put(model_path: str, model: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_cache_manager.ModelCacheManager" [color="black", fontcolor="black", label=<{ModelCacheManager|cache : OrderedDict[str, CacheEntry]<br ALIGN="LEFT"/>cache_dir : Path<br ALIGN="LEFT"/>current_memory_usage : int<br ALIGN="LEFT"/>disk_index : dict<br ALIGN="LEFT"/>disk_index_file<br ALIGN="LEFT"/>enable_disk_cache : bool<br ALIGN="LEFT"/>max_memory_bytes : int<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|clear(clear_disk: bool)<br ALIGN="LEFT"/>get(model_id: str, load_function: Optional[callable]): Optional[Tuple[Any, Optional[Any]]]<br ALIGN="LEFT"/>get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>list_cached_models(): List[Dict[str, Any]]<br ALIGN="LEFT"/>preload_models(model_ids: List[str], load_functions: Dict[str, callable])<br ALIGN="LEFT"/>put(model_id: str, model: Any, tokenizer: Optional[Any], model_type: str, config: Optional[Dict[str, Any]], load_time: float)<br ALIGN="LEFT"/>set_memory_limit(max_memory_gb: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_comparison.ModelComparison" [color="black", fontcolor="black", label=<{ModelComparison|batch_tester : NoneType<br ALIGN="LEFT"/>llm_manager : Optional[LLMManager]<br ALIGN="LEFT"/>performance_monitor : NoneType<br ALIGN="LEFT"/>reports : List[ComparisonReport]<br ALIGN="LEFT"/>save_dir<br ALIGN="LEFT"/>|benchmark_models(model_ids: List[str], test_suite: str): Dict[str, Any]<br ALIGN="LEFT"/>compare_outputs(model_ids: List[str], prompt: str, system_prompt: Optional[str], max_tokens: int, temperature: float, num_samples: int): ComparisonReport<br ALIGN="LEFT"/>generate_html_report(report: ComparisonReport): Path<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.ai_model_manager.ModelConfig" [color="black", fontcolor="black", label=<{ModelConfig|api_key : Optional[str]<br ALIGN="LEFT"/>capabilities : List[str]<br ALIGN="LEFT"/>context_length : Optional[int]<br ALIGN="LEFT"/>endpoint : Optional[str]<br ALIGN="LEFT"/>gpu_enabled : bool<br ALIGN="LEFT"/>gpu_layers : Optional[int]<br ALIGN="LEFT"/>max_tokens : int<br ALIGN="LEFT"/>model_directory : Optional[str]<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>model_path : Optional[str]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>provider<br ALIGN="LEFT"/>quantization : Optional[str]<br ALIGN="LEFT"/>system_prompt : Optional[str]<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>threads : Optional[int]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_download_manager.ModelDownloadManager" [color="black", fontcolor="black", label=<{ModelDownloadManager|active_downloads : dict<br ALIGN="LEFT"/>api<br ALIGN="LEFT"/>cache_dir : Path<br ALIGN="LEFT"/>download_progress : dict<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>metadata_file<br ALIGN="LEFT"/>token : NoneType<br ALIGN="LEFT"/>|clear_cache(keep_recent: int): int<br ALIGN="LEFT"/>delete_cached_model(model_id: str): bool<br ALIGN="LEFT"/>download_file(model_id: str, filename: str, revision: Optional[str], progress_callback: Optional[Callable[[DownloadProgress], None]]): Optional[Path]<br ALIGN="LEFT"/>download_model(model_id: str, revision: Optional[str], allow_patterns: Optional[List[str]], ignore_patterns: Optional[List[str]], progress_callback: Optional[Callable[[DownloadProgress], None]], force_download: bool): Optional[Path]<br ALIGN="LEFT"/>get_cache_size(): Dict[str, float]<br ALIGN="LEFT"/>get_model_card(model_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_model_info(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>get_model_readme(model_id: str): Optional[str]<br ALIGN="LEFT"/>list_cached_models(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>search_models(query: str, task: Optional[str], library: Optional[str], limit: int, sort: str): List[ModelInfo]<br ALIGN="LEFT"/>verify_model_files(model_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_manager_dialog.ModelDownloadThread" [color="black", fontcolor="black", label=<{ModelDownloadThread|download_finished<br ALIGN="LEFT"/>is_cancelled : bool<br ALIGN="LEFT"/>log_message<br ALIGN="LEFT"/>model_name : str<br ALIGN="LEFT"/>model_url : str<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>|cancel()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelFineTuner" [color="black", fontcolor="black", label=<{ModelFineTuner|lock : _RLock<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>model_manager<br ALIGN="LEFT"/>training_history : dict<br ALIGN="LEFT"/>|fine_tune_model(model_id: str, training_data: Any, validation_data: Any, epochs: int, learning_rate: float, batch_size: int, callback: Callable): Dict[str, Any]<br ALIGN="LEFT"/>get_training_history(model_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app.ModelFinetuningDialog" [color="black", fontcolor="black", label=<{ModelFinetuningDialog|cancel_button<br ALIGN="LEFT"/>dataset_path_edit<br ALIGN="LEFT"/>epochs_spin<br ALIGN="LEFT"/>learning_rate_spin<br ALIGN="LEFT"/>loss_function_combo<br ALIGN="LEFT"/>model_path_edit<br ALIGN="LEFT"/>optimizer_combo<br ALIGN="LEFT"/>output_directory_edit<br ALIGN="LEFT"/>patience_spin<br ALIGN="LEFT"/>train_button<br ALIGN="LEFT"/>|setupUI()<br ALIGN="LEFT"/>start_training()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.ModelFinetuningDialog" [color="black", fontcolor="black", label=<{ModelFinetuningDialog|apply_aug_button : NoneType<br ALIGN="LEFT"/>aug_per_sample_spin : NoneType<br ALIGN="LEFT"/>aug_prob_label : NoneType<br ALIGN="LEFT"/>aug_prob_slider : NoneType<br ALIGN="LEFT"/>aug_progress : NoneType<br ALIGN="LEFT"/>aug_status : NoneType<br ALIGN="LEFT"/>augmentation_config<br ALIGN="LEFT"/>augmentation_tab<br ALIGN="LEFT"/>backtranslation_check : NoneType<br ALIGN="LEFT"/>batch_size_spin : NoneType<br ALIGN="LEFT"/>close_button<br ALIGN="LEFT"/>create_dataset_button : NoneType<br ALIGN="LEFT"/>cutoff_len_spin : NoneType<br ALIGN="LEFT"/>dataset_format_combo : NoneType<br ALIGN="LEFT"/>dataset_path_button : NoneType<br ALIGN="LEFT"/>dataset_path_edit : NoneType<br ALIGN="LEFT"/>dataset_preview : NoneType<br ALIGN="LEFT"/>dataset_tab<br ALIGN="LEFT"/>enhanced_training_button<br ALIGN="LEFT"/>epochs_spin : NoneType<br ALIGN="LEFT"/>export_dataset_button : NoneType<br ALIGN="LEFT"/>export_metrics_button : NoneType<br ALIGN="LEFT"/>gpu_info : dict<br ALIGN="LEFT"/>gradient_accum_spin : NoneType<br ALIGN="LEFT"/>help_button<br ALIGN="LEFT"/>knowledge_base : dict<br ALIGN="LEFT"/>learning_rate_spin : NoneType<br ALIGN="LEFT"/>load_preview_button : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>lora_alpha_spin : NoneType<br ALIGN="LEFT"/>lora_rank_spin : NoneType<br ALIGN="LEFT"/>metrics_tab<br ALIGN="LEFT"/>metrics_view : NoneType<br ALIGN="LEFT"/>model_format_combo : NoneType<br ALIGN="LEFT"/>model_path_button : NoneType<br ALIGN="LEFT"/>model_path_edit : NoneType<br ALIGN="LEFT"/>paraphrase_check : NoneType<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>preserve_labels_check : NoneType<br ALIGN="LEFT"/>preview_aug_button : NoneType<br ALIGN="LEFT"/>random_delete_check : NoneType<br ALIGN="LEFT"/>random_insert_check : NoneType<br ALIGN="LEFT"/>random_swap_check : NoneType<br ALIGN="LEFT"/>sample_count_spin : NoneType<br ALIGN="LEFT"/>save_model_button : NoneType<br ALIGN="LEFT"/>save_plot_button : NoneType<br ALIGN="LEFT"/>stop_button : NoneType<br ALIGN="LEFT"/>synonym_check : NoneType<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>train_button : NoneType<br ALIGN="LEFT"/>training_args : NoneType<br ALIGN="LEFT"/>training_config<br ALIGN="LEFT"/>training_device : NoneType, device, str<br ALIGN="LEFT"/>training_log : NoneType<br ALIGN="LEFT"/>training_tab<br ALIGN="LEFT"/>training_thread : NoneType<br ALIGN="LEFT"/>validate_dataset_button : NoneType<br ALIGN="LEFT"/>visualization_label : NoneType<br ALIGN="LEFT"/>|closeEvent(event)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_format_converter.ModelFormatConverter" [color="black", fontcolor="black", label=<{ModelFormatConverter|gpu_info : NoneType, dict<br ALIGN="LEFT"/>supported_conversions : dict<br ALIGN="LEFT"/>|analyze_model_architecture(model_path: Union[str, Path]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>convert_model(source_path: Union[str, Path], target_format: str, output_path: Optional[Union[str, Path]]): Optional[Path]<br ALIGN="LEFT"/>convert_model_with_automodel(source_path: Union[str, Path], target_format: str, model_type: str): Optional[Path]<br ALIGN="LEFT"/>get_model_info(model_path: Path): Dict[str, Any]<br ALIGN="LEFT"/>load_model_for_conversion(model_path: Union[str, Path], model_type: str): Optional[Any]<br ALIGN="LEFT"/>validate_conversion(original_path: Path, converted_path: Path, test_inputs: Optional[Dict[str, np.ndarray]], tolerance: float): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_fallback_chains.ModelHealth" [color="black", fontcolor="black", label=<{ModelHealth|avg_response_time : float<br ALIGN="LEFT"/>circuit_opened_at : Optional[datetime]<br ALIGN="LEFT"/>failure_count : int<br ALIGN="LEFT"/>is_circuit_open : bool<br ALIGN="LEFT"/>last_failure : Optional[datetime]<br ALIGN="LEFT"/>last_success : Optional[datetime]<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>recent_failures : List[FailureInfo]<br ALIGN="LEFT"/>success_count : int<br ALIGN="LEFT"/>total_requests : int<br ALIGN="LEFT"/>|get_success_rate(window_hours: int): float<br ALIGN="LEFT"/>should_retry(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_download_manager.ModelInfo" [color="black", fontcolor="black", label=<{ModelInfo|author : str<br ALIGN="LEFT"/>downloads : int<br ALIGN="LEFT"/>gated : bool<br ALIGN="LEFT"/>last_modified : Optional[datetime]<br ALIGN="LEFT"/>library_name : Optional[str]<br ALIGN="LEFT"/>likes : int<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>model_name : str<br ALIGN="LEFT"/>model_size : Optional[int]<br ALIGN="LEFT"/>pipeline_tag : Optional[str]<br ALIGN="LEFT"/>private : bool<br ALIGN="LEFT"/>tags : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.interface.ModelInfo" [color="black", fontcolor="black", label=<{ModelInfo|capabilities : list<br ALIGN="LEFT"/>checksum : Optional[str]<br ALIGN="LEFT"/>context_length : Optional[int]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>download_url : Optional[str]<br ALIGN="LEFT"/>format : str<br ALIGN="LEFT"/>local_path : Optional[str]<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>parameters : Optional[int]<br ALIGN="LEFT"/>provider : str<br ALIGN="LEFT"/>size_bytes : int<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'ModelInfo'<br ALIGN="LEFT"/>get_size_human_readable(): str<br ALIGN="LEFT"/>is_downloaded(): bool<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.test_model_integration.ModelIntegrationValidator" [color="black", fontcolor="black", label=<{ModelIntegrationValidator|llm_manager<br ALIGN="LEFT"/>results : dict<br ALIGN="LEFT"/>|create_mock_response(content: str): LLMResponse<br ALIGN="LEFT"/>create_test_binary_info()<br ALIGN="LEFT"/>create_test_protection()<br ALIGN="LEFT"/>run_all_tests(): dict<br ALIGN="LEFT"/>test_backend_creation(): bool<br ALIGN="LEFT"/>test_batch_testing(): bool<br ALIGN="LEFT"/>test_caching_system(): bool<br ALIGN="LEFT"/>test_model_comparison(): bool<br ALIGN="LEFT"/>test_performance_monitoring(): bool<br ALIGN="LEFT"/>test_quantization_support(): bool<br ALIGN="LEFT"/>test_script_generation(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_loading_dialog.ModelLoadingDialog" [color="black", fontcolor="black", label=<{ModelLoadingDialog|api_url_combo<br ALIGN="LEFT"/>llm_manager : NoneType<br ALIGN="LEFT"/>model_loaded<br ALIGN="LEFT"/>model_name_combo<br ALIGN="LEFT"/>models_list<br ALIGN="LEFT"/>priority_spin<br ALIGN="LEFT"/>progress_widget<br ALIGN="LEFT"/>provider_combo<br ALIGN="LEFT"/>|closeEvent(event)<br ALIGN="LEFT"/>create_loaded_models_tab()<br ALIGN="LEFT"/>create_new_model_tab()<br ALIGN="LEFT"/>get_next_id()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>load_new_model()<br ALIGN="LEFT"/>on_model_loaded(model_id: str)<br ALIGN="LEFT"/>refresh_loaded_models()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.model_loading_progress_widget.ModelLoadingItemWidget" [color="black", fontcolor="black", label=<{ModelLoadingItemWidget|cancel_btn<br ALIGN="LEFT"/>cancelled<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>name_label<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>set_completed(success: bool, error: Optional[str])<br ALIGN="LEFT"/>update_progress(progress: LoadingProgress)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.model_loading_progress_widget.ModelLoadingProgressWidget" [color="black", fontcolor="black", label=<{ModelLoadingProgressWidget|llm_manager : NoneType<br ALIGN="LEFT"/>loading_items : Dict[str, ModelLoadingItemWidget]<br ALIGN="LEFT"/>model_loaded<br ALIGN="LEFT"/>progress_callback<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>stats_text<br ALIGN="LEFT"/>tasks_container<br ALIGN="LEFT"/>tasks_layout<br ALIGN="LEFT"/>test_load_btn<br ALIGN="LEFT"/>update_timer : NoneType<br ALIGN="LEFT"/>|cancel_loading(model_id: str)<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>handle_completion_update(model_id: str, success: bool, error: Optional[str])<br ALIGN="LEFT"/>handle_progress_update(progress: LoadingProgress)<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>process_updates()<br ALIGN="LEFT"/>refresh_display()<br ALIGN="LEFT"/>setup_callbacks()<br ALIGN="LEFT"/>test_load_model()<br ALIGN="LEFT"/>update_statistics()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.lazy_model_loader.ModelLoadingStrategy" [color="black", fontcolor="black", label=<{ModelLoadingStrategy|<br ALIGN="LEFT"/>|<I>get_load_priority</I>(config: LLMConfig): int<br ALIGN="LEFT"/><I>should_preload</I>(config: LLMConfig): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" [color="black", fontcolor="black", label=<{ModelManager|backends : dict<br ALIGN="LEFT"/>cache<br ALIGN="LEFT"/>gpu_info : NoneType, dict<br ALIGN="LEFT"/>loaded_models : dict<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>model_metadata : dict<br ALIGN="LEFT"/>models_dir<br ALIGN="LEFT"/>repositories<br ALIGN="LEFT"/>|clear_cache()<br ALIGN="LEFT"/>evaluate_model_with_split(model_id: str, data: Any, labels: Any, test_size: float, random_state: int): Dict[str, Any]<br ALIGN="LEFT"/>get_available_backends(): List[str]<br ALIGN="LEFT"/>get_available_models(repository: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_available_repositories(): List[str]<br ALIGN="LEFT"/>get_cache_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_manager_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_model_info(model_id: str): Dict[str, Any]<br ALIGN="LEFT"/>get_model_path(model_id: str): str<br ALIGN="LEFT"/>import_api_model(model_name: str, api_config: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>import_local_model(file_path: str): Dict[str, Any]<br ALIGN="LEFT"/>list_models(): List[str]<br ALIGN="LEFT"/>load_model(model_id: str): Any<br ALIGN="LEFT"/>predict(model_id: str, input_data: Any): Any<br ALIGN="LEFT"/>predict_batch(model_id: str, batch_data: list): list<br ALIGN="LEFT"/>register_model(model_id: str, model_path: str, model_type: str, metadata: Dict[str, Any])<br ALIGN="LEFT"/>save_model(model: Any, path: str): bool<br ALIGN="LEFT"/>train_model(training_data: Any, model_type: str): bool<br ALIGN="LEFT"/>unload_model(model_id: str)<br ALIGN="LEFT"/>unregister_model(model_id: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.model_manager.ModelManager" [color="black", fontcolor="black", label=<{ModelManager|config : Dict[str, Any]<br ALIGN="LEFT"/>download_dir<br ALIGN="LEFT"/>repositories : Dict[str, ModelRepositoryInterface]<br ALIGN="LEFT"/>|get_available_models(repository_name: Optional[str]): List[ModelInfo]<br ALIGN="LEFT"/>get_available_repositories(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>get_model_details(model_id: str, repository_name: str): Optional[ModelInfo]<br ALIGN="LEFT"/>get_model_path(model_id: str, repository_name: str): Optional[str]<br ALIGN="LEFT"/>import_api_model(model_id: str, repository_name: str, progress_callback: Optional[Callable[[int, int], None]], complete_callback: Optional[Callable[[bool, str], None]]): bool<br ALIGN="LEFT"/>import_local_model(file_path: str): Optional[ModelInfo]<br ALIGN="LEFT"/>refresh_repositories()<br ALIGN="LEFT"/>remove_model(model_id: str, repository_name: str): bool<br ALIGN="LEFT"/>save_model(model: Any, path: str): bool<br ALIGN="LEFT"/>train_model(training_data: Any, model_type: str): bool<br ALIGN="LEFT"/>verify_model_integrity(model_path: str, expected_checksum: Optional[str]): Tuple[bool, str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_manager_dialog.ModelManagerDialog" [color="black", fontcolor="black", label=<{ModelManagerDialog|context_length_input<br ALIGN="LEFT"/>current_model : NoneType<br ALIGN="LEFT"/>custom_header<br ALIGN="LEFT"/>custom_url_input<br ALIGN="LEFT"/>deps_status_text<br ALIGN="LEFT"/>download_log<br ALIGN="LEFT"/>download_threads : dict<br ALIGN="LEFT"/>gpu_layers_input<br ALIGN="LEFT"/>host_input<br ALIGN="LEFT"/>model_info_text<br ALIGN="LEFT"/>models_table<br ALIGN="LEFT"/>port_input<br ALIGN="LEFT"/>progress_container<br ALIGN="LEFT"/>progress_layout<br ALIGN="LEFT"/>recommended_table<br ALIGN="LEFT"/>server_status_label<br ALIGN="LEFT"/>start_server_btn<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>status_timer<br ALIGN="LEFT"/>stop_server_btn<br ALIGN="LEFT"/>use_mlock_checkbox<br ALIGN="LEFT"/>use_mmap_checkbox<br ALIGN="LEFT"/>|add_download_log(message: str)<br ALIGN="LEFT"/>add_local_model()<br ALIGN="LEFT"/>check_dependencies()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>delete_selected_model()<br ALIGN="LEFT"/>download_custom_model()<br ALIGN="LEFT"/>download_model(model_url: str, model_name: str)<br ALIGN="LEFT"/>load_model(model_name: str)<br ALIGN="LEFT"/>load_selected_model()<br ALIGN="LEFT"/>on_download_finished(model_name: str, success: bool, progress_widget: QWidget)<br ALIGN="LEFT"/>populate_recommended_models()<br ALIGN="LEFT"/>refresh_models()<br ALIGN="LEFT"/>setup_download_tab(tab_widget)<br ALIGN="LEFT"/>setup_local_models_tab(tab_widget)<br ALIGN="LEFT"/>setup_server_tab(tab_widget)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_server()<br ALIGN="LEFT"/>stop_server()<br ALIGN="LEFT"/>unload_current_model()<br ALIGN="LEFT"/>update_model_info()<br ALIGN="LEFT"/>update_server_status()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.ModelMetrics" [color="black", fontcolor="black", label=<{ModelMetrics|accuracy : float<br ALIGN="LEFT"/>epoch : int<br ALIGN="LEFT"/>f1_score : float<br ALIGN="LEFT"/>loss : float<br ALIGN="LEFT"/>precision : float<br ALIGN="LEFT"/>recall : float<br ALIGN="LEFT"/>training_time : float<br ALIGN="LEFT"/>val_accuracy : float<br ALIGN="LEFT"/>val_loss : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_performance_monitor.ModelPerformanceMonitor" [color="black", fontcolor="black", label=<{ModelPerformanceMonitor|benchmarks : Dict[str, ModelBenchmark]<br ALIGN="LEFT"/>gpu_count : int<br ALIGN="LEFT"/>gpu_type : str<br ALIGN="LEFT"/>has_gpu : bool<br ALIGN="LEFT"/>has_nvidia_ml : bool<br ALIGN="LEFT"/>history_size : int<br ALIGN="LEFT"/>metrics_history : Dict[str, deque]<br ALIGN="LEFT"/>save_dir : Path<br ALIGN="LEFT"/>|clear_gpu_cache()<br ALIGN="LEFT"/>clear_metrics(model_id: Optional[str])<br ALIGN="LEFT"/>compare_models(model_ids: List[str], metric: str): Dict[str, Any]<br ALIGN="LEFT"/>end_inference(context: Dict[str, Any], tokens_generated: int, batch_size: int, sequence_length: int, error: Optional[str]): PerformanceMetrics<br ALIGN="LEFT"/>export_metrics(model_id: Optional[str], format: str): Optional[Path]<br ALIGN="LEFT"/>get_metrics_summary(model_id: str): Dict[str, Any]<br ALIGN="LEFT"/>optimize_for_monitoring(model: Any): Any<br ALIGN="LEFT"/>start_inference(model_id: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.ai_model_manager.ModelProvider" [color="black", fontcolor="black", label=<{ModelProvider|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.interface.ModelRepositoryInterface" [color="black", fontcolor="black", label=<{ModelRepositoryInterface|<br ALIGN="LEFT"/>|<I>authenticate</I>(): Tuple[bool, str]<br ALIGN="LEFT"/><I>download_model</I>(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/><I>get_available_models</I>(): List[ModelInfo]<br ALIGN="LEFT"/><I>get_model_details</I>(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_sharding.ModelShardingManager" [color="black", fontcolor="black", label=<{ModelShardingManager|device_count : int<br ALIGN="LEFT"/>device_properties : dict<br ALIGN="LEFT"/>gpu_type : NoneType, str<br ALIGN="LEFT"/>shard_configs : dict<br ALIGN="LEFT"/>unified_device : NoneType, device<br ALIGN="LEFT"/>|cleanup_memory()<br ALIGN="LEFT"/>create_device_map(model_config_or_path: Union[str, Dict], max_memory: Optional[Dict[int, str]], no_split_module_classes: Optional[List[str]], dtype: Optional[torch.dtype]): Dict[str, Any]<br ALIGN="LEFT"/>create_pipeline_parallel_groups(num_stages: Optional[int]): List[List[int]]<br ALIGN="LEFT"/>estimate_model_memory(model_config: Dict[str, Any], dtype: Optional[torch.dtype]): Dict[str, Any]<br ALIGN="LEFT"/>get_device_balance_score(device_map: Dict[str, Any]): float<br ALIGN="LEFT"/>get_sharding_info(): Dict[str, Any]<br ALIGN="LEFT"/>load_sharded_checkpoint(model: Any, checkpoint: Union[str, Path], device_map: Optional[Dict[str, Any]], max_memory: Optional[Dict[int, str]], no_split_module_classes: Optional[List[str]], dtype: Optional[torch.dtype]): Any<br ALIGN="LEFT"/>monitor_memory_usage(): Dict[int, Dict[str, float]]<br ALIGN="LEFT"/>optimize_device_map(device_map: Dict[str, Any], model_config: Dict[str, Any], layer_wise: bool): Dict[str, Any]<br ALIGN="LEFT"/>profile_model_distribution(model: Any, sample_input: Any, device_map: Dict[str, Any], num_iterations: int): Dict[str, Any]<br ALIGN="LEFT"/>shard_model(model: Any, device_map: Optional[Dict[str, Any]], max_memory: Optional[Dict[int, str]], offload_folder: Optional[str], offload_state_dict: bool): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.llm_config_dialog.ModelTestThread" [color="black", fontcolor="black", label=<{ModelTestThread|config : str<br ALIGN="LEFT"/>test_complete<br ALIGN="LEFT"/>test_progress<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.code_modification_dialog.ModificationAnalysisThread" [color="black", fontcolor="black", label=<{ModificationAnalysisThread|analysis_complete<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>modifier<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>request<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ModificationRequest" [color="black", fontcolor="black", label=<{ModificationRequest|constraints : List[str]<br ALIGN="LEFT"/>context_files : List[str]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>priority : str<br ALIGN="LEFT"/>request_id : str<br ALIGN="LEFT"/>requirements : List[str]<br ALIGN="LEFT"/>target_files : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ModificationType" [color="black", fontcolor="black", label=<{ModificationType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.MultiAgentSystem" [color="black", fontcolor="black", label=<{MultiAgentSystem|active : bool<br ALIGN="LEFT"/>agents : Dict[str, BaseAgent]<br ALIGN="LEFT"/>collaboration_stats : dict<br ALIGN="LEFT"/>knowledge_manager<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>message_router<br ALIGN="LEFT"/>task_distributor<br ALIGN="LEFT"/>|add_agent(agent: BaseAgent)<br ALIGN="LEFT"/>execute_collaborative_task(task: AgentTask): CollaborationResult<br ALIGN="LEFT"/>get_system_status(): Dict[str, Any]<br ALIGN="LEFT"/>remove_agent(agent_id: str)<br ALIGN="LEFT"/>route_message(message: AgentMessage)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.IntegratedBackgroundLoader.load_model_in_background.MultiCallback" [color="black", fontcolor="black", label=<{MultiCallback|callbacks<br ALIGN="LEFT"/>|on_completed(model_id, success, error)<br ALIGN="LEFT"/>on_progress(progress)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.multi_format_analyzer.MultiFormatBinaryAnalyzer" [color="black", fontcolor="black", label=<{MultiFormatBinaryAnalyzer|lief_available : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>macholib_available : bool<br ALIGN="LEFT"/>pefile_available : bool<br ALIGN="LEFT"/>pyelftools_available : bool<br ALIGN="LEFT"/>xml_available : bool<br ALIGN="LEFT"/>zipfile_available : bool<br ALIGN="LEFT"/>|analyze(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_apk(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_binary(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_com(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_dex(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_dotnet(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_elf(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_jar(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_java(_binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_macho(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_msi(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_pe(binary_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>identify_format(binary_path: Union[str, Path]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.progress_manager.MultiStageProgress" [color="black", fontcolor="black", label=<{MultiStageProgress|console : Console<br ALIGN="LEFT"/>current_stage : int<br ALIGN="LEFT"/>stages : List[Dict[str, Any]]<br ALIGN="LEFT"/>|add_stage(name: str, steps: List[str]): None<br ALIGN="LEFT"/>start(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.NLPCodeProcessor" [color="black", fontcolor="black", label=<{NLPCodeProcessor|business_keywords : dict<br ALIGN="LEFT"/>intent_keywords : dict<br ALIGN="LEFT"/>semantic_patterns : dict<br ALIGN="LEFT"/>vocabulary : dict<br ALIGN="LEFT"/>|extract_semantic_features(code: str, function_name: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor.NativeConcolicState" [color="black", fontcolor="black", label=<{NativeConcolicState|constraints : list<br ALIGN="LEFT"/>execution_trace : list<br ALIGN="LEFT"/>input_symbols : dict<br ALIGN="LEFT"/>is_terminated_flag : bool<br ALIGN="LEFT"/>memory : dict<br ALIGN="LEFT"/>pc : int<br ALIGN="LEFT"/>registers : dict<br ALIGN="LEFT"/>stack : list<br ALIGN="LEFT"/>symbolic_memory : dict<br ALIGN="LEFT"/>symbolic_registers : dict<br ALIGN="LEFT"/>termination_reason : NoneType, str<br ALIGN="LEFT"/>|add_constraint(constraint: str)<br ALIGN="LEFT"/>fork()<br ALIGN="LEFT"/>get_register(reg: str)<br ALIGN="LEFT"/>is_terminated(): bool<br ALIGN="LEFT"/>read_memory(addr: int, size: int)<br ALIGN="LEFT"/>set_register(reg: str, value, symbolic: bool)<br ALIGN="LEFT"/>terminate(reason: str)<br ALIGN="LEFT"/>write_memory(addr: int, value, size: int, symbolic: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.network_analysis_plugin.NetworkAnalysisPlugin" [color="black", fontcolor="black", label=<{NetworkAnalysisPlugin|capture_thread : NoneType<br ALIGN="LEFT"/>filter_expression : str<br ALIGN="LEFT"/>is_capturing : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>monitoring : bool<br ALIGN="LEFT"/>packet_queue : Queue<br ALIGN="LEFT"/>socket_monitor_thread : Thread<br ALIGN="LEFT"/>|analyze(binary_path)<br ALIGN="LEFT"/>analyze_socket_traffic(capture_file: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>cleanup_sockets()<br ALIGN="LEFT"/>create_socket_server(host: str, port: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_socket_apis(binary_path: str): List[str]<br ALIGN="LEFT"/>get_socket_info(sock: socket.socket): Dict[str, Any]<br ALIGN="LEFT"/>monitor_socket_activity(duration: int): Dict[str, Any]<br ALIGN="LEFT"/>monitor_traffic(target_process)<br ALIGN="LEFT"/>scan_ports(target_host: str, start_port: int, end_port: int, timeout: float): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.memory_forensics_engine.NetworkConnection" [color="black", fontcolor="black", label=<{NetworkConnection|create_time : str<br ALIGN="LEFT"/>local_addr : str<br ALIGN="LEFT"/>local_port : int<br ALIGN="LEFT"/>pid : int<br ALIGN="LEFT"/>process_name : str<br ALIGN="LEFT"/>protocol : str<br ALIGN="LEFT"/>remote_addr : str<br ALIGN="LEFT"/>remote_port : int<br ALIGN="LEFT"/>state : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.network_forensics_engine.NetworkForensicsEngine" [color="black", fontcolor="black", label=<{NetworkForensicsEngine|logger : NoneType, RootLogger<br ALIGN="LEFT"/>supported_formats : list<br ALIGN="LEFT"/>|analyze_capture(capture_path: Union[str, Path]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_live_traffic(interface: str, duration: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_protocols(packet_data: bytes): List[str]<br ALIGN="LEFT"/>extract_artifacts(traffic_data: bytes): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [color="black", fontcolor="black", label=<{NetworkLicenseServerEmulator|config : dict<br ALIGN="LEFT"/>dns_server : Optional[Any]<br ALIGN="LEFT"/>dns_socket : Optional[socket.socket]<br ALIGN="LEFT"/>license_hostnames : Dict[bytes, str], dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>port : int<br ALIGN="LEFT"/>protocol : str<br ALIGN="LEFT"/>protocol_fingerprints : Dict[str, Dict[str, Any]], dict<br ALIGN="LEFT"/>protocol_handlers : Dict[str, Any]<br ALIGN="LEFT"/>response_generator : NoneType, Optional[DynamicResponseGenerator]<br ALIGN="LEFT"/>response_templates : Dict[str, Dict[str, bytes]]<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server_thread : Optional[threading.Thread]<br ALIGN="LEFT"/>servers : List[socketserver.TCPServer]<br ALIGN="LEFT"/>ssl_interceptor : Optional[Any]<br ALIGN="LEFT"/>traffic_engine : NoneType, Optional[TrafficInterceptionEngine]<br ALIGN="LEFT"/>traffic_recorder : Optional[Any]<br ALIGN="LEFT"/>|analyze_captured_protocols(): Dict[str, Any]<br ALIGN="LEFT"/>export_learning_data(): Dict[str, Any]<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>get_traffic_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>import_learning_data(data: Dict[str, Any]): None<br ALIGN="LEFT"/>setup_dns_redirection_for_hosts(hostnames: List[str]): None<br ALIGN="LEFT"/>setup_transparent_proxy(target_host: str, target_port: int): bool<br ALIGN="LEFT"/>start(): bool<br ALIGN="LEFT"/>stop(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.traffic_analyzer.NetworkTrafficAnalyzer" [color="black", fontcolor="black", label=<{NetworkTrafficAnalyzer|captured_packets : list<br ALIGN="LEFT"/>capturing : bool<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>connections : dict<br ALIGN="LEFT"/>license_connections : list<br ALIGN="LEFT"/>license_patterns : list<br ALIGN="LEFT"/>license_ports : list<br ALIGN="LEFT"/>license_servers : set<br ALIGN="LEFT"/>local_networks : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>packets : list<br ALIGN="LEFT"/>|analyze_traffic(): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>generate_report(filename: Optional[str]): bool<br ALIGN="LEFT"/>get_results(): Dict[str, Any]<br ALIGN="LEFT"/>start_capture(interface: Optional[str]): bool<br ALIGN="LEFT"/>stop_capture(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_numpy_fallback.NumpyFallback" [color="black", fontcolor="black", label=<{NumpyFallback|ndarray : list<br ALIGN="LEFT"/>|array(data)<br ALIGN="LEFT"/>mean(data)<br ALIGN="LEFT"/>sum(data)<br ALIGN="LEFT"/>where(condition)<br ALIGN="LEFT"/>zeros(shape)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.import_checks.get_fallback_implementations.NumpyFallback" [color="black", fontcolor="black", label=<{NumpyFallback|ndarray : list<br ALIGN="LEFT"/>|array(data)<br ALIGN="LEFT"/>mean(data)<br ALIGN="LEFT"/>std(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ONNXBackend" [color="black", fontcolor="black", label=<{ONNXBackend|<br ALIGN="LEFT"/>|get_model_info(model: Any): Dict[str, Any]<br ALIGN="LEFT"/>load_model(model_path: str): Any<br ALIGN="LEFT"/>predict(model: Any, input_data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.ONNXLLMBackend" [color="black", fontcolor="black", label=<{ONNXLLMBackend|is_initialized : bool<br ALIGN="LEFT"/>session : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.os_detection_mixin.OSDetectionMixin" [color="black", fontcolor="black", label=<{OSDetectionMixin|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.OllamaBackend" [color="black", fontcolor="black", label=<{OllamaBackend|base_url<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_integration.OpenAIAdapter" [color="black", fontcolor="black", label=<{OpenAIAdapter|<br ALIGN="LEFT"/>|handle_tool_call(tool_name: str, parameters: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.OpenAIBackend" [color="black", fontcolor="black", label=<{OpenAIBackend|client : NoneType, OpenAI<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.openai_repository.OpenAIRepository" [color="black", fontcolor="black", label=<{OpenAIRepository|<br ALIGN="LEFT"/>|authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.openrouter_repository.OpenRouterRepository" [color="black", fontcolor="black", label=<{OpenRouterRepository|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|authenticate(): Tuple[bool, str]<br ALIGN="LEFT"/>download_model(model_id: str, destination_path: str): Tuple[bool, str]<br ALIGN="LEFT"/>get_available_models(): List[ModelInfo]<br ALIGN="LEFT"/>get_model_details(model_id: str): Optional[ModelInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.OperationType" [color="black", fontcolor="black", label=<{OperationType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.optimization_config.OptimizationManager" [color="black", fontcolor="black", label=<{OptimizationManager|active_optimizations : Dict[str, bool]<br ALIGN="LEFT"/>cache_stats : dict<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>gc_stats : dict<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>optimization_stats : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>|add_custom_rule(rule: OptimizationRule)<br ALIGN="LEFT"/>benchmark_optimizations(): Dict[str, float]<br ALIGN="LEFT"/>disable_rule(rule_name: str)<br ALIGN="LEFT"/>enable_rule(rule_name: str)<br ALIGN="LEFT"/>export_config(file_path: Path)<br ALIGN="LEFT"/>get_optimization_summary(): Dict[str, Any]<br ALIGN="LEFT"/>get_recommendations(): List[str]<br ALIGN="LEFT"/>import_config(file_path: Path)<br ALIGN="LEFT"/>optimize_cache_performance()<br ALIGN="LEFT"/>optimize_memory_usage()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.OptimizationResult" [color="black", fontcolor="black", label=<{OptimizationResult|after_metrics : Dict[str, float]<br ALIGN="LEFT"/>before_metrics : Dict[str, float]<br ALIGN="LEFT"/>details : str<br ALIGN="LEFT"/>improvement : float<br ALIGN="LEFT"/>optimization_type<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.optimization_config.OptimizationRule" [color="black", fontcolor="black", label=<{OptimizationRule|action : str<br ALIGN="LEFT"/>cooldown_seconds : int<br ALIGN="LEFT"/>custom_handler : Optional[Callable]<br ALIGN="LEFT"/>enabled : bool<br ALIGN="LEFT"/>last_triggered : Optional[datetime]<br ALIGN="LEFT"/>metric_name : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>threshold_type : str<br ALIGN="LEFT"/>threshold_value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.OptimizationRule" [color="black", fontcolor="black", label=<{OptimizationRule|avg_improvement : float<br ALIGN="LEFT"/>condition : str<br ALIGN="LEFT"/>enabled : bool<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>parameters : Dict[str, Any]<br ALIGN="LEFT"/>priority : int<br ALIGN="LEFT"/>rule_id : str<br ALIGN="LEFT"/>strategy<br ALIGN="LEFT"/>success_rate : float<br ALIGN="LEFT"/>times_applied : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.OptimizationStrategy" [color="black", fontcolor="black", label=<{OptimizationStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.OptimizationStrategy" [color="black", fontcolor="black", label=<{OptimizationStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.OptimizationType" [color="black", fontcolor="black", label=<{OptimizationType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.analysis_orchestrator.OrchestrationResult" [color="black", fontcolor="black", label=<{OrchestrationResult|binary_path : str<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>phases_completed : List[AnalysisPhase]<br ALIGN="LEFT"/>results : Dict[str, Any]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|add_error(phase: AnalysisPhase, error: str)<br ALIGN="LEFT"/>add_result(phase: AnalysisPhase, result: Any)<br ALIGN="LEFT"/>add_warning(phase: AnalysisPhase, warning: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.OutcomeType" [color="black", fontcolor="black", label=<{OutcomeType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.OutputStage" [color="black", fontcolor="black", label=<{OutputStage|output_path : Optional[str]<br ALIGN="LEFT"/>|process(input_data: PipelineData): PipelineData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.reporting.pdf_generator.PDFReportGenerator" [color="black", fontcolor="black", label=<{PDFReportGenerator|app : Optional[Any]<br ALIGN="LEFT"/>author : str<br ALIGN="LEFT"/>company : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>logo_path<br ALIGN="LEFT"/>matplotlib_available : bool<br ALIGN="LEFT"/>output_dir : str<br ALIGN="LEFT"/>pdfkit_available : bool<br ALIGN="LEFT"/>report_config : dict<br ALIGN="LEFT"/>reportlab_available : bool<br ALIGN="LEFT"/>sections : List[Dict[str, Any]]<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>|add_section(section_title: str, content: Optional[str]): int<br ALIGN="LEFT"/>add_subsection(section_index: int, title: str, content: Optional[str]): None<br ALIGN="LEFT"/>export_analysis(format_type: str, binary_path: Optional[str], analysis_results: Optional[Dict[str, Any]], output_path: Optional[str]): bool<br ALIGN="LEFT"/>generate_html_report(binary_path: str, analysis_results: Dict[str, Any], report_type: str): Optional[str]<br ALIGN="LEFT"/>generate_report(binary_path: Optional[str], analysis_results: Optional[Dict[str, Any]], report_type: str, output_path: Optional[str]): Optional[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.PEBManipulator" [color="black", fontcolor="black", label=<{PEBManipulator|PEB_BEING_DEBUGGED_OFFSET : int<br ALIGN="LEFT"/>PEB_HEAP_FLAGS_OFFSET : int<br ALIGN="LEFT"/>PEB_NT_GLOBAL_FLAG_OFFSET : int<br ALIGN="LEFT"/>kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ntdll<br ALIGN="LEFT"/>|get_peb_address(): Optional[int]<br ALIGN="LEFT"/>patch_all_peb_flags(): List[str]<br ALIGN="LEFT"/>patch_being_debugged_flag(): bool<br ALIGN="LEFT"/>patch_heap_flags(): bool<br ALIGN="LEFT"/>patch_nt_global_flag(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.PEFileModel" [color="black", fontcolor="black", label=<{PEFileModel|certificates : Optional[CodeSigningInfo]<br ALIGN="LEFT"/>entry_point : int<br ALIGN="LEFT"/>exports : List[ExportInfo], list<br ALIGN="LEFT"/>image_base : int<br ALIGN="LEFT"/>imports : List[ImportInfo], list<br ALIGN="LEFT"/>pe : Optional[pefile.PE]<br ALIGN="LEFT"/>sections : List[SectionInfo], list<br ALIGN="LEFT"/>structures : List[FileStructure], list<br ALIGN="LEFT"/>|get_certificates(): Optional[CodeSigningInfo]<br ALIGN="LEFT"/>get_exports(): List[ExportInfo]<br ALIGN="LEFT"/>get_file_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_imports(): List[ImportInfo]<br ALIGN="LEFT"/>get_section_at_offset(offset: int): Optional[SectionInfo]<br ALIGN="LEFT"/>get_section_at_rva(rva: int): Optional[SectionInfo]<br ALIGN="LEFT"/>get_sections(): List[SectionInfo]<br ALIGN="LEFT"/>get_structures(): List[FileStructure]<br ALIGN="LEFT"/>is_valid_offset(offset: int): bool<br ALIGN="LEFT"/>is_valid_rva(rva: int): bool<br ALIGN="LEFT"/>offset_to_rva(offset: int): Optional[int]<br ALIGN="LEFT"/>parse_file(): None<br ALIGN="LEFT"/>rva_to_offset(rva: int): Optional[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_structure_model.PEStructureItem" [color="black", fontcolor="black", label=<{PEStructureItem|child_items : list<br ALIGN="LEFT"/>item_data : Union[FileStructure, SectionInfo, str]<br ALIGN="LEFT"/>parent_item : NoneType<br ALIGN="LEFT"/>|append_child(item)<br ALIGN="LEFT"/>child(row: int)<br ALIGN="LEFT"/>child_count(): int<br ALIGN="LEFT"/>column_count(): int<br ALIGN="LEFT"/>data(column: int): Any<br ALIGN="LEFT"/>parent()<br ALIGN="LEFT"/>row(): int<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_structure_model.PEStructureModel" [color="black", fontcolor="black", label=<{PEStructureModel|pe_model : Optional[PEFileModel]<br ALIGN="LEFT"/>root_item<br ALIGN="LEFT"/>rva_selected<br ALIGN="LEFT"/>structure_selected<br ALIGN="LEFT"/>|columnCount(parent: QModelIndex): int<br ALIGN="LEFT"/>data(index: QModelIndex, role: int): Any<br ALIGN="LEFT"/>flags(index: QModelIndex): Qt.ItemFlag<br ALIGN="LEFT"/>get_item_offset_and_size(index: QModelIndex): tuple[Optional[int], Optional[int]]<br ALIGN="LEFT"/>get_item_rva(index: QModelIndex): Optional[int]<br ALIGN="LEFT"/>headerData(section: int, orientation: Qt.Orientation, role: int): Any<br ALIGN="LEFT"/>index(row: int, column: int, parent: QModelIndex): QModelIndex<br ALIGN="LEFT"/>parent(index: QModelIndex): QModelIndex<br ALIGN="LEFT"/>rowCount(parent: QModelIndex): int<br ALIGN="LEFT"/>set_pe_model(pe_model: PEFileModel)<br ALIGN="LEFT"/>setup_model_data()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector._check_mouse_movement.MockWintypes.POINT" [color="black", fontcolor="black", label=<{POINT|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.adobe_injector.PROCESS_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{PROCESS_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.PEBManipulator.get_peb_address.PROCESS_BASIC_INFORMATION" [color="black", fontcolor="black", label=<{PROCESS_BASIC_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.PROCESS_INFORMATION" [color="black", fontcolor="black", label=<{PROCESS_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_structures.WindowsProcessStructures.create_process_information.PROCESS_INFORMATION" [color="black", fontcolor="black", label=<{PROCESS_INFORMATION|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.cet_bypass.CETBypass._check_cet_status.PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY" [color="black", fontcolor="black", label=<{PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_pandas_fallback.PandasFallback" [color="black", fontcolor="black", label=<{PandasFallback|DataFrame<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.PanelType" [color="black", fontcolor="black", label=<{PanelType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.ParallelExecutor" [color="black", fontcolor="black", label=<{ParallelExecutor|execution_stats : dict<br ALIGN="LEFT"/>|execute_batch_parallel(operations: List[Tuple[Callable, tuple, dict]], max_workers: int): List[Any]<br ALIGN="LEFT"/>execute_parallel(func: Callable, items: List[Any], max_workers: int): List[Any]<br ALIGN="LEFT"/>get_execution_stats(): Dict[str, Any]<br ALIGN="LEFT"/>should_parallelize(item_count: int, estimated_time_per_item: float): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.ParallelPortEmulator" [color="black", fontcolor="black", label=<{ParallelPortEmulator|control_register : int<br ALIGN="LEFT"/>data_register : int<br ALIGN="LEFT"/>dongles : dict<br ALIGN="LEFT"/>inpout : WinDLL<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>port_address : int<br ALIGN="LEFT"/>port_backend : NoneType, str<br ALIGN="LEFT"/>status_register : int<br ALIGN="LEFT"/>win32file<br ALIGN="LEFT"/>|attach_dongle(dongle: BaseDongleEmulator)<br ALIGN="LEFT"/>read_port(port: int): int<br ALIGN="LEFT"/>write_port(port: int, value: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.PasteCommand" [color="black", fontcolor="black", label=<{PasteCommand|data : bytes<br ALIGN="LEFT"/>executed : bool<br ALIGN="LEFT"/>insert_mode : bool<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>old_data : Optional[bytes]<br ALIGN="LEFT"/>|execute(file_handler): bool<br ALIGN="LEFT"/>get_affected_range(): tuple<br ALIGN="LEFT"/>undo(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.patch_analyzer.PatchAnalyzer" [color="black", fontcolor="black", label=<{PatchAnalyzer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>patch_patterns : dict<br ALIGN="LEFT"/>|analyze_patch_file(patch_path: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_patch_series(patch_directory: str): Dict[str, Any]<br ALIGN="LEFT"/>compare_patches(patch1_path: str, patch2_path: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchEntry" [color="black", fontcolor="black", label=<{PatchEntry|architecture<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>original : bytes<br ALIGN="LEFT"/>pattern_name : str<br ALIGN="LEFT"/>replacement : bytes<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchGenerator" [color="black", fontcolor="black", label=<{PatchGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>pattern_db<br ALIGN="LEFT"/>|apply_patch(target_binary: str, patch_entries: List[Dict[str, Any]], create_backup: bool): bool<br ALIGN="LEFT"/>generate_patch(target_binary: str, patch_config: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>validate_patch(target_binary: str, patch_entries: List[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator_old.PatchGenerator" [color="black", fontcolor="black", label=<{PatchGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate_binary_patch(target_path: str, patch_type: str): Dict[str, Any]<br ALIGN="LEFT"/>validate_patch(patch_data: bytes, target_binary: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchPattern" [color="black", fontcolor="black", label=<{PatchPattern|architecture<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>context_required : bool<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>max_occurrences : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>pattern : bytes<br ALIGN="LEFT"/>replacement : bytes<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchResult" [color="black", fontcolor="black", label=<{PatchResult|architecture<br ALIGN="LEFT"/>checksum : str<br ALIGN="LEFT"/>entries : List[PatchEntry]<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>patch_type<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>target_path : str<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>total_size : int<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchType" [color="black", fontcolor="black", label=<{PatchType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.core.path_discovery.PathDiscovery" [color="black", fontcolor="black", label=<{PathDiscovery|cache : dict<br ALIGN="LEFT"/>config_manager : NoneType<br ALIGN="LEFT"/>is_linux<br ALIGN="LEFT"/>is_mac<br ALIGN="LEFT"/>is_windows<br ALIGN="LEFT"/>platform : str<br ALIGN="LEFT"/>system_paths : dict<br ALIGN="LEFT"/>tool_specs : dict<br ALIGN="LEFT"/>|ensure_tool_available(tool_name: str, parent_widget): Optional[str]<br ALIGN="LEFT"/>find_tool(tool_name: str, required_executables: Optional[List[str]]): Optional[str]<br ALIGN="LEFT"/>get_cuda_path(): Optional[str]<br ALIGN="LEFT"/>get_system_path(path_type: str): Optional[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.concolic_executor.ConcolicExecutionEngine.explore_paths.PathExplorationPlugin" [color="black", fontcolor="black", label=<{PathExplorationPlugin|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|did_finish_run_callback()<br ALIGN="LEFT"/>will_fork_state_callback(state)<br ALIGN="LEFT"/>will_run_callback()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.PatternCategory" [color="black", fontcolor="black", label=<{PatternCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.patching.patch_generator.PatternDatabase" [color="black", fontcolor="black", label=<{PatternDatabase|patterns : Dict[PatchType, List[PatchPattern]]<br ALIGN="LEFT"/>|get_patterns(patch_type: PatchType, architecture: Architecture): List[PatchPattern]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.PatternEvolutionEngine" [color="black", fontcolor="black", label=<{PatternEvolutionEngine|cache_ttl : int<br ALIGN="LEFT"/>database<br ALIGN="LEFT"/>evolution_threshold : float<br ALIGN="LEFT"/>last_cache_update : datetime<br ALIGN="LEFT"/>pattern_cache : Dict[str, List[PatternRule]]<br ALIGN="LEFT"/>|evolve_patterns(): Dict[str, Any]<br ALIGN="LEFT"/>get_applicable_patterns(context: Dict[str, Any]): List[PatternRule]<br ALIGN="LEFT"/>get_insights(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.PatternLibrary" [color="black", fontcolor="black", label=<{PatternLibrary|license_check_patterns : dict<br ALIGN="LEFT"/>|get_bypass_strategy(protection_type: ProtectionType): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine.PatternRule" [color="black", fontcolor="black", label=<{PatternRule|action : str<br ALIGN="LEFT"/>condition : str<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>effectiveness_score : float<br ALIGN="LEFT"/>last_used : Optional[datetime]<br ALIGN="LEFT"/>pattern_name : str<br ALIGN="LEFT"/>rule_id : str<br ALIGN="LEFT"/>success_rate : float<br ALIGN="LEFT"/>usage_count : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.learning_engine_simple.PatternRule" [color="black", fontcolor="black", label=<{PatternRule|action : str<br ALIGN="LEFT"/>effectiveness : float<br ALIGN="LEFT"/>last_used : datetime<br ALIGN="LEFT"/>pattern : str<br ALIGN="LEFT"/>rule_id : str<br ALIGN="LEFT"/>usage_count : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_engine.PayloadEngine" [color="black", fontcolor="black", label=<{PayloadEngine|api_obfuscator<br ALIGN="LEFT"/>assembly_compiler<br ALIGN="LEFT"/>cfi_bypass<br ALIGN="LEFT"/>debugger_detector<br ALIGN="LEFT"/>encoder_engine<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>payload_templates<br ALIGN="LEFT"/>polymorphic_engine<br ALIGN="LEFT"/>process_hollowing<br ALIGN="LEFT"/>sandbox_detector<br ALIGN="LEFT"/>shellcode_generator<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>timing_defense<br ALIGN="LEFT"/>vm_detector<br ALIGN="LEFT"/>|deploy_remote_payload(target_ip: str, target_port: int, payload: bytes, method: str, options: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>generate_payload(payload_type: PayloadType, architecture: Architecture, target_info: Dict[str, Any], options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>inject_binary_payload(target_binary: str, payload: bytes, injection_method: str): Dict[str, Any]<br ALIGN="LEFT"/>list_encoding_methods(): List[str]<br ALIGN="LEFT"/>list_payload_types(): List[str]<br ALIGN="LEFT"/>list_supported_architectures(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.payload_generator_dialog.PayloadGenerationThread" [color="black", fontcolor="black", label=<{PayloadGenerationThread|config<br ALIGN="LEFT"/>engine<br ALIGN="LEFT"/>error<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.payload_generator.PayloadGenerator" [color="black", fontcolor="black", label=<{PayloadGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|generate(payload_type: str): bytes<br ALIGN="LEFT"/>generate_nop_sled(length: int): bytes<br ALIGN="LEFT"/>generate_simple_payload(payload_type: str): Optional[bytes]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" [color="black", fontcolor="black", label=<{PayloadGeneratorDialog|api_hooks_check<br ALIGN="LEFT"/>api_obfuscation_check<br ALIGN="LEFT"/>asm_radio<br ALIGN="LEFT"/>close_btn<br ALIGN="LEFT"/>code_reorder_check<br ALIGN="LEFT"/>control_flow_check<br ALIGN="LEFT"/>current_payload : NoneType<br ALIGN="LEFT"/>custom_arch_combo<br ALIGN="LEFT"/>dead_code_check<br ALIGN="LEFT"/>debugger_detection_check<br ALIGN="LEFT"/>dll_wrapper_check<br ALIGN="LEFT"/>doc_macro_check<br ALIGN="LEFT"/>encoder_engine<br ALIGN="LEFT"/>encoder_list<br ALIGN="LEFT"/>encrypted_strings_check<br ALIGN="LEFT"/>entropy_label<br ALIGN="LEFT"/>exe_wrapper_check<br ALIGN="LEFT"/>garbage_insertion_check<br ALIGN="LEFT"/>generate_btn<br ALIGN="LEFT"/>generation_thread : NoneType<br ALIGN="LEFT"/>hash_label<br ALIGN="LEFT"/>hex_radio<br ALIGN="LEFT"/>info_layout<br ALIGN="LEFT"/>iterations_spin<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>metamorphic_check<br ALIGN="LEFT"/>null_bytes_label<br ALIGN="LEFT"/>null_free_check<br ALIGN="LEFT"/>output_display<br ALIGN="LEFT"/>output_format_combo<br ALIGN="LEFT"/>payload_engine<br ALIGN="LEFT"/>payload_generated<br ALIGN="LEFT"/>payload_type_combo<br ALIGN="LEFT"/>polymorphic_check<br ALIGN="LEFT"/>position_independent_check<br ALIGN="LEFT"/>powershell_check<br ALIGN="LEFT"/>register_rename_check<br ALIGN="LEFT"/>sandbox_detection_check<br ALIGN="LEFT"/>save_btn<br ALIGN="LEFT"/>shellcode_editor<br ALIGN="LEFT"/>size_label<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>template_engine<br ALIGN="LEFT"/>template_params : dict<br ALIGN="LEFT"/>test_btn<br ALIGN="LEFT"/>timing_checks_check<br ALIGN="LEFT"/>unicode_safe_check<br ALIGN="LEFT"/>vm_detection_check<br ALIGN="LEFT"/>xor_key_edit<br ALIGN="LEFT"/>|build_payload_config(): Dict[str, Any]<br ALIGN="LEFT"/>clear_layout(layout)<br ALIGN="LEFT"/>clear_template_params()<br ALIGN="LEFT"/>create_custom_tab()<br ALIGN="LEFT"/>create_encoding_tab()<br ALIGN="LEFT"/>create_evasion_tab()<br ALIGN="LEFT"/>create_hex_dump(data: bytes): str<br ALIGN="LEFT"/>create_output_tab()<br ALIGN="LEFT"/>create_template_tab()<br ALIGN="LEFT"/>format_c_array(data: bytes): str<br ALIGN="LEFT"/>format_powershell(data: bytes): str<br ALIGN="LEFT"/>format_python_string(data: bytes): str<br ALIGN="LEFT"/>generate_payload()<br ALIGN="LEFT"/>load_templates()<br ALIGN="LEFT"/>on_category_changed()<br ALIGN="LEFT"/>on_generation_error(error: str)<br ALIGN="LEFT"/>on_generation_finished(result: Dict[str, Any])<br ALIGN="LEFT"/>on_generation_progress(message: str)<br ALIGN="LEFT"/>on_template_selected(template_name: str)<br ALIGN="LEFT"/>save_payload()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>test_payload()<br ALIGN="LEFT"/>update_output_display()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.payload_result_handler.PayloadResultHandler" [color="black", fontcolor="black", label=<{PayloadResultHandler|results_cache : list<br ALIGN="LEFT"/>storage_path : str<br ALIGN="LEFT"/>|clear_results()<br ALIGN="LEFT"/>get_results(payload_id: Optional[str]): List[Dict[str, Any]]<br ALIGN="LEFT"/>handle_result(payload_info: Dict[str, Any], result: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>save_results(filename: Optional[str]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.exploitation.payload_result_handler.PayloadResultHandler" [color="black", fontcolor="black", label=<{PayloadResultHandler|<br ALIGN="LEFT"/>|process_payload_result(result: Dict[str, Any], output_func: Callable[[str], None], save_callback: Optional[Callable[[bytes, Dict[str, Any]], None]]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_templates.PayloadTemplates" [color="black", fontcolor="black", label=<{PayloadTemplates|anti_analysis_templates : dict<br ALIGN="LEFT"/>lateral_movement_templates : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>persistence_templates : dict<br ALIGN="LEFT"/>privilege_escalation_templates : dict<br ALIGN="LEFT"/>shell_templates : dict<br ALIGN="LEFT"/>steganography_templates : dict<br ALIGN="LEFT"/>|create_custom_template(name: str, category: str, description: str, parameters: List[str], implementations: Dict[str, Dict[str, str]]): bool<br ALIGN="LEFT"/>export_template(category: str, template_name: str): Optional[str]<br ALIGN="LEFT"/>get_template(category: str, template_name: str, architecture: Architecture): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_templates_by_category(category: str): List[str]<br ALIGN="LEFT"/>import_template(template_json: str): bool<br ALIGN="LEFT"/>list_templates(category: str): Dict[str, List[str]]<br ALIGN="LEFT"/>validate_template(template: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_types.PayloadType" [color="black", fontcolor="black", label=<{PayloadType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.PendingAction" [color="black", fontcolor="black", label=<{PendingAction|action_id : str<br ALIGN="LEFT"/>action_type<br ALIGN="LEFT"/>ai_reasoning : Optional[str]<br ALIGN="LEFT"/>command : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>potential_impacts : List[str]<br ALIGN="LEFT"/>risk_level : str<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.optimization_config.PerformanceConfig" [color="black", fontcolor="black", label=<{PerformanceConfig|cache_config<br ALIGN="LEFT"/>enable_cache_optimization : bool<br ALIGN="LEFT"/>enable_gc_optimization : bool<br ALIGN="LEFT"/>enable_monitoring : bool<br ALIGN="LEFT"/>gc_threshold_mb : float<br ALIGN="LEFT"/>max_history_size : int<br ALIGN="LEFT"/>monitoring_interval : float<br ALIGN="LEFT"/>optimization_rules : List[OptimizationRule]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceLevel" [color="black", fontcolor="black", label=<{PerformanceLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor.PerformanceMetric" [color="black", fontcolor="black", label=<{PerformanceMetric|category : str<br ALIGN="LEFT"/>context : Dict[str, Any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>unit : str<br ALIGN="LEFT"/>value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceMetric" [color="black", fontcolor="black", label=<{PerformanceMetric|component : str<br ALIGN="LEFT"/>details : Dict[str, Any]<br ALIGN="LEFT"/>resource_type<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_performance_monitor.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|batch_size : int<br ALIGN="LEFT"/>cpu_percent : float<br ALIGN="LEFT"/>device : str<br ALIGN="LEFT"/>error : Optional[str]<br ALIGN="LEFT"/>gpu_memory_mb : float<br ALIGN="LEFT"/>gpu_percent : float<br ALIGN="LEFT"/>inference_time : float<br ALIGN="LEFT"/>memory_used_mb : float<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>quantization : Optional[str]<br ALIGN="LEFT"/>sequence_length : int<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>tokens_generated : int<br ALIGN="LEFT"/>tokens_per_second : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.PerformanceMetrics" [color="black", fontcolor="black", label=<{PerformanceMetrics|<br ALIGN="LEFT"/>|auc_roc(y_true: List[int], y_scores: List[float]): float<br ALIGN="LEFT"/>confusion_matrix_metrics(tp: int, tn: int, fp: int, fn: int): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor.PerformanceMonitor" [color="black", fontcolor="black", label=<{PerformanceMonitor|active_operations : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>baseline_memory : int<br ALIGN="LEFT"/>cache_ttl : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_history : int<br ALIGN="LEFT"/>metrics : Dict[str, deque]<br ALIGN="LEFT"/>optimization_rules : List[Callable]<br ALIGN="LEFT"/>performance_cache : Dict[str, Any]<br ALIGN="LEFT"/>process : NoneType, Process<br ALIGN="LEFT"/>profiles : deque<br ALIGN="LEFT"/>start_time<br ALIGN="LEFT"/>thresholds : dict<br ALIGN="LEFT"/>|add_optimization_rule(rule: Callable[[str, str, float], None])<br ALIGN="LEFT"/>cache_result(cache_key: str, result: Any)<br ALIGN="LEFT"/>export_metrics(file_path: Path, format: str)<br ALIGN="LEFT"/>get_cached_result(cache_key: str): Optional[Any]<br ALIGN="LEFT"/>get_metrics_summary(time_window: Optional[timedelta]): Dict[str, Any]<br ALIGN="LEFT"/>get_performance_recommendations(): List[str]<br ALIGN="LEFT"/>optimize_cache()<br ALIGN="LEFT"/>profile_operation(operation_name: str, metadata: Dict[str, Any])<br ALIGN="LEFT"/>record_metric(name: str, value: float, unit: str, category: str, context: Dict[str, Any])<br ALIGN="LEFT"/>start_monitoring(interval: float)<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>time_function(func_name: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor_simple.PerformanceMonitor" [color="black", fontcolor="black", label=<{PerformanceMonitor|error_counts : defaultdict<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>metrics : defaultdict<br ALIGN="LEFT"/>operation_counts : defaultdict<br ALIGN="LEFT"/>start_times : dict<br ALIGN="LEFT"/>|end_operation(operation_id: str, operation_name: str, success: bool)<br ALIGN="LEFT"/>get_stats(operation_name: str): Dict[str, Any]<br ALIGN="LEFT"/>start_operation(operation_name: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.PerformanceMonitor" [color="black", fontcolor="black", label=<{PerformanceMonitor|counters : defaultdict<br ALIGN="LEFT"/>histograms : defaultdict<br ALIGN="LEFT"/>metrics : dict<br ALIGN="LEFT"/>start_times : dict<br ALIGN="LEFT"/>|end_timer(timer_id: str, metadata: Dict)<br ALIGN="LEFT"/>get_metrics_summary(): Dict[str, Any]<br ALIGN="LEFT"/>increment_counter(metric: str, value: int, tags: Dict)<br ALIGN="LEFT"/>record_gauge(metric: str, value: float, tags: Dict)<br ALIGN="LEFT"/>reset_metrics()<br ALIGN="LEFT"/>start_timer(operation: str): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.performance_monitor.PerformanceMonitor" [color="black", fontcolor="black", label=<{PerformanceMonitor|file_handler : NoneType<br ALIGN="LEFT"/>widget : NoneType<br ALIGN="LEFT"/>|create_widget(parent): Optional[QWidget]<br ALIGN="LEFT"/>get_stats_summary(): Dict[str, Any]<br ALIGN="LEFT"/>set_file_handler(file_handler)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" [color="black", fontcolor="black", label=<{PerformanceMonitor|process : Process<br ALIGN="LEFT"/>start_cpu : NoneType, float<br ALIGN="LEFT"/>start_memory : NoneType<br ALIGN="LEFT"/>start_time : NoneType<br ALIGN="LEFT"/>|start_monitoring()<br ALIGN="LEFT"/>stop_monitoring(): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.PerformanceOptimizationLayer" [color="black", fontcolor="black", label=<{PerformanceOptimizationLayer|cache_manager<br ALIGN="LEFT"/>optimizer<br ALIGN="LEFT"/>parallel_executor<br ALIGN="LEFT"/>resource_manager<br ALIGN="LEFT"/>|allocate_resources(operation_id: str, requirements: ResourceAllocation): bool<br ALIGN="LEFT"/>execute_parallel(func: Callable, items: List[Any], max_workers: int): List[Any]<br ALIGN="LEFT"/>get_comprehensive_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize(operation_id: str, operation_func: Callable): Any<br ALIGN="LEFT"/>release_resources(operation_id: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.PerformanceOptimizer" [color="black", fontcolor="black", label=<{PerformanceOptimizer|cache_manager<br ALIGN="LEFT"/>execution_profiles : Dict[str, PerformanceProfile]<br ALIGN="LEFT"/>optimization_cache : Dict[str, Any]<br ALIGN="LEFT"/>optimization_rules : List[OptimizationRule], list<br ALIGN="LEFT"/>optimization_stats : dict<br ALIGN="LEFT"/>parallel_executor<br ALIGN="LEFT"/>resource_manager<br ALIGN="LEFT"/>|get_optimization_recommendations(operation_id: str): List[str]<br ALIGN="LEFT"/>get_optimization_stats(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_operation(operation_id: str, operation_func: Callable): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [color="black", fontcolor="black", label=<{PerformanceOptimizer|adaptive_optimizer<br ALIGN="LEFT"/>cache_manager<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>db_optimizer : NoneType<br ALIGN="LEFT"/>gpu_optimizer<br ALIGN="LEFT"/>io_optimizer<br ALIGN="LEFT"/>is_monitoring : bool<br ALIGN="LEFT"/>memory_pool<br ALIGN="LEFT"/>optimization_level<br ALIGN="LEFT"/>optimization_results : list<br ALIGN="LEFT"/>profiler<br ALIGN="LEFT"/>thread_optimizer<br ALIGN="LEFT"/>|get_performance_report(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_all(): Dict[OptimizationType, OptimizationResult]<br ALIGN="LEFT"/>optimize_component(component_type: OptimizationType): OptimizationResult<br ALIGN="LEFT"/>performance_context(component_name: str)<br ALIGN="LEFT"/>set_optimization_level(level: PerformanceLevel)<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.PerformanceOptimizer" [color="black", fontcolor="black", label=<{PerformanceOptimizer|adaptive_analyzer<br ALIGN="LEFT"/>binary_chunker<br ALIGN="LEFT"/>cache_manager<br ALIGN="LEFT"/>memory_manager<br ALIGN="LEFT"/>|optimize_analysis(file_path: str, analysis_functions: List[callable]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_monitor.PerformanceProfile" [color="black", fontcolor="black", label=<{PerformanceProfile|cpu_usage : float<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>operation_name : str<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.PerformanceProfile" [color="black", fontcolor="black", label=<{PerformanceProfile|cache_hit_rate : float<br ALIGN="LEFT"/>cpu_usage : float<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>io_operations : int<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>operation_id : str<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>optimization_suggestions : List[str]<br ALIGN="LEFT"/>parallelization_potential : float<br ALIGN="LEFT"/>resource_bottlenecks : List[ResourceType]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.PerformanceProfile" [color="black", fontcolor="black", label=<{PerformanceProfile|analysis_level<br ALIGN="LEFT"/>cache_enabled : bool<br ALIGN="LEFT"/>chunk_size : int<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>max_file_size : int<br ALIGN="LEFT"/>memory_limit : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>optimization_flags : List[str]<br ALIGN="LEFT"/>parallel_workers : int<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceProfiler" [color="black", fontcolor="black", label=<{PerformanceProfiler|last_cpu_times : pcputimes<br ALIGN="LEFT"/>last_io_counters : pio<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>metrics_history : defaultdict<br ALIGN="LEFT"/>process : Process<br ALIGN="LEFT"/>profile_data : dict<br ALIGN="LEFT"/>profiling_active : bool<br ALIGN="LEFT"/>|get_current_metrics(): Dict[str, float]<br ALIGN="LEFT"/>start_profiling()<br ALIGN="LEFT"/>stop_profiling(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.analysis_stats.PerformanceTracker" [color="black", fontcolor="black", label=<{PerformanceTracker|metrics : dict<br ALIGN="LEFT"/>start_times : dict<br ALIGN="LEFT"/>|end_operation(operation_name: str, item_count: int)<br ALIGN="LEFT"/>get_metrics(): Dict[str, Any]<br ALIGN="LEFT"/>reset_metrics()<br ALIGN="LEFT"/>start_operation(operation_name: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.performance_monitor.PerformanceWidget" [color="black", fontcolor="black", label=<{PerformanceWidget|avg_read_time_label : NoneType<br ALIGN="LEFT"/>background_loader_status : NoneType<br ALIGN="LEFT"/>cache_hit_rate_label : NoneType<br ALIGN="LEFT"/>cache_hits_label : NoneType<br ALIGN="LEFT"/>cache_memory_label : NoneType<br ALIGN="LEFT"/>cache_misses_label : NoneType<br ALIGN="LEFT"/>cache_progress : NoneType<br ALIGN="LEFT"/>cache_regions_label : NoneType<br ALIGN="LEFT"/>cache_utilization_label : NoneType<br ALIGN="LEFT"/>clear_stats_button : NoneType<br ALIGN="LEFT"/>file_handler : NoneType<br ALIGN="LEFT"/>file_size_label : NoneType<br ALIGN="LEFT"/>large_read_label : NoneType<br ALIGN="LEFT"/>loading_strategy_label : NoneType<br ALIGN="LEFT"/>max_history : int<br ALIGN="LEFT"/>memory_limit_label : NoneType<br ALIGN="LEFT"/>memory_progress : NoneType<br ALIGN="LEFT"/>memory_strategy_label : NoneType<br ALIGN="LEFT"/>memory_used_label : NoneType<br ALIGN="LEFT"/>optimization_status : NoneType<br ALIGN="LEFT"/>optimize_button : NoneType<br ALIGN="LEFT"/>pattern_table : NoneType<br ALIGN="LEFT"/>random_count_label : NoneType<br ALIGN="LEFT"/>read_operations_label : NoneType<br ALIGN="LEFT"/>sequential_count_label : NoneType<br ALIGN="LEFT"/>sequential_ratio_label : NoneType<br ALIGN="LEFT"/>stats_history : list<br ALIGN="LEFT"/>system_memory_label : NoneType<br ALIGN="LEFT"/>system_memory_progress : NoneType<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>update_timer<br ALIGN="LEFT"/>|auto_optimize()<br ALIGN="LEFT"/>clear_stats()<br ALIGN="LEFT"/>create_cache_tab()<br ALIGN="LEFT"/>create_controls()<br ALIGN="LEFT"/>create_memory_tab()<br ALIGN="LEFT"/>create_overview_tab()<br ALIGN="LEFT"/>create_patterns_tab()<br ALIGN="LEFT"/>set_file_handler(file_handler)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_cache_tab(stats: Dict[str, Any])<br ALIGN="LEFT"/>update_display()<br ALIGN="LEFT"/>update_memory_tab(stats: Dict[str, Any])<br ALIGN="LEFT"/>update_overview_tab(stats: Dict[str, Any])<br ALIGN="LEFT"/>update_patterns_tab(stats: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.persistence_manager.PersistenceManager" [color="black", fontcolor="black", label=<{PersistenceManager|active_sessions : dict<br ALIGN="LEFT"/>linux_handler : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>method_rankings : dict<br ALIGN="LEFT"/>windows_handler : NoneType<br ALIGN="LEFT"/>|establish_persistence(payload_path: str, target_os: Optional[str], privilege_level: str, stealth_level: str, redundancy: int, options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_available_methods(target_os: Optional[str]): Dict[str, List[str]]<br ALIGN="LEFT"/>get_default_method(): str<br ALIGN="LEFT"/>get_method_info(target_os: str, method: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_session_details(session_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>list_active_sessions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>list_available_methods(): list<br ALIGN="LEFT"/>recommend_methods(target_os: str, privilege_level: str, stealth_level: str, count: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>remove_persistence(session_id: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.Pipeline" [color="black", fontcolor="black", label=<{Pipeline|console : Console<br ALIGN="LEFT"/>stages : List[PipelineStage]<br ALIGN="LEFT"/>|add_stage(stage: PipelineStage): 'Pipeline'<br ALIGN="LEFT"/>execute(initial_input: Union[str, Dict, PipelineData]): PipelineData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.PipelineData" [color="black", fontcolor="black", label=<{PipelineData|content : Any<br ALIGN="LEFT"/>format : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>|from_json(json_str: str): 'PipelineData'<br ALIGN="LEFT"/>to_json(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.PipelineStage" [color="black", fontcolor="black", label=<{PipelineStage|console : Console<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|<I>process</I>(input_data: PipelineData): PipelineData<br ALIGN="LEFT"/>validate_input(input_data: PipelineData): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ci_cd_dialog.PipelineThread" [color="black", fontcolor="black", label=<{PipelineThread|error<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>log_message<br ALIGN="LEFT"/>pipeline<br ALIGN="LEFT"/>plugin_path : str<br ALIGN="LEFT"/>stage_completed<br ALIGN="LEFT"/>stage_started<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.simconcolic.Plugin" [color="black", fontcolor="black", label=<{Plugin|analysis_metadata : dict<br ALIGN="LEFT"/>analysis_start_time<br ALIGN="LEFT"/>analyzer : NoneType<br ALIGN="LEFT"/>fork_count : int<br ALIGN="LEFT"/>fork_history : list<br ALIGN="LEFT"/>terminated_states : list<br ALIGN="LEFT"/>termination_pending : dict<br ALIGN="LEFT"/>total_states_analyzed : int<br ALIGN="LEFT"/>|did_finish_run_callback()<br ALIGN="LEFT"/>did_terminate_state_callback(state)<br ALIGN="LEFT"/>will_fork_state_callback(state)<br ALIGN="LEFT"/>will_run_callback()<br ALIGN="LEFT"/>will_terminate_state_callback(state)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.plugin_base.PluginConfigManager" [color="black", fontcolor="black", label=<{PluginConfigManager|config<br ALIGN="LEFT"/>|get(key: str, default: Any): Any<br ALIGN="LEFT"/>set(key: str, value: Any): None<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>update(updates: Dict[str, Any]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [color="black", fontcolor="black", label=<{PluginCreationWizard|code_page<br ALIGN="LEFT"/>features_page<br ALIGN="LEFT"/>info_page<br ALIGN="LEFT"/>plugin_created<br ALIGN="LEFT"/>plugin_type : str<br ALIGN="LEFT"/>summary_page<br ALIGN="LEFT"/>template_page<br ALIGN="LEFT"/>|accept()<br ALIGN="LEFT"/>generate_code_from_template(info, template, features)<br ALIGN="LEFT"/>generate_frida_code(info, template, features)<br ALIGN="LEFT"/>generate_ghidra_code(info, template, features)<br ALIGN="LEFT"/>generate_plugin_code()<br ALIGN="LEFT"/>generate_python_code(info, template, features)<br ALIGN="LEFT"/>on_page_changed(page_id)<br ALIGN="LEFT"/>save_plugin(plugin_data)<br ALIGN="LEFT"/>update_summary()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.PluginDebugger" [color="black", fontcolor="black", label=<{PluginDebugger|breakpoints : Dict[int, Breakpoint]<br ALIGN="LEFT"/>call_history : list<br ALIGN="LEFT"/>call_stack : list<br ALIGN="LEFT"/>command_queue : Queue<br ALIGN="LEFT"/>current_frame : NoneType<br ALIGN="LEFT"/>exception_breakpoint : bool<br ALIGN="LEFT"/>exception_filters : list<br ALIGN="LEFT"/>exception_history : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>next_breakpoint_id : int<br ALIGN="LEFT"/>output_queue : Queue<br ALIGN="LEFT"/>plugin_module : NoneType, module<br ALIGN="LEFT"/>return_history : list<br ALIGN="LEFT"/>stack_frames : list<br ALIGN="LEFT"/>state : IDLE, PAUSED, RUNNING, STEPPING, TERMINATED<br ALIGN="LEFT"/>step_mode : NoneType, str<br ALIGN="LEFT"/>trace_calls : bool<br ALIGN="LEFT"/>trace_returns : bool<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>watched_returns : list<br ALIGN="LEFT"/>watched_variables : dict<br ALIGN="LEFT"/>|add_breakpoint(file: str, line: int, function: str, condition: str, type: BreakpointType): int<br ALIGN="LEFT"/>disable_breakpoint(bp_id: int)<br ALIGN="LEFT"/>enable_breakpoint(bp_id: int)<br ALIGN="LEFT"/>get_source_code(filename: str, start_line: int, end_line: int): List[str]<br ALIGN="LEFT"/>get_variables(frame_index: int): Dict[str, Any]<br ALIGN="LEFT"/>load_plugin(plugin_path: str)<br ALIGN="LEFT"/>remove_breakpoint(bp_id: int)<br ALIGN="LEFT"/>run(binary_path: str, options: Dict[str, Any])<br ALIGN="LEFT"/>set_exception_breakpoint(enabled: bool)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_dialog_base.PluginDialogBase" [color="black", fontcolor="black", label=<{PluginDialogBase|plugin_label : NoneType<br ALIGN="LEFT"/>plugin_path : Optional[str]<br ALIGN="LEFT"/>|browse_plugin()<br ALIGN="LEFT"/>create_plugin_selection_layout()<br ALIGN="LEFT"/><I>init_dialog</I>()<br ALIGN="LEFT"/>load_plugin(plugin_path: str)<br ALIGN="LEFT"/>on_plugin_loaded(plugin_path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.plugin_editor.PluginEditor" [color="black", fontcolor="black", label=<{PluginEditor|current_file : NoneType<br ALIGN="LEFT"/>editor<br ALIGN="LEFT"/>file_label<br ALIGN="LEFT"/>highlighter : NoneType<br ALIGN="LEFT"/>outline_list<br ALIGN="LEFT"/>saveRequested<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>syntax_combo<br ALIGN="LEFT"/>textChanged<br ALIGN="LEFT"/>validationComplete<br ALIGN="LEFT"/>validation_list<br ALIGN="LEFT"/>validation_timer<br ALIGN="LEFT"/>validator<br ALIGN="LEFT"/>|change_syntax(syntax)<br ALIGN="LEFT"/>get_code()<br ALIGN="LEFT"/>new_file()<br ALIGN="LEFT"/>on_text_changed()<br ALIGN="LEFT"/>open_file()<br ALIGN="LEFT"/>perform_validation()<br ALIGN="LEFT"/>save_file()<br ALIGN="LEFT"/>set_code(code)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_context_menu(position)<br ALIGN="LEFT"/>show_find_dialog()<br ALIGN="LEFT"/>update_code_outline()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_editor_dialog.PluginEditorDialog" [color="black", fontcolor="black", label=<{PluginEditorDialog|api_list<br ALIGN="LEFT"/>ci_cd_btn<br ALIGN="LEFT"/>clear_btn<br ALIGN="LEFT"/>debug_btn<br ALIGN="LEFT"/>docs_viewer<br ALIGN="LEFT"/>docs_widget<br ALIGN="LEFT"/>editor<br ALIGN="LEFT"/>plugin_path : NoneType<br ALIGN="LEFT"/>plugin_saved<br ALIGN="LEFT"/>run_btn<br ALIGN="LEFT"/>run_test_btn<br ALIGN="LEFT"/>stop_test_btn<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>test_file_edit<br ALIGN="LEFT"/>test_gen_btn<br ALIGN="LEFT"/>test_output<br ALIGN="LEFT"/>test_process : NoneType<br ALIGN="LEFT"/>test_widget<br ALIGN="LEFT"/>verbose_check<br ALIGN="LEFT"/>|browse_test_file()<br ALIGN="LEFT"/>debug_plugin()<br ALIGN="LEFT"/>generate_tests()<br ALIGN="LEFT"/>get_api_documentation(topic)<br ALIGN="LEFT"/>handle_stderr()<br ALIGN="LEFT"/>handle_stdout()<br ALIGN="LEFT"/>load_plugin(path)<br ALIGN="LEFT"/>on_plugin_saved(path)<br ALIGN="LEFT"/>on_validation_complete(results)<br ALIGN="LEFT"/>open_ci_cd()<br ALIGN="LEFT"/>run_plugin()<br ALIGN="LEFT"/>run_test()<br ALIGN="LEFT"/>save_plugin()<br ALIGN="LEFT"/>setup_docs_tab()<br ALIGN="LEFT"/>setup_test_tab()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_api_docs(current, previous)<br ALIGN="LEFT"/>stop_test()<br ALIGN="LEFT"/>test_finished(exit_code, exit_status)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.PluginFeaturesPage" [color="black", fontcolor="black", label=<{PluginFeaturesPage|async_check<br ALIGN="LEFT"/>error_handling_check<br ALIGN="LEFT"/>feature_checks : dict<br ALIGN="LEFT"/>logging_check<br ALIGN="LEFT"/>|get_selected_features()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.PluginInfoPage" [color="black", fontcolor="black", label=<{PluginInfoPage|author_edit<br ALIGN="LEFT"/>category_combo<br ALIGN="LEFT"/>description_edit<br ALIGN="LEFT"/>name_edit<br ALIGN="LEFT"/>version_edit<br ALIGN="LEFT"/>|get_plugin_info()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_manager_dialog.PluginInstallThread" [color="black", fontcolor="black", label=<{PluginInstallThread|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginManager" [color="black", fontcolor="black", label=<{PluginManager|auto_discover<br ALIGN="LEFT"/>auto_load<br ALIGN="LEFT"/>config : Dict[str, Any]<br ALIGN="LEFT"/>disabled_plugins : set<br ALIGN="LEFT"/>discovery_paths<br ALIGN="LEFT"/>enabled_plugins : set<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>load_order : List[str]<br ALIGN="LEFT"/>logger : Logger<br ALIGN="LEFT"/>plugin_dependencies : Dict[str, List[str]]<br ALIGN="LEFT"/>plugin_metadata : Dict[str, PluginMetadata]<br ALIGN="LEFT"/>plugins : Dict[str, AbstractPlugin]<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|activate_plugin(plugin_name: str): bool<br ALIGN="LEFT"/>deactivate_plugin(plugin_name: str): bool<br ALIGN="LEFT"/>discover_plugins(): List[str]<br ALIGN="LEFT"/>get_plugin(plugin_name: str): Optional[AbstractPlugin]<br ALIGN="LEFT"/>get_plugin_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_plugins_by_capability(capability: str): List[AbstractPlugin]<br ALIGN="LEFT"/>get_plugins_by_type(component_type: ComponentType): List[AbstractPlugin]<br ALIGN="LEFT"/>load_all_plugins(): int<br ALIGN="LEFT"/>load_plugin(plugin_name: str): bool<br ALIGN="LEFT"/>unload_plugin(plugin_name: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_manager_dialog.PluginManagerDialog" [color="black", fontcolor="black", label=<{PluginManagerDialog|author_edit : NoneType<br ALIGN="LEFT"/>auto_enable : NoneType<br ALIGN="LEFT"/>available_list : NoneType<br ALIGN="LEFT"/>backup_existing : NoneType<br ALIGN="LEFT"/>configure_btn : NoneType<br ALIGN="LEFT"/>disable_btn : NoneType<br ALIGN="LEFT"/>enable_btn : NoneType<br ALIGN="LEFT"/>file_path_edit : NoneType<br ALIGN="LEFT"/>install_btn : NoneType<br ALIGN="LEFT"/>install_thread : NoneType<br ALIGN="LEFT"/>installed_list : NoneType<br ALIGN="LEFT"/>parent : NoneType<br ALIGN="LEFT"/>plugin_details : NoneType<br ALIGN="LEFT"/>plugin_info : NoneType<br ALIGN="LEFT"/>plugin_name_edit : NoneType<br ALIGN="LEFT"/>plugin_type_combo : NoneType<br ALIGN="LEFT"/>preview_btn : NoneType<br ALIGN="LEFT"/>progress_bar : NoneType<br ALIGN="LEFT"/>remove_btn : NoneType<br ALIGN="LEFT"/>repo_combo : NoneType<br ALIGN="LEFT"/>status_label : NoneType<br ALIGN="LEFT"/>test_file_edit : NoneType<br ALIGN="LEFT"/>test_output : NoneType<br ALIGN="LEFT"/>|exec()<br ALIGN="LEFT"/>exec_()<br ALIGN="LEFT"/><I>show</I>()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.plugin_base.PluginMetadata" [color="black", fontcolor="black", label=<{PluginMetadata|author : str<br ALIGN="LEFT"/>capabilities : list<br ALIGN="LEFT"/>categories : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>supported_formats : list<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginMetadata" [color="black", fontcolor="black", label=<{PluginMetadata|author : str<br ALIGN="LEFT"/>capabilities : List[str]<br ALIGN="LEFT"/>component_type<br ALIGN="LEFT"/>configuration_schema : Dict[str, Any]<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>license : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>supported_formats : List[str]<br ALIGN="LEFT"/>tags : List[str]<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginStatus" [color="black", fontcolor="black", label=<{PluginStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.plugin_system.PluginSystem" [color="black", fontcolor="black", label=<{PluginSystem|logger : NoneType, RootLogger<br ALIGN="LEFT"/>plugin_dir : str<br ALIGN="LEFT"/>plugins : NoneType, dict<br ALIGN="LEFT"/>|create_plugin_template(plugin_name: str, template_type: str): str<br ALIGN="LEFT"/>create_sample_plugins(): None<br ALIGN="LEFT"/>discover_plugins(): List[str]<br ALIGN="LEFT"/>execute_plugin(plugin_name: str): Any<br ALIGN="LEFT"/>execute_remote_plugin(plugin_url: str): Any<br ALIGN="LEFT"/>execute_sandboxed_plugin(plugin_name: str): Any<br ALIGN="LEFT"/>find_plugin(plugin_name: str): Optional[str]<br ALIGN="LEFT"/>install_plugin(plugin_name: str): bool<br ALIGN="LEFT"/>list_plugins(): List[Dict[str, Any]]<br ALIGN="LEFT"/>load_plugins(): Dict[str, List[Dict[str, Any]]]<br ALIGN="LEFT"/>run_custom_plugin(app, plugin_info: Dict[str, Any]): None<br ALIGN="LEFT"/>run_frida_plugin_from_file(app, plugin_path: str): None<br ALIGN="LEFT"/>run_ghidra_plugin_from_file(app, plugin_path: str): None<br ALIGN="LEFT"/>run_plugin(app, plugin_name: str): None<br ALIGN="LEFT"/>run_plugin_in_sandbox(plugin_path: str, function_name: str): Optional[List[str]]<br ALIGN="LEFT"/>run_plugin_remotely(app, plugin_info: Dict[str, Any]): Optional[List[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_test_generator.PluginTestGenerator" [color="black", fontcolor="black", label=<{PluginTestGenerator|method_test_template : str<br ALIGN="LEFT"/>test_template : str<br ALIGN="LEFT"/>|generate_tests_for_file(file_path)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_test_generator.PluginTestRunner" [color="black", fontcolor="black", label=<{PluginTestRunner|results : list<br ALIGN="LEFT"/>|run_tests(test_file, options)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.plugin_editor.PluginValidator" [color="black", fontcolor="black", label=<{PluginValidator|<br ALIGN="LEFT"/>|validate_imports(code: str): Tuple[bool, List[str]]<br ALIGN="LEFT"/>validate_structure(code: str): Tuple[bool, List[str]]<br ALIGN="LEFT"/>validate_syntax(code: str): Tuple[bool, List[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.polymorphic_engine.PolymorphicEngine" [color="black", fontcolor="black", label=<{PolymorphicEngine|dead_code_templates : list<br ALIGN="LEFT"/>garbage_registers : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>nop_equivalents : list<br ALIGN="LEFT"/>|encode_payload(payload: bytes, target_analysis: Dict[str, Any]): bytes<br ALIGN="LEFT"/>generate_decoder_stub(key: bytes, payload_length: int): bytes<br ALIGN="LEFT"/>generate_polymorphic_key(): bytes<br ALIGN="LEFT"/>metamorphic_encode(payload: bytes, target_analysis: Dict[str, Any]): bytes<br ALIGN="LEFT"/>xor_encode_with_key(payload: bytes, key: bytes): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionConfidence" [color="black", fontcolor="black", label=<{PredictionConfidence|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionInput" [color="black", fontcolor="black", label=<{PredictionInput|context : Dict[str, Any]<br ALIGN="LEFT"/>features : Dict[str, float]<br ALIGN="LEFT"/>historical_data : List[Dict[str, Any]]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>operation_type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionResult" [color="black", fontcolor="black", label=<{PredictionResult|confidence<br ALIGN="LEFT"/>confidence_score : float<br ALIGN="LEFT"/>error_bounds : Tuple[float, float]<br ALIGN="LEFT"/>factors : Dict[str, float]<br ALIGN="LEFT"/>model_version : str<br ALIGN="LEFT"/>predicted_value : float<br ALIGN="LEFT"/>prediction_id : str<br ALIGN="LEFT"/>prediction_type<br ALIGN="LEFT"/>reasoning : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionType" [color="black", fontcolor="black", label=<{PredictionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictiveIntelligenceEngine" [color="black", fontcolor="black", label=<{PredictiveIntelligenceEngine|prediction_cache : Dict[str, PredictionResult]<br ALIGN="LEFT"/>prediction_history : deque<br ALIGN="LEFT"/>prediction_stats : dict<br ALIGN="LEFT"/>success_predictor<br ALIGN="LEFT"/>time_predictor<br ALIGN="LEFT"/>vulnerability_predictor<br ALIGN="LEFT"/>|get_prediction_analytics(): Dict[str, Any]<br ALIGN="LEFT"/>get_prediction_insights(): Dict[str, Any]<br ALIGN="LEFT"/>make_prediction(prediction_type: PredictionType, context: Dict[str, Any]): PredictionResult<br ALIGN="LEFT"/>verify_prediction_accuracy(prediction_id: str, actual_value: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictiveModel" [color="black", fontcolor="black", label=<{PredictiveModel|feature_importance : Dict[str, float]<br ALIGN="LEFT"/>last_training : Optional[datetime]<br ALIGN="LEFT"/>model_name : str<br ALIGN="LEFT"/>model_parameters : Dict[str, Any]<br ALIGN="LEFT"/>model_version : str<br ALIGN="LEFT"/>training_data : List[Dict[str, Any]]<br ALIGN="LEFT"/>|predict(features: Dict[str, float]): Tuple[float, float]<br ALIGN="LEFT"/>train(training_data: List[Dict[str, Any]])<br ALIGN="LEFT"/>update_model(new_data: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.preferences_dialog.PreferencesDialog" [color="black", fontcolor="black", label=<{PreferencesDialog|api_key_edit<br ALIGN="LEFT"/>apply_btn<br ALIGN="LEFT"/>auto_detect_checkbox<br ALIGN="LEFT"/>auto_refine_checkbox<br ALIGN="LEFT"/>auto_save_checkbox<br ALIGN="LEFT"/>backup_checkbox<br ALIGN="LEFT"/>cancel_btn<br ALIGN="LEFT"/>capture_output_checkbox<br ALIGN="LEFT"/>confirm_patches_checkbox<br ALIGN="LEFT"/>default_model_combo<br ALIGN="LEFT"/>explain_scripts_checkbox<br ALIGN="LEFT"/>max_tokens_spin<br ALIGN="LEFT"/>ml_analysis_checkbox<br ALIGN="LEFT"/>ok_btn<br ALIGN="LEFT"/>preferences_changed<br ALIGN="LEFT"/>qemu_memory_spin<br ALIGN="LEFT"/>qemu_preference_combo<br ALIGN="LEFT"/>qemu_timeout_spin<br ALIGN="LEFT"/>sandbox_default_checkbox<br ALIGN="LEFT"/>script_timeout_spin<br ALIGN="LEFT"/>settings<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>theme_combo<br ALIGN="LEFT"/>verbose_output_checkbox<br ALIGN="LEFT"/>warn_dangerous_checkbox<br ALIGN="LEFT"/>|accept_preferences()<br ALIGN="LEFT"/>apply_preferences()<br ALIGN="LEFT"/>create_ai_tab()<br ALIGN="LEFT"/>create_execution_tab()<br ALIGN="LEFT"/>create_general_tab()<br ALIGN="LEFT"/>create_security_tab()<br ALIGN="LEFT"/>load_preferences()<br ALIGN="LEFT"/>save_preferences()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.PreprocessingModule" [color="black", fontcolor="black", label=<{PreprocessingModule|StandardScaler<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation" [color="black", fontcolor="black", label=<{PrivilegeEscalation|escalation_techniques : dict<br ALIGN="LEFT"/>exploits_db : dict<br ALIGN="LEFT"/>external_tools : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze_escalation_opportunities(target_os: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>attempt_escalation(technique: str, target_os: Optional[str], options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_available_techniques(target_os: Optional[str]): Dict[str, List[str]]<br ALIGN="LEFT"/>get_missing_tools(techniques: Optional[List[str]]): Dict[str, List[str]]<br ALIGN="LEFT"/>get_technique_info(target_os: str, technique: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>handle_result_error(result, error)<br ALIGN="LEFT"/>init_result(details)<br ALIGN="LEFT"/>is_windows()<br ALIGN="LEFT"/>safe_command_execution(command, timeout, retries, shell)<br ALIGN="LEFT"/>validate_exploit_result(result, expected_privileges)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalationManager" [color="black", fontcolor="black", label=<{PrivilegeEscalationManager|escalation_engine<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|escalate_privileges(target_platform: str, method: str): Dict[str, Any]<br ALIGN="LEFT"/>execute_local_exploit(binary_path: str, payload: bytes, technique: str, options: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.ProcessHollowing" [color="black", fontcolor="black", label=<{ProcessHollowing|logger : NoneType, RootLogger<br ALIGN="LEFT"/>supported_targets : dict<br ALIGN="LEFT"/>|generate_hollowing_code(): str<br ALIGN="LEFT"/>hollow_process(target_process: str, payload: bytes, payload_entry_point: int): Tuple[bool, Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.process_hollowing.ProcessHollowing" [color="black", fontcolor="black", label=<{ProcessHollowing|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|get_required_libraries(): list<br ALIGN="LEFT"/>hollow_process(target_exe: str, payload_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ProcessResource" [color="black", fontcolor="black", label=<{ProcessResource|command : str<br ALIGN="LEFT"/>process : Popen<br ALIGN="LEFT"/>psutil_process : NoneType, Process<br ALIGN="LEFT"/>|update_usage()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.ProcessWorker" [color="black", fontcolor="black", label=<{ProcessWorker|error<br ALIGN="LEFT"/>processFound<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.config_profiles.ProfileManager" [color="black", fontcolor="black", label=<{ProfileManager|console : Console<br ALIGN="LEFT"/>profile_dir : Path<br ALIGN="LEFT"/>profiles : dict<br ALIGN="LEFT"/>|apply_profile(profile_name: str, args: Any): Any<br ALIGN="LEFT"/>create_profile_interactive(): ConfigProfile<br ALIGN="LEFT"/>delete_profile(name: str): bool<br ALIGN="LEFT"/>get_profile(name: str): Optional[ConfigProfile]<br ALIGN="LEFT"/>list_profiles(): None<br ALIGN="LEFT"/>save_profile(profile: ConfigProfile): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.program_discovery.ProgramDiscoveryEngine" [color="black", fontcolor="black", label=<{ProgramDiscoveryEngine|ANALYSIS_PRIORITIES : dict<br ALIGN="LEFT"/>COMMON_EXECUTABLE_DIRS : dict<br ALIGN="LEFT"/>WINDOWS_REGISTRY_PATHS : list<br ALIGN="LEFT"/>cache_file : str<br ALIGN="LEFT"/>last_scan_time : NoneType, Optional[float]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>path_discovery<br ALIGN="LEFT"/>programs_cache : Dict[str, ProgramInfo], dict<br ALIGN="LEFT"/>|analyze_program_from_path(program_path: str): Optional[ProgramInfo]<br ALIGN="LEFT"/>discover_programs_from_path(search_path: str): List[ProgramInfo]<br ALIGN="LEFT"/>get_installed_programs(): List[ProgramInfo]<br ALIGN="LEFT"/>scan_executable_directories(): List[ProgramInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.program_selector_dialog.ProgramDiscoveryThread" [color="black", fontcolor="black", label=<{ProgramDiscoveryThread|discovery_complete<br ALIGN="LEFT"/>discovery_engine<br ALIGN="LEFT"/>discovery_progress<br ALIGN="LEFT"/>program_found<br ALIGN="LEFT"/>search_paths : list<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop_discovery()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.smart_program_selector_dialog.ProgramDiscoveryWorker" [color="black", fontcolor="black", label=<{ProgramDiscoveryWorker|discovery_paths : List[str]<br ALIGN="LEFT"/>finished : NoneType<br ALIGN="LEFT"/>programs_found : NoneType<br ALIGN="LEFT"/>progress_updated : NoneType<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.program_discovery.ProgramInfo" [color="black", fontcolor="black", label=<{ProgramInfo|analysis_priority : int<br ALIGN="LEFT"/>architecture : Optional[str]<br ALIGN="LEFT"/>confidence_score : float<br ALIGN="LEFT"/>description : Optional[str]<br ALIGN="LEFT"/>discovery_method : str<br ALIGN="LEFT"/>display_name : str<br ALIGN="LEFT"/>estimated_size : Optional[int]<br ALIGN="LEFT"/>executable_paths : List[str]<br ALIGN="LEFT"/>file_types : List[str]<br ALIGN="LEFT"/>icon_path : Optional[str]<br ALIGN="LEFT"/>install_date : Optional[str]<br ALIGN="LEFT"/>install_location : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>publisher : str<br ALIGN="LEFT"/>registry_key : Optional[str]<br ALIGN="LEFT"/>uninstall_string : Optional[str]<br ALIGN="LEFT"/>version : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.program_selector_dialog.ProgramSelectorDialog" [color="black", fontcolor="black", label=<{ProgramSelectorDialog|analysis_results : dict<br ALIGN="LEFT"/>analyze_btn<br ALIGN="LEFT"/>auto_analyze_checkbox<br ALIGN="LEFT"/>cancel_btn<br ALIGN="LEFT"/>discovered_programs : list<br ALIGN="LEFT"/>discovery_thread : NoneType<br ALIGN="LEFT"/>file_filters : dict<br ALIGN="LEFT"/>folder_path_label<br ALIGN="LEFT"/>full_scan_btn<br ALIGN="LEFT"/>include_subdirs_checkbox<br ALIGN="LEFT"/>installation_folder<br ALIGN="LEFT"/>licensing_files : list<br ALIGN="LEFT"/>licensing_tree<br ALIGN="LEFT"/>program_info<br ALIGN="LEFT"/>programs_table<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>scan_desktop_btn<br ALIGN="LEFT"/>search_filter<br ALIGN="LEFT"/>select_file_btn<br ALIGN="LEFT"/>selected_program : NoneType<br ALIGN="LEFT"/>|add_licensing_file_to_tree(file_path, file_type, priority)<br ALIGN="LEFT"/>add_program_to_table(program_dict)<br ALIGN="LEFT"/>analyze_installation_folder(folder_path)<br ALIGN="LEFT"/>analyze_selected_program()<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>create_program_info_from_file(file_path, metadata)<br ALIGN="LEFT"/>discovery_finished()<br ALIGN="LEFT"/>filter_programs(text)<br ALIGN="LEFT"/>format_file_size(size)<br ALIGN="LEFT"/>full_system_scan()<br ALIGN="LEFT"/>get_desktop_paths()<br ALIGN="LEFT"/>get_selected_program_data()<br ALIGN="LEFT"/>on_program_selected()<br ALIGN="LEFT"/>open_licensing_file(item)<br ALIGN="LEFT"/>process_selected_file(file_path)<br ALIGN="LEFT"/>scan_desktop_shortcuts()<br ALIGN="LEFT"/>select_file_or_shortcut()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_discovery_thread(search_paths)<br ALIGN="LEFT"/>update_discovery_progress(message, progress)<br ALIGN="LEFT"/>update_program_details(program_data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelFineTuner._fine_tune_tensorflow.ProgressCallback" [color="black", fontcolor="black", label=<{ProgressCallback|<br ALIGN="LEFT"/>|on_epoch_end(epoch, logs)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.model_manager.ProgressHandler" [color="black", fontcolor="black", label=<{ProgressHandler|complete_callback : Optional[Callable[[bool, str], None]]<br ALIGN="LEFT"/>progress_callback : Optional[Callable[[int, int], None]]<br ALIGN="LEFT"/>|on_complete(success: bool, message: str)<br ALIGN="LEFT"/>on_progress(bytes_downloaded: int, total_bytes: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.progress_manager.ProgressManager" [color="black", fontcolor="black", label=<{ProgressManager|console : Console<br ALIGN="LEFT"/>live : Live, NoneType<br ALIGN="LEFT"/>progress : NoneType, Progress<br ALIGN="LEFT"/>task_ids : Dict[str, int]<br ALIGN="LEFT"/>tasks : Dict[str, AnalysisTask]<br ALIGN="LEFT"/>|complete_task(task_name: str, success: bool, error: Optional[str]): None<br ALIGN="LEFT"/>create_progress_display(): Progress<br ALIGN="LEFT"/>start_analysis(binary_path: str, analysis_types: List[str]): None<br ALIGN="LEFT"/>stop(): None<br ALIGN="LEFT"/>update_progress(task_name: str, current: int, total: int, speed: Optional[float]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.ProgressTracker" [color="black", fontcolor="black", label=<{ProgressTracker|completed_items : int<br ALIGN="LEFT"/>eta_label : Label<br ALIGN="LEFT"/>frame : Labelframe<br ALIGN="LEFT"/>last_update : NoneType<br ALIGN="LEFT"/>max_speed_history : int<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>progress_bar : Progressbar<br ALIGN="LEFT"/>progress_var : DoubleVar<br ALIGN="LEFT"/>speed_history : list<br ALIGN="LEFT"/>start_time : NoneType<br ALIGN="LEFT"/>status_frame : Frame<br ALIGN="LEFT"/>status_label : Label<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>total_items : int<br ALIGN="LEFT"/>|finish(status: str)<br ALIGN="LEFT"/>format_time(seconds: float): str<br ALIGN="LEFT"/>start(total_items: int)<br ALIGN="LEFT"/>update(completed: int, status: str)<br ALIGN="LEFT"/>update_display()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.ui.ui_utils.ProgressTracker" [color="black", fontcolor="black", label=<{ProgressTracker|callback : Optional[Callable[[int], None]]<br ALIGN="LEFT"/>current : int<br ALIGN="LEFT"/>is_cancelled : bool<br ALIGN="LEFT"/>total : int<br ALIGN="LEFT"/>|cancel()<br ALIGN="LEFT"/>get_percentage(): int<br ALIGN="LEFT"/>reset()<br ALIGN="LEFT"/>update(value: int, increment: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.project_manager.ProjectManager" [color="black", fontcolor="black", label=<{ProjectManager|config_file<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>current_project : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>projects_dir<br ALIGN="LEFT"/>settings : dict<br ALIGN="LEFT"/>templates_dir<br ALIGN="LEFT"/>workspace_root<br ALIGN="LEFT"/>|cleanup_workspace(): int<br ALIGN="LEFT"/>create_project(name: str, description: str, template: Optional[str]): Optional[IntellicrackProject]<br ALIGN="LEFT"/>create_project_interactive(): Optional[IntellicrackProject]<br ALIGN="LEFT"/>delete_project(name: str, confirm: bool): bool<br ALIGN="LEFT"/>display_project_tree(project: IntellicrackProject): None<br ALIGN="LEFT"/>display_projects_table(): None<br ALIGN="LEFT"/>export_project(project: IntellicrackProject, export_path: str, include_binaries: bool): bool<br ALIGN="LEFT"/>import_binary(project: IntellicrackProject, binary_path: str, copy_file: bool): bool<br ALIGN="LEFT"/>import_project(archive_path: str, project_name: Optional[str]): Optional[IntellicrackProject]<br ALIGN="LEFT"/>list_projects(): List[Dict[str, Any]]<br ALIGN="LEFT"/>load_project(name: str): Optional[IntellicrackProject]<br ALIGN="LEFT"/>save_project(project: IntellicrackProject): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.script_generation_prompts.PromptType" [color="black", fontcolor="black", label=<{PromptType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_core.ProtectionAnalysis" [color="black", fontcolor="black", label=<{ProtectionAnalysis|architecture : str<br ALIGN="LEFT"/>compiler : Optional[str]<br ALIGN="LEFT"/>detections : List[DetectionResult]<br ALIGN="LEFT"/>entry_point : Optional[str]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>has_overlay : bool<br ALIGN="LEFT"/>has_resources : bool<br ALIGN="LEFT"/>imports : List[str]<br ALIGN="LEFT"/>is_packed : bool<br ALIGN="LEFT"/>is_protected : bool<br ALIGN="LEFT"/>license_file_summary : dict<br ALIGN="LEFT"/>license_files : list<br ALIGN="LEFT"/>linker : Optional[str]<br ALIGN="LEFT"/>metadata : Dict[str, any]<br ALIGN="LEFT"/>sections : List[Dict[str, any]]<br ALIGN="LEFT"/>strings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.intellicrack_protection_widget.ProtectionAnalysisThread" [color="black", fontcolor="black", label=<{ProtectionAnalysisThread|ai_file_tools<br ALIGN="LEFT"/>analysis_complete<br ALIGN="LEFT"/>analysis_error<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>detector<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.protection_analyzer_tool.ProtectionAnalyzerTool" [color="black", fontcolor="black", label=<{ProtectionAnalyzerTool|ai_assistant<br ALIGN="LEFT"/>ai_file_tools<br ALIGN="LEFT"/>detector : NoneType<br ALIGN="LEFT"/>|analyze(binary_path: str, detailed: bool): Dict[str, Any]<br ALIGN="LEFT"/>format_for_display(analysis: Dict[str, Any]): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.protection_aware_script_gen.ProtectionAwareScriptGenerator" [color="black", fontcolor="black", label=<{ProtectionAwareScriptGenerator|kb : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>script_templates : dict<br ALIGN="LEFT"/>unified_engine : NoneType<br ALIGN="LEFT"/>|generate_bypass_script(binary_path: str, script_type: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.ProtectionCard" [color="black", fontcolor="black", label=<{ProtectionCard|clicked<br ALIGN="LEFT"/>protection_data : Dict[str, Any]<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>mousePressEvent(event)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.protection_knowledge_base.ProtectionCategory" [color="black", fontcolor="black", label=<{ProtectionCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.ProtectionCategory" [color="black", fontcolor="black", label=<{ProtectionCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.pattern_library.ProtectionComplexity" [color="black", fontcolor="black", label=<{ProtectionComplexity|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.protection_detection_handlers.ProtectionDetectionHandlers" [color="black", fontcolor="black", label=<{ProtectionDetectionHandlers|binary_path : NoneType<br ALIGN="LEFT"/>|run_checksum_detection()<br ALIGN="LEFT"/>run_commercial_protection_scan()<br ALIGN="LEFT"/>run_dongle_emulation()<br ALIGN="LEFT"/>run_embedded_script_detection()<br ALIGN="LEFT"/>run_hardware_dongle_detection()<br ALIGN="LEFT"/>run_self_healing_detection()<br ALIGN="LEFT"/>run_tpm_bypass()<br ALIGN="LEFT"/>run_tpm_detection()<br ALIGN="LEFT"/>run_vm_bypass()<br ALIGN="LEFT"/>update_status(message)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_manager.ProtectionDetector" [color="black", fontcolor="black", label=<{ProtectionDetector|adaptation_callbacks : list<br ALIGN="LEFT"/>detected_protections : defaultdict<br ALIGN="LEFT"/>protection_signatures : dict<br ALIGN="LEFT"/>|analyze_api_call(module: str, function: str, args: List[Any]): Set[ProtectionType]<br ALIGN="LEFT"/>analyze_string(string_data: str): Set[ProtectionType]<br ALIGN="LEFT"/>get_detected_protections(): Dict[str, List[str]]<br ALIGN="LEFT"/>notify_protection_detected(protection_type: ProtectionType, details: Dict[str, Any])<br ALIGN="LEFT"/>register_adaptation_callback(callback: Callable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.protection_detector.ProtectionDetector" [color="black", fontcolor="black", label=<{ProtectionDetector|engine<br ALIGN="LEFT"/>|analyze(file_path: str, deep_scan: bool): UnifiedProtectionResult<br ALIGN="LEFT"/>analyze_directory(directory: str, recursive: bool, deep_scan: bool): List[ProtectionAnalysis]<br ALIGN="LEFT"/>detect_protections(file_path: str, deep_scan: bool): ProtectionAnalysis<br ALIGN="LEFT"/>export_results(analysis: ProtectionAnalysis, output_format: str): str<br ALIGN="LEFT"/>get_bypass_strategies(file_path: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_quick_summary(file_path: str): Dict[str, Any]<br ALIGN="LEFT"/>get_summary(analysis: ProtectionAnalysis): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.intellicrack_hex_protection_integration.ProtectionIntegrationWidget" [color="black", fontcolor="black", label=<{ProtectionIntegrationWidget|hex_widget : NoneType<br ALIGN="LEFT"/>info_label<br ALIGN="LEFT"/>integration<br ALIGN="LEFT"/>open_in_protection_viewer_btn<br ALIGN="LEFT"/>sync_sections_btn<br ALIGN="LEFT"/>|init_ui()<br ALIGN="LEFT"/>sync_sections_from_die()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.protection_knowledge_base.ProtectionKnowledgeBase" [color="black", fontcolor="black", label=<{ProtectionKnowledgeBase|analysis_workflows : dict<br ALIGN="LEFT"/>bypass_strategies : dict<br ALIGN="LEFT"/>protection_schemes : dict<br ALIGN="LEFT"/>|estimate_bypass_time(protection_name: str, skill_level: str): str<br ALIGN="LEFT"/>export_knowledge_base(output_path: str)<br ALIGN="LEFT"/>get_analysis_workflow(workflow_type: str): List[str]<br ALIGN="LEFT"/>get_bypass_techniques(protection_name: str): List[BypassTechnique]<br ALIGN="LEFT"/>get_protection_info(protection_name: str): Optional[ProtectionSchemeInfo]<br ALIGN="LEFT"/>get_tools_for_protection(protection_name: str): List[str]<br ALIGN="LEFT"/>search_by_signature(signature: str): List[ProtectionSchemeInfo]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.pattern_library.ProtectionPattern" [color="black", fontcolor="black", label=<{ProtectionPattern|bypass_strategy : str<br ALIGN="LEFT"/>complexity<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>frida_template : str<br ALIGN="LEFT"/>ghidra_template : str<br ALIGN="LEFT"/>indicators : List[str]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>success_rate : float<br ALIGN="LEFT"/>variants : Optional[List[str]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.protection_knowledge_base.ProtectionSchemeInfo" [color="black", fontcolor="black", label=<{ProtectionSchemeInfo|analysis_tips : List[str]<br ALIGN="LEFT"/>bypass_difficulty<br ALIGN="LEFT"/>bypass_techniques : List[BypassTechnique]<br ALIGN="LEFT"/>category<br ALIGN="LEFT"/>common_applications : List[str]<br ALIGN="LEFT"/>common_mistakes : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>detection_signatures : List[str]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>resources : List[str]<br ALIGN="LEFT"/>vendor : str<br ALIGN="LEFT"/>versions : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ProtectionType" [color="black", fontcolor="black", label=<{ProtectionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.frida_constants.ProtectionType" [color="black", fontcolor="black", label=<{ProtectionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.ProtectionType" [color="black", fontcolor="black", label=<{ProtectionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_core.ProtectionType" [color="black", fontcolor="black", label=<{ProtectionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.network.protocol_fingerprinter.ProtocolFingerprinter" [color="black", fontcolor="black", label=<{ProtocolFingerprinter|config : dict<br ALIGN="LEFT"/>learned_signatures : dict<br ALIGN="LEFT"/>license_ports : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>signatures : dict<br ALIGN="LEFT"/>traffic_samples : list<br ALIGN="LEFT"/>|analyze_binary(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_pcap(pcap_path: str): Dict[str, Any]<br ALIGN="LEFT"/>analyze_traffic(packet_data: Union[bytes, bytearray], port: Optional[int]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>fingerprint_packet(packet_data: Union[bytes, bytearray], port: Optional[int]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>generate_response(protocol_id: str, request_packet: Union[bytes, bytearray], response_type: str): Optional[bytes]<br ALIGN="LEFT"/>parse_packet(protocol_id: str, packet_data: Union[bytes, bytearray]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.ProtocolType" [color="black", fontcolor="black", label=<{ProtocolType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.PyTorchBackend" [color="black", fontcolor="black", label=<{PyTorchBackend|<br ALIGN="LEFT"/>|get_model_info(model: Any): Dict[str, Any]<br ALIGN="LEFT"/>load_model(model_path: str): Any<br ALIGN="LEFT"/>predict(model: Any, input_data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.PyTorchLLMBackend" [color="black", fontcolor="black", label=<{PyTorchLLMBackend|device : NoneType, device<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>quantization_manager : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.script_generator_dialog.PythonHighlighter" [color="black", fontcolor="black", label=<{PythonHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.syntax_highlighters.PythonHighlighter" [color="black", fontcolor="black", label=<{PythonHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>match_multiline_string(text, expression, state, format)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PythonPlugin" [color="black", fontcolor="black", label=<{PythonPlugin|last_error : str<br ALIGN="LEFT"/>module : NoneType<br ALIGN="LEFT"/>module_path : Path<br ALIGN="LEFT"/>plugin_instance : NoneType<br ALIGN="LEFT"/>status : ACTIVE, ERROR, INITIALIZING, READY<br ALIGN="LEFT"/>|activate(): bool<br ALIGN="LEFT"/>cleanup(): bool<br ALIGN="LEFT"/>deactivate(): bool<br ALIGN="LEFT"/>execute_operation(operation: str, parameters: Dict[str, Any]): Any<br ALIGN="LEFT"/>get_metadata(): PluginMetadata<br ALIGN="LEFT"/>get_supported_operations(): List[str]<br ALIGN="LEFT"/>initialize(config: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.PythonSyntaxHighlighter" [color="black", fontcolor="black", label=<{PythonSyntaxHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.PythonSyntaxHighlighter" [color="black", fontcolor="black", label=<{PythonSyntaxHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUExecutionThread" [color="black", fontcolor="black", label=<{QEMUExecutionThread|binary_path : str<br ALIGN="LEFT"/>execution_complete<br ALIGN="LEFT"/>output_update<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>qemu_manager<br ALIGN="LEFT"/>script_content : str<br ALIGN="LEFT"/>script_type : str<br ALIGN="LEFT"/>snapshot_id : str<br ALIGN="LEFT"/>start_time : NoneType<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUSnapshot" [color="black", fontcolor="black", label=<{QEMUSnapshot|binary_path : str<br ALIGN="LEFT"/>children_snapshots : Set[str]<br ALIGN="LEFT"/>created_at : datetime<br ALIGN="LEFT"/>disk_path : str<br ALIGN="LEFT"/>disk_usage : int<br ALIGN="LEFT"/>memory_usage : int<br ALIGN="LEFT"/>network_isolated : bool<br ALIGN="LEFT"/>parent_snapshot : Optional[str]<br ALIGN="LEFT"/>performance_metrics : Dict[str, Any]<br ALIGN="LEFT"/>snapshot_id : str<br ALIGN="LEFT"/>ssh_port : int<br ALIGN="LEFT"/>test_results : List[Dict[str, Any]]<br ALIGN="LEFT"/>version : int<br ALIGN="LEFT"/>vm_name : str<br ALIGN="LEFT"/>vm_process : Optional[subprocess.Popen]<br ALIGN="LEFT"/>vnc_port : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.processing.qemu_emulator.QEMUSystemEmulator" [color="black", fontcolor="black", label=<{QEMUSystemEmulator|SUPPORTED_ARCHITECTURES : dict<br ALIGN="LEFT"/>architecture : str<br ALIGN="LEFT"/>binary_path : bytes, str<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>monitor : Optional[Any]<br ALIGN="LEFT"/>monitor_socket : Optional[str]<br ALIGN="LEFT"/>qemu_process : NoneType, Optional[subprocess.Popen]<br ALIGN="LEFT"/>rootfs_path : str<br ALIGN="LEFT"/>shared_folder<br ALIGN="LEFT"/>ssh_client : Optional[Any]<br ALIGN="LEFT"/>|cleanup(): bool<br ALIGN="LEFT"/>compare_snapshots(snapshot1: str, snapshot2: str): Dict[str, Any]<br ALIGN="LEFT"/>create_snapshot(name: str): bool<br ALIGN="LEFT"/>execute_command(command: str, timeout: int): Optional[str]<br ALIGN="LEFT"/>get_system_status(): Dict[str, Any]<br ALIGN="LEFT"/>restore_snapshot(name: str): bool<br ALIGN="LEFT"/>start_system(headless: bool, enable_snapshot: bool): bool<br ALIGN="LEFT"/>stop_system(force: bool): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.qemu_test_dialog.QEMUTestDialog" [color="black", fontcolor="black", label=<{QEMUTestDialog|button_group<br ALIGN="LEFT"/>continue_btn<br ALIGN="LEFT"/>host_run_radio<br ALIGN="LEFT"/>qemu_test_radio<br ALIGN="LEFT"/>remember_checkbox<br ALIGN="LEFT"/>script_preview : str<br ALIGN="LEFT"/>script_type : str<br ALIGN="LEFT"/>target_binary : str<br ALIGN="LEFT"/>user_choice : NoneType, str<br ALIGN="LEFT"/>|get_user_choice(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUTestManager" [color="black", fontcolor="black", label=<{QEMUTestManager|base_images : dict<br ALIGN="LEFT"/>circuit_breaker_threshold : int<br ALIGN="LEFT"/>circuit_breaker_timeout : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>master_ssh_key<br ALIGN="LEFT"/>qemu_emulator : NoneType<br ALIGN="LEFT"/>qemu_executable : str<br ALIGN="LEFT"/>snapshots : dict<br ALIGN="LEFT"/>ssh_circuit_breaker : dict<br ALIGN="LEFT"/>ssh_clients : dict<br ALIGN="LEFT"/>ssh_connection_pool : dict<br ALIGN="LEFT"/>ssh_keys : dict<br ALIGN="LEFT"/>ssh_lock : _RLock<br ALIGN="LEFT"/>ssh_public_key : NoneType, str<br ALIGN="LEFT"/>ssh_retry_count : int<br ALIGN="LEFT"/>ssh_retry_delay : int<br ALIGN="LEFT"/>ssh_timeout : int<br ALIGN="LEFT"/>working_dir<br ALIGN="LEFT"/>|cleanup_all_snapshots()<br ALIGN="LEFT"/>cleanup_old_snapshots(max_age_days: int, keep_versions: int): Dict[str, Any]<br ALIGN="LEFT"/>cleanup_snapshot(snapshot_id: str)<br ALIGN="LEFT"/>compare_snapshots(snapshot_id1: str, snapshot_id2: str): Dict[str, Any]<br ALIGN="LEFT"/>create_script_test_snapshot(binary_path: str, platform: str): str<br ALIGN="LEFT"/>create_snapshot(binary_path: str): str<br ALIGN="LEFT"/>create_versioned_snapshot(parent_snapshot_id: str, binary_path: str): str<br ALIGN="LEFT"/>enable_network_isolation(snapshot_id: str, isolated: bool)<br ALIGN="LEFT"/>get_snapshot_hierarchy(): Dict[str, Any]<br ALIGN="LEFT"/>get_snapshot_info(snapshot_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>list_snapshots(): List[Dict[str, Any]]<br ALIGN="LEFT"/>monitor_snapshot_performance(snapshot_id: str): Dict[str, Any]<br ALIGN="LEFT"/>optimize_snapshot_storage(): Dict[str, Any]<br ALIGN="LEFT"/>perform_snapshot_maintenance(optimize: bool, cleanup_old: bool, verify_integrity: bool): Dict[str, Any]<br ALIGN="LEFT"/>rollback_snapshot(snapshot_id: str, target_state: Optional[str]): bool<br ALIGN="LEFT"/>test_frida_script(snapshot_id: str, script_content: str, binary_path: str): ExecutionResult<br ALIGN="LEFT"/>test_ghidra_script(snapshot_id: str, script_content: str, binary_path: str): ExecutionResult<br ALIGN="LEFT"/>test_script_in_vm(script_content: str, binary_path: str, script_type: str, timeout: int): ExecutionResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUTestResultsDialog" [color="black", fontcolor="black", label=<{QEMUTestResultsDialog|analysis_tab<br ALIGN="LEFT"/>analysis_tree<br ALIGN="LEFT"/>api_tab<br ALIGN="LEFT"/>api_tree<br ALIGN="LEFT"/>button_box<br ALIGN="LEFT"/>duration_label<br ALIGN="LEFT"/>execution_thread : NoneType<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>memory_tab<br ALIGN="LEFT"/>memory_tree<br ALIGN="LEFT"/>modify_btn<br ALIGN="LEFT"/>output_tab<br ALIGN="LEFT"/>output_text<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>qemu_manager<br ALIGN="LEFT"/>result_action : str<br ALIGN="LEFT"/>run_host_btn<br ALIGN="LEFT"/>script_info : dict<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>status_widget<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>test_results : NoneType<br ALIGN="LEFT"/>|display_results(results: TestResults)<br ALIGN="LEFT"/>export_results()<br ALIGN="LEFT"/>modify_script()<br ALIGN="LEFT"/>run_on_host()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_execution()<br ALIGN="LEFT"/>update_output(line: str)<br ALIGN="LEFT"/>update_progress(value: int, message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.qiling_emulator.QilingEmulator" [color="black", fontcolor="black", label=<{QilingEmulator|ARCH_MAPPING : dict<br ALIGN="LEFT"/>OS_MAPPING : dict<br ALIGN="LEFT"/>api_calls : list<br ALIGN="LEFT"/>api_hooks : dict<br ALIGN="LEFT"/>arch : str<br ALIGN="LEFT"/>binary_path : bytes, str<br ALIGN="LEFT"/>code_hooks : list<br ALIGN="LEFT"/>license_checks : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>mapped_files : list<br ALIGN="LEFT"/>memory_accesses : list<br ALIGN="LEFT"/>memory_hooks : list<br ALIGN="LEFT"/>ostype : str<br ALIGN="LEFT"/>ql : NoneType<br ALIGN="LEFT"/>ql_arch : NoneType<br ALIGN="LEFT"/>ql_os : NoneType<br ALIGN="LEFT"/>rootfs : NoneType<br ALIGN="LEFT"/>suspicious_behaviors : list<br ALIGN="LEFT"/>verbose : bool<br ALIGN="LEFT"/>|add_api_hook(api_name: str, hook_func: Callable)<br ALIGN="LEFT"/>add_license_detection_hooks()<br ALIGN="LEFT"/>detect_binary_format(): Dict[str, Any]<br ALIGN="LEFT"/>emulate_with_patches(patches: List[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_arch_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_os_info(): Dict[str, Any]<br ALIGN="LEFT"/><I>hook_code_execution</I>(ql: Qiling, address: int, size: int)<br ALIGN="LEFT"/>hook_memory_access(ql: Qiling, access: int, address: int, size: int, value: int)<br ALIGN="LEFT"/>map_file_to_fs(host_path: str, guest_path: str)<br ALIGN="LEFT"/>run(timeout: Optional[int], until_address: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>setup_filesystem_mappings()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.quantization_manager.QuantizationManager" [color="black", fontcolor="black", label=<{QuantizationManager|available_backends : dict<br ALIGN="LEFT"/>loaded_models : dict<br ALIGN="LEFT"/>quantization_configs : dict<br ALIGN="LEFT"/>sharding_manager : NoneType<br ALIGN="LEFT"/>|apply_dynamic_quantization(model: Any, quantization_config: Dict[str, Any]): Optional[Any]<br ALIGN="LEFT"/>cleanup_memory()<br ALIGN="LEFT"/>create_gptq_config(bits: int, group_size: int): Optional[Any]<br ALIGN="LEFT"/>create_lora_config(r: int, lora_alpha: int, target_modules: Optional[list], lora_dropout: float): Optional[Any]<br ALIGN="LEFT"/>create_quantization_config(quantization_type: str): dict<br ALIGN="LEFT"/>estimate_memory_usage(model_path: Union[str, Path], quantization_type: str): Dict[str, float]<br ALIGN="LEFT"/>get_sharding_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_supported_quantization_types(): list<br ALIGN="LEFT"/>load_lora_adapter(base_model: Any, adapter_path: Union[str, Path]): Optional[Any]<br ALIGN="LEFT"/>load_quantized_model(model_path: Union[str, Path], quantization_type: str, device: str): Optional[Any]<br ALIGN="LEFT"/>prepare_model_for_gptq_quantization(model_path: Union[str, Path], config: Any): Optional[Any]<br ALIGN="LEFT"/>quantize_model_with_bnb(model: Any, quantization_bits: int): Optional[Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.background_loader.QueuedProgressCallback" [color="black", fontcolor="black", label=<{QueuedProgressCallback|completion_queue : Queue<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_queue : Queue<br ALIGN="LEFT"/>|get_completion_updates(): List[tuple]<br ALIGN="LEFT"/>get_progress_updates(): List[LoadingProgress]<br ALIGN="LEFT"/>on_completed(model_id: str, success: bool, error: Optional[str])<br ALIGN="LEFT"/>on_progress(progress: LoadingProgress)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" [color="black", fontcolor="black", label=<{R2AIEngine|anomaly_detector : NoneType<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>function_clusterer : NoneType<br ALIGN="LEFT"/>license_detector : NoneType, RandomForestClassifier<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>model_dir<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>scaler : NoneType, StandardScaler<br ALIGN="LEFT"/>text_vectorizer : NoneType, TfidfVectorizer<br ALIGN="LEFT"/>vulnerability_classifier : NoneType, RandomForestClassifier<br ALIGN="LEFT"/>|analyze_with_ai(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2AnalysisWorker" [color="black", fontcolor="black", label=<{R2AnalysisWorker|analysis_completed<br ALIGN="LEFT"/>analysis_type : str<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>options : Dict[str, Any]<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>status_updated<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_binary_diff.R2BinaryDiff" [color="black", fontcolor="black", label=<{R2BinaryDiff|binary1_path : str<br ALIGN="LEFT"/>binary2_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>|analyze_differences(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.tools.radare2_utils.R2BinaryDiff" [color="black", fontcolor="black", label=<{R2BinaryDiff|binary1 : str<br ALIGN="LEFT"/>binary2 : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|compare_functions(): Dict[str, Any]<br ALIGN="LEFT"/>compare_strings(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_bypass_generator.R2BypassGenerator" [color="black", fontcolor="black", label=<{R2BypassGenerator|ai_engine<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>decompiler<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>vulnerability_engine<br ALIGN="LEFT"/>|generate_comprehensive_bypass(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2ConfigurationDialog" [color="black", fontcolor="black", label=<{R2ConfigurationDialog|analysis_depth<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>custom_flags<br ALIGN="LEFT"/>enable_ai<br ALIGN="LEFT"/>enable_bypass<br ALIGN="LEFT"/>enable_cfg<br ALIGN="LEFT"/>enable_decompilation<br ALIGN="LEFT"/>enable_imports<br ALIGN="LEFT"/>enable_strings<br ALIGN="LEFT"/>enable_vulnerability<br ALIGN="LEFT"/>max_functions<br ALIGN="LEFT"/>radare2_path<br ALIGN="LEFT"/>timeout_seconds<br ALIGN="LEFT"/>|get_configuration(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_decompiler.R2DecompilationEngine" [color="black", fontcolor="black", label=<{R2DecompilationEngine|binary_path : str<br ALIGN="LEFT"/>decompilation_cache : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>|analyze_license_functions(): Dict[str, Any]<br ALIGN="LEFT"/>decompile_all_functions(limit: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>decompile_function(address: int, optimize: bool): Dict[str, Any]<br ALIGN="LEFT"/>export_analysis_report(output_path: str, analysis_results: Dict[str, Any]): bool<br ALIGN="LEFT"/>generate_license_bypass_suggestions(function_results: Dict[str, Any]): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.R2ErrorHandler" [color="black", fontcolor="black", label=<{R2ErrorHandler|circuit_breakers : dict<br ALIGN="LEFT"/>error_history : List[ErrorEvent], list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_errors_per_session : int<br ALIGN="LEFT"/>performance_monitor : dict<br ALIGN="LEFT"/>recovery_actions : Dict[str, RecoveryAction]<br ALIGN="LEFT"/>session_stats : dict<br ALIGN="LEFT"/>|add_recovery_action(name: str, action: RecoveryAction)<br ALIGN="LEFT"/>clear_error_history()<br ALIGN="LEFT"/>error_context(operation_name: str)<br ALIGN="LEFT"/>get_error_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>handle_error(error: Exception, operation_name: str, context: Dict[str, Any]): bool<br ALIGN="LEFT"/>is_operation_degraded(operation_name: str): bool<br ALIGN="LEFT"/>reset_circuit_breaker(operation_name: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.tools.radare2_utils.R2Exception" [color="black", fontcolor="red", label=<{R2Exception|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_imports.R2ImportExportAnalyzer" [color="black", fontcolor="black", label=<{R2ImportExportAnalyzer|api_cache : dict<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>|analyze_imports_exports(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2IntegrationWidget" [color="black", fontcolor="black", label=<{R2IntegrationWidget|analysis_config : dict<br ALIGN="LEFT"/>binary_path : NoneType, str<br ALIGN="LEFT"/>browse_button<br ALIGN="LEFT"/>buttons : dict<br ALIGN="LEFT"/>config_button<br ALIGN="LEFT"/>current_worker : NoneType<br ALIGN="LEFT"/>file_label<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>results_viewer<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|set_binary_path(path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_json_standardizer.R2JSONStandardizer" [color="black", fontcolor="black", label=<{R2JSONStandardizer|ANALYSIS_TYPES : dict<br ALIGN="LEFT"/>SCHEMA_VERSION : str<br ALIGN="LEFT"/>analysis_id : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>timestamp<br ALIGN="LEFT"/>|standardize_analysis_result(analysis_type: str, raw_result: Dict[str, Any], binary_path: str, metadata: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.R2PerformanceOptimizer" [color="black", fontcolor="black", label=<{R2PerformanceOptimizer|PERFORMANCE_PROFILES : dict<br ALIGN="LEFT"/>adaptive_thresholds : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>performance_metrics : dict<br ALIGN="LEFT"/>profile_usage_stats : dict<br ALIGN="LEFT"/>strategy<br ALIGN="LEFT"/>system_info : dict<br ALIGN="LEFT"/>|benchmark_analysis_types(binary_path: str, analysis_types: List[str]): Dict[str, Dict[str, float]]<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>get_performance_report(): Dict[str, Any]<br ALIGN="LEFT"/>optimize_for_binary(binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>optimize_r2_session(r2_session, config: Dict[str, Any])<br ALIGN="LEFT"/>start_monitoring(interval: float)<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.R2RealtimeAnalyzer" [color="black", fontcolor="black", label=<{R2RealtimeAnalyzer|active_analyses : Dict[str, threading.Thread]<br ALIGN="LEFT"/>analysis_cache : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>analysis_queue : Queue<br ALIGN="LEFT"/>error_handler : NoneType<br ALIGN="LEFT"/>event_callbacks : Dict[AnalysisEvent, List[Callable]]<br ALIGN="LEFT"/>file_hashes : Dict[str, str]<br ALIGN="LEFT"/>file_observer : NoneType<br ALIGN="LEFT"/>file_watcher : NoneType<br ALIGN="LEFT"/>latest_results : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_concurrent_analyses : int<br ALIGN="LEFT"/>performance_optimizer<br ALIGN="LEFT"/>result_history : Dict[str, List[AnalysisUpdate]]<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>update_interval : float<br ALIGN="LEFT"/>update_mode<br ALIGN="LEFT"/>update_thread : NoneType, Thread<br ALIGN="LEFT"/>watched_binaries : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>worker_threads : List[threading.Thread]<br ALIGN="LEFT"/>|add_binary(binary_path: str, analysis_config: Optional[Dict[str, Any]]): bool<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>get_latest_results(binary_path: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_result_history(binary_path: str, limit: int): List[AnalysisUpdate]<br ALIGN="LEFT"/>get_status(): Dict[str, Any]<br ALIGN="LEFT"/>register_event_callback(event_type: AnalysisEvent, callback: Callable)<br ALIGN="LEFT"/>remove_binary(binary_path: str): bool<br ALIGN="LEFT"/>start_realtime_analysis()<br ALIGN="LEFT"/>stop_realtime_analysis()<br ALIGN="LEFT"/>unregister_event_callback(event_type: AnalysisEvent, callback: Callable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2ResultsViewer" [color="black", fontcolor="black", label=<{R2ResultsViewer|component_selector<br ALIGN="LEFT"/>export_button<br ALIGN="LEFT"/>results_data : Dict[str, Any], dict<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>|display_results(results: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_scripting.R2ScriptingEngine" [color="black", fontcolor="black", label=<{R2ScriptingEngine|binary_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>script_cache : dict<br ALIGN="LEFT"/>|analyze_specific_function(function_name: str): Dict[str, Any]<br ALIGN="LEFT"/>create_automated_patcher_script(patches: List[Dict[str, Any]]): str<br ALIGN="LEFT"/>create_custom_r2_script(script_name: str, commands: List[str], description: str): str<br ALIGN="LEFT"/>create_license_validator_script(validation_points: List[Dict[str, Any]]): str<br ALIGN="LEFT"/>execute_custom_analysis(script_commands: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>execute_license_analysis_workflow(): Dict[str, Any]<br ALIGN="LEFT"/>execute_r2_script_file(script_path: str): Dict[str, Any]<br ALIGN="LEFT"/>execute_vulnerability_analysis_workflow(): Dict[str, Any]<br ALIGN="LEFT"/>generate_function_analysis_script(function_name: str): List[str]<br ALIGN="LEFT"/>generate_license_analysis_script(): List[str]<br ALIGN="LEFT"/>generate_vulnerability_analysis_script(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.tools.radare2_utils.R2Session" [color="black", fontcolor="black", label=<{R2Session|analysis_cache : dict<br ALIGN="LEFT"/>analysis_level : str<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>is_connected : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>r2 : NoneType, open<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>|analyze_all(level: str): bool<br ALIGN="LEFT"/>analyze_api_calls(): Dict[str, List[str]]<br ALIGN="LEFT"/>analyze_function_deeper(address: Union[str, int]): bool<br ALIGN="LEFT"/>apply_signatures(): bool<br ALIGN="LEFT"/>connect(): bool<br ALIGN="LEFT"/>decompile_function(address: Union[str, int]): str<br ALIGN="LEFT"/>detect_vulnerabilities(): Dict[str, List[Dict[str, Any]]]<br ALIGN="LEFT"/>disconnect()<br ALIGN="LEFT"/>emulate_function(address: Union[str, int]): Dict[str, Any]<br ALIGN="LEFT"/>get_esil_registers(): Dict[str, Any]<br ALIGN="LEFT"/>get_exports(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_function_graph(address: Union[str, int]): Dict[str, Any]<br ALIGN="LEFT"/>get_function_info(address: Union[str, int]): Dict[str, Any]<br ALIGN="LEFT"/>get_function_signature(address: Union[str, int]): str<br ALIGN="LEFT"/>get_functions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_identified_functions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_imports(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_info(): Dict[str, Any]<br ALIGN="LEFT"/>get_license_strings(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_relocations(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_strings(min_length: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_strings_with_xrefs(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_symbols(): List[Dict[str, Any]]<br ALIGN="LEFT"/>initialize_esil(): bool<br ALIGN="LEFT"/>run_optimization_passes(address: Union[str, int]): bool<br ALIGN="LEFT"/>search_strings(pattern: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>step_esil(address: Union[str, int], steps: int): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_signatures.R2SignatureAnalyzer" [color="black", fontcolor="black", label=<{R2SignatureAnalyzer|binary_path : str<br ALIGN="LEFT"/>custom_signatures : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>signature_cache : dict<br ALIGN="LEFT"/>|analyze_signatures(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_strings.R2StringAnalyzer" [color="black", fontcolor="black", label=<{R2StringAnalyzer|binary_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>string_cache : dict<br ALIGN="LEFT"/>|analyze_all_strings(min_length: int, encoding: str): Dict[str, Any]<br ALIGN="LEFT"/>search_license_validation_strings(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.radare2_ui_manager.R2UIManager" [color="black", fontcolor="black", label=<{R2UIManager|analysis_completed<br ALIGN="LEFT"/>analysis_config<br ALIGN="LEFT"/>analysis_failed<br ALIGN="LEFT"/>analysis_history : list<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>analysis_started<br ALIGN="LEFT"/>binary_loaded<br ALIGN="LEFT"/>binary_path : NoneType<br ALIGN="LEFT"/>current_results : Dict[str, Any], dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>main_app : NoneType<br ALIGN="LEFT"/>status_updated<br ALIGN="LEFT"/>ui_components : dict<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>export_results(file_path: str): bool<br ALIGN="LEFT"/>get_analysis_history(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_current_results(): Dict[str, Any]<br ALIGN="LEFT"/>integrate_with_application(main_app): bool<br ALIGN="LEFT"/>set_binary_path(path: str)<br ALIGN="LEFT"/>show_configuration()<br ALIGN="LEFT"/>start_analysis(analysis_type: str, options: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" [color="black", fontcolor="black", label=<{R2VulnerabilityEngine|binary_path : str<br ALIGN="LEFT"/>decompiler<br ALIGN="LEFT"/>esil_engine<br ALIGN="LEFT"/>import_analyzer<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>radare2_path : Optional[str]<br ALIGN="LEFT"/>string_analyzer<br ALIGN="LEFT"/>vulnerability_patterns : dict<br ALIGN="LEFT"/>|analyze_vulnerabilities(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_rms_norm.RMSNorm" [color="black", fontcolor="black", label=<{RMSNorm|eps : float<br ALIGN="LEFT"/>weight : Parameter<br ALIGN="LEFT"/>|forward(x)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.mitigation_bypass.bypass_base.ROPBasedBypass" [color="black", fontcolor="black", label=<{ROPBasedBypass|rop_techniques : list<br ALIGN="LEFT"/>|assess_rop_viability(binary_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>find_rop_gadgets(binary_info: Dict[str, Any]): List[Dict[str, Any]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.rop_generator.ROPChainGenerator" [color="black", fontcolor="black", label=<{ROPChainGenerator|arch<br ALIGN="LEFT"/>binary_path : Optional[str]<br ALIGN="LEFT"/>chains : List[Dict[str, Any]], list<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>gadgets : List[Dict[str, Any]], list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_chain_length<br ALIGN="LEFT"/>max_gadget_size<br ALIGN="LEFT"/>target_functions : List[Dict[str, Any]]<br ALIGN="LEFT"/>|add_target_function(function_name: str, function_address: Optional[str], description: Optional[str]): None<br ALIGN="LEFT"/>clear_analysis(): None<br ALIGN="LEFT"/>find_gadgets(): bool<br ALIGN="LEFT"/>generate_chain(target: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>generate_chains(): bool<br ALIGN="LEFT"/>generate_report(filename: Optional[str]): Optional[str]<br ALIGN="LEFT"/>get_results(): Dict[str, Any]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>set_binary(binary_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_enhanced_integration.Radare2EnhancedIntegration" [color="black", fontcolor="black", label=<{Radare2EnhancedIntegration|binary_path : Optional[str]<br ALIGN="LEFT"/>cache_ttl<br ALIGN="LEFT"/>components : dict<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>error_handler : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>monitoring_enabled : bool<br ALIGN="LEFT"/>monitoring_thread : NoneType, Thread<br ALIGN="LEFT"/>performance_stats : dict<br ALIGN="LEFT"/>r2pipe_available : bool<br ALIGN="LEFT"/>results_cache : dict<br ALIGN="LEFT"/>|cleanup()<br ALIGN="LEFT"/>clear_cache()<br ALIGN="LEFT"/>close()<br ALIGN="LEFT"/>get_exports(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_functions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_health_status(): Dict[str, Any]<br ALIGN="LEFT"/>get_imports(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_performance_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_sections(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_strings(min_length: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>open_binary(binary_path: str): bool<br ALIGN="LEFT"/>optimize_performance()<br ALIGN="LEFT"/>run_comprehensive_analysis(analysis_types: Optional[List[str]]): Dict[str, Any]<br ALIGN="LEFT"/>start_real_time_monitoring(callback: Optional[Callable])<br ALIGN="LEFT"/>stop_real_time_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.RandomForestFallback" [color="black", fontcolor="black", label=<{RandomForestFallback|n_estimators : int<br ALIGN="LEFT"/>|fit(X, y)<br ALIGN="LEFT"/>predict(X)<br ALIGN="LEFT"/>predict_proba(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.models.repositories.base.RateLimitConfig" [color="black", fontcolor="black", label=<{RateLimitConfig|requests_per_day : int<br ALIGN="LEFT"/>requests_per_minute : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.base.RateLimiter" [color="black", fontcolor="black", label=<{RateLimiter|config<br ALIGN="LEFT"/>day_counters : dict<br ALIGN="LEFT"/>minute_counters : dict<br ALIGN="LEFT"/>|check_limit(resource: str): Tuple[bool, str]<br ALIGN="LEFT"/>record_request(resource: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.RealTimeAdaptationEngine" [color="black", fontcolor="black", label=<{RealTimeAdaptationEngine|active_adaptations : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>adaptation_history : deque<br ALIGN="LEFT"/>adaptation_rules : List[AdaptationRule]<br ALIGN="LEFT"/>adaptation_stats : dict<br ALIGN="LEFT"/>debug_system<br ALIGN="LEFT"/>hook_manager<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>runtime_monitor<br ALIGN="LEFT"/>|add_adaptation_rule(rule: AdaptationRule)<br ALIGN="LEFT"/>get_adaptation_insights(): Dict[str, Any]<br ALIGN="LEFT"/>get_adaptation_status(): Dict[str, Any]<br ALIGN="LEFT"/>remove_adaptation_rule(rule_id: str): bool<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.RealTimeChart" [color="black", fontcolor="black", label=<{RealTimeChart|axis<br ALIGN="LEFT"/>canvas : FigureCanvasTkAgg<br ALIGN="LEFT"/>data_points : list<br ALIGN="LEFT"/>figure : Figure<br ALIGN="LEFT"/>max_points : int<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>|refresh()<br ALIGN="LEFT"/>update_data(value: float, label: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.RecoveryAction" [color="black", fontcolor="black", label=<{RecoveryAction|action_id : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>estimated_time : float<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>side_effects : List[str]<br ALIGN="LEFT"/>strategy<br ALIGN="LEFT"/>success_probability : float<br ALIGN="LEFT"/>target_component : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.RecoveryAction" [color="black", fontcolor="black", label=<{RecoveryAction|action : Callable<br ALIGN="LEFT"/>delay : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>exponential_backoff : bool<br ALIGN="LEFT"/>max_attempts : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>prerequisites : Optional[List[str]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.RecoveryStrategy" [color="black", fontcolor="black", label=<{RecoveryStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.RecoveryStrategy" [color="black", fontcolor="black", label=<{RecoveryStrategy|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.RecoverySystem" [color="black", fontcolor="black", label=<{RecoverySystem|circuit_breakers : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>component_restart_timeout : int<br ALIGN="LEFT"/>health_monitor<br ALIGN="LEFT"/>learning_engine : NoneType<br ALIGN="LEFT"/>max_recovery_attempts : int<br ALIGN="LEFT"/>recovery_cooldown : int<br ALIGN="LEFT"/>recovery_history : deque<br ALIGN="LEFT"/>recovery_strategies : Dict[FailureType, List[RecoveryAction]]<br ALIGN="LEFT"/>|get_recovery_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>handle_failure(failure: FailureEvent)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.remote_executor.RemotePluginExecutor" [color="black", fontcolor="black", label=<{RemotePluginExecutor|logger : NoneType, RootLogger<br ALIGN="LEFT"/>remote_host : str<br ALIGN="LEFT"/>remote_port : int<br ALIGN="LEFT"/>shared_secret<br ALIGN="LEFT"/>|execute_plugin(plugin_path: str, method_name: str): List[str]<br ALIGN="LEFT"/>start_server(host: str, port: int): None<br ALIGN="LEFT"/>test_connection(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.hex_commands.ReplaceCommand" [color="black", fontcolor="black", label=<{ReplaceCommand|executed : bool<br ALIGN="LEFT"/>new_data : bytes<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>old_data : Optional[bytes]<br ALIGN="LEFT"/>|can_merge_with(other: 'HexCommand'): bool<br ALIGN="LEFT"/>execute(file_handler): bool<br ALIGN="LEFT"/>get_affected_range(): tuple<br ALIGN="LEFT"/>merge_with(other: 'HexCommand'): 'HexCommand'<br ALIGN="LEFT"/>undo(file_handler): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.ReplaceDialog" [color="black", fontcolor="black", label=<{ReplaceDialog|case_sensitive<br ALIGN="LEFT"/>find_pattern<br ALIGN="LEFT"/>find_type<br ALIGN="LEFT"/>replace_all<br ALIGN="LEFT"/>replace_pattern<br ALIGN="LEFT"/>|setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.report_manager_dialog.ReportGenerationThread" [color="black", fontcolor="black", label=<{ReportGenerationThread|generation_finished<br ALIGN="LEFT"/>output_path : str<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>report_config : Dict[str, Any]<br ALIGN="LEFT"/>status_updated<br ALIGN="LEFT"/>|generate_report_content(): str<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.ReportGenerator" [color="black", fontcolor="black", label=<{ReportGenerator|output_dir : Path<br ALIGN="LEFT"/>|generate_comprehensive_report(analyzer: 'SuccessRateAnalyzer'): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.reporting.report_generator.ReportGenerator" [color="black", fontcolor="black", label=<{ReportGenerator|metadata : dict<br ALIGN="LEFT"/>output_dir : Path<br ALIGN="LEFT"/>sections : list<br ALIGN="LEFT"/>|add_section(title: str, content: Any): int<br ALIGN="LEFT"/>set_metadata(title: str, author: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.report_manager_dialog.ReportManagerDialog" [color="black", fontcolor="black", label=<{ReportManagerDialog|binary_path_edit : NoneType<br ALIGN="LEFT"/>browse_binary_btn : NoneType<br ALIGN="LEFT"/>browse_output_btn : NoneType<br ALIGN="LEFT"/>close_btn<br ALIGN="LEFT"/>create_template_btn : NoneType<br ALIGN="LEFT"/>current_report : NoneType<br ALIGN="LEFT"/>date_filter<br ALIGN="LEFT"/>delete_btn : NoneType<br ALIGN="LEFT"/>duplicate_btn : NoneType<br ALIGN="LEFT"/>edit_btn : NoneType<br ALIGN="LEFT"/>edit_template_btn : NoneType<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>generate_btn : NoneType<br ALIGN="LEFT"/>generation_thread : NoneType<br ALIGN="LEFT"/>include_detailed_logs : NoneType<br ALIGN="LEFT"/>include_executive_summary : NoneType<br ALIGN="LEFT"/>include_recommendations : NoneType<br ALIGN="LEFT"/>include_screenshots : NoneType<br ALIGN="LEFT"/>open_after_generation : NoneType<br ALIGN="LEFT"/>output_format_combo : NoneType<br ALIGN="LEFT"/>output_path_edit : NoneType<br ALIGN="LEFT"/>preview_btn : NoneType<br ALIGN="LEFT"/>progress_bar : NoneType<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>report_name_edit : NoneType<br ALIGN="LEFT"/>report_preview : NoneType<br ALIGN="LEFT"/>report_type_combo : NoneType<br ALIGN="LEFT"/>reports : dict<br ALIGN="LEFT"/>reports_dir<br ALIGN="LEFT"/>reports_table<br ALIGN="LEFT"/>search_edit<br ALIGN="LEFT"/>status_label : NoneType<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>template_description : NoneType<br ALIGN="LEFT"/>template_list : NoneType<br ALIGN="LEFT"/>type_filter<br ALIGN="LEFT"/>use_template_btn : NoneType<br ALIGN="LEFT"/>view_btn : NoneType<br ALIGN="LEFT"/>|browse_binary()<br ALIGN="LEFT"/>browse_output()<br ALIGN="LEFT"/>create_generate_tab()<br ALIGN="LEFT"/>create_reports_tab()<br ALIGN="LEFT"/>create_template()<br ALIGN="LEFT"/>create_templates_tab()<br ALIGN="LEFT"/>delete_report()<br ALIGN="LEFT"/>duplicate_report()<br ALIGN="LEFT"/>edit_report()<br ALIGN="LEFT"/>edit_template()<br ALIGN="LEFT"/>export_report()<br ALIGN="LEFT"/>filter_reports()<br ALIGN="LEFT"/>format_file_size(size_bytes: int): str<br ALIGN="LEFT"/>generate_report()<br ALIGN="LEFT"/>load_reports()<br ALIGN="LEFT"/>on_generation_finished(success: bool, message: str, output_path: str)<br ALIGN="LEFT"/>on_report_selected()<br ALIGN="LEFT"/>on_template_selected()<br ALIGN="LEFT"/>preview_report()<br ALIGN="LEFT"/>refresh_report_list()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_report_preview(report_id: str)<br ALIGN="LEFT"/>update_reports_table()<br ALIGN="LEFT"/>use_template()<br ALIGN="LEFT"/>view_report()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.icp_report_generator.ReportOptions" [color="black", fontcolor="black", label=<{ReportOptions|include_bypass_methods : bool<br ALIGN="LEFT"/>include_entropy_graph : bool<br ALIGN="LEFT"/>include_raw_json : bool<br ALIGN="LEFT"/>include_recommendations : bool<br ALIGN="LEFT"/>include_technical_details : bool<br ALIGN="LEFT"/>output_format : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.ReportOptionsDialog" [color="black", fontcolor="black", label=<{ReportOptionsDialog|format_combo<br ALIGN="LEFT"/>raw_data_check<br ALIGN="LEFT"/>recommendations_check<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.repositories.factory.RepositoryFactory" [color="black", fontcolor="black", label=<{RepositoryFactory|<br ALIGN="LEFT"/>|create_repository(config: Dict[str, Any]): Optional[ModelRepositoryInterface]<br ALIGN="LEFT"/>get_available_repository_types(): List[str]<br ALIGN="LEFT"/>register_repository_type(type_name: str, repository_class: Type[ModelRepositoryInterface])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestClassifier" [color="black", fontcolor="black", label=<{RequestClassifier|auth_patterns : dict<br ALIGN="LEFT"/>license_patterns : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>provider_patterns : dict<br ALIGN="LEFT"/>|classify_request(request: RequestInfo): Tuple[CloudProvider, AuthenticationType, RequestType, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestInfo" [color="black", fontcolor="black", label=<{RequestInfo|auth_type<br ALIGN="LEFT"/>body : bytes<br ALIGN="LEFT"/>client_ip : str<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>headers : Dict[str, str]<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>provider<br ALIGN="LEFT"/>request_type<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>url : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestType" [color="black", fontcolor="black", label=<{RequestType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.import_checks.get_fallback_implementations.RequestsFallback" [color="black", fontcolor="black", label=<{RequestsFallback|<br ALIGN="LEFT"/>|get(url)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.ResearchManager" [color="black", fontcolor="black", label=<{ResearchManager|active_campaigns : dict<br ALIGN="LEFT"/>binary_differ<br ALIGN="LEFT"/>campaign_results : dict<br ALIGN="LEFT"/>campaign_templates : dict<br ALIGN="LEFT"/>completed_campaigns : dict<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>correlation_patterns : dict<br ALIGN="LEFT"/>correlation_stats : dict<br ALIGN="LEFT"/>fuzzing_engine<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>vulnerability_analyzer<br ALIGN="LEFT"/>|cancel_campaign(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>create_campaign(name: str, campaign_type: CampaignType, targets: List[str], template: Optional[str], custom_config: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_campaign_results(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>get_campaign_status(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>list_campaigns(status_filter: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>pause_campaign(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>resume_campaign(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>start_campaign(campaign_id: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.ResearchWorkerThread" [color="black", fontcolor="black", label=<{ResearchWorkerThread|analysis_completed<br ALIGN="LEFT"/>binary_diff_completed<br ALIGN="LEFT"/>campaign_status_changed<br ALIGN="LEFT"/>campaign_updated<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>fuzzing_progress<br ALIGN="LEFT"/>operation_queue : list<br ALIGN="LEFT"/>research_manager<br ALIGN="LEFT"/>results_ready<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|add_operation(operation_type: str)<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.ResilienceSelfHealingSystem" [color="black", fontcolor="black", label=<{ResilienceSelfHealingSystem|auto_recovery_enabled : bool<br ALIGN="LEFT"/>emergency_shutdown_threshold : int<br ALIGN="LEFT"/>health_monitor<br ALIGN="LEFT"/>recovery_system<br ALIGN="LEFT"/>state_manager<br ALIGN="LEFT"/>|disable_auto_recovery()<br ALIGN="LEFT"/>enable_auto_recovery()<br ALIGN="LEFT"/>enable_enhanced_monitoring()<br ALIGN="LEFT"/>get_system_resilience_status(): Dict[str, Any]<br ALIGN="LEFT"/>trigger_emergency_recovery()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.ResourceAllocation" [color="black", fontcolor="black", label=<{ResourceAllocation|cache_size_mb : int<br ALIGN="LEFT"/>cpu_cores : int<br ALIGN="LEFT"/>gpu_memory_mb : int<br ALIGN="LEFT"/>io_buffer_size : int<br ALIGN="LEFT"/>max_processes : int<br ALIGN="LEFT"/>max_threads : int<br ALIGN="LEFT"/>memory_mb : int<br ALIGN="LEFT"/>priority_level : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceContext" [color="black", fontcolor="black", label=<{ResourceContext|managed_resources : List[str]<br ALIGN="LEFT"/>owner : str<br ALIGN="LEFT"/>resource_manager<br ALIGN="LEFT"/>|cleanup_all()<br ALIGN="LEFT"/>get_resource_count(): int<br ALIGN="LEFT"/>register_resource(resource_type: ResourceType, resource_handle: Any, cleanup_func: Callable, metadata: Dict): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.ResourceInfo" [color="black", fontcolor="black", label=<{ResourceInfo|data_hash : str<br ALIGN="LEFT"/>language : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.ResourceManager" [color="black", fontcolor="black", label=<{ResourceManager|active_allocations : Dict[str, ResourceAllocation]<br ALIGN="LEFT"/>allocation_history : deque<br ALIGN="LEFT"/>resource_limits : dict<br ALIGN="LEFT"/>resource_pools : Dict[ResourceType, Any]<br ALIGN="LEFT"/>|allocate_resources(operation_id: str, requirements: ResourceAllocation): bool<br ALIGN="LEFT"/>get_resource_usage(): Dict[str, float]<br ALIGN="LEFT"/>optimize_resource_allocation(): Dict[str, Any]<br ALIGN="LEFT"/>release_resources(operation_id: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceManager" [color="black", fontcolor="black", label=<{ResourceManager|cleanup_interval : int<br ALIGN="LEFT"/>max_containers : int<br ALIGN="LEFT"/>max_memory_mb : int<br ALIGN="LEFT"/>max_processes : int<br ALIGN="LEFT"/>max_vms : int<br ALIGN="LEFT"/>|cleanup_all()<br ALIGN="LEFT"/>cleanup_by_owner(owner: str): int<br ALIGN="LEFT"/>emergency_cleanup(): Dict[str, int]<br ALIGN="LEFT"/>force_cleanup_by_type(resource_type: ResourceType): int<br ALIGN="LEFT"/>force_cleanup_expired(max_age_seconds: int): int<br ALIGN="LEFT"/>get_resource(resource_id: str): Optional[ManagedResource]<br ALIGN="LEFT"/>get_resource_usage_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_resources_by_owner(owner: str): List[ManagedResource]<br ALIGN="LEFT"/>health_check(): Dict[str, Any]<br ALIGN="LEFT"/>managed_container(container_id: str, container_name: Optional[str])<br ALIGN="LEFT"/>managed_process(command: Union[str, List[str]])<br ALIGN="LEFT"/>managed_vm(vm_name: str, vm_process: Optional[subprocess.Popen])<br ALIGN="LEFT"/>register_resource(resource: ManagedResource): str<br ALIGN="LEFT"/>release_resource(resource_id: str)<br ALIGN="LEFT"/>set_resource_limits()<br ALIGN="LEFT"/>temp_directory(prefix: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ResourceManager" [color="black", fontcolor="black", label=<{ResourceManager|auto_cleanup<br ALIGN="LEFT"/>config : Dict[str, Any]<br ALIGN="LEFT"/>logger : Logger<br ALIGN="LEFT"/>max_cpu_usage<br ALIGN="LEFT"/>max_memory_usage<br ALIGN="LEFT"/>max_workers<br ALIGN="LEFT"/>monitoring_enabled<br ALIGN="LEFT"/>monitoring_task : Optional[asyncio.Task]<br ALIGN="LEFT"/>process_pool : Optional[ProcessPoolExecutor]<br ALIGN="LEFT"/>resource_stats : dict<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>thread_pool : Optional[ThreadPoolExecutor]<br ALIGN="LEFT"/>tracked_processes : Dict[int, psutil.Process]<br ALIGN="LEFT"/>|execute_in_process(func: Callable)<br ALIGN="LEFT"/>execute_in_thread(func: Callable)<br ALIGN="LEFT"/>get_resource_stats(): Dict[str, Any]<br ALIGN="LEFT"/>kill_process(pid: int, force: bool)<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>start_external_process(cmd: List[str], cwd: str, timeout: int): subprocess.Popen<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.ResourcePool" [color="black", fontcolor="black", label=<{ResourcePool|allocated : int<br ALIGN="LEFT"/>available_items : List[Any]<br ALIGN="LEFT"/>creation_func : Optional[Callable]<br ALIGN="LEFT"/>growth_factor : float<br ALIGN="LEFT"/>in_use_items : set<br ALIGN="LEFT"/>initial_size : int<br ALIGN="LEFT"/>max_size : int<br ALIGN="LEFT"/>pool_type : str<br ALIGN="LEFT"/>shrink_threshold : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceState" [color="black", fontcolor="black", label=<{ResourceState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.performance_optimization_layer.ResourceType" [color="black", fontcolor="black", label=<{ResourceType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceType" [color="black", fontcolor="black", label=<{ResourceType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.ResourceType" [color="black", fontcolor="black", label=<{ResourceType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceUsage" [color="black", fontcolor="black", label=<{ResourceUsage|cpu_percent : float<br ALIGN="LEFT"/>disk_io_mb : float<br ALIGN="LEFT"/>last_update : datetime<br ALIGN="LEFT"/>memory_mb : float<br ALIGN="LEFT"/>network_io_mb : float<br ALIGN="LEFT"/>start_time : datetime<br ALIGN="LEFT"/>|get_duration(): timedelta<br ALIGN="LEFT"/>update(process: psutil.Process)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.dynamic_response_generator.ResponseContext" [color="black", fontcolor="black", label=<{ResponseContext|client_fingerprint : str<br ALIGN="LEFT"/>headers : Optional[Dict[str, str]]<br ALIGN="LEFT"/>parsed_request : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>protocol_type : str<br ALIGN="LEFT"/>request_data : bytes<br ALIGN="LEFT"/>source_ip : str<br ALIGN="LEFT"/>source_port : int<br ALIGN="LEFT"/>target_host : str<br ALIGN="LEFT"/>target_port : int<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.ResponseInfo" [color="black", fontcolor="black", label=<{ResponseInfo|body : bytes<br ALIGN="LEFT"/>bypass_applied : bool<br ALIGN="LEFT"/>cache_hit : bool<br ALIGN="LEFT"/>headers : Dict[str, str]<br ALIGN="LEFT"/>original_response : Optional[bytes]<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>status : int<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.parsing_utils.ResponseLineParser" [color="black", fontcolor="black", label=<{ResponseLineParser|<br ALIGN="LEFT"/>|clean_and_filter_lines(lines: List[str], min_length: int, filter_patterns: Optional[List[str]]): List[str]<br ALIGN="LEFT"/>extract_structured_content(response: str, patterns: List[str], section_separators: Optional[List[str]]): List[Dict[str, str]]<br ALIGN="LEFT"/>parse_lines_by_sections(response: str, section_keywords: Dict[str, List[str]], line_processor: Optional[Callable[[str, str], Optional[str]]]): Dict[str, List[str]]<br ALIGN="LEFT"/>parse_lines_with_categorization(response: str, category_keywords: Dict[str, List[str]], default_category: str): Dict[str, List[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.ResponseModifier" [color="black", fontcolor="black", label=<{ResponseModifier|auth_manager<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|modify_response(request: RequestInfo, original_response: aiohttp.ClientResponse, response_body: bytes): Tuple[int, Dict[str, str], bytes]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_cache_manager.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.incremental_manager.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.analysis_cache.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.core.exception_utils.RestrictedUnpickler" [color="black", fontcolor="black", label=<{RestrictedUnpickler|<br ALIGN="LEFT"/>|find_class(module, name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.shared.result_utils.ResultMixin" [color="black", fontcolor="black", label=<{ResultMixin|<br ALIGN="LEFT"/>|create_analysis_result(): Dict[str, Any]<br ALIGN="LEFT"/>init_result(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.ReverseEngineeringAgent" [color="black", fontcolor="black", label=<{ReverseEngineeringAgent|capabilities : list<br ALIGN="LEFT"/>|execute_task(task: AgentTask): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.RuntimeMetric" [color="black", fontcolor="black", label=<{RuntimeMetric|category : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>metric_name : str<br ALIGN="LEFT"/>source : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.RuntimeMonitor" [color="black", fontcolor="black", label=<{RuntimeMonitor|active : bool<br ALIGN="LEFT"/>adaptation_rules : Dict[str, Dict]<br ALIGN="LEFT"/>anomaly_detectors : Dict[str, AnomalyDetector]<br ALIGN="LEFT"/>anomaly_history : list<br ALIGN="LEFT"/>metric_aggregates : Dict[str, Dict[str, float]]<br ALIGN="LEFT"/>metric_history : Dict[str, deque]<br ALIGN="LEFT"/>metrics_buffer : deque<br ALIGN="LEFT"/>monitor_interval : float<br ALIGN="LEFT"/>monitor_thread : Optional[threading.Thread]<br ALIGN="LEFT"/>subscribers : List[Callable[[RuntimeMetric], None]]<br ALIGN="LEFT"/>|get_metric_trend(metric_name: str, window_minutes: int): Dict[str, Any]<br ALIGN="LEFT"/>record_metric(metric_name: str, value: float, source: str, category: str, metadata: Dict[str, Any])<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>subscribe_to_metrics(callback: Callable[[RuntimeMetric], None])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator._start_ssl_interceptor.SSLInterceptor" [color="black", fontcolor="black", label=<{SSLInterceptor|context : SSLContext<br ALIGN="LEFT"/>parent : str<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>|intercept_connection(client_socket: socket.socket, server_address: Tuple[str, int]): None<br ALIGN="LEFT"/>stop(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.ssl_interceptor.SSLTLSInterceptor" [color="black", fontcolor="black", label=<{SSLTLSInterceptor|ca_cert : NoneType<br ALIGN="LEFT"/>ca_key : NoneType<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>proxy_process : NoneType, Popen<br ALIGN="LEFT"/>proxy_server : NoneType<br ALIGN="LEFT"/>response_templates : dict<br ALIGN="LEFT"/>traffic_log : list<br ALIGN="LEFT"/>|add_target_host(host: str)<br ALIGN="LEFT"/>configure(config: Dict[str, Any]): bool<br ALIGN="LEFT"/>generate_ca_certificate(): Tuple[Optional[bytes], Optional[bytes]]<br ALIGN="LEFT"/>get_config(): Dict[str, Any]<br ALIGN="LEFT"/>get_target_hosts(): List[str]<br ALIGN="LEFT"/>get_traffic_log(): List[Dict[str, Any]]<br ALIGN="LEFT"/>remove_target_host(host: str)<br ALIGN="LEFT"/>start(): bool<br ALIGN="LEFT"/>stop(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.STARTUPINFO" [color="black", fontcolor="black", label=<{STARTUPINFO|cb<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_structures.WindowsProcessStructures.create_startup_info.STARTUPINFO" [color="black", fontcolor="black", label=<{STARTUPINFO|cb<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.SafeModuleReplacer" [color="black", fontcolor="black", label=<{SafeModuleReplacer|original_modules : dict<br ALIGN="LEFT"/>replaced_modules : set<br ALIGN="LEFT"/>|replace_module(module_name: str, fallback_factory)<br ALIGN="LEFT"/>restore_module(module_name: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.SafetensorsBackend" [color="black", fontcolor="black", label=<{SafetensorsBackend|device : NoneType, device<br ALIGN="LEFT"/>is_initialized : bool<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.SafetyVerificationSystem" [color="black", fontcolor="black", label=<{SafetyVerificationSystem|risk_thresholds : dict<br ALIGN="LEFT"/>safety_rules : List[Dict[str, Any]], list<br ALIGN="LEFT"/>|verify_chain_safety(chain: ExploitChain): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxConfig" [color="black", fontcolor="black", label=<{SandboxConfig|analysis_depth<br ALIGN="LEFT"/>command_line_args : List[str]<br ALIGN="LEFT"/>cpu_limit : int<br ALIGN="LEFT"/>custom_hooks : Dict[str, Callable]<br ALIGN="LEFT"/>custom_rootfs : Optional[str]<br ALIGN="LEFT"/>enable_api_hooks : bool<br ALIGN="LEFT"/>enable_filesystem : bool<br ALIGN="LEFT"/>enable_memory_monitoring : bool<br ALIGN="LEFT"/>enable_network : bool<br ALIGN="LEFT"/>enable_registry : bool<br ALIGN="LEFT"/>enable_snapshots : bool<br ALIGN="LEFT"/>environment_vars : Dict[str, str]<br ALIGN="LEFT"/>max_memory : int<br ALIGN="LEFT"/>sandbox_type<br ALIGN="LEFT"/>snapshot_interval : int<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>working_directory : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector" [color="black", fontcolor="black", label=<{SandboxDetector|behavioral_patterns : dict<br ALIGN="LEFT"/>detection_methods : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>sandbox_signatures : dict<br ALIGN="LEFT"/>|detect_sandbox(aggressive: bool): Dict[str, Any]<br ALIGN="LEFT"/>generate_sandbox_evasion(): str<br ALIGN="LEFT"/>get_aggressive_methods(): List[str]<br ALIGN="LEFT"/>get_detection_type(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxManager" [color="black", fontcolor="black", label=<{SandboxManager|logger : NoneType, RootLogger<br ALIGN="LEFT"/>qemu_available : bool<br ALIGN="LEFT"/>qiling_available : bool<br ALIGN="LEFT"/>|analyze_binary(binary_path: str, config: Optional[SandboxConfig]): SandboxResult<br ALIGN="LEFT"/>compare_sandbox_results(result1: SandboxResult, result2: SandboxResult): Dict[str, Any]<br ALIGN="LEFT"/>export_results(result: SandboxResult, output_path: str, format: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxResult" [color="black", fontcolor="black", label=<{SandboxResult|anti_debug_techniques : List[Dict[str, Any]]<br ALIGN="LEFT"/>anti_vm_checks : List[Dict[str, Any]]<br ALIGN="LEFT"/>api_calls : List[Dict[str, Any]]<br ALIGN="LEFT"/>debug_log : str<br ALIGN="LEFT"/>dns_queries : List[str]<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>exit_code : Optional[int]<br ALIGN="LEFT"/>files_created : List[str]<br ALIGN="LEFT"/>files_deleted : List[str]<br ALIGN="LEFT"/>files_modified : List[str]<br ALIGN="LEFT"/>files_read : List[str]<br ALIGN="LEFT"/>license_api_calls : List[Dict[str, Any]]<br ALIGN="LEFT"/>license_checks : List[Dict[str, Any]]<br ALIGN="LEFT"/>license_files_accessed : List[str]<br ALIGN="LEFT"/>memory_allocations : List[Dict[str, Any]]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>network_connections : List[Dict[str, Any]]<br ALIGN="LEFT"/>processes_created : List[Dict[str, Any]]<br ALIGN="LEFT"/>registry_keys_created : List[str]<br ALIGN="LEFT"/>registry_keys_deleted : List[str]<br ALIGN="LEFT"/>registry_keys_modified : List[str]<br ALIGN="LEFT"/>sandbox_type<br ALIGN="LEFT"/>snapshot_diffs : List[Dict[str, Any]]<br ALIGN="LEFT"/>snapshots : List[Dict[str, Any]]<br ALIGN="LEFT"/>stderr : str<br ALIGN="LEFT"/>stdout : str<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>suspicious_memory_patterns : List[Dict[str, Any]]<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxType" [color="black", fontcolor="black", label=<{SandboxType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.icp_backend.ScanMode" [color="black", fontcolor="black", label=<{ScanMode|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.ScanMode" [color="black", fontcolor="black", label=<{ScanMode|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.tools.pcapy_compat.ScapyPacketReader" [color="black", fontcolor="black", label=<{ScapyPacketReader|filter : NoneType<br ALIGN="LEFT"/>interface : NoneType, str<br ALIGN="LEFT"/>promisc : bool<br ALIGN="LEFT"/>timeout : float<br ALIGN="LEFT"/>|loop(count, callback)<br ALIGN="LEFT"/>setfilter(filter_str)<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" [color="black", fontcolor="black", label=<{ScriptExecutionManager|QEMUTestDialog : NoneType<br ALIGN="LEFT"/>QEMUTestResultsDialog : NoneType<br ALIGN="LEFT"/>execution_completed<br ALIGN="LEFT"/>execution_started<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_concurrent_scripts : int<br ALIGN="LEFT"/>qemu_manager : NoneType<br ALIGN="LEFT"/>qemu_test_completed<br ALIGN="LEFT"/>qemu_test_started<br ALIGN="LEFT"/>running_scripts : dict<br ALIGN="LEFT"/>script_history : dict<br ALIGN="LEFT"/>script_queue : list<br ALIGN="LEFT"/>settings<br ALIGN="LEFT"/>|add_trusted_binary(binary_path: str)<br ALIGN="LEFT"/>execute_script(script_type: str, script_content: str, target_binary: str, options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_execution_history(limit: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>remove_trusted_binary(binary_path: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.script_generation_prompts.ScriptGenerationPrompts" [color="black", fontcolor="black", label=<{ScriptGenerationPrompts|logger : NoneType, RootLogger<br ALIGN="LEFT"/>prompts : dict<br ALIGN="LEFT"/>|build_context_data(binary_analysis: Dict[str, Any], protection_types: List[str]): Dict[str, str]<br ALIGN="LEFT"/>get_available_prompt_types(): List[str]<br ALIGN="LEFT"/>get_frida_prompt(complexity: str): Dict[str, str]<br ALIGN="LEFT"/>get_ghidra_prompt(complexity: str): Dict[str, str]<br ALIGN="LEFT"/>get_prompt(prompt_type: PromptType): Dict[str, str]<br ALIGN="LEFT"/>get_prompt_requirements(prompt_type: PromptType): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptGenerationResult" [color="black", fontcolor="black", label=<{ScriptGenerationResult|confidence_score : float<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>generation_time : float<br ALIGN="LEFT"/>iterations : int<br ALIGN="LEFT"/>recommendations : List[str]<br ALIGN="LEFT"/>script : Optional[GeneratedScript]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [color="black", fontcolor="black", label=<{ScriptGeneratorDialog|analysis_depth : NoneType<br ALIGN="LEFT"/>analyze_btn : NoneType<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>bypass_config : NoneType<br ALIGN="LEFT"/>bypass_language : NoneType<br ALIGN="LEFT"/>bypass_methods<br ALIGN="LEFT"/>bypass_output : NoneType<br ALIGN="LEFT"/>close_btn : NoneType<br ALIGN="LEFT"/>config_layout<br ALIGN="LEFT"/>config_stack<br ALIGN="LEFT"/>copy_btn : NoneType<br ALIGN="LEFT"/>doc_display : NoneType<br ALIGN="LEFT"/>exploit_advanced : NoneType<br ALIGN="LEFT"/>exploit_config : NoneType<br ALIGN="LEFT"/>exploit_type : NoneType<br ALIGN="LEFT"/>generate_btn<br ALIGN="LEFT"/>generated_scripts : dict<br ALIGN="LEFT"/>highlighter : NoneType<br ALIGN="LEFT"/>include_analysis : NoneType<br ALIGN="LEFT"/>include_exploitation : NoneType<br ALIGN="LEFT"/>include_options : NoneType<br ALIGN="LEFT"/>include_persistence : NoneType<br ALIGN="LEFT"/>include_recon : NoneType<br ALIGN="LEFT"/>method_hook : NoneType<br ALIGN="LEFT"/>method_loader : NoneType<br ALIGN="LEFT"/>method_memory : NoneType<br ALIGN="LEFT"/>method_patch : NoneType<br ALIGN="LEFT"/>method_registry : NoneType<br ALIGN="LEFT"/>payload_type : NoneType<br ALIGN="LEFT"/>save_btn : NoneType<br ALIGN="LEFT"/>script_display : NoneType<br ALIGN="LEFT"/>script_tabs : NoneType<br ALIGN="LEFT"/>script_type_combo<br ALIGN="LEFT"/>status_label : NoneType<br ALIGN="LEFT"/>strategy_config : NoneType<br ALIGN="LEFT"/>strategy_type : NoneType<br ALIGN="LEFT"/>target_function : NoneType<br ALIGN="LEFT"/>template_display : NoneType<br ALIGN="LEFT"/>test_btn : NoneType<br ALIGN="LEFT"/>worker : NoneType<br ALIGN="LEFT"/>|analyze_script()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>copy_script()<br ALIGN="LEFT"/>generate_script()<br ALIGN="LEFT"/>get_bypass_config()<br ALIGN="LEFT"/>get_exploit_config()<br ALIGN="LEFT"/>get_strategy_config()<br ALIGN="LEFT"/>on_binary_path_changed(text)<br ALIGN="LEFT"/>on_error(error_msg)<br ALIGN="LEFT"/>on_script_generated(result)<br ALIGN="LEFT"/>on_script_type_changed(script_type)<br ALIGN="LEFT"/>save_script()<br ALIGN="LEFT"/>setup_bypass_config()<br ALIGN="LEFT"/>setup_exploit_config()<br ALIGN="LEFT"/>setup_footer(layout)<br ALIGN="LEFT"/>setup_header(layout)<br ALIGN="LEFT"/>setup_left_panel(splitter)<br ALIGN="LEFT"/>setup_main_content(layout)<br ALIGN="LEFT"/>setup_right_panel(splitter)<br ALIGN="LEFT"/>setup_strategy_config()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>test_script()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.ScriptGeneratorPanel" [color="black", fontcolor="black", label=<{ScriptGeneratorPanel|config<br ALIGN="LEFT"/>custom_editor : ScrolledText<br ALIGN="LEFT"/>custom_lang_var : StringVar<br ALIGN="LEFT"/>frame : Frame<br ALIGN="LEFT"/>frida_editor : ScrolledText<br ALIGN="LEFT"/>frida_process_var : StringVar<br ALIGN="LEFT"/>frida_type_var : StringVar<br ALIGN="LEFT"/>ghidra_binary_var : StringVar<br ALIGN="LEFT"/>ghidra_editor : ScrolledText<br ALIGN="LEFT"/>ghidra_type_var : StringVar<br ALIGN="LEFT"/>notebook : Notebook<br ALIGN="LEFT"/>parent : Widget<br ALIGN="LEFT"/>r2_binary_var : StringVar<br ALIGN="LEFT"/>r2_editor : ScrolledText<br ALIGN="LEFT"/>r2_type_var : StringVar<br ALIGN="LEFT"/>script_history : list<br ALIGN="LEFT"/>ui_controller<br ALIGN="LEFT"/>|add_to_script_history(platform: str, script_type: str, content: str)<br ALIGN="LEFT"/>browse_binary()<br ALIGN="LEFT"/>browse_process()<br ALIGN="LEFT"/>browse_r2_binary()<br ALIGN="LEFT"/>create_custom_tab()<br ALIGN="LEFT"/>create_frida_tab()<br ALIGN="LEFT"/>create_ghidra_tab()<br ALIGN="LEFT"/>create_radare2_tab()<br ALIGN="LEFT"/>generate_frida_script()<br ALIGN="LEFT"/>generate_ghidra_script()<br ALIGN="LEFT"/>generate_r2_script()<br ALIGN="LEFT"/>highlight_syntax(text_widget, keywords)<br ALIGN="LEFT"/>load_custom_script()<br ALIGN="LEFT"/>load_frida_script()<br ALIGN="LEFT"/>load_ghidra_script()<br ALIGN="LEFT"/>load_r2_script()<br ALIGN="LEFT"/>load_script_to_editor(editor: scrolledtext.ScrolledText, title: str, filetypes: List[Tuple[str, str]])<br ALIGN="LEFT"/>on_language_change(event)<br ALIGN="LEFT"/>run_custom_script()<br ALIGN="LEFT"/>run_frida_script()<br ALIGN="LEFT"/>run_ghidra_script()<br ALIGN="LEFT"/>run_r2_script()<br ALIGN="LEFT"/>save_custom_script()<br ALIGN="LEFT"/>save_frida_script()<br ALIGN="LEFT"/>save_ghidra_script()<br ALIGN="LEFT"/>save_r2_script()<br ALIGN="LEFT"/>save_script_to_file(script: str, title: str, filetypes: List[Tuple[str, str]])<br ALIGN="LEFT"/>setup_java_syntax_highlighting(text_widget)<br ALIGN="LEFT"/>setup_js_syntax_highlighting(text_widget)<br ALIGN="LEFT"/>setup_python_syntax_highlighting(text_widget)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorWorker" [color="black", fontcolor="black", label=<{ScriptGeneratorWorker|ai_generator : NoneType<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>error_occurred<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>script_generated<br ALIGN="LEFT"/>script_type : str<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.ghidra_script_selector.ScriptInfoWidget" [color="black", fontcolor="black", label=<{ScriptInfoWidget|author_label<br ALIGN="LEFT"/>category_label<br ALIGN="LEFT"/>current_script : NoneType, Optional[GhidraScript]<br ALIGN="LEFT"/>description_text<br ALIGN="LEFT"/>modified_label<br ALIGN="LEFT"/>name_label<br ALIGN="LEFT"/>size_label<br ALIGN="LEFT"/>tags_label<br ALIGN="LEFT"/>type_label<br ALIGN="LEFT"/>validation_errors<br ALIGN="LEFT"/>validation_group<br ALIGN="LEFT"/>validation_label<br ALIGN="LEFT"/>version_label<br ALIGN="LEFT"/>|update_script_info(script: Optional[GhidraScript])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptMetadata" [color="black", fontcolor="black", label=<{ScriptMetadata|generated_at : datetime<br ALIGN="LEFT"/>generation_time : float<br ALIGN="LEFT"/>iterations : int<br ALIGN="LEFT"/>llm_model : str<br ALIGN="LEFT"/>protection_types : List[ProtectionType]<br ALIGN="LEFT"/>refinement_notes : List[str]<br ALIGN="LEFT"/>script_id : str<br ALIGN="LEFT"/>script_type<br ALIGN="LEFT"/>success_probability : float<br ALIGN="LEFT"/>target_binary : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptTemplateEngine" [color="black", fontcolor="black", label=<{ScriptTemplateEngine|frida_base_template : str<br ALIGN="LEFT"/>ghidra_base_template : str<br ALIGN="LEFT"/>|render_frida_script(): str<br ALIGN="LEFT"/>render_ghidra_script(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.script_templates.ScriptTemplateEngine" [color="black", fontcolor="black", label=<{ScriptTemplateEngine|frida_templates<br ALIGN="LEFT"/>ghidra_templates<br ALIGN="LEFT"/>|render_frida_script(): str<br ALIGN="LEFT"/>render_ghidra_script(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptType" [color="black", fontcolor="black", label=<{ScriptType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptValidator" [color="black", fontcolor="black", label=<{ScriptValidator|context_compression_ratio : float<br ALIGN="LEFT"/>forbidden_patterns : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_context_tokens : int<br ALIGN="LEFT"/>required_frida_elements : list<br ALIGN="LEFT"/>required_ghidra_elements : list<br ALIGN="LEFT"/>|validate_script(script: GeneratedScript): Tuple[bool, List[str]]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.SearchEngine" [color="black", fontcolor="black", label=<{SearchEngine|chunk_size : int<br ALIGN="LEFT"/>file_handler<br ALIGN="LEFT"/>|replace_all(find_pattern: Union[str, bytes], replace_pattern: Union[str, bytes], search_type: SearchType, case_sensitive: bool, whole_words: bool): List[Tuple[int, int]]<br ALIGN="LEFT"/>search(pattern: Union[str, bytes], search_type: SearchType, start_offset: int, case_sensitive: bool, whole_words: bool, direction: str): Optional[SearchResult]<br ALIGN="LEFT"/>search_all(pattern: Union[str, bytes], search_type: SearchType, case_sensitive: bool, whole_words: bool, max_results: int): List[SearchResult]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.SearchHistory" [color="black", fontcolor="black", label=<{SearchHistory|entries : List[Dict[str, Any]], list<br ALIGN="LEFT"/>history_file<br ALIGN="LEFT"/>max_entries : int<br ALIGN="LEFT"/>|add_search(pattern: str, search_type: SearchType, options: Dict[str, Any])<br ALIGN="LEFT"/>get_recent_searches(search_type: Optional[SearchType], limit: int): List[str]<br ALIGN="LEFT"/>load_history()<br ALIGN="LEFT"/>save_history()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.SearchResult" [color="black", fontcolor="black", label=<{SearchResult|context : bytes<br ALIGN="LEFT"/>data : bytes<br ALIGN="LEFT"/>length : int<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'SearchResult'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.SearchThread" [color="black", fontcolor="black", label=<{SearchThread|find_all : bool<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>pattern : str<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>result_found<br ALIGN="LEFT"/>search_completed<br ALIGN="LEFT"/>search_engine<br ALIGN="LEFT"/>search_type<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.similarity_search_dialog.BinarySimilaritySearchDialog.search_similar_binaries.SearchThread" [color="black", fontcolor="black", label=<{SearchThread|binary_path : str<br ALIGN="LEFT"/>result_signal<br ALIGN="LEFT"/>search_engine<br ALIGN="LEFT"/>threshold : float<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.advanced_search.SearchType" [color="black", fontcolor="black", label=<{SearchType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.secrets_manager.SecretsManager" [color="black", fontcolor="black", label=<{SecretsManager|KNOWN_SECRETS : list<br ALIGN="LEFT"/>SERVICE_NAME : str<br ALIGN="LEFT"/>config_dir<br ALIGN="LEFT"/>key_file<br ALIGN="LEFT"/>secrets_file<br ALIGN="LEFT"/>|clear_cache()<br ALIGN="LEFT"/>delete(key: str)<br ALIGN="LEFT"/>export_secrets(include_values: bool): Dict[str, Any]<br ALIGN="LEFT"/>find_env_file_location(): Optional[str]<br ALIGN="LEFT"/>generate_key_from_password(password: str, salt: Optional[bytes]): bytes<br ALIGN="LEFT"/>get(key: str, default: Optional[str]): Optional[str]<br ALIGN="LEFT"/>get_api_key(service: str): Optional[str]<br ALIGN="LEFT"/>import_secrets(secrets: Dict[str, str], use_keychain: bool)<br ALIGN="LEFT"/>list_keys(): list<br ALIGN="LEFT"/>rotate_key(old_key: str, new_key: str)<br ALIGN="LEFT"/>set(key: str, value: str, use_keychain: bool)<br ALIGN="LEFT"/>verify_password_hash(password: str, stored_hash: bytes, salt: bytes): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.pe_file_model.SectionInfo" [color="black", fontcolor="black", label=<{SectionInfo|characteristics : int<br ALIGN="LEFT"/>entropy : Optional[float]<br ALIGN="LEFT"/>is_executable<br ALIGN="LEFT"/>is_readable<br ALIGN="LEFT"/>is_writable<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>raw_offset : int<br ALIGN="LEFT"/>raw_size : int<br ALIGN="LEFT"/>virtual_address : int<br ALIGN="LEFT"/>virtual_size : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.security_enforcement.SecureHash" [color="black", fontcolor="black", label=<{SecureHash|block_size<br ALIGN="LEFT"/>digest_size<br ALIGN="LEFT"/>name<br ALIGN="LEFT"/>|copy()<br ALIGN="LEFT"/>digest()<br ALIGN="LEFT"/>hexdigest()<br ALIGN="LEFT"/>update(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.security_enforcement._monkey_patch_subprocess.SecurePopen" [color="black", fontcolor="black", label=<{SecurePopen|returncode : NoneType, object<br ALIGN="LEFT"/>stdin<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.security_enforcement.SecurityEnforcement" [color="black", fontcolor="black", label=<{SecurityEnforcement|config : dict<br ALIGN="LEFT"/>security_config<br ALIGN="LEFT"/>|disable_bypass()<br ALIGN="LEFT"/>enable_bypass()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.security_enforcement.SecurityError" [color="black", fontcolor="red", label=<{SecurityError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.security_utils.SecurityError" [color="black", fontcolor="red", label=<{SecurityError|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.SecurityFinding" [color="black", fontcolor="black", label=<{SecurityFinding|confidence : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>evidence : str<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>finding_type<br ALIGN="LEFT"/>is_critical<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>remediation : str<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.SecurityFindingType" [color="black", fontcolor="black", label=<{SecurityFindingType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticAnalysisResult" [color="black", fontcolor="black", label=<{SemanticAnalysisResult|analysis_id : str<br ALIGN="LEFT"/>analysis_time : float<br ALIGN="LEFT"/>business_logic_map : Dict[str, BusinessLogicPattern]<br ALIGN="LEFT"/>complexity_metrics : Dict[str, float]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>intent_mismatches : List[IntentMismatch]<br ALIGN="LEFT"/>relationships : List[SemanticRelationship]<br ALIGN="LEFT"/>semantic_nodes : List[SemanticNode]<br ALIGN="LEFT"/>semantic_summary : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticCodeAnalyzer" [color="black", fontcolor="black", label=<{SemanticCodeAnalyzer|analysis_cache : Dict[str, SemanticAnalysisResult]<br ALIGN="LEFT"/>cache_ttl : int<br ALIGN="LEFT"/>llm_manager<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>nlp_processor<br ALIGN="LEFT"/>semantic_kb<br ALIGN="LEFT"/>|analyze_file(file_path: str, content: Optional[str]): SemanticAnalysisResult<br ALIGN="LEFT"/>get_semantic_insights(file_paths: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticIntent" [color="black", fontcolor="black", label=<{SemanticIntent|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticKnowledgeBase" [color="black", fontcolor="black", label=<{SemanticKnowledgeBase|anti_patterns : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>patterns : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>rules : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticNode" [color="black", fontcolor="black", label=<{SemanticNode|business_pattern : Optional[BusinessLogicPattern]<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>content : str<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>location : Dict[str, int]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>nlp_features : Dict[str, Any]<br ALIGN="LEFT"/>node_id : str<br ALIGN="LEFT"/>node_type : str<br ALIGN="LEFT"/>semantic_intent<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticRelationship" [color="black", fontcolor="black", label=<{SemanticRelationship|confidence : float<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>relationship_id : str<br ALIGN="LEFT"/>relationship_type : str<br ALIGN="LEFT"/>source_node : str<br ALIGN="LEFT"/>strength : float<br ALIGN="LEFT"/>target_node : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.SentinelEmulator" [color="black", fontcolor="black", label=<{SentinelEmulator|cell_data : dict<br ALIGN="LEFT"/>|read_cell(cell_id: int): bytes<br ALIGN="LEFT"/>transform_data(cell_id: int, data: bytes): bytes<br ALIGN="LEFT"/>write_cell(cell_id: int, data: bytes): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.c2.session_manager.Session" [color="black", fontcolor="black", label=<{Session|active_tasks : Dict[str, Any]<br ALIGN="LEFT"/>capabilities<br ALIGN="LEFT"/>client_info<br ALIGN="LEFT"/>command_history : List[Dict[str, Any]]<br ALIGN="LEFT"/>commands_received : int<br ALIGN="LEFT"/>commands_sent : int<br ALIGN="LEFT"/>connection_info : Dict[str, Any]<br ALIGN="LEFT"/>created_at<br ALIGN="LEFT"/>data_received : int<br ALIGN="LEFT"/>data_sent : int<br ALIGN="LEFT"/>last_seen<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>session_id : str<br ALIGN="LEFT"/>stats<br ALIGN="LEFT"/>status : str<br ALIGN="LEFT"/>|add_task(task: Dict[str, Any])<br ALIGN="LEFT"/>get_pending_tasks(): List[Dict[str, Any]]<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>update_last_seen()<br ALIGN="LEFT"/>update_task_status(task_id: str, status: str, result: Any)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.SessionInfo" [color="black", fontcolor="black", label=<{SessionInfo|ai_queries : int<br ALIGN="LEFT"/>commands_executed : int<br ALIGN="LEFT"/>current_binary : Optional[str]<br ALIGN="LEFT"/>current_project : Optional[str]<br ALIGN="LEFT"/>errors_encountered : int<br ALIGN="LEFT"/>exports_created : int<br ALIGN="LEFT"/>start_time : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.session_manager.SessionManager" [color="black", fontcolor="black", label=<{SessionManager|cleanup_thread : NoneType<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>db_path<br ALIGN="LEFT"/>lock : _RLock<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>sessions : Dict[str, Session]<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|cleanup_all_sessions()<br ALIGN="LEFT"/>create_session(connection_info: Dict[str, Any]): Session<br ALIGN="LEFT"/>create_task(session_id: str, task_type: str, task_data: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>export_session_data(session_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>get_active_sessions(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_pending_tasks(session_id: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_session(session_id: str): Optional[Session]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>load_sessions_from_database()<br ALIGN="LEFT"/>mark_session_inactive(session_id: str)<br ALIGN="LEFT"/>mark_task_sent(task_id: str)<br ALIGN="LEFT"/>store_keylog_data(session_id: str, keylog_data: str, timestamp: float)<br ALIGN="LEFT"/>store_screenshot(session_id: str, screenshot_data: bytes, timestamp: float)<br ALIGN="LEFT"/>store_task_result(task_id: str, result: Any, success: bool)<br ALIGN="LEFT"/>store_uploaded_file(session_id: str, filename: str, file_data: bytes)<br ALIGN="LEFT"/>update_session_info(session_id: str, client_info: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.settings_tab.SettingsTab" [color="black", fontcolor="black", label=<{SettingsTab|accent_color_btn<br ALIGN="LEFT"/>ai_max_tokens<br ALIGN="LEFT"/>ai_provider_combo<br ALIGN="LEFT"/>ai_temperature<br ALIGN="LEFT"/>analysis_depth_combo<br ALIGN="LEFT"/>analysis_timeout<br ALIGN="LEFT"/>auto_analysis_cb<br ALIGN="LEFT"/>auto_backup_cb<br ALIGN="LEFT"/>auto_cleanup_cb<br ALIGN="LEFT"/>background_tasks_cb<br ALIGN="LEFT"/>cache_size<br ALIGN="LEFT"/>confirm_dangerous_cb<br ALIGN="LEFT"/>console_font_combo<br ALIGN="LEFT"/>console_font_size<br ALIGN="LEFT"/>debug_mode_cb<br ALIGN="LEFT"/>enable_animations_cb<br ALIGN="LEFT"/>enable_gpu_cb<br ALIGN="LEFT"/>experimental_features_cb<br ALIGN="LEFT"/>ghidra_path<br ALIGN="LEFT"/>gpu_device_combo<br ALIGN="LEFT"/>icon_size_combo<br ALIGN="LEFT"/>ida_path<br ALIGN="LEFT"/>include_comments_cb<br ALIGN="LEFT"/>include_error_handling_cb<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>log_file_path<br ALIGN="LEFT"/>log_level_combo<br ALIGN="LEFT"/>log_to_file_cb<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>memory_limit<br ALIGN="LEFT"/>network_timeout<br ALIGN="LEFT"/>opacity_label<br ALIGN="LEFT"/>opacity_slider<br ALIGN="LEFT"/>optimize_code_cb<br ALIGN="LEFT"/>output_directory<br ALIGN="LEFT"/>parallel_processing_cb<br ALIGN="LEFT"/>preview_area<br ALIGN="LEFT"/>proxy_edit<br ALIGN="LEFT"/>radare2_path<br ALIGN="LEFT"/>reports_directory<br ALIGN="LEFT"/>safe_mode_cb<br ALIGN="LEFT"/>scripts_directory<br ALIGN="LEFT"/>settings : dict<br ALIGN="LEFT"/>settings_changed<br ALIGN="LEFT"/>settings_tabs<br ALIGN="LEFT"/>show_debug_console_cb<br ALIGN="LEFT"/>show_tooltips_cb<br ALIGN="LEFT"/>theme_changed<br ALIGN="LEFT"/>theme_combo<br ALIGN="LEFT"/>ui_font_combo<br ALIGN="LEFT"/>ui_font_size<br ALIGN="LEFT"/>worker_threads<br ALIGN="LEFT"/>x64dbg_path<br ALIGN="LEFT"/>|browse_directory(line_edit, title)<br ALIGN="LEFT"/>browse_file(line_edit, title)<br ALIGN="LEFT"/>browse_path(line_edit, title)<br ALIGN="LEFT"/>collect_settings_from_ui()<br ALIGN="LEFT"/>create_advanced_tab()<br ALIGN="LEFT"/>create_analysis_tab()<br ALIGN="LEFT"/>create_appearance_tab()<br ALIGN="LEFT"/>create_paths_tab()<br ALIGN="LEFT"/>create_performance_tab()<br ALIGN="LEFT"/>create_preview_panel()<br ALIGN="LEFT"/>create_settings_panel()<br ALIGN="LEFT"/>export_settings()<br ALIGN="LEFT"/>get_default_settings()<br ALIGN="LEFT"/>import_settings()<br ALIGN="LEFT"/>load_settings()<br ALIGN="LEFT"/>log_message(message, level)<br ALIGN="LEFT"/>on_opacity_changed(value)<br ALIGN="LEFT"/>on_theme_changed(theme)<br ALIGN="LEFT"/>reset_to_defaults()<br ALIGN="LEFT"/>save_settings()<br ALIGN="LEFT"/>select_accent_color()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>update_preview()<br ALIGN="LEFT"/>update_ui_from_settings()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.first_run_setup.SetupWorker" [color="black", fontcolor="black", label=<{SetupWorker|finished<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>tasks : List[str]<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.analysis.severity_levels.SeverityLevel" [color="black", fontcolor="black", label=<{SeverityLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.shellcode_generator.ShellcodeGenerator" [color="black", fontcolor="black", label=<{ShellcodeGenerator|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|add_evasion_techniques(shellcode: bytes, techniques: List[EvasionTechnique], architecture: Architecture): bytes<br ALIGN="LEFT"/>generate_bind_shell(architecture: Architecture, port: int): bytes<br ALIGN="LEFT"/>generate_custom_shellcode(payload_type: PayloadType, architecture: Architecture, options: Dict[str, Any]): bytes<br ALIGN="LEFT"/>generate_encoded_shellcode(shellcode: bytes, encoding: EncodingType, key: Optional[bytes]): bytes<br ALIGN="LEFT"/>generate_message_box(architecture: Architecture, title: str, message: str): bytes<br ALIGN="LEFT"/>generate_reverse_shell(architecture: Architecture, lhost: str, lport: int): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.signature_editor_dialog.SignatureEditorDialog" [color="black", fontcolor="black", label=<{SignatureEditorDialog|add_db_btn<br ALIGN="LEFT"/>add_test_file_btn<br ALIGN="LEFT"/>add_test_folder_btn<br ALIGN="LEFT"/>clear_test_files_btn<br ALIGN="LEFT"/>current_signature_path : NoneType, Optional[str]<br ALIGN="LEFT"/>current_signatures : List[Dict], list<br ALIGN="LEFT"/>db_combo<br ALIGN="LEFT"/>format_btn<br ALIGN="LEFT"/>insert_template_btn<br ALIGN="LEFT"/>insert_template_to_editor_btn<br ALIGN="LEFT"/>load_sig_btn<br ALIGN="LEFT"/>new_sig_btn<br ALIGN="LEFT"/>refresh_btn<br ALIGN="LEFT"/>run_test_btn<br ALIGN="LEFT"/>save_sig_btn<br ALIGN="LEFT"/>search_input<br ALIGN="LEFT"/>sig_description_input<br ALIGN="LEFT"/>sig_info_text<br ALIGN="LEFT"/>sig_name_input<br ALIGN="LEFT"/>sig_type_combo<br ALIGN="LEFT"/>sig_version_input<br ALIGN="LEFT"/>signature_databases : Dict[str, str]<br ALIGN="LEFT"/>signature_editor : Optional[QTextEdit]<br ALIGN="LEFT"/>signature_list : Optional[QListWidget]<br ALIGN="LEFT"/>stop_test_btn<br ALIGN="LEFT"/>syntax_highlighter : Optional[SignatureSyntaxHighlighter]<br ALIGN="LEFT"/>template_category_list<br ALIGN="LEFT"/>template_list<br ALIGN="LEFT"/>template_preview<br ALIGN="LEFT"/>test_files_list<br ALIGN="LEFT"/>test_results_model : Optional[QStandardItemModel]<br ALIGN="LEFT"/>test_results_table : Optional[QTableView]<br ALIGN="LEFT"/>test_summary_label<br ALIGN="LEFT"/>test_worker : NoneType, Optional[SignatureTestWorker]<br ALIGN="LEFT"/>validate_btn<br ALIGN="LEFT"/>|add_signature_database()<br ALIGN="LEFT"/>add_test_file()<br ALIGN="LEFT"/>add_test_folder()<br ALIGN="LEFT"/>clear_test_files()<br ALIGN="LEFT"/>filter_signatures(text: str)<br ALIGN="LEFT"/>format_signature()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>insert_template()<br ALIGN="LEFT"/>load_signature_databases()<br ALIGN="LEFT"/>load_signature_file()<br ALIGN="LEFT"/>load_signature_from_list(item: QListWidgetItem)<br ALIGN="LEFT"/>load_signatures_from_database(db_name: str)<br ALIGN="LEFT"/>load_template_category(current_item, previous_item)<br ALIGN="LEFT"/>new_signature()<br ALIGN="LEFT"/>refresh_signatures()<br ALIGN="LEFT"/>run_signature_tests()<br ALIGN="LEFT"/>save_signature()<br ALIGN="LEFT"/>show_template_menu()<br ALIGN="LEFT"/>stop_signature_tests()<br ALIGN="LEFT"/>validate_signature_syntax()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.signature_editor_dialog.SignatureSyntaxHighlighter" [color="black", fontcolor="black", label=<{SignatureSyntaxHighlighter|highlighting_rules : list<br ALIGN="LEFT"/>|highlightBlock(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.signature_editor_dialog.SignatureTestWorker" [color="black", fontcolor="black", label=<{SignatureTestWorker|progress_update<br ALIGN="LEFT"/>signature_content : str<br ALIGN="LEFT"/>test_completed<br ALIGN="LEFT"/>test_files : List[str]<br ALIGN="LEFT"/>unified_engine : NoneType<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.simple_analysis_plugin.SimpleAnalysisPlugin" [color="black", fontcolor="black", label=<{SimpleAnalysisPlugin|results : dict<br ALIGN="LEFT"/>|analyze(binary_path)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.main_app._check_intercepted_traffic.run_network_license_server.SimpleLicenseServer" [color="black", fontcolor="black", label=<{SimpleLicenseServer|client_stats : dict<br ALIGN="LEFT"/>features : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>port : int<br ALIGN="LEFT"/>protocol : str<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>server_socket : NoneType, socket<br ALIGN="LEFT"/>server_thread : NoneType, Thread<br ALIGN="LEFT"/>|start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager.train_model.SimpleNN" [color="black", fontcolor="black", label=<{SimpleNN|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.models.model_manager.ModelManager.train_model.SimpleNN" [color="black", fontcolor="black", label=<{SimpleNN|fc1 : Linear<br ALIGN="LEFT"/>fc2 : Linear<br ALIGN="LEFT"/>relu : ReLU<br ALIGN="LEFT"/>|forward(x)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.SklearnBackend" [color="black", fontcolor="black", label=<{SklearnBackend|<br ALIGN="LEFT"/>|get_model_info(model: Any): Dict[str, Any]<br ALIGN="LEFT"/>load_model(model_path: str): Any<br ALIGN="LEFT"/>predict(model: Any, input_data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.SklearnFallback" [color="black", fontcolor="black", label=<{SklearnFallback|cluster<br ALIGN="LEFT"/>ensemble<br ALIGN="LEFT"/>preprocessing<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.lazy_model_loader.SmartLoadingStrategy" [color="black", fontcolor="black", label=<{SmartLoadingStrategy|logger : NoneType, RootLogger<br ALIGN="LEFT"/>preload_api_models : bool<br ALIGN="LEFT"/>preload_small_models : bool<br ALIGN="LEFT"/>small_model_threshold_mb : int<br ALIGN="LEFT"/>|get_load_priority(config: LLMConfig): int<br ALIGN="LEFT"/>should_preload(config: LLMConfig): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.smart_program_selector_dialog.SmartProgramSelectorDialog" [color="black", fontcolor="black", label=<{SmartProgramSelectorDialog|analyze_button : object<br ALIGN="LEFT"/>cancel_button : object<br ALIGN="LEFT"/>discovery_timer : object<br ALIGN="LEFT"/>discovery_worker : Optional[ProgramDiscoveryWorker]<br ALIGN="LEFT"/>programs_list : object<br ALIGN="LEFT"/>progress_text : object<br ALIGN="LEFT"/>scan_button : object<br ALIGN="LEFT"/>selected_program : Optional[ProgramInfo]<br ALIGN="LEFT"/>|analyze_selected_program()<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>discovery_finished()<br ALIGN="LEFT"/>get_discovery_paths(): List[str]<br ALIGN="LEFT"/>get_selected_program(): Optional[ProgramInfo]<br ALIGN="LEFT"/>handle_programs_found(programs: List[ProgramInfo])<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_program_discovery()<br ALIGN="LEFT"/>update_progress(message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.progress_manager.SpeedColumn" [color="black", fontcolor="black", label=<{SpeedColumn|<br ALIGN="LEFT"/>|render(task)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.splash_screen.SplashScreen" [color="black", fontcolor="black", label=<{SplashScreen|progress_bar<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|set_progress(value: int, message: str)<br ALIGN="LEFT"/>update_progress(value: int, message: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.stack_canary_bypass.StackCanaryBypass" [color="black", fontcolor="black", label=<{StackCanaryBypass|bypass_techniques : list<br ALIGN="LEFT"/>canary_size : int<br ALIGN="LEFT"/>canary_terminator : bytes<br ALIGN="LEFT"/>is_windows<br ALIGN="LEFT"/>is_x64<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|brute_force_canary(target_info: Dict[str, Any], max_attempts: int): Dict[str, Any]<br ALIGN="LEFT"/>get_bypass_recommendations(target_info: Dict[str, Any]): List[Dict[str, Any]]<br ALIGN="LEFT"/>leak_canary_via_format_string(target_info: Dict[str, Any], offset: Optional[int]): Dict[str, Any]<br ALIGN="LEFT"/>test_bypass_techniques(target_info: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.tools.plugin_debugger.StackFrame" [color="black", fontcolor="black", label=<{StackFrame|code : str<br ALIGN="LEFT"/>filename : str<br ALIGN="LEFT"/>function : str<br ALIGN="LEFT"/>globals : Dict[str, Any]<br ALIGN="LEFT"/>lineno : int<br ALIGN="LEFT"/>locals : Dict[str, Any]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.StandardScalerFallback" [color="black", fontcolor="black", label=<{StandardScalerFallback|<br ALIGN="LEFT"/>|fit(X)<br ALIGN="LEFT"/>fit_transform(X)<br ALIGN="LEFT"/>transform(X)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.simconcolic.State" [color="black", fontcolor="black", label=<{State|analyzer : str<br ALIGN="LEFT"/>cpu : CPU<br ALIGN="LEFT"/>id<br ALIGN="LEFT"/>input_symbols : dict<br ALIGN="LEFT"/>terminated : bool<br ALIGN="LEFT"/>termination_reason : str<br ALIGN="LEFT"/>|abandon()<br ALIGN="LEFT"/>is_terminated(): bool<br ALIGN="LEFT"/>set_termination_reason(reason: str)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.StateManager" [color="black", fontcolor="black", label=<{StateManager|checkpoint_interval : int<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>state_file<br ALIGN="LEFT"/>state_history : deque<br ALIGN="LEFT"/>|capture_system_state(): SystemState<br ALIGN="LEFT"/>get_state_analytics(): Dict[str, Any]<br ALIGN="LEFT"/>restore_from_checkpoint(): Optional[SystemState]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.StaticAnalysisAgent" [color="black", fontcolor="black", label=<{StaticAnalysisAgent|capabilities : list<br ALIGN="LEFT"/>|execute_task(task: AgentTask): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.StatisticalResult" [color="black", fontcolor="black", label=<{StatisticalResult|confidence_interval : Tuple[float, float]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>metric_name : str<br ALIGN="LEFT"/>p_value : Optional[float]<br ALIGN="LEFT"/>sample_size : int<br ALIGN="LEFT"/>significance_level : float<br ALIGN="LEFT"/>value : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.StatisticalTester" [color="black", fontcolor="black", label=<{StatisticalTester|<br ALIGN="LEFT"/>|chi_square_test(observed: List[int], expected: List[int]): Dict[str, float]<br ALIGN="LEFT"/>fishers_exact_test(success1: int, total1: int, success2: int, total2: int): Dict[str, float]<br ALIGN="LEFT"/>mann_whitney_u_test(group1: List[float], group2: List[float]): Dict[str, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.string_extraction_widget.StringExtractionThread" [color="black", fontcolor="black", label=<{StringExtractionThread|error_occurred<br ALIGN="LEFT"/>extract_ascii : bool<br ALIGN="LEFT"/>extract_unicode : bool<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>min_length : int<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>status_update<br ALIGN="LEFT"/>strings_found<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.string_extraction_widget.StringExtractionWidget" [color="black", fontcolor="black", label=<{StringExtractionWidget|all_strings : List[Tuple[int, str, str]], list<br ALIGN="LEFT"/>category_filter<br ALIGN="LEFT"/>encoding_filter<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>export_format<br ALIGN="LEFT"/>extract_ascii_cb<br ALIGN="LEFT"/>extract_btn<br ALIGN="LEFT"/>extract_thread<br ALIGN="LEFT"/>extract_unicode_cb<br ALIGN="LEFT"/>file_path : Optional[str]<br ALIGN="LEFT"/>filtered_strings : List[Tuple[int, str, str]], list<br ALIGN="LEFT"/>min_length_filter<br ALIGN="LEFT"/>min_length_spin<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>search_input<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>string_selected<br ALIGN="LEFT"/>string_table<br ALIGN="LEFT"/>strings_exported<br ALIGN="LEFT"/>|apply_filters()<br ALIGN="LEFT"/>display_strings(strings: List[Tuple[int, str, str, str]])<br ALIGN="LEFT"/>export_strings()<br ALIGN="LEFT"/>extract_strings()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>load_file(file_path: str)<br ALIGN="LEFT"/>on_error(error: str)<br ALIGN="LEFT"/>on_progress_update(progress: int)<br ALIGN="LEFT"/>on_status_update(status: str)<br ALIGN="LEFT"/>on_strings_found(strings: List[Tuple[int, str, str]])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.StringInfo" [color="black", fontcolor="black", label=<{StringInfo|encoding : str<br ALIGN="LEFT"/>length : int<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>suspicious : bool<br ALIGN="LEFT"/>value : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.structure_visualizer.StructureVisualizerWidget" [color="black", fontcolor="black", label=<{StructureVisualizerWidget|binary_format<br ALIGN="LEFT"/>content_splitter<br ALIGN="LEFT"/>current_binary : NoneType<br ALIGN="LEFT"/>details_text<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>exports_table<br ALIGN="LEFT"/>header_field_selected<br ALIGN="LEFT"/>headers_table<br ALIGN="LEFT"/>highlight_suspicious_cb<br ALIGN="LEFT"/>imports_table<br ALIGN="LEFT"/>imports_widget<br ALIGN="LEFT"/>memory_map<br ALIGN="LEFT"/>section_selected<br ALIGN="LEFT"/>sections_table<br ALIGN="LEFT"/>show_raw_data_cb<br ALIGN="LEFT"/>structure_data : Dict[str, Any]<br ALIGN="LEFT"/>structure_widget<br ALIGN="LEFT"/>structures : dict<br ALIGN="LEFT"/>tree_view<br ALIGN="LEFT"/>view_combo<br ALIGN="LEFT"/>|export_structure()<br ALIGN="LEFT"/>set_structure_data(data: Dict[str, Any])<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_details()<br ALIGN="LEFT"/>update_view()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.SuccessProbabilityPredictor" [color="black", fontcolor="black", label=<{SuccessProbabilityPredictor|feature_extractor<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>|predict_success_probability(operation_type: str, context: Dict[str, Any]): PredictionResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [color="black", fontcolor="black", label=<{SuccessRateAnalyzer|bayesian_analyzer<br ALIGN="LEFT"/>cache : dict<br ALIGN="LEFT"/>cache_duration : int<br ALIGN="LEFT"/>cache_expiry : dict<br ALIGN="LEFT"/>event_tracker<br ALIGN="LEFT"/>is_running : bool<br ALIGN="LEFT"/>ml_predictor<br ALIGN="LEFT"/>report_generator<br ALIGN="LEFT"/>survival_analyzer<br ALIGN="LEFT"/>time_series_analyzer<br ALIGN="LEFT"/>|compare_success_rates(component1: str, component2: str, protection_category: ProtectionCategory): Dict[str, Any]<br ALIGN="LEFT"/>export_data(format: str, include_raw_events: bool): str<br ALIGN="LEFT"/>generate_comprehensive_report(): str<br ALIGN="LEFT"/>generate_performance_dashboard(): Dict[str, Any]<br ALIGN="LEFT"/>get_bayesian_success_rate(component: str, protection_category: ProtectionCategory): Dict[str, Any]<br ALIGN="LEFT"/>get_category_statistics(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>get_component_statistics(): Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>get_success_rate(component: str, protection_category: ProtectionCategory, time_window: int): StatisticalResult<br ALIGN="LEFT"/>get_trend_analysis(component: str, protection_category: ProtectionCategory): TrendAnalysis<br ALIGN="LEFT"/>log_event(event_type: EventType, outcome: OutcomeType, protection_category: ProtectionCategory, component: str, duration: float, metadata: Dict[str, Any], error_details: str)<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.SummaryPage" [color="black", fontcolor="black", label=<{SummaryPage|summary_text<br ALIGN="LEFT"/>|update_summary(info, template, features, code)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.SurvivalAnalyzer" [color="black", fontcolor="black", label=<{SurvivalAnalyzer|survival_data : list<br ALIGN="LEFT"/>|add_observation(duration: float, censored: bool)<br ALIGN="LEFT"/>kaplan_meier_estimate(): Tuple[List[float], List[float]]<br ALIGN="LEFT"/>median_survival_time(): Optional[float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.symbolic_executor.SymbolicExecutionEngine" [color="black", fontcolor="black", label=<{SymbolicExecutionEngine|binary_path : str<br ALIGN="LEFT"/>completed_paths : list<br ALIGN="LEFT"/>coverage_data : dict<br ALIGN="LEFT"/>crashed_states : list<br ALIGN="LEFT"/>discovered_vulnerabilities : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_paths : int<br ALIGN="LEFT"/>memory_limit : int<br ALIGN="LEFT"/>path_constraints : list<br ALIGN="LEFT"/>states : list<br ALIGN="LEFT"/>timed_out_states : list<br ALIGN="LEFT"/>timeout : int<br ALIGN="LEFT"/>|discover_vulnerabilities(vulnerability_types: Optional[List[str]]): List[Dict[str, Any]]<br ALIGN="LEFT"/>explore_from(start_address: int): Dict[str, Any]<br ALIGN="LEFT"/>generate_exploit(vulnerability: Dict[str, Any]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.SystemMetrics" [color="black", fontcolor="black", label=<{SystemMetrics|cpu_percent : float<br ALIGN="LEFT"/>disk_usage : float<br ALIGN="LEFT"/>load_average : Optional[List[float]]<br ALIGN="LEFT"/>memory_percent : float<br ALIGN="LEFT"/>network_recv : int<br ALIGN="LEFT"/>network_sent : int<br ALIGN="LEFT"/>process_count : int<br ALIGN="LEFT"/>uptime : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMetrics" [color="black", fontcolor="black", label=<{SystemMetrics|cpu_per_core : List[float]<br ALIGN="LEFT"/>cpu_percent : float<br ALIGN="LEFT"/>disk_read_mb : float<br ALIGN="LEFT"/>disk_write_mb : float<br ALIGN="LEFT"/>gpu_memory_percent : Optional[float]<br ALIGN="LEFT"/>gpu_percent : Optional[float]<br ALIGN="LEFT"/>gpu_temp : Optional[float]<br ALIGN="LEFT"/>memory_percent : float<br ALIGN="LEFT"/>memory_total_gb : float<br ALIGN="LEFT"/>memory_used_gb : float<br ALIGN="LEFT"/>network_recv_mb : float<br ALIGN="LEFT"/>network_sent_mb : float<br ALIGN="LEFT"/>timestamp : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWidget" [color="black", fontcolor="black", label=<{SystemMonitorWidget|alert_triggered<br ALIGN="LEFT"/>auto_scroll_cb<br ALIGN="LEFT"/>cpu_bar<br ALIGN="LEFT"/>cpu_curve<br ALIGN="LEFT"/>cpu_label<br ALIGN="LEFT"/>cpu_plot<br ALIGN="LEFT"/>cpu_threshold : float<br ALIGN="LEFT"/>gpu_bar<br ALIGN="LEFT"/>gpu_label<br ALIGN="LEFT"/>gpu_threshold : float<br ALIGN="LEFT"/>history_size : int<br ALIGN="LEFT"/>interval_spin<br ALIGN="LEFT"/>memory_bar<br ALIGN="LEFT"/>memory_curve<br ALIGN="LEFT"/>memory_label<br ALIGN="LEFT"/>memory_plot<br ALIGN="LEFT"/>memory_threshold : float<br ALIGN="LEFT"/>metrics_history : deque<br ALIGN="LEFT"/>monitor_thread<br ALIGN="LEFT"/>monitor_worker<br ALIGN="LEFT"/>pause_btn<br ALIGN="LEFT"/>process_table<br ALIGN="LEFT"/>update_interval : int<br ALIGN="LEFT"/>|closeEvent(event)<br ALIGN="LEFT"/>export_metrics(filepath: str)<br ALIGN="LEFT"/>get_current_metrics(): Optional[SystemMetrics]<br ALIGN="LEFT"/>get_metrics_summary(): Dict[str, Any]<br ALIGN="LEFT"/>set_thresholds(cpu: float, memory: float, gpu: float)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>start_monitoring()<br ALIGN="LEFT"/>stop_monitoring()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWorker" [color="black", fontcolor="black", label=<{SystemMonitorWorker|error_occurred<br ALIGN="LEFT"/>last_disk_io : NoneType, dict, sdiskio<br ALIGN="LEFT"/>last_net_io : NoneType, dict, snetio<br ALIGN="LEFT"/>metrics_updated<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>update_interval : int<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.system_reconnaissance.SystemRecon" [color="black", fontcolor="black", label=<{SystemRecon|is_windows<br ALIGN="LEFT"/>is_x64<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|find_interesting_files(patterns: List[str], search_paths: List[str]): List[Dict[str, Any]]<br ALIGN="LEFT"/>gather_system_info(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.resilience_self_healing.SystemState" [color="black", fontcolor="black", label=<{SystemState|active_components : Set[str]<br ALIGN="LEFT"/>failed_components : Set[str]<br ALIGN="LEFT"/>health_status<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>performance_metrics : Dict[str, float]<br ALIGN="LEFT"/>resource_usage : Dict[str, float]<br ALIGN="LEFT"/>state_id : str<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [color="black", fontcolor="black", label=<{SystemUtilitiesDialog|close_btn : NoneType<br ALIGN="LEFT"/>current_results : dict<br ALIGN="LEFT"/>deps_check_btn : NoneType<br ALIGN="LEFT"/>deps_install_btn : NoneType<br ALIGN="LEFT"/>deps_table : NoneType<br ALIGN="LEFT"/>extract_icon_btn<br ALIGN="LEFT"/>icon_browse_btn<br ALIGN="LEFT"/>icon_file_edit<br ALIGN="LEFT"/>icon_format_combo<br ALIGN="LEFT"/>icon_output_browse_btn<br ALIGN="LEFT"/>icon_output_edit<br ALIGN="LEFT"/>icon_preview<br ALIGN="LEFT"/>icon_size_combo<br ALIGN="LEFT"/>memory_free_label : NoneType<br ALIGN="LEFT"/>memory_percent_label : NoneType<br ALIGN="LEFT"/>memory_results : NoneType<br ALIGN="LEFT"/>memory_total_label : NoneType<br ALIGN="LEFT"/>memory_used_label : NoneType<br ALIGN="LEFT"/>opt_clear_cache : NoneType<br ALIGN="LEFT"/>opt_compress_memory : NoneType<br ALIGN="LEFT"/>opt_defrag_memory : NoneType<br ALIGN="LEFT"/>optimize_memory_btn : NoneType<br ALIGN="LEFT"/>process_filter : NoneType<br ALIGN="LEFT"/>process_kill_btn : NoneType<br ALIGN="LEFT"/>process_refresh_btn : NoneType<br ALIGN="LEFT"/>process_table : NoneType<br ALIGN="LEFT"/>progress_bar : NoneType<br ALIGN="LEFT"/>status_label : NoneType<br ALIGN="LEFT"/>sysinfo_display : NoneType<br ALIGN="LEFT"/>sysinfo_export_btn : NoneType<br ALIGN="LEFT"/>sysinfo_refresh_btn : NoneType<br ALIGN="LEFT"/>tabs<br ALIGN="LEFT"/>worker : NoneType<br ALIGN="LEFT"/>|browse_icon_file()<br ALIGN="LEFT"/>browse_icon_output()<br ALIGN="LEFT"/>check_dependencies()<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>connect_signals()<br ALIGN="LEFT"/>export_system_info()<br ALIGN="LEFT"/>extract_icon()<br ALIGN="LEFT"/>filter_processes(filter_text)<br ALIGN="LEFT"/>format_system_info(info)<br ALIGN="LEFT"/>get_process_list()<br ALIGN="LEFT"/>get_system_info()<br ALIGN="LEFT"/>install_dependencies()<br ALIGN="LEFT"/>kill_selected_process()<br ALIGN="LEFT"/>on_dependencies_checked(result)<br ALIGN="LEFT"/>on_error(error_msg)<br ALIGN="LEFT"/>on_icon_extracted(result)<br ALIGN="LEFT"/>on_memory_optimized(result)<br ALIGN="LEFT"/>on_process_list_received(result)<br ALIGN="LEFT"/>on_process_selection_changed()<br ALIGN="LEFT"/>on_progress_updated(value, message)<br ALIGN="LEFT"/>on_system_info_received(result)<br ALIGN="LEFT"/>optimize_memory()<br ALIGN="LEFT"/>setup_dependencies_tab()<br ALIGN="LEFT"/>setup_footer(layout)<br ALIGN="LEFT"/>setup_icon_tab()<br ALIGN="LEFT"/>setup_memory_tab()<br ALIGN="LEFT"/>setup_process_tab()<br ALIGN="LEFT"/>setup_sysinfo_tab()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" [color="black", fontcolor="black", label=<{SystemUtilitiesWorker|error_occurred<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>operation : str<br ALIGN="LEFT"/>operation_completed<br ALIGN="LEFT"/>progress_updated<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.payload_engine.PayloadEngine._inject_via_generic_method.inject_via_thread_hijacking.THREADENTRY32" [color="black", fontcolor="black", label=<{THREADENTRY32|dwSize<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.adobe_injector.THREADENTRY32" [color="black", fontcolor="black", label=<{THREADENTRY32|dwSize<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.patching.syscalls.THREAD_BASIC_INFORMATION_32" [color="black", fontcolor="black", label=<{THREAD_BASIC_INFORMATION_32|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation._check_token_privilege.TOKEN_PRIVILEGES" [color="black", fontcolor="black", label=<{TOKEN_PRIVILEGES|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.tpm_bypass.TPMAnalyzer" [color="black", fontcolor="black", label=<{TPMAnalyzer|binary_path : Optional[str]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>tpm_indicators : list<br ALIGN="LEFT"/>|analyze(): Dict[str, Any]<br ALIGN="LEFT"/>generate_bypass(tpm_version: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.tpm_bypass.TPMProtectionBypass" [color="black", fontcolor="black", label=<{TPMProtectionBypass|app : Optional[Any]<br ALIGN="LEFT"/>hooks : List[Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>patches : List[Dict[str, Any]]<br ALIGN="LEFT"/>virtual_tpm : NoneType, Optional[Dict[str, Union[bytes, int]]], dict<br ALIGN="LEFT"/>|bypass_tpm_checks(): Dict[str, Any]<br ALIGN="LEFT"/>clear_hooks(): None<br ALIGN="LEFT"/>generate_bypass_script(): str<br ALIGN="LEFT"/>get_hook_status(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.taint_analyzer.TaintAnalysisEngine" [color="black", fontcolor="black", label=<{TaintAnalysisEngine|binary_path : Optional[str]<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>results : Dict[str, Any], dict<br ALIGN="LEFT"/>taint_propagation : List[List[Dict[str, Any]]], list<br ALIGN="LEFT"/>taint_sinks : List[Dict[str, Any]]<br ALIGN="LEFT"/>taint_sources : List[Dict[str, Any]]<br ALIGN="LEFT"/>|add_taint_sink(sink_type: str, sink_location: str, sink_description: Optional[str]): None<br ALIGN="LEFT"/>add_taint_source(source_type: str, source_location: str, source_description: Optional[str]): None<br ALIGN="LEFT"/>analyze_with_sources(sources: List[str]): Dict[str, Any]<br ALIGN="LEFT"/>clear_analysis(): None<br ALIGN="LEFT"/>generate_report(filename: Optional[str]): Optional[str]<br ALIGN="LEFT"/>get_results(): Dict[str, Any]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>run_analysis(): bool<br ALIGN="LEFT"/>set_binary(binary_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.symbolic_executor.TaintTracker" [color="black", fontcolor="black", label=<{TaintTracker|taint_propagation : dict<br ALIGN="LEFT"/>tainted_data : dict<br ALIGN="LEFT"/>|add_taint(data, source)<br ALIGN="LEFT"/>get_taint_source(data)<br ALIGN="LEFT"/>is_tainted(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.TargetAnalyzer" [color="black", fontcolor="black", label=<{TargetAnalyzer|detected_techniques : set<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze_imports(file_path: str): List[AntiDebugTechnique]<br ALIGN="LEFT"/>analyze_pe_headers(file_path: str): List[AntiDebugTechnique]<br ALIGN="LEFT"/>analyze_runtime_behavior(): List[AntiDebugTechnique]<br ALIGN="LEFT"/>analyze_target(file_path: Optional[str]): Dict[str, Any]<br ALIGN="LEFT"/>detect_vm_environment(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.TaskDistributor" [color="black", fontcolor="black", label=<{TaskDistributor|load_balancer<br ALIGN="LEFT"/>system<br ALIGN="LEFT"/>task_queue : PriorityQueue<br ALIGN="LEFT"/>|distribute_task(task: AgentTask): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.task_manager.TaskManager" [color="black", fontcolor="black", label=<{TaskManager|active_task_count_changed<br ALIGN="LEFT"/>all_tasks_completed<br ALIGN="LEFT"/>task_submitted<br ALIGN="LEFT"/>thread_pool<br ALIGN="LEFT"/>|cancel_all_tasks()<br ALIGN="LEFT"/>cancel_task(task_id: str): bool<br ALIGN="LEFT"/>get_active_tasks(): Dict[str, str]<br ALIGN="LEFT"/>get_task_history(): List[Dict]<br ALIGN="LEFT"/>get_task_result(task_id: str): Optional[Any]<br ALIGN="LEFT"/>get_thread_count(): int<br ALIGN="LEFT"/>set_thread_count(count: int)<br ALIGN="LEFT"/>submit_callable(func: Callable, args: tuple, kwargs: dict, task_id: Optional[str], description: str): str<br ALIGN="LEFT"/>submit_task(task: BaseTask): str<br ALIGN="LEFT"/>wait_for_all(timeout_ms: int): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.task_manager.TaskMeta" [color="black", fontcolor="black", label=<{TaskMeta|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.multi_agent_system.TaskPriority" [color="black", fontcolor="black", label=<{TaskPriority|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.autonomous_agent.TaskRequest" [color="black", fontcolor="black", label=<{TaskRequest|additional_params : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>autonomous_mode : bool<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>max_iterations : int<br ALIGN="LEFT"/>script_types : List[ScriptType]<br ALIGN="LEFT"/>test_environment<br ALIGN="LEFT"/>user_confirmation_required : bool<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.task_manager.TaskSignals" [color="black", fontcolor="black", label=<{TaskSignals|error<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>result<br ALIGN="LEFT"/>started<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.task_manager.TaskStatus" [color="black", fontcolor="black", label=<{TaskStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.c2.communication_protocols.TcpProtocol" [color="black", fontcolor="black", label=<{TcpProtocol|connected : bool<br ALIGN="LEFT"/>connection_count<br ALIGN="LEFT"/>is_server : bool<br ALIGN="LEFT"/>reader : NoneType<br ALIGN="LEFT"/>server<br ALIGN="LEFT"/>server_socket : NoneType<br ALIGN="LEFT"/>socket : NoneType<br ALIGN="LEFT"/>writer : NoneType<br ALIGN="LEFT"/>|connect(): bool<br ALIGN="LEFT"/>disconnect()<br ALIGN="LEFT"/>send_message(message: Dict[str, Any]): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>start()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.logging.audit_logger.TelemetryCollector" [color="black", fontcolor="black", label=<{TelemetryCollector|audit_logger : NoneType<br ALIGN="LEFT"/>export_interval : int<br ALIGN="LEFT"/>performance_monitor<br ALIGN="LEFT"/>telemetry_data : list<br ALIGN="LEFT"/>|export_telemetry_json(filepath: str)<br ALIGN="LEFT"/>get_telemetry_history(limit: int): List[Dict[str, Any]]<br ALIGN="LEFT"/>set_audit_logger(audit_logger: AuditLogger)<br ALIGN="LEFT"/>start_collection()<br ALIGN="LEFT"/>stop_collection()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.TemplateSelectionPage" [color="black", fontcolor="black", label=<{TemplateSelectionPage|description_label<br ALIGN="LEFT"/>plugin_type<br ALIGN="LEFT"/>template_list<br ALIGN="LEFT"/>|get_selected_template()<br ALIGN="LEFT"/>get_templates_for_type(plugin_type)<br ALIGN="LEFT"/>on_template_selected(current, previous)<br ALIGN="LEFT"/>populate_templates()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_manager_module.TensorFlowBackend" [color="black", fontcolor="black", label=<{TensorFlowBackend|<br ALIGN="LEFT"/>|get_model_info(model: Any): Dict[str, Any]<br ALIGN="LEFT"/>load_model(model_path: str): Any<br ALIGN="LEFT"/>predict(model: Any, input_data: Any): Any<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.llm_backends.TensorFlowLLMBackend" [color="black", fontcolor="black", label=<{TensorFlowLLMBackend|is_initialized : bool<br ALIGN="LEFT"/>model : NoneType<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>|chat(messages: List[LLMMessage], tools: Optional[List[Dict]]): LLMResponse<br ALIGN="LEFT"/>initialize(): bool<br ALIGN="LEFT"/>shutdown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" [color="black", fontcolor="black", label=<{TerminalDashboard|activity_log : list<br ALIGN="LEFT"/>analysis_stats<br ALIGN="LEFT"/>callbacks : dict<br ALIGN="LEFT"/>components : dict<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>cpu_history : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>max_activity_entries : int<br ALIGN="LEFT"/>max_history : int<br ALIGN="LEFT"/>memory_history : list<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>session_info<br ALIGN="LEFT"/>system_metrics<br ALIGN="LEFT"/>update_interval : float<br ALIGN="LEFT"/>update_thread : NoneType<br ALIGN="LEFT"/>|create_status_summary(): str<br ALIGN="LEFT"/>create_system_overview_table(): None<br ALIGN="LEFT"/>display_activity_with_status(activity_title: str, activities: List[str]): None<br ALIGN="LEFT"/>display_metrics_columns(): None<br ALIGN="LEFT"/>display_project_tree_view(project_data: Dict[str, Any]): None<br ALIGN="LEFT"/>increment_counter(counter: str)<br ALIGN="LEFT"/>log_activity(message: str, level: str)<br ALIGN="LEFT"/>register_callback(event: str, callback: Callable)<br ALIGN="LEFT"/>show_analysis_progress(operation_name: str, total_steps: int, current_step: int): None<br ALIGN="LEFT"/>show_dashboard(duration: Optional[float])<br ALIGN="LEFT"/>update_analysis_stats()<br ALIGN="LEFT"/>update_session_info()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.hex_viewer_cli.TerminalHexViewer" [color="black", fontcolor="black", label=<{TerminalHexViewer|bytes_per_line : int<br ALIGN="LEFT"/>colors : dict<br ALIGN="LEFT"/>current_offset : int<br ALIGN="LEFT"/>current_search_index : int<br ALIGN="LEFT"/>cursor_offset : int<br ALIGN="LEFT"/>data : NoneType, mmap<br ALIGN="LEFT"/>edit_mode : bool<br ALIGN="LEFT"/>file_handle : NoneType<br ALIGN="LEFT"/>file_size : int<br ALIGN="LEFT"/>filepath : str<br ALIGN="LEFT"/>help_visible : bool<br ALIGN="LEFT"/>hex_area_height : int<br ALIGN="LEFT"/>hex_edit_mode : bool<br ALIGN="LEFT"/>mmap_file : NoneType, mmap<br ALIGN="LEFT"/>modifications : dict<br ALIGN="LEFT"/>modified : bool<br ALIGN="LEFT"/>screen_height : int<br ALIGN="LEFT"/>screen_width : int<br ALIGN="LEFT"/>search_pattern : str<br ALIGN="LEFT"/>search_results : list<br ALIGN="LEFT"/>status_line : int<br ALIGN="LEFT"/>stdscr<br ALIGN="LEFT"/>|run(stdscr)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestAntiAntiDebugSuite" [color="black", fontcolor="black", label=<{TestAntiAntiDebugSuite|anti_debug<br ALIGN="LEFT"/>fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_anti_debug_initialization()<br ALIGN="LEFT"/>test_api_hook_installation()<br ALIGN="LEFT"/>test_debug_detection_bypass()<br ALIGN="LEFT"/>test_memory_protection_bypass()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_batch_tester.TestCase" [color="black", fontcolor="black", label=<{TestCase|expected_output : Optional[str]<br ALIGN="LEFT"/>expected_patterns : Optional[List[str]]<br ALIGN="LEFT"/>max_tokens : int<br ALIGN="LEFT"/>metadata : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>prompt : str<br ALIGN="LEFT"/>system_prompt : Optional[str]<br ALIGN="LEFT"/>temperature : float<br ALIGN="LEFT"/>test_id : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestCategory" [color="black", fontcolor="black", label=<{TestCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.tools.plugin_test_generator.TestCoverageAnalyzer" [color="black", fontcolor="black", label=<{TestCoverageAnalyzer|coverage_data : dict<br ALIGN="LEFT"/>|analyze_coverage(plugin_file, test_file)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestDataGenerator" [color="black", fontcolor="black", label=<{TestDataGenerator|db_connection<br ALIGN="LEFT"/>random : Random<br ALIGN="LEFT"/>temp_dir<br ALIGN="LEFT"/>|calculate_performance_metrics(test_results: List[TestResult]): Dict[str, float]<br ALIGN="LEFT"/>cleanup()<br ALIGN="LEFT"/>create_test_binary(path: Path, binary_type: str): Path<br ALIGN="LEFT"/>generate_analysis_data(num_samples: int): pd.DataFrame<br ALIGN="LEFT"/>generate_api_sequence(length: int): List[str]<br ALIGN="LEFT"/>generate_binary_data(size: int): bytes<br ALIGN="LEFT"/>generate_crypto_data(): Dict[str, Any]<br ALIGN="LEFT"/>generate_license_key(format_type: str): str<br ALIGN="LEFT"/>generate_pe_header(): bytes<br ALIGN="LEFT"/>setup_test_database(): sqlite3.Connection<br ALIGN="LEFT"/>store_test_binary(filename: str, data: bytes): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.autonomous_agent.TestEnvironment" [color="black", fontcolor="black", label=<{TestEnvironment|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" [color="black", fontcolor="black", label=<{TestFixtures|data_generator<br ALIGN="LEFT"/>sample_files<br ALIGN="LEFT"/>temp_dir : NoneType, Path<br ALIGN="LEFT"/>test_dll<br ALIGN="LEFT"/>test_pe<br ALIGN="LEFT"/>|analysis_data(): pd.DataFrame<br ALIGN="LEFT"/>analyze_test_data_with_union(data: Union[List[TestResult], Dict[str, Any], str]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_with_mocking(binary_path: Path): Dict[str, Any]<br ALIGN="LEFT"/>create_performance_charts(test_results: List[TestResult])<br ALIGN="LEFT"/>create_test_files()<br ALIGN="LEFT"/>fetch_remote_signatures(signature_url: str): Dict[str, Any]<br ALIGN="LEFT"/>get_performance_metrics_tuple(test_results: List[TestResult]): Tuple[float, float, int]<br ALIGN="LEFT"/>mock_analysis_environment()<br ALIGN="LEFT"/>run_async_analysis(targets: List[str]): List[Dict[str, Any]]<br ALIGN="LEFT"/>run_external_analysis(binary_path: Path): Dict[str, Any]<br ALIGN="LEFT"/>run_parallel_analysis(binary_paths: List[Path]): List[Dict[str, Any]]<br ALIGN="LEFT"/>run_threaded_tests(test_functions: List[Callable]): List[Dict[str, Any]]<br ALIGN="LEFT"/>sample_binary(): Path<br ALIGN="LEFT"/>schedule_analysis_with_timedelta(delay_minutes: int): Dict[str, Any]<br ALIGN="LEFT"/>setup()<br ALIGN="LEFT"/>teardown()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.test_generator_dialog.TestGenerationThread" [color="black", fontcolor="black", label=<{TestGenerationThread|error<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>options : Dict[str, Any]<br ALIGN="LEFT"/>plugin_path : str<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>runner<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.test_generator_dialog.TestGeneratorDialog" [color="black", fontcolor="black", label=<{TestGeneratorDialog|coverage_summary<br ALIGN="LEFT"/>coverage_text<br ALIGN="LEFT"/>coverage_widget<br ALIGN="LEFT"/>generate_btn<br ALIGN="LEFT"/>generate_coverage_cb<br ALIGN="LEFT"/>generation_thread : NoneType<br ALIGN="LEFT"/>generator<br ALIGN="LEFT"/>include_edge_cases_cb<br ALIGN="LEFT"/>include_fixtures_cb<br ALIGN="LEFT"/>include_invalid_input_cb<br ALIGN="LEFT"/>include_mocks_cb<br ALIGN="LEFT"/>mock_generator<br ALIGN="LEFT"/>mock_viewer<br ALIGN="LEFT"/>mock_widget<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>results_widget<br ALIGN="LEFT"/>run_after_generation_cb<br ALIGN="LEFT"/>run_btn<br ALIGN="LEFT"/>save_btn<br ALIGN="LEFT"/>stop_on_failure_cb<br ALIGN="LEFT"/>summary_label<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>template_list<br ALIGN="LEFT"/>test_code_edit<br ALIGN="LEFT"/>test_output<br ALIGN="LEFT"/>timeout_spin<br ALIGN="LEFT"/>uncovered_list<br ALIGN="LEFT"/>|create_coverage_widget(): QWidget<br ALIGN="LEFT"/>create_mock_widget(): QWidget<br ALIGN="LEFT"/>create_options_panel(): QWidget<br ALIGN="LEFT"/>create_results_widget(): QWidget<br ALIGN="LEFT"/>generate_mock_binary()<br ALIGN="LEFT"/>generate_mock_network()<br ALIGN="LEFT"/>generate_mock_registry()<br ALIGN="LEFT"/>generate_tests()<br ALIGN="LEFT"/>init_dialog()<br ALIGN="LEFT"/>load_plugin(path: str)<br ALIGN="LEFT"/>on_error(error: str)<br ALIGN="LEFT"/>on_progress(message: str)<br ALIGN="LEFT"/>on_tests_finished(results: Dict[str, Any])<br ALIGN="LEFT"/>run_tests()<br ALIGN="LEFT"/>save_mock_data()<br ALIGN="LEFT"/>save_tests()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_coverage_display(coverage: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestHardwareDongleEmulator" [color="black", fontcolor="black", label=<{TestHardwareDongleEmulator|emulator<br ALIGN="LEFT"/>fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_dongle_creation()<br ALIGN="LEFT"/>test_dongle_memory_operations()<br ALIGN="LEFT"/>test_emulator_initialization()<br ALIGN="LEFT"/>test_encryption_operations()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestModuleIntegration" [color="black", fontcolor="black", label=<{TestModuleIntegration|fixtures<br ALIGN="LEFT"/>modules : dict<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_classifier_detector_integration()<br ALIGN="LEFT"/>test_core_engine_integration()<br ALIGN="LEFT"/>test_unwrapper_anti_debug_integration()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestNeuralNetworkDetector" [color="black", fontcolor="black", label=<{TestNeuralNetworkDetector|detector<br ALIGN="LEFT"/>fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_detector_initialization()<br ALIGN="LEFT"/>test_feature_extraction()<br ALIGN="LEFT"/>test_model_prediction()<br ALIGN="LEFT"/>test_training_data_preparation()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestPerformanceBenchmarks" [color="black", fontcolor="black", label=<{TestPerformanceBenchmarks|fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_batch_processing_performance()<br ALIGN="LEFT"/>test_classification_performance()<br ALIGN="LEFT"/>test_concurrent_processing()<br ALIGN="LEFT"/>test_memory_leak_detection()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestPriority" [color="black", fontcolor="black", label=<{TestPriority|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestProtectionClassifier" [color="black", fontcolor="black", label=<{TestProtectionClassifier|classifier<br ALIGN="LEFT"/>fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_classification_accuracy()<br ALIGN="LEFT"/>test_classifier_initialization()<br ALIGN="LEFT"/>test_file_classification()<br ALIGN="LEFT"/>test_invalid_file_handling()<br ALIGN="LEFT"/>test_signature_loading()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.model_batch_tester.TestResult" [color="black", fontcolor="black", label=<{TestResult|error : Optional[str]<br ALIGN="LEFT"/>inference_time : float<br ALIGN="LEFT"/>model_id : str<br ALIGN="LEFT"/>output : str<br ALIGN="LEFT"/>passed_validation : Optional[bool]<br ALIGN="LEFT"/>performance_metrics : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>test_id : str<br ALIGN="LEFT"/>tokens_generated : int<br ALIGN="LEFT"/>validation_details : Optional[Dict[str, Any]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestResult" [color="black", fontcolor="black", label=<{TestResult|assertion_count : int<br ALIGN="LEFT"/>category<br ALIGN="LEFT"/>cpu_usage : float<br ALIGN="LEFT"/>error_message : Optional[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>memory_usage : float<br ALIGN="LEFT"/>priority<br ALIGN="LEFT"/>status<br ALIGN="LEFT"/>tags : List[str]<br ALIGN="LEFT"/>test_name : str<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.TestResults" [color="black", fontcolor="black", label=<{TestResults|api_calls : List[Dict[str, Any]]<br ALIGN="LEFT"/>duration : float<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>exit_code : int<br ALIGN="LEFT"/>file_operations : List[Dict[str, Any]]<br ALIGN="LEFT"/>memory_changes : List[Dict[str, Any]]<br ALIGN="LEFT"/>network_activity : List[Dict[str, Any]]<br ALIGN="LEFT"/>output : str<br ALIGN="LEFT"/>process_state : str<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>warnings : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestRunner" [color="black", fontcolor="black", label=<{TestRunner|coverage : Coverage<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>output_dir : Path<br ALIGN="LEFT"/>test_results : list<br ALIGN="LEFT"/>|run_all_tests(): TestSuiteResults<br ALIGN="LEFT"/>run_category_tests(category: TestCategory): TestSuiteResults<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestSecurityValidation" [color="black", fontcolor="black", label=<{TestSecurityValidation|fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_buffer_overflow_protection()<br ALIGN="LEFT"/>test_code_injection_protection()<br ALIGN="LEFT"/>test_input_validation()<br ALIGN="LEFT"/>test_path_traversal_protection()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestStatus" [color="black", fontcolor="black", label=<{TestStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestSuiteResults" [color="black", fontcolor="black", label=<{TestSuiteResults|coverage_percentage : float<br ALIGN="LEFT"/>error_tests : int<br ALIGN="LEFT"/>failed_tests : int<br ALIGN="LEFT"/>passed_tests : int<br ALIGN="LEFT"/>skipped_tests : int<br ALIGN="LEFT"/>success_rate<br ALIGN="LEFT"/>test_results : List[TestResult]<br ALIGN="LEFT"/>timestamp : datetime<br ALIGN="LEFT"/>total_execution_time : float<br ALIGN="LEFT"/>total_tests : int<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestVMProtectionUnwrapper" [color="black", fontcolor="black", label=<{TestVMProtectionUnwrapper|fixtures<br ALIGN="LEFT"/>monitor<br ALIGN="LEFT"/>unwrapper<br ALIGN="LEFT"/>|setUp()<br ALIGN="LEFT"/>tearDown()<br ALIGN="LEFT"/>test_unwrapper_initialization()<br ALIGN="LEFT"/>test_vm_context_emulation()<br ALIGN="LEFT"/>test_vm_detection()<br ALIGN="LEFT"/>test_vm_instruction_parsing()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.TextEditorDialog" [color="black", fontcolor="black", label=<{TextEditorDialog|close_btn<br ALIGN="LEFT"/>content_changed<br ALIGN="LEFT"/>copy_action<br ALIGN="LEFT"/>current_file : NoneType<br ALIGN="LEFT"/>cut_action<br ALIGN="LEFT"/>export_action<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>file_path : NoneType<br ALIGN="LEFT"/>file_saved<br ALIGN="LEFT"/>file_status_label<br ALIGN="LEFT"/>file_watcher<br ALIGN="LEFT"/>find_action<br ALIGN="LEFT"/>find_next_action<br ALIGN="LEFT"/>find_prev_action<br ALIGN="LEFT"/>find_replace_dialog : NoneType<br ALIGN="LEFT"/>font_size_spin<br ALIGN="LEFT"/>highlighter<br ALIGN="LEFT"/>is_modified : bool<br ALIGN="LEFT"/>line_col_label<br ALIGN="LEFT"/>new_action<br ALIGN="LEFT"/>open_action<br ALIGN="LEFT"/>original_content : str<br ALIGN="LEFT"/>paste_action<br ALIGN="LEFT"/>redo_action<br ALIGN="LEFT"/>reload_btn<br ALIGN="LEFT"/>save_action<br ALIGN="LEFT"/>save_as_action<br ALIGN="LEFT"/>save_as_btn<br ALIGN="LEFT"/>save_btn<br ALIGN="LEFT"/>select_all_action<br ALIGN="LEFT"/>status_bar<br ALIGN="LEFT"/>syntax_mode : str<br ALIGN="LEFT"/>text_edit<br ALIGN="LEFT"/>toolbar<br ALIGN="LEFT"/>undo_action<br ALIGN="LEFT"/>|change_font_size(size: int)<br ALIGN="LEFT"/>check_save_changes(): bool<br ALIGN="LEFT"/>closeEvent(event)<br ALIGN="LEFT"/>close_with_confirmation()<br ALIGN="LEFT"/>export_file()<br ALIGN="LEFT"/>find_text(text: str, forward: bool)<br ALIGN="LEFT"/>load_file(file_path: str)<br ALIGN="LEFT"/>new_file()<br ALIGN="LEFT"/>on_content_changed()<br ALIGN="LEFT"/>on_file_changed_externally(file_path: str)<br ALIGN="LEFT"/>open_file()<br ALIGN="LEFT"/>reload_file()<br ALIGN="LEFT"/>replace_all_text(find_text: str, replace_text: str): int<br ALIGN="LEFT"/>replace_text(find_text: str, replace_text: str)<br ALIGN="LEFT"/>save_file()<br ALIGN="LEFT"/>save_file_as()<br ALIGN="LEFT"/>setup_actions()<br ALIGN="LEFT"/>setup_connections()<br ALIGN="LEFT"/>setup_status_bar()<br ALIGN="LEFT"/>setup_toolbar()<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>show_find_replace()<br ALIGN="LEFT"/>update_cursor_position()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.theme_manager.ThemeManager" [color="black", fontcolor="black", label=<{ThemeManager|current_theme : str<br ALIGN="LEFT"/>settings<br ALIGN="LEFT"/>styles_dir<br ALIGN="LEFT"/>themes : dict<br ALIGN="LEFT"/>|get_current_theme()<br ALIGN="LEFT"/>load_theme_preference()<br ALIGN="LEFT"/>save_theme_preference()<br ALIGN="LEFT"/>set_theme(theme_name)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.ThemidaHandler" [color="black", fontcolor="black", label=<{ThemidaHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|decrypt_themida_vm(vm_data: bytes, key: bytes): bytes<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.ThreadPoolOptimizer" [color="black", fontcolor="black", label=<{ThreadPoolOptimizer|executor : ThreadPoolExecutor<br ALIGN="LEFT"/>initial_workers<br ALIGN="LEFT"/>last_optimization<br ALIGN="LEFT"/>lock : lock<br ALIGN="LEFT"/>max_workers<br ALIGN="LEFT"/>min_workers<br ALIGN="LEFT"/>optimization_interval : int<br ALIGN="LEFT"/>queue_depths : deque<br ALIGN="LEFT"/>response_times : deque<br ALIGN="LEFT"/>|get_stats(): Dict[str, Any]<br ALIGN="LEFT"/>submit(fn: Callable)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.severity_levels.ThreatLevel" [color="black", fontcolor="black", label=<{ThreatLevel|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.TimeSeriesAnalyzer" [color="black", fontcolor="black", label=<{TimeSeriesAnalyzer|history : defaultdict<br ALIGN="LEFT"/>|add_data_point(component: str, timestamp: float, value: float)<br ALIGN="LEFT"/>detect_trend(component: str, window_size: int): Dict[str, Any]<br ALIGN="LEFT"/>forecast_arima(component: str, periods: int): Tuple[List[float], List[Tuple[float, float]]]<br ALIGN="LEFT"/>seasonal_decomposition(component: str, period: int): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.TimeSeriesData" [color="black", fontcolor="black", label=<{TimeSeriesData|metadata : List[Dict[str, Any]]<br ALIGN="LEFT"/>timestamps : List[datetime]<br ALIGN="LEFT"/>values : List[float]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.timing_attacks.TimingAttackDefense" [color="black", fontcolor="black", label=<{TimingAttackDefense|logger : NoneType, RootLogger<br ALIGN="LEFT"/>timing_checks : dict<br ALIGN="LEFT"/>timing_threads : list<br ALIGN="LEFT"/>|anti_acceleration_loop(duration: float): None<br ALIGN="LEFT"/>execution_delay(check_environment: bool): None<br ALIGN="LEFT"/>generate_timing_defense_code(): str<br ALIGN="LEFT"/>rdtsc_timing_check(): bool<br ALIGN="LEFT"/>secure_sleep(duration: float, callback: Callable): bool<br ALIGN="LEFT"/>stalling_code(min_duration: float, max_duration: float): None<br ALIGN="LEFT"/>time_bomb(trigger_time: float, action: Callable): threading.Thread<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.TimingNormalizer" [color="black", fontcolor="black", label=<{TimingNormalizer|baseline_times : dict<br ALIGN="LEFT"/>kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>timing_hooks : dict<br ALIGN="LEFT"/>|add_random_delays()<br ALIGN="LEFT"/>apply_timing_normalizations(): List[str]<br ALIGN="LEFT"/>measure_baseline_timing()<br ALIGN="LEFT"/>normalize_get_tick_count(): bool<br ALIGN="LEFT"/>normalize_rdtsc(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.Tool" [color="black", fontcolor="black", label=<{Tool|category<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>example : Optional[str]<br ALIGN="LEFT"/>function : Callable<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>parameters : Dict[str, Any]<br ALIGN="LEFT"/>risk_level : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.ToolCategory" [color="black", fontcolor="black", label=<{ToolCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.config.external_tools_config.ToolCategory" [color="black", fontcolor="black", label=<{ToolCategory|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.config.external_tools_config.ToolStatus" [color="black", fontcolor="black", label=<{ToolStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.tool_discovery.ToolValidator" [color="black", fontcolor="black", label=<{ToolValidator|<br ALIGN="LEFT"/>|validate_frida(tool_path: str): Dict[str, Any]<br ALIGN="LEFT"/>validate_ghidra(tool_path: str): Dict[str, Any]<br ALIGN="LEFT"/>validate_python(tool_path: str): Dict[str, Any]<br ALIGN="LEFT"/>validate_qemu(tool_path: str): Dict[str, Any]<br ALIGN="LEFT"/>validate_radare2(tool_path: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.tools_tab.ToolsTab" [color="black", fontcolor="black", label=<{ToolsTab|analysis_binary_edit<br ALIGN="LEFT"/>available_tools : dict<br ALIGN="LEFT"/>capture_filter_edit<br ALIGN="LEFT"/>crypto_input<br ALIGN="LEFT"/>file_path_edit<br ALIGN="LEFT"/>interface_combo<br ALIGN="LEFT"/>is_loaded : bool<br ALIGN="LEFT"/>loaded_plugins : dict<br ALIGN="LEFT"/>network_capture_started<br ALIGN="LEFT"/>network_interfaces : list<br ALIGN="LEFT"/>output_console<br ALIGN="LEFT"/>packets_table<br ALIGN="LEFT"/>plugin_info_text<br ALIGN="LEFT"/>plugin_list<br ALIGN="LEFT"/>plugin_loaded<br ALIGN="LEFT"/>plugin_output<br ALIGN="LEFT"/>reg_key_edit<br ALIGN="LEFT"/>results_tabs<br ALIGN="LEFT"/>scan_target_edit<br ALIGN="LEFT"/>tool_executed<br ALIGN="LEFT"/>tool_output<br ALIGN="LEFT"/>tools_tabs<br ALIGN="LEFT"/>|analyze_entropy()<br ALIGN="LEFT"/>analyze_exports()<br ALIGN="LEFT"/>analyze_imports()<br ALIGN="LEFT"/>analyze_sections()<br ALIGN="LEFT"/>analyze_symbols()<br ALIGN="LEFT"/>base64_decode()<br ALIGN="LEFT"/>base64_encode()<br ALIGN="LEFT"/>browse_analysis_binary()<br ALIGN="LEFT"/>browse_file()<br ALIGN="LEFT"/>calculate_hash(algorithm)<br ALIGN="LEFT"/>create_analysis_tools_tab()<br ALIGN="LEFT"/>create_hex_dump()<br ALIGN="LEFT"/>create_network_tools_tab()<br ALIGN="LEFT"/>create_new_plugin()<br ALIGN="LEFT"/>create_plugin_manager_tab()<br ALIGN="LEFT"/>create_results_panel()<br ALIGN="LEFT"/>create_system_tools_tab()<br ALIGN="LEFT"/>create_tools_panel()<br ALIGN="LEFT"/>disassemble_binary()<br ALIGN="LEFT"/>edit_selected_plugin()<br ALIGN="LEFT"/>extract_strings()<br ALIGN="LEFT"/>get_file_info()<br ALIGN="LEFT"/>get_memory_info()<br ALIGN="LEFT"/>get_system_info()<br ALIGN="LEFT"/>list_processes()<br ALIGN="LEFT"/>load_selected_plugin()<br ALIGN="LEFT"/>log_message(message, level)<br ALIGN="LEFT"/>ping_scan()<br ALIGN="LEFT"/>populate_network_interfaces()<br ALIGN="LEFT"/>populate_plugin_list()<br ALIGN="LEFT"/>port_scan()<br ALIGN="LEFT"/>query_registry()<br ALIGN="LEFT"/>reload_selected_plugin()<br ALIGN="LEFT"/>save_packet_capture()<br ALIGN="LEFT"/>service_scan()<br ALIGN="LEFT"/>setup_content()<br ALIGN="LEFT"/>start_packet_capture()<br ALIGN="LEFT"/>stop_packet_capture()<br ALIGN="LEFT"/>unload_selected_plugin()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.traffic_interception_engine.TrafficInterceptionEngine" [color="black", fontcolor="black", label=<{TrafficInterceptionEngine|active_connections : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>analysis_callbacks : List[Callable[[AnalyzedTraffic], None]]<br ALIGN="LEFT"/>analysis_thread : Optional[threading.Thread]<br ALIGN="LEFT"/>bind_interface : str<br ALIGN="LEFT"/>capture_backend : str<br ALIGN="LEFT"/>capture_config : dict<br ALIGN="LEFT"/>capture_thread : Optional[threading.Thread]<br ALIGN="LEFT"/>connection_lock : lock<br ALIGN="LEFT"/>dns_redirections : Dict[str, str]<br ALIGN="LEFT"/>license_patterns : dict<br ALIGN="LEFT"/>license_ports : set<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>packet_queue : List[InterceptedPacket]<br ALIGN="LEFT"/>proxy_mappings : Dict[str, Tuple[str, int]]<br ALIGN="LEFT"/>queue_lock : lock<br ALIGN="LEFT"/>running : bool<br ALIGN="LEFT"/>stats : dict<br ALIGN="LEFT"/>|add_analysis_callback(callback: Callable[[AnalyzedTraffic], None])<br ALIGN="LEFT"/>get_active_connections(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>remove_analysis_callback(callback: Callable[[AnalyzedTraffic], None])<br ALIGN="LEFT"/>set_dns_redirection(hostname: str, target_ip: str): bool<br ALIGN="LEFT"/>setup_transparent_proxy(target_host: str, target_port: int): bool<br ALIGN="LEFT"/>start_interception(ports: List[int]): bool<br ALIGN="LEFT"/>stop_interception(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator._start_traffic_recorder.TrafficRecorder" [color="black", fontcolor="black", label=<{TrafficRecorder|last_save<br ALIGN="LEFT"/>max_entries : int<br ALIGN="LEFT"/>parent : str<br ALIGN="LEFT"/>recording : bool<br ALIGN="LEFT"/>save_interval : int<br ALIGN="LEFT"/>traffic_log : List[Dict[str, Any]]<br ALIGN="LEFT"/>|analyze_patterns(): Dict[str, List[str]]<br ALIGN="LEFT"/>record(source: str, destination: str, data: bytes, protocol: str): None<br ALIGN="LEFT"/>save_log(): None<br ALIGN="LEFT"/>stop(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingConfig" [color="black", fontcolor="black", label=<{TrainingConfig|batch_size : int<br ALIGN="LEFT"/>cutoff_len : int<br ALIGN="LEFT"/>dataset_format : str<br ALIGN="LEFT"/>dataset_path : str<br ALIGN="LEFT"/>epochs : int<br ALIGN="LEFT"/>evaluation_strategy : str<br ALIGN="LEFT"/>gradient_accumulation_steps : int<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>logging_steps : int<br ALIGN="LEFT"/>lora_alpha : int<br ALIGN="LEFT"/>lora_rank : int<br ALIGN="LEFT"/>loss_function : str<br ALIGN="LEFT"/>model_format : str<br ALIGN="LEFT"/>model_path : str<br ALIGN="LEFT"/>optimizer : str<br ALIGN="LEFT"/>output_directory : str<br ALIGN="LEFT"/>patience : int<br ALIGN="LEFT"/>save_strategy : str<br ALIGN="LEFT"/>warmup_ratio : float<br ALIGN="LEFT"/>weight_decay : float<br ALIGN="LEFT"/>|to_enhanced_config(): 'EnhancedTrainingConfiguration'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingConfiguration" [color="black", fontcolor="black", label=<{TrainingConfiguration|base_model : str<br ALIGN="LEFT"/>batch_size : int<br ALIGN="LEFT"/>checkpoint_frequency : int<br ALIGN="LEFT"/>dataset_path : str<br ALIGN="LEFT"/>epochs : int<br ALIGN="LEFT"/>freeze_layers : int<br ALIGN="LEFT"/>learning_rate : float<br ALIGN="LEFT"/>loss_function : str<br ALIGN="LEFT"/>mixed_precision : bool<br ALIGN="LEFT"/>model_name : str<br ALIGN="LEFT"/>model_type : str<br ALIGN="LEFT"/>multi_gpu : bool<br ALIGN="LEFT"/>optimizer : str<br ALIGN="LEFT"/>output_directory : str<br ALIGN="LEFT"/>patience : int<br ALIGN="LEFT"/>save_checkpoints : bool<br ALIGN="LEFT"/>tensorboard_logging : bool<br ALIGN="LEFT"/>use_augmentation : bool<br ALIGN="LEFT"/>use_early_stopping : bool<br ALIGN="LEFT"/>use_gpu : bool<br ALIGN="LEFT"/>use_transfer_learning : bool<br ALIGN="LEFT"/>validation_split : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingStatus" [color="black", fontcolor="black", label=<{TrainingStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingStatus" [color="black", fontcolor="black", label=<{TrainingStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingThread" [color="black", fontcolor="black", label=<{TrainingThread|config<br ALIGN="LEFT"/>error_occurred : NoneType<br ALIGN="LEFT"/>log_message : NoneType<br ALIGN="LEFT"/>metrics_updated : NoneType<br ALIGN="LEFT"/>paused : bool<br ALIGN="LEFT"/>progress_updated : NoneType<br ALIGN="LEFT"/>should_stop : bool<br ALIGN="LEFT"/>training_completed : NoneType<br ALIGN="LEFT"/>|pause_training()<br ALIGN="LEFT"/>resume_training()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>stop_training()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [color="black", fontcolor="black", label=<{TrainingThread|config<br ALIGN="LEFT"/>is_stopped : bool<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>model : NoneType, RecursiveScriptModule<br ALIGN="LEFT"/>progress_signal<br ALIGN="LEFT"/>status : COMPLETED, ERROR, IDLE, PAUSED, PREPARING, TRAINING, VALIDATING<br ALIGN="LEFT"/>tokenizer : NoneType<br ALIGN="LEFT"/>training_args<br ALIGN="LEFT"/>training_history : list<br ALIGN="LEFT"/>|pause()<br ALIGN="LEFT"/>resume()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.tabs.ai_assistant_tab.AIAssistantTab.start_model_training.TrainingThread" [color="black", fontcolor="black", label=<{TrainingThread|finished_training<br ALIGN="LEFT"/>model_manager<br ALIGN="LEFT"/>params<br ALIGN="LEFT"/>progress_update<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingVisualizationWidget" [color="black", fontcolor="black", label=<{TrainingVisualizationWidget|accuracy_plot : PlotWidget<br ALIGN="LEFT"/>loss_plot : PlotWidget<br ALIGN="LEFT"/>training_data : dict<br ALIGN="LEFT"/>|clear_plots()<br ALIGN="LEFT"/>export_data(filename)<br ALIGN="LEFT"/>setup_ui()<br ALIGN="LEFT"/>update_plots(epoch, loss, accuracy)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.scripts.cli.pipeline.TransformStage" [color="black", fontcolor="black", label=<{TransformStage|output_format : str<br ALIGN="LEFT"/>|process(input_data: PipelineData): PipelineData<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.TrendAnalysis" [color="black", fontcolor="black", label=<{TrendAnalysis|change_points : List[float]<br ALIGN="LEFT"/>component : str<br ALIGN="LEFT"/>forecast_intervals : List[Tuple[float, float]]<br ALIGN="LEFT"/>forecast_values : List[float]<br ALIGN="LEFT"/>protection_category<br ALIGN="LEFT"/>seasonal_pattern : bool<br ALIGN="LEFT"/>trend_direction : str<br ALIGN="LEFT"/>trend_strength : float<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.TriggerCondition" [color="black", fontcolor="black", label=<{TriggerCondition|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.tutorial_system.Tutorial" [color="black", fontcolor="black", label=<{Tutorial|completion_message : str<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>difficulty : str<br ALIGN="LEFT"/>estimated_time : int<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>steps : List[TutorialStep]<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.tutorial_system.TutorialStep" [color="black", fontcolor="black", label=<{TutorialStep|commands : List[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>expected_output : Optional[str]<br ALIGN="LEFT"/>explanation : str<br ALIGN="LEFT"/>hints : List[str]<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>skip_allowed : bool<br ALIGN="LEFT"/>title : str<br ALIGN="LEFT"/>validation : Optional[Callable]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.scripts.cli.tutorial_system.TutorialSystem" [color="black", fontcolor="black", label=<{TutorialSystem|cli_instance : NoneType<br ALIGN="LEFT"/>console : Console<br ALIGN="LEFT"/>current_step : int<br ALIGN="LEFT"/>current_tutorial : NoneType<br ALIGN="LEFT"/>tutorial_history : list<br ALIGN="LEFT"/>tutorial_progress : dict<br ALIGN="LEFT"/>tutorials : dict<br ALIGN="LEFT"/>|confirm_tutorial_reset(tutorial_name: str): bool<br ALIGN="LEFT"/>display_centered_tutorial_header(tutorial: Tutorial): None<br ALIGN="LEFT"/>display_step_with_syntax(step: TutorialStep): None<br ALIGN="LEFT"/>display_tutorial_cards(): None<br ALIGN="LEFT"/>display_tutorial_structure_tree(tutorial_name: str): None<br ALIGN="LEFT"/>display_tutorials_table(): None<br ALIGN="LEFT"/>get_custom_tutorial_settings(): Dict[str, Any]<br ALIGN="LEFT"/>interactive_tutorial_selection(): Optional[str]<br ALIGN="LEFT"/>list_tutorials(): None<br ALIGN="LEFT"/>next_step()<br ALIGN="LEFT"/>prev_step()<br ALIGN="LEFT"/>quit_tutorial()<br ALIGN="LEFT"/>resume_tutorial(): bool<br ALIGN="LEFT"/>show_help()<br ALIGN="LEFT"/>show_progress()<br ALIGN="LEFT"/>show_tutorial_progress_bar(tutorial_name: str): None<br ALIGN="LEFT"/>skip_step()<br ALIGN="LEFT"/>start_tutorial(tutorial_name: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" [color="black", fontcolor="black", label=<{UIConfig|auto_refresh : bool<br ALIGN="LEFT"/>enable_animations : bool<br ALIGN="LEFT"/>font_family : str<br ALIGN="LEFT"/>font_size : int<br ALIGN="LEFT"/>max_log_entries : int<br ALIGN="LEFT"/>panel_weights : Tuple[int, int, int]<br ALIGN="LEFT"/>refresh_interval : int<br ALIGN="LEFT"/>show_tooltips : bool<br ALIGN="LEFT"/>theme<br ALIGN="LEFT"/>|from_dict(data: Dict[str, Any]): 'UIConfig'<br ALIGN="LEFT"/>to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [color="black", fontcolor="black", label=<{UIEnhancementModule|analysis_state : ANALYZING, COMPLETE, ERROR, IDLE, SCANNING<br ALIGN="LEFT"/>analysis_viewer<br ALIGN="LEFT"/>anti_debug<br ALIGN="LEFT"/>config<br ALIGN="LEFT"/>core_engine<br ALIGN="LEFT"/>current_target : NoneType<br ALIGN="LEFT"/>dongle_emulator<br ALIGN="LEFT"/>file_explorer<br ALIGN="LEFT"/>log_viewer<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>main_paned : Panedwindow<br ALIGN="LEFT"/>memory_label : Label<br ALIGN="LEFT"/>progress_tracker<br ALIGN="LEFT"/>protection_classifier<br ALIGN="LEFT"/>root : Tk<br ALIGN="LEFT"/>script_generator<br ALIGN="LEFT"/>state_label : Label<br ALIGN="LEFT"/>status_frame : Frame<br ALIGN="LEFT"/>status_label : Label<br ALIGN="LEFT"/>target_label : Label<br ALIGN="LEFT"/>vm_unwrapper<br ALIGN="LEFT"/>|analyze_file(file_path: str)<br ALIGN="LEFT"/>apply_cyberpunk_theme()<br ALIGN="LEFT"/>apply_dark_theme()<br ALIGN="LEFT"/>apply_high_contrast_theme()<br ALIGN="LEFT"/>apply_light_theme()<br ALIGN="LEFT"/>apply_theme()<br ALIGN="LEFT"/>batch_analysis()<br ALIGN="LEFT"/>create_main_interface()<br ALIGN="LEFT"/>create_menu()<br ALIGN="LEFT"/>create_status_bar()<br ALIGN="LEFT"/>deep_analysis()<br ALIGN="LEFT"/>execute_custom_script(script: str, language: str)<br ALIGN="LEFT"/>execute_frida_script(script: str, target: str)<br ALIGN="LEFT"/>execute_ghidra_script(script: str, target: str)<br ALIGN="LEFT"/>execute_r2_script(script: str, target: str)<br ALIGN="LEFT"/>exit_application()<br ALIGN="LEFT"/>export_results()<br ALIGN="LEFT"/>generate_frida_script(target: str, script_type: str): str<br ALIGN="LEFT"/>generate_ghidra_script(target: str, script_type: str): str<br ALIGN="LEFT"/>generate_r2_script(target: str, script_type: str): str<br ALIGN="LEFT"/>generate_scripts(file_path: str)<br ALIGN="LEFT"/>initialize_analysis_modules()<br ALIGN="LEFT"/>load_config(): UIConfig<br ALIGN="LEFT"/>open_disassembler()<br ALIGN="LEFT"/>open_file()<br ALIGN="LEFT"/>open_folder()<br ALIGN="LEFT"/>open_hex_editor()<br ALIGN="LEFT"/>open_plugin_manager()<br ALIGN="LEFT"/>open_string_extractor()<br ALIGN="LEFT"/>quick_scan()<br ALIGN="LEFT"/>refresh_current_view()<br ALIGN="LEFT"/>reset_layout()<br ALIGN="LEFT"/>run()<br ALIGN="LEFT"/>save_config()<br ALIGN="LEFT"/>setup_logging()<br ALIGN="LEFT"/>show_about()<br ALIGN="LEFT"/>show_documentation()<br ALIGN="LEFT"/>show_file_properties(file_path: Path)<br ALIGN="LEFT"/>show_preferences()<br ALIGN="LEFT"/>show_preferences_dialog()<br ALIGN="LEFT"/>show_recent_files()<br ALIGN="LEFT"/>show_shortcuts()<br ALIGN="LEFT"/>start_auto_refresh()<br ALIGN="LEFT"/>toggle_panels()<br ALIGN="LEFT"/>update_status()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.shared_ui_layouts.UILayoutHelpers" [color="black", fontcolor="black", label=<{UILayoutHelpers|<br ALIGN="LEFT"/>|create_config_group(title: str, use_form_layout: bool): Tuple[QGroupBox, QVBoxLayout]<br ALIGN="LEFT"/>create_dialog_buttons(button_specs: List[Tuple[str, Callable, bool]], layout: QVBoxLayout): List[QPushButton]<br ALIGN="LEFT"/>create_file_browse_widget(placeholder_text: str, browse_callback: Optional[Callable], browse_text: str): Tuple[QHBoxLayout, QLineEdit, QPushButton]<br ALIGN="LEFT"/>create_tabbed_dialog_layout(dialog, window_title: str, size: Tuple[int, int], is_modal: bool): Tuple[QVBoxLayout, QTabWidget]<br ALIGN="LEFT"/>create_tabs_from_specs(tab_widget: QTabWidget, tab_specs: List[Tuple[str, QWidget]]): None<br ALIGN="LEFT"/>finalize_widget_layout(widget: QWidget, layout): QWidget<br ALIGN="LEFT"/>setup_standard_form_field(layout, label_text: str, widget: QWidget): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.event_handler_utils.UIStateManager" [color="black", fontcolor="black", label=<{UIStateManager|state_mappings : dict<br ALIGN="LEFT"/>|apply_state(state_name: str)<br ALIGN="LEFT"/>register_state_mapping(state_name: str, widget_states: Dict[QWidget, bool])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UITheme" [color="black", fontcolor="black", label=<{UITheme|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.ui.ui_utils.UIUpdateQueue" [color="black", fontcolor="black", label=<{UIUpdateQueue|updates : List[Tuple[str, Any]]<br ALIGN="LEFT"/>|add_update(update_type: str, data: Any)<br ALIGN="LEFT"/>clear()<br ALIGN="LEFT"/>flush(callback: Callable[[str, Any], None])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.USBDongleDriver" [color="black", fontcolor="black", label=<{USBDongleDriver|dongles : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>usb<br ALIGN="LEFT"/>usb_backend : NoneType, str<br ALIGN="LEFT"/>win32api<br ALIGN="LEFT"/>win32file<br ALIGN="LEFT"/>|bulk_transfer(vendor_id: int, product_id: int, endpoint: int, data: bytes, length: int): bytes<br ALIGN="LEFT"/>control_transfer(vendor_id: int, product_id: int, request_type: int, request: int, value: int, index: int, data: bytes): bytes<br ALIGN="LEFT"/>find_dongles(vendor_id: Optional[int], product_id: Optional[int]): List[BaseDongleEmulator]<br ALIGN="LEFT"/>register_dongle(dongle: BaseDongleEmulator)<br ALIGN="LEFT"/>unregister_dongle(vendor_id: int, product_id: int)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.UnifiedAnalysisThread" [color="black", fontcolor="black", label=<{UnifiedAnalysisThread|analysis_complete<br ALIGN="LEFT"/>analysis_error<br ALIGN="LEFT"/>analysis_progress<br ALIGN="LEFT"/>deep_scan : bool<br ALIGN="LEFT"/>engine<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" [color="black", fontcolor="black", label=<{UnifiedProtectionEngine|cache : NoneType<br ALIGN="LEFT"/>enable_heuristics : bool<br ALIGN="LEFT"/>enable_protection : bool<br ALIGN="LEFT"/>protection_detector<br ALIGN="LEFT"/>|analyze(file_path: str, deep_scan: bool, timeout: int): UnifiedProtectionResult<br ALIGN="LEFT"/>analyze_file(file_path: str, deep_scan: bool, timeout: int): UnifiedProtectionResult<br ALIGN="LEFT"/>cleanup_cache(): int<br ALIGN="LEFT"/>clear_cache(): None<br ALIGN="LEFT"/>get_cache_size(): Tuple[int, float]<br ALIGN="LEFT"/>get_cache_stats(): Dict[str, Any]<br ALIGN="LEFT"/>get_quick_summary(file_path: str): Dict[str, Any]<br ALIGN="LEFT"/>invalidate_cache_for_file(file_path: str): None<br ALIGN="LEFT"/>remove_from_cache(file_path: str): bool<br ALIGN="LEFT"/>save_cache(): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionResult" [color="black", fontcolor="black", label=<{UnifiedProtectionResult|analysis_time : float<br ALIGN="LEFT"/>architecture : str<br ALIGN="LEFT"/>bypass_strategies : List[Dict[str, Any]]<br ALIGN="LEFT"/>confidence_score : float<br ALIGN="LEFT"/>engines_used : List[str]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_type : str<br ALIGN="LEFT"/>has_anti_debug : bool<br ALIGN="LEFT"/>has_anti_vm : bool<br ALIGN="LEFT"/>has_licensing : bool<br ALIGN="LEFT"/>icp_analysis : Optional[ICPScanResult]<br ALIGN="LEFT"/>is_obfuscated : bool<br ALIGN="LEFT"/>is_packed : bool<br ALIGN="LEFT"/>is_protected : bool<br ALIGN="LEFT"/>protection_analysis : Optional[AdvancedProtectionAnalysis]<br ALIGN="LEFT"/>protections : List[Dict[str, Any]]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [color="black", fontcolor="black", label=<{UnifiedProtectionWidget|analysis_thread : Optional[UnifiedAnalysisThread]<br ALIGN="LEFT"/>bypass_requested<br ALIGN="LEFT"/>bypass_widget<br ALIGN="LEFT"/>cards_layout<br ALIGN="LEFT"/>cards_widget<br ALIGN="LEFT"/>content_splitter<br ALIGN="LEFT"/>current_result : NoneType, Optional[UnifiedProtectionResult]<br ALIGN="LEFT"/>deep_scan_btn<br ALIGN="LEFT"/>details_tabs<br ALIGN="LEFT"/>details_text<br ALIGN="LEFT"/>entropy_graph<br ALIGN="LEFT"/>file_info_label<br ALIGN="LEFT"/>hex_viewer<br ALIGN="LEFT"/>icp_features_btn<br ALIGN="LEFT"/>perf_text<br ALIGN="LEFT"/>progress_bar<br ALIGN="LEFT"/>protection_analyzed<br ALIGN="LEFT"/>quick_scan_btn<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>strategies_layout<br ALIGN="LEFT"/>string_extractor<br ALIGN="LEFT"/>summary_group<br ALIGN="LEFT"/>summary_text<br ALIGN="LEFT"/>tech_text<br ALIGN="LEFT"/>|analyze_file(file_path: Optional[str], deep_scan: bool)<br ALIGN="LEFT"/>clear_results()<br ALIGN="LEFT"/>display_bypass_strategies(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>display_protection_cards(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>display_results(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>export_bypass_guide()<br ALIGN="LEFT"/>generate_bypass_script()<br ALIGN="LEFT"/>init_ui()<br ALIGN="LEFT"/>on_analysis_complete(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>on_analysis_error(error_msg: str)<br ALIGN="LEFT"/>on_analysis_progress(message: str, progress: int)<br ALIGN="LEFT"/>on_protection_clicked(protection_data: Dict[str, Any])<br ALIGN="LEFT"/>set_binary_path(file_path: str)<br ALIGN="LEFT"/>show_icp_features_dialog()<br ALIGN="LEFT"/>show_protection_details(protection: Dict[str, Any])<br ALIGN="LEFT"/>update_entropy_graph(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>update_performance_info(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>update_summary(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>update_technical_info(result: UnifiedProtectionResult)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.lateral_movement.LateralMovement._linux_docker_api.UnixHTTPConnection" [color="black", fontcolor="black", label=<{UnixHTTPConnection|path<br ALIGN="LEFT"/>sock : socket<br ALIGN="LEFT"/>|connect()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.UpdateMode" [color="black", fontcolor="black", label=<{UpdateMode|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMAnalyzer" [color="black", fontcolor="black", label=<{VMAnalyzer|logger : NoneType, RootLogger<br ALIGN="LEFT"/>patterns : dict<br ALIGN="LEFT"/>|analyze_vm_structure(vm_data: bytes, entry_point: int): Dict[str, Any]<br ALIGN="LEFT"/>detect_vm_protection(binary_data: bytes): ProtectionType<br ALIGN="LEFT"/>find_vm_entry_points(binary_data: bytes, protection_type: ProtectionType): List[int]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMContext" [color="black", fontcolor="black", label=<{VMContext|flags : Dict[str, bool]<br ALIGN="LEFT"/>memory : Dict[int, bytes]<br ALIGN="LEFT"/>registers : Dict[str, int]<br ALIGN="LEFT"/>stack : List[int]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.anti_analysis.vm_detector.VMDetector" [color="black", fontcolor="black", label=<{VMDetector|detection_methods : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>vm_signatures : dict<br ALIGN="LEFT"/>|detect_vm(aggressive: bool): Dict[str, Any]<br ALIGN="LEFT"/>generate_bypass(vm_type: str): Dict[str, Any]<br ALIGN="LEFT"/>generate_evasion_code(target_vm: str): str<br ALIGN="LEFT"/>get_aggressive_methods(): list<br ALIGN="LEFT"/>get_detection_type(): str<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.vm_bypass.VMDetector" [color="black", fontcolor="black", label=<{VMDetector|logger : NoneType, RootLogger<br ALIGN="LEFT"/>vm_indicators : list<br ALIGN="LEFT"/>|detect(): Dict[str, Any]<br ALIGN="LEFT"/>generate_bypass(vm_type: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMEmulator" [color="black", fontcolor="black", label=<{VMEmulator|context<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>protection_type<br ALIGN="LEFT"/>|execute_vm_instruction(instruction: VMInstruction): bool<br ALIGN="LEFT"/>parse_vm_instruction(vm_data: bytes, offset: int): VMInstruction<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMInstruction" [color="black", fontcolor="black", label=<{VMInstruction|metadata : Dict[str, Any]<br ALIGN="LEFT"/>mnemonic : str<br ALIGN="LEFT"/>opcode : int<br ALIGN="LEFT"/>operands : List[int]<br ALIGN="LEFT"/>size : int<br ALIGN="LEFT"/>vm_type<br ALIGN="LEFT"/>x86_equivalent : Optional[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMInstructionType" [color="black", fontcolor="black", label=<{VMInstructionType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMProtectHandler" [color="black", fontcolor="black", label=<{VMProtectHandler|logger : NoneType, RootLogger<br ALIGN="LEFT"/>|decrypt_vm_code(encrypted_data: bytes, key: bytes, version: ProtectionType): bytes<br ALIGN="LEFT"/>identify_version(vm_data: bytes): ProtectionType<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMProtectionUnwrapper" [color="black", fontcolor="black", label=<{VMProtectionUnwrapper|analyzer<br ALIGN="LEFT"/>emulators : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|batch_unwrap(input_dir: str, output_dir: str): Dict[str, Any]<br ALIGN="LEFT"/>get_statistics(): Dict[str, Any]<br ALIGN="LEFT"/>unwrap_file(input_file: str, output_file: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.resources.resource_manager.VMResource" [color="black", fontcolor="black", label=<{VMResource|vm_name : str<br ALIGN="LEFT"/>vm_process : Optional[subprocess.Popen]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.hexview.hex_renderer.ViewMode" [color="black", fontcolor="black", label=<{ViewMode|name<br ALIGN="LEFT"/>|names(): List[str]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.hexview.file_handler.VirtualFileAccess" [color="black", fontcolor="black", label=<{VirtualFileAccess|applied_edits : list<br ALIGN="LEFT"/>chunk_manager<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>file_size<br ALIGN="LEFT"/>large_file_handler : NoneType, Optional[LargeFileHandler]<br ALIGN="LEFT"/>pending_edits : dict<br ALIGN="LEFT"/>read_only : bool<br ALIGN="LEFT"/>temp_file_path : NoneType<br ALIGN="LEFT"/>use_large_file_optimization : bool<br ALIGN="LEFT"/>using_temp_file : bool<br ALIGN="LEFT"/>write_file : NoneType<br ALIGN="LEFT"/>|apply_edits(): bool<br ALIGN="LEFT"/>delete(offset: int, length: int): bool<br ALIGN="LEFT"/>discard_edits()<br ALIGN="LEFT"/>get_file_size(): int<br ALIGN="LEFT"/>get_modification_time(): float<br ALIGN="LEFT"/>get_performance_stats(): Optional[dict]<br ALIGN="LEFT"/>insert(offset: int, data: bytes): bool<br ALIGN="LEFT"/>optimize_for_random_access()<br ALIGN="LEFT"/>optimize_for_sequential_access()<br ALIGN="LEFT"/>read(offset: int, size: int): bytes<br ALIGN="LEFT"/>save_as(new_path: str): bool<br ALIGN="LEFT"/>undo_last_edit(): bool<br ALIGN="LEFT"/>write(offset: int, data: bytes): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.vm_bypass.VirtualizationAnalyzer" [color="black", fontcolor="black", label=<{VirtualizationAnalyzer|binary_path : Optional[str]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>|analyze(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.protection_bypass.vm_bypass.VirtualizationDetectionBypass" [color="black", fontcolor="black", label=<{VirtualizationDetectionBypass|app : Optional[Any]<br ALIGN="LEFT"/>hooks : List[Dict[str, Any]]<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>patches : List[Dict[str, Any]]<br ALIGN="LEFT"/>|bypass_vm_detection(): Dict[str, Any]<br ALIGN="LEFT"/>clear_hooks(): None<br ALIGN="LEFT"/>generate_bypass_script(): str<br ALIGN="LEFT"/>get_hook_status(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.visual_patch_editor.VisualPatchEditorDialog" [color="black", fontcolor="black", label=<{VisualPatchEditorDialog|address_edit<br ALIGN="LEFT"/>binary_path : str<br ALIGN="LEFT"/>bytes_edit<br ALIGN="LEFT"/>description_edit<br ALIGN="LEFT"/>disasm_view<br ALIGN="LEFT"/>disassembly_cache : dict<br ALIGN="LEFT"/>original_bytes_view<br ALIGN="LEFT"/>original_patches<br ALIGN="LEFT"/>patch_list<br ALIGN="LEFT"/>patched_bytes_view<br ALIGN="LEFT"/>patches<br ALIGN="LEFT"/>status_label<br ALIGN="LEFT"/>|add_new_patch(): None<br ALIGN="LEFT"/>clear_patch_form(): None<br ALIGN="LEFT"/>duplicate_selected_patch(): None<br ALIGN="LEFT"/>get_patches(): List[Dict[str, Any]]<br ALIGN="LEFT"/>has_unsaved_changes(): bool<br ALIGN="LEFT"/>init_ui(): None<br ALIGN="LEFT"/>patch_selected(current, previous): None<br ALIGN="LEFT"/>populate_patch_list(): None<br ALIGN="LEFT"/>remove_selected_patch(): None<br ALIGN="LEFT"/>show_test_results(results: List[str]): None<br ALIGN="LEFT"/>test_patches(): None<br ALIGN="LEFT"/>update_byte_preview(address: int, new_bytes: bytes): None<br ALIGN="LEFT"/>update_current_patch(): None<br ALIGN="LEFT"/>update_disassembly_view(address: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.visualization_analytics.VisualizationAnalytics" [color="black", fontcolor="black", label=<{VisualizationAnalytics|analytics_engine<br ALIGN="LEFT"/>dashboard_manager<br ALIGN="LEFT"/>data_collector<br ALIGN="LEFT"/>|create_custom_dashboard(name: str, description: str, chart_configs: List[Dict[str, Any]]): Dashboard<br ALIGN="LEFT"/>generate_insights_report(): Dict[str, Any]<br ALIGN="LEFT"/>get_dashboard(dashboard_id: str): Optional[Dashboard]<br ALIGN="LEFT"/>get_system_status(): Dict[str, Any]<br ALIGN="LEFT"/>list_dashboards(): List[Dict[str, str]]<br ALIGN="LEFT"/>refresh_dashboard(dashboard_id: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.exploit_chain_builder.Vulnerability" [color="black", fontcolor="black", label=<{Vulnerability|confidence : float<br ALIGN="LEFT"/>cve_id : Optional[str]<br ALIGN="LEFT"/>description : str<br ALIGN="LEFT"/>discovery_method : str<br ALIGN="LEFT"/>exploitability : float<br ALIGN="LEFT"/>impact : Dict[str, str]<br ALIGN="LEFT"/>location : Dict[str, Any]<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>prerequisites : List[str]<br ALIGN="LEFT"/>severity : str<br ALIGN="LEFT"/>vuln_id : str<br ALIGN="LEFT"/>vuln_type<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.VulnerabilityAnalyzer" [color="black", fontcolor="black", label=<{VulnerabilityAnalyzer|analysis_cache : dict<br ALIGN="LEFT"/>dynamic_indicators : dict<br ALIGN="LEFT"/>feature_extractors : dict<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ml_model : NoneType, RandomForestClassifier<br ALIGN="LEFT"/>vulnerability_patterns : dict<br ALIGN="LEFT"/>|analyze_code_snippet(code: str, language: str, vulnerability_types: Optional[List[VulnerabilityType]]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_target(target_info: Dict[str, Any], analysis_options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>analyze_vulnerability(target_path: str, analysis_method: AnalysisMethod, vulnerability_types: Optional[List[VulnerabilityType]]): Dict[str, Any]<br ALIGN="LEFT"/>clear_analysis_cache()<br ALIGN="LEFT"/>export_analysis(result: Dict[str, Any], output_file: str, format: str): bool<br ALIGN="LEFT"/>get_analysis_cache(): Dict[str, Any]<br ALIGN="LEFT"/>load_ml_model(model_path: str): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog._execute_testcase.VulnerabilityAnalyzer" [color="black", fontcolor="black", label=<{VulnerabilityAnalyzer|analysis_cache : dict<br ALIGN="LEFT"/>detection_modules : dict<br ALIGN="LEFT"/>|analyze(target_path, analysis_type)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.VulnerabilityCorrelator" [color="black", fontcolor="black", label=<{VulnerabilityCorrelator|<br ALIGN="LEFT"/>|analyze_campaigns(campaigns: List[Dict]): Dict<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.predictive_intelligence.VulnerabilityPredictor" [color="black", fontcolor="black", label=<{VulnerabilityPredictor|discovery_history : list<br ALIGN="LEFT"/>feature_extractor<br ALIGN="LEFT"/>model<br ALIGN="LEFT"/>pattern_weights : dict<br ALIGN="LEFT"/>vulnerability_patterns : list<br ALIGN="LEFT"/>|get_confidence_score(binary_path: str): float<br ALIGN="LEFT"/>predict(binary_path: str): List[Dict[str, Any]]<br ALIGN="LEFT"/>predict_vulnerability_likelihood(file_context: Dict[str, Any]): PredictionResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.vulnerability_engine.VulnerabilityReport" [color="black", fontcolor="black", label=<{VulnerabilityReport|<br ALIGN="LEFT"/>|generate_report(vulnerabilities: List[Dict[str, Any]], binary_path: str): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [color="black", fontcolor="black", label=<{VulnerabilityResearchAI|active_workflows : dict<br ALIGN="LEFT"/>ai_recommendations : list<br ALIGN="LEFT"/>c2_manager : C2Manager<br ALIGN="LEFT"/>config : dict<br ALIGN="LEFT"/>exploitation_history : list<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>payload_engine : PayloadEngine<br ALIGN="LEFT"/>persistence_manager : PersistenceManager<br ALIGN="LEFT"/>research_manager : ResearchManager<br ALIGN="LEFT"/>vulnerability_analyzer : VulnerabilityAnalyzer<br ALIGN="LEFT"/>|analyze_target_with_ai(target_path: str, analysis_options: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>execute_automated_exploitation(target_info: Dict[str, Any], exploitation_config: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>get_ai_insights(target_info: Optional[Dict[str, Any]]): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.VulnerabilityResearchDialog" [color="black", fontcolor="black", label=<{VulnerabilityResearchDialog|active_campaigns : dict<br ALIGN="LEFT"/>ai_integration_check<br ALIGN="LEFT"/>analyze_coverage_btn<br ALIGN="LEFT"/>auto_correlation_check<br ALIGN="LEFT"/>auto_exploitation_check<br ALIGN="LEFT"/>branch_coverage_bar<br ALIGN="LEFT"/>branch_coverage_label<br ALIGN="LEFT"/>browse_binary_btn<br ALIGN="LEFT"/>browse_targets_btn<br ALIGN="LEFT"/>browse_tests_btn<br ALIGN="LEFT"/>campaign_name_edit<br ALIGN="LEFT"/>campaign_results : dict<br ALIGN="LEFT"/>campaign_type_combo<br ALIGN="LEFT"/>campaigns_tab<br ALIGN="LEFT"/>campaigns_tree<br ALIGN="LEFT"/>cancel_campaign_btn<br ALIGN="LEFT"/>close_btn<br ALIGN="LEFT"/>cold_spots_table<br ALIGN="LEFT"/>confidence_spin<br ALIGN="LEFT"/>config_tab<br ALIGN="LEFT"/>correlate_results_btn<br ALIGN="LEFT"/>correlation_edit<br ALIGN="LEFT"/>coverage_binary_edit<br ALIGN="LEFT"/>coverage_metrics_widget<br ALIGN="LEFT"/>coverage_summary_text<br ALIGN="LEFT"/>coverage_tab<br ALIGN="LEFT"/>create_campaign_btn<br ALIGN="LEFT"/>export_btn<br ALIGN="LEFT"/>export_coverage_btn<br ALIGN="LEFT"/>export_viz_btn<br ALIGN="LEFT"/>file_coverage_combo<br ALIGN="LEFT"/>file_coverage_display<br ALIGN="LEFT"/>function_coverage_bar<br ALIGN="LEFT"/>function_coverage_label<br ALIGN="LEFT"/>function_coverage_table<br ALIGN="LEFT"/>generate_report_btn<br ALIGN="LEFT"/>hot_spots_table<br ALIGN="LEFT"/>line_coverage_bar<br ALIGN="LEFT"/>line_coverage_label<br ALIGN="LEFT"/>load_config_btn<br ALIGN="LEFT"/>max_campaigns_spin<br ALIGN="LEFT"/>min_samples_spin<br ALIGN="LEFT"/>pause_campaign_btn<br ALIGN="LEFT"/>raw_data_edit<br ALIGN="LEFT"/>realtime_adaptation_check<br ALIGN="LEFT"/>refresh_campaigns_btn<br ALIGN="LEFT"/>research_manager<br ALIGN="LEFT"/>reset_config_btn<br ALIGN="LEFT"/>result_tabs<br ALIGN="LEFT"/>results_tab<br ALIGN="LEFT"/>results_tree<br ALIGN="LEFT"/>retrain_threshold_spin<br ALIGN="LEFT"/>save_config_btn<br ALIGN="LEFT"/>spots_tabs<br ALIGN="LEFT"/>start_campaign_btn<br ALIGN="LEFT"/>storage_dir_edit<br ALIGN="LEFT"/>summary_edit<br ALIGN="LEFT"/>tab_widget<br ALIGN="LEFT"/>targets_edit<br ALIGN="LEFT"/>template_combo<br ALIGN="LEFT"/>test_cases_edit<br ALIGN="LEFT"/>timeout_spin<br ALIGN="LEFT"/>update_timer<br ALIGN="LEFT"/>vulnerabilities_table<br ALIGN="LEFT"/>worker<br ALIGN="LEFT"/>|closeEvent(event)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.VulnerabilityType" [color="black", fontcolor="black", label=<{VulnerabilityType|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.WilsonScoreInterval" [color="black", fontcolor="black", label=<{WilsonScoreInterval|<br ALIGN="LEFT"/>|calculate(successes: int, total: int, confidence_level: float): Tuple[float, float]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.WindowsAPIHooker" [color="black", fontcolor="black", label=<{WindowsAPIHooker|active_hooks : set<br ALIGN="LEFT"/>hooked_functions : dict<br ALIGN="LEFT"/>kernel32<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>ntdll<br ALIGN="LEFT"/>original_functions : dict<br ALIGN="LEFT"/>user32<br ALIGN="LEFT"/>|hook_check_remote_debugger_present(): bool<br ALIGN="LEFT"/>hook_is_debugger_present(): bool<br ALIGN="LEFT"/>hook_nt_query_information_process(): bool<br ALIGN="LEFT"/>hook_nt_set_information_thread(): bool<br ALIGN="LEFT"/>hook_output_debug_string(): bool<br ALIGN="LEFT"/>install_all_hooks(): List[str]<br ALIGN="LEFT"/>restore_hooks(): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.patching.windows_activator.WindowsActivator" [color="black", fontcolor="black", label=<{WindowsActivator|last_validation_result : NoneType<br ALIGN="LEFT"/>last_validation_time : NoneType<br ALIGN="LEFT"/>logger : NoneType, RootLogger<br ALIGN="LEFT"/>script_path<br ALIGN="LEFT"/>temp_dir<br ALIGN="LEFT"/>validation_cache_duration : int<br ALIGN="LEFT"/>|activate_office(office_version: str): Dict[str, any]<br ALIGN="LEFT"/>activate_windows(method: ActivationMethod): Dict[str, any]<br ALIGN="LEFT"/>activate_windows_digital(): Dict[str, any]<br ALIGN="LEFT"/>activate_windows_kms(): Dict[str, any]<br ALIGN="LEFT"/>check_prerequisites(): Tuple[bool, List[str]]<br ALIGN="LEFT"/>get_activation_status(): Dict[str, str]<br ALIGN="LEFT"/>get_product_key_info(): Dict[str, str]<br ALIGN="LEFT"/>reset_activation(): Dict[str, any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_common.WindowsConstants" [color="black", fontcolor="black", label=<{WindowsConstants|CREATE_NO_WINDOW : int<br ALIGN="LEFT"/>CREATE_SUSPENDED : int<br ALIGN="LEFT"/>MEM_COMMIT : int<br ALIGN="LEFT"/>MEM_RESERVE : int<br ALIGN="LEFT"/>PAGE_EXECUTE_READWRITE : int<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_structures.WindowsContext" [color="black", fontcolor="black", label=<{WindowsContext|kernel32 : NoneType<br ALIGN="LEFT"/>|create_context_structure()<br ALIGN="LEFT"/>get_entry_point(context: Any): int<br ALIGN="LEFT"/>get_thread_context(thread_handle: int): Optional[Any]<br ALIGN="LEFT"/>set_thread_context(thread_handle: int, context: Any): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence" [color="black", fontcolor="black", label=<{WindowsPersistence|logger : NoneType, RootLogger<br ALIGN="LEFT"/>persistence_methods : dict<br ALIGN="LEFT"/>registry_locations : dict<br ALIGN="LEFT"/>|generate_persistence_code(method: str): str<br ALIGN="LEFT"/>get_default_method(): str<br ALIGN="LEFT"/>list_available_methods(): list<br ALIGN="LEFT"/>list_persistence_methods(): List[str]<br ALIGN="LEFT"/>remove_persistence(cleanup_info: Dict[str, Any]): bool<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.system.windows_structures.WindowsProcessStructures" [color="black", fontcolor="black", label=<{WindowsProcessStructures|<br ALIGN="LEFT"/>|create_process_information()<br ALIGN="LEFT"/>create_startup_info()<br ALIGN="LEFT"/>create_suspended_process(exe_path: str, command_line: str): Optional[Dict]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_bypass_wizard.WizardPresetManager" [color="black", fontcolor="black", label=<{WizardPresetManager|<br ALIGN="LEFT"/>|apply_software_preset(wizard: FridaBypassWizard, software_name: str)<br ALIGN="LEFT"/>create_custom_wizard(config: Dict[str, Any])<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.frida_bypass_wizard.WizardState" [color="black", fontcolor="black", label=<{WizardState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ui.main_app.WorkerThread" [color="black", fontcolor="black", label=<{WorkerThread|args : tuple<br ALIGN="LEFT"/>error<br ALIGN="LEFT"/>finished<br ALIGN="LEFT"/>func<br ALIGN="LEFT"/>is_running : bool<br ALIGN="LEFT"/>kwargs : dict<br ALIGN="LEFT"/>progress<br ALIGN="LEFT"/>result<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>stop()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowDefinition" [color="black", fontcolor="black", label=<{WorkflowDefinition|description : str<br ALIGN="LEFT"/>error_handling : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>parallel_execution : bool<br ALIGN="LEFT"/>result_aggregation : str<br ALIGN="LEFT"/>steps : List[WorkflowStep]<br ALIGN="LEFT"/>tags : List[str]<br ALIGN="LEFT"/>timeout : Optional[int]<br ALIGN="LEFT"/>workflow_id : str<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowEngine" [color="black", fontcolor="black", label=<{WorkflowEngine|default_timeout : int<br ALIGN="LEFT"/>event_bus<br ALIGN="LEFT"/>logger : Logger<br ALIGN="LEFT"/>max_concurrent_workflows : int<br ALIGN="LEFT"/>plugin_manager<br ALIGN="LEFT"/>running_workflows : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>workflow_history : List[Dict[str, Any]]<br ALIGN="LEFT"/>workflows : Dict[str, WorkflowDefinition]<br ALIGN="LEFT"/>|cancel_workflow(execution_id: str): bool<br ALIGN="LEFT"/>execute_workflow(workflow_id: str, parameters: Dict[str, Any]): str<br ALIGN="LEFT"/>get_available_workflows(): List[Dict[str, Any]]<br ALIGN="LEFT"/>get_workflow_status(execution_id: str): Optional[Dict[str, Any]]<br ALIGN="LEFT"/>register_workflow(workflow: WorkflowDefinition)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.integration_manager.WorkflowResult" [color="black", fontcolor="black", label=<{WorkflowResult|artifacts : Dict[str, Any]<br ALIGN="LEFT"/>errors : List[str]<br ALIGN="LEFT"/>execution_time : float<br ALIGN="LEFT"/>results : Dict[str, Any]<br ALIGN="LEFT"/>success : bool<br ALIGN="LEFT"/>tasks_completed : int<br ALIGN="LEFT"/>tasks_failed : int<br ALIGN="LEFT"/>workflow_id : str<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.ai.autonomous_agent.WorkflowState" [color="black", fontcolor="black", label=<{WorkflowState|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowStatus" [color="black", fontcolor="black", label=<{WorkflowStatus|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowStep" [color="black", fontcolor="black", label=<{WorkflowStep|condition : Optional[str]<br ALIGN="LEFT"/>dependencies : List[str]<br ALIGN="LEFT"/>max_retries : int<br ALIGN="LEFT"/>method : str<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>parameters : Dict[str, Any]<br ALIGN="LEFT"/>plugin_name : str<br ALIGN="LEFT"/>retry_count : int<br ALIGN="LEFT"/>step_id : str<br ALIGN="LEFT"/>timeout : Optional[int]<br ALIGN="LEFT"/>|to_dict(): Dict[str, Any]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.YaraMatch" [color="black", fontcolor="black", label=<{YaraMatch|category<br ALIGN="LEFT"/>confidence : float<br ALIGN="LEFT"/>identifier : str<br ALIGN="LEFT"/>length : int<br ALIGN="LEFT"/>metadata : Dict[str, Any]<br ALIGN="LEFT"/>namespace : str<br ALIGN="LEFT"/>offset : int<br ALIGN="LEFT"/>rule_name : str<br ALIGN="LEFT"/>severity<br ALIGN="LEFT"/>string_data : str<br ALIGN="LEFT"/>tags : List[str]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.YaraPatternEngine" [color="black", fontcolor="black", label=<{YaraPatternEngine|compiled_rules : NoneType, Optional[yara.Rules]<br ALIGN="LEFT"/>custom_rules_path : Optional[str]<br ALIGN="LEFT"/>rule_metadata : Dict[str, Dict[str, Any]]<br ALIGN="LEFT"/>scanned_files : Set[str]<br ALIGN="LEFT"/>|create_custom_rule(rule_content: str, rule_name: str): bool<br ALIGN="LEFT"/>generate_icp_supplemental_data(scan_result: YaraScanResult): Dict[str, Any]<br ALIGN="LEFT"/>get_rule_info(): Dict[str, Any]<br ALIGN="LEFT"/>scan_file(file_path: str, timeout: int): YaraScanResult<br ALIGN="LEFT"/>scan_memory(process_id: int, timeout: int): YaraScanResult<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.YaraScanResult" [color="black", fontcolor="black", label=<{YaraScanResult|error : Optional[str]<br ALIGN="LEFT"/>file_path : str<br ALIGN="LEFT"/>has_licensing<br ALIGN="LEFT"/>has_packers<br ALIGN="LEFT"/>has_protections<br ALIGN="LEFT"/>high_confidence_matches<br ALIGN="LEFT"/>matches : List[YaraMatch]<br ALIGN="LEFT"/>metadata : dict<br ALIGN="LEFT"/>scan_time : float<br ALIGN="LEFT"/>total_rules : int<br ALIGN="LEFT"/>|get_matches_by_category(category: PatternCategory): List[YaraMatch]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.core.common_imports._DummyWidget" [color="black", fontcolor="black", label=<{_DummyWidget|<br ALIGN="LEFT"/>|<I>addItems</I>()<br ALIGN="LEFT"/><I>addLayout</I>()<br ALIGN="LEFT"/><I>addStretch</I>()<br ALIGN="LEFT"/><I>addTab</I>()<br ALIGN="LEFT"/><I>addWidget</I>()<br ALIGN="LEFT"/><I>connect</I>()<br ALIGN="LEFT"/><I>setMaximum</I>()<br ALIGN="LEFT"/><I>setMinimum</I>()<br ALIGN="LEFT"/><I>setObjectName</I>()<br ALIGN="LEFT"/><I>setText</I>()<br ALIGN="LEFT"/><I>setValue</I>()<br ALIGN="LEFT"/><I>start</I>()<br ALIGN="LEFT"/>timeout()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.core.analysis.cfg_explorer._MockNetworkX" [color="black", fontcolor="black", label=<{_MockNetworkX|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_numpy_fallback.NumpyFallback.random" [color="black", fontcolor="black", label=<{random|<br ALIGN="LEFT"/>|choice(a, size, p)<br ALIGN="LEFT"/>normal(loc, scale, size)<br ALIGN="LEFT"/>rand()<br ALIGN="LEFT"/>randint(low, high, size)<br ALIGN="LEFT"/>randn()<br ALIGN="LEFT"/>random(size)<br ALIGN="LEFT"/>uniform(low, high, size)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.import_checks.get_fallback_implementations.NumpyFallback.random" [color="black", fontcolor="black", label=<{random|<br ALIGN="LEFT"/>|choice(a, p)<br ALIGN="LEFT"/>normal(loc, scale)<br ALIGN="LEFT"/>uniform(low, high)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.utils.core.siphash24_replacement.siphash13" [color="black", fontcolor="black", label=<{siphash13|key : bytes<br ALIGN="LEFT"/>|digest()<br ALIGN="LEFT"/>hexdigest()<br ALIGN="LEFT"/>update(data)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"intellicrack.ai.ai_file_tools.FileApprovalDialog" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.lazy_model_loader.DefaultLoadingStrategy" -> "intellicrack.ai.lazy_model_loader.ModelLoadingStrategy" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.lazy_model_loader.SmartLoadingStrategy" -> "intellicrack.ai.lazy_model_loader.ModelLoadingStrategy" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.AnthropicBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.GPTQBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.HuggingFaceLocalBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.LlamaCppBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.LocalGGUFBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.ONNXLLMBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.OllamaBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.OpenAIBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.PyTorchLLMBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.SafetensorsBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.llm_backends.TensorFlowLLMBackend" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.model_manager_module.ONNXBackend" -> "intellicrack.ai.model_manager_module.ModelBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.model_manager_module.PyTorchBackend" -> "intellicrack.ai.model_manager_module.ModelBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.model_manager_module.SklearnBackend" -> "intellicrack.ai.model_manager_module.ModelBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.model_manager_module.TensorFlowBackend" -> "intellicrack.ai.model_manager_module.ModelBackend" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.multi_agent_system.DynamicAnalysisAgent" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.multi_agent_system.ReverseEngineeringAgent" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.multi_agent_system.StaticAnalysisAgent" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.predictive_intelligence.LinearRegressionModel" -> "intellicrack.ai.predictive_intelligence.PredictiveModel" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.anti_analysis.debugger_detector.DebuggerDetector" -> "intellicrack.core.anti_analysis.base_detector.BaseDetector" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector" -> "intellicrack.core.anti_analysis.base_detector.BaseDetector" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.anti_analysis.vm_detector.VMDetector" -> "intellicrack.core.anti_analysis.base_detector.BaseDetector" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.c2.c2_client.C2Client" -> "intellicrack.core.c2.base_c2.BaseC2" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.c2.c2_server.C2Server" -> "intellicrack.core.c2.base_c2.BaseC2" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.c2.communication_protocols.DnsProtocol" -> "intellicrack.core.c2.communication_protocols.BaseProtocol" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.c2.communication_protocols.HttpsProtocol" -> "intellicrack.core.c2.communication_protocols.BaseProtocol" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.c2.communication_protocols.TcpProtocol" -> "intellicrack.core.c2.communication_protocols.BaseProtocol" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.base_exploitation.BaseExploitation" -> "intellicrack.core.shared.result_utils.ResultMixin" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.credential_harvester.CredentialHarvester" -> "intellicrack.utils.system.os_detection_mixin.OSDetectionMixin" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.lateral_movement.ConcreteLateralMovement" -> "intellicrack.core.exploitation.lateral_movement.LateralMovement" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.lateral_movement.LateralMovement" -> "intellicrack.core.exploitation.base_exploitation.BaseExploitation" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.lateral_movement.LateralMovement" -> "intellicrack.core.exploitation.base_persistence.BasePersistence" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.linux_persistence.LinuxPersistence" -> "intellicrack.core.exploitation.base_persistence.BasePersistence" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.persistence_manager.PersistenceManager" -> "intellicrack.core.exploitation.base_persistence.BasePersistence" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.persistence_manager.PersistenceManager" -> "intellicrack.utils.system.os_detection_mixin.OSDetectionMixin" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation" -> "intellicrack.core.exploitation.base_exploitation.BaseExploitation" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation" -> "intellicrack.utils.system.os_detection_mixin.OSDetectionMixin" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence" -> "intellicrack.core.exploitation.base_persistence.BasePersistence" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.mitigation_bypass.aslr_bypass.ASLRBypass" -> "intellicrack.core.mitigation_bypass.bypass_base.MitigationBypassBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.mitigation_bypass.bypass_base.ROPBasedBypass" -> "intellicrack.core.mitigation_bypass.bypass_base.MitigationBypassBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.network.generic_protocol_handler.GenericProtocolHandler" -> "intellicrack.core.network.license_protocol_handler.LicenseProtocolHandler" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.network.license_protocol_handler.FlexLMProtocolHandler" -> "intellicrack.core.network.license_protocol_handler.LicenseProtocolHandler" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.network.license_protocol_handler.HASPProtocolHandler" -> "intellicrack.core.network.license_protocol_handler.LicenseProtocolHandler" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.network.traffic_analyzer.NetworkTrafficAnalyzer" -> "intellicrack.core.network.base_network_analyzer.BaseNetworkAnalyzer" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.network.traffic_interception_engine.TrafficInterceptionEngine" -> "intellicrack.core.network.base_network_analyzer.BaseNetworkAnalyzer" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.patching.early_bird_injection.EarlyBirdInjector" -> "intellicrack.core.patching.base_patcher.BaseWindowsPatcher" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.patching.process_hollowing.ProcessHollowing" -> "intellicrack.core.patching.base_patcher.BaseWindowsPatcher" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.processing.docker_container.DockerContainer" -> "intellicrack.core.processing.base_snapshot_handler.BaseSnapshotHandler" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.processing.gpu_accelerator.GPUAccelerator" -> "intellicrack.core.processing.gpu_accelerator.GPUAccelerationManager" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.processing.qemu_emulator.QEMUSystemEmulator" -> "intellicrack.core.processing.base_snapshot_handler.BaseSnapshotHandler" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.resources.resource_manager.ContainerResource" -> "intellicrack.core.resources.resource_manager.ManagedResource" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.resources.resource_manager.ProcessResource" -> "intellicrack.core.resources.resource_manager.ManagedResource" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.resources.resource_manager.VMResource" -> "intellicrack.core.resources.resource_manager.ManagedResource" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.task_manager.CallableTask" -> "intellicrack.core.task_manager.BaseTask" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.task_manager.LongRunningTask" -> "intellicrack.core.task_manager.BaseTask" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.vulnerability_research.base_analyzer.BaseAnalyzer" -> "intellicrack.core.shared.result_utils.ResultMixin" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.vulnerability_research.binary_differ.BinaryDiffer" -> "intellicrack.core.vulnerability_research.base_analyzer.BaseAnalyzer" [arrowhead="empty", arrowtail="none"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.VulnerabilityAnalyzer" -> "intellicrack.core.vulnerability_research.base_analyzer.BaseAnalyzer" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.advanced_search.AdvancedSearchDialog" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.advanced_search.FindAllDialog" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.advanced_search.ReplaceDialog" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.advanced_search.SearchThread" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.data_inspector.DataInspector" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.hex_commands.DeleteCommand" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.hex_commands.FillCommand" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.hex_commands.InsertCommand" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.hex_commands.PasteCommand" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.hex_commands.ReplaceCommand" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="empty", arrowtail="none"];
"intellicrack.hexview.performance_monitor.PerformanceWidget" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.model_manager.ProgressHandler" -> "intellicrack.models.repositories.interface.DownloadProgressCallback" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.anthropic_repository.AnthropicRepository" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.base.APIRepositoryBase" -> "intellicrack.models.repositories.interface.ModelRepositoryInterface" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.google_repository.GoogleRepository" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.lmstudio_repository.LMStudioRepository" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.local_repository.LocalFileRepository" -> "intellicrack.models.repositories.interface.ModelRepositoryInterface" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.openai_repository.OpenAIRepository" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.models.repositories.openrouter_repository.OpenRouterRepository" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.demo_plugin.DemoPlugin" -> "intellicrack.plugins.plugin_base.BasePlugin" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.HASPEmulator" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.SentinelEmulator" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.FridaPlugin" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AbstractPlugin" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.GhidraPlugin" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AbstractPlugin" [arrowhead="empty", arrowtail="none"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PythonPlugin" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AbstractPlugin" [arrowhead="empty", arrowtail="none"];
"intellicrack.protection.intellicrack_protection_advanced.AdvancedProtectionAnalysis" -> "intellicrack.protection.intellicrack_protection_core.ProtectionAnalysis" [arrowhead="empty", arrowtail="none"];
"intellicrack.protection.intellicrack_protection_advanced.IntellicrackAdvancedProtection" -> "intellicrack.protection.intellicrack_protection_core.IntellicrackProtectionCore" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.ai_integration.ClaudeAdapter" -> "intellicrack.scripts.cli.ai_integration.AIModelAdapter" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.ai_integration.OpenAIAdapter" -> "intellicrack.scripts.cli.ai_integration.AIModelAdapter" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.pipeline.AnalysisStage" -> "intellicrack.scripts.cli.pipeline.PipelineStage" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.pipeline.FilterStage" -> "intellicrack.scripts.cli.pipeline.PipelineStage" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.pipeline.OutputStage" -> "intellicrack.scripts.cli.pipeline.PipelineStage" [arrowhead="empty", arrowtail="none"];
"intellicrack.scripts.cli.pipeline.TransformStage" -> "intellicrack.scripts.cli.pipeline.PipelineStage" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.ci_cd_dialog.CICDDialog" -> "intellicrack.ui.dialogs.plugin_dialog_base.PluginDialogBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" -> "intellicrack.ui.dialogs.base_dialog.BinarySelectionDialog" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenWorker" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" -> "intellicrack.ui.dialogs.base_dialog.BaseTemplateDialog" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.report_manager_dialog.ReportManagerDialog" -> "intellicrack.ui.dialogs.base_dialog.BaseTemplateDialog" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" -> "intellicrack.ui.dialogs.base_dialog.BinarySelectionDialog" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorWorker" -> "intellicrack.ui.common_imports.MockQtClass" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.dialogs.test_generator_dialog.TestGeneratorDialog" -> "intellicrack.ui.dialogs.plugin_dialog_base.PluginDialogBase" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.main_app.IntellicrackApp" -> "intellicrack.ui.protection_detection_handlers.ProtectionDetectionHandlers" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.ai_assistant_tab.AIAssistantTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.analysis_tab.AnalysisTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.analysis_tab_original.AnalysisTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.dashboard_tab.DashboardTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.exploitation_tab.ExploitationTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.project_workspace_tab.DashboardTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.settings_tab.SettingsTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.tabs.tools_tab.ToolsTab" -> "intellicrack.ui.tabs.base_tab.BaseTab" [arrowhead="empty", arrowtail="none"];
"intellicrack.ui.widgets.pe_file_model.PEFileModel" -> "intellicrack.ui.widgets.pe_file_model.BinaryFileModel" [arrowhead="empty", arrowtail="none"];
"intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_assistant", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" -> "intellicrack.tools.protection_analyzer_tool.ProtectionAnalyzerTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_assistant", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_assistant", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" -> "intellicrack.ui.widgets.intellicrack_protection_widget.IntellicrackProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_assistant", style="solid"];
"intellicrack.ai.ai_assistant_enhanced.ToolCategory" -> "intellicrack.ai.ai_assistant_enhanced.Tool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="category", style="solid"];
"intellicrack.ai.ai_file_tools.AIFileTools" -> "intellicrack.ai.ai_assistant_enhanced.IntellicrackAIAssistant" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_tools", style="solid"];
"intellicrack.ai.ai_file_tools.AIFileTools" -> "intellicrack.tools.protection_analyzer_tool.ProtectionAnalyzerTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_file_tools", style="solid"];
"intellicrack.ai.ai_file_tools.AIFileTools" -> "intellicrack.ui.widgets.intellicrack_protection_widget.ProtectionAnalysisThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_file_tools", style="solid"];
"intellicrack.ai.ai_file_tools.FileReadTool" -> "intellicrack.ai.ai_file_tools.AIFileTools" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="read_tool", style="solid"];
"intellicrack.ai.ai_file_tools.FileSearchTool" -> "intellicrack.ai.ai_file_tools.AIFileTools" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_tool", style="solid"];
"intellicrack.ai.ai_script_generator.AIScriptGenerator" -> "intellicrack.ai.autonomous_agent.AutonomousAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_generator", style="solid"];
"intellicrack.ai.ai_script_generator.AIScriptGenerator" -> "intellicrack.ai.integration_manager.IntegrationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_generator", style="solid"];
"intellicrack.ai.ai_script_generator.AIScriptGenerator" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorWorker" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_generator", style="solid"];
"intellicrack.ai.ai_script_generator.PatternLibrary" -> "intellicrack.ai.ai_script_generator.AIScriptGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_library", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptMetadata" -> "intellicrack.ai.ai_script_generator.GeneratedScript" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="metadata", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptTemplateEngine" -> "intellicrack.ai.ai_script_generator.AIScriptGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="template_engine", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptType" -> "intellicrack.ai.ai_script_generator.ScriptMetadata" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_type", style="solid"];
"intellicrack.ai.ai_script_generator.ScriptValidator" -> "intellicrack.ai.ai_script_generator.AIScriptGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="validator", style="solid"];
"intellicrack.ai.ai_tools.AIAssistant" -> "intellicrack.ai.ai_tools.CodeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_assistant", style="solid"];
"intellicrack.ai.ai_tools.AIAssistant" -> "intellicrack.ui.widgets.intellicrack_protection_widget.IntellicrackProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_tools", style="solid"];
"intellicrack.ai.autonomous_agent.AutonomousAgent" -> "intellicrack.ai.integration_manager.IntegrationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="autonomous_agent", style="solid"];
"intellicrack.ai.autonomous_agent.TaskRequest" -> "intellicrack.ai.autonomous_agent.AutonomousAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="current_task", style="solid"];
"intellicrack.ai.autonomous_agent.TestEnvironment" -> "intellicrack.ai.autonomous_agent.TaskRequest" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="test_environment", style="solid"];
"intellicrack.ai.background_loader.BackgroundModelLoader" -> "intellicrack.ai.background_loader.IntegratedBackgroundLoader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="background_loader", style="solid"];
"intellicrack.ai.background_loader.IntegratedBackgroundLoader" -> "intellicrack.ai.llm_backends.LLMManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="background_loader", style="solid"];
"intellicrack.ai.background_loader.QueuedProgressCallback" -> "intellicrack.ui.widgets.model_loading_progress_widget.ModelLoadingProgressWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress_callback", style="solid"];
"intellicrack.ai.coordination_layer.AICoordinationLayer" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_coordinator", style="solid"];
"intellicrack.ai.coordination_layer.AnalysisStrategy" -> "intellicrack.ai.coordination_layer.AnalysisRequest" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy", style="solid"];
"intellicrack.ai.coordination_layer.AnalysisStrategy" -> "intellicrack.ai.coordination_layer.CoordinatedResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy_used", style="solid"];
"intellicrack.ai.enhanced_training_interface.DatasetAnalysisWidget" -> "intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dataset_tab", style="solid"];
"intellicrack.ai.enhanced_training_interface.HyperparameterOptimizationWidget" -> "intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hyperopt_tab", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingConfiguration" -> "intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingThread" -> "intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="training_thread", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingVisualizationWidget" -> "intellicrack.ai.enhanced_training_interface.EnhancedTrainingInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="viz_tab", style="solid"];
"intellicrack.ai.exploit_chain_builder.ChainComplexity" -> "intellicrack.ai.exploit_chain_builder.ExploitChain" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="complexity", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitChainFramework" -> "intellicrack.ai.exploit_chain_builder.AutomatedExploitChainBuilder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chain_framework", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitPrimitive" -> "intellicrack.ai.exploit_chain_builder.ExploitStep" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="step_type", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitPrimitiveLibrary" -> "intellicrack.ai.exploit_chain_builder.AutomatedExploitChainBuilder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="primitive_lib", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitPrimitiveLibrary" -> "intellicrack.ai.exploit_chain_builder.ExploitChainFramework" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="primitive_lib", style="solid"];
"intellicrack.ai.exploit_chain_builder.ExploitType" -> "intellicrack.ai.exploit_chain_builder.Vulnerability" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vuln_type", style="solid"];
"intellicrack.ai.exploit_chain_builder.SafetyVerificationSystem" -> "intellicrack.ai.exploit_chain_builder.AutomatedExploitChainBuilder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="safety_system", style="solid"];
"intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exploitation_orchestrator", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ChangeStatus" -> "intellicrack.ai.intelligent_code_modifier.CodeChange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="status", style="solid"];
"intellicrack.ai.intelligent_code_modifier.CodeAnalyzer" -> "intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analyzer", style="solid"];
"intellicrack.ai.intelligent_code_modifier.DiffGenerator" -> "intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="diff_generator", style="solid"];
"intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" -> "intellicrack.ai.integration_manager.IntegrationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="code_modifier", style="solid"];
"intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" -> "intellicrack.ui.dialogs.code_modification_dialog.CodeModificationDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="modifier", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ModificationType" -> "intellicrack.ai.intelligent_code_modifier.CodeChange" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="modification_type", style="solid"];
"intellicrack.ai.lazy_model_loader.DefaultLoadingStrategy" -> "intellicrack.ai.lazy_model_loader.LazyModelManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loading_strategy", style="solid"];
"intellicrack.ai.lazy_model_loader.LazyModelManager" -> "intellicrack.ai.llm_backends.LLMManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="lazy_manager", style="solid"];
"intellicrack.ai.learning_engine.AILearningDatabase" -> "intellicrack.ai.learning_engine.AILearningEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="database", style="solid"];
"intellicrack.ai.learning_engine.FailureAnalysisEngine" -> "intellicrack.ai.learning_engine.AILearningEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="failure_engine", style="solid"];
"intellicrack.ai.learning_engine.PatternEvolutionEngine" -> "intellicrack.ai.learning_engine.AILearningEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.predictive_intelligence.FeatureExtractor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.realtime_adaptation_engine.RealTimeAdaptationEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.resilience_self_healing.HealthMonitor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.resilience_self_healing.RecoverySystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.learning_engine_simple.AILearningEngine" -> "intellicrack.ai.visualization_analytics.DataCollector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="learning_engine", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.exploit_chain_builder.AutomatedExploitChainBuilder" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.integration_manager.IntegrationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.llm_fallback_chains.FallbackChain" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.multi_agent_system.MultiAgentSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.semantic_code_analyzer.SemanticCodeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.hexview.ai_bridge.AIBinaryBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.scripts.test_model_integration.ModelIntegrationValidator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ui.dialogs.code_modification_dialog.CodeModificationDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ui.dialogs.llm_config_dialog.LLMConfigDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ui.dialogs.model_loading_dialog.ModelLoadingDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ui.widgets.model_loading_progress_widget.ModelLoadingProgressWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMProvider" -> "intellicrack.ai.llm_backends.LLMConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="provider", style="solid"];
"intellicrack.ai.llm_config_manager.LLMConfigManager" -> "intellicrack.ui.dialogs.llm_config_dialog.LLMConfigDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_manager", style="solid"];
"intellicrack.ai.llm_fallback_chains.FailureType" -> "intellicrack.ai.llm_fallback_chains.FailureInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="failure_type", style="solid"];
"intellicrack.ai.llm_types.LoadingState" -> "intellicrack.ai.llm_types.LoadingProgress" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state", style="solid"];
"intellicrack.ai.local_gguf_server.LocalGGUFServer" -> "intellicrack.ai.local_gguf_server.GGUFModelManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server", style="solid"];
"intellicrack.ai.model_batch_tester.ModelBatchTester" -> "intellicrack.ai.model_comparison.ModelComparison" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_tester", style="solid"];
"intellicrack.ai.model_manager_module.ModelCache" -> "intellicrack.ai.model_manager_module.ModelManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ai.coordination_layer.AICoordinationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.model_performance_monitor.ModelPerformanceMonitor" -> "intellicrack.ai.model_batch_tester.ModelBatchTester" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance_monitor", style="solid"];
"intellicrack.ai.model_performance_monitor.ModelPerformanceMonitor" -> "intellicrack.ai.model_comparison.ModelComparison" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance_monitor", style="solid"];
"intellicrack.ai.model_sharding.ModelShardingManager" -> "intellicrack.ai.quantization_manager.QuantizationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sharding_manager", style="solid"];
"intellicrack.ai.model_sharding.ModelShardingManager" -> "intellicrack.ai.quantization_manager.QuantizationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sharding_manager", style="solid"];
"intellicrack.ai.multi_agent_system.KnowledgeManager" -> "intellicrack.ai.multi_agent_system.MultiAgentSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="knowledge_manager", style="solid"];
"intellicrack.ai.multi_agent_system.LoadBalancer" -> "intellicrack.ai.multi_agent_system.TaskDistributor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="load_balancer", style="solid"];
"intellicrack.ai.multi_agent_system.MessageRouter" -> "intellicrack.ai.multi_agent_system.MultiAgentSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="message_router", style="solid"];
"intellicrack.ai.multi_agent_system.MessageType" -> "intellicrack.ai.multi_agent_system.AgentMessage" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="message_type", style="solid"];
"intellicrack.ai.multi_agent_system.TaskDistributor" -> "intellicrack.ai.multi_agent_system.MultiAgentSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="task_distributor", style="solid"];
"intellicrack.ai.multi_agent_system.TaskPriority" -> "intellicrack.ai.multi_agent_system.AgentMessage" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="priority", style="solid"];
"intellicrack.ai.multi_agent_system.TaskPriority" -> "intellicrack.ai.multi_agent_system.AgentTask" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="priority", style="solid"];
"intellicrack.ai.optimization_config.CacheConfig" -> "intellicrack.ai.optimization_config.PerformanceConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_config", style="solid"];
"intellicrack.ai.optimization_config.PerformanceConfig" -> "intellicrack.ai.optimization_config.OptimizationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ai.orchestrator.AIEventBus" -> "intellicrack.ai.coordination_layer.AICoordinationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.ai.orchestrator.AIEventBus" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.ai.orchestrator.AIOrchestrator" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_orchestrator", style="solid"];
"intellicrack.ai.orchestrator.AISharedContext" -> "intellicrack.ai.coordination_layer.AICoordinationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="shared_context", style="solid"];
"intellicrack.ai.orchestrator.AISharedContext" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="shared_context", style="solid"];
"intellicrack.ai.orchestrator.AITaskType" -> "intellicrack.ai.orchestrator.AIResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="task_type", style="solid"];
"intellicrack.ai.orchestrator.AITaskType" -> "intellicrack.ai.orchestrator.AITask" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="task_type", style="solid"];
"intellicrack.ai.orchestrator.AnalysisComplexity" -> "intellicrack.ai.orchestrator.AITask" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="complexity", style="solid"];
"intellicrack.ai.pattern_library.ProtectionComplexity" -> "intellicrack.ai.pattern_library.ProtectionPattern" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="complexity", style="solid"];
"intellicrack.ai.performance_optimization_layer.CacheManager" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.ai.performance_optimization_layer.CacheManager" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.ai.performance_optimization_layer.OptimizationStrategy" -> "intellicrack.ai.performance_optimization_layer.OptimizationRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy", style="solid"];
"intellicrack.ai.performance_optimization_layer.ParallelExecutor" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="parallel_executor", style="solid"];
"intellicrack.ai.performance_optimization_layer.ParallelExecutor" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="parallel_executor", style="solid"];
"intellicrack.ai.performance_optimization_layer.PerformanceOptimizer" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimizer", style="solid"];
"intellicrack.ai.performance_optimization_layer.ResourceManager" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizationLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resource_manager", style="solid"];
"intellicrack.ai.performance_optimization_layer.ResourceManager" -> "intellicrack.ai.performance_optimization_layer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resource_manager", style="solid"];
"intellicrack.ai.predictive_intelligence.ExecutionTimePredictor" -> "intellicrack.ai.predictive_intelligence.PredictiveIntelligenceEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="time_predictor", style="solid"];
"intellicrack.ai.predictive_intelligence.FeatureExtractor" -> "intellicrack.ai.predictive_intelligence.ExecutionTimePredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="feature_extractor", style="solid"];
"intellicrack.ai.predictive_intelligence.FeatureExtractor" -> "intellicrack.ai.predictive_intelligence.SuccessProbabilityPredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="feature_extractor", style="solid"];
"intellicrack.ai.predictive_intelligence.FeatureExtractor" -> "intellicrack.ai.predictive_intelligence.VulnerabilityPredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="feature_extractor", style="solid"];
"intellicrack.ai.predictive_intelligence.LinearRegressionModel" -> "intellicrack.ai.predictive_intelligence.ExecutionTimePredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ai.predictive_intelligence.LinearRegressionModel" -> "intellicrack.ai.predictive_intelligence.SuccessProbabilityPredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ai.predictive_intelligence.LinearRegressionModel" -> "intellicrack.ai.predictive_intelligence.VulnerabilityPredictor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionConfidence" -> "intellicrack.ai.predictive_intelligence.PredictionResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="confidence", style="solid"];
"intellicrack.ai.predictive_intelligence.PredictionType" -> "intellicrack.ai.predictive_intelligence.PredictionResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="prediction_type", style="solid"];
"intellicrack.ai.predictive_intelligence.SuccessProbabilityPredictor" -> "intellicrack.ai.predictive_intelligence.PredictiveIntelligenceEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="success_predictor", style="solid"];
"intellicrack.ai.predictive_intelligence.VulnerabilityPredictor" -> "intellicrack.ai.predictive_intelligence.PredictiveIntelligenceEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_predictor", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUTestManager" -> "intellicrack.ai.autonomous_agent.AutonomousAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_manager", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUTestManager" -> "intellicrack.ai.integration_manager.IntegrationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_manager", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUTestManager" -> "intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUTestResultsDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_manager", style="solid"];
"intellicrack.ai.qemu_test_manager_enhanced.EnhancedQEMUTestManager" -> "intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_manager", style="solid"];
"intellicrack.ai.quantization_manager.QuantizationManager" -> "intellicrack.ai.llm_backends.PyTorchLLMBackend" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="quantization_manager", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AdaptationType" -> "intellicrack.ai.realtime_adaptation_engine.AdaptationEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adaptation_type", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.AdaptationType" -> "intellicrack.ai.realtime_adaptation_engine.AdaptationRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adaptation_type", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.DynamicHookManager" -> "intellicrack.ai.realtime_adaptation_engine.RealTimeAdaptationEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hook_manager", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.LiveDebuggingSystem" -> "intellicrack.ai.realtime_adaptation_engine.RealTimeAdaptationEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="debug_system", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.RuntimeMonitor" -> "intellicrack.ai.realtime_adaptation_engine.RealTimeAdaptationEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="runtime_monitor", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.TriggerCondition" -> "intellicrack.ai.realtime_adaptation_engine.AdaptationEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="trigger_condition", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.TriggerCondition" -> "intellicrack.ai.realtime_adaptation_engine.AdaptationRule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="condition", style="solid"];
"intellicrack.ai.resilience_self_healing.FailureType" -> "intellicrack.ai.resilience_self_healing.FailureEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="failure_type", style="solid"];
"intellicrack.ai.resilience_self_healing.HealthMonitor" -> "intellicrack.ai.resilience_self_healing.ResilienceSelfHealingSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="health_monitor", style="solid"];
"intellicrack.ai.resilience_self_healing.HealthStatus" -> "intellicrack.ai.resilience_self_healing.SystemState" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="health_status", style="solid"];
"intellicrack.ai.resilience_self_healing.RecoveryStrategy" -> "intellicrack.ai.resilience_self_healing.RecoveryAction" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy", style="solid"];
"intellicrack.ai.resilience_self_healing.RecoverySystem" -> "intellicrack.ai.resilience_self_healing.ResilienceSelfHealingSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="recovery_system", style="solid"];
"intellicrack.ai.resilience_self_healing.StateManager" -> "intellicrack.ai.resilience_self_healing.ResilienceSelfHealingSystem" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="state_manager", style="solid"];
"intellicrack.ai.script_templates.FridaTemplates" -> "intellicrack.ai.script_templates.ScriptTemplateEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="frida_templates", style="solid"];
"intellicrack.ai.script_templates.GhidraTemplates" -> "intellicrack.ai.script_templates.ScriptTemplateEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ghidra_templates", style="solid"];
"intellicrack.ai.semantic_code_analyzer.NLPCodeProcessor" -> "intellicrack.ai.semantic_code_analyzer.SemanticCodeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="nlp_processor", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticIntent" -> "intellicrack.ai.semantic_code_analyzer.IntentMismatch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="expected_intent", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticIntent" -> "intellicrack.ai.semantic_code_analyzer.SemanticNode" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="semantic_intent", style="solid"];
"intellicrack.ai.semantic_code_analyzer.SemanticKnowledgeBase" -> "intellicrack.ai.semantic_code_analyzer.SemanticCodeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="semantic_kb", style="solid"];
"intellicrack.ai.visualization_analytics.AnalyticsEngine" -> "intellicrack.ai.visualization_analytics.VisualizationAnalytics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analytics_engine", style="solid"];
"intellicrack.ai.visualization_analytics.ChartGenerator" -> "intellicrack.ai.visualization_analytics.DashboardManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chart_generator", style="solid"];
"intellicrack.ai.visualization_analytics.ChartType" -> "intellicrack.ai.visualization_analytics.ChartData" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chart_type", style="solid"];
"intellicrack.ai.visualization_analytics.DashboardManager" -> "intellicrack.ai.visualization_analytics.VisualizationAnalytics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dashboard_manager", style="solid"];
"intellicrack.ai.visualization_analytics.DataCollector" -> "intellicrack.ai.visualization_analytics.VisualizationAnalytics" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="data_collector", style="solid"];
"intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vuln_research_ai", style="solid"];
"intellicrack.config.ConfigManager" -> "intellicrack.ai.llm_config_manager.LLMConfigManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_manager", style="solid"];
"intellicrack.config.ConfigManager" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.core.ai_model_manager.ModelProvider" -> "intellicrack.core.ai_model_manager.ModelConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="provider", style="solid"];
"intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" -> "intellicrack.ui.tabs.analysis_tab_original.AnalysisTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_orchestrator", style="solid"];
"intellicrack.core.analysis.binary_analyzer.BinaryAnalyzer" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="binary_analyzer", style="solid"];
"intellicrack.core.analysis.binary_similarity_search.BinarySimilaritySearch" -> "intellicrack.ui.dialogs.similarity_search_dialog.BinarySimilaritySearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_engine", style="solid"];
"intellicrack.core.analysis.cfg_explorer._MockNetworkX.DiGraph" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="call_graph", style="solid"];
"intellicrack.core.analysis.dynamic_analyzer.AdvancedDynamicAnalyzer" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamic_analyzer", style="solid"];
"intellicrack.core.analysis.dynamic_analyzer.AdvancedDynamicAnalyzer" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dynamic_analyzer", style="solid"];
"intellicrack.core.analysis.entropy_analyzer.EntropyAnalyzer" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entropy_analyzer", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.FirmwareType" -> "intellicrack.core.analysis.firmware_analyzer.FirmwareAnalysisResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="firmware_type", style="solid"];
"intellicrack.core.analysis.firmware_analyzer.SecurityFindingType" -> "intellicrack.core.analysis.firmware_analyzer.SecurityFinding" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="finding_type", style="solid"];
"intellicrack.core.analysis.ghidra_decompiler.GhidraDecompiler" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ghidra_decompiler", style="solid"];
"intellicrack.core.analysis.multi_format_analyzer.MultiFormatBinaryAnalyzer" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="binary_analyzer", style="solid"];
"intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_engine", style="solid"];
"intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" -> "intellicrack.core.analysis.radare2_bypass_generator.R2BypassGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ai_engine", style="solid"];
"intellicrack.core.analysis.radare2_decompiler.R2DecompilationEngine" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decompiler", style="solid"];
"intellicrack.core.analysis.radare2_decompiler.R2DecompilationEngine" -> "intellicrack.core.analysis.radare2_bypass_generator.R2BypassGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decompiler", style="solid"];
"intellicrack.core.analysis.radare2_decompiler.R2DecompilationEngine" -> "intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="decompiler", style="solid"];
"intellicrack.core.analysis.radare2_enhanced_integration.Radare2EnhancedIntegration" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="radare2", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.ErrorSeverity" -> "intellicrack.core.analysis.radare2_error_handler.ErrorEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="severity", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.RecoveryStrategy" -> "intellicrack.core.analysis.radare2_error_handler.ErrorEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="recovery_strategy", style="solid"];
"intellicrack.core.analysis.radare2_esil.ESILAnalysisEngine" -> "intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="esil_engine", style="solid"];
"intellicrack.core.analysis.radare2_imports.R2ImportExportAnalyzer" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="import_analyzer", style="solid"];
"intellicrack.core.analysis.radare2_imports.R2ImportExportAnalyzer" -> "intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="import_analyzer", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.AnalysisLevel" -> "intellicrack.core.analysis.radare2_performance_optimizer.PerformanceProfile" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_level", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.R2PerformanceOptimizer" -> "intellicrack.core.analysis.radare2_realtime_analyzer.R2RealtimeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance_optimizer", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.AnalysisEvent" -> "intellicrack.core.analysis.radare2_realtime_analyzer.AnalysisUpdate" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_type", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.BinaryFileWatcher" -> "intellicrack.core.analysis.radare2_realtime_analyzer.R2RealtimeAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_watcher", style="solid"];
"intellicrack.core.analysis.radare2_scripting.R2ScriptingEngine" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scripting_engine", style="solid"];
"intellicrack.core.analysis.radare2_strings.R2StringAnalyzer" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="string_analyzer", style="solid"];
"intellicrack.core.analysis.radare2_strings.R2StringAnalyzer" -> "intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="string_analyzer", style="solid"];
"intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" -> "intellicrack.core.analysis.cfg_explorer.CFGExplorer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_engine", style="solid"];
"intellicrack.core.analysis.radare2_vulnerability_engine.R2VulnerabilityEngine" -> "intellicrack.core.analysis.radare2_bypass_generator.R2BypassGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_engine", style="solid"];
"intellicrack.core.analysis.vulnerability_engine.AdvancedVulnerabilityEngine" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_engine", style="solid"];
"intellicrack.core.analysis.vulnerability_engine.AdvancedVulnerabilityEngine" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_engine", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.PatternCategory" -> "intellicrack.core.analysis.yara_pattern_engine.YaraMatch" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="category", style="solid"];
"intellicrack.core.analysis.yara_pattern_engine.YaraPatternEngine" -> "intellicrack.core.analysis.analysis_orchestrator.AnalysisOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="yara_engine", style="solid"];
"intellicrack.core.anti_analysis.api_obfuscation.APIObfuscator" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="api_obfuscator", style="solid"];
"intellicrack.core.anti_analysis.debugger_detector.DebuggerDetector" -> "intellicrack.core.anti_analysis.AntiAnalysisEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="debugger_detector", style="solid"];
"intellicrack.core.anti_analysis.debugger_detector.DebuggerDetector" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="debugger_detector", style="solid"];
"intellicrack.core.anti_analysis.process_hollowing.ProcessHollowing" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="process_hollowing", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector" -> "intellicrack.core.anti_analysis.AntiAnalysisEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sandbox_detector", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sandbox_detector", style="solid"];
"intellicrack.core.anti_analysis.timing_attacks.TimingAttackDefense" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="timing_defense", style="solid"];
"intellicrack.core.anti_analysis.vm_detector.VMDetector" -> "intellicrack.core.anti_analysis.AntiAnalysisEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vm_detector", style="solid"];
"intellicrack.core.anti_analysis.vm_detector.VMDetector" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vm_detector", style="solid"];
"intellicrack.core.app_context.AppContext" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="app_context", style="solid"];
"intellicrack.core.c2.c2_manager.C2Manager" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="c2_manager", style="solid"];
"intellicrack.core.c2.c2_manager.C2Manager" -> "intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="c2_manager", style="solid"];
"intellicrack.core.c2.c2_server.C2Server" -> "intellicrack.core.c2.c2_manager.C2Manager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server", style="solid"];
"intellicrack.core.c2.c2_server.C2Server" -> "intellicrack.ui.dialogs.c2_management_dialog.C2ServerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server", style="solid"];
"intellicrack.core.config.external_tools_config.ToolCategory" -> "intellicrack.core.config.external_tools_config.ExternalTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="category", style="solid"];
"intellicrack.core.config.external_tools_config.ToolStatus" -> "intellicrack.core.config.external_tools_config.ExternalTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="status", style="solid"];
"intellicrack.core.config_manager.IntellicrackConfig" -> "intellicrack.config.ConfigManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_modern_config", style="solid"];
"intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" -> "intellicrack.ui.dialogs.ai_coding_assistant_dialog.AICodingAssistantDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_execution_manager", style="solid"];
"intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" -> "intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_execution_manager", style="solid"];
"intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_execution_manager", style="solid"];
"intellicrack.core.exploitation.assembly_compiler.AssemblyCompiler" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="assembly_compiler", style="solid"];
"intellicrack.core.exploitation.cfi_bypass.CFIBypass" -> "intellicrack.core.mitigation_bypass.BypassEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cfi_bypass", style="solid"];
"intellicrack.core.exploitation.encoder_engine.EncoderEngine" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="encoder_engine", style="solid"];
"intellicrack.core.exploitation.encoder_engine.EncoderEngine" -> "intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="encoder_engine", style="solid"];
"intellicrack.core.exploitation.lateral_movement.ConcreteLateralMovement" -> "intellicrack.core.exploitation.lateral_movement.LateralMovementManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="movement_engine", style="solid"];
"intellicrack.core.exploitation.linux_persistence.LinuxPersistence" -> "intellicrack.core.exploitation.persistence_manager.PersistenceManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="linux_handler", style="solid"];
"intellicrack.core.exploitation.payload_engine.PayloadEngine" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="payload_engine", style="solid"];
"intellicrack.core.exploitation.payload_engine.PayloadEngine" -> "intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="payload_engine", style="solid"];
"intellicrack.core.exploitation.payload_engine.PayloadEngine" -> "intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="payload_engine", style="solid"];
"intellicrack.core.exploitation.payload_templates.PayloadTemplates" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_payload_templates", style="solid"];
"intellicrack.core.exploitation.payload_templates.PayloadTemplates" -> "intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="template_engine", style="solid"];
"intellicrack.core.exploitation.persistence_manager.PersistenceManager" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="persistence_manager", style="solid"];
"intellicrack.core.exploitation.persistence_manager.PersistenceManager" -> "intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="persistence_manager", style="solid"];
"intellicrack.core.exploitation.polymorphic_engine.PolymorphicEngine" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="polymorphic_engine", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalation" -> "intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalationManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="escalation_engine", style="solid"];
"intellicrack.core.exploitation.privilege_escalation.PrivilegeEscalationManager" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="privesc_manager", style="solid"];
"intellicrack.core.exploitation.shellcode_generator.ShellcodeGenerator" -> "intellicrack.core.exploitation.payload_engine.PayloadEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_shellcode_generator", style="solid"];
"intellicrack.core.exploitation.windows_persistence.WindowsPersistence" -> "intellicrack.core.exploitation.persistence_manager.PersistenceManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="windows_handler", style="solid"];
"intellicrack.core.frida_manager.FridaOperationLogger" -> "intellicrack.core.frida_manager.FridaManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logger", style="solid"];
"intellicrack.core.frida_manager.FridaPerformanceOptimizer" -> "intellicrack.core.frida_manager.FridaManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimizer", style="solid"];
"intellicrack.core.frida_manager.HookBatcher" -> "intellicrack.core.frida_manager.FridaManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batcher", style="solid"];
"intellicrack.core.frida_manager.ProtectionDetector" -> "intellicrack.core.frida_manager.FridaManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="detector", style="solid"];
"intellicrack.core.logging.audit_logger.AuditLogger" -> "intellicrack.ai.autonomous_agent.AutonomousAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_audit_logger", style="solid"];
"intellicrack.core.logging.audit_logger.PerformanceMonitor" -> "intellicrack.core.logging.audit_logger.TelemetryCollector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance_monitor", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.core.c2.communication_protocols.DnsProtocol" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="socket", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.core.c2.communication_protocols.DnsProtocol" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="socket", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.core.exploitation.lateral_movement.LateralMovement._linux_docker_api.UnixHTTPConnection" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sock", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dns_socket", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.plugins.custom_modules.license_server_emulator.FlexLMEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server_socket", style="solid"];
"intellicrack.core.network.cloud_license_hooker.CloudLicenseResponseGenerator._setup_cross_platform_hooks.HookedSocket" -> "intellicrack.ui.main_app._check_intercepted_traffic.run_network_license_server.SimpleLicenseServer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server_socket", style="solid"];
"intellicrack.core.network.dynamic_response_generator.DynamicResponseGenerator" -> "intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="response_generator", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator._start_ssl_interceptor.SSLInterceptor" -> "intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ssl_interceptor", style="solid"];
"intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator._start_traffic_recorder.TrafficRecorder" -> "intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="traffic_recorder", style="solid"];
"intellicrack.core.network.traffic_analyzer.NetworkTrafficAnalyzer" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="traffic_analyzer", style="solid"];
"intellicrack.core.network.traffic_interception_engine.InterceptedPacket" -> "intellicrack.core.network.traffic_interception_engine.AnalyzedTraffic" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="packet", style="solid"];
"intellicrack.core.network.traffic_interception_engine.TrafficInterceptionEngine" -> "intellicrack.core.network.license_server_emulator.NetworkLicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="traffic_engine", style="solid"];
"intellicrack.core.processing.gpu_accelerator.GPUAccelerator" -> "intellicrack.scripts.cli.main.IntellicrackCLI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="gpu", style="solid"];
"intellicrack.core.processing.qemu_emulator.QEMUSystemEmulator" -> "intellicrack.ai.qemu_test_manager.QEMUTestManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_emulator", style="solid"];
"intellicrack.core.processing.sandbox_manager.AnalysisDepth" -> "intellicrack.core.processing.sandbox_manager.SandboxConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_depth", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxType" -> "intellicrack.core.processing.sandbox_manager.SandboxConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sandbox_type", style="solid"];
"intellicrack.core.processing.sandbox_manager.SandboxType" -> "intellicrack.core.processing.sandbox_manager.SandboxResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sandbox_type", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceManager" -> "intellicrack.ai.autonomous_agent.AutonomousAgent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_resource_manager", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceUsage" -> "intellicrack.core.resources.resource_manager.ManagedResource" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="usage", style="solid"];
"intellicrack.core.security_enforcement._monkey_patch_subprocess.SecurePopen" -> "intellicrack.core.network.ssl_interceptor.SSLTLSInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="proxy_process", style="solid"];
"intellicrack.core.security_enforcement._monkey_patch_subprocess.SecurePopen" -> "intellicrack.core.processing.qemu_emulator.QEMUSystemEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="qemu_process", style="solid"];
"intellicrack.core.shared.result_types.AnalysisType" -> "intellicrack.core.shared.result_types.AnalysisResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_type", style="solid"];
"intellicrack.core.task_manager.TaskManager" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="task_manager", style="solid"];
"intellicrack.core.vulnerability_research.binary_differ.BinaryDiffer" -> "intellicrack.core.vulnerability_research.research_manager.ResearchManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="binary_differ", style="solid"];
"intellicrack.core.vulnerability_research.fuzzing_engine.FuzzingEngine" -> "intellicrack.core.vulnerability_research.research_manager.ResearchManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fuzzing_engine", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.ResearchManager" -> "intellicrack.ai.exploitation_orchestrator.ExploitationOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="research_manager", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.ResearchManager" -> "intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="research_manager", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.ResearchManager" -> "intellicrack.ui.dialogs.vulnerability_research_dialog.ResearchWorkerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="research_manager", style="solid"];
"intellicrack.core.vulnerability_research.research_manager.ResearchManager" -> "intellicrack.ui.dialogs.vulnerability_research_dialog.VulnerabilityResearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="research_manager", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.VulnerabilityAnalyzer" -> "intellicrack.ai.vulnerability_research_integration.VulnerabilityResearchAI" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_analyzer", style="solid"];
"intellicrack.core.vulnerability_research.vulnerability_analyzer.VulnerabilityAnalyzer" -> "intellicrack.core.vulnerability_research.research_manager.ResearchManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_analyzer", style="solid"];
"intellicrack.hexview.advanced_search.SearchHistory" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_history", style="solid"];
"intellicrack.hexview.advanced_search.SearchThread" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="current_search_thread", style="solid"];
"intellicrack.hexview.ai_bridge.AIBinaryBridge" -> "intellicrack.ai.orchestrator.AIOrchestrator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_bridge", style="solid"];
"intellicrack.hexview.ai_bridge.BinaryContextBuilder" -> "intellicrack.hexview.ai_bridge.AIBinaryBridge" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="context_builder", style="solid"];
"intellicrack.hexview.file_handler.ChunkManager" -> "intellicrack.hexview.file_handler.VirtualFileAccess" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chunk_manager", style="solid"];
"intellicrack.hexview.file_handler.ChunkManager" -> "intellicrack.hexview.file_handler.VirtualFileAccess" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chunk_manager", style="solid"];
"intellicrack.hexview.file_handler.LRUCache" -> "intellicrack.hexview.file_handler.ChunkManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="active_chunks", style="solid"];
"intellicrack.hexview.file_handler.VirtualFileAccess" -> "intellicrack.hexview.hex_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_handler", style="solid"];
"intellicrack.hexview.hex_highlighter.HexHighlighter" -> "intellicrack.hexview.hex_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.hexview.hex_renderer.HexViewRenderer" -> "intellicrack.hexview.hex_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="renderer", style="solid"];
"intellicrack.hexview.hex_widget.HexViewerWidget" -> "intellicrack.hexview.hex_dialog.HexViewerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_viewer", style="solid"];
"intellicrack.hexview.hex_widget.HexViewerWidget" -> "intellicrack.ui.tabs.analysis_tab.AnalysisTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="embedded_hex_viewer", style="solid"];
"intellicrack.hexview.hex_widget.HexViewerWidget" -> "intellicrack.ui.tabs.analysis_tab_original.AnalysisTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="embedded_hex_viewer", style="solid"];
"intellicrack.hexview.intellicrack_hex_protection_integration.IntellicrackHexProtectionIntegration" -> "intellicrack.hexview.intellicrack_hex_protection_integration.ProtectionIntegrationWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="integration", style="solid"];
"intellicrack.hexview.large_file_handler.BackgroundLoader" -> "intellicrack.hexview.large_file_handler.LargeFileHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="background_loader", style="solid"];
"intellicrack.hexview.large_file_handler.FileCache" -> "intellicrack.hexview.large_file_handler.LargeFileHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.hexview.large_file_handler.LargeFileHandler" -> "intellicrack.hexview.file_handler.VirtualFileAccess" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="large_file_handler", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryConfig" -> "intellicrack.hexview.large_file_handler.LargeFileHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryMonitor" -> "intellicrack.hexview.large_file_handler.LargeFileHandler" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_monitor", style="solid"];
"intellicrack.hexview.performance_monitor.PerformanceMonitor" -> "intellicrack.hexview.hex_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="performance_monitor", style="solid"];
"intellicrack.hexview.performance_monitor.PerformanceWidget" -> "intellicrack.hexview.performance_monitor.PerformanceMonitor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="widget", style="solid"];
"intellicrack.models.protection_knowledge_base.BypassDifficulty" -> "intellicrack.models.protection_knowledge_base.BypassTechnique" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="difficulty", style="solid"];
"intellicrack.models.protection_knowledge_base.BypassDifficulty" -> "intellicrack.models.protection_knowledge_base.ProtectionSchemeInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bypass_difficulty", style="solid"];
"intellicrack.models.protection_knowledge_base.ProtectionCategory" -> "intellicrack.models.protection_knowledge_base.ProtectionSchemeInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="category", style="solid"];
"intellicrack.models.protection_knowledge_base.ProtectionKnowledgeBase" -> "intellicrack.ai.protection_aware_script_gen.ProtectionAwareScriptGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="kb", style="solid"];
"intellicrack.models.repositories.base.CacheManager" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.models.repositories.base.RateLimitConfig" -> "intellicrack.models.repositories.base.RateLimiter" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.models.repositories.base.RateLimiter" -> "intellicrack.models.repositories.base.APIRepositoryBase" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="rate_limiter", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestAntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="anti_debug", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="anti_debug", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiDebugTechnique" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="technique", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.BypassResult" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="result", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.EnvironmentSanitizer" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="env_sanitizer", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.ExceptionHandler" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exception_handler", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.HardwareDebugProtector" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hw_protector", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.MemoryPatcher" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_patcher", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.PEBManipulator" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="peb_manipulator", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.TargetAnalyzer" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="target_analyzer", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.TimingNormalizer" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="timing_normalizer", style="solid"];
"intellicrack.plugins.custom_modules.anti_anti_debug_suite.WindowsAPIHooker" -> "intellicrack.plugins.custom_modules.anti_anti_debug_suite.AntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="api_hooker", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationManager" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="auth_manager", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationType" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="auth_type", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationType" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="auth_type", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassResult" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="result", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CacheManager" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CertificateManager" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cert_manager", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudProvider" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="provider", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudProvider" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="provider", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.InterceptorConfig" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.LocalLicenseServer" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="local_server", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestClassifier" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="request_classifier", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestType" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.BypassOperation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="request_type", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestType" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.RequestInfo" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="request_type", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.ResponseModifier" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CloudLicenseInterceptor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="response_modifier", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.CryptoEngine" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleAPIHooker" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="api_hooker", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleInterface" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleSpec" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interface", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleMemory" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleRegistryManager" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="registry_manager", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleType" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleSpec" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dongle_type", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestHardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="emulator", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dongle_emulator", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.ParallelPortEmulator" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="lpt_emulator", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.USBDongleDriver" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.HardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="usb_driver", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.AnalysisCoordinator" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_coordinator", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ComponentType" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginMetadata" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="component_type", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ConfigurationManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventBus" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventPriority" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.Event" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="priority", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="core_engine", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.LoggingManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="logging_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="plugin_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.ResourceManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resource_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowEngine" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.IntellicrackcoreEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="workflow_engine", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.AdobeEmulator" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adobe", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.DatabaseManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="db_manager", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.FlexLMEmulator" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="flexlm", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.HASPEmulator" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hasp", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.HardwareFingerprintGenerator" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fingerprint_gen", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.MicrosoftKMSEmulator" -> "intellicrack.plugins.custom_modules.license_server_emulator.LicenseServerEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="kms", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.AdaptiveOptimizer" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adaptive_optimizer", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.CacheManager" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.DatabaseOptimizer" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="db_optimizer", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.GPUOptimizer" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="gpu_optimizer", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.IOOptimizer" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="io_optimizer", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_pool", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_pool", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_pool", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_pool", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.MemoryPool" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_pool", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.OptimizationType" -> "intellicrack.plugins.custom_modules.performance_optimizer.OptimizationResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimization_type", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceLevel" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimization_level", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.PerformanceProfiler" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="profiler", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.ResourceType" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceMetric" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="resource_type", style="solid"];
"intellicrack.plugins.custom_modules.performance_optimizer.ThreadPoolOptimizer" -> "intellicrack.plugins.custom_modules.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="thread_optimizer", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.BayesianAnalyzer" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bayesian_analyzer", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.EventTracker" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_tracker", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.EventType" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.AnalysisEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="event_type", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.MLPredictor" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ml_predictor", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.OutcomeType" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.AnalysisEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="outcome", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.ProtectionCategory" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.AnalysisEvent" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="protection_category", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.ProtectionCategory" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.TrendAnalysis" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="protection_category", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.ReportGenerator" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="report_generator", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.SurvivalAnalyzer" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="survival_analyzer", style="solid"];
"intellicrack.plugins.custom_modules.success_rate_analyzer.TimeSeriesAnalyzer" -> "intellicrack.plugins.custom_modules.success_rate_analyzer.SuccessRateAnalyzer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="time_series_analyzer", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestAntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestHardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestModuleIntegration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestNeuralNetworkDetector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestPerformanceBenchmarks" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestProtectionClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestSecurityValidation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.PerformanceMonitor" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestVMProtectionUnwrapper" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestCategory" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="category", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestDataGenerator" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="data_generator", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestAntiAntiDebugSuite" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestHardwareDongleEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestModuleIntegration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestNeuralNetworkDetector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestPerformanceBenchmarks" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestProtectionClassifier" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestSecurityValidation" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestFixtures" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestVMProtectionUnwrapper" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="fixtures", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestPriority" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="priority", style="solid"];
"intellicrack.plugins.custom_modules.test_suite_comprehensive.TestStatus" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="status", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisViewerPanel" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_viewer", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.FileExplorerPanel" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_explorer", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.LogViewer" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_viewer", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.ProgressTracker" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress_tracker", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.RealTimeChart" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisViewerPanel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chart", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.ScriptGeneratorPanel" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_generator", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UITheme" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="theme", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMAnalyzer" -> "intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMProtectionUnwrapper" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analyzer", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMContext" -> "intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMEmulator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="context", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMInstructionType" -> "intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMInstruction" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vm_type", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMProtectionUnwrapper" -> "intellicrack.plugins.custom_modules.test_suite_comprehensive.TestVMProtectionUnwrapper" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unwrapper", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMProtectionUnwrapper" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.UIEnhancementModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vm_unwrapper", style="solid"];
"intellicrack.plugins.plugin_base.PluginConfigManager" -> "intellicrack.plugins.plugin_base.BasePlugin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_manager", style="solid"];
"intellicrack.protection.analysis_cache.AnalysisCache" -> "intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.protection.analysis_cache.AnalysisCache" -> "intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.protection.analysis_cache.AnalysisCache" -> "intellicrack.ui.widgets.cache_management_widget.CacheManagementWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.protection.analysis_cache.CacheStats" -> "intellicrack.protection.analysis_cache.AnalysisCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stats", style="solid"];
"intellicrack.protection.analysis_cache.CacheStats" -> "intellicrack.protection.analysis_cache.AnalysisCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stats", style="solid"];
"intellicrack.protection.analysis_cache.CacheStats" -> "intellicrack.protection.analysis_cache.AnalysisCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stats", style="solid"];
"intellicrack.protection.analysis_cache.CacheStats" -> "intellicrack.protection.analysis_cache.AnalysisCache" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_stats", style="solid"];
"intellicrack.protection.icp_backend.ICPBackend" -> "intellicrack.protection.intellicrack_protection_core.IntellicrackProtectionCore" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="icp_backend", style="solid"];
"intellicrack.protection.icp_backend.ICPBackend" -> "intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_backend", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.IntellicrackAdvancedProtection" -> "intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="protection_detector", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.IntellicrackAdvancedProtection" -> "intellicrack.ui.widgets.intellicrack_advanced_protection_widget.AdvancedAnalysisThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="detector", style="solid"];
"intellicrack.protection.intellicrack_protection_core.IntellicrackProtectionCore" -> "intellicrack.hexview.intellicrack_hex_protection_integration.IntellicrackHexProtectionIntegration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="protection_detector", style="solid"];
"intellicrack.protection.intellicrack_protection_core.IntellicrackProtectionCore" -> "intellicrack.ui.widgets.intellicrack_protection_widget.ProtectionAnalysisThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="detector", style="solid"];
"intellicrack.protection.intellicrack_protection_core.ProtectionType" -> "intellicrack.protection.intellicrack_protection_core.DetectionResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"intellicrack.protection.protection_detector.ProtectionDetector" -> "intellicrack.tools.protection_analyzer_tool.ProtectionAnalyzerTool" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="detector", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.ai.protection_aware_script_gen.ProtectionAwareScriptGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unified_engine", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.protection.protection_detector.ProtectionDetector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="engine", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.ui.dialogs.signature_editor_dialog.SignatureTestWorker" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unified_engine", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisWorker" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="unified_engine", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.ui.widgets.cache_management_widget.CacheManagementWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="engine", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionEngine" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedAnalysisThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="engine", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.ActionType" -> "intellicrack.scripts.cli.ai_wrapper.PendingAction" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="action_type", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.ConfirmationManager" -> "intellicrack.scripts.cli.ai_integration.IntellicrackAIServer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="confirmation_manager", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.ConfirmationManager" -> "intellicrack.scripts.cli.ai_wrapper.IntellicrackAIInterface" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="confirmation_manager", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.IntellicrackAIInterface" -> "intellicrack.scripts.cli.ai_integration.IntellicrackAIServer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="interface", style="solid"];
"intellicrack.scripts.cli.config_manager.ConfigManager" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_config_manager", style="solid"];
"intellicrack.scripts.cli.interactive_mode.AdvancedProgressManager" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress_manager", style="solid"];
"intellicrack.scripts.cli.progress_manager.ProgressManager" -> "intellicrack.scripts.cli.enhanced_runner.EnhancedCLIRunner" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress_manager", style="solid"];
"intellicrack.scripts.cli.project_manager.ProjectManager" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_project_manager", style="solid"];
"intellicrack.scripts.cli.project_manager.ProjectManager" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_project_manager", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.AnalysisStats" -> "intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_stats", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.SessionInfo" -> "intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="session_info", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.SystemMetrics" -> "intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="system_metrics", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_dashboard", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_dashboard", style="solid"];
"intellicrack.scripts.cli.terminal_dashboard.TerminalDashboard" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_dashboard", style="solid"];
"intellicrack.scripts.cli.tutorial_system.TutorialSystem" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_tutorial_system", style="solid"];
"intellicrack.tools.plugin_ci_cd.CICDPipeline" -> "intellicrack.ui.dialogs.ci_cd_dialog.PipelineThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pipeline", style="solid"];
"intellicrack.tools.plugin_debugger.BreakpointType" -> "intellicrack.tools.plugin_debugger.Breakpoint" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="type", style="solid"];
"intellicrack.tools.plugin_debugger.DebuggerThread" -> "intellicrack.ui.dialogs.debugger_dialog.DebuggerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="debugger_thread", style="solid"];
"intellicrack.tools.plugin_debugger.PluginDebugger" -> "intellicrack.ui.dialogs.debugger_dialog.DebuggerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="debugger", style="solid"];
"intellicrack.tools.plugin_test_generator.MockDataGenerator" -> "intellicrack.ui.dialogs.test_generator_dialog.TestGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="mock_generator", style="solid"];
"intellicrack.tools.plugin_test_generator.PluginTestGenerator" -> "intellicrack.ui.dialogs.test_generator_dialog.TestGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generator", style="solid"];
"intellicrack.tools.plugin_test_generator.PluginTestRunner" -> "intellicrack.ui.dialogs.test_generator_dialog.TestGenerationThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="runner", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ai.ai_file_tools.FileApprovalDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="approve_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ai.ai_file_tools.FileApprovalDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="deny_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_pattern_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_type_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="case_sensitive_check", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="whole_words_check", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="direction_group", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="forward_radio", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="backward_radio", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_next_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_previous_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_status_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_pattern_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_pattern_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_type_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_case_sensitive_check", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_whole_words_check", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_all_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_status_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_all_pattern_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_all_type_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="max_results_spin", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_all_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cancel_search_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_progress", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="results_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="history_list", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="use_history_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.AdvancedSearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="clear_history_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.FindAllDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="results_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.ReplaceDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_pattern", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.ReplaceDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_type", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.ReplaceDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_pattern", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.ReplaceDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="case_sensitive", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.advanced_search.ReplaceDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_all", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="integer_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="float_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ascii_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="utf8_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="utf16le_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="utf16be_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="binary_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="time_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="special_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="input_type_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="value_edit", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="apply_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="clear_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="offset_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="size_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="checksum_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.data_inspector.DataInspector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tab_widget", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_size_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_strategy_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="loading_strategy_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="read_operations_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_hit_rate_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sequential_ratio_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="avg_read_time_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimization_status", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="background_loader_status", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_used_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_limit_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_progress", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="system_memory_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="system_memory_progress", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_regions_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_memory_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_utilization_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_hits_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_misses_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_progress", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="sequential_count_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="random_count_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="large_read_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="optimize_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="clear_stats_button", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_timer", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.hexview.performance_monitor.PerformanceWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tab_widget", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analyze_keys_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_algorithm_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_clear_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_count_spin", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_export_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_format_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_generate_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_progress", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_stop_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="batch_table", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="copy_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="existing_keys_input", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generate_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="key_analysis_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="key_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="results_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="save_single_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tabs", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="algorithm_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="format_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="length_spin", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="validation_check", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_depth", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analyze_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bypass_config", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bypass_language", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bypass_output", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="close_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="copy_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="doc_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exploit_advanced", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exploit_config", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="exploit_type", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="include_analysis", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="include_exploitation", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="include_options", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="include_persistence", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="include_recon", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="method_hook", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="method_loader", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="method_memory", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="method_patch", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="method_registry", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="payload_type", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="save_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_tabs", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="status_label", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy_config", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="strategy_type", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="target_function", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="template_display", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="test_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_type_combo", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_stack", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="config_layout", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generate_btn", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bypass_methods", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.ChatWidget" -> "intellicrack.ui.dialogs.ai_coding_assistant_dialog.AICodingAssistantDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="chat_widget", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.FileTreeWidget" -> "intellicrack.ui.dialogs.ai_coding_assistant_dialog.AICodingAssistantDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_tree", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.JavaScriptSyntaxHighlighter" -> "intellicrack.ui.dialogs.ai_coding_assistant_dialog.CodeEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="syntax_highlighter", style="solid"];
"intellicrack.ui.dialogs.ai_coding_assistant_dialog.PythonSyntaxHighlighter" -> "intellicrack.ui.dialogs.ai_coding_assistant_dialog.CodeEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="syntax_highlighter", style="solid"];
"intellicrack.ui.dialogs.c2_management_dialog.C2ServerThread" -> "intellicrack.ui.dialogs.c2_management_dialog.C2ManagementDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="server_thread", style="solid"];
"intellicrack.ui.dialogs.ci_cd_dialog.PipelineThread" -> "intellicrack.ui.dialogs.ci_cd_dialog.CICDDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pipeline_thread", style="solid"];
"intellicrack.ui.dialogs.code_modification_dialog.DiffSyntaxHighlighter" -> "intellicrack.ui.dialogs.code_modification_dialog.CodeModificationDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="diff_highlighter", style="solid"];
"intellicrack.ui.dialogs.code_modification_dialog.ModificationAnalysisThread" -> "intellicrack.ui.dialogs.code_modification_dialog.CodeModificationDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_thread", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.CodeEditorWidget" -> "intellicrack.ui.dialogs.debugger_dialog.DebuggerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="code_editor", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.DebuggerOutputThread" -> "intellicrack.ui.dialogs.debugger_dialog.DebuggerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="output_thread", style="solid"];
"intellicrack.ui.dialogs.debugger_dialog.LineNumberArea" -> "intellicrack.ui.dialogs.debugger_dialog.CodeEditorWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="line_number_area", style="solid"];
"intellicrack.ui.dialogs.export_dialog.ExportWorker" -> "intellicrack.ui.dialogs.export_dialog.ExportDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="export_worker", style="solid"];
"intellicrack.ui.dialogs.first_run_setup.SetupWorker" -> "intellicrack.ui.dialogs.first_run_setup.FirstRunSetupDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.FridaWorker" -> "intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="frida_worker", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.FridaWorker" -> "intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="frida_worker", style="solid"];
"intellicrack.ui.dialogs.frida_manager_dialog.ProcessWorker" -> "intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="process_worker", style="solid"];
"intellicrack.ui.dialogs.ghidra_script_selector.ScriptInfoWidget" -> "intellicrack.ui.dialogs.ghidra_script_selector.GhidraScriptSelector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="info_widget", style="solid"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenWorker" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenWorker" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.keygen_dialog.KeygenWorker" -> "intellicrack.ui.dialogs.keygen_dialog.KeygenDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.llm_config_dialog.ModelTestThread" -> "intellicrack.ui.dialogs.llm_config_dialog.LLMConfigDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="test_thread", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.AugmentationConfig" -> "intellicrack.ui.dialogs.model_finetuning_dialog.ModelFinetuningDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="augmentation_config", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingConfig" -> "intellicrack.ui.dialogs.model_finetuning_dialog.ModelFinetuningDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="training_config", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" -> "intellicrack.ui.dialogs.model_finetuning_dialog.ModelFinetuningDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="training_thread", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_bert_model.BERTModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_bert_model.BERTModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_enhanced_transformer_model.EnhancedTransformerModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_fallback_model.FallbackModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_gpt_model.GPTModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="model", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_rms_norm.RMSNorm" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="final_norm", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_rms_norm.RMSNorm" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_llama_layer.LlamaLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="attention_norm", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_rms_norm.RMSNorm" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_llama_model.LlamaModel._create_llama_layer.LlamaLayer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ffn_norm", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread._create_tokenizer.DummyTokenizer" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="tokenizer", style="solid"];
"intellicrack.ui.dialogs.payload_generator_dialog.PayloadGenerationThread" -> "intellicrack.ui.dialogs.payload_generator_dialog.PayloadGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generation_thread", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.CodeGenerationPage" -> "intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="code_page", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.PluginFeaturesPage" -> "intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="features_page", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.PluginInfoPage" -> "intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="info_page", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.SummaryPage" -> "intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="summary_page", style="solid"];
"intellicrack.ui.dialogs.plugin_creation_wizard.TemplateSelectionPage" -> "intellicrack.ui.dialogs.plugin_creation_wizard.PluginCreationWizard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="template_page", style="solid"];
"intellicrack.ui.dialogs.program_selector_dialog.ProgramDiscoveryThread" -> "intellicrack.ui.dialogs.program_selector_dialog.ProgramSelectorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="discovery_thread", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUExecutionThread" -> "intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUTestResultsDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="execution_thread", style="solid"];
"intellicrack.ui.dialogs.report_manager_dialog.ReportGenerationThread" -> "intellicrack.ui.dialogs.report_manager_dialog.ReportManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generation_thread", style="solid"];
"intellicrack.ui.dialogs.script_generator_dialog.PythonHighlighter" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorWorker" -> "intellicrack.ui.dialogs.script_generator_dialog.ScriptGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.signature_editor_dialog.SignatureSyntaxHighlighter" -> "intellicrack.ui.dialogs.signature_editor_dialog.SignatureEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="syntax_highlighter", style="solid"];
"intellicrack.ui.dialogs.signature_editor_dialog.SignatureTestWorker" -> "intellicrack.ui.dialogs.signature_editor_dialog.SignatureEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="test_worker", style="solid"];
"intellicrack.ui.dialogs.similarity_search_dialog.BinarySimilaritySearchDialog.search_similar_binaries.SearchThread" -> "intellicrack.ui.dialogs.similarity_search_dialog.BinarySimilaritySearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="search_thread", style="solid"];
"intellicrack.ui.dialogs.smart_program_selector_dialog.ProgramDiscoveryWorker" -> "intellicrack.ui.dialogs.smart_program_selector_dialog.SmartProgramSelectorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="discovery_worker", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" -> "intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" -> "intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" -> "intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" -> "intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesWorker" -> "intellicrack.ui.dialogs.system_utilities_dialog.SystemUtilitiesDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.dialogs.test_generator_dialog.TestGenerationThread" -> "intellicrack.ui.dialogs.test_generator_dialog.TestGeneratorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generation_thread", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.FindReplaceDialog" -> "intellicrack.ui.dialogs.text_editor_dialog.TextEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="find_replace_dialog", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.PythonSyntaxHighlighter" -> "intellicrack.ui.dialogs.text_editor_dialog.TextEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.dialogs.text_editor_dialog.PythonSyntaxHighlighter" -> "intellicrack.ui.dialogs.text_editor_dialog.TextEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.dialogs.vulnerability_research_dialog.ResearchWorkerThread" -> "intellicrack.ui.dialogs.vulnerability_research_dialog.VulnerabilityResearchDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.enhanced_ui_integration.EnhancedAnalysisDashboard" -> "intellicrack.ui.enhanced_ui_integration.EnhancedMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dashboard", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_output", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_status", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_analysis_results", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="clear_analysis_results", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_progress", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_assistant_status", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="update_chat_display", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="replace_chat_display_last", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_user_question", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="set_keygen_name", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="set_keygen_version", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="switch_tab", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="generate_key_signal", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.WorkerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="finished", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.WorkerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="error", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.WorkerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress", style="solid"];
"intellicrack.ui.main_app.DummySignal" -> "intellicrack.ui.main_app.WorkerThread" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="result", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2AnalysisWorker" -> "intellicrack.ui.radare2_integration_ui.R2IntegrationWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="current_worker", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2IntegrationWidget" -> "intellicrack.ui.enhanced_ui_integration.EnhancedAnalysisDashboard" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="r2_widget", style="solid"];
"intellicrack.ui.radare2_integration_ui.R2ResultsViewer" -> "intellicrack.ui.radare2_integration_ui.R2IntegrationWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="results_viewer", style="solid"];
"intellicrack.ui.radare2_ui_manager.R2UIManager" -> "intellicrack.ui.comprehensive_integration.ComprehensiveR2Integration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ui_manager", style="solid"];
"intellicrack.ui.radare2_ui_manager.R2UIManager" -> "intellicrack.ui.comprehensive_integration.ComprehensiveR2Integration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ui_manager", style="solid"];
"intellicrack.ui.radare2_ui_manager.R2UIManager" -> "intellicrack.ui.comprehensive_integration.ComprehensiveR2Integration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ui_manager", style="solid"];
"intellicrack.ui.radare2_ui_manager.R2UIManager" -> "intellicrack.ui.comprehensive_integration.ComprehensiveR2Integration" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ui_manager", style="solid"];
"intellicrack.ui.tabs.ai_assistant_tab.AIAssistantTab.start_model_training.TrainingThread" -> "intellicrack.ui.tabs.ai_assistant_tab.AIAssistantTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="training_thread", style="solid"];
"intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisWorker" -> "intellicrack.ui.widgets.batch_analysis_widget.BatchAnalysisWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="worker", style="solid"];
"intellicrack.ui.widgets.cache_management_widget.CacheStatsWidget" -> "intellicrack.ui.widgets.cache_management_widget.CacheManagementWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="stats_widget", style="solid"];
"intellicrack.ui.widgets.cache_management_widget.CacheTopEntriesWidget" -> "intellicrack.ui.widgets.cache_management_widget.CacheManagementWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="top_entries_widget", style="solid"];
"intellicrack.ui.widgets.console_widget.ConsoleSyntaxHighlighter" -> "intellicrack.ui.widgets.console_widget.ConsoleWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.widgets.console_widget.ConsoleWidget" -> "intellicrack.ui.dialogs.frida_manager_dialog.FridaManagerDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="log_console", style="solid"];
"intellicrack.ui.widgets.cpu_status_widget.CPUMonitorWorker" -> "intellicrack.ui.widgets.cpu_status_widget.CPUStatusWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor_worker", style="solid"];
"intellicrack.ui.widgets.cpu_status_widget.CPUStatusWidget" -> "intellicrack.ui.tabs.dashboard_tab.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cpu_status", style="solid"];
"intellicrack.ui.widgets.cpu_status_widget.CPUStatusWidget" -> "intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cpu_status", style="solid"];
"intellicrack.ui.widgets.drop_zone_widget.DropZoneWidget" -> "intellicrack.ui.tabs.dashboard_tab.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="drop_zone", style="solid"];
"intellicrack.ui.widgets.drop_zone_widget.DropZoneWidget" -> "intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="drop_zone", style="solid"];
"intellicrack.ui.widgets.entropy_graph_widget.EntropyGraphWidget" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entropy_graph", style="solid"];
"intellicrack.ui.widgets.entropy_visualizer.EntropyVisualizer" -> "intellicrack.ui.tabs.analysis_tab.AnalysisTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entropy_visualizer", style="solid"];
"intellicrack.ui.widgets.gpu_status_widget.GPUMonitorWorker" -> "intellicrack.ui.widgets.gpu_status_widget.GPUStatusWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor_worker", style="solid"];
"intellicrack.ui.widgets.gpu_status_widget.GPUStatusWidget" -> "intellicrack.ui.tabs.dashboard_tab.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="gpu_status", style="solid"];
"intellicrack.ui.widgets.gpu_status_widget.GPUStatusWidget" -> "intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="gpu_status", style="solid"];
"intellicrack.ui.widgets.hex_viewer.HexDisplay" -> "intellicrack.ui.widgets.hex_viewer.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_display", style="solid"];
"intellicrack.ui.widgets.hex_viewer.HexViewerWidget" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_viewer_widget", style="solid"];
"intellicrack.ui.widgets.hex_viewer_widget.HexViewerThread" -> "intellicrack.ui.widgets.hex_viewer_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="load_thread", style="solid"];
"intellicrack.ui.widgets.hex_viewer_widget.HexViewerWidget" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="hex_viewer", style="solid"];
"intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisThread" -> "intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_analysis_thread", style="solid"];
"intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisWidget" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="icp_widget", style="solid"];
"intellicrack.ui.widgets.intellicrack_advanced_protection_widget.AdvancedAnalysisThread" -> "intellicrack.ui.widgets.intellicrack_advanced_protection_widget.IntellicrackAdvancedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_thread", style="solid"];
"intellicrack.ui.widgets.intellicrack_advanced_protection_widget.EntropyGraphWidget" -> "intellicrack.ui.widgets.intellicrack_advanced_protection_widget.IntellicrackAdvancedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="entropy_graph", style="solid"];
"intellicrack.ui.widgets.intellicrack_protection_widget.ProtectionAnalysisThread" -> "intellicrack.ui.widgets.intellicrack_protection_widget.IntellicrackProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_thread", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumpThread" -> "intellicrack.ui.widgets.memory_dumper.MemoryDumperWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dump_thread", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumpThread" -> "intellicrack.ui.widgets.memory_dumper.MemoryDumperWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="dump_thread", style="solid"];
"intellicrack.ui.widgets.memory_dumper.MemoryDumperWidget" -> "intellicrack.ui.main_app.IntellicrackApp" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_dumper_widget", style="solid"];
"intellicrack.ui.widgets.model_loading_progress_widget.ModelLoadingProgressWidget" -> "intellicrack.ui.dialogs.model_loading_dialog.ModelLoadingDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="progress_widget", style="solid"];
"intellicrack.ui.widgets.pe_file_model.PEFileModel" -> "intellicrack.ui.widgets.hex_viewer_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="file_model", style="solid"];
"intellicrack.ui.widgets.pe_structure_model.PEStructureItem" -> "intellicrack.ui.widgets.pe_structure_model.PEStructureModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="root_item", style="solid"];
"intellicrack.ui.widgets.pe_structure_model.PEStructureItem" -> "intellicrack.ui.widgets.pe_structure_model.PEStructureModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="root_item", style="solid"];
"intellicrack.ui.widgets.pe_structure_model.PEStructureModel" -> "intellicrack.ui.widgets.hex_viewer_widget.HexViewerWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="structure_model", style="solid"];
"intellicrack.ui.widgets.plugin_editor.PluginEditor" -> "intellicrack.ui.dialogs.plugin_editor_dialog.PluginEditorDialog" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="editor", style="solid"];
"intellicrack.ui.widgets.plugin_editor.PluginValidator" -> "intellicrack.ui.widgets.plugin_editor.PluginEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="validator", style="solid"];
"intellicrack.ui.widgets.string_extraction_widget.StringExtractionThread" -> "intellicrack.ui.widgets.string_extraction_widget.StringExtractionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="extract_thread", style="solid"];
"intellicrack.ui.widgets.string_extraction_widget.StringExtractionWidget" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="string_extractor", style="solid"];
"intellicrack.ui.widgets.syntax_highlighters.JavaScriptHighlighter" -> "intellicrack.ui.widgets.plugin_editor.PluginEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.widgets.syntax_highlighters.PythonHighlighter" -> "intellicrack.ui.widgets.plugin_editor.PluginEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.widgets.syntax_highlighters.PythonHighlighter" -> "intellicrack.ui.widgets.plugin_editor.PluginEditor" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="highlighter", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWidget" -> "intellicrack.ui.tabs.dashboard_tab.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="system_monitor", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWidget" -> "intellicrack.ui.tabs.dashboard_tab_original.DashboardTab" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="system_monitor", style="solid"];
"intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWorker" -> "intellicrack.ui.widgets.system_monitor_widget.SystemMonitorWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="monitor_worker", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.UnifiedAnalysisThread" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="analysis_thread", style="solid"];
"intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="protection_widget", style="solid"];
"intellicrack.utils.binary.certificate_extractor.CodeSigningInfo" -> "intellicrack.ui.widgets.pe_file_model.PEFileModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="certificates", style="solid"];
"intellicrack.utils.binary.certificate_extractor.CodeSigningInfo" -> "intellicrack.ui.widgets.pe_file_model.PEFileModel" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="certificates", style="solid"];
"intellicrack.utils.core.path_discovery.PathDiscovery" -> "intellicrack.utils.system.program_discovery.ProgramDiscoveryEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="path_discovery", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_pandas_fallback.DataFrameFallback" -> "intellicrack.utils.dependency_fallbacks.create_pandas_fallback.PandasFallback" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="DataFrame", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.ClusterModule" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.SklearnFallback" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cluster", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.DBSCANFallback" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.ClusterModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="DBSCAN", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.EnsembleModule" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.SklearnFallback" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="ensemble", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.PreprocessingModule" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.SklearnFallback" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="preprocessing", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.RandomForestFallback" -> "intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="license_detector", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.RandomForestFallback" -> "intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="vulnerability_classifier", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.RandomForestFallback" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.EnsembleModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="RandomForestClassifier", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.StandardScalerFallback" -> "intellicrack.core.analysis.radare2_ai_integration.R2AIEngine" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="scaler", style="solid"];
"intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.StandardScalerFallback" -> "intellicrack.utils.dependency_fallbacks.create_sklearn_fallback.PreprocessingModule" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="StandardScaler", style="solid"];
"intellicrack.utils.patching.patch_generator.Architecture" -> "intellicrack.utils.patching.patch_generator.PatchEntry" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="architecture", style="solid"];
"intellicrack.utils.patching.patch_generator.Architecture" -> "intellicrack.utils.patching.patch_generator.PatchPattern" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="architecture", style="solid"];
"intellicrack.utils.patching.patch_generator.Architecture" -> "intellicrack.utils.patching.patch_generator.PatchResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="architecture", style="solid"];
"intellicrack.utils.patching.patch_generator.PatchType" -> "intellicrack.utils.patching.patch_generator.PatchResult" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="patch_type", style="solid"];
"intellicrack.utils.patching.patch_generator.PatternDatabase" -> "intellicrack.utils.patching.patch_generator.PatchGenerator" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="pattern_db", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.AdaptiveAnalyzer" -> "intellicrack.utils.runtime.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="adaptive_analyzer", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.BinaryChunker" -> "intellicrack.utils.runtime.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="binary_chunker", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.CacheManager" -> "intellicrack.utils.runtime.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.MemoryManager" -> "intellicrack.utils.runtime.performance_optimizer.PerformanceOptimizer" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="memory_manager", style="solid"];
"intellicrack.utils.tools.ghidra_script_manager.GhidraScriptManager" -> "intellicrack.ui.dialogs.ghidra_script_selector.GhidraScriptSelector" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="script_manager", style="solid"];
"intellicrack.ai.enhanced_training_interface.TrainingConfiguration" -> "intellicrack.ai.enhanced_training_interface.TrainingThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ai.intelligent_code_modifier.IntelligentCodeModifier" -> "intellicrack.ui.dialogs.code_modification_dialog.ModificationAnalysisThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="modifier", style="solid"];
"intellicrack.ai.intelligent_code_modifier.ModificationRequest" -> "intellicrack.ui.dialogs.code_modification_dialog.ModificationAnalysisThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="request", style="solid"];
"intellicrack.ai.learning_engine.AILearningDatabase" -> "intellicrack.ai.learning_engine.FailureAnalysisEngine" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="database", style="solid"];
"intellicrack.ai.learning_engine.AILearningDatabase" -> "intellicrack.ai.learning_engine.PatternEvolutionEngine" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="database", style="solid"];
"intellicrack.ai.llm_backends.LLMConfig" -> "intellicrack.ai.lazy_model_loader.LazyModelWrapper" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ai.llm_backends.LLMConfig" -> "intellicrack.ai.llm_backends.LLMBackend" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.ai_tools.AIAssistant" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.ai_tools.CodeAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.ai_tools.CodeAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_llm_manager", style="solid"];
"intellicrack.ai.llm_backends.LLMManager" -> "intellicrack.ai.coordination_layer.AICoordinationLayer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_llm_manager", style="solid"];
"intellicrack.ai.local_gguf_server.GGUFModelManager" -> "intellicrack.ai.llm_backends.LocalGGUFBackend" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="gguf_manager", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ai.model_manager_module.AsyncModelManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.model_manager_module.ModelManager" -> "intellicrack.ai.model_manager_module.ModelFineTuner" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="model_manager", style="solid"];
"intellicrack.ai.multi_agent_system.AgentRole" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="role", style="solid"];
"intellicrack.ai.multi_agent_system.AgentTask" -> "intellicrack.ai.multi_agent_system.BaseAgent" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_task", style="solid"];
"intellicrack.ai.multi_agent_system.MultiAgentSystem" -> "intellicrack.ai.multi_agent_system.TaskDistributor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="system", style="solid"];
"intellicrack.ai.performance_monitor.PerformanceMonitor" -> "intellicrack.ai.performance_monitor.AsyncPerformanceMonitor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="base_monitor", style="solid"];
"intellicrack.ai.qemu_test_manager.QEMUTestManager" -> "intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUExecutionThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="qemu_manager", style="solid"];
"intellicrack.ai.realtime_adaptation_engine.RuntimeMonitor" -> "intellicrack.ai.realtime_adaptation_engine.LiveDebuggingSystem" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="runtime_monitor", style="solid"];
"intellicrack.ai.resilience_self_healing.HealthMonitor" -> "intellicrack.ai.resilience_self_healing.RecoverySystem" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="health_monitor", style="solid"];
"intellicrack.ai.visualization_analytics.DataCollector" -> "intellicrack.ai.visualization_analytics.AnalyticsEngine" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="data_collector", style="solid"];
"intellicrack.ai.visualization_analytics.DataCollector" -> "intellicrack.ai.visualization_analytics.ChartGenerator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="data_collector", style="solid"];
"intellicrack.ai.visualization_analytics.DataCollector" -> "intellicrack.ai.visualization_analytics.DashboardManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="data_collector", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.R2ErrorHandler" -> "intellicrack.core.analysis.radare2_enhanced_integration.Radare2EnhancedIntegration" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="error_handler", style="solid"];
"intellicrack.core.analysis.radare2_error_handler.R2ErrorHandler" -> "intellicrack.core.analysis.radare2_realtime_analyzer.R2RealtimeAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="error_handler", style="solid"];
"intellicrack.core.analysis.radare2_performance_optimizer.OptimizationStrategy" -> "intellicrack.core.analysis.radare2_performance_optimizer.R2PerformanceOptimizer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="strategy", style="solid"];
"intellicrack.core.analysis.radare2_realtime_analyzer.UpdateMode" -> "intellicrack.core.analysis.radare2_realtime_analyzer.R2RealtimeAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="update_mode", style="solid"];
"intellicrack.core.analysis.rop_generator.ROPChainGenerator" -> "intellicrack.ui.tabs.exploitation_tab.ExploitationTab" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_rop_generator", style="solid"];
"intellicrack.core.anti_analysis.sandbox_detector.SandboxDetector._check_mouse_movement.MockPOINT" -> "intellicrack.core.anti_analysis.process_hollowing.MockWintypes" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="POINT", style="solid"];
"intellicrack.core.c2.c2_client.C2Client._start_keylogging.MSG" -> "intellicrack.core.anti_analysis.process_hollowing.MockWintypes" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="MSG", style="solid"];
"intellicrack.core.frida_bypass_wizard.WizardState" -> "intellicrack.core.frida_bypass_wizard.FridaBypassWizard" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="state", style="solid"];
"intellicrack.core.frida_constants.ProtectionType" -> "intellicrack.core.frida_bypass_wizard.BypassStrategy" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="protection_type", style="solid"];
"intellicrack.core.logging.audit_logger.AuditEventType" -> "intellicrack.core.logging.audit_logger.AuditEvent" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="event_type", style="solid"];
"intellicrack.core.logging.audit_logger.AuditLogger" -> "intellicrack.core.logging.audit_logger.TelemetryCollector" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="audit_logger", style="solid"];
"intellicrack.core.logging.audit_logger.AuditSeverity" -> "intellicrack.core.logging.audit_logger.AuditEvent" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="severity", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceManager" -> "intellicrack.core.resources.resource_manager.AutoCleanupResource" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="resource_manager", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceManager" -> "intellicrack.core.resources.resource_manager.ResourceContext" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="resource_manager", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceType" -> "intellicrack.core.resources.resource_manager.AutoCleanupResource" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="resource_type", style="solid"];
"intellicrack.core.resources.resource_manager.ResourceType" -> "intellicrack.core.resources.resource_manager.ManagedResource" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="resource_type", style="solid"];
"intellicrack.core.security_enforcement._monkey_patch_subprocess.SecurePopen" -> "intellicrack.core.resources.resource_manager.ProcessResource" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="process", style="solid"];
"intellicrack.hexview.advanced_search.SearchEngine" -> "intellicrack.hexview.advanced_search.SearchThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="search_engine", style="solid"];
"intellicrack.hexview.advanced_search.SearchType" -> "intellicrack.hexview.advanced_search.SearchThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="search_type", style="solid"];
"intellicrack.hexview.hex_commands.OperationType" -> "intellicrack.hexview.hex_commands.HexCommand" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="operation_type", style="solid"];
"intellicrack.hexview.hex_highlighter.HighlightType" -> "intellicrack.hexview.hex_highlighter.HexHighlight" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="highlight_type", style="solid"];
"intellicrack.hexview.large_file_handler.FileCache" -> "intellicrack.hexview.large_file_handler.BackgroundLoader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="cache", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryConfig" -> "intellicrack.hexview.large_file_handler.BackgroundLoader" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryConfig" -> "intellicrack.hexview.large_file_handler.FileCache" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.hexview.large_file_handler.MemoryConfig" -> "intellicrack.hexview.large_file_handler.MemoryMonitor" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.models.model_manager.ModelManager.train_model.SimpleNN" -> "intellicrack.models.model_manager.ModelManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_last_trained_model", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationManager" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.LocalLicenseServer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="auth_manager", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.AuthenticationManager" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.ResponseModifier" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="auth_manager", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.InterceptorConfig" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CacheManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.cloud_license_interceptor.InterceptorConfig" -> "intellicrack.plugins.custom_modules.cloud_license_interceptor.CertificateManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.hardware_dongle_emulator.DongleSpec" -> "intellicrack.plugins.custom_modules.hardware_dongle_emulator.BaseDongleEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="spec", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventBus" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AnalysisCoordinator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventBus" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.EventBus" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowEngine" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="event_bus", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AnalysisCoordinator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="plugin_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.PluginManager" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowEngine" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="plugin_manager", style="solid"];
"intellicrack.plugins.custom_modules.intellicrack_core_engine.WorkflowEngine" -> "intellicrack.plugins.custom_modules.intellicrack_core_engine.AnalysisCoordinator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="workflow_engine", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.AdobeEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.FlexLMEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.HASPEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.license_server_emulator.CryptoManager" -> "intellicrack.plugins.custom_modules.license_server_emulator.MicrosoftKMSEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="crypto", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisResult" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisViewerPanel" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_analysis", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.AnalysisViewerPanel" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.FileExplorerPanel" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.LogViewer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.ui_enhancement_module.UIConfig" -> "intellicrack.plugins.custom_modules.ui_enhancement_module.ScriptGeneratorPanel" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.plugins.custom_modules.vm_protection_unwrapper.ProtectionType" -> "intellicrack.plugins.custom_modules.vm_protection_unwrapper.VMEmulator" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="protection_type", style="solid"];
"intellicrack.plugins.plugin_base.PluginMetadata" -> "intellicrack.plugins.plugin_base.BasePlugin" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="metadata", style="solid"];
"intellicrack.protection.icp_backend.ICPScanResult" -> "intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisWidget" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_result", style="solid"];
"intellicrack.protection.icp_backend.ScanMode" -> "intellicrack.ui.widgets.icp_analysis_widget.ICPAnalysisThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="scan_mode", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.AdvancedProtectionAnalysis" -> "intellicrack.ui.widgets.intellicrack_advanced_protection_widget.IntellicrackAdvancedProtectionWidget" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_analysis", style="solid"];
"intellicrack.protection.intellicrack_protection_advanced.ScanMode" -> "intellicrack.ui.widgets.intellicrack_advanced_protection_widget.AdvancedAnalysisThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="scan_mode", style="solid"];
"intellicrack.protection.intellicrack_protection_core.ProtectionAnalysis" -> "intellicrack.ui.widgets.intellicrack_protection_widget.IntellicrackProtectionWidget" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_analysis", style="solid"];
"intellicrack.protection.unified_protection_engine.UnifiedProtectionResult" -> "intellicrack.ui.widgets.unified_protection_widget.UnifiedProtectionWidget" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_result", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.IntellicrackAIInterface" -> "intellicrack.scripts.cli.ai_integration.AIModelAdapter" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="interface", style="solid"];
"intellicrack.scripts.cli.ai_wrapper.IntellicrackAIInterface" -> "intellicrack.scripts.cli.ai_integration.LangChainIntegration" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="interface", style="solid"];
"intellicrack.scripts.cli.project_manager.IntellicrackProject" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_project", style="solid"];
"intellicrack.scripts.cli.project_manager.IntellicrackProject" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_project", style="solid"];
"intellicrack.scripts.cli.project_manager.IntellicrackProject" -> "intellicrack.scripts.cli.interactive_mode.IntellicrackShell" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="_current_project", style="solid"];
"intellicrack.scripts.cli.project_manager.IntellicrackProject" -> "intellicrack.scripts.cli.project_manager.ProjectManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="current_project", style="solid"];
"intellicrack.tools.plugin_debugger.PluginDebugger" -> "intellicrack.tools.plugin_debugger.DebuggerThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="debugger", style="solid"];
"intellicrack.ui.common_imports.MockQtClass" -> "intellicrack.ui.main_window.IntellicrackMainWindow" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="ai_assistant_widget", style="solid"];
"intellicrack.ui.dialogs.model_finetuning_dialog.TrainingConfig" -> "intellicrack.ui.dialogs.model_finetuning_dialog.TrainingThread" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="config", style="solid"];
"intellicrack.ui.dialogs.qemu_test_dialog.QEMUTestDialog" -> "intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="QEMUTestDialog", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUTestResultsDialog" -> "intellicrack.core.execution.script_execution_manager.ScriptExecutionManager" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="QEMUTestResultsDialog", style="solid"];
"intellicrack.ui.dialogs.qemu_test_results_dialog.TestResults" -> "intellicrack.ui.dialogs.qemu_test_results_dialog.QEMUTestResultsDialog" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="test_results", style="solid"];
"intellicrack.ui.widgets.pe_file_model.PEFileModel" -> "intellicrack.ui.widgets.pe_structure_model.PEStructureModel" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="pe_model", style="solid"];
"intellicrack.utils.patching.patch_generator.BinaryAnalyzer" -> "intellicrack.utils.patching.patch_generator.IntelligentPatcher" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="analyzer", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.CacheManager" -> "intellicrack.utils.runtime.performance_optimizer.AdaptiveAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="cache_manager", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.MemoryManager" -> "intellicrack.utils.runtime.performance_optimizer.AdaptiveAnalyzer" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="memory_manager", style="solid"];
"intellicrack.utils.runtime.performance_optimizer.MemoryManager" -> "intellicrack.utils.runtime.performance_optimizer.BinaryChunker" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="memory_manager", style="solid"];
}
