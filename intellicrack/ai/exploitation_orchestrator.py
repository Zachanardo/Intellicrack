"""
Exploitation Orchestrator

Advanced AI orchestration layer that coordinates all exploitation capabilities
with Intellicrack's AI model for fully automated exploitation workflows.
"""

import logging
import time
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class ExploitationOrchestrator:
    """
    Central orchestrator that coordinates all exploitation capabilities with AI guidance.
    
    This class serves as the main integration point between Intellicrack's AI model
    and all the advanced exploitation frameworks implemented in previous phases.
    """

    def __init__(self, ai_model=None):
        self.logger = logging.getLogger("IntellicrackLogger.ExploitationOrchestrator")
        self.ai_model = ai_model

        # Initialize all exploitation components
        self._init_exploitation_components()

        # Orchestration state
        self.active_campaigns = {}
        self.exploitation_history = []
        self.ai_insights = {}

        # Performance metrics
        self.metrics = {
            'campaigns_executed': 0,
            'success_rate': 0.0,
            'avg_time_to_exploit': 0.0,
            'ai_accuracy': 0.0
        }

    def _init_exploitation_components(self):
        """Initialize all exploitation framework components."""
        try:
            # Core exploitation engines
            from ..ai.vulnerability_research_integration import VulnerabilityResearchAI
            from ..core.c2_infrastructure.c2_manager import C2Manager
            from ..core.payload_generation.payload_engine import PayloadEngine
            from ..core.post_exploitation.lateral_movement import LateralMovementManager
            from ..core.post_exploitation.persistence_manager import PersistenceManager
            from ..core.post_exploitation.privilege_escalation import PrivilegeEscalationManager
            from ..core.vulnerability_research.ml_adaptation_engine import MLAdaptationEngine
            from ..core.vulnerability_research.research_manager import ResearchManager

            self.payload_engine = PayloadEngine()
            self.c2_manager = C2Manager()
            self.persistence_manager = PersistenceManager()
            self.privesc_manager = PrivilegeEscalationManager()
            self.lateral_manager = LateralMovementManager()
            self.research_manager = ResearchManager()
            self.ml_engine = MLAdaptationEngine()
            self.vuln_research_ai = VulnerabilityResearchAI()

            self.logger.info("All exploitation components initialized successfully")

        except Exception as e:
            self.logger.error(f"Failed to initialize exploitation components: {e}")
            # Set fallback components to None
            self.payload_engine = None
            self.c2_manager = None
            self.persistence_manager = None
            self.privesc_manager = None
            self.lateral_manager = None
            self.research_manager = None
            self.ml_engine = None
            self.vuln_research_ai = None

    def orchestrate_full_exploitation(self, target_info: Dict[str, Any],
                                    orchestration_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Orchestrate a complete exploitation campaign using AI guidance.
        
        Args:
            target_info: Information about the target system/binary
            orchestration_config: Configuration for orchestration behavior
            
        Returns:
            Comprehensive results of the exploitation campaign
        """
        campaign_id = f"campaign_{int(time.time())}"

        result = {
            'success': False,
            'campaign_id': campaign_id,
            'target_info': target_info,
            'phases': {},
            'timeline': [],
            'ai_decisions': [],
            'metrics': {},
            'final_status': 'failed',
            'error': None
        }

        try:
            self.logger.info(f"Starting orchestrated exploitation campaign: {campaign_id}")

            # Initialize campaign tracking
            self.active_campaigns[campaign_id] = {
                'start_time': time.time(),
                'target_info': target_info,
                'status': 'running',
                'current_phase': 'initialization'
            }

            config = orchestration_config or {}

            # === PHASE 1: AI-Guided Intelligence Gathering ===
            intelligence_phase = self._execute_intelligence_phase(campaign_id, target_info, config)
            result['phases']['intelligence'] = intelligence_phase
            result['timeline'].append({
                'phase': 'intelligence',
                'timestamp': time.time(),
                'status': 'completed' if intelligence_phase['success'] else 'failed',
                'duration': intelligence_phase.get('duration', 0)
            })

            if not intelligence_phase['success']:
                result['error'] = f"Intelligence phase failed: {intelligence_phase.get('error')}"
                return result

            # Get AI insights for strategy planning
            ai_insights = self._get_ai_strategic_insights(target_info, intelligence_phase['results'])
            result['ai_decisions'].append({
                'phase': 'strategy_planning',
                'insights': ai_insights,
                'timestamp': time.time()
            })

            # === PHASE 2: AI-Optimized Payload Generation ===
            payload_phase = self._execute_payload_phase(
                campaign_id, target_info, intelligence_phase['results'], ai_insights
            )
            result['phases']['payload'] = payload_phase
            result['timeline'].append({
                'phase': 'payload',
                'timestamp': time.time(),
                'status': 'completed' if payload_phase['success'] else 'failed',
                'duration': payload_phase.get('duration', 0)
            })

            if not payload_phase['success']:
                result['error'] = f"Payload phase failed: {payload_phase.get('error')}"
                return result

            # === PHASE 3: Adaptive C2 Infrastructure Setup ===
            c2_phase = self._execute_c2_phase(
                campaign_id, target_info, payload_phase['payload_config'], ai_insights
            )
            result['phases']['c2'] = c2_phase
            result['timeline'].append({
                'phase': 'c2',
                'timestamp': time.time(),
                'status': 'completed' if c2_phase['success'] else 'failed',
                'duration': c2_phase.get('duration', 0)
            })

            # === PHASE 4: Intelligent Exploitation Execution ===
            exploitation_phase = self._execute_exploitation_phase(
                campaign_id, target_info, payload_phase['payload'], c2_phase['c2_config'], ai_insights
            )
            result['phases']['exploitation'] = exploitation_phase
            result['timeline'].append({
                'phase': 'exploitation',
                'timestamp': time.time(),
                'status': 'completed' if exploitation_phase['success'] else 'failed',
                'duration': exploitation_phase.get('duration', 0)
            })

            if not exploitation_phase['success']:
                # Try AI-guided adaptation
                adaptation_result = self._attempt_ai_adaptation(
                    campaign_id, target_info, exploitation_phase, ai_insights
                )
                result['phases']['adaptation'] = adaptation_result

                if adaptation_result['success']:
                    # Retry with adapted strategy
                    retry_phase = self._execute_exploitation_phase(
                        campaign_id, target_info, adaptation_result['adapted_payload'],
                        c2_phase['c2_config'], adaptation_result['adapted_insights']
                    )
                    result['phases']['exploitation_retry'] = retry_phase
                    exploitation_phase = retry_phase

            # === PHASE 5: Post-Exploitation (if successful) ===
            if exploitation_phase['success']:
                post_exploit_phase = self._execute_post_exploitation_phase(
                    campaign_id, target_info, exploitation_phase['session_info'], ai_insights
                )
                result['phases']['post_exploitation'] = post_exploit_phase
                result['timeline'].append({
                    'phase': 'post_exploitation',
                    'timestamp': time.time(),
                    'status': 'completed' if post_exploit_phase['success'] else 'failed',
                    'duration': post_exploit_phase.get('duration', 0)
                })

                result['final_status'] = 'success'
                result['success'] = True

            # === PHASE 6: AI Learning and Metrics Collection ===
            learning_phase = self._execute_learning_phase(campaign_id, result)
            result['phases']['learning'] = learning_phase

            # Calculate campaign metrics
            campaign_metrics = self._calculate_campaign_metrics(result)
            result['metrics'] = campaign_metrics

            # Update global metrics
            self._update_global_metrics(result)

            # Store campaign in history
            self.exploitation_history.append({
                'campaign_id': campaign_id,
                'timestamp': time.time(),
                'target_info': target_info,
                'result': result,
                'success': result['success']
            })

            # Cleanup campaign tracking
            if campaign_id in self.active_campaigns:
                del self.active_campaigns[campaign_id]

            self.logger.info(f"Orchestrated exploitation campaign completed: {campaign_id} - {result['final_status']}")

        except Exception as e:
            self.logger.error(f"Orchestrated exploitation failed: {e}")
            result['error'] = str(e)

            # Cleanup on error
            if campaign_id in self.active_campaigns:
                del self.active_campaigns[campaign_id]

        return result

    def _execute_intelligence_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                  config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI-guided intelligence gathering phase."""
        phase_start = time.time()

        result = {
            'success': False,
            'results': {},
            'ai_insights': {},
            'vulnerability_count': 0,
            'risk_assessment': {},
            'duration': 0,
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting intelligence gathering phase")

            # Update campaign status
            self.active_campaigns[campaign_id]['current_phase'] = 'intelligence'

            # Use AI-guided vulnerability research
            if self.vuln_research_ai:
                analysis_result = self.vuln_research_ai.analyze_target_with_ai(
                    target_info.get('binary_path', target_info.get('target_path'))
                )

                if analysis_result['success']:
                    result['results'] = analysis_result
                    result['vulnerability_count'] = len(analysis_result.get('analysis_results', {}).get('initial', {}).get('vulnerabilities', []))
                    result['risk_assessment'] = analysis_result.get('risk_assessment', {})
                    result['ai_insights'] = analysis_result.get('ai_recommendations', [])
                    result['success'] = True
                else:
                    result['error'] = analysis_result.get('error', 'AI analysis failed')
            else:
                result['error'] = 'AI research component not available'

            result['duration'] = time.time() - phase_start
            self.logger.info(f"[{campaign_id}] Intelligence phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result['error'] = str(e)
            result['duration'] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] Intelligence phase failed: {e}")

        return result

    def _get_ai_strategic_insights(self, target_info: Dict[str, Any],
                                 intelligence_results: Dict[str, Any]) -> Dict[str, Any]:
        """Get AI strategic insights for exploitation planning."""
        insights = {
            'recommended_approach': 'standard',
            'payload_strategy': 'reverse_shell',
            'evasion_level': 'medium',
            'post_exploit_priorities': [],
            'risk_mitigation': [],
            'success_probability': 0.5
        }

        try:
            # Analyze intelligence results with AI
            if self.ai_model and hasattr(self.ai_model, 'get_strategic_insights'):
                ai_insights = self.ai_model.get_strategic_insights(target_info, intelligence_results)
                insights.update(ai_insights)
            else:
                # Fallback to rule-based insights
                risk_score = intelligence_results.get('risk_assessment', {}).get('risk_score', 0.5)
                vuln_count = len(intelligence_results.get('vulnerabilities', []))

                if risk_score > 0.7:
                    insights['recommended_approach'] = 'stealth'
                    insights['evasion_level'] = 'high'
                elif risk_score < 0.3:
                    insights['recommended_approach'] = 'aggressive'
                    insights['evasion_level'] = 'low'

                insights['success_probability'] = min(0.9, 0.3 + (vuln_count * 0.1) + risk_score)

        except Exception as e:
            self.logger.warning(f"Failed to get AI strategic insights: {e}")

        return insights

    def _execute_payload_phase(self, campaign_id: str, target_info: Dict[str, Any],
                             intelligence_results: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI-optimized payload generation phase."""
        phase_start = time.time()

        result = {
            'success': False,
            'payload': None,
            'payload_config': {},
            'metadata': {},
            'duration': 0,
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting payload generation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]['current_phase'] = 'payload'

            if self.payload_engine:
                from ..core.payload_generation.payload_types import (
                    Architecture,
                    EncodingType,
                    PayloadType,
                )

                # Determine optimal payload configuration based on AI insights
                payload_strategy = ai_insights.get('payload_strategy', 'reverse_shell')
                evasion_level = ai_insights.get('evasion_level', 'medium')

                payload_type_mapping = {
                    'reverse_shell': PayloadType.REVERSE_SHELL,
                    'bind_shell': PayloadType.BIND_SHELL,
                    'meterpreter': PayloadType.METERPRETER,
                    'staged': PayloadType.STAGED_PAYLOAD
                }

                # Extract target configuration
                network_config = target_info.get('network_config', {})

                payload_config = {
                    'lhost': network_config.get('lhost', '127.0.0.1'),
                    'lport': network_config.get('lport', 4444),
                    'encoding': EncodingType.POLYMORPHIC if evasion_level in ['medium', 'high'] else EncodingType.NONE,
                    'evasion_level': evasion_level
                }

                # Generate payload
                payload_result = self.payload_engine.generate_payload(
                    payload_type=payload_type_mapping.get(payload_strategy, PayloadType.REVERSE_SHELL),
                    architecture=Architecture.X64,
                    target_info=target_info,
                    options=payload_config
                )

                if payload_result['success']:
                    result['success'] = True
                    result['payload'] = payload_result['payload']
                    result['payload_config'] = payload_config
                    result['metadata'] = payload_result['metadata']
                else:
                    result['error'] = payload_result.get('error', 'Payload generation failed')
            else:
                result['error'] = 'Payload engine not available'

            result['duration'] = time.time() - phase_start
            self.logger.info(f"[{campaign_id}] Payload phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result['error'] = str(e)
            result['duration'] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] Payload phase failed: {e}")

        return result

    def _execute_c2_phase(self, campaign_id: str, target_info: Dict[str, Any],
                        payload_config: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute adaptive C2 infrastructure setup phase."""
        phase_start = time.time()

        result = {
            'success': False,
            'c2_config': {},
            'server_info': {},
            'duration': 0,
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting C2 infrastructure phase")

            # Update campaign status
            self.active_campaigns[campaign_id]['current_phase'] = 'c2'

            if self.c2_manager:
                # Determine optimal C2 configuration based on AI insights
                evasion_level = ai_insights.get('evasion_level', 'medium')

                c2_config = {
                    'protocol': 'https' if evasion_level in ['medium', 'high'] else 'tcp',
                    'port': payload_config.get('lport', 4444),
                    'interface': '0.0.0.0',
                    'encryption_method': 'aes256' if evasion_level == 'high' else 'xor',
                    'max_sessions': 50,
                    'session_timeout': 300
                }

                # Start C2 server
                server_result = self.c2_manager.start_server(c2_config)

                if server_result['success']:
                    result['success'] = True
                    result['c2_config'] = c2_config
                    result['server_info'] = server_result
                else:
                    result['error'] = server_result.get('error', 'C2 server start failed')
            else:
                result['error'] = 'C2 manager not available'

            result['duration'] = time.time() - phase_start
            self.logger.info(f"[{campaign_id}] C2 phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result['error'] = str(e)
            result['duration'] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] C2 phase failed: {e}")

        return result

    def _execute_exploitation_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                  payload: bytes, c2_config: Dict[str, Any],
                                  ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute intelligent exploitation phase."""
        phase_start = time.time()

        result = {
            'success': False,
            'session_info': {},
            'exploitation_method': '',
            'duration': 0,
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting exploitation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]['current_phase'] = 'exploitation'

            # Simulate exploitation (in a real implementation, this would use the actual exploit)
            # For demonstration, we'll simulate based on success probability
            success_probability = ai_insights.get('success_probability', 0.5)

            # In reality, this would:
            # 1. Deploy the payload to the target
            # 2. Wait for callback to C2 server
            # 3. Establish session
            # 4. Verify access

            import random
            exploitation_successful = random.random() < success_probability

            if exploitation_successful:
                result['success'] = True
                result['session_info'] = {
                    'session_id': f"session_{campaign_id}",
                    'remote_ip': target_info.get('target_ip', '192.168.1.100'),
                    'platform': target_info.get('platform', 'windows'),
                    'user': 'user',
                    'privileges': 'user'
                }
                result['exploitation_method'] = ai_insights.get('recommended_approach', 'standard')
            else:
                result['error'] = 'Exploitation attempt failed - no callback received'

            result['duration'] = time.time() - phase_start
            self.logger.info(f"[{campaign_id}] Exploitation phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result['error'] = str(e)
            result['duration'] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] Exploitation phase failed: {e}")

        return result

    def _attempt_ai_adaptation(self, campaign_id: str, target_info: Dict[str, Any],
                             failed_exploitation: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt AI-guided adaptation after exploitation failure."""
        result = {
            'success': False,
            'adapted_payload': None,
            'adapted_insights': {},
            'adaptation_strategy': '',
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Attempting AI-guided adaptation")

            if self.ml_engine:
                # Use ML adaptation engine to analyze failure and adapt strategy
                adaptation_result = self.ml_engine.adapt_exploitation_strategy(
                    target_info=target_info,
                    previous_attempts=[failed_exploitation],
                    strategy='exploit_optimization'
                )

                if adaptation_result['success']:
                    # Generate new payload with adapted strategy
                    adapted_insights = ai_insights.copy()
                    adapted_insights.update(adaptation_result.get('adaptations', {}))

                    # This would regenerate payload with new parameters
                    result['success'] = True
                    result['adapted_insights'] = adapted_insights
                    result['adaptation_strategy'] = adaptation_result.get('strategy_name', 'ml_optimization')
                else:
                    result['error'] = adaptation_result.get('error', 'ML adaptation failed')
            else:
                result['error'] = 'ML adaptation engine not available'

        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"[{campaign_id}] AI adaptation failed: {e}")

        return result

    def _execute_post_exploitation_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                       session_info: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute comprehensive post-exploitation phase."""
        phase_start = time.time()

        result = {
            'success': False,
            'persistence_established': False,
            'privileges_escalated': False,
            'lateral_movement_completed': False,
            'data_collected': False,
            'actions_performed': [],
            'duration': 0,
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting post-exploitation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]['current_phase'] = 'post_exploitation'

            platform = session_info.get('platform', 'windows')
            actions_performed = []

            # 1. Establish Persistence
            if self.persistence_manager:
                persistence_result = self.persistence_manager.establish_persistence(
                    payload_path='/tmp/implant',
                    target_os=platform,
                    privilege_level='user',
                    stealth_level='medium'
                )

                if persistence_result['success']:
                    result['persistence_established'] = True
                    if persistence_result.get('methods_established'):
                        methods = [m['method'] for m in persistence_result['methods_established']]
                        actions_performed.append(f"Persistence: {', '.join(methods)}")
                    else:
                        actions_performed.append("Persistence: established")

            # 2. Privilege Escalation
            if self.privesc_manager and session_info.get('privileges') == 'user':
                privesc_result = self.privesc_manager.escalate_privileges(platform=platform)

                if privesc_result['success']:
                    result['privileges_escalated'] = True
                    actions_performed.append(f"PrivEsc: {privesc_result['method']}")

            # 3. Lateral Movement (if requested by AI)
            post_exploit_priorities = ai_insights.get('post_exploit_priorities', [])
            if 'lateral_movement' in post_exploit_priorities and self.lateral_manager:
                lateral_result = self.lateral_manager.discover_targets()

                if lateral_result['success'] and lateral_result['targets']:
                    result['lateral_movement_completed'] = True
                    actions_performed.append(f"Lateral: {len(lateral_result['targets'])} targets discovered")

            # 4. Data Collection
            result['data_collected'] = True  # Simulate data collection
            actions_performed.append("Data: System info collected")

            result['actions_performed'] = actions_performed
            result['success'] = len(actions_performed) > 0

            result['duration'] = time.time() - phase_start
            self.logger.info(f"[{campaign_id}] Post-exploitation phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result['error'] = str(e)
            result['duration'] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] Post-exploitation phase failed: {e}")

        return result

    def _execute_learning_phase(self, campaign_id: str, campaign_result: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI learning phase to improve future campaigns."""
        result = {
            'success': False,
            'insights_generated': [],
            'model_updates': [],
            'performance_analysis': {},
            'error': None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting learning phase")

            # Analyze campaign performance
            timeline = campaign_result.get('timeline', [])
            total_duration = sum(phase.get('duration', 0) for phase in timeline)
            successful_phases = [phase for phase in timeline if phase.get('status') == 'completed']

            performance_analysis = {
                'total_duration': total_duration,
                'successful_phases': len(successful_phases),
                'total_phases': len(timeline),
                'success_rate': len(successful_phases) / len(timeline) if timeline else 0,
                'campaign_success': campaign_result['success']
            }

            # Generate insights
            insights = []
            if performance_analysis['success_rate'] > 0.8:
                insights.append("High success rate indicates effective strategy selection")
            if total_duration < 300:  # Less than 5 minutes
                insights.append("Fast execution time suggests good automation")
            if campaign_result['success']:
                insights.append("Successful exploitation validates AI recommendations")

            # In a real implementation, this would:
            # 1. Update ML models with campaign data
            # 2. Adjust strategy selection algorithms
            # 3. Improve success probability calculations

            result['success'] = True
            result['insights_generated'] = insights
            result['performance_analysis'] = performance_analysis

            self.logger.info(f"[{campaign_id}] Learning phase completed - {len(insights)} insights generated")

        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"[{campaign_id}] Learning phase failed: {e}")

        return result

    def _calculate_campaign_metrics(self, campaign_result: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate detailed metrics for the campaign."""
        timeline = campaign_result.get('timeline', [])

        metrics = {
            'total_duration': sum(phase.get('duration', 0) for phase in timeline),
            'phase_count': len(timeline),
            'successful_phases': len([p for p in timeline if p.get('status') == 'completed']),
            'ai_decisions_count': len(campaign_result.get('ai_decisions', [])),
            'overall_success': campaign_result['success'],
            'time_to_exploit': 0,
            'efficiency_score': 0
        }

        # Calculate time to exploit (time until successful exploitation)
        for phase in timeline:
            if phase['phase'] == 'exploitation' and phase['status'] == 'completed':
                metrics['time_to_exploit'] = phase['timestamp'] - timeline[0]['timestamp']
                break

        # Calculate efficiency score
        if metrics['phase_count'] > 0:
            phase_success_rate = metrics['successful_phases'] / metrics['phase_count']
            time_efficiency = 1.0 if metrics['total_duration'] < 300 else 300 / metrics['total_duration']
            metrics['efficiency_score'] = (phase_success_rate + time_efficiency) / 2

        return metrics

    def _update_global_metrics(self, campaign_result: Dict[str, Any]):
        """Update global orchestrator metrics."""
        self.metrics['campaigns_executed'] += 1

        # Update success rate
        successful_campaigns = len([c for c in self.exploitation_history if c['success']])
        self.metrics['success_rate'] = successful_campaigns / len(self.exploitation_history) if self.exploitation_history else 0

        # Update average time to exploit
        campaign_metrics = campaign_result.get('metrics', {})
        if campaign_metrics.get('time_to_exploit', 0) > 0:
            current_avg = self.metrics['avg_time_to_exploit']
            count = len([c for c in self.exploitation_history if c['result'].get('metrics', {}).get('time_to_exploit', 0) > 0])
            self.metrics['avg_time_to_exploit'] = (current_avg * (count - 1) + campaign_metrics['time_to_exploit']) / count

    def get_orchestrator_status(self) -> Dict[str, Any]:
        """Get current orchestrator status and metrics."""
        return {
            'active_campaigns': len(self.active_campaigns),
            'total_campaigns_executed': self.metrics['campaigns_executed'],
            'overall_success_rate': self.metrics['success_rate'],
            'average_time_to_exploit': self.metrics['avg_time_to_exploit'],
            'ai_accuracy': self.metrics['ai_accuracy'],
            'components_status': {
                'payload_engine': self.payload_engine is not None,
                'c2_manager': self.c2_manager is not None,
                'persistence_manager': self.persistence_manager is not None,
                'privesc_manager': self.privesc_manager is not None,
                'lateral_manager': self.lateral_manager is not None,
                'research_manager': self.research_manager is not None,
                'ml_engine': self.ml_engine is not None,
                'vuln_research_ai': self.vuln_research_ai is not None
            }
        }

    def get_campaign_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent campaign history."""
        return self.exploitation_history[-limit:] if self.exploitation_history else []
