"""Vulnerability research integration for Intellicrack AI components.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import os
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

"""
Licensing Protection Analysis AI Integration

Integrates AI-powered analysis capabilities with Intellicrack for automated
detection and analysis of software licensing protection mechanisms.
"""

logger = logging.getLogger(__name__)


class LicensingProtectionAnalyzer:
    """AI-powered analysis of software licensing protection mechanisms."""

    def __init__(self) -> None:
        """Initialize the licensing protection analyzer system.

        Sets up analysis components for detecting and analyzing
        software licensing, registration, and activation systems.
        """
        self.logger = logging.getLogger("IntellicrackLogger.LicensingProtectionAnalyzer")

        # AI workflow configuration for licensing analysis
        self.config = {
            "auto_analysis_threshold": 0.7,
            "pattern_confidence_threshold": 0.8,
            "max_analysis_attempts": 3,
            "adaptive_strategy_enabled": True,
            "real_time_learning": True,
            "automated_reporting": True,
        }

        # Workflow state for tracking analysis
        self.active_workflows: Dict[str, Any] = {}
        self.analysis_history: List[Dict[str, Any]] = []
        self.ai_recommendations: List[Dict[str, Any]] = []

        # Licensing protection patterns database
        self.protection_patterns = {
            "serial_validation": ["serial", "license", "key", "activation", "register", "validate", "check", "verify", "product", "code"],
            "trial_limitations": ["trial", "expire", "days", "evaluation", "demo", "limit", "countdown", "remaining", "period", "grace"],
            "online_activation": [
                "activate",
                "server",
                "online",
                "internet",
                "connect",
                "auth",
                "token",
                "refresh",
                "callback",
                "heartbeat",
            ],
            "hardware_binding": ["hwid", "machine", "hardware", "bind", "fingerprint", "uuid", "mac", "cpu", "disk", "volume"],
            "subscription": ["subscription", "renew", "payment", "billing", "plan", "tier", "premium", "pro", "enterprise", "monthly"],
        }

    def analyze_licensing_protection(self, target_path: str, analysis_options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Perform AI-guided analysis of licensing protection mechanisms.

        Args:
            target_path: Path to target binary
            analysis_options: Optional analysis configuration

        Returns:
            Comprehensive analysis results with AI recommendations

        """
        result = {
            "success": False,
            "target_path": target_path,
            "analysis_results": {},
            "protection_mechanisms": [],
            "ai_recommendations": [],
            "bypass_strategies": [],
            "risk_assessment": {},
            "automated_actions": [],
            "error": None,
        }

        try:
            self.logger.info(f"Starting licensing protection analysis of: {target_path}")

            # Verify file exists
            if not os.path.exists(target_path):
                result["error"] = f"Target file not found: {target_path}"
                return result

            # Step 1: Initial licensing mechanism detection
            initial_analysis = self._perform_initial_licensing_analysis(target_path, analysis_options)
            result["analysis_results"]["initial"] = initial_analysis

            # Step 2: AI-powered pattern recognition
            ai_patterns = self._detect_licensing_patterns_with_ai(target_path, initial_analysis)
            result["analysis_results"]["ai_patterns"] = ai_patterns

            # Step 3: Protection mechanism classification
            protection_mechanisms = self._classify_protection_mechanisms(initial_analysis, ai_patterns)
            result["protection_mechanisms"] = protection_mechanisms

            # Step 4: Generate AI recommendations for bypassing
            ai_recommendations = self._generate_bypass_recommendations(initial_analysis, ai_patterns, protection_mechanisms)
            result["ai_recommendations"] = ai_recommendations

            # Step 5: Risk assessment for licensing bypass
            risk_assessment = self._perform_bypass_risk_assessment(target_path, protection_mechanisms)
            result["risk_assessment"] = risk_assessment

            # Step 6: Generate bypass strategies
            bypass_strategies = self._generate_bypass_strategies(target_path, protection_mechanisms, risk_assessment)
            result["bypass_strategies"] = bypass_strategies

            # Step 7: Automated analysis actions (if enabled)
            if self.config["adaptive_strategy_enabled"]:
                automated_actions = self._execute_automated_analysis(target_path, ai_recommendations, risk_assessment)
                result["automated_actions"] = automated_actions

            result["success"] = True

            # Log AI workflow
            self._log_ai_workflow(target_path, result)

            self.logger.info(f"Licensing analysis completed for: {target_path}")

        except Exception as e:
            self.logger.error(f"Licensing analysis failed: {e}")
            result["error"] = str(e)

        return result

    def _perform_initial_licensing_analysis(self, target_path: str, options: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Perform initial analysis to detect licensing mechanisms."""
        analysis_result = {
            "success": False,
            "licensing_indicators": [],
            "string_analysis": {},
            "import_analysis": {},
            "code_patterns": [],
            "error": None,
        }

        try:
            # Get file information
            os.path.getsize(target_path)
            Path(target_path).suffix.lower()

            # Analyze binary for licensing-related strings
            licensing_strings = self._extract_licensing_strings(target_path)
            analysis_result["string_analysis"] = {
                "total_strings": len(licensing_strings),
                "licensing_related": licensing_strings[:100],  # Limit for performance
                "categories": self._categorize_strings(licensing_strings),
            }

            # Analyze imports for licensing-related APIs
            import_indicators = self._analyze_imports_for_licensing(target_path)
            analysis_result["import_analysis"] = import_indicators

            # Detect common licensing code patterns
            code_patterns = self._detect_licensing_code_patterns(target_path)
            analysis_result["code_patterns"] = code_patterns

            # Identify licensing indicators
            indicators = []

            # Check for serial validation patterns
            if any(s for s in licensing_strings if "serial" in s.lower() or "license" in s.lower()):
                indicators.append({"type": "serial_validation", "confidence": 0.9, "evidence": "Serial/license strings detected"})

            # Check for trial limitations
            if any(s for s in licensing_strings if "trial" in s.lower() or "expire" in s.lower()):
                indicators.append({"type": "trial_limitation", "confidence": 0.85, "evidence": "Trial/expiration strings detected"})

            # Check for online activation
            if any(s for s in licensing_strings if "activate" in s.lower() or "server" in s.lower()):
                indicators.append({"type": "online_activation", "confidence": 0.8, "evidence": "Activation/server strings detected"})

            analysis_result["licensing_indicators"] = indicators
            analysis_result["success"] = True

        except Exception as e:
            self.logger.error(f"Initial licensing analysis failed: {e}")
            analysis_result["error"] = str(e)

        return analysis_result

    def _extract_licensing_strings(self, target_path: str) -> List[str]:
        """Extract licensing-related strings from binary."""
        licensing_strings = []

        try:
            # Read binary file and extract printable strings
            with open(target_path, "rb") as f:
                data = f.read()

            # Simple string extraction (would use proper tools in production)
            import string

            printable = set(string.printable.encode("ascii"))

            current_string = []
            for byte in data:
                if byte in printable:
                    current_string.append(chr(byte))
                else:
                    if len(current_string) > 4:  # Minimum string length
                        s = "".join(current_string)
                        # Check if string is licensing-related
                        for _category, keywords in self.protection_patterns.items():
                            if any(kw in s.lower() for kw in keywords):
                                licensing_strings.append(s)
                                break
                    current_string = []

        except Exception as e:
            self.logger.error(f"String extraction failed: {e}")

        return licensing_strings[:1000]  # Limit for performance

    def _categorize_strings(self, strings: List[str]) -> Dict[str, List[str]]:
        """Categorize strings by licensing protection type."""
        categories = {category: [] for category in self.protection_patterns}

        for s in strings:
            s_lower = s.lower()
            for category, keywords in self.protection_patterns.items():
                if any(kw in s_lower for kw in keywords):
                    categories[category].append(s)

        return categories

    def _analyze_imports_for_licensing(self, target_path: str) -> Dict[str, Any]:
        """Analyze imports for licensing-related APIs."""
        import_analysis = {"registry_apis": [], "crypto_apis": [], "network_apis": [], "time_apis": [], "hardware_apis": []}

        # Common licensing-related API patterns
        api_patterns = {
            "registry_apis": ["RegOpenKey", "RegQueryValue", "RegSetValue", "RegCreateKey"],
            "crypto_apis": ["CryptGenKey", "CryptEncrypt", "MD5", "SHA", "AES", "RSA"],
            "network_apis": ["InternetOpen", "HttpSendRequest", "socket", "connect", "SSL"],
            "time_apis": ["GetSystemTime", "GetLocalTime", "time", "clock", "timer"],
            "hardware_apis": ["GetVolumeInformation", "GetComputerName", "GetAdaptersInfo", "cpuid"],
        }

        # Check for API usage patterns (simplified - would use proper PE analysis in production)
        try:
            with open(target_path, "rb") as f:
                data = f.read()
                data_str = str(data)

                for category, apis in api_patterns.items():
                    for api in apis:
                        if api.encode() in data or api in data_str:
                            import_analysis[category].append(api)

        except Exception as e:
            self.logger.error(f"Import analysis failed: {e}")

        return import_analysis

    def _detect_licensing_code_patterns(self, target_path: str) -> List[Dict[str, Any]]:
        """Detect common licensing protection code patterns."""
        patterns = []

        # Common patterns in licensing protection
        pattern_signatures = [
            {"name": "Serial validation loop", "description": "Loop structure checking serial key characters", "confidence": 0.0},
            {"name": "Date/time comparison", "description": "Comparing dates for trial expiration", "confidence": 0.0},
            {"name": "Hardware fingerprint generation", "description": "Collecting hardware information for binding", "confidence": 0.0},
            {"name": "Network activation call", "description": "HTTP/HTTPS call for license activation", "confidence": 0.0},
            {"name": "Registry license storage", "description": "Storing license data in Windows registry", "confidence": 0.0},
        ]

        # Analyze binary for pattern signatures (simplified)
        try:
            file_size = os.path.getsize(target_path)

            # Heuristic confidence based on file characteristics
            for pattern in pattern_signatures:
                if file_size > 100 * 1024:  # Files > 100KB likely have licensing
                    pattern["confidence"] = 0.6
                    patterns.append(pattern)

        except Exception as e:
            self.logger.error(f"Pattern detection failed: {e}")

        return patterns

    def _detect_licensing_patterns_with_ai(self, target_path: str, initial_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Use AI to detect licensing protection patterns."""
        ai_patterns = {"success": False, "detected_patterns": [], "confidence_scores": {}, "insights": [], "error": None}

        try:
            # Analyze initial results for pattern recognition
            initial_analysis.get("licensing_indicators", [])
            string_categories = initial_analysis.get("string_analysis", {}).get("categories", {})

            detected_patterns = []
            confidence_scores = {}

            # Pattern recognition based on string analysis
            if string_categories.get("serial_validation"):
                detected_patterns.append("serial_key_validation")
                confidence_scores["serial_key_validation"] = min(0.95, len(string_categories["serial_validation"]) * 0.1)

            if string_categories.get("trial_limitations"):
                detected_patterns.append("trial_period_check")
                confidence_scores["trial_period_check"] = min(0.9, len(string_categories["trial_limitations"]) * 0.15)

            if string_categories.get("online_activation"):
                detected_patterns.append("online_license_activation")
                confidence_scores["online_license_activation"] = min(0.85, len(string_categories["online_activation"]) * 0.12)

            if string_categories.get("hardware_binding"):
                detected_patterns.append("hardware_id_binding")
                confidence_scores["hardware_id_binding"] = min(0.88, len(string_categories["hardware_binding"]) * 0.13)

            # Generate insights based on patterns
            insights = []
            if "serial_key_validation" in detected_patterns:
                insights.append("Serial key validation detected - keygen approach recommended")
            if "trial_period_check" in detected_patterns:
                insights.append("Trial limitations present - time manipulation or patch required")
            if "online_license_activation" in detected_patterns:
                insights.append("Online activation detected - server emulation or patch needed")
            if "hardware_id_binding" in detected_patterns:
                insights.append("Hardware binding present - HWID spoofing or patch required")

            ai_patterns["success"] = True
            ai_patterns["detected_patterns"] = detected_patterns
            ai_patterns["confidence_scores"] = confidence_scores
            ai_patterns["insights"] = insights

        except Exception as e:
            self.logger.error(f"AI pattern detection failed: {e}")
            ai_patterns["error"] = str(e)

        return ai_patterns

    def _classify_protection_mechanisms(self, initial_analysis: Dict[str, Any], ai_patterns: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Classify detected protection mechanisms."""
        mechanisms = []

        # Combine analysis results
        initial_analysis.get("licensing_indicators", [])
        detected_patterns = ai_patterns.get("detected_patterns", [])
        confidence_scores = ai_patterns.get("confidence_scores", {})

        # Classification based on detected patterns
        if "serial_key_validation" in detected_patterns:
            mechanisms.append(
                {
                    "type": "Serial Key Protection",
                    "complexity": "medium",
                    "confidence": confidence_scores.get("serial_key_validation", 0.5),
                    "bypass_methods": ["Keygen creation", "Patch validation routine", "Memory patching"],
                    "tools_required": ["IDA Pro", "x64dbg", "Python for keygen"],
                }
            )

        if "trial_period_check" in detected_patterns:
            mechanisms.append(
                {
                    "type": "Trial Period Limitation",
                    "complexity": "low",
                    "confidence": confidence_scores.get("trial_period_check", 0.5),
                    "bypass_methods": ["System time manipulation", "Registry cleaning", "Patch time check"],
                    "tools_required": ["Process Monitor", "Registry Editor", "Hex editor"],
                }
            )

        if "online_license_activation" in detected_patterns:
            mechanisms.append(
                {
                    "type": "Online Activation",
                    "complexity": "high",
                    "confidence": confidence_scores.get("online_license_activation", 0.5),
                    "bypass_methods": ["Server emulation", "Response patching", "Offline activation patch"],
                    "tools_required": ["Wireshark", "Burp Suite", "IDA Pro"],
                }
            )

        if "hardware_id_binding" in detected_patterns:
            mechanisms.append(
                {
                    "type": "Hardware ID Binding",
                    "complexity": "medium",
                    "confidence": confidence_scores.get("hardware_id_binding", 0.5),
                    "bypass_methods": ["HWID spoofing", "Patch HWID check", "Virtual machine isolation"],
                    "tools_required": ["HWID spoofer", "x64dbg", "VMware/VirtualBox"],
                }
            )

        # Sort by confidence
        mechanisms.sort(key=lambda x: x["confidence"], reverse=True)

        return mechanisms

    def _generate_bypass_recommendations(
        self, initial_analysis: Dict[str, Any], ai_patterns: Dict[str, Any], protection_mechanisms: List[Dict[str, Any]]
    ) -> List[str]:
        """Generate AI-powered recommendations for bypassing protections."""
        recommendations = []

        try:
            # Priority recommendations based on protection types
            for mechanism in protection_mechanisms:
                mech_type = mechanism["type"]
                confidence = mechanism["confidence"]

                if confidence > 0.8:
                    prefix = "HIGH CONFIDENCE"
                elif confidence > 0.6:
                    prefix = "MEDIUM CONFIDENCE"
                else:
                    prefix = "LOW CONFIDENCE"

                if mech_type == "Serial Key Protection":
                    recommendations.append(
                        f"{prefix}: Serial key protection detected - Recommend analyzing key validation algorithm for keygen creation"
                    )
                elif mech_type == "Trial Period Limitation":
                    recommendations.append(f"{prefix}: Trial limitation detected - Recommend locating time check functions for patching")
                elif mech_type == "Online Activation":
                    recommendations.append(f"{prefix}: Online activation detected - Recommend capturing activation traffic for emulation")
                elif mech_type == "Hardware ID Binding":
                    recommendations.append(
                        f"{prefix}: Hardware binding detected - Recommend identifying HWID generation routine for spoofing"
                    )

            # General recommendations based on complexity
            complexity_levels = [m["complexity"] for m in protection_mechanisms]
            if "high" in complexity_levels:
                recommendations.append("Complex protection detected - Multi-layered approach recommended with debugging and patching")
            elif "medium" in complexity_levels:
                recommendations.append("Medium complexity protection - Standard patching techniques should be effective")
            else:
                recommendations.append("Simple protection scheme - Basic patching or configuration changes may suffice")

            # Tool recommendations
            import_analysis = initial_analysis.get("import_analysis", {})
            if import_analysis.get("crypto_apis"):
                recommendations.append(
                    "Cryptographic APIs detected - Static analysis with IDA Pro recommended for algorithm identification"
                )
            if import_analysis.get("network_apis"):
                recommendations.append("Network APIs detected - Network traffic analysis with Wireshark recommended")

        except Exception as e:
            self.logger.error(f"Failed to generate recommendations: {e}")
            recommendations.append(f"Error generating recommendations: {e}")

        return recommendations

    def _perform_bypass_risk_assessment(self, target_path: str, protection_mechanisms: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess risk level for bypassing licensing protections."""
        risk_assessment = {
            "overall_risk": "medium",
            "risk_score": 0.5,
            "risk_factors": [],
            "bypass_difficulty": "medium",
            "detection_probability": 0.3,
        }

        try:
            risk_score = 0.0
            risk_factors = []

            # Assess based on protection mechanisms
            for mechanism in protection_mechanisms:
                complexity = mechanism["complexity"]
                mech_type = mechanism["type"]

                if complexity == "high":
                    risk_score += 0.3
                    risk_factors.append(f"High complexity {mech_type}")
                elif complexity == "medium":
                    risk_score += 0.2
                    risk_factors.append(f"Medium complexity {mech_type}")
                else:
                    risk_score += 0.1
                    risk_factors.append(f"Low complexity {mech_type}")

            # Multiple protections increase difficulty
            if len(protection_mechanisms) > 3:
                risk_score += 0.2
                risk_factors.append("Multiple protection layers detected")

            # Online activation increases risk
            if any(m["type"] == "Online Activation" for m in protection_mechanisms):
                risk_score += 0.15
                risk_factors.append("Online activation requires network interaction")

            # Normalize risk score
            risk_score = min(1.0, max(0.0, risk_score))

            # Determine overall risk level
            if risk_score > 0.7:
                overall_risk = "high"
                bypass_difficulty = "hard"
            elif risk_score > 0.4:
                overall_risk = "medium"
                bypass_difficulty = "medium"
            else:
                overall_risk = "low"
                bypass_difficulty = "easy"

            risk_assessment.update(
                {
                    "overall_risk": overall_risk,
                    "risk_score": risk_score,
                    "risk_factors": risk_factors,
                    "bypass_difficulty": bypass_difficulty,
                    "detection_probability": risk_score * 0.5,  # Simplified calculation
                }
            )

        except Exception as e:
            self.logger.error(f"Risk assessment failed: {e}")
            risk_assessment["error"] = str(e)

        return risk_assessment

    def _generate_bypass_strategies(
        self, target_path: str, protection_mechanisms: List[Dict[str, Any]], risk_assessment: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Generate specific strategies for bypassing detected protections."""
        strategies = []

        for mechanism in protection_mechanisms:
            strategy = {
                "target_protection": mechanism["type"],
                "approach": self._determine_bypass_approach(mechanism),
                "confidence": mechanism["confidence"],
                "estimated_time": self._estimate_bypass_time(mechanism),
                "required_tools": mechanism["tools_required"],
                "steps": self._generate_bypass_steps(mechanism),
            }
            strategies.append(strategy)

        return strategies

    def _determine_bypass_approach(self, mechanism: Dict[str, Any]) -> str:
        """Determine the best approach for bypassing a protection mechanism."""
        mech_type = mechanism["type"]

        approach_map = {
            "Serial Key Protection": "Algorithm analysis and keygen development",
            "Trial Period Limitation": "Time-based restriction removal via patching",
            "Online Activation": "Server response emulation or offline patch",
            "Hardware ID Binding": "Hardware fingerprint spoofing or validation bypass",
        }

        return approach_map.get(mech_type, "Manual analysis and patching required")

    def _estimate_bypass_time(self, mechanism: Dict[str, Any]) -> str:
        """Estimate time required to bypass protection mechanism."""
        complexity = mechanism["complexity"]

        time_map = {"low": "30 minutes - 2 hours", "medium": "2-8 hours", "high": "8-24 hours"}

        return time_map.get(complexity, "Variable")

    def _generate_bypass_steps(self, mechanism: Dict[str, Any]) -> List[str]:
        """Generate step-by-step bypass instructions."""
        mech_type = mechanism["type"]

        steps_map = {
            "Serial Key Protection": [
                "Load binary in IDA Pro for static analysis",
                "Locate serial validation function using string references",
                "Analyze validation algorithm and constraints",
                "Develop keygen based on algorithm or patch validation",
                "Test with multiple generated keys",
            ],
            "Trial Period Limitation": [
                "Monitor registry/file access with Process Monitor",
                "Identify trial period storage location",
                "Locate time check functions in debugger",
                "Patch time comparison or extend trial period",
                "Verify bypass with system date changes",
            ],
            "Online Activation": [
                "Capture activation traffic with Wireshark",
                "Analyze request/response format",
                "Create local server emulator or patch network calls",
                "Redirect activation to local server or bypass entirely",
                "Test offline functionality",
            ],
            "Hardware ID Binding": [
                "Identify HWID generation routine in debugger",
                "Analyze hardware information collection",
                "Implement HWID spoofing or patch validation",
                "Test on different hardware configurations",
                "Ensure portability of bypass",
            ],
        }

        return steps_map.get(mech_type, ["Perform manual analysis", "Identify protection routine", "Develop bypass", "Test thoroughly"])

    def _execute_automated_analysis(
        self, target_path: str, ai_recommendations: List[str], risk_assessment: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Execute safe automated analysis actions."""
        actions = []

        risk_level = risk_assessment.get("overall_risk", "medium")

        if risk_level == "low":
            actions.append(
                {"action": "automated_string_extraction", "status": "completed", "result": "Extracted and categorized licensing strings"}
            )
            actions.append(
                {"action": "import_table_analysis", "status": "completed", "result": "Analyzed API imports for licensing functions"}
            )

        if risk_level in ["low", "medium"]:
            actions.append({"action": "pattern_matching", "status": "completed", "result": "Matched common licensing protection patterns"})

        actions.append(
            {
                "action": "recommendation_generation",
                "status": "completed",
                "result": f"Generated {len(ai_recommendations)} AI recommendations",
            }
        )

        return actions

    def _log_ai_workflow(self, target_path: str, result: Dict[str, Any]) -> None:
        """Log AI workflow for analysis and learning."""
        workflow_log = {
            "timestamp": time.time(),
            "target_path": target_path,
            "success": result["success"],
            "protection_mechanisms_found": len(result.get("protection_mechanisms", [])),
            "ai_recommendations_count": len(result.get("ai_recommendations", [])),
            "risk_score": result.get("risk_assessment", {}).get("risk_score", 0),
        }

        # Store in recommendations history
        self.ai_recommendations.append(workflow_log)

        # Limit history size
        if len(self.ai_recommendations) > 1000:
            self.ai_recommendations = self.ai_recommendations[-1000:]

        self.logger.info(f"Logged AI workflow for {target_path}")

    def get_analysis_insights(self, target_info: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Get AI insights and recommendations for licensing protection analysis.

        Args:
            target_info: Optional specific target information

        Returns:
            AI insights and recommendations

        """
        insights = {
            "global_insights": {
                "total_analyses": len(self.analysis_history),
                "common_protections": self._get_common_protections(),
                "success_rate": self._calculate_success_rate(),
            },
            "target_specific_insights": {},
            "recommendations": [],
            "trends": [],
            "optimization_suggestions": [],
        }

        try:
            # Target-specific insights
            if target_info:
                target_insights = self._generate_target_specific_insights(target_info)
                insights["target_specific_insights"] = target_insights

            # Analysis trends
            trends = self._analyze_protection_trends()
            insights["trends"] = trends

            # Generate strategic recommendations
            recommendations = self._generate_strategic_recommendations(insights)
            insights["recommendations"] = recommendations

            # Optimization suggestions
            optimizations = self._generate_optimization_suggestions()
            insights["optimization_suggestions"] = optimizations

        except Exception as e:
            self.logger.error(f"Failed to generate insights: {e}")
            insights["error"] = str(e)

        return insights

    def _get_common_protections(self) -> List[str]:
        """Identify most common protection mechanisms."""
        protection_counts = {}

        for analysis in self.analysis_history:
            mechanisms = analysis.get("protection_mechanisms", [])
            for mech in mechanisms:
                prot_type = mech.get("type")
                protection_counts[prot_type] = protection_counts.get(prot_type, 0) + 1

        # Return top 5 most common
        sorted_protections = sorted(protection_counts.items(), key=lambda x: x[1], reverse=True)
        return [p[0] for p in sorted_protections[:5]]

    def _calculate_success_rate(self) -> float:
        """Calculate analysis success rate."""
        if not self.analysis_history:
            return 0.0

        successful = sum(1 for a in self.analysis_history if a.get("success", False))
        return successful / len(self.analysis_history)

    def _generate_target_specific_insights(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate insights specific to target."""
        return {
            "platform": target_info.get("platform", "unknown"),
            "recommended_tools": self._recommend_tools_for_target(target_info),
            "estimated_complexity": self._estimate_target_complexity(target_info),
        }

    def _recommend_tools_for_target(self, target_info: Dict[str, Any]) -> List[str]:
        """Recommend tools based on target characteristics."""
        platform = target_info.get("platform", "windows")

        if platform == "windows":
            return ["x64dbg", "IDA Pro", "Process Monitor", "API Monitor"]
        elif platform == "linux":
            return ["GDB", "Radare2", "strace", "ltrace"]
        else:
            return ["IDA Pro", "Ghidra", "Binary Ninja"]

    def _estimate_target_complexity(self, target_info: Dict[str, Any]) -> str:
        """Estimate complexity of target protection."""
        # Simplified heuristic
        size = target_info.get("file_size", 0)

        if size > 50 * 1024 * 1024:  # > 50MB
            return "high"
        elif size > 5 * 1024 * 1024:  # > 5MB
            return "medium"
        else:
            return "low"

    def _analyze_protection_trends(self) -> List[Dict[str, str]]:
        """Analyze trends in protection mechanisms."""
        return [
            {"trend": "serial_key_usage", "direction": "decreasing", "timeframe": "last_year"},
            {"trend": "online_activation", "direction": "increasing", "timeframe": "last_year"},
            {"trend": "hardware_binding", "direction": "stable", "timeframe": "last_year"},
        ]

    def _generate_strategic_recommendations(self, insights: Dict[str, Any]) -> List[str]:
        """Generate strategic recommendations based on insights."""
        recommendations = []

        # Based on common protections
        common_protections = insights.get("global_insights", {}).get("common_protections", [])

        if "Online Activation" in common_protections:
            recommendations.append("Focus on developing server emulation capabilities")

        if "Hardware ID Binding" in common_protections:
            recommendations.append("Invest in HWID spoofing techniques and tools")

        if "Serial Key Protection" in common_protections:
            recommendations.append("Maintain keygen template library for common algorithms")

        # Based on success rate
        success_rate = insights.get("global_insights", {}).get("success_rate", 0)
        if success_rate < 0.7:
            recommendations.append("Consider expanding analysis tool capabilities")

        return recommendations

    def _generate_optimization_suggestions(self) -> List[str]:
        """Generate suggestions for optimizing analysis process."""
        return [
            "Automate initial string extraction and categorization",
            "Build pattern database from successful bypasses",
            "Implement parallel analysis for multiple protection layers",
            "Cache analysis results for similar binaries",
        ]
