"""Report Manager Dialog for Intellicrack.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import os
import shutil
import subprocess
import sys
import time
from datetime import datetime, timezone
from typing import Any

# Import common PyQt6 components
from intellicrack.handlers.pyqt6_handler import (
    HAS_PYQT,
    QCheckBox,
    QComboBox,
    QFileDialog,
    QFormLayout,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidgetItem,
    QMessageBox,
    QProgressBar,
    QPushButton,
    Qt,
    QTableWidget,
    QTableWidgetItem,
    QTextBrowser,
    QThread,
    QVBoxLayout,
    QWidget,
    pyqtSignal,
)

from .base_dialog import BaseDialog

logger = logging.getLogger(__name__)


class ReportGenerationThread(QThread):
    """Thread for generating reports without blocking the UI."""

    progress_updated = pyqtSignal(int)
    status_updated = pyqtSignal(str)
    generation_finished = pyqtSignal(bool, str, str)

    def __init__(self, report_config: dict[str, Any], output_path: str) -> None:
        """Initialize the ReportGenerationThread with default values."""
        super().__init__()
        self.report_config = report_config
        self.output_path = output_path

    def run(self) -> None:
        """Generate report in background thread."""
        try:
            self.status_updated.emit("Initializing report generation...")
            self.progress_updated.emit(10)

            # Simulate report generation steps
            self.status_updated.emit("Collecting analysis data...")
            self.progress_updated.emit(30)
            time.sleep(1)  # Simulate work

            self.status_updated.emit("Processing results...")
            self.progress_updated.emit(60)
            time.sleep(1)  # Simulate work

            self.status_updated.emit("Generating output...")
            self.progress_updated.emit(80)

            # Create a simple report file
            report_content = self.generate_report_content()

            with open(self.output_path, "w", encoding="utf-8") as f:
                f.write(report_content)

            self.progress_updated.emit(100)
            self.status_updated.emit("Report generation complete")
            self.generation_finished.emit(True, "Report generated successfully", self.output_path)

        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Error in report_manager_dialog: %s", e)
            self.generation_finished.emit(False, f"Report generation failed: {e!s}", "")

    def generate_report_content(self) -> str:
        """Generate report content based on configuration."""
        config = self.report_config

        content = f"""# Intellicrack Analysis Report

Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
Report Type: {config.get("type", "Unknown")}
Binary: {config.get("binary_path", "N/A")}

## Executive Summary

This report contains the analysis results for the specified binary file.

## Analysis Details

### Binary Information
- File: {config.get("binary_path", "N/A")}
- Size: {config.get("file_size", "Unknown")}
- MD5: {config.get("md5_hash", "N/A")}
- SHA256: {config.get("sha256_hash", "N/A")}

### Analysis Results
- Vulnerabilities Found: {config.get("vulnerabilities", 0)}
- Suspicious Patterns: {config.get("patterns", 0)}
- License Checks: {config.get("license_checks", 0)}

### Recommendations

Based on the analysis, the following recommendations are provided:

1. Review identified vulnerabilities
2. Implement security patches
3. Consider license compliance issues

## Detailed Findings

[Detailed analysis results would be included here]

## Conclusion

The analysis has been completed successfully. Please review the findings and implement the recommended security measures.

---
Generated by Intellicrack Analysis Platform
"""
        return content


class ReportManagerDialog(BaseDialog):
    """Dialog for managing Intellicrack reports."""

    def __init__(self, parent=None) -> None:
        """Initialize the ReportManagerDialog with default values."""
        # Initialize UI attributes
        self.binary_path_edit = None
        self.browse_binary_btn = None
        self.browse_output_btn = None
        self.create_template_btn = None
        self.delete_btn = None
        self.duplicate_btn = None
        self.edit_btn = None
        self.edit_template_btn = None
        self.generate_btn = None
        self.generation_thread = None
        self.include_detailed_logs = None
        self.include_executive_summary = None
        self.include_recommendations = None
        self.include_screenshots = None
        self.open_after_generation = None
        self.output_format_combo = None
        self.output_path_edit = None
        self.preview_btn = None
        self.progress_bar = None
        self.report_name_edit = None
        self.report_preview = None
        self.report_type_combo = None
        self.status_label = None
        self.template_description = None
        self.template_list = None
        self.use_template_btn = None
        self.view_btn = None
        super().__init__(parent)
        self.reports_dir = os.path.join(os.path.dirname(__file__), "..", "..", "..", "reports")
        self.reports = {}
        self.current_report = None

        self.setup_ui()
        self.load_reports()
        self.refresh_report_list()

    # Note: finalize_widget_layout is now available in shared_ui_layouts.UILayoutHelpers

    def setup_ui(self) -> None:
        """Set up the user interface."""
        if not HAS_PYQT:
            logger.warning("PyQt6 not available, cannot create report manager dialog")
            return

        from ..shared_ui_layouts import UILayoutHelpers

        # Create main tabbed dialog layout
        layout, self.tab_widget = UILayoutHelpers.create_tabbed_dialog_layout(
            self,
            "Report Manager",
            (1000, 700),
            is_modal=True,
        )

        # Create and add tabs
        tab_specs = [
            ("Reports", self.create_reports_tab()),
            ("Generate Report", self.create_generate_tab()),
            ("Templates", self.create_templates_tab()),
        ]
        UILayoutHelpers.create_tabs_from_specs(self.tab_widget, tab_specs)

        # Create dialog buttons
        button_specs = [
            ("Refresh", self.refresh_report_list, False),
            ("Export Report...", self.export_report, False),
            ("Close", self.accept, True),
        ]
        buttons = UILayoutHelpers.create_dialog_buttons(button_specs, layout)

        # Store button references
        self.refresh_btn, self.export_btn, self.close_btn = buttons

        self.setLayout(layout)

    def create_reports_tab(self):
        """Create the reports list tab."""
        widget = QWidget()
        layout = QVBoxLayout()

        # Search and filter
        search_layout = QHBoxLayout()

        search_label = QLabel("Search:")
        self.search_edit = QLineEdit()
        self.search_edit.textChanged.connect(self.filter_reports)

        type_label = QLabel("Type:")
        self.type_filter = QComboBox()
        self.type_filter.addItems(["All", "Vulnerability", "License", "Performance", "Custom"])
        self.type_filter.currentTextChanged.connect(self.filter_reports)

        date_label = QLabel("Date:")
        self.date_filter = QComboBox()
        self.date_filter.addItems(["All", "Today", "This Week", "This Month", "Custom"])
        self.date_filter.currentTextChanged.connect(self.filter_reports)

        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_edit)
        search_layout.addWidget(type_label)
        search_layout.addWidget(self.type_filter)
        search_layout.addWidget(date_label)
        search_layout.addWidget(self.date_filter)
        search_layout.addStretch()

        layout.addLayout(search_layout)

        # Reports table
        self.reports_table = QTableWidget()
        self.reports_table.setColumnCount(6)
        self.reports_table.setHorizontalHeaderLabels(
            [
                "Name",
                "Type",
                "Created",
                "Size",
                "Status",
                "Actions",
            ],
        )
        self.reports_table.horizontalHeader().setStretchLastSection(True)
        self.reports_table.itemSelectionChanged.connect(self.on_report_selected)
        layout.addWidget(self.reports_table)

        # Report preview
        preview_group = QGroupBox("Report Preview")
        preview_layout = QVBoxLayout()

        self.report_preview = QTextBrowser()
        self.report_preview.setMaximumHeight(200)
        preview_layout.addWidget(self.report_preview)

        preview_group.setLayout(preview_layout)
        layout.addWidget(preview_group)

        # Report actions
        actions_layout = QHBoxLayout()

        self.view_btn = QPushButton("View Report")
        self.view_btn.clicked.connect(self.view_report)
        self.view_btn.setEnabled(False)

        self.edit_btn = QPushButton("Edit Report")
        self.edit_btn.clicked.connect(self.edit_report)
        self.edit_btn.setEnabled(False)

        self.duplicate_btn = QPushButton("Duplicate")
        self.duplicate_btn.clicked.connect(self.duplicate_report)
        self.duplicate_btn.setEnabled(False)

        self.delete_btn = QPushButton("Delete")
        self.delete_btn.clicked.connect(self.delete_report)
        self.delete_btn.setEnabled(False)

        actions_layout.addWidget(self.view_btn)
        actions_layout.addWidget(self.edit_btn)
        actions_layout.addWidget(self.duplicate_btn)
        actions_layout.addWidget(self.delete_btn)
        actions_layout.addStretch()

        layout.addLayout(actions_layout)

        widget.setLayout(layout)
        return widget

    def create_generate_tab(self):
        """Create the generate report tab."""
        widget = QWidget()
        layout = QVBoxLayout()

        # Report configuration
        config_group = QGroupBox("Report Configuration")
        config_layout = QFormLayout()

        self.report_name_edit = QLineEdit()
        self.report_type_combo = QComboBox()
        self.report_type_combo.addItems(["Vulnerability Analysis", "License Analysis", "Performance Analysis", "Custom"])

        self.binary_path_edit = QLineEdit()
        self.browse_binary_btn = QPushButton("Browse...")
        self.browse_binary_btn.clicked.connect(self.browse_binary)

        binary_layout = QHBoxLayout()
        binary_layout.addWidget(self.binary_path_edit)
        binary_layout.addWidget(self.browse_binary_btn)

        self.include_screenshots = QCheckBox("Include Screenshots")
        self.include_detailed_logs = QCheckBox("Include Detailed Logs")
        self.include_recommendations = QCheckBox("Include Recommendations")
        self.include_executive_summary = QCheckBox("Include Executive Summary")

        config_layout.addRow("Report Name:", self.report_name_edit)
        config_layout.addRow("Report Type:", self.report_type_combo)
        config_layout.addRow("Binary File:", binary_layout)
        config_layout.addRow("", self.include_screenshots)
        config_layout.addRow("", self.include_detailed_logs)
        config_layout.addRow("", self.include_recommendations)
        config_layout.addRow("", self.include_executive_summary)

        config_group.setLayout(config_layout)
        layout.addWidget(config_group)

        # Output options
        output_group = QGroupBox("Output Options")
        output_layout = QFormLayout()

        self.output_format_combo = QComboBox()
        self.output_format_combo.addItems(["PDF", "HTML", "Markdown", "Text"])

        self.output_path_edit = QLineEdit()
        self.browse_output_btn = QPushButton("Browse...")
        self.browse_output_btn.clicked.connect(self.browse_output)

        output_path_layout = QHBoxLayout()
        output_path_layout.addWidget(self.output_path_edit)
        output_path_layout.addWidget(self.browse_output_btn)

        self.open_after_generation = QCheckBox("Open report after generation")

        output_layout.addRow("Output Format:", self.output_format_combo)
        output_layout.addRow("Output Path:", output_path_layout)
        output_layout.addRow("", self.open_after_generation)

        output_group.setLayout(output_layout)
        layout.addWidget(output_group)

        # Generation controls
        generation_layout = QHBoxLayout()

        self.generate_btn = QPushButton("Generate Report")
        self.generate_btn.clicked.connect(self.generate_report)

        self.preview_btn = QPushButton("Preview")
        self.preview_btn.clicked.connect(self.preview_report)

        generation_layout.addWidget(self.generate_btn)
        generation_layout.addWidget(self.preview_btn)
        generation_layout.addStretch()

        layout.addLayout(generation_layout)

        # Progress bar (initially hidden)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Status label
        self.status_label = QLabel("")
        layout.addWidget(self.status_label)

        from ..shared_ui_layouts import UILayoutHelpers

        return UILayoutHelpers.finalize_widget_layout(widget, layout)

    def create_templates_tab(self):
        """Create the templates tab."""
        templates = [
            "Vulnerability Assessment Report",
            "License Compliance Report",
            "Performance Analysis Report",
            "Executive Summary Report",
            "Technical Deep Dive Report",
        ]

        # Use base class to create template widget
        widget = self.create_template_widget("Report Templates", templates)

        # Update reference to template description
        self.template_description = self.template_details

        return widget

    def load_reports(self) -> None:
        """Load existing reports from the reports directory."""
        self.reports = {}

        if not os.path.exists(self.reports_dir):
            os.makedirs(self.reports_dir, exist_ok=True)
            return

        for _item in os.listdir(self.reports_dir):
            item_path = os.path.join(self.reports_dir, _item)

            if os.path.isfile(item_path):
                # Get file info
                stat = os.stat(item_path)

                # Determine report type from filename or content
                report_type = "Unknown"
                if "vulnerability" in _item.lower():
                    report_type = "Vulnerability"
                elif "license" in _item.lower():
                    report_type = "License"
                elif "performance" in _item.lower():
                    report_type = "Performance"

                self.reports[_item] = {
                    "name": _item,
                    "path": item_path,
                    "type": report_type,
                    "created": datetime.fromtimestamp(stat.st_ctime),
                    "modified": datetime.fromtimestamp(stat.st_mtime),
                    "size": stat.st_size,
                    "status": "Complete",
                }

    def refresh_report_list(self) -> None:
        """Refresh the reports list display."""
        self.load_reports()
        self.update_reports_table()

    def update_reports_table(self) -> None:
        """Update the reports table."""
        if not HAS_PYQT:
            return

        self.reports_table.setRowCount(len(self.reports))

        for row, (report_id, report_info) in enumerate(self.reports.items()):
            # Name
            name_item = QTableWidgetItem(report_info["name"])
            name_item.setData(Qt.UserRole, report_id)
            self.reports_table.setItem(row, 0, name_item)

            # Type
            type_item = QTableWidgetItem(report_info["type"])
            self.reports_table.setItem(row, 1, type_item)

            # Created
            created_str = report_info["created"].strftime("%Y-%m-%d %H:%M")
            created_item = QTableWidgetItem(created_str)
            self.reports_table.setItem(row, 2, created_item)

            # Size
            size_str = self.format_file_size(report_info["size"])
            size_item = QTableWidgetItem(size_str)
            self.reports_table.setItem(row, 3, size_item)

            # Status
            status_item = QTableWidgetItem(report_info["status"])
            self.reports_table.setItem(row, 4, status_item)

            # Actions
            actions_btn = QPushButton("Actions")
            self.reports_table.setCellWidget(row, 5, actions_btn)

    def format_file_size(self, size_bytes: int) -> str:
        """Format file size in human readable format."""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        if size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        return f"{size_bytes / (1024 * 1024):.1f} MB"

    def on_report_selected(self) -> None:
        """Handle report selection."""
        if not HAS_PYQT:
            return

        current_row = self.reports_table.currentRow()
        if current_row >= 0:
            name_item = self.reports_table.item(current_row, 0)
            if name_item:
                report_id = name_item.data(Qt.UserRole)
                self.current_report = report_id

                # Update preview
                self.update_report_preview(report_id)

                # Enable action buttons
                self.view_btn.setEnabled(True)
                self.edit_btn.setEnabled(True)
                self.duplicate_btn.setEnabled(True)
                self.delete_btn.setEnabled(True)

    def update_report_preview(self, report_id: str) -> None:
        """Update the report preview."""
        if report_id not in self.reports:
            return

        report_info = self.reports[report_id]
        report_path = report_info["path"]

        try:
            with open(report_path, encoding="utf-8") as f:
                content = f.read()

            # Show first 1000 characters
            preview = content[:1000]
            if len(content) > 1000:
                preview += "\n\n... (truncated)"

            self.report_preview.setPlainText(preview)

        except (OSError, ValueError, RuntimeError) as e:
            self.logger.error("Error in report_manager_dialog: %s", e)
            self.report_preview.setPlainText(f"Error loading preview: {e!s}")

    def filter_reports(self) -> None:
        """Filter reports based on search criteria."""
        # Get search criteria
        search_text = self.search_entry.text().lower()
        selected_type = self.filter_combo.currentText()
        from_date = self.from_date.date().toPyDate()
        to_date = self.to_date.date().toPyDate()

        # Clear current display
        self.report_list.clear()

        # Filter reports based on criteria
        filtered_reports = []

        for report in self.reports:
            # Check type filter
            if selected_type != "All Types" and report.get("type", "") != selected_type:
                continue

            # Check date range
            report_date = report.get("date")
            if report_date:
                try:
                    # Convert string date to date object if needed
                    if isinstance(report_date, str):
                        report_date_obj = datetime.strptime(report_date, "%Y-%m-%d").replace(tzinfo=timezone.utc).date()
                    else:
                        report_date_obj = report_date

                    if report_date_obj < from_date or report_date_obj > to_date:
                        continue
                except (ValueError, KeyError, TypeError) as e:
                    # Skip reports with invalid dates
                    logger.debug(f"Invalid date in report: {e}")
                    continue

            # Check search text in title and description
            if search_text:
                title_match = search_text in report.get("title", "").lower()
                desc_match = search_text in report.get("description", "").lower()
                target_match = search_text in report.get("target", "").lower()

                if not (title_match or desc_match or target_match):
                    continue

            # Report passed all filters
            filtered_reports.append(report)

        # Update report list with filtered results
        for report in filtered_reports:
            item = QListWidgetItem(report["title"])
            item.setData(Qt.ItemDataRole.UserRole, report)
            self.report_list.addItem(item)

        # Update status
        total = len(self.reports)
        filtered = len(filtered_reports)
        status_text = f"Showing {filtered} of {total} reports"
        if hasattr(self, "status_label"):
            self.status_label.setText(status_text)

    def view_report(self) -> None:
        """View the selected report."""
        if not self.current_report:
            return

        report_info = self.reports[self.current_report]
        report_path = report_info["path"]

        # Try to open with system default application
        try:
            if sys.platform == "win32":
                os.startfile(report_path)  # noqa: S606  # Legitimate report file opening for security research viewing
            elif sys.platform == "darwin":
                subprocess.run(["open", report_path], check=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis
            else:
                subprocess.run(["xdg-open", report_path], check=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis
        except (OSError, ValueError, RuntimeError) as e:
            self.logger.error("Error in report_manager_dialog: %s", e)
            if HAS_PYQT:
                QMessageBox.warning(self, "Warning", f"Could not open report: {e!s}")

    def edit_report(self) -> None:
        """Edit the selected report."""
        if HAS_PYQT:
            QMessageBox.information(self, "Edit Report", "Report editing functionality would be implemented here")

    def duplicate_report(self) -> None:
        """Duplicate the selected report."""
        if not self.current_report:
            return

        report_info = self.reports[self.current_report]
        original_path = report_info["path"]

        # Create new filename
        base_name = os.path.splitext(self.current_report)[0]
        extension = os.path.splitext(self.current_report)[1]
        new_name = f"{base_name}_copy{extension}"
        new_path = os.path.join(self.reports_dir, new_name)

        try:
            shutil.copy2(original_path, new_path)
            self.refresh_report_list()

            if HAS_PYQT:
                QMessageBox.information(self, "Success", f"Report duplicated as: {new_name}")

        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Error in report_manager_dialog: %s", e)
            if HAS_PYQT:
                QMessageBox.critical(self, "Error", f"Failed to duplicate report: {e!s}")

    def delete_report(self) -> None:
        """Delete the selected report."""
        if not HAS_PYQT or not self.current_report:
            return

        reply = QMessageBox.question(
            self,
            "Confirm Delete",
            f"Are you sure you want to delete report '{self.current_report}'?",
            QMessageBox.Yes | QMessageBox.No,
        )

        if reply == QMessageBox.Yes:
            try:
                report_info = self.reports[self.current_report]
                os.remove(report_info["path"])

                self.refresh_report_list()
                self.report_preview.clear()

                # Disable action buttons
                self.view_btn.setEnabled(False)
                self.edit_btn.setEnabled(False)
                self.duplicate_btn.setEnabled(False)
                self.delete_btn.setEnabled(False)

                QMessageBox.information(self, "Success", "Report deleted successfully")

            except (OSError, ValueError, RuntimeError) as e:
                logger.error("Error in report_manager_dialog: %s", e)
                QMessageBox.critical(self, "Error", f"Failed to delete report: {e!s}")

    def browse_binary(self) -> None:
        """Browse for binary file."""
        if not HAS_PYQT:
            return

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Binary File",
            "",
            "Binary Files (*.exe *.dll *.so *.dylib);;All Files (*.*)",
        )

        if file_path:
            self.binary_path_edit.setText(file_path)

    def browse_output(self) -> None:
        """Browse for output directory."""
        if not HAS_PYQT:
            return

        dir_path = QFileDialog.getExistingDirectory(
            self,
            "Select Output Directory",
            self.reports_dir,
        )

        if dir_path:
            self.output_path_edit.setText(dir_path)

    def generate_report(self) -> None:
        """Generate a new report."""
        if not HAS_PYQT:
            return

        # Validate inputs
        if not self.report_name_edit.text().strip():
            QMessageBox.warning(self, "Warning", "Please enter a report name")
            return

        if not self.binary_path_edit.text().strip():
            QMessageBox.warning(self, "Warning", "Please select a binary file")
            return

        # Prepare report configuration
        config = {
            "name": self.report_name_edit.text().strip(),
            "type": self.report_type_combo.currentText(),
            "binary_path": self.binary_path_edit.text().strip(),
            "format": self.output_format_combo.currentText(),
            "include_screenshots": self.include_screenshots.isChecked(),
            "include_detailed_logs": self.include_detailed_logs.isChecked(),
            "include_recommendations": self.include_recommendations.isChecked(),
            "include_executive_summary": self.include_executive_summary.isChecked(),
        }

        # Determine output path
        output_dir = self.output_path_edit.text().strip() or self.reports_dir
        output_filename = f"{config['name']}.txt"  # Simplified for demo
        output_path = os.path.join(output_dir, output_filename)

        # Show progress
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.generate_btn.setEnabled(False)

        # Start generation thread
        self.generation_thread = ReportGenerationThread(config, output_path)
        self.generation_thread.progress_updated.connect(self.progress_bar.setValue)
        self.generation_thread.status_updated.connect(self.status_label.setText)
        self.generation_thread.generation_finished.connect(self.on_generation_finished)

        self.generation_thread.start()

    def on_generation_finished(self, success: bool, message: str, output_path: str) -> None:
        """Handle report generation completion."""
        if not HAS_PYQT:
            return

        self.progress_bar.setVisible(False)
        self.generate_btn.setEnabled(True)
        self.status_label.setText("")

        if success:
            QMessageBox.information(self, "Success", message)

            # Refresh reports list
            self.refresh_report_list()

            # Open report if requested
            if self.open_after_generation.isChecked() and output_path:
                try:
                    if sys.platform == "win32":
                        os.startfile(output_path)  # noqa: S606  # Legitimate report file opening for security research viewing
                    elif sys.platform == "darwin":
                        subprocess.run(["open", output_path], check=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis
                    else:
                        subprocess.run(["xdg-open", output_path], check=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis
                except Exception as e:
                    logger.error("Exception in report_manager_dialog: %s", e)
        else:
            QMessageBox.critical(self, "Error", message)

    def preview_report(self) -> None:
        """Preview the report before generation."""
        if HAS_PYQT:
            QMessageBox.information(self, "Preview", "Report preview functionality would be implemented here")

    def export_report(self) -> None:
        """Export the selected report."""
        if not HAS_PYQT or not self.current_report:
            return

        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Report",
            self.current_report,
            "All Files (*.*)",
        )

        if file_path:
            try:
                report_info = self.reports[self.current_report]
                shutil.copy2(report_info["path"], file_path)

                QMessageBox.information(self, "Success", f"Report exported to: {file_path}")

            except (OSError, ValueError, RuntimeError) as e:
                self.logger.error("Error in report_manager_dialog: %s", e)
                QMessageBox.critical(self, "Error", f"Failed to export report: {e!s}")

    def on_template_selected(self) -> None:
        """Handle template selection."""
        if not HAS_PYQT:
            return

        current_item = self.template_list.currentItem()
        if current_item:
            template_name = current_item.text()

            # Update template description
            descriptions = {
                "Vulnerability Assessment Report": "Comprehensive vulnerability analysis with risk ratings and remediation recommendations.",
                "License Compliance Report": "Analysis of license usage and compliance issues with legal recommendations.",
                "Performance Analysis Report": "Detailed performance metrics and optimization suggestions.",
                "Executive Summary Report": "High-level overview suitable for management and stakeholders.",
                "Technical Deep Dive Report": "Detailed technical analysis for security professionals and developers.",
            }

            description = descriptions.get(template_name, "No description available.")
            self.template_description.setPlainText(description)

            # Enable action buttons
            self.use_template_btn.setEnabled(True)
            self.edit_template_btn.setEnabled(True)

    def use_template(self) -> None:
        """Use the selected template for report generation."""
        current_item = self.template_list.currentItem()
        if current_item:
            template_name = current_item.text()

            # Switch to generate tab and populate fields
            self.tab_widget.setCurrentIndex(1)

            # Set report type based on template
            if "Vulnerability" in template_name:
                self.report_type_combo.setCurrentText("Vulnerability Analysis")
            elif "License" in template_name:
                self.report_type_combo.setCurrentText("License Analysis")
            elif "Performance" in template_name:
                self.report_type_combo.setCurrentText("Performance Analysis")

            # Set default options based on template
            if "Executive" in template_name:
                self.include_executive_summary.setChecked(True)
                self.include_detailed_logs.setChecked(False)
            elif "Technical" in template_name:
                self.include_detailed_logs.setChecked(True)
                self.include_screenshots.setChecked(True)

    def edit_template(self) -> None:
        """Edit the selected template."""
        if HAS_PYQT:
            QMessageBox.information(self, "Edit Template", "Template editing functionality would be implemented here")

    def create_template(self) -> None:
        """Create a new report template."""
        if HAS_PYQT:
            QMessageBox.information(self, "Create Template", "Template creation functionality would be implemented here")


# Export for external use
__all__ = ["ReportGenerationThread", "ReportManagerDialog"]
