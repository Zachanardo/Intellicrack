"""
Vulnerability Research Dialog

Advanced UI for managing vulnerability research campaigns, ML adaptation,
and automated exploitation workflows.
"""

import json
import logging
import time
from datetime import datetime
from typing import Any, Dict, List, Optional

from PyQt5.QtCore import Qt, QThread, QTimer, pyqtSignal
from PyQt5.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDialog,
    QFileDialog,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QSplitter,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTextEdit,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
)

# Import research components
try:
    from ...core.vulnerability_research.binary_differ import BinaryDiffer
    from ...core.vulnerability_research.fuzzing_engine import FuzzingEngine, FuzzingStrategy
    from ...core.vulnerability_research.ml_adaptation_engine import (
        AdaptationStrategy,
        MLAdaptationEngine,
    )
    from ...core.vulnerability_research.research_manager import (
        CampaignStatus,
        CampaignType,
        ResearchManager,
    )
    from ...core.vulnerability_research.vulnerability_analyzer import (
        AnalysisMethod,
        VulnerabilityAnalyzer,
    )
    RESEARCH_AVAILABLE = True
except ImportError:
    RESEARCH_AVAILABLE = False

logger = logging.getLogger(__name__)


class ResearchWorkerThread(QThread):
    """Background worker for research operations."""

    campaign_updated = pyqtSignal(str, dict)  # campaign_id, status
    results_ready = pyqtSignal(str, dict)     # campaign_id, results
    error_occurred = pyqtSignal(str, str)     # operation, error_message
    adaptation_complete = pyqtSignal(dict)     # adaptation_results

    def __init__(self):
        super().__init__()
        self.research_manager = ResearchManager() if RESEARCH_AVAILABLE else None
        self.ml_engine = MLAdaptationEngine() if RESEARCH_AVAILABLE else None
        self.operation_queue = []
        self.running = True

    def add_operation(self, operation_type: str, **kwargs):
        """Add operation to processing queue."""
        self.operation_queue.append({
            'type': operation_type,
            'args': kwargs,
            'timestamp': time.time()
        })

    def run(self):
        """Main worker thread loop."""
        while self.running:
            if self.operation_queue:
                operation = self.operation_queue.pop(0)
                self._process_operation(operation)
            else:
                self.msleep(100)  # Sleep 100ms when idle

    def _process_operation(self, operation: Dict[str, Any]):
        """Process a single operation."""
        try:
            op_type = operation['type']
            args = operation['args']

            if op_type == 'create_campaign':
                self._create_campaign(**args)
            elif op_type == 'start_campaign':
                self._start_campaign(**args)
            elif op_type == 'adapt_strategy':
                self._adapt_strategy(**args)
            elif op_type == 'train_models':
                self._train_models(**args)

        except Exception as e:
            self.error_occurred.emit(operation['type'], str(e))

    def _create_campaign(self, name: str, campaign_type: str, targets: List[str],
                        template: Optional[str] = None, config: Optional[Dict] = None):
        """Create research campaign."""
        if not self.research_manager:
            self.error_occurred.emit('create_campaign', 'Research manager not available')
            return

        campaign_type_enum = CampaignType(campaign_type)
        result = self.research_manager.create_campaign(
            name=name,
            campaign_type=campaign_type_enum,
            targets=targets,
            template=template,
            custom_config=config
        )

        if result['success']:
            self.campaign_updated.emit(result['campaign_id'], result)
        else:
            self.error_occurred.emit('create_campaign', result.get('error', 'Unknown error'))

    def _start_campaign(self, campaign_id: str):
        """Start research campaign."""
        if not self.research_manager:
            self.error_occurred.emit('start_campaign', 'Research manager not available')
            return

        result = self.research_manager.start_campaign(campaign_id)

        if result['success']:
            self.results_ready.emit(campaign_id, result['results'])
        else:
            self.error_occurred.emit('start_campaign', result.get('error', 'Unknown error'))

    def _adapt_strategy(self, target_info: Dict, previous_attempts: List[Dict],
                       strategy: str):
        """Perform ML strategy adaptation."""
        if not self.ml_engine:
            self.error_occurred.emit('adapt_strategy', 'ML engine not available')
            return

        strategy_enum = AdaptationStrategy(strategy)
        result = self.ml_engine.adapt_exploitation_strategy(
            target_info=target_info,
            previous_attempts=previous_attempts,
            strategy=strategy_enum
        )

        self.adaptation_complete.emit(result)

    def _train_models(self, training_data: Optional[Dict] = None):
        """Train ML models."""
        if not self.ml_engine:
            self.error_occurred.emit('train_models', 'ML engine not available')
            return

        result = self.ml_engine.train_adaptation_models(training_data)
        self.adaptation_complete.emit(result)

    def stop(self):
        """Stop worker thread."""
        self.running = False


class VulnerabilityResearchDialog(QDialog):
    """
    Main dialog for vulnerability research and ML adaptation.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Vulnerability Research & ML Adaptation")
        self.setMinimumSize(1400, 900)

        # Initialize components
        self.research_manager = ResearchManager() if RESEARCH_AVAILABLE else None
        self.ml_engine = MLAdaptationEngine() if RESEARCH_AVAILABLE else None

        # Active campaigns and results
        self.active_campaigns = {}
        self.campaign_results = {}

        # Worker thread
        self.worker = ResearchWorkerThread()
        self.worker.campaign_updated.connect(self._on_campaign_updated)
        self.worker.results_ready.connect(self._on_results_ready)
        self.worker.error_occurred.connect(self._on_error_occurred)
        self.worker.adaptation_complete.connect(self._on_adaptation_complete)
        self.worker.start()

        # Update timer
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self._update_campaign_status)
        self.update_timer.start(2000)  # Update every 2 seconds

        self._setup_ui()
        self._load_initial_data()

    def _setup_ui(self):
        """Setup user interface."""
        layout = QVBoxLayout(self)

        # Main tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)

        # Research campaigns tab
        self.campaigns_tab = self._create_campaigns_tab()
        self.tab_widget.addTab(self.campaigns_tab, "Research Campaigns")

        # ML adaptation tab
        self.ml_tab = self._create_ml_adaptation_tab()
        self.tab_widget.addTab(self.ml_tab, "ML Adaptation")

        # Results analysis tab
        self.results_tab = self._create_results_tab()
        self.tab_widget.addTab(self.results_tab, "Results & Analysis")

        # Configuration tab
        self.config_tab = self._create_configuration_tab()
        self.tab_widget.addTab(self.config_tab, "Configuration")

        # Button layout
        button_layout = QHBoxLayout()

        self.export_btn = QPushButton("Export Results")
        self.export_btn.clicked.connect(self._export_results)
        button_layout.addWidget(self.export_btn)

        button_layout.addStretch()

        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        button_layout.addWidget(self.close_btn)

        layout.addLayout(button_layout)

    def _create_campaigns_tab(self) -> QWidget:
        """Create research campaigns tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Campaign creation section
        creation_group = QGroupBox("Create New Campaign")
        creation_layout = QGridLayout(creation_group)

        # Campaign details
        creation_layout.addWidget(QLabel("Campaign Name:"), 0, 0)
        self.campaign_name_edit = QLineEdit()
        creation_layout.addWidget(self.campaign_name_edit, 0, 1)

        creation_layout.addWidget(QLabel("Campaign Type:"), 1, 0)
        self.campaign_type_combo = QComboBox()
        self.campaign_type_combo.addItems([
            "Binary Analysis", "Fuzzing", "Vulnerability Assessment",
            "Patch Analysis", "Hybrid Research"
        ])
        creation_layout.addWidget(self.campaign_type_combo, 1, 1)

        creation_layout.addWidget(QLabel("Template:"), 2, 0)
        self.template_combo = QComboBox()
        self.template_combo.addItems([
            "None", "Basic Fuzzing", "Comprehensive Analysis", "Patch Research"
        ])
        creation_layout.addWidget(self.template_combo, 2, 1)

        # Target selection
        creation_layout.addWidget(QLabel("Targets:"), 3, 0)
        self.targets_edit = QTextEdit()
        self.targets_edit.setMaximumHeight(80)
        self.targets_edit.setPlaceholderText("Enter target files/directories (one per line)")
        creation_layout.addWidget(self.targets_edit, 3, 1)

        # Buttons
        button_layout = QHBoxLayout()

        self.browse_targets_btn = QPushButton("Browse Targets")
        self.browse_targets_btn.clicked.connect(self._browse_targets)
        button_layout.addWidget(self.browse_targets_btn)

        self.create_campaign_btn = QPushButton("Create Campaign")
        self.create_campaign_btn.clicked.connect(self._create_campaign)
        button_layout.addWidget(self.create_campaign_btn)

        creation_layout.addLayout(button_layout, 4, 0, 1, 2)

        layout.addWidget(creation_group)

        # Active campaigns section
        campaigns_group = QGroupBox("Active Campaigns")
        campaigns_layout = QVBoxLayout(campaigns_group)

        # Campaign list
        self.campaigns_tree = QTreeWidget()
        self.campaigns_tree.setHeaderLabels([
            "Campaign", "Type", "Status", "Progress", "Targets", "Created"
        ])
        self.campaigns_tree.itemDoubleClicked.connect(self._show_campaign_details)
        campaigns_layout.addWidget(self.campaigns_tree)

        # Campaign controls
        controls_layout = QHBoxLayout()

        self.start_campaign_btn = QPushButton("Start")
        self.start_campaign_btn.clicked.connect(self._start_selected_campaign)
        controls_layout.addWidget(self.start_campaign_btn)

        self.pause_campaign_btn = QPushButton("Pause")
        self.pause_campaign_btn.clicked.connect(self._pause_selected_campaign)
        controls_layout.addWidget(self.pause_campaign_btn)

        self.cancel_campaign_btn = QPushButton("Cancel")
        self.cancel_campaign_btn.clicked.connect(self._cancel_selected_campaign)
        controls_layout.addWidget(self.cancel_campaign_btn)

        controls_layout.addStretch()

        self.refresh_campaigns_btn = QPushButton("Refresh")
        self.refresh_campaigns_btn.clicked.connect(self._refresh_campaigns)
        controls_layout.addWidget(self.refresh_campaigns_btn)

        campaigns_layout.addLayout(controls_layout)

        layout.addWidget(campaigns_group)

        return widget

    def _create_ml_adaptation_tab(self) -> QWidget:
        """Create ML adaptation tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Adaptation configuration
        config_group = QGroupBox("Adaptation Configuration")
        config_layout = QGridLayout(config_group)

        config_layout.addWidget(QLabel("Adaptation Strategy:"), 0, 0)
        self.adaptation_strategy_combo = QComboBox()
        self.adaptation_strategy_combo.addItems([
            "Exploit Optimization", "Vulnerability Prediction",
            "Evasion Adaptation", "Payload Evolution", "Target Profiling"
        ])
        config_layout.addWidget(self.adaptation_strategy_combo, 0, 1)

        config_layout.addWidget(QLabel("Target Information:"), 1, 0)
        self.target_info_edit = QTextEdit()
        self.target_info_edit.setMaximumHeight(100)
        self.target_info_edit.setPlaceholderText("Enter target information (JSON format)")
        config_layout.addWidget(self.target_info_edit, 1, 1)

        # Adaptation controls
        adapt_layout = QHBoxLayout()

        self.adapt_strategy_btn = QPushButton("Adapt Strategy")
        self.adapt_strategy_btn.clicked.connect(self._adapt_strategy)
        adapt_layout.addWidget(self.adapt_strategy_btn)

        self.predict_success_btn = QPushButton("Predict Success")
        self.predict_success_btn.clicked.connect(self._predict_success)
        adapt_layout.addWidget(self.predict_success_btn)

        adapt_layout.addStretch()

        config_layout.addLayout(adapt_layout, 2, 0, 1, 2)

        layout.addWidget(config_group)

        # Model management
        models_group = QGroupBox("ML Models")
        models_layout = QVBoxLayout(models_group)

        # Model status
        self.models_table = QTableWidget(0, 4)
        self.models_table.setHorizontalHeaderLabels([
            "Model", "Status", "Accuracy", "Last Trained"
        ])
        models_layout.addWidget(self.models_table)

        # Model controls
        model_controls = QHBoxLayout()

        self.train_models_btn = QPushButton("Train Models")
        self.train_models_btn.clicked.connect(self._train_models)
        model_controls.addWidget(self.train_models_btn)

        self.load_training_data_btn = QPushButton("Load Training Data")
        self.load_training_data_btn.clicked.connect(self._load_training_data)
        model_controls.addWidget(self.load_training_data_btn)

        model_controls.addStretch()

        self.refresh_models_btn = QPushButton("Refresh")
        self.refresh_models_btn.clicked.connect(self._refresh_models)
        model_controls.addWidget(self.refresh_models_btn)

        models_layout.addLayout(model_controls)

        layout.addWidget(models_group)

        # Adaptation results
        results_group = QGroupBox("Adaptation Results")
        results_layout = QVBoxLayout(results_group)

        self.adaptation_results_edit = QTextEdit()
        self.adaptation_results_edit.setReadOnly(True)
        results_layout.addWidget(self.adaptation_results_edit)

        layout.addWidget(results_group)

        return widget

    def _create_results_tab(self) -> QWidget:
        """Create results analysis tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Results splitter
        splitter = QSplitter(Qt.Horizontal)

        # Campaign results list
        results_group = QGroupBox("Campaign Results")
        results_layout = QVBoxLayout(results_group)

        self.results_tree = QTreeWidget()
        self.results_tree.setHeaderLabels([
            "Campaign", "Type", "Status", "Results", "Completed"
        ])
        self.results_tree.itemSelectionChanged.connect(self._show_result_details)
        results_layout.addWidget(self.results_tree)

        splitter.addWidget(results_group)

        # Result details
        details_group = QGroupBox("Result Details")
        details_layout = QVBoxLayout(details_group)

        # Result tabs
        self.result_tabs = QTabWidget()

        # Summary tab
        self.summary_edit = QTextEdit()
        self.summary_edit.setReadOnly(True)
        self.result_tabs.addTab(self.summary_edit, "Summary")

        # Vulnerabilities tab
        self.vulnerabilities_table = QTableWidget(0, 5)
        self.vulnerabilities_table.setHorizontalHeaderLabels([
            "Type", "Severity", "Location", "Exploitable", "Description"
        ])
        self.result_tabs.addTab(self.vulnerabilities_table, "Vulnerabilities")

        # Correlation tab
        self.correlation_edit = QTextEdit()
        self.correlation_edit.setReadOnly(True)
        self.result_tabs.addTab(self.correlation_edit, "Correlation")

        # Raw data tab
        self.raw_data_edit = QTextEdit()
        self.raw_data_edit.setReadOnly(True)
        self.result_tabs.addTab(self.raw_data_edit, "Raw Data")

        details_layout.addWidget(self.result_tabs)

        splitter.addWidget(details_group)

        layout.addWidget(splitter)

        # Analysis controls
        analysis_layout = QHBoxLayout()

        self.generate_report_btn = QPushButton("Generate Report")
        self.generate_report_btn.clicked.connect(self._generate_report)
        analysis_layout.addWidget(self.generate_report_btn)

        self.correlate_results_btn = QPushButton("Correlate Results")
        self.correlate_results_btn.clicked.connect(self._correlate_results)
        analysis_layout.addWidget(self.correlate_results_btn)

        analysis_layout.addStretch()

        layout.addLayout(analysis_layout)

        return widget

    def _create_configuration_tab(self) -> QWidget:
        """Create configuration tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Research configuration
        research_group = QGroupBox("Research Configuration")
        research_layout = QGridLayout(research_group)

        research_layout.addWidget(QLabel("Max Concurrent Campaigns:"), 0, 0)
        self.max_campaigns_spin = QSpinBox()
        self.max_campaigns_spin.setRange(1, 20)
        self.max_campaigns_spin.setValue(5)
        research_layout.addWidget(self.max_campaigns_spin, 0, 1)

        research_layout.addWidget(QLabel("Default Timeout (seconds):"), 1, 0)
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(300, 86400)
        self.timeout_spin.setValue(3600)
        research_layout.addWidget(self.timeout_spin, 1, 1)

        research_layout.addWidget(QLabel("Result Storage Directory:"), 2, 0)
        self.storage_dir_edit = QLineEdit()
        self.storage_dir_edit.setText("/tmp/intellicrack_research")
        research_layout.addWidget(self.storage_dir_edit, 2, 1)

        research_layout.addWidget(QLabel("Auto Correlation:"), 3, 0)
        self.auto_correlation_check = QCheckBox()
        self.auto_correlation_check.setChecked(True)
        research_layout.addWidget(self.auto_correlation_check, 3, 1)

        layout.addWidget(research_group)

        # ML configuration
        ml_group = QGroupBox("ML Configuration")
        ml_layout = QGridLayout(ml_group)

        ml_layout.addWidget(QLabel("Min Training Samples:"), 0, 0)
        self.min_samples_spin = QSpinBox()
        self.min_samples_spin.setRange(10, 1000)
        self.min_samples_spin.setValue(50)
        ml_layout.addWidget(self.min_samples_spin, 0, 1)

        ml_layout.addWidget(QLabel("Retrain Threshold:"), 1, 0)
        self.retrain_threshold_spin = QSpinBox()
        self.retrain_threshold_spin.setRange(50, 10000)
        self.retrain_threshold_spin.setValue(100)
        ml_layout.addWidget(self.retrain_threshold_spin, 1, 1)

        ml_layout.addWidget(QLabel("Confidence Threshold:"), 2, 0)
        self.confidence_spin = QSpinBox()
        self.confidence_spin.setRange(50, 99)
        self.confidence_spin.setValue(70)
        self.confidence_spin.setSuffix("%")
        ml_layout.addWidget(self.confidence_spin, 2, 1)

        layout.addWidget(ml_group)

        # Integration settings
        integration_group = QGroupBox("Integration Settings")
        integration_layout = QGridLayout(integration_group)

        integration_layout.addWidget(QLabel("AI Model Integration:"), 0, 0)
        self.ai_integration_check = QCheckBox()
        self.ai_integration_check.setChecked(True)
        integration_layout.addWidget(self.ai_integration_check, 0, 1)

        integration_layout.addWidget(QLabel("Automated Exploitation:"), 1, 0)
        self.auto_exploitation_check = QCheckBox()
        self.auto_exploitation_check.setChecked(False)
        integration_layout.addWidget(self.auto_exploitation_check, 1, 1)

        integration_layout.addWidget(QLabel("Real-time Adaptation:"), 2, 0)
        self.realtime_adaptation_check = QCheckBox()
        self.realtime_adaptation_check.setChecked(True)
        integration_layout.addWidget(self.realtime_adaptation_check, 2, 1)

        layout.addWidget(integration_group)

        # Configuration controls
        config_controls = QHBoxLayout()

        self.save_config_btn = QPushButton("Save Configuration")
        self.save_config_btn.clicked.connect(self._save_configuration)
        config_controls.addWidget(self.save_config_btn)

        self.load_config_btn = QPushButton("Load Configuration")
        self.load_config_btn.clicked.connect(self._load_configuration)
        config_controls.addWidget(self.load_config_btn)

        self.reset_config_btn = QPushButton("Reset to Defaults")
        self.reset_config_btn.clicked.connect(self._reset_configuration)
        config_controls.addWidget(self.reset_config_btn)

        config_controls.addStretch()

        layout.addLayout(config_controls)
        layout.addStretch()

        return widget

    # Event handlers and operations

    def _load_initial_data(self):
        """Load initial data and populate UI."""
        try:
            if not RESEARCH_AVAILABLE:
                QMessageBox.warning(self, "Warning",
                                  "Research components not available. Some features may be limited.")
                return

            # Load existing campaigns
            self._refresh_campaigns()

            # Load model status
            self._refresh_models()

            # Load results
            self._refresh_results()

        except Exception as e:
            logger.error(f"Failed to load initial data: {e}")

    def _browse_targets(self):
        """Browse for target files."""
        files, _ = QFileDialog.getOpenFileNames(
            self, "Select Target Files", "",
            "All Files (*)")

        if files:
            current_text = self.targets_edit.toPlainText()
            if current_text:
                current_text += "\n"
            current_text += "\n".join(files)
            self.targets_edit.setPlainText(current_text)

    def _create_campaign(self):
        """Create new research campaign."""
        try:
            name = self.campaign_name_edit.text().strip()
            if not name:
                QMessageBox.warning(self, "Warning", "Please enter a campaign name.")
                return

            campaign_type = self.campaign_type_combo.currentText()
            template = self.template_combo.currentText()

            targets_text = self.targets_edit.toPlainText().strip()
            if not targets_text:
                QMessageBox.warning(self, "Warning", "Please specify target files.")
                return

            targets = [t.strip() for t in targets_text.split('\n') if t.strip()]

            # Map UI values to internal values
            type_mapping = {
                "Binary Analysis": "binary_analysis",
                "Fuzzing": "fuzzing",
                "Vulnerability Assessment": "vulnerability_assessment",
                "Patch Analysis": "patch_analysis",
                "Hybrid Research": "hybrid_research"
            }

            template_mapping = {
                "None": None,
                "Basic Fuzzing": "basic_fuzzing",
                "Comprehensive Analysis": "comprehensive_analysis",
                "Patch Research": "patch_research"
            }

            campaign_type_val = type_mapping.get(campaign_type, "binary_analysis")
            template_val = template_mapping.get(template)

            # Add to worker queue
            self.worker.add_operation(
                'create_campaign',
                name=name,
                campaign_type=campaign_type_val,
                targets=targets,
                template=template_val
            )

            # Clear form
            self.campaign_name_edit.clear()
            self.targets_edit.clear()

            QMessageBox.information(self, "Success", "Campaign creation initiated.")

        except Exception as e:
            logger.error(f"Campaign creation failed: {e}")
            QMessageBox.critical(self, "Error", f"Failed to create campaign: {e}")

    def _start_selected_campaign(self):
        """Start selected campaign."""
        selected_items = self.campaigns_tree.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Warning", "Please select a campaign to start.")
            return

        item = selected_items[0]
        campaign_id = item.data(0, Qt.UserRole)

        if campaign_id:
            self.worker.add_operation('start_campaign', campaign_id=campaign_id)
            QMessageBox.information(self, "Success", "Campaign start initiated.")

    def _adapt_strategy(self):
        """Perform ML strategy adaptation."""
        try:
            strategy = self.adaptation_strategy_combo.currentText()
            target_info_text = self.target_info_edit.toPlainText().strip()

            if not target_info_text:
                QMessageBox.warning(self, "Warning", "Please enter target information.")
                return

            try:
                target_info = json.loads(target_info_text)
            except json.JSONDecodeError:
                QMessageBox.warning(self, "Warning", "Invalid JSON format in target information.")
                return

            # Map UI strategy to internal value
            strategy_mapping = {
                "Exploit Optimization": "exploit_optimization",
                "Vulnerability Prediction": "vulnerability_prediction",
                "Evasion Adaptation": "evasion_adaptation",
                "Payload Evolution": "payload_evolution",
                "Target Profiling": "target_profiling"
            }

            strategy_val = strategy_mapping.get(strategy, "exploit_optimization")

            # For demo, use empty previous attempts
            previous_attempts = []

            self.worker.add_operation(
                'adapt_strategy',
                target_info=target_info,
                previous_attempts=previous_attempts,
                strategy=strategy_val
            )

            QMessageBox.information(self, "Success", "Strategy adaptation initiated.")

        except Exception as e:
            logger.error(f"Strategy adaptation failed: {e}")
            QMessageBox.critical(self, "Error", f"Failed to adapt strategy: {e}")

    def _train_models(self):
        """Train ML models."""
        self.worker.add_operation('train_models')
        QMessageBox.information(self, "Success", "Model training initiated.")

    # Signal handlers

    def _on_campaign_updated(self, campaign_id: str, data: Dict):
        """Handle campaign update."""
        self.active_campaigns[campaign_id] = data
        self._refresh_campaigns()

    def _on_results_ready(self, campaign_id: str, results: Dict):
        """Handle results ready."""
        self.campaign_results[campaign_id] = results
        self._refresh_results()

    def _on_error_occurred(self, operation: str, error: str):
        """Handle error."""
        QMessageBox.critical(self, "Error", f"Operation '{operation}' failed: {error}")

    def _on_adaptation_complete(self, results: Dict):
        """Handle adaptation completion."""
        # Display results
        results_text = json.dumps(results, indent=2)
        self.adaptation_results_edit.setPlainText(results_text)

    def _refresh_campaigns(self):
        """Refresh campaigns display."""
        self.campaigns_tree.clear()

        if not self.research_manager:
            return

        try:
            campaigns_result = self.research_manager.list_campaigns()
            if campaigns_result['success']:
                for campaign in campaigns_result['campaigns']:
                    item = QTreeWidgetItem([
                        campaign['name'],
                        campaign['type'],
                        campaign['status'],
                        f"{campaign['progress']:.1%}",
                        str(campaign['targets_count']),
                        datetime.fromtimestamp(campaign['created_at']).strftime('%Y-%m-%d %H:%M')
                    ])
                    item.setData(0, Qt.UserRole, campaign['id'])
                    self.campaigns_tree.addTopLevelItem(item)

        except Exception as e:
            logger.error(f"Failed to refresh campaigns: {e}")

    def _refresh_models(self):
        """Refresh models display."""
        if not self.ml_engine:
            return

        try:
            insights = self.ml_engine.get_adaptation_insights()
            model_status = insights.get('model_status', {})

            self.models_table.setRowCount(len(model_status))

            for row, (model_name, status) in enumerate(model_status.items()):
                self.models_table.setItem(row, 0, QTableWidgetItem(model_name))
                self.models_table.setItem(row, 1,
                    QTableWidgetItem("Trained" if status['trained'] else "Not Trained"))
                self.models_table.setItem(row, 2, QTableWidgetItem("N/A"))  # Accuracy placeholder
                self.models_table.setItem(row, 3, QTableWidgetItem(str(status['last_updated'])))

        except Exception as e:
            logger.error(f"Failed to refresh models: {e}")

    def _refresh_results(self):
        """Refresh results display."""
        self.results_tree.clear()

        for campaign_id, results in self.campaign_results.items():
            campaign_name = f"Campaign {campaign_id[:8]}"
            item = QTreeWidgetItem([
                campaign_name,
                results.get('campaign_type', 'Unknown'),
                "Completed" if results.get('success') else "Failed",
                f"{len(results.get('detailed_results', {}))} results",
                datetime.now().strftime('%Y-%m-%d %H:%M')
            ])
            item.setData(0, Qt.UserRole, campaign_id)
            self.results_tree.addTopLevelItem(item)

    def _update_campaign_status(self):
        """Update campaign status periodically."""
        if self.research_manager:
            try:
                # Update active campaigns
                campaigns_result = self.research_manager.list_campaigns(status_filter="running")
                if campaigns_result['success']:
                    for campaign in campaigns_result['campaigns']:
                        if campaign['id'] in self.active_campaigns:
                            self.active_campaigns[campaign['id']].update(campaign)

                self._refresh_campaigns()

            except Exception as e:
                logger.debug(f"Status update failed: {e}")

    def closeEvent(self, event):
        """Handle dialog close."""
        self.worker.stop()
        self.worker.wait()
        super().closeEvent(event)

    # Placeholder methods for remaining functionality

    def _pause_selected_campaign(self):
        """Pause selected campaign."""
        QMessageBox.information(self, "Info", "Pause functionality not yet implemented.")

    def _cancel_selected_campaign(self):
        """Cancel selected campaign."""
        QMessageBox.information(self, "Info", "Cancel functionality not yet implemented.")

    def _show_campaign_details(self):
        """Show campaign details."""
        QMessageBox.information(self, "Info", "Campaign details not yet implemented.")

    def _predict_success(self):
        """Predict exploitation success."""
        QMessageBox.information(self, "Info", "Success prediction not yet implemented.")

    def _load_training_data(self):
        """Load training data."""
        QMessageBox.information(self, "Info", "Training data loading not yet implemented.")

    def _show_result_details(self):
        """Show result details."""
        QMessageBox.information(self, "Info", "Result details not yet implemented.")

    def _generate_report(self):
        """Generate analysis report."""
        QMessageBox.information(self, "Info", "Report generation not yet implemented.")

    def _correlate_results(self):
        """Correlate results."""
        QMessageBox.information(self, "Info", "Result correlation not yet implemented.")

    def _export_results(self):
        """Export results."""
        QMessageBox.information(self, "Info", "Export functionality not yet implemented.")

    def _save_configuration(self):
        """Save configuration."""
        QMessageBox.information(self, "Info", "Configuration saving not yet implemented.")

    def _load_configuration(self):
        """Load configuration."""
        QMessageBox.information(self, "Info", "Configuration loading not yet implemented.")

    def _reset_configuration(self):
        """Reset configuration."""
        QMessageBox.information(self, "Info", "Configuration reset not yet implemented.")
