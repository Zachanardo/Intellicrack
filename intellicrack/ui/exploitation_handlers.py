"""
Exploitation UI Handler Methods

This module contains all the handler methods for the enhanced exploitation UI
components in Intellicrack. These methods integrate with the core exploitation
frameworks implemented in the previous phases.
"""

import logging
import os
import time

from PyQt5.QtWidgets import QFileDialog, QMessageBox

try:
    from ..utils.payload_result_handler import PayloadResultHandler
except ImportError:
    PayloadResultHandler = None

logger = logging.getLogger(__name__)


def generate_advanced_payload(self):
    """Generate advanced payload using the payload engine."""
    try:
        # Import payload generation components
        from ..core.payload_generation.payload_engine import PayloadEngine
        from ..core.payload_generation.payload_types import Architecture, EncodingType, PayloadType

        if not hasattr(self, 'payload_engine'):
            self.payload_engine = PayloadEngine()

        # Get configuration from UI
        payload_type_str = self.payload_type_combo.currentText()
        architecture_str = self.arch_combo.currentText()
        encoding_str = self.encoding_combo.currentText()
        evasion_level = self.evasion_combo.currentText().lower()

        # Map UI values to enum values
        payload_type_mapping = {
            "Reverse Shell": PayloadType.REVERSE_SHELL,
            "Bind Shell": PayloadType.BIND_SHELL,
            "Meterpreter": PayloadType.METERPRETER,
            "Staged Payload": PayloadType.STAGED_PAYLOAD,
            "License Bypass": PayloadType.CUSTOM,
            "Function Hijack": PayloadType.CUSTOM,
            "Code Cave": PayloadType.CUSTOM,
            "Custom Shellcode": PayloadType.CUSTOM
        }

        architecture_mapping = {
            "x86": Architecture.X86,
            "x64": Architecture.X64,
            "ARM": Architecture.ARM,
            "ARM64": Architecture.ARM64
        }

        encoding_mapping = {
            "None": EncodingType.NONE,
            "Polymorphic": EncodingType.POLYMORPHIC,
            "Metamorphic": EncodingType.METAMORPHIC,
            "XOR": EncodingType.XOR,
            "Alpha": EncodingType.ALPHANUMERIC
        }

        payload_type = payload_type_mapping.get(payload_type_str, PayloadType.REVERSE_SHELL)
        architecture = architecture_mapping.get(architecture_str, Architecture.X86)
        encoding = encoding_mapping.get(encoding_str, EncodingType.POLYMORPHIC)

        # Prepare target info and options
        target_info = {
            'os_type': 'windows',
            'architecture': architecture_str.lower(),
            'protections': ['aslr', 'dep'],
            'av_products': []
        }

        options = {
            'lhost': self.lhost_edit.text(),
            'lport': int(self.lport_edit.text()),
            'encoding': encoding,
            'evasion_level': evasion_level
        }

        # Generate payload
        self.exploit_output.append("=== Generating Advanced Payload ===")
        self.exploit_output.append(f"Type: {payload_type_str}")
        self.exploit_output.append(f"Architecture: {architecture_str}")
        self.exploit_output.append(f"Encoding: {encoding_str}")
        self.exploit_output.append(f"Evasion Level: {evasion_level}")
        self.exploit_output.append("")

        result = self.payload_engine.generate_payload(
            payload_type=payload_type,
            architecture=architecture,
            target_info=target_info,
            options=options
        )

        # Define save callback for payload storage
        def save_payload(payload_data: bytes, metadata: dict):
            # Store payload for testing
            self.current_payload = payload_data
            self.current_payload_metadata = metadata

        # Use common payload result handler
        if PayloadResultHandler:
            PayloadResultHandler.process_payload_result(result, self.exploit_output.append, save_payload)
        else:
            # Fallback for missing handler
            if result['success']:
                payload = result['payload']
                metadata = result['metadata']
                
                self.exploit_output.append("✓ Payload generated successfully!")
                self.exploit_output.append(f"  Size: {metadata['size_bytes']} bytes")
                self.exploit_output.append(f"  Entropy: {metadata['entropy']:.3f}")
                if 'hash_md5' in metadata:
                    self.exploit_output.append(f"  MD5: {metadata['hash_md5']}")
                if 'generation_time' in result:
                    self.exploit_output.append(f"  Generation time: {result['generation_time']:.2f}s")
                
                save_payload(payload, metadata)
            else:
                self.exploit_output.append(f"✗ Payload generation failed: {result.get('error', 'Unknown error')}")

    except Exception as e:
        logger.error(f"Payload generation failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_generated_payload(self):
    """Test the generated payload in a safe environment."""
    try:
        if not hasattr(self, 'current_payload'):
            QMessageBox.warning(self, "No Payload", "Please generate a payload first.")
            return

        self.exploit_output.append("=== Testing Generated Payload ===")
        self.exploit_output.append("Running payload in sandbox environment...")

        # This would run the payload in a controlled environment
        # For safety, we'll just validate the payload structure
        payload = self.current_payload
        metadata = self.current_payload_metadata

        # Basic validation
        if len(payload) > 0:
            self.exploit_output.append("✓ Payload has valid size")

        if metadata['null_bytes'] == 0:
            self.exploit_output.append("✓ No null bytes detected")
        else:
            self.exploit_output.append(f"⚠ {metadata['null_bytes']} null bytes detected")

        if len(metadata['bad_chars']) == 0:
            self.exploit_output.append("✓ No bad characters detected")
        else:
            self.exploit_output.append(f"⚠ Bad characters detected: {metadata['bad_chars']}")

        self.exploit_output.append(f"✓ Compatibility score: {metadata['compatibility_score']:.2f}")
        self.exploit_output.append("Payload testing completed.")

    except Exception as e:
        logger.error(f"Payload testing failed: {e}")
        self.exploit_output.append(f"✗ Testing error: {e}")


def start_c2_server(self):
    """Start the C2 server with configured settings."""
    try:
        from ..core.c2_infrastructure.c2_manager import C2Manager

        if not hasattr(self, 'c2_manager'):
            self.c2_manager = C2Manager()

        protocol = self.c2_protocol_combo.currentText().lower()
        port = int(self.c2_port_edit.text())
        encryption = self.c2_encryption_combo.currentText()

        self.exploit_output.append("=== Starting C2 Server ===")
        self.exploit_output.append(f"Protocol: {protocol}")
        self.exploit_output.append(f"Port: {port}")
        self.exploit_output.append(f"Encryption: {encryption}")

        config = {
            'protocol': protocol,
            'port': port,
            'encryption_method': encryption.lower().replace('-', ''),
            'interface': '0.0.0.0'
        }

        result = self.c2_manager.start_server(config)

        if result['success']:
            self.exploit_output.append("✓ C2 Server started successfully!")
            self.exploit_output.append(f"  Server ID: {result['server_id']}")
            self.exploit_output.append(f"  Listening on: {result['address']}")
        else:
            self.exploit_output.append(f"✗ Failed to start C2 server: {result.get('error')}")

    except Exception as e:
        logger.error(f"C2 server start failed: {e}")
        self.exploit_output.append(f"✗ Error starting C2 server: {e}")


def stop_c2_server(self):
    """Stop the C2 server."""
    try:
        if not hasattr(self, 'c2_manager'):
            QMessageBox.warning(self, "No Server", "No C2 server is running.")
            return

        self.exploit_output.append("=== Stopping C2 Server ===")

        result = self.c2_manager.stop_server()

        if result['success']:
            self.exploit_output.append("✓ C2 Server stopped successfully!")
        else:
            self.exploit_output.append(f"✗ Failed to stop C2 server: {result.get('error')}")

    except Exception as e:
        logger.error(f"C2 server stop failed: {e}")
        self.exploit_output.append(f"✗ Error stopping C2 server: {e}")


def open_c2_management(self):
    """Open the C2 management dialog."""
    try:
        from ..ui.dialogs.c2_management_dialog import C2ManagementDialog

        dialog = C2ManagementDialog(self)
        dialog.exec_()

    except Exception as e:
        logger.error(f"Failed to open C2 management dialog: {e}")
        QMessageBox.critical(self, "Error", f"Failed to open C2 management dialog: {e}")


def establish_persistence(self):
    """Establish persistence on the target system."""
    try:
        from ..core.post_exploitation.persistence_manager import PersistenceManager

        if not hasattr(self, 'persistence_manager'):
            self.persistence_manager = PersistenceManager()

        platform = self.platform_combo.currentText().lower()

        self.exploit_output.append("=== Establishing Persistence ===")
        self.exploit_output.append(f"Target Platform: {platform}")

        result = self.persistence_manager.establish_persistence(
            platform=platform,
            method='auto',
            payload_path='/tmp/implant'
        )

        if result['success']:
            self.exploit_output.append("✓ Persistence established successfully!")
            self.exploit_output.append(f"  Method: {result['method']}")
            self.exploit_output.append(f"  Location: {result['location']}")
        else:
            self.exploit_output.append(f"✗ Failed to establish persistence: {result.get('error')}")

    except Exception as e:
        logger.error(f"Persistence establishment failed: {e}")
        self.exploit_output.append(f"✗ Error establishing persistence: {e}")


def escalate_privileges(self):
    """Attempt to escalate privileges on the target system."""
    try:
        from ..core.post_exploitation.privilege_escalation import PrivilegeEscalationManager

        if not hasattr(self, 'privesc_manager'):
            self.privesc_manager = PrivilegeEscalationManager()

        platform = self.platform_combo.currentText().lower()

        self.exploit_output.append("=== Escalating Privileges ===")
        self.exploit_output.append(f"Target Platform: {platform}")

        result = self.privesc_manager.escalate_privileges(platform=platform)

        if result['success']:
            self.exploit_output.append("✓ Privilege escalation successful!")
            self.exploit_output.append(f"  Method: {result['method']}")
            self.exploit_output.append(f"  New privileges: {result['privileges']}")
        else:
            self.exploit_output.append(f"✗ Privilege escalation failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"Privilege escalation failed: {e}")
        self.exploit_output.append(f"✗ Error escalating privileges: {e}")


def perform_lateral_movement(self):
    """Perform lateral movement to other systems."""
    try:
        from ..core.post_exploitation.lateral_movement import LateralMovementManager

        if not hasattr(self, 'lateral_manager'):
            self.lateral_manager = LateralMovementManager()

        platform = self.platform_combo.currentText().lower()

        self.exploit_output.append("=== Performing Lateral Movement ===")
        self.exploit_output.append(f"Platform: {platform}")

        result = self.lateral_manager.discover_targets()

        if result['success']:
            targets = result['targets']
            self.exploit_output.append(f"✓ Discovered {len(targets)} potential targets")

            for target in targets[:5]:  # Show first 5 targets
                self.exploit_output.append(f"  • {target['ip']} - {target['hostname']}")

        else:
            self.exploit_output.append(f"✗ Target discovery failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"Lateral movement failed: {e}")
        self.exploit_output.append(f"✗ Error performing lateral movement: {e}")


def harvest_credentials(self):
    """Harvest credentials from the target system."""
    try:
        from ..core.post_exploitation.credential_harvesting import CredentialHarvester

        if not hasattr(self, 'cred_harvester'):
            self.cred_harvester = CredentialHarvester()

        platform = self.platform_combo.currentText().lower()

        self.exploit_output.append("=== Harvesting Credentials ===")
        self.exploit_output.append(f"Platform: {platform}")

        result = self.cred_harvester.harvest_credentials(platform=platform)

        if result['success']:
            creds = result['credentials']
            self.exploit_output.append(f"✓ Harvested {len(creds)} credentials")

            for cred in creds[:3]:  # Show first 3 credentials
                self.exploit_output.append(f"  • {cred['type']}: {cred['username']} (from {cred['source']})")

        else:
            self.exploit_output.append(f"✗ Credential harvesting failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"Credential harvesting failed: {e}")
        self.exploit_output.append(f"✗ Error harvesting credentials: {e}")


def collect_system_info(self):
    """Collect system information from the target."""
    try:
        from ..core.post_exploitation.system_reconnaissance import SystemRecon

        if not hasattr(self, 'system_recon'):
            self.system_recon = SystemRecon()

        platform = self.platform_combo.currentText().lower()

        self.exploit_output.append("=== Collecting System Information ===")
        self.exploit_output.append(f"Platform: {platform}")

        result = self.system_recon.collect_system_info(platform=platform)

        if result['success']:
            info = result['system_info']
            self.exploit_output.append("✓ System information collected:")
            self.exploit_output.append(f"  OS: {info.get('os', 'Unknown')}")
            self.exploit_output.append(f"  Architecture: {info.get('architecture', 'Unknown')}")
            self.exploit_output.append(f"  Users: {len(info.get('users', []))}")
            self.exploit_output.append(f"  Processes: {len(info.get('processes', []))}")
        else:
            self.exploit_output.append(f"✗ System info collection failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"System info collection failed: {e}")
        self.exploit_output.append(f"✗ Error collecting system info: {e}")


def cleanup_exploitation(self):
    """Clean up exploitation artifacts and remove traces."""
    try:
        self.exploit_output.append("=== Cleaning Up Exploitation Artifacts ===")

        # Stop any running C2 servers
        if hasattr(self, 'c2_manager'):
            self.c2_manager.stop_all_servers()
            self.exploit_output.append("✓ Stopped all C2 servers")

        # Clear payload artifacts
        if hasattr(self, 'current_payload'):
            delattr(self, 'current_payload')
            self.exploit_output.append("✓ Cleared payload data")

        # Remove temporary files
        temp_files = ['/tmp/intellicrack_payload', '/tmp/intellicrack_implant']
        for temp_file in temp_files:
            if os.path.exists(temp_file):
                os.remove(temp_file)
                self.exploit_output.append(f"✓ Removed {temp_file}")

        self.exploit_output.append("✓ Cleanup completed successfully")

    except Exception as e:
        logger.error(f"Cleanup failed: {e}")
        self.exploit_output.append(f"✗ Error during cleanup: {e}")


def open_vulnerability_research(self):
    """Open the vulnerability research dialog."""
    try:
        from ..ui.dialogs.vulnerability_research_dialog import VulnerabilityResearchDialog

        dialog = VulnerabilityResearchDialog(self)
        dialog.exec_()

    except Exception as e:
        logger.error(f"Failed to open vulnerability research dialog: {e}")
        QMessageBox.critical(self, "Error", f"Failed to open vulnerability research dialog: {e}")


def run_quick_vulnerability_analysis(self):
    """Run a quick vulnerability analysis on the current binary."""
    try:
        if not self.binary_path:
            QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
            return

        from ..core.vulnerability_research.vulnerability_analyzer import (
            AnalysisMethod,
            VulnerabilityAnalyzer,
        )

        if not hasattr(self, 'vulnerability_analyzer'):
            self.vulnerability_analyzer = VulnerabilityAnalyzer()

        self.exploit_output.append("=== Quick Vulnerability Analysis ===")
        self.exploit_output.append(f"Target: {os.path.basename(self.binary_path)}")

        result = self.vulnerability_analyzer.analyze_target(
            target_path=self.binary_path,
            method=AnalysisMethod.STATIC,
            use_ml=True
        )

        if result['success']:
            vulnerabilities = result['vulnerabilities']
            self.exploit_output.append(f"✓ Analysis completed - {len(vulnerabilities)} vulnerabilities found")

            for vuln in vulnerabilities[:5]:  # Show first 5 vulnerabilities
                self.exploit_output.append(f"  • {vuln['type']} ({vuln['severity']}) - {vuln['description']}")

        else:
            self.exploit_output.append(f"✗ Analysis failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"Quick vulnerability analysis failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def run_ai_guided_analysis(self):
    """Run AI-guided vulnerability analysis."""
    try:
        if not self.binary_path:
            QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
            return

        from ..ai.vulnerability_research_integration import VulnerabilityResearchAI

        if not hasattr(self, 'vuln_research_ai'):
            self.vuln_research_ai = VulnerabilityResearchAI()

        self.exploit_output.append("=== AI-Guided Vulnerability Analysis ===")
        self.exploit_output.append(f"Target: {os.path.basename(self.binary_path)}")

        result = self.vuln_research_ai.analyze_target_with_ai(self.binary_path)

        if result['success']:
            recommendations = result['ai_recommendations']
            risk_assessment = result['risk_assessment']

            self.exploit_output.append("✓ AI analysis completed")
            self.exploit_output.append(f"  Risk Level: {risk_assessment['overall_risk']}")
            self.exploit_output.append(f"  Risk Score: {risk_assessment['risk_score']:.2f}")
            self.exploit_output.append(f"  AI Recommendations: {len(recommendations)}")

            for rec in recommendations[:3]:  # Show first 3 recommendations
                self.exploit_output.append(f"  • {rec}")

        else:
            self.exploit_output.append(f"✗ AI analysis failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"AI-guided analysis failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_aslr_bypass(self):
    """Test ASLR bypass techniques."""
    try:
        from ..core.exploit_mitigation.aslr_bypass import ASLRBypass

        if not hasattr(self, 'aslr_bypass'):
            self.aslr_bypass = ASLRBypass()

        self.exploit_output.append("=== Testing ASLR Bypass ===")

        result = self.aslr_bypass.test_bypass_techniques()

        if result['success']:
            techniques = result['working_techniques']
            self.exploit_output.append("✓ ASLR bypass test completed")
            self.exploit_output.append(f"  Working techniques: {len(techniques)}")

            for technique in techniques:
                self.exploit_output.append(f"  • {technique['name']}: {technique['effectiveness']}")

        else:
            self.exploit_output.append(f"✗ ASLR bypass test failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"ASLR bypass test failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_dep_bypass(self):
    """Test DEP/NX bypass techniques."""
    try:
        from ..core.exploit_mitigation.dep_bypass import DEPBypass

        if not hasattr(self, 'dep_bypass'):
            self.dep_bypass = DEPBypass()

        self.exploit_output.append("=== Testing DEP/NX Bypass ===")

        result = self.dep_bypass.test_bypass_techniques()

        if result['success']:
            self.exploit_output.append("✓ DEP bypass techniques available")
            self.exploit_output.append(f"  ROP chain generation: {result['rop_available']}")
            self.exploit_output.append(f"  JOP techniques: {result['jop_available']}")
        else:
            self.exploit_output.append(f"✗ DEP bypass test failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"DEP bypass test failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_cfi_bypass(self):
    """Test CFI bypass techniques."""
    try:
        from ..core.exploit_mitigation.cfi_bypass import CFIBypass

        if not hasattr(self, 'cfi_bypass'):
            self.cfi_bypass = CFIBypass()

        self.exploit_output.append("=== Testing CFI Bypass ===")

        result = self.cfi_bypass.test_bypass_techniques()

        if result['success']:
            self.exploit_output.append("✓ CFI bypass test completed")
            self.exploit_output.append(f"  Bypass success rate: {result['success_rate']:.1%}")
            self.exploit_output.append(f"  Recommended technique: {result['best_technique']}")
        else:
            self.exploit_output.append(f"✗ CFI bypass test failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"CFI bypass test failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_cet_bypass(self):
    """Test CET bypass techniques."""
    try:
        from ..core.exploit_mitigation.cet_bypass import CETBypass

        if not hasattr(self, 'cet_bypass'):
            self.cet_bypass = CETBypass()

        self.exploit_output.append("=== Testing CET Bypass ===")

        result = self.cet_bypass.test_bypass_techniques()

        if result['success']:
            self.exploit_output.append("✓ CET bypass test completed")
            self.exploit_output.append(f"  Shadow stack bypass: {result['shadow_stack_bypass']}")
            self.exploit_output.append(f"  IBT bypass: {result['ibt_bypass']}")
        else:
            self.exploit_output.append(f"✗ CET bypass test failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"CET bypass test failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def test_stack_canary_bypass(self):
    """Test stack canary bypass techniques."""
    try:
        from ..core.exploit_mitigation.stack_canary_bypass import StackCanaryBypass

        if not hasattr(self, 'canary_bypass'):
            self.canary_bypass = StackCanaryBypass()

        self.exploit_output.append("=== Testing Stack Canary Bypass ===")

        result = self.canary_bypass.test_bypass_techniques()

        if result['success']:
            self.exploit_output.append("✓ Stack canary bypass test completed")
            self.exploit_output.append(f"  Leak techniques available: {len(result['leak_techniques'])}")
            self.exploit_output.append(f"  Brute force feasible: {result['brute_force_feasible']}")
        else:
            self.exploit_output.append(f"✗ Stack canary bypass test failed: {result.get('error')}")

    except Exception as e:
        logger.error(f"Stack canary bypass test failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def run_full_automated_exploitation(self):
    """Run full automated exploitation workflow using the orchestrator."""
    try:
        if not self.binary_path:
            QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
            return

        self.exploit_output.append("=== Advanced AI-Orchestrated Exploitation ===")
        self.exploit_output.append(f"Target: {os.path.basename(self.binary_path)}")
        self.exploit_output.append("Starting AI-orchestrated exploitation campaign...")
        self.exploit_output.append("=" * 50)

        # Use the exploitation orchestrator if available
        if hasattr(self, 'exploitation_orchestrator') and self.exploitation_orchestrator:
            # Prepare target information
            target_info = {
                'binary_path': self.binary_path,
                'target_path': self.binary_path,
                'platform': self.platform_combo.currentText().lower(),
                'network_config': {
                    'lhost': self.lhost_edit.text(),
                    'lport': int(self.lport_edit.text())
                },
                'target_ip': '192.168.1.100'  # Placeholder
            }

            # Run orchestrated exploitation
            result = self.exploitation_orchestrator.orchestrate_full_exploitation(target_info)

            if result['success']:
                self.exploit_output.append("🎯 AI-Orchestrated Exploitation SUCCESSFUL!")
                self.exploit_output.append(f"  Campaign ID: {result['campaign_id']}")
                self.exploit_output.append(f"  Final Status: {result['final_status']}")

                # Show exploitation timeline with durations
                timeline = result['timeline']
                self.exploit_output.append(f"\n📊 Execution Timeline ({len(timeline)} phases):")
                total_time = 0
                for entry in timeline:
                    status_symbol = "✓" if entry['status'] == 'completed' else "✗"
                    duration = entry.get('duration', 0)
                    total_time += duration
                    self.exploit_output.append(f"  {status_symbol} {entry['phase'].replace('_', ' ').title()} ({duration:.2f}s)")

                self.exploit_output.append(f"\n⏱️ Total Campaign Time: {total_time:.2f} seconds")

                # Show AI decisions made during the campaign
                ai_decisions = result['ai_decisions']
                if ai_decisions:
                    self.exploit_output.append(f"\n🤖 AI Decisions Made ({len(ai_decisions)}):")
                    for decision in ai_decisions:
                        phase = decision['phase'].replace('_', ' ').title()
                        self.exploit_output.append(f"  • {phase}: AI strategic insights applied")

                # Show campaign metrics
                metrics = result.get('metrics', {})
                if metrics:
                    self.exploit_output.append("\n📈 Campaign Metrics:")
                    self.exploit_output.append(f"  • Efficiency Score: {metrics.get('efficiency_score', 0):.2f}")
                    self.exploit_output.append(f"  • Successful Phases: {metrics.get('successful_phases', 0)}/{metrics.get('phase_count', 0)}")
                    if metrics.get('time_to_exploit', 0) > 0:
                        self.exploit_output.append(f"  • Time to Exploit: {metrics['time_to_exploit']:.2f}s")

                # Show post-exploitation results if available
                post_exploit = result['phases'].get('post_exploitation', {})
                if post_exploit.get('success'):
                    actions = post_exploit.get('actions_performed', [])
                    self.exploit_output.append(f"\n🚀 Post-Exploitation Complete ({len(actions)} actions):")
                    for action in actions:
                        self.exploit_output.append(f"  • {action}")

            else:
                self.exploit_output.append("❌ AI-Orchestrated Exploitation FAILED")
                self.exploit_output.append(f"  Error: {result.get('error', 'Unknown error')}")

                # Show what phases completed
                timeline = result.get('timeline', [])
                if timeline:
                    self.exploit_output.append("\n📊 Phase Results:")
                    for entry in timeline:
                        status = "✓" if entry['status'] == 'completed' else "✗"
                        self.exploit_output.append(f"  {status} {entry['phase'].replace('_', ' ').title()}")

                # Show orchestrator recommendations for next steps
                self.exploit_output.append("\n💡 Recommendations:")
                self.exploit_output.append("  • Review target configuration")
                self.exploit_output.append("  • Try different evasion levels")
                self.exploit_output.append("  • Check network connectivity")
        else:
            # Fallback to regular vulnerability research AI
            from ..ai.vulnerability_research_integration import VulnerabilityResearchAI

            if not hasattr(self, 'vuln_research_ai'):
                self.vuln_research_ai = VulnerabilityResearchAI()

            self.exploit_output.append("Note: Using fallback AI system (orchestrator not available)")

            # Prepare target information
            target_info = {
                'binary_path': self.binary_path,
                'platform': self.platform_combo.currentText().lower(),
                'network_config': {
                    'lhost': self.lhost_edit.text(),
                    'lport': int(self.lport_edit.text())
                }
            }

            # Run automated exploitation
            result = self.vuln_research_ai.execute_automated_exploitation(target_info)

            if result['success']:
                self.exploit_output.append("✓ Automated exploitation completed successfully!")
                self.exploit_output.append(f"  Workflow ID: {result['workflow_id']}")
                self.exploit_output.append(f"  Final Status: {result['final_status']}")

                # Show exploitation phases
                phases = result['exploitation_phases']
                for phase_name, phase_result in phases.items():
                    status = "✓" if phase_result.get('success') else "✗"
                    self.exploit_output.append(f"  {status} {phase_name.replace('_', ' ').title()}")

            else:
                self.exploit_output.append(f"✗ Automated exploitation failed: {result.get('error')}")

        # Show orchestrator status
        if hasattr(self, 'exploitation_orchestrator') and self.exploitation_orchestrator:
            orchestrator_status = self.exploitation_orchestrator.get_orchestrator_status()
            self.exploit_output.append("\n📊 Orchestrator Status:")
            self.exploit_output.append(f"  • Total Campaigns: {orchestrator_status['total_campaigns_executed']}")
            self.exploit_output.append(f"  • Success Rate: {orchestrator_status['overall_success_rate']:.1%}")
            if orchestrator_status['average_time_to_exploit'] > 0:
                self.exploit_output.append(f"  • Avg Time to Exploit: {orchestrator_status['average_time_to_exploit']:.2f}s")

    except Exception as e:
        logger.error(f"Full automated exploitation failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def run_ai_orchestrated_campaign(self):
    """Run a comprehensive AI-orchestrated exploitation campaign with full visibility."""
    try:
        if not self.binary_path:
            QMessageBox.warning(self, "No Binary", "Please select a binary file first.")
            return

        if not hasattr(self, 'exploitation_orchestrator') or not self.exploitation_orchestrator:
            self.exploit_output.append("❌ Exploitation Orchestrator not available")
            return

        self.exploit_output.append("🤖 === AI EXPLOITATION ORCHESTRATOR === 🤖")
        self.exploit_output.append(f"Target Binary: {os.path.basename(self.binary_path)}")
        self.exploit_output.append(f"AI Model: {'Available' if hasattr(self, 'ml_predictor') and self.ml_predictor else 'Fallback'}")
        self.exploit_output.append("=" * 60)

        # Get orchestrator status before campaign
        pre_status = self.exploitation_orchestrator.get_orchestrator_status()
        self.exploit_output.append("📊 Pre-Campaign Status:")
        self.exploit_output.append(f"  • Active Campaigns: {pre_status['active_campaigns']}")
        self.exploit_output.append(f"  • Historical Success Rate: {pre_status['overall_success_rate']:.1%}")
        self.exploit_output.append(f"  • Components Online: {sum(pre_status['components_status'].values())}/8")
        self.exploit_output.append("")

        # Prepare comprehensive target information
        target_info = {
            'binary_path': self.binary_path,
            'target_path': self.binary_path,
            'platform': self.platform_combo.currentText().lower(),
            'network_config': {
                'lhost': self.lhost_edit.text(),
                'lport': int(self.lport_edit.text())
            },
            'target_ip': '192.168.1.100',
            'analysis_depth': 'comprehensive'
        }

        # Advanced orchestration configuration
        orchestration_config = {
            'ai_guidance_level': 'maximum',
            'adaptation_enabled': True,
            'learning_enabled': True,
            'post_exploit_priority': ['persistence', 'privilege_escalation', 'data_collection']
        }

        self.exploit_output.append("🚀 Launching AI-orchestrated exploitation campaign...")

        # Run the campaign
        result = self.exploitation_orchestrator.orchestrate_full_exploitation(
            target_info, orchestration_config
        )

        # Display comprehensive results
        self.exploit_output.append("=" * 60)

        if result['success']:
            self.exploit_output.append("🎯 *** CAMPAIGN SUCCESSFUL *** 🎯")
        else:
            self.exploit_output.append("❌ *** CAMPAIGN FAILED *** ❌")

        self.exploit_output.append(f"Campaign ID: {result['campaign_id']}")
        self.exploit_output.append(f"Final Status: {result['final_status']}")
        self.exploit_output.append("")

        # Detailed phase analysis
        phases = result.get('phases', {})
        timeline = result.get('timeline', [])

        self.exploit_output.append("📋 PHASE-BY-PHASE ANALYSIS:")
        for phase_entry in timeline:
            phase_name = phase_entry['phase']
            phase_data = phases.get(phase_name, {})

            status_emoji = "✅" if phase_entry['status'] == 'completed' else "❌"
            duration = phase_entry.get('duration', 0)

            self.exploit_output.append(f"  {status_emoji} {phase_name.upper().replace('_', ' ')} ({duration:.2f}s)")

            # Show phase-specific details
            if phase_name == 'intelligence' and phase_data.get('success'):
                vuln_count = phase_data.get('vulnerability_count', 0)
                risk_score = phase_data.get('risk_assessment', {}).get('risk_score', 0)
                self.exploit_output.append(f"     • Vulnerabilities Found: {vuln_count}")
                self.exploit_output.append(f"     • Risk Score: {risk_score:.2f}")

            elif phase_name == 'payload' and phase_data.get('success'):
                metadata = phase_data.get('metadata', {})
                self.exploit_output.append(f"     • Payload Size: {metadata.get('size_bytes', 0)} bytes")
                self.exploit_output.append(f"     • Compatibility: {metadata.get('compatibility_score', 0):.2f}")

            elif phase_name == 'post_exploitation' and phase_data.get('success'):
                actions = phase_data.get('actions_performed', [])
                self.exploit_output.append(f"     • Actions Completed: {len(actions)}")
                if phase_data.get('persistence_established'):
                    self.exploit_output.append("     • Persistence: ✅ Established")
                if phase_data.get('privileges_escalated'):
                    self.exploit_output.append("     • Privilege Escalation: ✅ Successful")

        # AI decision analysis
        ai_decisions = result.get('ai_decisions', [])
        if ai_decisions:
            self.exploit_output.append(f"\n🧠 AI STRATEGIC DECISIONS ({len(ai_decisions)}):")
            for decision in ai_decisions:
                phase = decision['phase'].replace('_', ' ').title()
                insights = decision.get('insights', {})
                self.exploit_output.append(f"  • {phase}:")
                if 'success_probability' in insights:
                    self.exploit_output.append(f"    - Success Probability: {insights['success_probability']:.1%}")
                if 'recommended_approach' in insights:
                    self.exploit_output.append(f"    - Approach: {insights['recommended_approach']}")

        # Campaign metrics and learning
        metrics = result.get('metrics', {})
        if metrics:
            self.exploit_output.append("\n📊 CAMPAIGN METRICS:")
            self.exploit_output.append(f"  • Total Duration: {metrics.get('total_duration', 0):.2f}s")
            self.exploit_output.append(f"  • Phase Success Rate: {metrics.get('successful_phases', 0)}/{metrics.get('phase_count', 0)}")
            self.exploit_output.append(f"  • Efficiency Score: {metrics.get('efficiency_score', 0):.2f}")
            if metrics.get('time_to_exploit', 0) > 0:
                self.exploit_output.append(f"  • Time to Exploit: {metrics['time_to_exploit']:.2f}s")

        # Learning phase results
        learning = phases.get('learning', {})
        if learning.get('success'):
            insights = learning.get('insights_generated', [])
            if insights:
                self.exploit_output.append(f"\n🎓 AI LEARNING INSIGHTS ({len(insights)}):")
                for insight in insights:
                    self.exploit_output.append(f"  • {insight}")

        # Updated orchestrator status
        post_status = self.exploitation_orchestrator.get_orchestrator_status()
        self.exploit_output.append("\n📈 POST-CAMPAIGN STATUS:")
        self.exploit_output.append(f"  • Total Campaigns: {post_status['total_campaigns_executed']} (+1)")
        self.exploit_output.append(f"  • Updated Success Rate: {post_status['overall_success_rate']:.1%}")
        if post_status['average_time_to_exploit'] > 0:
            self.exploit_output.append(f"  • Avg Time to Exploit: {post_status['average_time_to_exploit']:.2f}s")

        self.exploit_output.append("=" * 60)
        self.exploit_output.append("🤖 AI Orchestration Campaign Complete 🤖")

    except Exception as e:
        logger.error(f"AI orchestrated campaign failed: {e}")
        self.exploit_output.append(f"❌ Orchestration Error: {e}")


def save_exploitation_output(self):
    """Save exploitation output to a file."""
    try:
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Exploitation Output",
            f"exploitation_output_{int(time.time())}.txt",
            "Text Files (*.txt);;All Files (*)"
        )

        if file_path:
            with open(file_path, 'w') as f:
                f.write(self.exploit_output.toPlainText())

            QMessageBox.information(self, "Saved", f"Output saved to {file_path}")

    except Exception as e:
        logger.error(f"Failed to save output: {e}")
        QMessageBox.critical(self, "Error", f"Failed to save output: {e}")
