"""Exploitation handlers for Intellicrack UI.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
from typing import Any, Protocol

from intellicrack.handlers.pyqt6_handler import QMessageBox, QTextEdit, QWidget


logger = logging.getLogger(__name__)

try:
    from ..utils.exploitation.payload_result_handler import PayloadResultHandler
    _payload_handler_available = True
except ImportError as e:
    logger.exception("Import error in exploitation_handlers: %s", e)
    _payload_handler_available = False
    PayloadResultHandler = None  # type: ignore[misc, assignment]


class ExploitationTabProtocol(Protocol):
    """Protocol defining the expected interface for exploitation tab handlers."""

    exploit_output: QTextEdit
    binary_path: str


def cleanup_exploitation(self: QWidget) -> None:
    """Clean up exploitation resources and reset state.

    Args:
        self: Widget instance with exploitation interface (must have exploit_output attribute).
    """
    if not hasattr(self, "exploit_output"):
        logger.error("Widget missing required 'exploit_output' attribute")
        return

    exploit_output: QTextEdit = getattr(self, "exploit_output")

    try:
        exploit_output.append("=== Cleaning Up Exploitation Resources ===")

        if hasattr(self, "current_payload"):
            delattr(self, "current_payload")
            exploit_output.append("OK Cleared payload data")

        if hasattr(self, "current_payload_metadata"):
            delattr(self, "current_payload_metadata")
            exploit_output.append("OK Cleared payload metadata")

        if hasattr(self, "payload_engine"):
            exploit_output.append("OK Reset payload engine")

        exploit_output.append("Cleanup completed successfully")

    except Exception as e:
        logger.exception("Exploitation cleanup failed: %s", e)
        exploit_output.append(f"FAIL Cleanup error: {e}")


def save_exploitation_output(self: QWidget) -> None:
    """Save exploitation output and results to file.

    Args:
        self: Widget instance with exploitation interface (must have exploit_output attribute).
    """
    if not hasattr(self, "exploit_output"):
        logger.error("Widget missing required 'exploit_output' attribute")
        return

    exploit_output: QTextEdit = getattr(self, "exploit_output")

    try:
        from datetime import datetime

        from ..handlers.pyqt6_handler import QFileDialog

        default_name = f"exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

        file_path_tuple: tuple[str, str] = QFileDialog.getSaveFileName(
            self,
            "Save Exploitation Output",
            default_name,
            "Text Files (*.txt);;All Files (*.*)"
        )
        file_path: str = file_path_tuple[0]

        if file_path:
            output_text: str = exploit_output.toPlainText()

            with open(file_path, "w", encoding="utf-8") as f:
                f.write("=== Intellicrack Exploitation Report ===\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                binary_path: str = getattr(self, "binary_path", "Not specified")
                f.write(f"Target Binary: {binary_path}\n")
                f.write("\n" + "=" * 50 + "\n\n")
                f.write(output_text)

            exploit_output.append(f"\nOK Output saved to: {file_path}")
            QMessageBox.information(self, "Saved", f"Exploitation output saved to:\n{file_path}")

    except Exception as e:
        logger.exception("Failed to save exploitation output: %s", e)
        exploit_output.append(f"FAIL Save error: {e}")
        QMessageBox.critical(self, "Error", f"Failed to save output:\n{e}")
