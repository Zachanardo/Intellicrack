"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging

from intellicrack.handlers.pyqt6_handler import QMessageBox

"""
Exploitation UI Handler Methods

This module contains all the handler methods for the enhanced exploitation UI
components in Intellicrack. These methods integrate with the core exploitation
frameworks implemented in the previous phases.
"""

logger = logging.getLogger(__name__)

try:
    from ..utils.payload_result_handler import PayloadResultHandler
except ImportError as e:
    logger.error("Import error in exploitation_handlers: %s", e)
    PayloadResultHandler = None


def generate_advanced_payload(self):
    """Generate advanced payload using the payload engine."""
    try:
        # Import payload generation components
        from ..core.exploitation.payload_engine import PayloadEngine
        from ..core.exploitation.payload_types import Architecture, EncodingType, PayloadType

        if not hasattr(self, "payload_engine"):
            self.payload_engine = PayloadEngine()

        # Get configuration from UI
        payload_type_str = self.payload_type_combo.currentText()
        architecture_str = self.arch_combo.currentText()
        encoding_str = self.encoding_combo.currentText()
        evasion_level = self.evasion_combo.currentText().lower()

        # Map UI values to enum values
        payload_type_mapping = {
            "Reverse Shell": PayloadType.REVERSE_SHELL,
            "Bind Shell": PayloadType.BIND_SHELL,
            "Meterpreter": PayloadType.METERPRETER,
            "Staged Payload": PayloadType.STAGED_PAYLOAD,
            "License Bypass": PayloadType.CUSTOM,
            "Function Hijack": PayloadType.CUSTOM,
            "Code Cave": PayloadType.CUSTOM,
            "Custom Shellcode": PayloadType.CUSTOM,
        }

        architecture_mapping = {
            "x86": Architecture.X86,
            "x64": Architecture.X64,
            "ARM": Architecture.ARM,
            "ARM64": Architecture.ARM64,
        }

        encoding_mapping = {
            "None": EncodingType.NONE,
            "Polymorphic": EncodingType.POLYMORPHIC,
            "Metamorphic": EncodingType.METAMORPHIC,
            "XOR": EncodingType.XOR,
            "Alpha": EncodingType.ALPHANUMERIC,
        }

        payload_type = payload_type_mapping.get(payload_type_str, PayloadType.REVERSE_SHELL)
        architecture = architecture_mapping.get(architecture_str, Architecture.X86)
        encoding = encoding_mapping.get(encoding_str, EncodingType.POLYMORPHIC)

        # Prepare target info and options
        target_info = {
            "os_type": "windows",
            "architecture": architecture_str.lower(),
            "protections": ["aslr", "dep"],
            "av_products": [],
        }

        options = {
            "lhost": self.lhost_edit.text(),
            "lport": int(self.lport_edit.text()),
            "encoding": encoding,
            "evasion_level": evasion_level,
        }

        # Generate payload
        self.exploit_output.append("=== Generating Advanced Payload ===")
        self.exploit_output.append(f"Type: {payload_type_str}")
        self.exploit_output.append(f"Architecture: {architecture_str}")
        self.exploit_output.append(f"Encoding: {encoding_str}")
        self.exploit_output.append(f"Evasion Level: {evasion_level}")
        self.exploit_output.append("")

        result = self.payload_engine.generate_payload(
            payload_type=payload_type,
            architecture=architecture,
            target_info=target_info,
            options=options,
        )

        # Define save callback for payload storage
        def save_payload(payload_data: bytes, metadata: dict):
            # Store payload for testing
            self.current_payload = payload_data
            self.current_payload_metadata = metadata

        # Use common payload result handler
        if PayloadResultHandler:
            PayloadResultHandler.process_payload_result(result, self.exploit_output.append, save_payload)
        # Fallback for missing handler
        elif result["success"]:
            payload = result["payload"]
            metadata = result["metadata"]

            self.exploit_output.append("✓ Payload generated successfully!")
            self.exploit_output.append(f"  Size: {metadata['size_bytes']} bytes")
            self.exploit_output.append(f"  Entropy: {metadata['entropy']:.3f}")
            if "hash_md5" in metadata:
                self.exploit_output.append(f"  MD5: {metadata['hash_md5']}")
            if "generation_time" in result:
                self.exploit_output.append(f"  Generation time: {result['generation_time']:.2f}s")

            save_payload(payload, metadata)
        else:
            self.exploit_output.append(f"✗ Payload generation failed: {result.get('error', 'Unknown error')}")

    except Exception as e:
        logger.error(f"Payload generation failed: {e}")
        self.exploit_output.append(f"✗ Error: {e}")


def validate_generated_payload(self):
    """Test the generated payload in a safe environment."""
    try:
        if not hasattr(self, "current_payload"):
            QMessageBox.warning(self, "No Payload", "Please generate a payload first.")
            return

        self.exploit_output.append("=== Testing Generated Payload ===")
        self.exploit_output.append("Running payload in sandbox environment...")

        # This would run the payload in a controlled environment
        # For safety, we'll just validate the payload structure
        payload = self.current_payload
        metadata = self.current_payload_metadata

        # Basic validation
        if len(payload) > 0:
            self.exploit_output.append("✓ Payload has valid size")

        if metadata["null_bytes"] == 0:
            self.exploit_output.append("✓ No null bytes detected")
        else:
            self.exploit_output.append(f"⚠ {metadata['null_bytes']} null bytes detected")

        if len(metadata["bad_chars"]) == 0:
            self.exploit_output.append("✓ No bad characters detected")
        else:
            self.exploit_output.append(f"⚠ Bad characters detected: {metadata['bad_chars']}")

        self.exploit_output.append(f"✓ Compatibility score: {metadata['compatibility_score']:.2f}")
        self.exploit_output.append("Payload testing completed.")

    except Exception as e:
        logger.error(f"Payload testing failed: {e}")
        self.exploit_output.append(f"✗ Testing error: {e}")
