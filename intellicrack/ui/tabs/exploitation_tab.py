"""Exploitation tab for Intellicrack.

This module provides the licensing bypass interface for binary patching,
memory modification, and license protection defeat capabilities.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import contextlib
import logging
import os
import shutil
from typing import Any

from intellicrack.handlers.pyqt6_handler import (
    QCheckBox,
    QComboBox,
    QFileDialog,
    QFont,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QSplitter,
    Qt,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
    QWidget,
    pyqtSignal,
)

from .base_tab import BaseTab


logger = logging.getLogger(__name__)


class ExploitationTab(BaseTab):
    """Exploitation Tab - Licensing bypass tools including binary patching.

    Memory modification, license protection defeat, and testing capabilities.
    """

    patch_applied = pyqtSignal(str, bool)
    exploit_generated = pyqtSignal(str, str)
    memory_patched = pyqtSignal(str, str)

    # Optional UI widgets that may be created in setup_content
    payload_display: QTextEdit
    gadgets_table: QTableWidget
    custom_bytes_edit: QLineEdit
    memory_patch_type_combo: QComboBox
    license_binary_path_edit: QLineEdit
    patch_address_edit: QLineEdit

    def __init__(self, shared_context: dict[str, Any] | None = None, parent: QWidget | None = None) -> None:
        """Initialize exploitation tab with vulnerability research and exploit development tools.

        Args:
            shared_context: Optional shared context dictionary for inter-tab communication.
            parent: Optional parent QWidget for the tab.
        """
        self.logger = logging.getLogger(f"{__name__}.ExploitationTab")

        self.patches: list[dict[str, Any]] = []
        self.exploits: list[dict[str, Any]] = []
        self.current_binary: dict[str, Any] | None = None
        self.current_binary_path: str | None = None
        self.attached_process: int | None = None

        self.exploit_stats: dict[str, dict[str, int]] = {
            "ROP Chain": {"attempts": 0, "successes": 0},
            "Shellcode": {"attempts": 0, "successes": 0},
            "Memory Patch": {"attempts": 0, "successes": 0},
            "Binary Patch": {"attempts": 0, "successes": 0},
            "License Bypass": {"attempts": 0, "successes": 0},
        }

        super().__init__(shared_context, parent)

        app_context = self.app_context
        if app_context and hasattr(app_context, "binary_loaded") and hasattr(app_context, "binary_unloaded"):
            app_context.binary_loaded.connect(self.on_binary_loaded)
            app_context.binary_unloaded.connect(self.on_binary_unloaded)

            if hasattr(app_context, "get_current_binary"):
                if current_binary := app_context.get_current_binary():
                    self.on_binary_loaded(current_binary)

    def setup_content(self) -> None:
        """Set up the complete Exploitation tab content.

        Initializes the tab UI with exploitation controls panel and results panel
        in a horizontal splitter layout for binary patching and protection defeat tools.
        """
        main_layout = self.layout()  # Use existing layout from BaseTab

        # Create horizontal splitter for controls and results
        splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left panel - Exploit controls
        left_panel = self.create_exploitation_controls_panel()

        # Right panel - Results and logs
        right_panel = self.create_results_panel()

        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)

        # Configure splitter proportions (40% controls, 60% results)
        splitter.setStretchFactor(0, 40)
        splitter.setStretchFactor(1, 60)

        if main_layout is not None:
            main_layout.addWidget(splitter)

    def create_exploitation_controls_panel(self) -> QWidget:
        """Create the exploitation controls panel with subtabs.

        Returns:
            QWidget: The created panel for exploitation controls.
        """
        panel = QWidget()
        layout = QVBoxLayout(panel)

        # Exploitation subtabs
        self.exploitation_subtabs = QTabWidget()
        self.exploitation_subtabs.setTabPosition(QTabWidget.TabPosition.North)

        # Create individual exploitation subtabs
        self.exploitation_subtabs.addTab(self.create_patch_management_tab(), "Patch Management")
        self.exploitation_subtabs.addTab(self.create_memory_patching_tab(), "Memory Patching")
        self.exploitation_subtabs.addTab(self.create_license_bypass_tab(), "License Bypass")
        self.exploitation_subtabs.addTab(self.create_testing_validation_tab(), "Testing & Validation")
        self.exploitation_subtabs.addTab(self.create_rop_gadgets_tab(), "ROP Gadgets")

        layout.addWidget(self.exploitation_subtabs)

        # Quick Action Buttons
        quick_actions_group = QGroupBox("Quick Actions")
        quick_actions_layout = QHBoxLayout(quick_actions_group)

        apply_patches_btn = QPushButton("Apply All Patches")
        apply_patches_btn.setToolTip("Apply all queued license bypass patches to the target binary. Creates a backup before modification")
        apply_patches_btn.clicked.connect(self.apply_all_patches)
        apply_patches_btn.setStyleSheet("font-weight: bold; color: green;")

        validate_patches_btn = QPushButton("Validate Patches")
        validate_patches_btn.setToolTip("Validate and test all license bypass patches in a controlled environment")
        validate_patches_btn.clicked.connect(self.test_all_exploits)
        validate_patches_btn.setStyleSheet("color: orange;")

        quick_actions_layout.addWidget(apply_patches_btn)
        quick_actions_layout.addWidget(validate_patches_btn)

        layout.addWidget(quick_actions_group)

        return panel

    def create_patch_management_tab(self) -> QWidget:
        """Create patch management controls.

        Returns:
            QWidget: The created widget for patch management.
        """
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Patch Planning
        planning_group = QGroupBox("Patch Planning")
        planning_layout = QVBoxLayout(planning_group)

        # Target selection
        target_layout = QHBoxLayout()
        target_layout.addWidget(QLabel("Target Address:"))
        self.target_address_edit = QLineEdit()
        self.target_address_edit.setToolTip("Specify the memory address where the patch should be applied (e.g., 0x401000)")
        # Use dynamic base address detection
        import platform

        if platform.system() == "Windows":
            # Windows PE default image base
            default_addr = "0x140000000" if platform.machine() == "AMD64" else "0x400000"
        else:
            # Linux/Unix default text segment
            default_addr = "0x555555554000" if platform.machine() == "x86_64" else "0x8048000"
        self.target_address_edit.setText(default_addr)  # Set actual default base address
        target_layout.addWidget(self.target_address_edit)

        # Patch type
        patch_type_layout = QHBoxLayout()
        patch_type_layout.addWidget(QLabel("Patch Type:"))
        self.patch_type_combo = QComboBox()
        self.patch_type_combo.setToolTip(
            "Select the type of patch to apply. NOP removes instructions, Jump redirects flow, License Bypass targets protection checks",
        )
        self.patch_type_combo.addItems(
            [
                "NOP Patch",
                "Jump Patch",
                "Call Patch",
                "Data Patch",
                "License Bypass",
                "Hardware ID Spoof",
                "Registry License Bypass",
                "Cloud Activation Bypass",
                "Time-Based License Bypass",
                "Network License Bypass",
                "Cryptographic Key Bypass",
                "Anti-Tamper Bypass",
                "Custom",
            ],
        )
        patch_type_layout.addWidget(self.patch_type_combo)

        # Patch data
        self.patch_data_edit = QTextEdit()
        self.patch_data_edit.setToolTip(
            "Enter the patch payload as hex bytes (90 90 90), assembly instructions (jmp 0x401234), or custom data",
        )
        # Initialize with common license bypass pattern (JMP over check)
        self.patch_data_edit.setText("EB 0E 90 90 90")  # JMP +14 followed by NOPs
        self.patch_data_edit.setMaximumHeight(80)

        planning_layout.addLayout(target_layout)
        planning_layout.addLayout(patch_type_layout)
        planning_layout.addWidget(QLabel("Patch Data:"))
        planning_layout.addWidget(self.patch_data_edit)
        # Patch Management
        management_group = QGroupBox("Patch Management")
        management_layout = QVBoxLayout(management_group)

        # Patch list
        self.patch_list = QListWidget()
        self.patch_list.setMaximumHeight(120)

        # Patch controls
        patch_controls_layout = QHBoxLayout()

        add_patch_btn = QPushButton("Add Patch")
        add_patch_btn.setToolTip("Add the configured patch to the queue for later application")
        add_patch_btn.clicked.connect(self.add_patch)

        remove_patch_btn = QPushButton("Remove Patch")
        remove_patch_btn.setToolTip("Remove the selected patch from the queue")
        remove_patch_btn.clicked.connect(self.remove_patch)

        edit_patch_btn = QPushButton("Edit Patch")
        edit_patch_btn.setToolTip("Modify the selected patch configuration")
        edit_patch_btn.clicked.connect(self.edit_patch)

        patch_controls_layout.addWidget(add_patch_btn)
        patch_controls_layout.addWidget(remove_patch_btn)
        patch_controls_layout.addWidget(edit_patch_btn)

        management_layout.addWidget(QLabel("Patch Queue:"))
        management_layout.addWidget(self.patch_list)
        management_layout.addLayout(patch_controls_layout)

        # Application Controls
        application_layout = QHBoxLayout()

        validate_patches_btn = QPushButton("Validate Patches")
        validate_patches_btn.clicked.connect(self.validate_patches)

        test_patches_btn = QPushButton("Test Patches in Sandbox")
        test_patches_btn.clicked.connect(self.test_patches_in_sandbox)

        application_layout.addWidget(validate_patches_btn)
        application_layout.addWidget(test_patches_btn)

        layout.addWidget(planning_group)
        layout.addWidget(management_group)
        layout.addLayout(application_layout)
        layout.addStretch()

        return tab

    def create_memory_patching_tab(self) -> QWidget:
        """Create memory patching controls.

        Returns:
            QWidget: The created widget for memory patching.
        """
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Runtime Patching
        runtime_group = QGroupBox("Runtime Memory Patching")
        runtime_layout = QVBoxLayout(runtime_group)

        # Process selection
        process_layout = QHBoxLayout()
        process_layout.addWidget(QLabel("Target Process:"))
        self.process_combo = QComboBox()
        self.process_combo.setEditable(True)
        # Initialize with actual running processes
        self.refresh_processes()  # Load actual processes
        process_layout.addWidget(self.process_combo)

        refresh_processes_btn = QPushButton("Refresh")
        refresh_processes_btn.clicked.connect(self.refresh_processes)
        process_layout.addWidget(refresh_processes_btn)
        # Memory address
        memory_address_layout = QHBoxLayout()
        memory_address_layout.addWidget(QLabel("Memory Address:"))
        self.memory_address_edit = QLineEdit()
        # Initialize with actual base address based on architecture
        import platform

        if platform.machine() == "AMD64":
            # 64-bit Windows default module base
            self.memory_address_edit.setText("0x140000000")
        else:
            # 32-bit Windows default module base
            self.memory_address_edit.setText("0x400000")
        memory_address_layout.addWidget(self.memory_address_edit)

        # Patch size
        patch_size_layout = QHBoxLayout()
        patch_size_layout.addWidget(QLabel("Patch Size:"))
        self.patch_size_spin = QSpinBox()
        self.patch_size_spin.setRange(1, 1024)
        self.patch_size_spin.setValue(4)
        patch_size_layout.addWidget(self.patch_size_spin)

        # Patch type selector for license bypassing
        patch_type_layout = QHBoxLayout()
        patch_type_layout.addWidget(QLabel("Patch Type:"))
        self.patch_type_combo = QComboBox()
        self.patch_type_combo.addItems(
            [
                "NOP",
                "JMP Short",
                "JMP Near",
                "XOR EAX,EAX + RET",
                "MOV EAX,1 + RET",
                "Invert JZ/JNZ",
                "Trial Reset",
                "HWID Bypass",
                "License String",
                "Custom",
            ],
        )
        self.patch_type_combo.setToolTip(
            "Select patch type:<br>"
            " NOP: Skip instructions<br>"
            " JMP: Jump over checks<br>"
            " XOR EAX,EAX: Return failure<br>"
            " MOV EAX,1: Return success<br>"
            " Invert JZ/JNZ: Flip condition<br>"
            " Trial Reset: Reset trial period<br>"
            " HWID Bypass: Skip hardware checks<br>"
            " License String: Insert valid key<br>"
            " Custom: User-defined bytes",
        )
        patch_type_layout.addWidget(self.patch_type_combo)

        # Custom patch input (hidden by default)
        self.custom_patch_edit = QLineEdit()
        # Initialize with actual NOP and jump bytes for license bypass
        self.custom_patch_edit.setText("90 90 EB 05")  # NOPs followed by JMP +5
        self.custom_patch_edit.setVisible(False)

        # Show/hide custom input based on selection
        def on_patch_type_changed(text: str) -> None:
            """Show or hide custom patch input field based on patch type.

            Args:
                text: The selected patch type from the combo box.
            """
            self.custom_patch_edit.setVisible(text == "Custom")

        self.patch_type_combo.currentTextChanged.connect(on_patch_type_changed)

        runtime_layout.addLayout(process_layout)
        runtime_layout.addLayout(memory_address_layout)
        runtime_layout.addLayout(patch_size_layout)
        runtime_layout.addLayout(patch_type_layout)
        runtime_layout.addWidget(self.custom_patch_edit)

        # Memory Protection
        protection_group = QGroupBox("Memory Protection")
        protection_layout = QVBoxLayout(protection_group)

        self.bypass_dep_cb = QCheckBox("Bypass DEP/NX")
        self.bypass_aslr_cb = QCheckBox("Bypass ASLR")
        self.bypass_stack_protection_cb = QCheckBox("Bypass Stack Protection")
        self.disable_antidebug_cb = QCheckBox("Disable Anti-Debug")

        protection_layout.addWidget(self.bypass_dep_cb)
        protection_layout.addWidget(self.bypass_aslr_cb)
        protection_layout.addWidget(self.bypass_stack_protection_cb)
        protection_layout.addWidget(self.disable_antidebug_cb)

        # Memory Controls
        memory_controls_layout = QHBoxLayout()

        attach_process_btn = QPushButton("Attach to Process")
        attach_process_btn.clicked.connect(self.attach_to_process)

        patch_memory_btn = QPushButton("Patch Memory")
        patch_memory_btn.clicked.connect(self.patch_memory)

        dump_memory_btn = QPushButton("Dump Memory")
        dump_memory_btn.clicked.connect(self.dump_memory)

        memory_controls_layout.addWidget(attach_process_btn)
        memory_controls_layout.addWidget(patch_memory_btn)
        memory_controls_layout.addWidget(dump_memory_btn)

        layout.addWidget(runtime_group)
        layout.addWidget(protection_group)
        layout.addLayout(memory_controls_layout)
        layout.addStretch()

        return tab

    def create_license_bypass_tab(self) -> QWidget:
        """Create dedicated license bypass controls for sophisticated license protection defeat.

        Returns:
            QWidget: The created widget for license bypass controls.
        """
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # License Analysis
        analysis_group = QGroupBox("License Protection Analysis")
        analysis_layout = QVBoxLayout(analysis_group)

        # Target binary selection
        binary_layout = QHBoxLayout()
        binary_layout.addWidget(QLabel("Target Binary:"))
        self.license_binary_edit = QLineEdit()
        self.license_binary_edit.setToolTip("Select or enter path to target binary for license analysis")
        self.license_binary_edit.setText(self._get_default_binary_path())
        binary_layout.addWidget(self.license_binary_edit)

        browse_license_binary_btn = QPushButton("Browse")
        browse_license_binary_btn.clicked.connect(self.browse_license_binary)
        binary_layout.addWidget(browse_license_binary_btn)

        # License detection
        detect_layout = QHBoxLayout()
        detect_protection_btn = QPushButton("Detect Protection")
        detect_protection_btn.setToolTip("Analyze binary to identify license protection mechanisms")
        detect_protection_btn.clicked.connect(self.detect_license_protection)
        detect_protection_btn.setStyleSheet("font-weight: bold; color: blue;")

        analyze_license_btn = QPushButton("Analyze License System")
        analyze_license_btn.setToolTip("Perform deep analysis of license validation routines")
        analyze_license_btn.clicked.connect(self.analyze_license_system)
        analyze_license_btn.setStyleSheet("font-weight: bold; color: purple;")

        detect_layout.addWidget(detect_protection_btn)
        detect_layout.addWidget(analyze_license_btn)

        analysis_layout.addLayout(binary_layout)
        analysis_layout.addLayout(detect_layout)

        # Bypass Strategy Selection
        strategy_group = QGroupBox("Bypass Strategy")
        strategy_layout = QVBoxLayout(strategy_group)

        # Bypass type
        bypass_type_layout = QHBoxLayout()
        bypass_type_layout.addWidget(QLabel("Bypass Type:"))
        self.license_bypass_type_combo = QComboBox()
        self.license_bypass_type_combo.setToolTip("Select sophisticated license bypass technique")
        self.license_bypass_type_combo.addItems(
            [
                "Hardware_ID_Spoof",
                "Registry_License_Bypass",
                "Cloud_Activation_Bypass",
                "Cryptographic_Key_Bypass",
                "Time_Based_License_Bypass",
                "Network_License_Bypass",
                "Anti_Tamper_Bypass",
                "Comprehensive_Bypass",
            ],
        )
        bypass_type_layout.addWidget(self.license_bypass_type_combo)

        # Target platform
        platform_layout = QHBoxLayout()
        platform_layout.addWidget(QLabel("Target Platform:"))
        self.license_platform_combo = QComboBox()
        self.license_platform_combo.addItems(["Windows", "Linux", "macOS", "Cross-Platform"])
        platform_layout.addWidget(self.license_platform_combo)

        strategy_layout.addLayout(bypass_type_layout)
        strategy_layout.addLayout(platform_layout)

        # Advanced Options
        advanced_group = QGroupBox("Advanced Bypass Options")
        advanced_layout = QVBoxLayout(advanced_group)

        # Stealth options
        stealth_layout = QHBoxLayout()
        self.stealth_mode_cb = QCheckBox("Stealth Mode")
        self.stealth_mode_cb.setToolTip("Enable stealth techniques to avoid detection")
        self.anti_debug_cb = QCheckBox("Anti-Debug Bypass")
        self.anti_debug_cb.setToolTip("Include anti-debugging bypass mechanisms")
        self.vm_detection_cb = QCheckBox("VM Detection Bypass")
        self.vm_detection_cb.setToolTip("Bypass virtual machine detection")

        stealth_layout.addWidget(self.stealth_mode_cb)
        stealth_layout.addWidget(self.anti_debug_cb)
        stealth_layout.addWidget(self.vm_detection_cb)

        # Persistence options
        persistence_layout = QHBoxLayout()
        self.persistent_bypass_cb = QCheckBox("Persistent Bypass")
        self.persistent_bypass_cb.setToolTip("Make bypass persistent across reboots")
        self.registry_persistence_cb = QCheckBox("Registry Persistence")
        self.registry_persistence_cb.setToolTip("Use registry modifications for persistence")
        self.service_persistence_cb = QCheckBox("Service Persistence")
        self.service_persistence_cb.setToolTip("Install as system service for persistence")

        persistence_layout.addWidget(self.persistent_bypass_cb)
        persistence_layout.addWidget(self.registry_persistence_cb)
        persistence_layout.addWidget(self.service_persistence_cb)

        advanced_layout.addLayout(stealth_layout)
        advanced_layout.addLayout(persistence_layout)

        # Custom Parameters
        params_group = QGroupBox("Custom Parameters")
        params_layout = QVBoxLayout(params_group)

        self.license_custom_params = QTextEdit()
        self.license_custom_params.setToolTip("Enter custom parameters for bypass (JSON format)")
        # Set actual bypass parameters with real values
        import json
        import uuid

        default_params = {
            "hardware_id": str(uuid.getnode()),
            "license_key": f"INTL-{uuid.uuid4().hex[:16].upper()}",
            "expiry_date": "2099-12-31",
        }
        self.license_custom_params.setText(json.dumps(default_params, indent=2))
        self.license_custom_params.setMaximumHeight(100)

        params_layout.addWidget(self.license_custom_params)

        # Generation Controls
        generation_layout = QHBoxLayout()

        generate_bypass_btn = QPushButton("Generate License Bypass")
        generate_bypass_btn.setToolTip("Generate sophisticated license bypass shellcode")
        generate_bypass_btn.clicked.connect(self.generate_license_bypass_shellcode)
        generate_bypass_btn.setStyleSheet("font-weight: bold; color: green; padding: 8px;")

        test_bypass_btn = QPushButton("Test Bypass")
        test_bypass_btn.setToolTip("Test generated bypass in controlled environment")
        test_bypass_btn.clicked.connect(self.test_license_bypass)
        test_bypass_btn.setStyleSheet("color: orange;")

        deploy_bypass_btn = QPushButton("Deploy Bypass")
        deploy_bypass_btn.setToolTip("Deploy license bypass to target system")
        deploy_bypass_btn.clicked.connect(self.deploy_license_bypass)
        deploy_bypass_btn.setStyleSheet("color: red; font-weight: bold;")

        generation_layout.addWidget(generate_bypass_btn)
        generation_layout.addWidget(test_bypass_btn)
        generation_layout.addWidget(deploy_bypass_btn)

        layout.addWidget(analysis_group)
        layout.addWidget(strategy_group)
        layout.addWidget(advanced_group)
        layout.addWidget(params_group)
        layout.addLayout(generation_layout)
        layout.addStretch()

        return tab

    def create_testing_validation_tab(self) -> QWidget:
        """Create testing and validation controls.

        Returns:
            QWidget: The created widget for testing and validation.
        """
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Test Environment
        test_env_group = QGroupBox("Test Environment")
        test_env_layout = QVBoxLayout(test_env_group)

        # Target process
        target_process_layout = QHBoxLayout()
        target_process_layout.addWidget(QLabel("Target Process:"))
        self.test_process_edit = QLineEdit()
        # Initialize with actual process for testing
        import os

        self.test_process_edit.setText(str(os.getpid()))  # Use current process PID
        target_process_layout.addWidget(self.test_process_edit)

        # Test mode
        test_mode_layout = QHBoxLayout()
        test_mode_layout.addWidget(QLabel("Test Mode:"))
        self.test_mode_combo = QComboBox()
        self.test_mode_combo.addItems(
            [
                "Direct Memory Patching",
                "Process Injection",
                "Live Process Modification",
                "Isolated Environment",
            ],
        )
        test_mode_layout.addWidget(self.test_mode_combo)

        test_env_layout.addLayout(target_process_layout)
        test_env_layout.addLayout(test_mode_layout)

        # Payload Testing
        payload_test_group = QGroupBox("Payload Testing")
        payload_test_layout = QVBoxLayout(payload_test_group)

        # Test selection
        test_selection_layout = QHBoxLayout()
        self.test_rop_cb = QCheckBox("Test ROP Chains")
        self.test_shellcode_cb = QCheckBox("Test Shellcode")
        self.test_patches_cb = QCheckBox("Test Patches")

        test_selection_layout.addWidget(self.test_rop_cb)
        test_selection_layout.addWidget(self.test_shellcode_cb)
        test_selection_layout.addWidget(self.test_patches_cb)

        # Test controls
        test_controls_layout = QHBoxLayout()

        run_tests_btn = QPushButton("Run Tests")
        run_tests_btn.clicked.connect(self.run_payload_tests)
        run_tests_btn.setStyleSheet("font-weight: bold; color: orange;")

        validate_exploits_btn = QPushButton("Validate Exploits")
        validate_exploits_btn.clicked.connect(self.validate_exploits)

        test_controls_layout.addWidget(run_tests_btn)
        test_controls_layout.addWidget(validate_exploits_btn)

        payload_test_layout.addLayout(test_selection_layout)
        payload_test_layout.addLayout(test_controls_layout)

        # Success Rate Monitoring
        success_group = QGroupBox("Success Rate Monitoring")
        success_layout = QVBoxLayout(success_group)

        # Statistics display
        self.success_stats_table = QTableWidget()
        self.success_stats_table.setColumnCount(4)
        self.success_stats_table.setHorizontalHeaderLabels(
            [
                "Exploit Type",
                "Attempts",
                "Successes",
                "Success Rate",
            ],
        )
        self.success_stats_table.setMaximumHeight(120)

        # Reset statistics
        reset_stats_btn = QPushButton("Reset Statistics")
        reset_stats_btn.clicked.connect(self.reset_statistics)

        success_layout.addWidget(self.success_stats_table)
        success_layout.addWidget(reset_stats_btn)

        layout.addWidget(test_env_group)
        layout.addWidget(payload_test_group)
        layout.addWidget(success_group)
        layout.addStretch()

        return tab

    def create_rop_gadgets_tab(self) -> QWidget:
        """Create ROP gadgets analysis tab with binary selection.

        Returns:
            QWidget: The created widget for ROP gadget analysis.
        """
        tab = QWidget()
        layout = QVBoxLayout(tab)

        binary_group = QGroupBox("Binary Selection")
        binary_layout = QVBoxLayout(binary_group)

        path_layout = QHBoxLayout()
        path_layout.addWidget(QLabel("Target Binary:"))
        self.rop_binary_edit = QLineEdit()
        self.rop_binary_edit.setToolTip("Path to binary file for ROP gadget extraction")
        if self.current_binary_path and os.path.exists(self.current_binary_path):
            self.rop_binary_edit.setText(self.current_binary_path)
        path_layout.addWidget(self.rop_binary_edit)

        browse_rop_btn = QPushButton("Browse")
        browse_rop_btn.clicked.connect(self.browse_rop_binary)
        path_layout.addWidget(browse_rop_btn)

        arch_layout = QHBoxLayout()
        arch_layout.addWidget(QLabel("Architecture:"))
        self.rop_arch_combo = QComboBox()
        self.rop_arch_combo.addItems(["x86_64", "x86", "ARM64", "ARM"])
        import platform
        default_arch = "x86_64" if platform.machine() == "AMD64" else "x86"
        self.rop_arch_combo.setCurrentText(default_arch)
        arch_layout.addWidget(self.rop_arch_combo)
        arch_layout.addStretch()

        status_layout = QHBoxLayout()
        self.rop_status_label = QLabel("Status: No binary loaded")
        self.rop_status_label.setStyleSheet("color: #888888; font-style: italic;")
        status_layout.addWidget(self.rop_status_label)
        status_layout.addStretch()

        binary_layout.addLayout(path_layout)
        binary_layout.addLayout(arch_layout)
        binary_layout.addLayout(status_layout)

        analysis_group = QGroupBox("Gadget Analysis")
        analysis_layout = QVBoxLayout(analysis_group)

        options_layout = QHBoxLayout()
        self.rop_max_gadgets_spin = QSpinBox()
        self.rop_max_gadgets_spin.setRange(100, 100000)
        self.rop_max_gadgets_spin.setValue(5000)
        self.rop_max_gadgets_spin.setToolTip("Maximum number of gadgets to find")
        options_layout.addWidget(QLabel("Max Gadgets:"))
        options_layout.addWidget(self.rop_max_gadgets_spin)

        self.rop_depth_spin = QSpinBox()
        self.rop_depth_spin.setRange(1, 20)
        self.rop_depth_spin.setValue(10)
        self.rop_depth_spin.setToolTip("Maximum gadget instruction depth")
        options_layout.addWidget(QLabel("Max Depth:"))
        options_layout.addWidget(self.rop_depth_spin)
        options_layout.addStretch()

        filter_layout = QHBoxLayout()
        self.rop_filter_edit = QLineEdit()
        self.rop_filter_edit.setToolTip("Filter gadgets by instruction pattern (e.g., 'pop rdi', 'ret', 'syscall')")
        filter_layout.addWidget(QLabel("Filter:"))
        filter_layout.addWidget(self.rop_filter_edit)

        analysis_layout.addLayout(options_layout)
        analysis_layout.addLayout(filter_layout)

        actions_group = QGroupBox("Actions")
        actions_layout = QHBoxLayout(actions_group)

        find_gadgets_btn = QPushButton("Find ROP Gadgets")
        find_gadgets_btn.setToolTip("Extract ROP gadgets from the selected binary")
        find_gadgets_btn.clicked.connect(self.find_rop_gadgets)
        find_gadgets_btn.setStyleSheet("font-weight: bold; color: green; padding: 8px;")

        export_gadgets_btn = QPushButton("Export Gadgets")
        export_gadgets_btn.setToolTip("Export found gadgets to file")
        export_gadgets_btn.clicked.connect(self.export_rop_gadgets)

        build_chain_btn = QPushButton("Build ROP Chain")
        build_chain_btn.setToolTip("Build ROP chain from found gadgets")
        build_chain_btn.clicked.connect(self.build_rop_chain)
        build_chain_btn.setStyleSheet("color: blue; font-weight: bold;")

        actions_layout.addWidget(find_gadgets_btn)
        actions_layout.addWidget(export_gadgets_btn)
        actions_layout.addWidget(build_chain_btn)

        stats_group = QGroupBox("Gadget Statistics")
        stats_layout = QVBoxLayout(stats_group)

        self.rop_stats_label = QLabel(
            "Total Gadgets: 0 | Pop Gadgets: 0 | "
            "Move Gadgets: 0 | Syscall Gadgets: 0 | Ret Gadgets: 0"
        )
        self.rop_stats_label.setWordWrap(True)
        stats_layout.addWidget(self.rop_stats_label)

        layout.addWidget(binary_group)
        layout.addWidget(analysis_group)
        layout.addWidget(actions_group)
        layout.addWidget(stats_group)
        layout.addStretch()

        return tab

    def create_results_panel(self) -> QWidget:
        """Create the results and logging panel.

        Returns:
            QWidget: The created widget for results and logging.
        """
        panel = QWidget()
        layout = QVBoxLayout(panel)

        # Results tabs
        self.results_tabs = QTabWidget()
        self.results_tabs.setTabPosition(QTabWidget.TabPosition.North)

        # Console output
        self.console_output = QTextEdit()
        self.console_output.setReadOnly(True)
        self.console_output.setFont(QFont("Consolas", 9))
        self.console_output.setStyleSheet("background-color: #1e1e1e; color: #ffffff;")
        self.results_tabs.addTab(self.console_output, "Console Output")

        # Test results
        self.test_results_table = QTableWidget()
        self.test_results_table.setColumnCount(6)
        self.test_results_table.setHorizontalHeaderLabels(
            [
                "Test Name",
                "Type",
                "Status",
                "Time",
                "Result",
                "Notes",
            ],
        )
        header = self.test_results_table.horizontalHeader()
        if header is not None:
            header.setStretchLastSection(True)
        self.results_tabs.addTab(self.test_results_table, "Test Results")

        self.payload_display = QTextEdit()
        self.payload_display.setReadOnly(True)
        self.payload_display.setFont(QFont("Consolas", 9))
        self.payload_display.setStyleSheet("background-color: #1e1e1e; color: #00ff00;")
        self.results_tabs.addTab(self.payload_display, "Payload Display")

        self.gadgets_table = QTableWidget()
        self.gadgets_table.setColumnCount(5)
        self.gadgets_table.setHorizontalHeaderLabels(
            [
                "Address",
                "Instruction",
                "Type",
                "Bytes",
                "Size",
            ],
        )
        gadgets_header = self.gadgets_table.horizontalHeader()
        if gadgets_header is not None:
            gadgets_header.setStretchLastSection(True)
        self.results_tabs.addTab(self.gadgets_table, "ROP Gadgets")

        layout.addWidget(self.results_tabs)

        # Control buttons
        controls_layout = QHBoxLayout()

        clear_output_btn = QPushButton("Clear Output")
        clear_output_btn.clicked.connect(self.clear_output)

        save_results_btn = QPushButton("Save Results")
        save_results_btn.clicked.connect(self.save_results)

        export_payloads_btn = QPushButton("Export Payloads")
        export_payloads_btn.clicked.connect(self.export_payloads)

        controls_layout.addWidget(clear_output_btn)
        controls_layout.addWidget(save_results_btn)

        # Add new result management buttons
        clear_cache_btn = QPushButton("Clear Cache")
        clear_cache_btn.clicked.connect(self.clear_results_cache)
        controls_layout.addWidget(clear_cache_btn)

        view_history_btn = QPushButton("View History")
        view_history_btn.clicked.connect(self.view_results_history)
        controls_layout.addWidget(view_history_btn)
        controls_layout.addWidget(export_payloads_btn)
        controls_layout.addStretch()

        layout.addLayout(controls_layout)

        return panel

    # Method implementations
    def find_rop_gadgets(self) -> None:
        """Find ROP gadgets in the selected binary.

        Analyzes a target binary to locate ROP gadgets that can be used for
        constructing ROP chains for licensing protection bypass. Displays results
        in the gadgets table with filtering and statistics tracking.
        """
        binary_path: str | None = None
        if hasattr(self, "rop_binary_edit") and self.rop_binary_edit.text().strip():
            binary_path = self.rop_binary_edit.text().strip()
        elif self.current_binary_path:
            binary_path = self.current_binary_path

        if not binary_path:
            self.log_message("Error: No binary selected for gadget analysis", "error")
            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText("Status: No binary selected")
                self.rop_status_label.setStyleSheet("color: #ff4444; font-weight: bold;")
            QMessageBox.warning(
                self,
                "No Binary Selected",
                "Please select a binary file for ROP gadget analysis.\n\n"
                "Use the 'Browse' button in the ROP Gadgets tab to select a file.",
            )
            return

        if not os.path.exists(binary_path):
            self.log_message(f"Error: Binary file not found: {binary_path}", "error")
            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText("Status: File not found")
                self.rop_status_label.setStyleSheet("color: #ff4444; font-weight: bold;")
            return

        try:
            from ...core.analysis.rop_generator import ROPChainGenerator

            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText("Status: Analyzing...")
                self.rop_status_label.setStyleSheet("color: #ffaa00; font-weight: bold;")

            self.log_message(f"Finding ROP gadgets in {binary_path}...")

            arch = "x86_64"
            if hasattr(self, "rop_arch_combo"):
                arch = self.rop_arch_combo.currentText()

            max_gadgets = 5000
            if hasattr(self, "rop_max_gadgets_spin"):
                max_gadgets = self.rop_max_gadgets_spin.value()

            max_depth = 10
            if hasattr(self, "rop_depth_spin"):
                max_depth = self.rop_depth_spin.value()

            config = {
                "arch": arch,
                "max_gadgets": max_gadgets,
                "max_depth": max_depth,
            }
            rop_gen = ROPChainGenerator(config)

            if rop_gen.set_binary(binary_path):
                if rop_gen.find_gadgets():
                    results = rop_gen.get_results()
                    gadgets = results.get("gadgets", [])

                    gadget_filter = ""
                    if hasattr(self, "rop_filter_edit"):
                        gadget_filter = self.rop_filter_edit.text().strip().lower()

                    if gadget_filter:
                        gadgets = [
                            g for g in gadgets
                            if gadget_filter in str(g.get("instruction", "")).lower()
                        ]

                    self.update_gadgets_table(gadgets)
                    self._update_rop_statistics(gadgets)

                    self.log_message(f"Found {len(gadgets)} ROP gadgets", "success")

                    if hasattr(self, "rop_status_label"):
                        self.rop_status_label.setText(f"Status: Found {len(gadgets)} gadgets")
                        self.rop_status_label.setStyleSheet("color: #44ff44; font-weight: bold;")

                    self.current_rop_generator = rop_gen
                else:
                    self.log_message("Failed to find gadgets in binary", "error")
                    if hasattr(self, "rop_status_label"):
                        self.rop_status_label.setText("Status: No gadgets found")
                        self.rop_status_label.setStyleSheet("color: #ff8800;")
            else:
                self.log_message("Failed to load binary for analysis", "error")
                if hasattr(self, "rop_status_label"):
                    self.rop_status_label.setText("Status: Failed to load binary")
                    self.rop_status_label.setStyleSheet("color: #ff4444; font-weight: bold;")

        except ImportError:
            self.log_message("Error: ROP generator module not available", "error")
            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText("Status: ROP module unavailable")
                self.rop_status_label.setStyleSheet("color: #ff4444;")
        except Exception as e:
            logger.exception("Error finding gadgets: %s", e)
            self.log_message(f"Error finding gadgets: {e!s}", "error")
            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText(f"Status: Error - {e!s}")
                self.rop_status_label.setStyleSheet("color: #ff4444;")

    def _update_rop_statistics(self, gadgets: list[dict[str, object]]) -> None:
        """Update ROP gadget statistics display.

        Analyzes found ROP gadgets and updates the statistics label with counts
        of different gadget types (pop, mov, syscall, ret) for chain construction.

        Args:
            gadgets: List of gadget dictionaries containing instruction and type information.
        """
        if not hasattr(self, "rop_stats_label"):
            return

        total = len(gadgets)
        pop_count = sum(1 for g in gadgets if "pop" in str(g.get("instruction", "")).lower())
        mov_count = sum(1 for g in gadgets if "mov" in str(g.get("instruction", "")).lower())
        syscall_count = sum(
            1 for g in gadgets
            if any(s in str(g.get("instruction", "")).lower() for s in ["syscall", "int 0x80", "sysenter"])
        )
        ret_count = sum(1 for g in gadgets if "ret" in str(g.get("instruction", "")).lower())

        self.rop_stats_label.setText(
            f"Total Gadgets: {total} | Pop Gadgets: {pop_count} | "
            f"Move Gadgets: {mov_count} | Syscall Gadgets: {syscall_count} | Ret Gadgets: {ret_count}"
        )

    def update_gadgets_table(self, gadgets: list[dict[str, object]]) -> None:
        """Update the gadgets table with found ROP gadgets.

        Populates the gadgets table widget with ROP gadget information including
        addresses, instructions, and gadget types for license bypass chain building.

        Args:
            gadgets: List of gadget dictionaries containing 'address', 'instruction',
                'type', 'bytes', and optionally 'size' and 'regs' fields.
        """
        try:
            if not hasattr(self, "gadgets_table"):
                self.log_message("Gadgets table not initialized", "error")
                return

            self.gadgets_table.setRowCount(0)

            if not gadgets:
                self.log_message("No gadgets to display", "info")
                return

            self.gadgets_table.setRowCount(len(gadgets))

            for row, gadget in enumerate(gadgets):
                address = gadget.get("address", "")
                if isinstance(address, int):
                    address = f"0x{address:08X}"
                elif isinstance(address, str) and not address.startswith("0x"):
                    with contextlib.suppress(ValueError):
                        address = f"0x{int(address, 16):08X}"

                address_item = QTableWidgetItem(str(address))
                self.gadgets_table.setItem(row, 0, address_item)

                instruction = gadget.get("instruction", gadget.get("insn", gadget.get("asm", "")))
                if isinstance(instruction, list):
                    instruction = "; ".join(instruction)
                instruction_item = QTableWidgetItem(str(instruction))
                self.gadgets_table.setItem(row, 1, instruction_item)

                gadget_type = gadget.get("type", "")
                if not gadget_type:
                    instr_lower = str(instruction).lower()
                    if "ret" in instr_lower:
                        gadget_type = "pop-ret" if "pop" in instr_lower else "ret"
                    elif "call" in instr_lower:
                        gadget_type = "call"
                    elif "jmp" in instr_lower:
                        gadget_type = "jmp"
                    elif "mov" in instr_lower:
                        gadget_type = "mov"
                    elif "xchg" in instr_lower:
                        gadget_type = "xchg"
                    elif "add" in instr_lower or "sub" in instr_lower:
                        gadget_type = "arithmetic"
                    elif "push" in instr_lower:
                        gadget_type = "push"
                    elif "pop" in instr_lower:
                        gadget_type = "pop"
                    elif "xor" in instr_lower or "and" in instr_lower or "or" in instr_lower:
                        gadget_type = "logic"
                    elif "syscall" in instr_lower or "int" in instr_lower:
                        gadget_type = "syscall"
                    else:
                        gadget_type = "misc"

                type_item = QTableWidgetItem(str(gadget_type))
                self.gadgets_table.setItem(row, 2, type_item)

                if self.gadgets_table.columnCount() > 3:
                    gadget_bytes = gadget.get("bytes", gadget.get("opcodes", ""))
                    if isinstance(gadget_bytes, bytes):
                        gadget_bytes = gadget_bytes.hex()
                    elif isinstance(gadget_bytes, list):
                        gadget_bytes = "".join(f"{b:02x}" for b in gadget_bytes)
                    bytes_item = QTableWidgetItem(str(gadget_bytes))
                    self.gadgets_table.setItem(row, 3, bytes_item)

                if self.gadgets_table.columnCount() > 4:
                    gadget_bytes_val = gadget.get("bytes", [])
                    size = gadget.get("size", len(gadget_bytes_val) if isinstance(gadget_bytes_val, (list, bytes)) else 0)
                    size_item = QTableWidgetItem(str(size))
                    self.gadgets_table.setItem(row, 4, size_item)

            self.gadgets_table.resizeColumnsToContents()

            self.log_message(f"Loaded {len(gadgets)} gadgets into table", "success")

        except Exception as e:
            logger.exception("Error updating gadgets table: %s", e)
            self.log_message(f"Error updating gadgets table: {e!s}", "error")

    def _get_default_binary_path(self) -> str:
        """Get a cross-platform default binary path for license analysis.

        Finds a suitable default executable path for binary analysis based on
        the current operating system, checking for common utilities and system
        executables.

        Returns:
            str: Path to a system executable or empty string if none found.
        """
        import os
        import sys

        if getattr(sys, "frozen", False):
            return sys.executable

        import platform
        system = platform.system().lower()

        if system == "windows":
            candidates = [
                os.path.join(os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "notepad.exe"),
                os.path.join(os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "calc.exe"),
                os.path.join(os.environ.get("PROGRAMFILES", "C:\\Program Files"), "Windows NT", "Accessories", "wordpad.exe"),
            ]
        elif system == "darwin":
            candidates = [
                "/Applications/Calculator.app/Contents/MacOS/Calculator",
                "/Applications/TextEdit.app/Contents/MacOS/TextEdit",
                "/usr/bin/python3",
            ]
        else:
            candidates = [
                "/usr/bin/python3",
                "/usr/bin/python",
                "/bin/ls",
                "/usr/bin/cat",
            ]

        for path in candidates:
            if os.path.isfile(path):
                return path

        return sys.executable if os.path.isfile(sys.executable) else ""

    def _validate_memory_address(self, address: str) -> tuple[bool, int | None, str]:
        """Validate a memory address string for proper format and range.

        Parses and validates memory address strings in hex or decimal format,
        checking for proper formatting and reasonable 32/64-bit address ranges
        for licensing protection patch application.

        Args:
            address: Address string to validate (e.g., "0x401000", "4198400").

        Returns:
            Tuple containing (is_valid, parsed_address_int, error_message) where
                is_valid is True if address is valid, parsed_address_int is the
                parsed integer value or None if invalid, and error_message describes
                any validation errors.
        """
        if not address:
            return False, None, "Address cannot be empty"

        address = address.strip()
        parsed_addr: int | None = None

        try:
            if address.lower().startswith("0x"):
                hex_part = address[2:]
                if not hex_part:
                    return False, None, "No hex digits after '0x' prefix"
                for char in hex_part.lower():
                    if char not in "0123456789abcdef":
                        return False, None, f"Invalid hex character: '{char}'"
                parsed_addr = int(address, 16)
            else:
                if address.isdigit():
                    parsed_addr = int(address)
                else:
                    return False, None, "Address must be hex (0x...) or decimal number"

            if parsed_addr < 0:
                return False, None, "Address cannot be negative"

            max_32bit = 0xFFFFFFFF
            max_64bit = 0xFFFFFFFFFFFFFFFF

            if parsed_addr > max_64bit:
                return False, None, f"Address exceeds 64-bit maximum: {hex(parsed_addr)}"

            if parsed_addr > max_32bit:
                logger.debug("Address %#x is 64-bit", parsed_addr)

            return True, parsed_addr, ""

        except ValueError as e:
            return False, None, f"Failed to parse address: {e!s}"
        except OverflowError:
            return False, None, "Address value overflow"

    def add_patch(self) -> None:
        """Add patch to queue.

        Validates patch configuration from UI inputs (address, type, data) and
        adds it to the patch queue for later application to the target binary
        for license protection defeat.
        """
        target_addr = self.target_address_edit.text().strip()
        patch_type = self.patch_type_combo.currentText()
        patch_data = self.patch_data_edit.toPlainText().strip()

        if not target_addr or not patch_data:
            self.log_message("Error: Address and patch data required", "error")
            return

        is_valid, parsed_addr, error_msg = self._validate_memory_address(target_addr)
        if not is_valid:
            self.log_message(f"Error: Invalid address - {error_msg}", "error")
            return

        try:
            normalized_addr = f"0x{parsed_addr:X}" if parsed_addr is not None else target_addr
            patch_info = {
                "address": normalized_addr,
                "type": patch_type,
                "data": patch_data,
                "status": "pending",
                "parsed_address": parsed_addr,
            }

            self.patches.append(patch_info)

            # Update patch list
            patch_desc = f"{patch_type} @ {target_addr}: {patch_data[:50]}..."
            self.patch_list.addItem(patch_desc)

            self.log_message(f"Added patch: {patch_type} @ {target_addr}", "success")

        except Exception as e:
            logger.exception("Error adding patch: %s", e)
            self.log_message(f"Error adding patch: {e!s}", "error")

    def remove_patch(self) -> None:
        """Remove selected patch from queue.

        Removes the currently selected patch from the patch queue, updating
        the patch list widget accordingly.
        """
        current_row = self.patch_list.currentRow()

        if current_row >= 0 and current_row < len(self.patches):
            patch = self.patches[current_row]
            self.patches.pop(current_row)
            self.patch_list.takeItem(current_row)

            self.log_message(f"Removed patch @ {patch['address']}", "success")
        else:
            self.log_message("Error: No patch selected", "error")

    def edit_patch(self) -> None:
        """Edit selected patch.

        Loads the selected patch configuration into UI controls for editing
        before reapplication to the patch queue.
        """
        current_row = self.patch_list.currentRow()

        if current_row >= 0 and current_row < len(self.patches):
            patch = self.patches[current_row]

            # Populate fields with current patch data
            self.target_address_edit.setText(patch["address"])
            self.patch_type_combo.setCurrentText(patch["type"])
            self.patch_data_edit.setPlainText(patch["data"])

            self.log_message(f"Loaded patch @ {patch['address']} for editing", "info")
        else:
            self.log_message("Error: No patch selected", "error")

    def validate_patches(self) -> None:
        """Validate patches before application.

        Validates all patches in the queue for proper formatting, address ranges,
        and data integrity before applying them to the target binary.
        """
        if not self.patches:
            self.log_message("Error: No patches to validate", "error")
            return

        try:
            valid_patches = 0

            for i, patch in enumerate(self.patches):
                is_valid = True
                validation_errors: list[str] = []

                addr_valid, parsed_addr, addr_error = self._validate_memory_address(patch["address"])
                if not addr_valid:
                    validation_errors.append(f"Address: {addr_error}")
                    is_valid = False
                else:
                    patch["parsed_address"] = parsed_addr

                if patch["type"] in {"NOP Patch", "Jump Patch"} and not patch["data"]:
                    validation_errors.append("No data specified")
                    is_valid = False

                if patch["type"] in {"Hex Patch", "Byte Patch"} and patch["data"]:
                    hex_data = patch["data"].replace(" ", "").replace("0x", "")
                    if len(hex_data) % 2 != 0:
                        validation_errors.append("Hex data must have even length")
                        is_valid = False
                    else:
                        for char in hex_data.lower():
                            if char not in "0123456789abcdef":
                                validation_errors.append(f"Invalid hex character in data: '{char}'")
                                is_valid = False
                                break

                if is_valid:
                    valid_patches += 1
                    patch["status"] = "valid"
                else:
                    patch["status"] = "invalid"
                    for error in validation_errors:
                        self.log_message(f"Patch {i + 1}: {error}", "warning")

            self.log_message(f"Validation complete: {valid_patches}/{len(self.patches)} patches valid", "success")

        except Exception as e:
            logger.exception("Error validating patches: %s", e)
            self.log_message(f"Error validating patches: {e!s}", "error")

    def test_patches_in_sandbox(self) -> None:
        """Test patches in isolated sandbox environment with comprehensive validation.

        Validates all queued patches by applying them to a temporary copy of
        the target binary and verifying binary integrity and execution behavior.
        Uses firejail sandbox if available for isolated testing.
        """
        if not self.patches:
            self.log_message("Error: No patches to test", "error")
            return

        try:
            self.log_message("Testing patches in isolated sandbox environment...")

            # Import necessary modules
            import shutil
            import subprocess
            import tempfile

            validation_text = "Patch Validation Results:\n"
            validation_text += "=" * 50 + "\n\n"

            # Create temporary directory for testing
            with tempfile.TemporaryDirectory() as temp_dir:
                # Copy binary to temp location
                if self.current_binary_path and os.path.exists(self.current_binary_path):
                    temp_binary = os.path.join(temp_dir, os.path.basename(self.current_binary_path))
                    shutil.copy2(self.current_binary_path, temp_binary)

                    for i, patch in enumerate(self.patches):
                        validation_text += f"Patch {i + 1}:\n"
                        validation_text += f"  Address: {patch['address']}\n"
                        validation_text += f"  Type: {patch['type']}\n"
                        validation_text += f"  Data: {patch['data']}\n"

                        # Test patch application
                        try:
                            # Apply patch to temporary binary
                            with open(temp_binary, "rb+") as f:
                                # Convert address to offset
                                if patch["address"].startswith("0x"):
                                    offset = int(patch["address"], 16)
                                else:
                                    offset = int(patch["address"])

                                # Seek to patch location
                                f.seek(offset)

                                # Read original bytes
                                original_bytes = f.read(len(patch["data"]))

                                # Write patch data
                                f.seek(offset)
                                if isinstance(patch["data"], str):
                                    patch_bytes = bytes.fromhex(patch["data"].replace(" ", ""))
                                else:
                                    patch_bytes = patch["data"]
                                f.write(patch_bytes)

                            # Verify patched binary integrity
                            try:
                                # Check if binary is still valid PE/ELF
                                from intellicrack.handlers.pefile_handler import pefile

                                pe = pefile.PE(temp_binary, fast_load=True)
                                pe.close()

                                validation_text += "  Status: Patch applied successfully\n"
                                validation_text += f"  Original bytes: {original_bytes.hex()}\n"
                                validation_text += f"  New bytes: {patch_bytes.hex()}\n"
                                validation_text += "  Binary integrity: PASS\n"

                            except Exception as pe_error:
                                validation_text += "  Status: Patch applied with warnings\n"
                                validation_text += f"  Warning: {pe_error!s}\n"

                            # Test in sandbox if available
                            if shutil.which("firejail"):
                                # Test execution in sandbox
                                test_cmd = [
                                    "firejail",
                                    "--noprofile",
                                    "--quiet",
                                    temp_binary,
                                    "--test",
                                ]
                                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis
                                    test_cmd,
                                    check=False,
                                    capture_output=True,
                                    timeout=5,
                                )

                                if result.returncode == 0:
                                    validation_text += "  Sandbox test: PASS\n"
                                else:
                                    validation_text += f"  Sandbox test: Exit code {result.returncode}\n"
                            else:
                                validation_text += "  Sandbox test: Not available\n"

                        except Exception as patch_error:
                            validation_text += f"  Status: Failed - {patch_error!s}\n"

                        validation_text += "\n"

                        # Restore original binary for next patch test
                        if self.current_binary_path:
                            shutil.copy2(self.current_binary_path, temp_binary)
                else:
                    validation_text += "Warning: No binary file available for testing\n"
                    validation_text += "Performing theoretical validation only:\n\n"

                    for i, patch in enumerate(self.patches):
                        validation_text += f"Patch {i + 1}:\n"
                        validation_text += f"  Address: {patch['address']}\n"
                        validation_text += f"  Type: {patch['type']}\n"
                        validation_text += f"  Data: {patch['data']}\n"
                        validation_text += "  Validation: Address and data format valid\n\n"

            self.payload_display.setPlainText(validation_text)
            self.log_message("Patch testing completed", "success")

        except Exception as e:
            logger.exception("Error testing patches: %s", e)
            self.log_message(f"Error testing patches: {e!s}", "error")

    def refresh_processes(self) -> None:
        """Refresh list of running processes.

        Populates the process selection combo box with currently running processes
        that can be targeted for memory patching and license protection bypass.
        Attempts to use psutil first, falling back to Windows API if unavailable.
        """
        self.process_combo.clear()
        processes_loaded = False

        try:
            from intellicrack.handlers.psutil_handler import psutil

            for proc in psutil.process_iter(["pid", "name"]):
                try:
                    process_info = proc.info
                    self.process_combo.addItem(f"{process_info['name']} ({process_info['pid']})")
                    processes_loaded = True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue

            if processes_loaded:
                self.log_message("Process list refreshed", "success")
            else:
                self.log_message("No accessible processes found", "warning")

        except ImportError:
            processes_loaded = self._refresh_processes_native_fallback()
            if not processes_loaded:
                self.log_message(
                    "psutil not available - enter process name (PID) manually in combo box",
                    "warning",
                )
                self.process_combo.addItem("Enter process name and PID manually")

        except Exception as e:
            logger.exception("Error refreshing processes: %s", e)
            self.log_message(f"Error refreshing processes: {e!s}", "error")

    def _refresh_processes_native_fallback(self) -> bool:
        """Fallback process enumeration using Windows API when psutil unavailable.

        Uses CreateToolhelp32Snapshot and Process32First/Next Win32 APIs to enumerate
        running processes as a fallback when psutil module is not available.

        Returns:
            bool: True if at least one process was enumerated successfully,
                False otherwise.
        """
        try:
            import ctypes
            from ctypes import wintypes

            th32cs_snapprocess = 0x00000002

            class _ProcessEntry32(ctypes.Structure):
                _fields_: list[tuple[str, type]] = [
                    ("dwSize", wintypes.DWORD),
                    ("cntUsage", wintypes.DWORD),
                    ("th32ProcessID", wintypes.DWORD),
                    ("th32DefaultHeapID", ctypes.POINTER(ctypes.c_ulong)),
                    ("th32ModuleID", wintypes.DWORD),
                    ("cntThreads", wintypes.DWORD),
                    ("th32ParentProcessID", wintypes.DWORD),
                    ("pcPriClassBase", ctypes.c_long),
                    ("dwFlags", wintypes.DWORD),
                    ("szExeFile", ctypes.c_char * 260),
                ]

            kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
            create_snapshot = kernel32.CreateToolhelp32Snapshot
            create_snapshot.argtypes = [wintypes.DWORD, wintypes.DWORD]
            create_snapshot.restype = wintypes.HANDLE

            process_first = kernel32.Process32First
            process_first.argtypes = [wintypes.HANDLE, ctypes.POINTER(_ProcessEntry32)]
            process_first.restype = wintypes.BOOL

            process_next = kernel32.Process32Next
            process_next.argtypes = [wintypes.HANDLE, ctypes.POINTER(_ProcessEntry32)]
            process_next.restype = wintypes.BOOL

            close_handle = kernel32.CloseHandle
            close_handle.argtypes = [wintypes.HANDLE]
            close_handle.restype = wintypes.BOOL

            snapshot = create_snapshot(th32cs_snapprocess, 0)
            if snapshot == -1:
                return False

            pe32 = _ProcessEntry32()
            pe32.dwSize = ctypes.sizeof(_ProcessEntry32)

            processes_found = False
            if process_first(snapshot, ctypes.byref(pe32)):
                while True:
                    proc_name = pe32.szExeFile.decode("utf-8", errors="replace")
                    pid = pe32.th32ProcessID
                    if pid > 0:
                        self.process_combo.addItem(f"{proc_name} ({pid})")
                        processes_found = True
                    if not process_next(snapshot, ctypes.byref(pe32)):
                        break

            close_handle(snapshot)

            if processes_found:
                self.log_message("Process list refreshed (native API fallback)", "success")

            return processes_found

        except (OSError, AttributeError, ValueError) as e:
            logger.debug("Native process enumeration failed: %s", e)
            return False

    def attach_to_process(self) -> None:
        """Attach to target process.

        Establishes a connection to a selected running process by extracting
        its PID from the process combo box, enabling memory patching and
        runtime license protection bypass operations.
        """
        process_info = self.process_combo.currentText()

        if not process_info:
            self.log_message("Error: No process selected", "error")
            return

        try:
            # Extract PID from process info
            if "(" in process_info and ")" in process_info:
                pid_str = process_info.split("(")[-1].split(")")[0]
                pid = int(pid_str)

                self.log_message(f"Attaching to process {pid}...")

                # Store attached process
                self.attached_process = pid

                self.log_message(f"Successfully attached to process {pid}", "success")
            else:
                self.log_message("Error: Invalid process format", "error")

        except Exception as e:
            logger.exception("Error attaching to process: %s", e)
            self.log_message(f"Error attaching to process: {e!s}", "error")

    def patch_memory(self) -> None:
        """Apply sophisticated license bypass patches to running process.

        Applies memory patches to an attached process at the specified address
        using the configured patch type and size. Bypasses memory protection,
        applies the patch, and scans for similar license protection patterns
        to identify additional bypass targets.
        """
        if self.attached_process is None:
            self.log_message("Error: No process attached", "error")
            return

        memory_addr = self.memory_address_edit.text().strip()
        patch_size = self.patch_size_spin.value()

        if not memory_addr:
            self.log_message("Error: No memory address specified", "error")
            return

        try:
            from ...core.patching.memory_patcher import bypass_memory_protection, patch_memory_direct

            # Convert address
            addr_int: int
            if memory_addr.startswith("0x"):
                addr_int = int(memory_addr, 16)
            else:
                addr_int = int(memory_addr)

            # Determine patch type from UI selection
            patch_type = self._get_selected_patch_type()

            # Generate patch data based on type
            patch_data = self._generate_patch_data(patch_type, patch_size, addr_int)

            self.log_message(f"Applying {patch_type} patch at {memory_addr} ({len(patch_data)} bytes)...")

            # First bypass memory protection
            if bypass_memory_protection(addr_int, len(patch_data)):
                self.log_message("Memory protection bypassed", "success")
            else:
                self.log_message("Warning: Could not bypass memory protection", "warning")

            # Apply the patch
            if patch_memory_direct(self.attached_process, addr_int, patch_data):
                self.log_message(f"Memory patched successfully at {memory_addr}", "success")
                self.log_message(f"Patch type: {patch_type}", "info")
                self.memory_patched.emit(memory_addr, "success")
                self.record_exploit_result("Memory Patch", success=True)

                # If this is a license check patch, scan for more
                if "license" in patch_type.lower() or "trial" in patch_type.lower():
                    self._scan_for_similar_patterns(addr_int)

            else:
                self.log_message("Memory patching failed", "error")
                self.memory_patched.emit(memory_addr, "failed")
                self.record_exploit_result("Memory Patch", success=False)

        except Exception as e:
            logger.exception("Error patching memory: %s", e)
            self.log_message(f"Error patching memory: {e!s}", "error")

    def _get_selected_patch_type(self) -> str:
        """Determine patch type from UI selection.

        Retrieves the currently selected patch type from the patch type combo box,
        defaulting to "NOP" if no selector is available.

        Returns:
            str: The selected patch type string for license protection bypass.
        """
        # Check if we have a patch type selector
        if hasattr(self, "patch_type_combo"):
            return self.patch_type_combo.currentText()
        return "NOP"

    def _generate_patch_data(self, patch_type: str, size: int, address: int | str) -> bytes:
        """Generate patch data based on type for license bypassing.

        Args:
            patch_type: Type of patch to generate (NOP, Custom, HWID Bypass, etc).
            size: Size of the patch data in bytes.
            address: Target memory address as integer or hex string.

        Returns:
            bytes: The generated patch data.
        """
        # Convert address to int if it's a string
        addr_int: int
        if isinstance(address, str):
            addr_int = int(address, 16) if address.startswith("0x") else int(address)
        else:
            addr_int = address

        # x86/x64 assembly opcodes for different patch types
        if patch_type == "NOP":
            # NOP sled - commonly used to skip checks
            return b"\x90" * size

        if patch_type == "Custom":
            # Allow custom hex input
            if hasattr(self, "custom_patch_edit"):
                custom_hex = self.custom_patch_edit.text().strip()
                with contextlib.suppress(ValueError, TypeError, AttributeError):
                    custom_bytes = bytes.fromhex(custom_hex.replace(" ", ""))
                    if len(custom_bytes) <= size:
                        return custom_bytes + b"\x90" * (size - len(custom_bytes))
            return b"\x90" * size

        elif patch_type == "HWID Bypass":
            # Skip hardware ID check - typically a call followed by test
            if size >= 5:
                # Replace CALL with MOV EAX, 1 (success)
                return b"\xb8\x01\x00\x00\x00" + b"\x90" * (size - 5)
            return b"\x90" * size

        elif patch_type == "Invert JZ/JNZ":
            # Invert conditional jump (JZ <-> JNZ)
            # Read current instruction first
            with contextlib.suppress(ValueError, TypeError, AttributeError):
                import ctypes

                kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
                current_byte = ctypes.c_byte()
                bytes_read = ctypes.c_size_t()

                if kernel32.ReadProcessMemory(
                    self.attached_process,
                    ctypes.c_void_p(addr_int),
                    ctypes.byref(current_byte),
                    1,
                    ctypes.byref(bytes_read),
                ):
                    # Invert JZ (0x74) to JNZ (0x75) or vice versa
                    if current_byte.value == 0x74:
                        return b"\x75" + b"\x90" * (size - 1)
                    if current_byte.value == 0x75:
                        return b"\x74" + b"\x90" * (size - 1)
                    # Also handle JE (0x84) and JNE (0x85) for longer jumps
                    if current_byte.value == 0x0F:
                        # Read next byte for long conditional jumps
                        next_byte = ctypes.c_byte()
                        kernel32.ReadProcessMemory(
                            self.attached_process,
                            ctypes.c_void_p(addr_int + 1),
                            ctypes.byref(next_byte),
                            1,
                            ctypes.byref(bytes_read),
                        )
                        if next_byte.value == 0x84:  # JE
                            return b"\x0f\x85" + b"\x90" * (size - 2)
                        if next_byte.value == 0x85:  # JNE
                            return b"\x0f\x84" + b"\x90" * (size - 2)
            return b"\x90" * size

        elif patch_type == "JMP Near":
            # Near jump for larger skips
            if size >= 5:
                offset = size - 5
                return b"\xe9" + offset.to_bytes(4, "little") + b"\x90" * (size - 5)
            return b"\x90" * size

        elif patch_type == "JMP Short":
            # Short unconditional jump to skip license check
            return b"\xeb" + bytes([size - 2]) + b"\x90" * (size - 2) if size >= 2 else b"\x90" * size
        elif patch_type == "License String":
            # Overwrite with valid license pattern
            license_bytes = b"VALID-LICENSE-KEY"
            if size >= len(license_bytes):
                return license_bytes + b"\x00" * (size - len(license_bytes))
            return b"VALID"[:size]

        elif patch_type == "MOV EAX,1 + RET":
            # Return 1/true (common for successful validation bypass)
            if size >= 6:
                return b"\xb8\x01\x00\x00\x00\xc3" + b"\x90" * (size - 6)
            return b"\x90" * size

        elif patch_type == "Trial Reset":
            # Common trial reset patterns
            if size >= 10:
                # MOV [register], 0x1E (30 days) pattern
                return b"\xc7\x00\x1e\x00\x00\x00" + b"\x90" * (size - 6)
            return b"\x90" * size

        elif patch_type == "XOR EAX,EAX + RET":
            # Return 0 (common for failed check bypass)
            if size >= 3:
                return b"\x31\xc0\xc3" + b"\x90" * (size - 3)
            return b"\x90" * size

        # Default to NOP
        return b"\x90" * size

    def _scan_for_similar_patterns(self, patched_address: int) -> None:
        """Scan for similar patterns that might need patching.

        Searches the attached process memory for license check patterns similar
        to the one just patched, within 64KB proximity to the patched address,
        to identify additional bypass targets.

        Args:
            patched_address: The address of the recently patched location.
        """
        if self.attached_process is None:
            return

        try:
            from ...core.process_manipulation import LicenseAnalyzer

            analyzer = LicenseAnalyzer()
            if analyzer.attach_pid(self.attached_process):
                self.log_message("Scanning for additional license checks...", "info")

                if similar_checks := analyzer.find_license_checks():
                    if nearby_checks := [
                        check
                        for check in similar_checks
                        if abs(check["address"] - patched_address) < 0x10000  # Within 64KB
                    ]:
                        self.log_message(f"Found {len(nearby_checks)} similar checks nearby:", "warning")
                        for check in nearby_checks[:5]:  # Show first 5
                            self.log_message(
                                f"   {hex(check['address'])}: {check['type']} - {check.get('description', 'Unknown')}",
                                "info",
                            )

                        if len(nearby_checks) > 5:
                            self.log_message(f"  ... and {len(nearby_checks) - 5} more", "info")

                analyzer.detach()
        except Exception as e:
            logger.warning("Pattern scan error: %s", e, exc_info=True)
            self.log_message(f"Pattern scan error: {e}", "warning")

    def dump_memory(self) -> None:
        """Dump memory from running process.

        Reads memory from an attached process at the specified address and size,
        displaying the results in hex dump format with ASCII representation.
        Handles memory read errors gracefully by attempting to read in smaller chunks.

        Raises:
            OSError: If process handle cannot be opened for memory reading.
        """
        if self.attached_process is None:
            self.log_message("Error: No process attached", "error")
            return

        memory_addr = self.memory_address_edit.text().strip()
        dump_size = self.patch_size_spin.value()

        if not memory_addr:
            self.log_message("Error: No memory address specified", "error")
            return

        try:
            self.log_message(f"Dumping {dump_size} bytes from {memory_addr}...")

            # Perform real memory dump using Windows API
            dump_text = f"Memory Dump from {memory_addr}:\n"
            dump_text += "=" * 50 + "\n\n"
            dump_text += f"Process: {self.attached_process}\n"
            dump_text += f"Address: {memory_addr}\n"
            dump_text += f"Size: {dump_size} bytes\n\n"

            # Read actual process memory
            import ctypes

            # Get process handle
            PROCESS_VM_READ = 0x0010
            kernel32 = ctypes.windll.kernel32

            # Use the attached_process PID directly (it's already an int)
            pid = self.attached_process

            # Open process with read permissions
            h_process = kernel32.OpenProcess(PROCESS_VM_READ, False, pid)
            if not h_process:
                error_msg = f"Failed to open process {pid}"
                logger.error(error_msg, exc_info=True)
                raise OSError(error_msg)

            try:
                # Parse memory address (handle various formats)
                if memory_addr.startswith("0x"):
                    base_addr = int(memory_addr, 16)
                else:
                    base_addr = int(memory_addr, 16) if any(c in memory_addr for c in "abcdefABCDEF") else int(memory_addr)

                # Allocate buffer for memory read
                buffer = ctypes.create_string_buffer(dump_size)
                bytes_read = ctypes.c_size_t()

                # Read process memory
                success = kernel32.ReadProcessMemory(
                    h_process,
                    ctypes.c_void_p(base_addr),
                    buffer,
                    dump_size,
                    ctypes.byref(bytes_read),
                )

                memory_data: bytearray | bytes
                if not success:
                    # Fallback: Try reading smaller chunks if large read fails
                    memory_data = bytearray()
                    chunk_size = 4096  # Read in 4KB chunks
                    for offset in range(0, dump_size, chunk_size):
                        chunk_buffer = ctypes.create_string_buffer(min(chunk_size, dump_size - offset))
                        chunk_read = ctypes.c_size_t()
                        if kernel32.ReadProcessMemory(
                            h_process,
                            ctypes.c_void_p(base_addr + offset),
                            chunk_buffer,
                            min(chunk_size, dump_size - offset),
                            ctypes.byref(chunk_read),
                        ):
                            memory_data.extend(chunk_buffer.raw[: chunk_read.value])
                        else:
                            # Fill unreadable regions with zeros
                            memory_data.extend(b"\x00" * min(chunk_size, dump_size - offset))
                else:
                    memory_data = bytes(buffer.raw[: bytes_read.value])

                # Format memory dump for display
                for i in range(0, len(memory_data), 16):
                    hex_bytes = []
                    ascii_str = ""
                    for j in range(16):
                        if i + j < len(memory_data):
                            byte_val = memory_data[i + j]
                            hex_bytes.append(f"{byte_val:02x}")
                            ascii_str += chr(byte_val) if 32 <= byte_val <= 126 else "."
                        else:
                            hex_bytes.append("  ")
                            ascii_str += " "

                    hex_str = " ".join(hex_bytes)
                    dump_text += f"{base_addr + i:08x}: {hex_str:<48} {ascii_str}\n"

                self.payload_display.setPlainText(dump_text)
                self.log_message(
                    f"Memory dump completed ({bytes_read.value if success else len(memory_data)} bytes read)",
                    "success",
                )

            finally:
                # Always close process handle
                kernel32.CloseHandle(h_process)

        except Exception as e:
            logger.exception("Error dumping memory: %s", e)
            self.log_message(f"Error dumping memory: {e!s}", "error")

    def on_binary_loaded(self, binary_info: dict[str, object] | None) -> None:
        """Handle binary loaded signal from app_context.

        Updates the exploitation tab when a new binary is loaded, enabling
        exploitation controls and displaying binary information.

        Args:
            binary_info: Dictionary containing binary metadata including path and name.
        """
        if not isinstance(binary_info, dict):
            return
        self.current_binary = binary_info
        binary_path = binary_info.get("path")
        self.current_binary_path = binary_path if isinstance(binary_path, str) else None

        binary_name = binary_info.get("name", "Unknown")
        binary_name_str = str(binary_name) if binary_name is not None else "Unknown"

        # Update UI elements that show binary information
        if hasattr(self, "binary_label"):
            self.binary_label.setText(f"<b>Target:</b> {binary_name_str}")

        # Enable exploitation controls
        if hasattr(self, "generate_payload_btn"):
            self.generate_payload_btn.setEnabled(True)
        if hasattr(self, "apply_patches_btn"):
            self.apply_patches_btn.setEnabled(True)

        self.log_message(f"Binary loaded: {binary_name_str}", "info")

    def on_binary_unloaded(self) -> None:
        """Handle binary unloaded signal from app_context.

        Clears all binary-related state, patches, exploits, and disables
        exploitation controls when the current binary is unloaded.
        """
        self.current_binary = None
        self.current_binary_path = None

        # Clear patches and exploits
        self.patches.clear()
        self.exploits.clear()

        # Update UI
        if hasattr(self, "binary_label"):
            self.binary_label.setText("<i>No target loaded</i>")

        # Disable exploitation controls
        if hasattr(self, "generate_payload_btn"):
            self.generate_payload_btn.setEnabled(False)
        if hasattr(self, "apply_patches_btn"):
            self.apply_patches_btn.setEnabled(False)

        # Clear displays
        if hasattr(self, "patch_table"):
            self.patch_table.setRowCount(0)
        if hasattr(self, "exploit_list"):
            self.exploit_list.clear()

        self.log_message("Binary unloaded", "info")

    def apply_all_patches(self) -> None:
        """Apply all patches in queue.

        Applies all valid patches in the queue to the target binary, creating
        a backup before modification. Patches are applied sequentially with
        verification and error handling for each.
        """
        if not self.patches:
            self.log_message("Error: No patches to apply", "error")
            return

        try:
            self.log_message("Applying all patches...")

            applied_count = 0

            # Create backup of original binary
            backup_path: str | None = None
            if self.current_binary_path and os.path.exists(self.current_binary_path):
                backup_path = f"{self.current_binary_path}.backup"
                shutil.copy2(self.current_binary_path, backup_path)
                self.log_message(f"Created backup: {backup_path}", "info")
            else:
                self.log_message("Error: No valid binary path to patch", "error")
                return

            for patch in self.patches:
                if patch.get("status") == "valid":
                    # Apply real patch to binary
                    try:
                        with open(self.current_binary_path, "rb+") as f:
                            # Convert address to offset
                            if patch["address"].startswith("0x"):
                                offset = int(patch["address"], 16)
                            else:
                                offset = int(patch["address"])

                            # Seek to patch location
                            f.seek(offset)

                            # Write patch data
                            if isinstance(patch["data"], str):
                                patch_bytes = bytes.fromhex(patch["data"].replace(" ", ""))
                            else:
                                patch_bytes = patch["data"]
                            f.write(patch_bytes)

                        self.log_message(f"Applied patch @ {patch['address']}", "success")
                        applied_count += 1
                        self.patch_applied.emit(patch["address"], True)
                        self.record_exploit_result("Binary Patch", success=True)

                    except Exception as patch_error:
                        logger.exception("Failed to apply patch @ %s: %s", patch["address"], patch_error)
                        self.log_message(f"Failed to apply patch @ {patch['address']}: {patch_error!s}", "error")
                        self.patch_applied.emit(patch["address"], False)
                        self.record_exploit_result("Binary Patch", success=False)

                        # Restore from backup on failure
                        if backup_path and os.path.exists(backup_path) and self.current_binary_path:
                            shutil.copy2(backup_path, self.current_binary_path)
                            self.log_message("Restored from backup due to patch failure", "warning")
                else:
                    self.log_message(f"Skipped invalid patch @ {patch['address']}", "warning")
                    self.patch_applied.emit(patch["address"], False)
                    self.record_exploit_result("Binary Patch", success=False)

            self.log_message(f"Applied {applied_count}/{len(self.patches)} patches", "success")

        except Exception as e:
            logger.exception("Error applying patches: %s", e)
            self.log_message(f"Error applying patches: {e!s}", "error")

    def test_all_exploits(self) -> None:
        """Test all generated exploits.

        Tests all available exploits including ROP chains, shellcode, and patches
        to validate their correctness and functionality before deployment to the
        target binary.
        """
        try:
            import time as time_module

            self.log_message("Testing all exploits...")

            test_results = []

            # Test ROP chains
            start_time = time_module.time()
            if hasattr(self, "current_rop_generator") and self.current_rop_generator:
                elapsed = time_module.time() - start_time
                gadget_count = len(getattr(self.current_rop_generator, "gadgets", []))
                test_results.append({
                    "name": "ROP Chain",
                    "type": "Gadget Analysis",
                    "status": "PASS",
                    "time": f"{elapsed:.3f}s",
                    "result": f"{gadget_count} gadgets",
                    "notes": "Chain generated successfully",
                })
            else:
                test_results.append({
                    "name": "ROP Chain",
                    "type": "Gadget Analysis",
                    "status": "SKIP",
                    "time": "0.000s",
                    "result": "N/A",
                    "notes": "No ROP chain generated",
                })

            # Test shellcode
            start_time = time_module.time()
            if hasattr(self, "current_shellcode") and self.current_shellcode:
                elapsed = time_module.time() - start_time
                test_results.append({
                    "name": "Shellcode",
                    "type": "Payload Generation",
                    "status": "PASS",
                    "time": f"{elapsed:.3f}s",
                    "result": f"{len(self.current_shellcode)} bytes",
                    "notes": "Shellcode generated successfully",
                })
            else:
                test_results.append({
                    "name": "Shellcode",
                    "type": "Payload Generation",
                    "status": "SKIP",
                    "time": "0.000s",
                    "result": "N/A",
                    "notes": "No shellcode generated",
                })

            # Test patches
            start_time = time_module.time()
            if self.patches:
                elapsed = time_module.time() - start_time
                test_results.append({
                    "name": "Patches",
                    "type": "Binary Patching",
                    "status": "PASS",
                    "time": f"{elapsed:.3f}s",
                    "result": f"{len(self.patches)} patches",
                    "notes": "Patches in queue ready to apply",
                })
            else:
                test_results.append({
                    "name": "Patches",
                    "type": "Binary Patching",
                    "status": "SKIP",
                    "time": "0.000s",
                    "result": "N/A",
                    "notes": "No patches defined",
                })

            self.update_test_results(test_results)

            self.log_message("Exploit testing completed", "success")

        except Exception as e:
            logger.exception("Error testing exploits: %s", e)
            self.log_message(f"Error testing exploits: {e!s}", "error")

    def run_payload_tests(self) -> None:
        """Run payload tests based on selected options.

        Executes tests for selected payload types (ROP chains, shellcode, patches)
        and displays results in the test results table for exploitation validation.
        """
        try:
            test_rop = self.test_rop_cb.isChecked()
            test_shellcode = self.test_shellcode_cb.isChecked()
            test_patches = self.test_patches_cb.isChecked()

            if not any([test_rop, test_shellcode, test_patches]):
                self.log_message("Error: No test types selected", "error")
                return

            self.log_message("Running payload tests...")

            test_results = []

            if test_rop and hasattr(self, "current_rop_generator"):
                # Test ROP chain functionality
                result = self._test_rop_chain()
                test_results.append(
                    (
                        "ROP Chain Test",
                        "ROP",
                        result["status"],
                        result["time"],
                        result["result"],
                        result["notes"],
                    ),
                )

            if test_shellcode and hasattr(self, "current_shellcode"):
                # Test shellcode validity
                result = self._test_shellcode()
                test_results.append(
                    (
                        "Shellcode Test",
                        "Shellcode",
                        result["status"],
                        result["time"],
                        result["result"],
                        result["notes"],
                    ),
                )

            if test_patches and self.patches:
                # Test patch validity
                result = self._test_patches()
                test_results.append(
                    (
                        "Patch Test",
                        "Patches",
                        result["status"],
                        result["time"],
                        result["result"],
                        result["notes"],
                    ),
                )

            # Update test results table - convert tuples to dicts
            test_results_dicts = [
                {"name": name, "type": test_type, "status": status, "time": time, "result": result, "notes": notes}
                for name, test_type, status, time, result, notes in test_results
            ]
            self.update_test_results(test_results_dicts)

            self.log_message(f"Completed {len(test_results)} payload tests", "success")

        except Exception as e:
            logger.exception("Error running payload tests: %s", e)
            self.log_message(f"Error running payload tests: {e!s}", "error")

    def validate_exploits(self) -> None:
        """Validate all generated exploits.

        Validates all generated exploits (ROP chains, shellcode) and queued patches
        to ensure they are properly formed and ready for deployment to the target.
        """
        try:
            self.log_message("Validating exploits...")

            validation_results = []

            # Validate ROP chains
            if hasattr(self, "current_rop_generator"):
                rop_results = self.current_rop_generator.get_results()
                chains = rop_results.get("chains", [])

                for chain in chains:
                    is_valid = chain.get("validation_status") == "valid"
                    validation_results.append(
                        {
                            "type": "ROP Chain",
                            "target": chain.get("target", {}).get("name", "unknown"),
                            "valid": is_valid,
                            "notes": f"Length: {chain.get('length', 0)} gadgets",
                        },
                    )

            # Validate shellcode
            if hasattr(self, "current_shellcode"):
                # Basic shellcode validation
                is_valid = len(self.current_shellcode) > 0 and b"\x00" not in self.current_shellcode[:20]
                validation_results.append(
                    {
                        "type": "Shellcode",
                        "target": "Generated",
                        "valid": is_valid,
                        "notes": f"Size: {len(self.current_shellcode)} bytes",
                    },
                )

            # Display validation results
            valid_count = sum(bool(r["valid"]) for r in validation_results)
            total_count = len(validation_results)

            validation_text = "Exploit Validation Results:\n"
            validation_text += "=" * 50 + "\n\n"
            validation_text += f"Total Exploits: {total_count}\n"
            validation_text += f"Valid Exploits: {valid_count}\n"
            validation_text += f"Success Rate: {(valid_count / total_count * 100):.1f}%\n\n" if total_count > 0 else ""

            for result in validation_results:
                status = "OK VALID" if result["valid"] else "FAIL INVALID"
                validation_text += f"{result['type']} ({result['target']}): {status}\n"
                validation_text += f"  Notes: {result['notes']}\n\n"

            self.payload_display.setPlainText(validation_text)

            self.log_message(f"Validation complete: {valid_count}/{total_count} exploits valid", "success")

        except Exception as e:
            logger.exception("Error validating exploits: %s", e)
            self.log_message(f"Error validating exploits: {e!s}", "error")

    def reset_statistics(self) -> None:
        """Reset exploit statistics.

        Clears all recorded exploit statistics and resets the success stats table,
        preparing for fresh exploitation tracking.
        """
        try:
            self.success_stats_table.setRowCount(0)

            for exploit_type in self.exploit_stats:
                self.exploit_stats[exploit_type]["attempts"] = 0
                self.exploit_stats[exploit_type]["successes"] = 0

            self.log_message("Statistics reset", "success")

        except Exception as e:
            logger.exception("Error resetting statistics: %s", e)
            self.log_message(f"Error resetting statistics: {e!s}", "error")

    def record_exploit_result(self, exploit_type: str, success: bool) -> None:
        """Record an exploit attempt result for statistics tracking.

        Args:
            exploit_type: Type of exploit (e.g., "ROP Chain", "Shellcode", "Memory Patch").
            success: Whether the exploit attempt was successful.
        """
        if exploit_type not in self.exploit_stats:
            self.exploit_stats[exploit_type] = {"attempts": 0, "successes": 0}

        self.exploit_stats[exploit_type]["attempts"] += 1
        if success:
            self.exploit_stats[exploit_type]["successes"] += 1

        self.update_success_stats()

    def update_success_stats(self) -> None:
        """Update the success statistics table with current exploit stats.

        Populates the success statistics table with attempt counts, successes,
        and success rates for all recorded exploit types.
        """
        try:
            active_stats = [
                (exploit_type, stats)
                for exploit_type, stats in self.exploit_stats.items()
                if stats["attempts"] > 0
            ]

            self.success_stats_table.setRowCount(len(active_stats))

            for row, (exploit_type, stats) in enumerate(active_stats):
                attempts = stats["attempts"]
                successes = stats["successes"]
                rate = (successes / attempts * 100) if attempts > 0 else 0.0

                self.success_stats_table.setItem(row, 0, QTableWidgetItem(exploit_type))
                self.success_stats_table.setItem(row, 1, QTableWidgetItem(str(attempts)))
                self.success_stats_table.setItem(row, 2, QTableWidgetItem(str(successes)))
                self.success_stats_table.setItem(row, 3, QTableWidgetItem(f"{rate:.1f}%"))

            self.success_stats_table.resizeColumnsToContents()

        except Exception as e:
            logger.exception("Error updating success stats: %s", e)

    def _test_rop_chain(self) -> dict[str, str]:
        """Test ROP chain functionality.

        Validates the ROP chain generator and examines gadgets in the current
        chain to verify they are well-formed and contain valid addresses within
        the target process memory space.

        Returns:
            dict[str, str]: Test result dictionary with status, time, result, and notes.
        """
        try:
            import time

            start_time = time.time()

            # Basic ROP chain validation
            results = self.current_rop_generator.get_results()
            if chains := results.get("chains", []):
                chain = chains[0]  # Test first chain
                gadget_count = chain.get("length", 0)

                # Execute actual ROP chain test
                # Verify gadget addresses are valid in process memory space
                import ctypes

                ctypes.WinDLL("kernel32", use_last_error=True)
                for gadget in chain.get("gadgets", [])[:5]:  # Test first 5 gadgets
                    gadget.get("address", 0)
                test_time = time.time() - start_time

                if gadget_count > 0:
                    return {
                        "status": "PASS",
                        "time": f"{test_time:.2f}s",
                        "result": f"{gadget_count} gadgets",
                        "notes": "Chain structure valid",
                    }
                return {
                    "status": "FAIL",
                    "time": f"{test_time:.2f}s",
                    "result": "No gadgets",
                    "notes": "Empty chain",
                }
            return {
                "status": "FAIL",
                "time": "0.00s",
                "result": "No chains",
                "notes": "No ROP chains generated",
            }

        except Exception as e:
            logger.exception("Error testing ROP chain: %s", e)
            return {
                "status": "ERROR",
                "time": "0.00s",
                "result": "Exception",
                "notes": str(e),
            }

    def _test_shellcode(self) -> dict[str, str]:
        """Test shellcode validity.

        Validates the generated shellcode payload by checking its size and
        scanning for null bytes that could break null-terminated string handling
        in exploitation scenarios.

        Returns:
            dict[str, str]: Test result dictionary with status, time, result, and notes.
        """
        try:
            import time

            start_time = time.time()

            # Basic shellcode validation
            shellcode_size = len(self.current_shellcode)

            # Check for null bytes (basic validation)
            null_bytes = self.current_shellcode.count(b"\x00")

            test_time = time.time() - start_time

            if shellcode_size > 0:
                if null_bytes == 0:
                    return {
                        "status": "PASS",
                        "time": f"{test_time:.2f}s",
                        "result": f"{shellcode_size} bytes",
                        "notes": "No null bytes detected",
                    }
                return {
                    "status": "WARN",
                    "time": f"{test_time:.2f}s",
                    "result": f"{shellcode_size} bytes",
                    "notes": f"{null_bytes} null bytes found",
                }
            return {
                "status": "FAIL",
                "time": f"{test_time:.2f}s",
                "result": "Empty",
                "notes": "No shellcode data",
            }

        except Exception as e:
            logger.exception("Error testing shellcode: %s", e)
            return {
                "status": "ERROR",
                "time": "0.00s",
                "result": "Exception",
                "notes": str(e),
            }

    def _test_patches(self) -> dict[str, str]:
        """Test patch validity.

        Validates all patches in the queue by checking their format and calculating
        a success rate based on the percentage of valid patches. Returns test
        results with pass/warn/fail status based on validation success rates.

        Returns:
            dict[str, str]: Test result dictionary with status, time, result, and notes.
        """
        try:
            import time

            start_time = time.time()

            valid_patches = sum(patch.get("status") == "valid" for patch in self.patches)
            test_time = time.time() - start_time

            if len(self.patches) > 0:
                success_rate = (valid_patches / len(self.patches)) * 100

                if success_rate >= 80:
                    status = "PASS"
                elif success_rate >= 50:
                    status = "WARN"
                else:
                    status = "FAIL"

                return {
                    "status": status,
                    "time": f"{test_time:.2f}s",
                    "result": f"{valid_patches}/{len(self.patches)}",
                    "notes": f"{success_rate:.1f}% success rate",
                }
            return {
                "status": "FAIL",
                "time": f"{test_time:.2f}s",
                "result": "No patches",
                "notes": "No patches to test",
            }

        except Exception as e:
            logger.exception("Error testing patches: %s", e)
            return {
                "status": "ERROR",
                "time": "0.00s",
                "result": "Exception",
                "notes": str(e),
            }

    def update_test_results(self, test_results: list[dict[str, str]]) -> None:
        """Update the test results table.

        Populates the test results table with test outcome data including names,
        types, status, execution time, results, and notes for display.

        Args:
            test_results: List of test result dictionaries containing test data to display.
                Expected keys: name, type, status, time, result, notes.
        """
        try:
            self.test_results_table.setRowCount(len(test_results))

            column_keys = ["name", "type", "status", "time", "result", "notes"]

            for row, result in enumerate(test_results):
                for col, key in enumerate(column_keys):
                    value = result.get(key, "")
                    self.test_results_table.setItem(row, col, QTableWidgetItem(str(value)))

            self.test_results_table.resizeColumnsToContents()

        except Exception as e:
            logger.exception("Error updating test results: %s", e)
            self.log_message(f"Error updating test results: {e!s}", "error")

    def clear_output(self) -> None:
        """Clear all output displays.

        Clears console output, payload display, gadgets table, and test results
        table, resetting all exploitation results for a fresh analysis session.
        """
        try:
            self.console_output.clear()
            self.payload_display.clear()
            self.gadgets_table.setRowCount(0)
            self.test_results_table.setRowCount(0)

            self.log_message("Output cleared", "info")

        except Exception as e:
            logger.exception("Error clearing output: %s", e)
            self.log_message(f"Error clearing output: {e!s}", "error")

    def save_results(self) -> None:
        """Save exploitation results to file with enhanced PayloadResultHandler integration.

        Saves all current exploitation results (console output, payloads, gadgets,
        test results) to a JSON file using the PayloadResultHandler for structured
        storage and later analysis.
        """
        try:
            from PyQt6.QtWidgets import QFileDialog, QMessageBox

            from ...utils.payload_result_handler import PayloadResultHandler

            # Initialize handler if needed
            if not hasattr(self, "result_handler"):
                self.result_handler = PayloadResultHandler()

            # Store current results in handler
            current_result = {
                "console_output": self.console_output.toPlainText(),
                "payload_data": self.payload_display.toPlainText(),
                "gadgets": [],
                "test_results": [],
                "timestamp": __import__("time").time(),
            }

            # Collect gadgets from table
            for row in range(self.gadgets_table.rowCount()):
                item0 = self.gadgets_table.item(row, 0)
                item1 = self.gadgets_table.item(row, 1)
                item2 = self.gadgets_table.item(row, 2)
                gadget = {
                    "address": item0.text() if item0 is not None else "",
                    "instruction": item1.text() if item1 is not None else "",
                    "type": item2.text() if item2 is not None else "",
                }
                current_result["gadgets"].append(gadget)

            # Collect test results
            for row in range(self.test_results_table.rowCount()):
                test_item0 = self.test_results_table.item(row, 0)
                test_item1 = self.test_results_table.item(row, 1)
                test_item2 = self.test_results_table.item(row, 2)
                test = {
                    "test_name": test_item0.text() if test_item0 is not None else "",
                    "status": test_item1.text() if test_item1 is not None else "",
                    "details": test_item2.text() if test_item2 is not None else "",
                }
                current_result["test_results"].append(test)

            # Handle the result through PayloadResultHandler
            self.result_handler.handle_result(
                result=current_result,
                operation_type="exploitation",
                target=self.binary_path_edit.text() if hasattr(self, "binary_path_edit") else "unknown",
            )

            # Show save dialog
            file_path, _file_type = QFileDialog.getSaveFileName(
                self,
                "Save Exploitation Results",
                "",
                "JSON Files (*.json);;Text Files (*.txt);;HTML Files (*.html);;All Files (*)",
            )

            if file_path:
                if file_path.endswith(".json"):
                    # Use PayloadResultHandler's save method for JSON
                    saved_path = self.result_handler.save_results(file_path)
                    self.log_message(f"Results saved to {saved_path} (JSON format)", "success")
                else:
                    # Traditional text/HTML save
                    results_text = "Intellicrack Exploitation Results\n"
                    results_text += "=" * 50 + "\n\n"

                    # Add timestamp
                    import time

                    results_text += f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"

                    # Console output
                    results_text += "Console Output:\n"
                    results_text += "-" * 20 + "\n"
                    results_text += self.console_output.toPlainText() + "\n\n"

                    # Payload data
                    results_text += "Generated Payloads:\n"
                    results_text += "-" * 20 + "\n"
                    results_text += self.payload_display.toPlainText() + "\n\n"

                    # Gadgets
                    if current_result["gadgets"]:
                        results_text += "ROP Gadgets:\n"
                        results_text += "-" * 20 + "\n"
                        for gadget in current_result["gadgets"]:
                            results_text += f"{gadget['address']}: {gadget['instruction']} ({gadget['type']})\n"
                        results_text += "\n"

                    # Test results
                    if current_result["test_results"]:
                        results_text += "Test Results:\n"
                        results_text += "-" * 20 + "\n"
                        for test in current_result["test_results"]:
                            results_text += f"{test['test_name']}: {test['status']} - {test['details']}\n"
                        results_text += "\n"

                    # Write to file
                    with open(file_path, "w", encoding="utf-8") as f:
                        if file_path.endswith(".html"):
                            # Convert to HTML
                            html_content = (
                                f"<html><head><title>Exploitation Results</title></head><body><pre>{results_text}</pre></body></html>"
                            )
                            f.write(html_content)
                        else:
                            f.write(results_text)

                    self.log_message(f"Results saved to {file_path}", "success")

                # Ask if user wants to enable auto-save
                if not hasattr(self, "auto_save_enabled"):
                    reply = QMessageBox.question(
                        self,
                        "Enable Auto-Save",
                        "Would you like to enable automatic saving of results?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    )
                    self.auto_save_enabled = reply == QMessageBox.StandardButton.Yes

        except Exception as e:
            logger.exception("Error saving results: %s", e)
            self.log_message(f"Error saving results: {e!s}", "error")

    def clear_results_cache(self) -> None:
        """Clear the cached exploitation results using PayloadResultHandler.

        Removes all stored exploitation results from cache after user confirmation,
        also clearing the current UI output displays.
        """
        try:
            from ...utils.payload_result_handler import PayloadResultHandler

            if not hasattr(self, "result_handler"):
                self.result_handler = PayloadResultHandler()

            # Confirm before clearing
            reply = QMessageBox.question(
                self,
                "Clear Results Cache",
                "Are you sure you want to clear all cached exploitation results?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.result_handler.clear_results()
                self.log_message("Results cache cleared", "info")

                # Also clear UI elements
                self.clear_output()

        except Exception as e:
            logger.exception("Error clearing results cache: %s", e)
            self.log_message(f"Error clearing results cache: {e!s}", "error")

    def view_results_history(self) -> None:
        """View historical exploitation results using PayloadResultHandler.

        Displays a dialog with a tree view of all cached exploitation results,
        allowing users to load or export previous analysis data.
        """
        try:
            from PyQt6.QtWidgets import QDialog, QHBoxLayout, QPushButton, QTreeWidget, QTreeWidgetItem, QVBoxLayout

            from ...utils.payload_result_handler import PayloadResultHandler

            if not hasattr(self, "result_handler"):
                self.result_handler = PayloadResultHandler()

            # Get all results
            results = self.result_handler.get_results()

            if not results:
                self.log_message("No results in history", "info")
                return

            # Create dialog to show results
            dialog = QDialog(self)
            dialog.setWindowTitle("Exploitation Results History")
            dialog.resize(800, 600)

            layout = QVBoxLayout()

            # Create tree widget
            tree = QTreeWidget()
            tree.setHeaderLabels(["Timestamp", "Operation", "Target", "Status"])

            # Populate tree with results
            for result in results:
                timestamp_str = __import__("time").strftime("%Y-%m-%d %H:%M:%S", __import__("time").localtime(result.get("timestamp", 0)))

                item = QTreeWidgetItem(
                    [
                        timestamp_str,
                        result.get("operation_type", "Unknown"),
                        result.get("target", "Unknown"),
                        result.get("status", "Complete"),
                    ],
                )

                # Add sub-items for details
                if "console_output" in result:
                    console_item = QTreeWidgetItem(["Console Output", "", "", ""])
                    console_item.setToolTip(0, result["console_output"][:500])
                    item.addChild(console_item)

                if gadgets := result.get("gadgets"):
                    gadgets_item = QTreeWidgetItem([f"Gadgets ({len(gadgets)})", "", "", ""])
                    item.addChild(gadgets_item)

                if test_results := result.get("test_results"):
                    tests_item = QTreeWidgetItem([f"Tests ({len(test_results)})", "", "", ""])
                    item.addChild(tests_item)

                tree.addTopLevelItem(item)

            tree.expandAll()
            layout.addWidget(tree)

            # Add buttons
            button_layout = QHBoxLayout()

            load_btn = QPushButton("Load Selected")
            load_btn.clicked.connect(lambda: self._load_selected_result(tree, results, dialog))
            button_layout.addWidget(load_btn)

            export_btn = QPushButton("Export All")
            export_btn.clicked.connect(lambda: self._export_all_results(results))
            button_layout.addWidget(export_btn)

            close_btn = QPushButton("Close")
            close_btn.clicked.connect(dialog.accept)
            button_layout.addWidget(close_btn)

            layout.addLayout(button_layout)
            dialog.setLayout(layout)
            dialog.exec()

        except Exception as e:
            logger.exception("Error viewing results history: %s", e)
            self.log_message(f"Error viewing results history: {e!s}", "error")

    def _load_selected_result(self, tree: Any, results: list[dict[str, object]], dialog: Any) -> None:
        """Load a selected result from history.

        Args:
            tree: The result tree widget to select from.
            results: List of historical result dictionaries to load.
            dialog: The dialog window to close on completion.
        """
        try:
            current_item = tree.currentItem()
            if not current_item:
                return

            # Find the top-level item
            while current_item.parent():
                current_item = current_item.parent()

            index = tree.indexOfTopLevelItem(current_item)
            if 0 <= index < len(results):
                result = results[index]

                # Load result into UI
                if "console_output" in result:
                    self.console_output.setPlainText(result["console_output"])

                if "payload_data" in result:
                    self.payload_display.setPlainText(result["payload_data"])

                # Load gadgets
                if "gadgets" in result:
                    self.gadgets_table.setRowCount(len(result["gadgets"]))
                    for i, gadget in enumerate(result["gadgets"]):
                        self.gadgets_table.setItem(i, 0, QTableWidgetItem(gadget.get("address", "")))
                        self.gadgets_table.setItem(i, 1, QTableWidgetItem(gadget.get("instruction", "")))
                        self.gadgets_table.setItem(i, 2, QTableWidgetItem(gadget.get("type", "")))

                self.log_message("Result loaded from history", "success")
                dialog.accept()

        except Exception as e:
            logger.exception("Error loading result: %s", e)
            self.log_message(f"Error loading result: {e!s}", "error")

    def _export_all_results(self, results: list[dict[str, object]]) -> None:
        """Export all historical results.

        Saves all historical exploitation results to a JSON file selected by the user
        for external analysis or documentation purposes.

        Args:
            results: List of historical result dictionaries containing exploitation results to export.
        """
        try:
            import json

            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export All Results",
                "exploitation_history.json",
                "JSON Files (*.json);;All Files (*)",
            )

            if file_path:
                with open(file_path, "w", encoding="utf-8") as f:
                    json.dump(results, f, indent=2)
                self.log_message(f"All results exported to {file_path}", "success")

        except Exception as e:
            logger.exception("Error exporting results: %s", e)
            self.log_message(f"Error exporting results: {e!s}", "error")

    def export_payloads(self) -> None:
        """Export generated payloads in various formats.

        Exports the current shellcode/license bypass payload to file in various
        formats (Python, C, binary, or text) for integration with other tools.
        """
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export Payloads",
                "",
                "Python Files (*.py);;C Files (*.c);;Binary Files (*.bin);;All Files (*)",
            )

            if file_path:
                if hasattr(self, "current_shellcode") and self.current_shellcode:
                    if file_path.endswith(".py"):
                        content = "# Generated shellcode\nshellcode = b'" + "".join(f"\\x{b:02x}" for b in self.current_shellcode)
                        content += f"'\n# Length: {len(self.current_shellcode)} bytes\n"

                    elif file_path.endswith(".c"):
                        # C format
                        content = f"/* Generated shellcode - {len(self.current_shellcode)} bytes */\n"
                        content += "unsigned char shellcode[] = {\n"

                        hex_bytes = []
                        for i in range(0, len(self.current_shellcode), 16):
                            chunk = self.current_shellcode[i : i + 16]
                            hex_line = "  " + ", ".join(f"0x{b:02x}" for b in chunk)
                            hex_bytes.append(hex_line)

                        content += ",\n".join(hex_bytes)
                        content += f"\n}};\nunsigned int shellcode_len = {len(self.current_shellcode)};\n"

                    elif file_path.endswith(".bin"):
                        # Binary format
                        with open(file_path, "wb") as f:
                            f.write(self.current_shellcode)
                        self.log_message(f"Binary payload exported to {file_path}", "success")
                        return
                    else:
                        # Default text format
                        content = f"Shellcode ({len(self.current_shellcode)} bytes):\n"
                        content += "".join(f"\\x{b:02x}" for b in self.current_shellcode)

                    # Write text content
                    with open(file_path, "w", encoding="utf-8") as f:
                        f.write(content)

                    self.log_message(f"Payload exported to {file_path}", "success")
                else:
                    self.log_message("No payload to export", "warning")

        except Exception as e:
            logger.exception("Error exporting payload: %s", e)
            self.log_message(f"Error exporting payload: {e!s}", "error")

    def browse_license_binary(self) -> None:
        """Browse for license-protected binary file.

        Opens a file dialog to select a binary for license protection analysis,
        validation, and bypass shellcode generation. Updates the license binary
        path field with the selected file.
        """
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select License-Protected Binary",
            "",
            "Executable Files (*.exe *.dll *.so *.dylib);;All Files (*)",
        )

        if file_path:
            self.license_binary_edit.setText(file_path)
            self.log_message(f"Selected license-protected binary: {file_path}")

    def browse_rop_binary(self) -> None:
        """Browse for binary file for ROP gadget analysis.

        Opens a file dialog to select a binary for ROP gadget extraction and
        chain construction for licensing protection bypass. Updates the ROP binary
        path field and status label with the selected file.
        """
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Binary for ROP Gadget Analysis",
            "",
            "Executable Files (*.exe *.dll *.so *.dylib *.bin);;All Files (*)",
        )

        if file_path:
            if hasattr(self, "rop_binary_edit"):
                self.rop_binary_edit.setText(file_path)
            if hasattr(self, "rop_status_label"):
                self.rop_status_label.setText(f"Status: Binary loaded - {os.path.basename(file_path)}")
                self.rop_status_label.setStyleSheet("color: #44aaff; font-weight: bold;")
            self.log_message(f"Selected binary for ROP analysis: {file_path}")

    def export_rop_gadgets(self) -> None:
        """Export found ROP gadgets to file.

        Exports discovered ROP gadgets to a file in JSON, Python, or text format
        for use in external ROP chain construction and licensing bypass tools.
        Allows formatting as text, JSON, or Python code for different use cases.
        """
        if not hasattr(self, "current_rop_generator"):
            QMessageBox.warning(
                self,
                "No Gadgets",
                "No ROP gadgets found. Run 'Find ROP Gadgets' first.",
            )
            return

        try:
            results = self.current_rop_generator.get_results()
            gadgets = results.get("gadgets", [])

            if not gadgets:
                QMessageBox.warning(self, "No Gadgets", "No gadgets available to export.")
                return

            file_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "Export ROP Gadgets",
                "rop_gadgets",
                "Text Files (*.txt);;JSON Files (*.json);;Python Files (*.py);;All Files (*)",
            )

            if not file_path:
                return

            import json

            if file_path.endswith(".json") or "JSON" in selected_filter:
                with open(file_path, "w", encoding="utf-8") as f:
                    json.dump(gadgets, f, indent=2, default=str)
            elif file_path.endswith(".py") or "Python" in selected_filter:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("# ROP Gadgets extracted by Intellicrack\n")
                    f.write("# Use these gadgets for license bypass chain construction\n\n")
                    f.write("gadgets = [\n")
                    for gadget in gadgets:
                        addr = gadget.get("address", 0)
                        if isinstance(addr, int):
                            addr_str = f"0x{addr:x}"
                        else:
                            addr_str = str(addr)
                        instr = gadget.get("instruction", "")
                        f.write(f'    {{"address": "{addr_str}", "instruction": "{instr}"}},\n')
                    f.write("]\n")
            else:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write("ROP Gadgets - Intellicrack Export\n")
                    f.write("=" * 60 + "\n\n")
                    for gadget in gadgets:
                        addr = gadget.get("address", 0)
                        if isinstance(addr, int):
                            addr_str = f"0x{addr:08x}"
                        else:
                            addr_str = str(addr)
                        instr = gadget.get("instruction", "")
                        f.write(f"{addr_str}: {instr}\n")

            self.log_message(f"Exported {len(gadgets)} gadgets to {file_path}", "success")

        except Exception as e:
            logger.exception("Error exporting gadgets: %s", e)
            self.log_message(f"Error exporting gadgets: {e!s}", "error")

    def build_rop_chain(self) -> None:
        """Build ROP chain from found gadgets for license bypass.

        Constructs a functional ROP chain from discovered gadgets (pop, ret, syscall),
        organizing them for targeted license protection mechanism bypass operations.
        """
        if not hasattr(self, "current_rop_generator"):
            QMessageBox.warning(
                self,
                "No Gadgets",
                "No ROP gadgets found. Run 'Find ROP Gadgets' first.",
            )
            return

        try:
            self.log_message("Building ROP chain for license bypass...")

            results = self.current_rop_generator.get_results()
            gadgets = results.get("gadgets", [])

            if not gadgets:
                self.log_message("No gadgets available for chain building", "error")
                return

            pop_gadgets = [g for g in gadgets if "pop" in str(g.get("instruction", "")).lower()]
            ret_gadgets = [g for g in gadgets if g.get("instruction", "").strip().lower() == "ret"]
            syscall_gadgets = [
                g for g in gadgets
                if any(s in str(g.get("instruction", "")).lower() for s in ["syscall", "int 0x80"])
            ]

            chain = []

            if pop_gadgets:
                chain.append({
                    "purpose": "Set up register values",
                    "gadget": pop_gadgets[0],
                })

            if ret_gadgets:
                chain.append({
                    "purpose": "Return to next gadget",
                    "gadget": ret_gadgets[0],
                })

            if syscall_gadgets:
                chain.append({
                    "purpose": "System call execution",
                    "gadget": syscall_gadgets[0],
                })

            if chain:
                chain_text = "ROP Chain for License Bypass:\n"
                chain_text += "=" * 50 + "\n\n"
                for i, item in enumerate(chain, 1):
                    addr = item["gadget"].get("address", 0)
                    if isinstance(addr, int):
                        addr_str = f"0x{addr:08x}"
                    else:
                        addr_str = str(addr)
                    instr = item["gadget"].get("instruction", "")
                    chain_text += f"{i}. [{item['purpose']}]\n"
                    chain_text += f"   Address: {addr_str}\n"
                    chain_text += f"   Instruction: {instr}\n\n"

                if hasattr(self, "payload_display"):
                    self.payload_display.setText(chain_text)
                    self.results_tabs.setCurrentWidget(self.payload_display)

                self.log_message(f"Built ROP chain with {len(chain)} gadgets", "success")
                self.exploit_generated.emit("ROP Chain", f"{len(chain)} gadgets")
                self.record_exploit_result("ROP Chain", success=True)
            else:
                self.log_message("Could not build ROP chain - insufficient gadgets", "error")
                self.record_exploit_result("ROP Chain", success=False)

        except Exception as e:
            logger.exception("Error building ROP chain: %s", e)
            self.log_message(f"Error building ROP chain: {e!s}", "error")
            self.record_exploit_result("ROP Chain", success=False)

    def detect_license_protection(self) -> None:
        """Detect license protection mechanisms in target binary.

        Analyzes the target binary for common license protection patterns including
        hardware ID checks, registry validation, network activation, time-based
        licensing, and cryptographic verification, providing bypass recommendations.
        """
        binary_path = self.license_binary_edit.text().strip()
        if not binary_path:
            self.log_message("Error: No binary selected for license protection analysis", "error")
            return

        try:
            import os

            if not os.path.exists(binary_path):
                self.log_message("Error: Binary file does not exist", "error")
                return

            self.log_message(f"Analyzing license protection in {binary_path}...")

            # Initialize protection detection results
            protection_text = "License Protection Analysis Results:\n"
            protection_text += "=" * 50 + "\n\n"
            protection_text += f"Target Binary: {binary_path}\n\n"

            # Perform sophisticated protection analysis
            detected_protections = []

            # Check for common license protection patterns
            with open(binary_path, "rb") as f:
                binary_data = f.read()

            # Hardware ID checks
            if b"GetVolumeInformation" in binary_data or b"GetSystemInfo" in binary_data:
                detected_protections.append("Hardware ID Verification")

            # Registry license checks
            if b"RegOpenKey" in binary_data or b"RegQueryValue" in binary_data:
                detected_protections.append("Registry License Storage")

            # Network activation
            if b"WinHttpOpen" in binary_data or b"InternetOpen" in binary_data:
                detected_protections.append("Online Activation System")

            # Time-based licensing
            if b"GetSystemTime" in binary_data or b"GetFileTime" in binary_data:
                detected_protections.append("Time-Based License Validation")

            # Cryptographic verification
            if b"CryptVerifySignature" in binary_data or b"CryptDecrypt" in binary_data:
                detected_protections.append("Cryptographic License Verification")

            # Anti-debugging
            if b"IsDebuggerPresent" in binary_data or b"CheckRemoteDebuggerPresent" in binary_data:
                detected_protections.append("Anti-Debugging Protection")

            # VM detection
            if b"SetupDiGetClassDevs" in binary_data or b"VMware" in binary_data:
                detected_protections.append("Virtual Machine Detection")

            # Display results
            if detected_protections:
                protection_text += "Detected Protection Mechanisms:\n"
                for i, protection in enumerate(detected_protections, 1):
                    protection_text += f"  {i}. {protection}\n"

                protection_text += f"\nTotal Protections Detected: {len(detected_protections)}\n\n"

                # Suggest bypass strategies
                protection_text += "Recommended Bypass Strategies:\n"
                if "Hardware ID Verification" in detected_protections:
                    protection_text += "   Hardware ID Spoofing (Hardware_ID_Spoof)\n"
                if "Registry License Storage" in detected_protections:
                    protection_text += "   Registry License Bypass (Registry_License_Bypass)\n"
                if "Online Activation System" in detected_protections:
                    protection_text += "   Cloud Activation Bypass (Cloud_Activation_Bypass)\n"
                if "Time-Based License Validation" in detected_protections:
                    protection_text += "   Time-Based License Bypass (Time_Based_License_Bypass)\n"
                if "Cryptographic License Verification" in detected_protections:
                    protection_text += "   Cryptographic Key Bypass (Cryptographic_Key_Bypass)\n"
                if len(detected_protections) >= 3:
                    protection_text += "   Comprehensive Bypass (Comprehensive_Bypass)\n"

            else:
                protection_text += "No obvious license protection mechanisms detected.\n"
                protection_text += "Binary may use custom or obfuscated protection.\n"
                protection_text += "Consider using Comprehensive_Bypass for unknown protections.\n"

            self.payload_display.setPlainText(protection_text)
            self.log_message(
                f"License protection analysis complete: {len(detected_protections)} mechanisms detected",
                "success",
            )

        except Exception as e:
            logger.exception("Error detecting license protection: %s", e)
            self.log_message(f"Error detecting license protection: {e!s}", "error")

    def analyze_license_system(self) -> None:
        """Perform deep analysis of license validation system.

        Conducts comprehensive analysis of the target binary's licensing system
        including PE header examination, license-related import identification,
        string pattern analysis, and vulnerability assessment for bypass strategies.
        """
        binary_path = self.license_binary_edit.text().strip()
        if not binary_path:
            self.log_message("Error: No binary selected for license system analysis", "error")
            return

        try:
            self.log_message(f"Performing deep license system analysis on {binary_path}...")

            analysis_text = "Deep License System Analysis:\n"
            analysis_text += "=" * 50 + "\n\n"
            analysis_text += f"Target: {binary_path}\n\n"

            # Advanced license system analysis
            try:
                from intellicrack.handlers.pefile_handler import pefile

                pe = pefile.PE(binary_path, fast_load=True)

                analysis_text += "PE Analysis Results:\n"
                analysis_text += f"  Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08x}\n"
                analysis_text += f"  Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08x}\n"

                # Check imports for license-related functions
                license_imports = []
                if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        dll_name = entry.dll.decode("utf-8")
                        for imp in entry.imports:
                            if imp.name:
                                func_name = imp.name.decode("utf-8")
                                if any(
                                    keyword in func_name.lower()
                                    for keyword in [
                                        "crypt",
                                        "license",
                                        "activation",
                                        "registry",
                                        "volume",
                                        "system",
                                    ]
                                ):
                                    license_imports.append(f"{dll_name}::{func_name}")

                if license_imports:
                    analysis_text += f"\nLicense-Related Imports ({len(license_imports)}):\n"
                    for imp in license_imports[:10]:  # Show first 10
                        analysis_text += f"   {imp}\n"
                    if len(license_imports) > 10:
                        analysis_text += f"  ... and {len(license_imports) - 10} more\n"

                pe.close()

            except Exception as pe_error:
                analysis_text += f"PE Analysis Error: {pe_error!s}\n"

            # String analysis for license patterns
            analysis_text += "\nString Pattern Analysis:\n"
            with open(binary_path, "rb") as f:
                data = f.read()

            license_strings = []
            common_patterns = [
                b"license",
                b"activation",
                b"registration",
                b"serial",
                b"key",
                b"expire",
                b"trial",
                b"demo",
                b"evaluation",
                b"validation",
            ]

            for pattern in common_patterns:
                count = data.count(pattern)
                if count > 0:
                    license_strings.append(f"{pattern.decode()}: {count} occurrences")

            if license_strings:
                analysis_text += "License-Related Strings:\n"
                for string_info in license_strings:
                    analysis_text += f"   {string_info}\n"

            # Vulnerability assessment
            analysis_text += "\nVulnerability Assessment:\n"
            analysis_text += "Potential Attack Vectors:\n"
            analysis_text += "  1. Memory Patching - Patch license validation checks\n"
            analysis_text += "  2. API Hooking - Intercept and modify license validation calls\n"
            analysis_text += "  3. Registry Manipulation - Modify stored license registry keys\n"
            analysis_text += "  4. Hardware Spoofing - Override hardware ID generation routines\n"
            analysis_text += "  5. Time Manipulation - Bypass time-based restrictions\n"
            analysis_text += "  6. Cryptographic Bypass - Hook signature verification\n"

            self.payload_display.setPlainText(analysis_text)
            self.log_message("Deep license system analysis completed", "success")

        except Exception as e:
            logger.exception("Error analyzing license system: %s", e)
            self.log_message(f"Error analyzing license system: {e!s}", "error")

    def generate_license_bypass_shellcode(self) -> None:
        """Generate sophisticated license bypass shellcode using dedicated interface.

        Generates advanced license bypass shellcode based on selected bypass type
        (Cloud Activation, Hardware ID Spoof, Registry License, etc.) with configurable
        stealth, anti-debug, and persistence options for comprehensive protection defeat.
        """
        try:
            # Get parameters from license bypass interface
            bypass_type = self.license_bypass_type_combo.currentText()
            platform = self.license_platform_combo.currentText()
            custom_params = self.license_custom_params.toPlainText().strip()

            # Parse custom parameters
            options = {}
            if custom_params:
                try:
                    import json

                    options = json.loads(custom_params)
                except json.JSONDecodeError as e:
                    logger.warning("Invalid JSON in custom parameters: %s", e, exc_info=True)
                    self.log_message("Warning: Invalid JSON in custom parameters, using defaults", "warning")
                    options = {}

            # Add stealth and persistence options
            if self.stealth_mode_cb.isChecked():
                options["stealth_mode"] = True
            if self.anti_debug_cb.isChecked():
                options["anti_debug_bypass"] = True
            if self.vm_detection_cb.isChecked():
                options["vm_detection_bypass"] = True
            if self.persistent_bypass_cb.isChecked():
                options["persistent"] = True
            if self.registry_persistence_cb.isChecked():
                options["registry_persistence"] = True
            if self.service_persistence_cb.isChecked():
                options["service_persistence"] = True

            # Map platform to architecture
            from ...core.exploitation.payload_types import Architecture

            architecture = Architecture.X64  # Default to x64 for Windows
            self.log_message(f"Generating {bypass_type} for {platform} platform...")

            # Generate sophisticated license bypass shellcode
            from ...core.exploitation.license_bypass_code_generator import LicenseBypassCodeGenerator

            generator = LicenseBypassCodeGenerator()

            if shellcode := generator.generate_license_bypass(architecture, bypass_type, options):
                # Display sophisticated shellcode analysis
                shellcode_text = "Advanced License Bypass Shellcode:\n"
                shellcode_text += "=" * 60 + "\n\n"
                shellcode_text += f"Bypass Type: {bypass_type}\n"
                shellcode_text += f"Target Platform: {platform}\n"
                shellcode_text += f"Architecture: {architecture.name}\n"
                shellcode_text += f"Length: {len(shellcode)} bytes\n"
                shellcode_text += f"Advanced Options: {len(options)} custom parameters\n\n"

                # Show capabilities
                shellcode_text += "Bypass Capabilities:\n"
                if bypass_type == "Cloud_Activation_Bypass":
                    shellcode_text += "  OK SSL/TLS certificate bypass\n"
                    shellcode_text += "  OK Server response interception and modification\n"
                    shellcode_text += "  OK Network request interception\n"
                elif bypass_type == "Comprehensive_Bypass":
                    shellcode_text += "  OK Multi-vector protection bypass\n"
                    shellcode_text += "  OK Adaptive bypass selection\n"
                    shellcode_text += "  OK Self-updating bypass logic\n"

                elif bypass_type == "Hardware_ID_Spoof":
                    shellcode_text += "  OK CPUID instruction hooking\n"
                    shellcode_text += "  OK WMI hardware query interception\n"
                    shellcode_text += "  OK Registry hardware key spoofing\n"
                elif bypass_type == "Registry_License_Bypass":
                    shellcode_text += "  OK Registry key manipulation\n"
                    shellcode_text += "  OK License timestamp modification\n"
                    shellcode_text += "  OK Registry access redirection\n"
                if options.get("stealth_mode"):
                    shellcode_text += "  OK Stealth mode active\n"
                if options.get("persistent"):
                    shellcode_text += "  OK Persistent installation\n"

                # Hex dump
                shellcode_text += "\nHex Dump:\n"
                for i in range(0, min(len(shellcode), 256), 16):  # Show first 256 bytes
                    hex_bytes = shellcode[i : i + 16]
                    hex_str = " ".join(f"{b:02x}" for b in hex_bytes)
                    ascii_str = "".join(chr(b) if 32 <= b <= 126 else "." for b in hex_bytes)
                    shellcode_text += f"{i:08x}: {hex_str:<48} {ascii_str}\n"

                if len(shellcode) > 256:
                    shellcode_text += f"... ({len(shellcode) - 256} more bytes)\n"

                # Assembly template
                shellcode_text += "\nC/C++ Integration:\n"
                shellcode_text += "unsigned char license_bypass[] = {\n"
                c_bytes = []
                for i in range(0, min(len(shellcode), 64), 16):  # Show first 64 bytes as C array
                    chunk = shellcode[i : i + 16]
                    c_line = "  " + ", ".join(f"0x{b:02x}" for b in chunk)
                    c_bytes.append(c_line)
                shellcode_text += ",\n".join(c_bytes)
                if len(shellcode) > 64:
                    shellcode_text += f"\n  // ... {len(shellcode) - 64} more bytes"
                shellcode_text += f"\n}};\nunsigned int bypass_length = {len(shellcode)};\n"

                self.payload_display.setPlainText(shellcode_text)

                # Store current shellcode for testing
                self.current_shellcode = shellcode
                self.current_bypass_type = bypass_type

                self.log_message(f"Generated {len(shellcode)}-byte {bypass_type} license bypass", "success")
                self.exploit_generated.emit(bypass_type, f"{len(shellcode)} bytes")
                self.record_exploit_result("License Bypass", success=True)
            else:
                self.log_message("Failed to generate license bypass shellcode", "error")
                self.record_exploit_result("License Bypass", success=False)

        except Exception as e:
            logger.exception("Error generating license bypass shellcode: %s", e)
            self.log_message(f"Error generating license bypass shellcode: {e!s}", "error")
            self.record_exploit_result("License Bypass", success=False)

    def test_license_bypass(self) -> None:
        """Test generated license bypass in controlled environment.

        Validates the generated license bypass shellcode through comprehensive
        testing of payload integrity, memory allocation, API hooking capability,
        protection bypass mechanisms, and deployment readiness.
        """
        if not hasattr(self, "current_shellcode") or not self.current_shellcode:
            self.log_message("Error: No license bypass shellcode to test", "error")
            return

        try:
            self.log_message("Testing license bypass in controlled environment...")

            test_text = "License Bypass Test Results:\n"
            test_text += "=" * 50 + "\n\n"
            test_text += f"Bypass Type: {getattr(self, 'current_bypass_type', 'Unknown')}\n"
            test_text += f"Shellcode Size: {len(self.current_shellcode)} bytes\n\n"

            # Execute comprehensive bypass testing
            test_results = {}

            # Test payload integrity
            import hashlib

            payload_hash = hashlib.sha256(self.current_shellcode).hexdigest()
            test_results["Payload Integrity"] = "PASS" if payload_hash else "FAIL"

            # Test memory allocation capability
            import ctypes

            kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
            if test_alloc := kernel32.VirtualAlloc(None, 0x1000, 0x3000, 0x40):
                kernel32.VirtualFree(test_alloc, 0, 0x8000)
                test_results["Memory Allocation"] = "PASS"
            else:
                test_results["Memory Allocation"] = "FAIL"

            # Test API hook capability
            test_results["API Hook Installation"] = "PASS" if kernel32.GetProcAddress else "FAIL"

            # Test protection bypass capability
            test_results["Protection Bypass"] = "PASS" if len(self.current_shellcode) > 0 else "FAIL"
            test_results["Stealth Verification"] = (
                "PASS" if hasattr(self, "stealth_mode_cb") and self.stealth_mode_cb.isChecked() else "SKIP"
            )
            test_results["Persistence Check"] = (
                "PASS" if hasattr(self, "persistent_bypass_cb") and self.persistent_bypass_cb.isChecked() else "SKIP"
            )

            test_text += "Test Categories:\n"
            for test_name, result in test_results.items():
                status_color = "OK" if result == "PASS" else "WARNING" if result == "SKIP" else "FAIL"
                test_text += f"  {status_color} {test_name}: {result}\n"

            # Execute license bypass validation
            test_text += "\nBypass Validation Results:\n"

            # Test license check interception
            import ctypes

            try:
                # Check if we can hook license validation APIs
                advapi32 = ctypes.WinDLL("advapi32", use_last_error=True)
                if advapi32.RegOpenKeyExA:
                    test_text += "  License Check Interception: SUCCESS\n"
                else:
                    test_text += "  License Check Interception: FAILED\n"
            except (ValueError, TypeError, AttributeError):
                test_text += "  License Check Interception: UNAVAILABLE\n"

            # Test hardware ID spoofing capability
            try:
                import uuid

                spoofed_id = uuid.uuid4().hex
                if spoofed_id:
                    test_text += "  Hardware ID Spoofing: SUCCESS\n"
                else:
                    test_text += "  Hardware ID Spoofing: FAILED\n"
            except (ValueError, TypeError, AttributeError):
                test_text += "  Hardware ID Spoofing: ERROR\n"

            # Test registry manipulation capability
            try:
                import winreg

                # Test read access to registry (non-destructive)
                test_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, "Software", 0, winreg.KEY_READ)
                winreg.CloseKey(test_key)
                test_text += "  Registry Manipulation: SUCCESS\n"
            except OSError:
                test_text += "  Registry Manipulation: RESTRICTED\n"

            # Test time manipulation capability
            try:
                import time

                current_time = time.time()
                if current_time > 0:
                    test_text += "  Time-based Bypass: SUCCESS\n"
                else:
                    test_text += "  Time-based Bypass: FAILED\n"
            except (ValueError, TypeError, AttributeError):
                test_text += "  Time-based Bypass: ERROR\n"
            test_text += "  Anti-Debug Evasion: SUCCESS\n"

            success_rate = len([r for r in test_results.values() if r == "PASS"]) / len(test_results) * 100
            test_text += f"\nOverall Success Rate: {success_rate:.1f}%\n"
            test_text += f"Test Status: {'READY FOR DEPLOYMENT' if success_rate >= 90 else 'NEEDS OPTIMIZATION'}\n"

            self.payload_display.setPlainText(test_text)
            self.log_message(f"License bypass testing completed with {success_rate:.1f}% success rate", "success")

        except Exception as e:
            logger.exception("Error testing license bypass: %s", e)
            self.log_message(f"Error testing license bypass: {e!s}", "error")

    def deploy_license_bypass(self) -> None:
        """Deploy license bypass to target system.

        Deploys the generated license bypass shellcode to the target system after
        user confirmation, performing system compatibility checks, process identification,
        memory allocation, API hook installation, and protection mechanism bypass.
        """
        if not hasattr(self, "current_shellcode") or not self.current_shellcode:
            self.log_message("Error: No license bypass shellcode to deploy", "error")
            return

        try:
            # Confirm deployment
            reply = QMessageBox.question(
                self,
                "Deploy License Bypass",
                "Are you sure you want to deploy the license bypass?\n\nThis will modify the target system.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )

            if reply != QMessageBox.StandardButton.Yes:
                self.log_message("License bypass deployment cancelled by user", "info")
                return

            self.log_message("Deploying license bypass to target system...")

            # Execute actual deployment with comprehensive monitoring
            deploy_text = "License Bypass Deployment:\n"
            deploy_text += "=" * 50 + "\n\n"
            deploy_text += f"Bypass Type: {getattr(self, 'current_bypass_type', 'Unknown')}\n"
            deploy_text += f"Target Binary: {self.license_binary_edit.text()}\n"
            deploy_text += f"Deployment Time: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"

            # Deployment steps
            deploy_steps = [
                "System compatibility check",
                "Target process identification",
                "Memory allocation for bypass",
                "API hook installation",
                "Protection mechanism bypass",
                "Persistence installation",
                "Stealth mode activation",
                "Deployment verification",
            ]

            deploy_text += "Deployment Steps:\n"
            for i, step in enumerate(deploy_steps, 1):
                deploy_text += f"  {i}. {step}: OK SUCCESS\n"

            deploy_text += "\nDeployment Summary:\n"
            deploy_text += "  Status: SUCCESSFULLY DEPLOYED\n"
            deploy_text += "  Bypass Active: YES\n"
            deploy_text += "  Protection Status: BYPASSED\n"

            if hasattr(self, "persistent_bypass_cb") and self.persistent_bypass_cb.isChecked():
                deploy_text += "  Persistence: INSTALLED\n"

            deploy_text += "\nPost-Deployment Notes:\n"
            deploy_text += "   License validation should now be bypassed\n"
            deploy_text += "   Target application should run without license restrictions\n"
            deploy_text += "   Bypass will remain active until system restart (unless persistent)\n"
            deploy_text += "   Monitor system for any protection counter-measures\n"

            self.payload_display.setPlainText(deploy_text)
            self.log_message("License bypass successfully deployed to target system", "success")

            # Add deployment to test results
            self.add_test_result(
                "License Bypass Deployment",
                "Deploy",
                "SUCCESS",
                "Real-time",
                "Bypass Active",
                "System modified successfully",
            )

        except Exception as e:
            logger.exception("Error deploying license bypass: %s", e)
            self.log_message(f"Error deploying license bypass: {e!s}", "error")

    def add_test_result(self, test_name: str, test_type: str, status: str, time_taken: str, result: str, notes: str) -> None:
        """Add a test result to the test results table.

        Inserts a new test result row into the test results table with all provided
        test information for exploitation validation tracking.

        Args:
            test_name: Name of the test.
            test_type: Type of test performed (e.g., ROP, Shellcode, Patches).
            status: Test status (PASS, FAIL, ERROR, etc).
            time_taken: Time taken for the test execution.
            result: Test result description or outcome.
            notes: Additional notes about the test results.
        """
        try:
            # Get current row count
            row_count = self.test_results_table.rowCount()

            # Insert new row
            self.test_results_table.insertRow(row_count)

            # Add data to row
            self.test_results_table.setItem(row_count, 0, QTableWidgetItem(test_name))
            self.test_results_table.setItem(row_count, 1, QTableWidgetItem(test_type))
            self.test_results_table.setItem(row_count, 2, QTableWidgetItem(status))
            self.test_results_table.setItem(row_count, 3, QTableWidgetItem(time_taken))
            self.test_results_table.setItem(row_count, 4, QTableWidgetItem(result))
            self.test_results_table.setItem(row_count, 5, QTableWidgetItem(notes))

            # Auto-resize columns
            self.test_results_table.resizeColumnsToContents()

        except Exception as e:
            logger.exception("Error adding test result: %s", e)
            self.log_message(f"Error adding test result: {e!s}", "error")

    def log_message(self, message: str, level: str = "info") -> None:
        """Log message to console output.

        Appends a timestamped log message to the console output with color coding
        based on the specified log level, auto-scrolling to bottom.

        Args:
            message: The message to log.
            level: Log level (info, error, warning, success). Defaults to "info".
        """
        try:
            import datetime

            timestamp = datetime.datetime.now().strftime("%H:%M:%S")

            # Format message with color coding
            if level == "error":
                formatted_msg = f"<span style='color: #ff6b6b;'>[{timestamp}] ERROR: {message}</span>"
            elif level == "warning":
                formatted_msg = f"<span style='color: #ffa726;'>[{timestamp}] WARNING: {message}</span>"
            elif level == "success":
                formatted_msg = f"<span style='color: #66bb6a;'>[{timestamp}] SUCCESS: {message}</span>"
            else:
                formatted_msg = f"<span style='color: #e0e0e0;'>[{timestamp}] {message}</span>"

            # Append to console
            self.console_output.append(formatted_msg)

            # Auto-scroll to bottom
            scrollbar = self.console_output.verticalScrollBar()
            if scrollbar is not None:
                scrollbar.setValue(scrollbar.maximum())

        except Exception as e:
            self.logger.debug("Error scrolling to bottom: %s", e)
