"""
Common exploit-related utility functions to avoid code duplication.
"""

from .logger import log_message
from .ui_helpers import generate_exploit_strategy_common, generate_exploit_payload_common


def handle_exploit_strategy_generation(update_output_signal, binary_path, vulnerability_type="buffer_overflow"):
    """
    Common handler for exploit strategy generation.
    
    Args:
        update_output_signal: Qt signal to emit log messages
        binary_path: Path to the binary file
        vulnerability_type: Type of vulnerability to exploit
    
    Returns:
        dict: The generated strategy
    """
    update_output_signal.emit(log_message(
        "[Exploit Strategy] Generating exploitation strategy..."))
    
    strategy = generate_exploit_strategy_common(binary_path, vulnerability_type)
    
    if "error" in strategy:
        update_output_signal.emit(log_message(
            f"[Exploit Strategy] Error: {strategy['error']}"))
    else:
        update_output_signal.emit(log_message(
            "[Exploit Strategy] Strategy generated successfully"))
        
        # Display strategy details
        if "strategy" in strategy and "steps" in strategy["strategy"]:
            update_output_signal.emit(log_message(
                "[Exploit Strategy] Exploitation steps:"))
            for i, step in enumerate(strategy["strategy"]["steps"], 1):
                update_output_signal.emit(log_message(
                    f"[Exploit Strategy] {i}. {step}"))
        
        if "automation_script" in strategy:
            update_output_signal.emit(log_message(
                "[Exploit Strategy] Automation script generated"))
    
    return strategy


def handle_exploit_payload_generation(update_output_signal, payload_type):
    """
    Common handler for exploit payload generation.
    
    Args:
        update_output_signal: Qt signal to emit log messages
        payload_type: Type of payload to generate
    
    Returns:
        dict: The generated payload result
    """
    update_output_signal.emit(log_message(
        f"[Payload Generator] Generating {payload_type} payload..."))
    
    payload_result = generate_exploit_payload_common(payload_type)
    
    if "error" in payload_result:
        update_output_signal.emit(log_message(
            f"[Payload Generator] Error: {payload_result['error']}"))
    else:
        update_output_signal.emit(log_message(
            f"[Payload Generator] {payload_type} payload generated successfully"))
        
        # Display payload details
        if "description" in payload_result:
            update_output_signal.emit(log_message(
                f"[Payload Generator] Description: {payload_result['description']}"))
        
        if "payload_bytes" in payload_result:
            update_output_signal.emit(log_message(
                f"[Payload Generator] Payload bytes: {payload_result['payload_bytes'][:100]}..."))
    
    return payload_result


def create_analysis_button(button_text, callback, extra_buttons=None):
    """
    Common function to create analysis buttons with consistent styling.
    
    Args:
        button_text: Text for the button
        callback: Function to call when button is clicked
        extra_buttons: Optional list of (text, callback) tuples for additional buttons
        
    Returns:
        list: List of (button_text, callback, style) tuples
    """
    buttons = []
    
    # Main button
    style = ""
    if button_text == "Analyze Binary":
        style = "QPushButton { background-color: #2196F3; color: white; font-weight: bold; }"
    buttons.append((button_text, callback, style))
    
    # Extra buttons if provided
    if extra_buttons:
        for btn_text, btn_callback in extra_buttons:
            btn_style = ""
            if btn_text == "Analyze Binary":
                btn_style = "QPushButton { background-color: #2196F3; color: white; font-weight: bold; }"
            buttons.append((btn_text, btn_callback, btn_style))
    
    return buttons