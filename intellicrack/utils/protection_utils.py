"""Protection utilities for software licensing analysis and bypass.

This module provides utilities for analyzing software protection mechanisms,
detecting protection types, generating bypass strategies, and creating hooks
and emulation configurations for licensing protection systems.

Copyright (C) 2025 Zachary Flint.

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import logging
from typing import Any


logger: logging.Logger = logging.getLogger(__name__)


def inject_comprehensive_api_hooks(app: object, hook_types: list[str] | None = None) -> str:
    """Inject comprehensive API hooks for various protection mechanisms.

    Args:
        app: Application instance
        hook_types: List of hook types to inject, or None to use defaults

    Returns:
        Generated script content for API hooking

    """
    logger.debug("Injecting API hooks for app: %s, hook_types: %s", app is not None, hook_types)
    if hook_types is None:
        hook_types = ["hardware_id", "debugger", "time", "telemetry", "network"]

    script_lines = [
        "// Comprehensive API Hooking Script",
        "// Generated by Intellicrack Protection Utils",
        "",
        "console.log('[Intellicrack] Starting comprehensive API hooking...');",
        "",
    ]

    # Hardware ID hooks
    if "hardware_id" in hook_types:
        script_lines.extend(
            [
                "// Hardware ID Spoofing Hooks",
                "if (Process.platform === 'windows') {",
                "    var kernel32 = Process.getModuleByName('kernel32.dll');",
                "    var advapi32 = Process.getModuleByName('advapi32.dll');",
                "",
                "    // Hook GetVolumeInformation",
                "    try {",
                "        var GetVolumeInformationW = kernel32.getExportByName('GetVolumeInformationW');",
                "        Interceptor.attach(GetVolumeInformationW, {",
                "            onEnter: function(args) {",
                "                console.log('[HWID] GetVolumeInformationW called');",
                "            },",
                "            onLeave: function(retval) {",
                "                console.log('[HWID] Spoofing volume information');",
                "                // Modify volume serial number",
                "                return retval;",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[HWID] Failed to hook GetVolumeInformationW: ' + e);",
                "    }",
                "",
                "    // Hook registry functions for hardware info",
                "    try {",
                "        var RegQueryValueExW = advapi32.getExportByName('RegQueryValueExW');",
                "        Interceptor.attach(RegQueryValueExW, {",
                "            onEnter: function(args) {",
                "                var valueName = args[1].readUtf16String();",
                "                if (valueName && (valueName.includes('ProcessorId') || valueName.includes('SystemBiosVersion'))) {",
                "                    console.log('[HWID] Registry query for hardware info: ' + valueName);",
                "                }",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[HWID] Failed to hook RegQueryValueExW: ' + e);",
                "    }",
                "}",
                "",
            ],
        )

    # Anti-debugger hooks
    if "debugger" in hook_types:
        script_lines.extend(
            [
                "// Anti-Debugger Hooks",
                "if (Process.platform === 'windows') {",
                "    var ntdll = Process.getModuleByName('ntdll.dll');",
                "",
                "    // Hook NtQueryInformationProcess",
                "    try {",
                "        var NtQueryInformationProcess = ntdll.getExportByName('NtQueryInformationProcess');",
                "        Interceptor.attach(NtQueryInformationProcess, {",
                "            onEnter: function(args) {",
                "                var infoClass = args[1].toInt32();",
                "                if (infoClass === 7) { // ProcessDebugPort",
                "                    console.log('[AntiDebug] ProcessDebugPort query detected');",
                "                    this.spoofDebugPort = true;",
                "                }",
                "            },",
                "            onLeave: function(retval) {",
                "                if (this.spoofDebugPort) {",
                "                    console.log('[AntiDebug] Spoofing debug port result');",
                "                    retval.replace(ptr(0)); // Return success but no debug port",
                "                }",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[AntiDebug] Failed to hook NtQueryInformationProcess: ' + e);",
                "    }",
                "",
                "    // Hook IsDebuggerPresent",
                "    try {",
                "        var IsDebuggerPresent = kernel32.getExportByName('IsDebuggerPresent');",
                "        Interceptor.attach(IsDebuggerPresent, {",
                "            onLeave: function(retval) {",
                "                console.log('[AntiDebug] IsDebuggerPresent called, returning false');",
                "                retval.replace(ptr(0)); // Always return false",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[AntiDebug] Failed to hook IsDebuggerPresent: ' + e);",
                "    }",
                "}",
                "",
            ],
        )

    # Time manipulation hooks
    if "time" in hook_types:
        script_lines.extend(
            [
                "// Time Manipulation Hooks",
                "if (Process.platform === 'windows') {",
                "    // Hook GetTickCount and GetTickCount64",
                "    try {",
                "        var GetTickCount = kernel32.getExportByName('GetTickCount');",
                "        Interceptor.attach(GetTickCount, {",
                "            onLeave: function(retval) {",
                "                console.log('[Time] GetTickCount called, returning modified value');",
                "                // Return a time that makes the application think it's been running longer",
                "                var spoofedTime = retval.toInt32() + 3600000; // Add 1 hour",
                "                retval.replace(ptr(spoofedTime));",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[Time] Failed to hook GetTickCount: ' + e);",
                "    }",
                "",
                "    // Hook GetSystemTime",
                "    try {",
                "        var GetSystemTime = kernel32.getExportByName('GetSystemTime');",
                "        Interceptor.attach(GetSystemTime, {",
                "            onEnter: function(args) {",
                "                console.log('[Time] GetSystemTime called');",
                "            }",
                "        });",
                "    } catch (e) {",
                "        console.log('[Time] Failed to hook GetSystemTime: ' + e);",
                "    }",
                "}",
                "",
            ],
        )

    # Telemetry blocking hooks
    if "telemetry" in hook_types:
        script_lines.extend(
            [
                "// Telemetry Blocking Hooks",
                "if (Process.platform === 'windows') {",
                "    var wininet = null;",
                "    try {",
                "        wininet = Process.getModuleByName('wininet.dll');",
                "    } catch (e) {",
                "        console.log('[Telemetry] wininet.dll not found');",
                "    }",
                "",
                "    if (wininet) {",
                "        // Hook InternetOpenUrl",
                "        try {",
                "            var InternetOpenUrlW = wininet.getExportByName('InternetOpenUrlW');",
                "            Interceptor.attach(InternetOpenUrlW, {",
                "                onEnter: function(args) {",
                "                    var url = args[1].readUtf16String();",
                "                    console.log('[Telemetry] InternetOpenUrl called with: ' + url);",
                "                    if (url && (url.includes('telemetry') || url.includes('analytics') || url.includes('tracking'))) {",
                "                        console.log('[Telemetry] Blocking telemetry URL: ' + url);",
                "                        this.blockRequest = true;",
                "                    }",
                "                },",
                "                onLeave: function(retval) {",
                "                    if (this.blockRequest) {",
                "                        retval.replace(ptr(0)); // Return null handle",
                "                    }",
                "                }",
                "            });",
                "        } catch (e) {",
                "            console.log('[Telemetry] Failed to hook InternetOpenUrlW: ' + e);",
                "        }",
                "    }",
                "}",
                "",
            ],
        )

    # Network monitoring hooks
    if "network" in hook_types:
        script_lines.extend(
            [
                "// Network Monitoring Hooks",
                "if (Process.platform === 'windows') {",
                "    var ws2_32 = null;",
                "    try {",
                "        ws2_32 = Process.getModuleByName('ws2_32.dll');",
                "    } catch (e) {",
                "        console.log('[Network] ws2_32.dll not found');",
                "    }",
                "",
                "    if (ws2_32) {",
                "        // Hook connect function",
                "        try {",
                "            var connect = ws2_32.getExportByName('connect');",
                "            Interceptor.attach(connect, {",
                "                onEnter: function(args) {",
                "                    console.log('[Network] Socket connect called');",
                "                    // Could analyze the destination address here",
                "                }",
                "            });",
                "        } catch (e) {",
                "            console.log('[Network] Failed to hook connect: ' + e);",
                "        }",
                "",
                "        // Hook send function",
                "        try {",
                "            var send = ws2_32.getExportByName('send');",
                "            Interceptor.attach(send, {",
                "                onEnter: function(args) {",
                "                    var dataPtr = args[1];",
                "                    var dataSize = args[2].toInt32();",
                "                    console.log('[Network] Data being sent, size: ' + dataSize);",
                "                }",
                "            });",
                "        } catch (e) {",
                "            console.log('[Network] Failed to hook send: ' + e);",
                "        }",
                "    }",
                "}",
                "",
            ],
        )

    # Add completion message
    script_lines.extend(
        [
            "console.log('[Intellicrack] API hooking setup complete');",
            "console.log('[Intellicrack] Active hooks: " + ", ".join(hook_types) + "');",
            "",
        ],
    )

    return "\n".join(script_lines)


def detect_protection_mechanisms(binary_path: str) -> dict[str, Any]:
    """Detect protection mechanisms in a binary.

    Args:
        binary_path: Path to binary file

    Returns:
        Dictionary with detected protection information

    """
    protections: dict[str, str | bool | list[str] | None] = {
        "packer": None,
        "obfuscation": False,
        "anti_debug": False,
        "vm_detection": False,
        "hardware_fingerprinting": False,
        "time_checks": False,
        "network_validation": False,
        "details": [],
    }

    try:
        with open(binary_path, "rb") as f:
            data = f.read(8192)  # Read first 8KB for quick analysis

        # Simple heuristic checks
        details_list = protections["details"]
        assert isinstance(details_list, list)

        if b"UPX" in data:
            protections["packer"] = "UPX"
            details_list.append("UPX packer detected")

        if b"VMProtect" in data or b"vmprotect" in data.lower():
            protections["packer"] = "VMProtect"
            details_list.append("VMProtect detected")

        if b"Themida" in data or b"themida" in data.lower():
            protections["packer"] = "Themida"
            details_list.append("Themida protection detected")

        # Anti-debug indicators
        debug_strings = [
            b"IsDebuggerPresent",
            b"CheckRemoteDebuggerPresent",
            b"NtQueryInformationProcess",
        ]
        for debug_str in debug_strings:
            if debug_str in data:
                protections["anti_debug"] = True
                details_list.append(f"Anti-debug API detected: {debug_str.decode()}")
                break

        # VM detection indicators
        vm_strings = [b"VMware", b"VirtualBox", b"QEMU", b"Xen"]
        for vm_str in vm_strings:
            if vm_str in data:
                protections["vm_detection"] = True
                details_list.append(f"VM detection string found: {vm_str.decode()}")

        # Hardware fingerprinting
        hw_strings = [b"GetVolumeInformation", b"GetSystemInfo", b"GetComputerName"]
        for hw_str in hw_strings:
            if hw_str in data:
                protections["hardware_fingerprinting"] = True
                details_list.append(f"Hardware fingerprinting API: {hw_str.decode()}")

        # Time-based checks
        time_strings = [b"GetTickCount", b"GetSystemTime", b"QueryPerformanceCounter"]
        for time_str in time_strings:
            if time_str in data:
                protections["time_checks"] = True
                details_list.append(f"Time-based check API: {time_str.decode()}")

        # Network validation
        net_strings = [b"InternetOpen", b"HttpSendRequest", b"WinHttpOpen"]
        for net_str in net_strings:
            if net_str in data:
                protections["network_validation"] = True
                details_list.append(f"Network validation API: {net_str.decode()}")

    except Exception as e:
        logger.debug("Protection detection failed: %s", e, exc_info=True)
        details_list = protections["details"]
        assert isinstance(details_list, list)
        details_list.append(f"Detection error: {e}")

    return protections


def generate_bypass_strategy(protections: dict[str, Any]) -> list[str]:
    """Generate bypass strategy based on detected protections.

    Args:
        protections: Protection analysis results

    Returns:
        List of recommended bypass strategies

    """
    strategies = []

    if protections.get("packer"):
        packer = protections["packer"]
        strategies.append(f"Unpack {packer} protection first")

        if packer == "Themida":
            strategies.append("Use Themida unpacker or generic unpackers")

        elif packer == "UPX":
            strategies.append("Use 'upx -d' to decompress UPX packed binary")
        elif packer == "VMProtect":
            strategies.append("Consider VMProtect-specific unpacking tools")
    if protections.get("anti_debug"):
        strategies.extend((
            "Implement anti-debug bypass hooks",
            "Hook IsDebuggerPresent and NtQueryInformationProcess",
            "Consider using hardware breakpoints instead of software breakpoints",
        ))
    if protections.get("vm_detection"):
        strategies.extend((
            "Use VM evasion techniques",
            "Modify VM artifacts to appear as physical machine",
            "Hook VM detection APIs",
        ))
    if protections.get("hardware_fingerprinting"):
        strategies.extend((
            "Implement hardware fingerprint spoofing",
            "Hook GetVolumeInformation and GetSystemInfo",
            "Use consistent spoofed hardware identifiers",
        ))
    if protections.get("time_checks"):
        strategies.extend((
            "Implement time manipulation hooks",
            "Hook GetTickCount and time-related APIs",
            "Consider time acceleration techniques",
        ))
    if protections.get("network_validation"):
        strategies.append("Set up local license server emulation")
        strategies.append("Hook network APIs to redirect requests")
        strategies.append("Analyze network protocol for proper responses")

    if not any(
        protections.get(key)
        for key in [
            "packer",
            "anti_debug",
            "vm_detection",
            "hardware_fingerprinting",
            "time_checks",
            "network_validation",
        ]
    ):
        strategies.append("No major protections detected - standard patching may be sufficient")
        strategies.append("Focus on license validation logic analysis")

    return strategies


def create_custom_hook_script(hook_config: dict[str, Any]) -> str:
    """Create a custom Frida hook script based on configuration.

    Args:
        hook_config: Hook configuration dictionary

    Returns:
        Generated Frida script

    """
    script_lines = [
        "// Custom Hook Script",
        "// Generated by Intellicrack Protection Utils",
        "",
        "console.log('[Custom] Starting custom hooks...');",
        "",
    ]

    # Process function hooks
    if "functions" in hook_config:
        for func_config in hook_config["functions"]:
            module_name = func_config.get("module", "kernel32.dll")
            function_name = func_config.get("name")
            hook_type = func_config.get("type", "log")  # log, block, modify

            if not function_name:
                continue

            script_lines.extend(
                [
                    f"// Hook {function_name} in {module_name}",
                    "try {",
                    f"    var module = Process.getModuleByName('{module_name}');",
                    f"    var {function_name} = module.getExportByName('{function_name}');",
                    f"    Interceptor.attach({function_name}, {{",
                    "        onEnter: function(args) {",
                    f"            console.log('[Custom] {function_name} called');",
                ],
            )

            if hook_type == "block":
                script_lines.extend(
                    [
                        "            this.block = true;",
                    ],
                )
            elif hook_type == "modify":
                script_lines.extend(
                    [
                        "            // Custom modification logic here",
                        "            this.modify = true;",
                    ],
                )

            script_lines.extend(
                [
                    "        },",
                    "        onLeave: function(retval) {",
                ],
            )

            if hook_type == "block":
                script_lines.extend(
                    [
                        "            if (this.block) {",
                        f"                console.log('[Custom] Blocking {function_name}');",
                        "                retval.replace(ptr(0));",
                        "            }",
                    ],
                )
            elif hook_type == "modify":
                script_lines.extend(
                    [
                        "            if (this.modify) {",
                        f"                console.log('[Custom] Modifying {function_name} result');",
                        "                // Custom result modification here",
                        "            }",
                    ],
                )

            script_lines.extend(
                [
                    "        }",
                    "    });",
                    "} catch (e) {",
                    f"    console.log('[Custom] Failed to hook {function_name}: ' + e);",
                    "}",
                    "",
                ],
            )

    # Process memory patches
    if "memory_patches" in hook_config:
        for patch in hook_config["memory_patches"]:
            address = patch.get("address")
            original = patch.get("original", "")
            replacement = patch.get("replacement", "")

            if address:
                script_lines.extend(
                    [
                        f"// Memory patch at {address}",
                        "try {",
                        f"    var addr = ptr('{address}');",
                        f"    var originalBytes = '{original}';",
                        f"    var newBytes = '{replacement}';",
                        "    ",
                        "    // Apply memory patch",
                        "    Memory.protect(addr, newBytes.length / 2, 'rwx');",
                        "    for (var i = 0; i < newBytes.length; i += 2) {",
                        "        var byte = parseInt(newBytes.substr(i, 2), 16);",
                        "        addr.add(i / 2).writeU8(byte);",
                        "    }",
                        f"    console.log('[Custom] Applied memory patch at {address}');",
                        "} catch (e) {",
                        f"    console.log('[Custom] Failed to apply patch at {address}: ' + e);",
                        "}",
                        "",
                    ],
                )

    script_lines.extend(
        [
            "console.log('[Custom] Custom hooks setup complete');",
            "",
        ],
    )

    return "\n".join(script_lines)


def emulate_hardware_dongle(config: dict[str, Any]) -> dict[str, Any]:
    """Emulate hardware dongle for license bypass.

    This function creates a virtual hardware dongle emulation configuration
    that can bypass hardware-based license checks by emulating the presence
    and responses of common hardware protection devices.

    Args:
        config: Configuration dictionary with dongle parameters

    Returns:
        Dictionary containing dongle emulation details and status

    """
    logger.info("Generating hardware dongle emulation configuration")

    # Extract configuration parameters
    dongle_type = config.get("type", "generic")
    vendor_id = config.get("vendor_id", "0x0529")  # Aladdin HASP default
    product_id = config.get("product_id", "0x0001")
    serial_number = config.get("serial", "EMULATED_001")

    emulation_result = {
        "dongle_id": serial_number,
        "status": "active",
        "features": [],
        "emulation_active": True,
        "type": dongle_type,
        "vendor_id": vendor_id,
        "product_id": product_id,
        "responses": {},
        "memory_map": {},
        "implementation": {},
    }

    # Configure based on dongle type
    if dongle_type.lower() == "hasp":
        emulation_result["features"] = ["feature1", "feature2", "feature3", "unlimited_users"]
        emulation_result["responses"] = {
            "get_version": b"\x04\x00\x00\x00",  # Version 4
            "get_id": serial_number.encode(),
            "is_present": b"\x01",  # Present
            "check_license": b"\x01\x00\x00\x00",  # Valid
            "get_memory": b"\x00" * 112,  # 112 bytes of memory
        }
        emulation_result["implementation"]["script"] = """
// HASP Dongle Emulation
Interceptor.attach(Module.findExportByName(null, 'hasp_login'), {
    onLeave: function(retval) {
        console.log('[Dongle] HASP login intercepted, returning success');
        retval.replace(0);  // HASP_STATUS_OK
    }
});
"""

    elif dongle_type.lower() == "sentinel":
        emulation_result["features"] = ["feature_a", "feature_b", "pro_license"]
        emulation_result["responses"] = {
            "slm_login": 0,  # Success
            "slm_get_info": {"version": "7.0", "features": 0xFFFF},
            "slm_check_license": 0,  # Valid
        }
        emulation_result["implementation"]["script"] = """
// Sentinel Dongle Emulation
Interceptor.attach(Module.findExportByName(null, 'SLM_LoginEasy'), {
    onLeave: function(retval) {
        console.log('[Dongle] Sentinel login intercepted, returning success');
        retval.replace(0);  // SLM_SUCCESS
    }
});
"""

    elif dongle_type.lower() == "wibu":
        emulation_result["features"] = ["codemeter", "network_license", "time_unlimited"]
        emulation_result["responses"] = {
            "cm_login": 0,
            "cm_get_license": {"valid": True, "expiry": "2099-12-31"},
            "cm_check": 0,
        }
        emulation_result["implementation"]["script"] = """
// CodeMeter Dongle Emulation
Interceptor.attach(Module.findExportByName(null, 'CmGetLicenseInfo'), {
    onLeave: function(retval) {
        console.log('[Dongle] CodeMeter license check intercepted');
        retval.replace(0);  // CM_OK
    }
});
"""

    else:
        # Generic dongle emulation
        emulation_result["features"] = ["basic", "standard", "pro"]
        emulation_result["responses"] = {
            "check": True,
            "validate": 0,
            "get_features": 0xFFFFFFFF,
        }

    # Add memory emulation
    emulation_result["memory_map"] = {
        "0x0000": b"DONGLE_OK",
        "0x0008": serial_number.encode()[:16].ljust(16, b"\x00"),
        "0x0018": b"\xff" * 8,  # Feature flags
        "0x0020": b"\x00" * 32,  # User data area
    }

    # Add advanced features
    emulation_result["advanced"] = {
        "usb_emulation": vendor_id != "0x0000",
        "network_emulation": False,
        "time_based_features": False,
        "encryption_support": True,
    }

    logger.info("Hardware dongle emulation configured for %s", dongle_type)
    return emulation_result


def generate_hwid_spoof_config(target_hwid: str) -> dict[str, Any]:
    """Generate hardware ID spoofing configuration.

    This function creates a comprehensive configuration for spoofing hardware IDs,
    including registry modifications, API hooks, and system information overrides.

    Args:
        target_hwid: Target hardware ID to spoof

    Returns:
        Dictionary containing HWID spoofing configuration

    """
    logger.info("Generating HWID spoof configuration for: %s", target_hwid)

    import uuid

    # Parse target HWID or generate components
    if len(target_hwid) == 36 and "-" in target_hwid:
        # UUID format
        hwid_uuid = target_hwid
    else:
        # Generate UUID from HWID
        hwid_uuid = str(uuid.uuid5(uuid.NAMESPACE_DNS, target_hwid))

    config = {
        "target_hwid": target_hwid,
        "spoof_method": "registry",
        "backup_original": True,
        "restore_command": f"restore_hwid {target_hwid}",
        "components": {
            "machine_guid": hwid_uuid,
            "product_id": f"00000-00000-{target_hwid[:5]}-00000",
            "hardware_id": target_hwid,
            "volume_serial": f"{target_hwid[:8]}",
            "cpu_id": f"BFEBFBFF{target_hwid[:8].upper()}",
            "motherboard_serial": f"MB-{target_hwid[:12].upper()}",
            "mac_address": f"{target_hwid[:2]}:{target_hwid[2:4]}:{target_hwid[4:6]}:00:00:01",
        },
        "registry_keys": [
            {
                "path": r"HKLM\SOFTWARE\Microsoft\Cryptography",
                "value": "MachineGuid",
                "data": hwid_uuid,
                "type": "REG_SZ",
            },
            {
                "path": r"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion",
                "value": "ProductId",
                "data": f"00000-00000-{target_hwid[:5]}-00000",
                "type": "REG_SZ",
            },
        ],
        "api_hooks": {
            "kernel32.dll": [
                {
                    "function": "GetVolumeInformationW",
                    "hook_type": "modify_serial",
                    "serial": f"{target_hwid[:8]}",
                },
            ],
            "advapi32.dll": [
                {
                    "function": "RegQueryValueExW",
                    "hook_type": "intercept_hwid",
                    "values": ["MachineGuid", "ProductId", "DigitalProductId"],
                },
            ],
        },
        "wmi_overrides": {
            "Win32_BaseBoard": {"SerialNumber": f"MB-{target_hwid[:12].upper()}"},
            "Win32_Processor": {"ProcessorId": f"BFEBFBFF{target_hwid[:8].upper()}"},
            "Win32_DiskDrive": {"SerialNumber": f"DSK-{target_hwid[:10].upper()}"},
            "Win32_NetworkAdapter": {"MACAddress": f"{target_hwid[:2]}:{target_hwid[2:4]}:{target_hwid[4:6]}:00:00:01"},
        },
        "implementation_script": f'''
# HWID Spoofing Script
# Target HWID: {target_hwid}

import winreg
import subprocess

def backup_registry() -> None:
    """Backup current HWID values from registry.

    Exports the HKLM\\SOFTWARE\\Microsoft\\Cryptography registry key
    to a file for restoration purposes.

    """
    subprocess.run(['reg', 'export', 'HKLM\\SOFTWARE\\Microsoft\\Cryptography', 'hwid_backup.reg'])

def apply_hwid_spoof() -> None:
    """Apply hardware ID spoofing registry modifications.

    Modifies the registry MachineGuid value to the spoofed HWID UUID.

    Raises:
        Exception: If registry modification fails.

    """
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,
                           r'SOFTWARE\\Microsoft\\Cryptography',
                           0, winreg.KEY_WRITE)
        winreg.SetValueEx(key, 'MachineGuid', 0, winreg.REG_SZ, '{hwid_uuid}')
        winreg.CloseKey(key)
        print(f"HWID spoofed to: {hwid_uuid}")
    except Exception as e:
        logger.error("Exception in protection_utils: %s", e, exc_info=True)
        print(f"Failed to spoof HWID: {{e}}")

if __name__ == "__main__":
    backup_registry()
    apply_hwid_spoof()
''',
        "restoration": {
            "backup_location": "hwid_backup.reg",
            "restore_script": """
# HWID Restoration Script
import subprocess
subprocess.run(['reg', 'import', 'hwid_backup.reg'])
print("Original HWID restored")
""",
            "verification_command": "wmic csproduct get UUID",
        },
    }

    logger.info("HWID spoof configuration generated")
    return config


def generate_time_bomb_defuser(binary_path: str) -> dict[str, Any]:
    """Generate time bomb defusal configuration.

    This function analyzes a binary for time-based protection mechanisms
    and generates patches to defuse time bombs and trial limitations.

    Args:
        binary_path: Path to the binary to analyze

    Returns:
        Dictionary containing time bomb defusal strategy

    """
    logger.info("Analyzing binary for time bombs: %s", binary_path)

    config: dict[str, Any] = {
        "binary": binary_path,
        "time_checks_found": 0,
        "patches": [],
        "defusal_strategy": "nop_time_checks",
        "analysis_results": {},
        "hook_points": [],
        "recommendations": [],
    }

    try:
        # Read binary for analysis
        with open(binary_path, "rb") as f:
            binary_data = f.read()

        # Common time-related API patterns
        time_apis = {
            b"GetSystemTime": "System time check",
            b"GetLocalTime": "Local time check",
            b"GetTickCount": "Uptime check",
            b"GetTickCount64": "Extended uptime check",
            b"QueryPerformanceCounter": "High-resolution time check",
            b"time": "C runtime time check",
            b"_time64": "64-bit time check",
            b"GetFileTime": "File timestamp check",
            b"CompareFileTime": "Time comparison",
        }

        time_checks_found = config["time_checks_found"]
        assert isinstance(time_checks_found, int)
        analysis_results = config["analysis_results"]
        assert isinstance(analysis_results, dict)
        hook_points = config["hook_points"]
        assert isinstance(hook_points, list)
        patches = config["patches"]
        assert isinstance(patches, list)
        recommendations = config["recommendations"]
        assert isinstance(recommendations, list)

        # Search for time-related APIs
        for api, description in time_apis.items():
            if api in binary_data:
                time_checks_found += 1
                offset = binary_data.find(api)

                analysis_results[api.decode()] = {
                    "offset": hex(offset),
                    "description": description,
                    "severity": "high" if b"Compare" in api else "medium",
                }

                # Generate hook point
                hook_points.append(
                    {
                        "api": api.decode(),
                        "module": "kernel32.dll" if b"Get" in api else "msvcrt.dll",
                        "strategy": "return_fixed_value",
                    },
                )

        config["time_checks_found"] = time_checks_found

        # Look for date comparison patterns
        date_patterns = [
            (b"\x07\xe5", "2021"),  # Year 2021 in hex
            (b"\x07\xe6", "2022"),
            (b"\x07\xe7", "2023"),
            (b"\x07\xe8", "2024"),
            (b"\x07\xe9", "2025"),
        ]

        for pattern, year in date_patterns:
            if pattern in binary_data:
                offset = binary_data.find(pattern)
                analysis_results[f"year_{year}"] = {
                    "offset": hex(offset),
                    "description": f"Hardcoded year {year} found",
                    "severity": "critical",
                }

                # Generate patch to change year to 2099
                patches.append(
                    {
                        "offset": hex(offset),
                        "original": pattern.hex(),
                        "replacement": b"\x07\xf3".hex(),  # 2099
                        "description": f"Change year {year} to 2099",
                    },
                )

        # Generate defusal strategies based on findings
        if time_checks_found > 0:
            config["defusal_strategy"] = "comprehensive_time_bypass"

            # Add Frida script for runtime bypass
            config["frida_script"] = """
// Time Bomb Defuser Script
console.log('[TimeBomb] Starting time manipulation...');

// Fixed date: January 1, 2020
var fixedDate = new Date(2020, 0, 1);
var fixedTick = 1000000;

// Hook GetSystemTime
Interceptor.attach(Module.findExportByName('kernel32.dll', 'GetSystemTime'), {
    onEnter: function(args) {
        this.timePtr = args[0];
    },
    onLeave: function(retval) {
        if (this.timePtr) {
            // SYSTEMTIME structure
            this.timePtr.writeU16(2020);       // wYear
            this.timePtr.add(2).writeU16(1);   // wMonth
            this.timePtr.add(4).writeU16(1);   // wDayOfWeek
            this.timePtr.add(6).writeU16(1);   // wDay
            this.timePtr.add(8).writeU16(0);   // wHour
            this.timePtr.add(10).writeU16(0);  // wMinute
            this.timePtr.add(12).writeU16(0);  // wSecond
            this.timePtr.add(14).writeU16(0);  // wMilliseconds
            console.log('[TimeBomb] GetSystemTime spoofed to 2020-01-01');
        }
    }
});

// Hook GetTickCount
Interceptor.attach(Module.findExportByName('kernel32.dll', 'GetTickCount'), {
    onLeave: function(retval) {
        retval.replace(fixedTick);
        console.log('[TimeBomb] GetTickCount spoofed');
    }
});

// Hook time() function
var time_func = Module.findExportByName('msvcrt.dll', 'time');
if (time_func) {
    Interceptor.attach(time_func, {
        onLeave: function(retval) {
            var fixedTime = Math.floor(fixedDate.getTime() / 1000);
            retval.replace(ptr(fixedTime));
            console.log('[TimeBomb] time() spoofed');
        }
    });
}
"""

        # Add recommendations
        if time_checks_found > 3:
            recommendations.append("Multiple time checks detected - comprehensive bypass recommended")

        if any("critical" in result.get("severity", "") for result in analysis_results.values() if isinstance(result, dict)):
            recommendations.append("Critical time bomb detected - immediate patching required")

        if patches:
            recommendations.append(f"Apply {len(patches)} binary patches for permanent fix")

        recommendations.extend(
            [
                "Use Frida script for runtime bypass without modifying binary",
                "Consider system date manipulation as alternative approach",
                "Monitor for additional time checks during runtime",
            ],
        )

    except Exception as e:
        logger.exception("Time bomb analysis failed: %s", e)
        config["error"] = str(e)
        recommendations = config["recommendations"]
        assert isinstance(recommendations, list)
        recommendations.append("Manual analysis required")

    logger.info("Found %s time checks", config["time_checks_found"])
    return config


def generate_telemetry_blocker(app_name: str) -> dict[str, Any]:
    """Generate telemetry blocking configuration.

    This function creates a comprehensive configuration to block telemetry
    and analytics data collection from applications.

    Args:
        app_name: Name of the application to block telemetry for

    Returns:
        Dictionary containing telemetry blocking configuration

    """
    logger.info("Generating telemetry blocker for: %s", app_name)

    # Common telemetry domains by application
    telemetry_domains = {
        "default": [
            "telemetry.microsoft.com",
            "telemetry.adobe.com",
            "analytics.google.com",
            "metrics.*.com",
            "tracking.*.com",
            "stats.*.com",
            "dc.services.visualstudio.com",
            "vortex.data.microsoft.com",
        ],
        "adobe": [
            "lm.licenses.adobe.com",
            "activate.adobe.com",
            "practivate.adobe.com",
            "ereg.adobe.com",
            "wip.adobe.com",
            "adobeereg.com",
            "Adobelm.com",
            "hlrcv.stage.adobe.com",
        ],
        "microsoft": [
            "telemetry.microsoft.com",
            "vortex.data.microsoft.com",
            "settings-win.data.microsoft.com",
            "watson.microsoft.com",
            "umwatson.events.data.microsoft.com",
            "sqm.microsoft.com",
        ],
        "autodesk": [
            "autodesk.com/adsk/servlet",
            "planet9.autodesk.com",
            "registeronce.autodesk.com",
            "api.autodesk.com",
        ],
    }

    # Determine which domains to block
    app_lower = app_name.lower()
    blocked_domains_list: list[str] = telemetry_domains.get("default", []).copy()

    for key, domains in telemetry_domains.items():
        if key in app_lower:
            blocked_domains_list.extend(domains)

    # Remove duplicates
    blocked_domains_list = list(set(blocked_domains_list))

    config: dict[str, Any] = {
        "application": app_name,
        "blocked_domains": blocked_domains_list,
        "blocked_ips": [],
        "firewall_rules": [],
        "hosts_entries": [],
        "dns_redirects": {},
        "implementation": {
            "hosts_file": True,
            "firewall": True,
            "dns": False,
            "proxy": False,
        },
    }

    hosts_entries = config["hosts_entries"]
    assert isinstance(hosts_entries, list)
    firewall_rules = config["firewall_rules"]
    assert isinstance(firewall_rules, list)

    # Generate hosts file entries
    for domain in blocked_domains_list:
        hosts_entries.append(f"0.0.0.0 {domain}")
        hosts_entries.append(f"::0 {domain}")  # IPv6

    # Generate firewall rules (Windows netsh format)
    firewall_rules.extend([
        {
            "name": f"Block_{app_name}_Telemetry_Out",
            "direction": "out",
            "action": "block",
            "program": f"%ProgramFiles%\\{app_name}\\*.exe",
            "command": f'netsh advfirewall firewall add rule name="Block {app_name} Telemetry" dir=out action=block program="%ProgramFiles%\\{app_name}\\*.exe" enable=yes',
        },
        {
            "name": f"Block_{app_name}_Analytics",
            "direction": "out",
            "action": "block",
            "protocol": "tcp",
            "remoteport": "443,80",
            "command": f'netsh advfirewall firewall add rule name="Block {app_name} Analytics" dir=out action=block protocol=tcp remoteport=443,80 enable=yes',
        },
    ])

    # Add domain-specific firewall rules
    for domain in blocked_domains_list[:10]:  # Limit to 10 most important
        firewall_rules.append(
            {
                "name": f"Block_{domain.replace('.', '_')}",
                "direction": "out",
                "action": "block",
                "remoteip": domain,
                "command": f'netsh advfirewall firewall add rule name="Block {domain}" dir=out action=block remoteip={domain} enable=yes',
            },
        )

    # Generate Frida script for runtime blocking
    config["frida_script"] = f"""
// Telemetry Blocking Script for {app_name}
console.log('[Telemetry] Starting telemetry blocker...');

var blocked_domains = {blocked_domains_list};

// Hook WinInet functions
try {{
    var wininet = Process.getModuleByName('wininet.dll');

    // Hook InternetConnectW
    var InternetConnectW = wininet.getExportByName('InternetConnectW');
    Interceptor.attach(InternetConnectW, {{
        onEnter: function(args) {{
            var serverName = args[1].readUtf16String();
            for (var i = 0; i < blocked_domains.length; i++) {{
                if (serverName && serverName.includes(blocked_domains[i])) {{
                    console.log('[Telemetry] Blocking connection to: ' + serverName);
                    args[1] = Memory.allocUtf16String('127.0.0.1');
                    break;
                }}
            }}
        }}
    }});

    // Hook HttpOpenRequestW
    var HttpOpenRequestW = wininet.getExportByName('HttpOpenRequestW');
    Interceptor.attach(HttpOpenRequestW, {{
        onEnter: function(args) {{
            var objectName = args[2].readUtf16String();
            if (objectName && (objectName.includes('telemetry') || objectName.includes('analytics'))) {{
                console.log('[Telemetry] Blocking HTTP request: ' + objectName);
                this.block = true;
            }}
        }},
        onLeave: function(retval) {{
            if (this.block) {{
                retval.replace(ptr(0));
            }}
        }}
    }});
}} catch (e) {{
    console.log('[Telemetry] WinInet hooks failed: ' + e);
}}

// Hook WinHTTP functions
try {{
    var winhttp = Process.getModuleByName('winhttp.dll');

    var WinHttpConnect = winhttp.getExportByName('WinHttpConnect');
    Interceptor.attach(WinHttpConnect, {{
        onEnter: function(args) {{
            var serverName = args[1].readUtf16String();
            for (var i = 0; i < blocked_domains.length; i++) {{
                if (serverName && serverName.includes(blocked_domains[i])) {{
                    console.log('[Telemetry] Blocking WinHTTP connection to: ' + serverName);
                    args[1] = Memory.allocUtf16String('127.0.0.1');
                    break;
                }}
            }}
        }}
    }});
}} catch (e) {{
    console.log('[Telemetry] WinHTTP hooks failed: ' + e);
}}

console.log('[Telemetry] Telemetry blocker active');
"""

    # Add batch script for easy setup
    config["setup_script"] = f"""@echo off
echo Setting up telemetry blocker for {app_name}...

:: Add hosts entries
echo.
echo Adding hosts file entries...
{"".join(f"echo {entry} >> %WINDIR%{chr(92)}System32{chr(92)}drivers{chr(92)}etc{chr(92)}hosts{chr(10)}" for entry in hosts_entries[:5])}

:: Add firewall rules
echo.
echo Adding firewall rules...
{chr(10).join(rule["command"] for rule in firewall_rules[:3] if isinstance(rule, dict) and "command" in rule)}

echo.
echo Telemetry blocker setup complete!
pause
"""

    # Add removal script
    config["removal_script"] = f"""@echo off
echo Removing telemetry blocker for {app_name}...

:: Remove firewall rules
{chr(10).join(f'netsh advfirewall firewall delete rule name="{rule["name"]}"' for rule in firewall_rules[:3] if isinstance(rule, dict) and "name" in rule)}

echo.
echo Telemetry blocker removed!
echo Note: Hosts file entries must be removed manually
pause
"""

    logger.info("Telemetry blocker configured with %s blocked domains", len(blocked_domains_list))
    return config


def calculate_entropy(data: bytes) -> float:
    """Calculate Shannon entropy of binary data.

    Args:
        data: Binary data to analyze

    Returns:
        Entropy value between 0 and 8

    """
    if not data:
        return 0.0

    import math

    # Count byte frequencies
    byte_counts: dict[int, int] = {}
    for byte in data:
        byte_counts[byte] = byte_counts.get(byte, 0) + 1

    # Calculate entropy
    entropy = 0.0
    data_len = len(data)

    for count in byte_counts.values():
        if count > 0:
            probability = count / data_len
            entropy -= probability * math.log2(probability)

    return min(entropy, 8.0)


# Export commonly used functions
__all__ = [
    "calculate_entropy",
    "create_custom_hook_script",
    "detect_protection_mechanisms",
    "emulate_hardware_dongle",
    "generate_bypass_strategy",
    "generate_hwid_spoof_config",
    "generate_telemetry_blocker",
    "generate_time_bomb_defuser",
    "inject_comprehensive_api_hooks",
]
