"""
Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import logging
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


def inject_comprehensive_api_hooks(app: Any, hook_types: List[str] = None) -> str:
    """
    Inject comprehensive API hooks for various protection mechanisms.

    Args:
        app: Application instance
        hook_types: List of hook types to inject

    Returns:
        Generated script content for API hooking
    """
    if hook_types is None:
        hook_types = ["hardware_id", "debugger", "time", "telemetry", "network"]

    script_lines = [
        "// Comprehensive API Hooking Script",
        "// Generated by Intellicrack Protection Utils",
        "",
        "console.log('[Intellicrack] Starting comprehensive API hooking...');",
        ""
    ]

    # Hardware ID hooks
    if "hardware_id" in hook_types:
        script_lines.extend([
            "// Hardware ID Spoofing Hooks",
            "if (Process.platform === 'windows') {",
            "    var kernel32 = Process.getModuleByName('kernel32.dll');",
            "    var advapi32 = Process.getModuleByName('advapi32.dll');",
            "",
            "    // Hook GetVolumeInformation",
            "    try {",
            "        var GetVolumeInformationW = kernel32.getExportByName('GetVolumeInformationW');",
            "        Interceptor.attach(GetVolumeInformationW, {",
            "            onEnter: function(args) {",
            "                console.log('[HWID] GetVolumeInformationW called');",
            "            },",
            "            onLeave: function(retval) {",
            "                console.log('[HWID] Spoofing volume information');",
            "                // Modify volume serial number",
            "                return retval;",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[HWID] Failed to hook GetVolumeInformationW: ' + e);",
            "    }",
            "",
            "    // Hook registry functions for hardware info",
            "    try {",
            "        var RegQueryValueExW = advapi32.getExportByName('RegQueryValueExW');",
            "        Interceptor.attach(RegQueryValueExW, {",
            "            onEnter: function(args) {",
            "                var valueName = args[1].readUtf16String();",
            "                if (valueName && (valueName.includes('ProcessorId') || valueName.includes('SystemBiosVersion'))) {",
            "                    console.log('[HWID] Registry query for hardware info: ' + valueName);",
            "                }",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[HWID] Failed to hook RegQueryValueExW: ' + e);",
            "    }",
            "}",
            ""
        ])

    # Anti-debugger hooks
    if "debugger" in hook_types:
        script_lines.extend([
            "// Anti-Debugger Hooks",
            "if (Process.platform === 'windows') {",
            "    var ntdll = Process.getModuleByName('ntdll.dll');",
            "",
            "    // Hook NtQueryInformationProcess",
            "    try {",
            "        var NtQueryInformationProcess = ntdll.getExportByName('NtQueryInformationProcess');",
            "        Interceptor.attach(NtQueryInformationProcess, {",
            "            onEnter: function(args) {",
            "                var infoClass = args[1].toInt32();",
            "                if (infoClass === 7) { // ProcessDebugPort",
            "                    console.log('[AntiDebug] ProcessDebugPort query detected');",
            "                    this.spoofDebugPort = true;",
            "                }",
            "            },",
            "            onLeave: function(retval) {",
            "                if (this.spoofDebugPort) {",
            "                    console.log('[AntiDebug] Spoofing debug port result');",
            "                    retval.replace(ptr(0)); // Return success but no debug port",
            "                }",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[AntiDebug] Failed to hook NtQueryInformationProcess: ' + e);",
            "    }",
            "",
            "    // Hook IsDebuggerPresent",
            "    try {",
            "        var IsDebuggerPresent = kernel32.getExportByName('IsDebuggerPresent');",
            "        Interceptor.attach(IsDebuggerPresent, {",
            "            onLeave: function(retval) {",
            "                console.log('[AntiDebug] IsDebuggerPresent called, returning false');",
            "                retval.replace(ptr(0)); // Always return false",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[AntiDebug] Failed to hook IsDebuggerPresent: ' + e);",
            "    }",
            "}",
            ""
        ])

    # Time manipulation hooks
    if "time" in hook_types:
        script_lines.extend([
            "// Time Manipulation Hooks",
            "if (Process.platform === 'windows') {",
            "    // Hook GetTickCount and GetTickCount64",
            "    try {",
            "        var GetTickCount = kernel32.getExportByName('GetTickCount');",
            "        Interceptor.attach(GetTickCount, {",
            "            onLeave: function(retval) {",
            "                console.log('[Time] GetTickCount called, returning modified value');",
            "                // Return a time that makes the application think it's been running longer",
            "                var spoofedTime = retval.toInt32() + 3600000; // Add 1 hour",
            "                retval.replace(ptr(spoofedTime));",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[Time] Failed to hook GetTickCount: ' + e);",
            "    }",
            "",
            "    // Hook GetSystemTime",
            "    try {",
            "        var GetSystemTime = kernel32.getExportByName('GetSystemTime');",
            "        Interceptor.attach(GetSystemTime, {",
            "            onEnter: function(args) {",
            "                console.log('[Time] GetSystemTime called');",
            "            }",
            "        });",
            "    } catch (e) {",
            "        console.log('[Time] Failed to hook GetSystemTime: ' + e);",
            "    }",
            "}",
            ""
        ])

    # Telemetry blocking hooks
    if "telemetry" in hook_types:
        script_lines.extend([
            "// Telemetry Blocking Hooks",
            "if (Process.platform === 'windows') {",
            "    var wininet = null;",
            "    try {",
            "        wininet = Process.getModuleByName('wininet.dll');",
            "    } catch (e) {",
            "        console.log('[Telemetry] wininet.dll not found');",
            "    }",
            "",
            "    if (wininet) {",
            "        // Hook InternetOpenUrl",
            "        try {",
            "            var InternetOpenUrlW = wininet.getExportByName('InternetOpenUrlW');",
            "            Interceptor.attach(InternetOpenUrlW, {",
            "                onEnter: function(args) {",
            "                    var url = args[1].readUtf16String();",
            "                    console.log('[Telemetry] InternetOpenUrl called with: ' + url);",
            "                    if (url && (url.includes('telemetry') || url.includes('analytics') || url.includes('tracking'))) {",
            "                        console.log('[Telemetry] Blocking telemetry URL: ' + url);",
            "                        this.blockRequest = true;",
            "                    }",
            "                },",
            "                onLeave: function(retval) {",
            "                    if (this.blockRequest) {",
            "                        retval.replace(ptr(0)); // Return null handle",
            "                    }",
            "                }",
            "            });",
            "        } catch (e) {",
            "            console.log('[Telemetry] Failed to hook InternetOpenUrlW: ' + e);",
            "        }",
            "    }",
            "}",
            ""
        ])

    # Network monitoring hooks
    if "network" in hook_types:
        script_lines.extend([
            "// Network Monitoring Hooks",
            "if (Process.platform === 'windows') {",
            "    var ws2_32 = null;",
            "    try {",
            "        ws2_32 = Process.getModuleByName('ws2_32.dll');",
            "    } catch (e) {",
            "        console.log('[Network] ws2_32.dll not found');",
            "    }",
            "",
            "    if (ws2_32) {",
            "        // Hook connect function",
            "        try {",
            "            var connect = ws2_32.getExportByName('connect');",
            "            Interceptor.attach(connect, {",
            "                onEnter: function(args) {",
            "                    console.log('[Network] Socket connect called');",
            "                    // Could analyze the destination address here",
            "                }",
            "            });",
            "        } catch (e) {",
            "            console.log('[Network] Failed to hook connect: ' + e);",
            "        }",
            "",
            "        // Hook send function",
            "        try {",
            "            var send = ws2_32.getExportByName('send');",
            "            Interceptor.attach(send, {",
            "                onEnter: function(args) {",
            "                    var dataPtr = args[1];",
            "                    var dataSize = args[2].toInt32();",
            "                    console.log('[Network] Data being sent, size: ' + dataSize);",
            "                }",
            "            });",
            "        } catch (e) {",
            "            console.log('[Network] Failed to hook send: ' + e);",
            "        }",
            "    }",
            "}",
            ""
        ])

    # Add completion message
    script_lines.extend([
        "console.log('[Intellicrack] API hooking setup complete');",
        "console.log('[Intellicrack] Active hooks: " + ", ".join(hook_types) + "');",
        ""
    ])

    return "\n".join(script_lines)


def detect_protection_mechanisms(binary_path: str) -> Dict[str, Any]:
    """
    Detect protection mechanisms in a binary.

    Args:
        binary_path: Path to binary file

    Returns:
        Dictionary with detected protection information
    """
    protections = {
        'packer': None,
        'obfuscation': False,
        'anti_debug': False,
        'vm_detection': False,
        'hardware_fingerprinting': False,
        'time_checks': False,
        'network_validation': False,
        'details': []
    }

    try:
        with open(binary_path, 'rb') as f:
            data = f.read(8192)  # Read first 8KB for quick analysis

        # Simple heuristic checks
        if b'UPX' in data:
            protections['packer'] = 'UPX'
            protections['details'].append('UPX packer detected')

        if b'VMProtect' in data or b'vmprotect' in data.lower():
            protections['packer'] = 'VMProtect'
            protections['details'].append('VMProtect detected')

        if b'Themida' in data or b'themida' in data.lower():
            protections['packer'] = 'Themida'
            protections['details'].append('Themida protection detected')

        # Anti-debug indicators
        debug_strings = [b'IsDebuggerPresent', b'CheckRemoteDebuggerPresent', b'NtQueryInformationProcess']
        for debug_str in debug_strings:
            if debug_str in data:
                protections['anti_debug'] = True
                protections['details'].append(f'Anti-debug API detected: {debug_str.decode()}')
                break

        # VM detection indicators
        vm_strings = [b'VMware', b'VirtualBox', b'QEMU', b'Xen']
        for vm_str in vm_strings:
            if vm_str in data:
                protections['vm_detection'] = True
                protections['details'].append(f'VM detection string found: {vm_str.decode()}')

        # Hardware fingerprinting
        hw_strings = [b'GetVolumeInformation', b'GetSystemInfo', b'GetComputerName']
        for hw_str in hw_strings:
            if hw_str in data:
                protections['hardware_fingerprinting'] = True
                protections['details'].append(f'Hardware fingerprinting API: {hw_str.decode()}')

        # Time-based checks
        time_strings = [b'GetTickCount', b'GetSystemTime', b'QueryPerformanceCounter']
        for time_str in time_strings:
            if time_str in data:
                protections['time_checks'] = True
                protections['details'].append(f'Time-based check API: {time_str.decode()}')

        # Network validation
        net_strings = [b'InternetOpen', b'HttpSendRequest', b'WinHttpOpen']
        for net_str in net_strings:
            if net_str in data:
                protections['network_validation'] = True
                protections['details'].append(f'Network validation API: {net_str.decode()}')

    except Exception as e:
        logger.debug(f"Protection detection failed: {e}")
        protections['details'].append(f'Detection error: {e}')

    return protections


def generate_bypass_strategy(protections: Dict[str, Any]) -> List[str]:
    """
    Generate bypass strategy based on detected protections.

    Args:
        protections: Protection analysis results

    Returns:
        List of recommended bypass strategies
    """
    strategies = []

    if protections.get('packer'):
        packer = protections['packer']
        strategies.append(f"Unpack {packer} protection first")

        if packer == 'UPX':
            strategies.append("Use 'upx -d' to decompress UPX packed binary")
        elif packer == 'VMProtect':
            strategies.append("Consider VMProtect-specific unpacking tools")
        elif packer == 'Themida':
            strategies.append("Use Themida unpacker or generic unpackers")

    if protections.get('anti_debug'):
        strategies.append("Implement anti-debug bypass hooks")
        strategies.append("Hook IsDebuggerPresent and NtQueryInformationProcess")
        strategies.append("Consider using hardware breakpoints instead of software breakpoints")

    if protections.get('vm_detection'):
        strategies.append("Use VM evasion techniques")
        strategies.append("Modify VM artifacts to appear as physical machine")
        strategies.append("Hook VM detection APIs")

    if protections.get('hardware_fingerprinting'):
        strategies.append("Implement hardware fingerprint spoofing")
        strategies.append("Hook GetVolumeInformation and GetSystemInfo")
        strategies.append("Use consistent fake hardware IDs")

    if protections.get('time_checks'):
        strategies.append("Implement time manipulation hooks")
        strategies.append("Hook GetTickCount and time-related APIs")
        strategies.append("Consider time acceleration techniques")

    if protections.get('network_validation'):
        strategies.append("Set up local license server emulation")
        strategies.append("Hook network APIs to redirect requests")
        strategies.append("Analyze network protocol for proper responses")

    if not any(protections.get(key) for key in ['packer', 'anti_debug', 'vm_detection', 'hardware_fingerprinting', 'time_checks', 'network_validation']):
        strategies.append("No major protections detected - standard patching may be sufficient")
        strategies.append("Focus on license validation logic analysis")

    return strategies


def create_custom_hook_script(hook_config: Dict[str, Any]) -> str:
    """
    Create a custom Frida hook script based on configuration.

    Args:
        hook_config: Hook configuration dictionary

    Returns:
        Generated Frida script
    """
    script_lines = [
        "// Custom Hook Script",
        "// Generated by Intellicrack Protection Utils",
        "",
        "console.log('[Custom] Starting custom hooks...');",
        ""
    ]

    # Process function hooks
    if 'functions' in hook_config:
        for func_config in hook_config['functions']:
            module_name = func_config.get('module', 'kernel32.dll')
            function_name = func_config.get('name')
            hook_type = func_config.get('type', 'log')  # log, block, modify

            if not function_name:
                continue

            script_lines.extend([
                f"// Hook {function_name} in {module_name}",
                "try {",
                f"    var module = Process.getModuleByName('{module_name}');",
                f"    var {function_name} = module.getExportByName('{function_name}');",
                f"    Interceptor.attach({function_name}, {{",
                "        onEnter: function(args) {",
                f"            console.log('[Custom] {function_name} called');",
            ])

            if hook_type == 'block':
                script_lines.extend([
                    "            this.block = true;",
                ])
            elif hook_type == 'modify':
                script_lines.extend([
                    "            // Custom modification logic here",
                    "            this.modify = true;",
                ])

            script_lines.extend([
                "        },",
                "        onLeave: function(retval) {",
            ])

            if hook_type == 'block':
                script_lines.extend([
                    "            if (this.block) {",
                    f"                console.log('[Custom] Blocking {function_name}');",
                    "                retval.replace(ptr(0));",
                    "            }",
                ])
            elif hook_type == 'modify':
                script_lines.extend([
                    "            if (this.modify) {",
                    f"                console.log('[Custom] Modifying {function_name} result');",
                    "                // Custom result modification here",
                    "            }",
                ])

            script_lines.extend([
                "        }",
                "    });",
                "} catch (e) {",
                f"    console.log('[Custom] Failed to hook {function_name}: ' + e);",
                "}",
                ""
            ])

    # Process memory patches
    if 'memory_patches' in hook_config:
        for patch in hook_config['memory_patches']:
            address = patch.get('address')
            original = patch.get('original', '')
            replacement = patch.get('replacement', '')

            if address:
                script_lines.extend([
                    f"// Memory patch at {address}",
                    "try {",
                    f"    var addr = ptr('{address}');",
                    f"    var originalBytes = '{original}';",
                    f"    var newBytes = '{replacement}';",
                    "    ",
                    "    // Apply memory patch",
                    "    Memory.protect(addr, newBytes.length / 2, 'rwx');",
                    "    for (var i = 0; i < newBytes.length; i += 2) {",
                    "        var byte = parseInt(newBytes.substr(i, 2), 16);",
                    "        addr.add(i / 2).writeU8(byte);",
                    "    }",
                    f"    console.log('[Custom] Applied memory patch at {address}');",
                    "} catch (e) {",
                    f"    console.log('[Custom] Failed to apply patch at {address}: ' + e);",
                    "}",
                    ""
                ])

    script_lines.extend([
        "console.log('[Custom] Custom hooks setup complete');",
        ""
    ])

    return "\n".join(script_lines)


# Export commonly used functions
__all__ = [
    'inject_comprehensive_api_hooks',
    'detect_protection_mechanisms',
    'generate_bypass_strategy',
    'create_custom_hook_script'
]
