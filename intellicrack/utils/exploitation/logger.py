"""Perform logger utilities for exploitation module.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

from __future__ import annotations

import contextlib
import json
import logging
import os
import re
import socket
import sqlite3
import struct
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from typing import Literal

_logger = logging.getLogger(__name__)
_log_lock = threading.Lock()
_db_lock = threading.Lock()
_network_lock = threading.Lock()

_SENSITIVE_PATTERNS: list[re.Pattern[str]] = [
    re.compile(r'\bpassword["\']?\s*[:=]\s*["\']?[^\s"\']+', re.IGNORECASE),
    re.compile(r'\bapi[_-]?key["\']?\s*[:=]\s*["\']?[^\s"\']+', re.IGNORECASE),
    re.compile(r"\bsk-[a-zA-Z0-9]{20,}", re.IGNORECASE),
    re.compile(r"\b\d{3}-\d{2}-\d{4}\b"),
    re.compile(r'\bsecret["\']?\s*[:=]\s*["\']?[^\s"\']+', re.IGNORECASE),
    re.compile(r'\btoken["\']?\s*[:=]\s*["\']?[^\s"\']+', re.IGNORECASE),
]

_LOG_FILE_PATH: Path | None = None
_DATABASE_PATH: Path | None = None
_SYSLOG_HOST: str = "127.0.0.1"
_SYSLOG_PORT: int = 514
_SYSLOG_FACILITY: int = 1
_db_connection: sqlite3.Connection | None = None


def _sanitize_message(message: str) -> str:
    """Sanitize sensitive data from log messages."""
    result = message
    for pattern in _SENSITIVE_PATTERNS:
        result = pattern.sub("[REDACTED]", result)
    return result


def _sanitize_context(context: dict[str, Any]) -> dict[str, Any]:
    """Sanitize sensitive data from context dictionaries."""
    sensitive_keys = {"password", "api_key", "apikey", "secret", "token", "ssn", "social_security", "credit_card", "private_key"}
    result: dict[str, Any] = {}
    for key, value in context.items():
        key_lower = key.lower().replace("-", "_")
        if any(sens in key_lower for sens in sensitive_keys):
            result[key] = "[REDACTED]"
        elif isinstance(value, str):
            result[key] = _sanitize_message(value)
        elif isinstance(value, dict):
            result[key] = _sanitize_context(value)
        else:
            result[key] = value
    return result


def _serialize_context(context: dict[str, Any]) -> str:
    """Serialize context to JSON, handling non-serializable objects."""

    def default_serializer(obj: Any) -> str:
        if hasattr(obj, "__dict__"):
            return f"<{type(obj).__name__}>"
        return str(obj)

    try:
        return json.dumps(context, default=default_serializer, separators=(",", ":"))
    except (TypeError, ValueError):
        return json.dumps({"serialization_error": True}, separators=(",", ":"))


def _write_to_file(formatted_message: str, log_file: Path | None = None) -> bool:
    """Write message to log file."""
    target_file = log_file or _LOG_FILE_PATH
    if target_file is None:
        target_file = Path(os.getcwd()) / "exploitation.log"

    try:
        with _log_lock, open(target_file, "a", encoding="utf-8") as f:
            f.write(formatted_message + "\n")
        return True
    except (OSError, PermissionError):
        return False


def _write_to_console(formatted_message: str) -> bool:
    """Write message to console."""
    try:
        print(formatted_message)
        return True
    except (OSError, ValueError):
        return False


def _level_to_syslog_severity(level: str) -> int:
    """Convert log level string to syslog severity."""
    severity_map = {
        "DEBUG": 7,
        "INFO": 6,
        "NOTICE": 5,
        "WARNING": 4,
        "ERROR": 3,
        "CRITICAL": 2,
        "ALERT": 1,
        "EMERGENCY": 0,
    }
    return severity_map.get(level.upper(), 6)


def _write_to_network(
    formatted_message: str,
    context: dict[str, Any] | None = None,
    level: str = "INFO",
) -> bool:
    """Send log message to remote syslog server via UDP RFC 5424 format.

    Args:
        formatted_message: The formatted log message to send
        context: Optional context dictionary for structured data
        level: Log level for syslog severity mapping

    Returns:
        True if message was sent successfully, False otherwise
    """
    try:
        with _network_lock:
            severity = _level_to_syslog_severity(level)
            priority = (_SYSLOG_FACILITY * 8) + severity

            timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z"
            hostname = socket.gethostname()
            app_name = "intellicrack"
            proc_id = str(os.getpid())
            msg_id = "-"

            if context:
                sd_params = " ".join(f'{k}="{str(v)[:255]}"' for k, v in context.items() if isinstance(v, (str, int, float, bool)))
                structured_data = f"[intellicrack@0 {sd_params}]" if sd_params else "-"
            else:
                structured_data = "-"

            syslog_msg = f"<{priority}>1 {timestamp} {hostname} {app_name} {proc_id} {msg_id} {structured_data} {formatted_message}"

            message_bytes = syslog_msg.encode("utf-8", errors="replace")

            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(2.0)
            try:
                sock.sendto(message_bytes, (_SYSLOG_HOST, _SYSLOG_PORT))
                return True
            finally:
                sock.close()

    except (TimeoutError, OSError):
        return False


def _init_database(db_path: Path) -> sqlite3.Connection:
    """Initialize SQLite database for log storage."""
    conn = sqlite3.connect(str(db_path), check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS exploitation_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL,
            level TEXT NOT NULL,
            message TEXT NOT NULL,
            context_json TEXT,
            created_at REAL DEFAULT (julianday('now'))
        )
    """)
    cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON exploitation_logs(timestamp)
    """)
    cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_logs_level ON exploitation_logs(level)
    """)
    conn.commit()
    return conn


def _get_db_connection() -> sqlite3.Connection | None:
    """Get or create database connection."""
    global _db_connection

    if _DATABASE_PATH is None:
        return None

    if _db_connection is None:
        try:
            _db_connection = _init_database(_DATABASE_PATH)
        except sqlite3.Error:
            return None

    return _db_connection


def _write_to_database(
    formatted_message: str,
    context: dict[str, Any] | None = None,
    level: str = "INFO",
    timestamp_str: str | None = None,
) -> bool:
    """Write log entry to SQLite database.

    Args:
        formatted_message: The formatted log message
        context: Optional context dictionary
        level: Log level string
        timestamp_str: Optional timestamp string

    Returns:
        True if write succeeded, False otherwise
    """
    try:
        with _db_lock:
            conn = _get_db_connection()
            if conn is None:
                db_path = _DATABASE_PATH or Path(os.getcwd()) / "exploitation_logs.db"
                conn = _init_database(db_path)

            ts = timestamp_str or datetime.now().isoformat()
            context_json = json.dumps(context) if context else None

            cursor = conn.cursor()
            cursor.execute(
                """INSERT INTO exploitation_logs
                   (timestamp, level, message, context_json)
                   VALUES (?, ?, ?, ?)""",
                (ts, level.upper(), formatted_message, context_json),
            )
            conn.commit()
            return True

    except sqlite3.Error:
        return False


def log_message(
    message: str,
    level: str = "INFO",
    *,
    context: dict[str, Any] | None = None,
    destination: str = "file",
    timestamp: bool = True,
    sanitize: bool = True,
    log_file: Path | str | None = None,
) -> bool:
    """Log an exploitation message with optional context.

    Provides comprehensive logging for security research workflows with
    support for multiple destinations, context tracking, and sanitization.

    Args:
        message: The log message to record
        level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        context: Optional dictionary with additional context information
        destination: Output destination (file, console, network, database)
        timestamp: Whether to include timestamp in output
        sanitize: Whether to sanitize sensitive data
        log_file: Optional specific log file path

    Returns:
        True if logging succeeded, False otherwise
    """
    try:
        level_upper = level.upper() if isinstance(level, str) else str(level)

        if sanitize:
            safe_message = _sanitize_message(message)
            safe_context = _sanitize_context(context) if context else None
        else:
            safe_message = message
            safe_context = context

        if timestamp:
            ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            formatted = f"[{ts}] [{level_upper}] {safe_message}"
        else:
            ts = None
            formatted = f"[{level_upper}] {safe_message}"

        if safe_context:
            context_str = _serialize_context(safe_context)
            formatted = f"{formatted} | context={context_str}"

        log_file_path = Path(log_file) if log_file else None

        if destination == "file":
            return _write_to_file(formatted, log_file_path)
        elif destination == "console":
            return _write_to_console(formatted)
        elif destination == "network":
            return _write_to_network(formatted, safe_context, level_upper)
        elif destination == "database":
            return _write_to_database(formatted, safe_context, level_upper, ts)
        else:
            return _write_to_file(formatted, log_file_path)

    except Exception:
        return False


def configure_logging(
    log_file: Path | str | None = None,
    database_path: Path | str | None = None,
    syslog_host: str | None = None,
    syslog_port: int | None = None,
    syslog_facility: int | None = None,
) -> None:
    """Configure global logging settings.

    Args:
        log_file: Default log file path
        database_path: Database path for database logging
        syslog_host: Remote syslog server hostname/IP
        syslog_port: Remote syslog server port
        syslog_facility: Syslog facility code (0-23)
    """
    global _LOG_FILE_PATH, _DATABASE_PATH, _SYSLOG_HOST, _SYSLOG_PORT, _SYSLOG_FACILITY

    if log_file:
        _LOG_FILE_PATH = Path(log_file)
    if database_path:
        _DATABASE_PATH = Path(database_path)
    if syslog_host:
        _SYSLOG_HOST = syslog_host
    if syslog_port:
        _SYSLOG_PORT = syslog_port
    if syslog_facility is not None:
        _SYSLOG_FACILITY = syslog_facility


def get_log_file_path() -> Path | None:
    """Get the current log file path."""
    return _LOG_FILE_PATH


def close_database() -> None:
    """Close the database connection if open."""
    global _db_connection
    if _db_connection is not None:
        with contextlib.suppress(sqlite3.Error):
            _db_connection.close()
        _db_connection = None
