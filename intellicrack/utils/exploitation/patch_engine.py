"""Real binary patching engine for defeating software licensing protections.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
"""

import hashlib
import logging
import os
import shutil
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class BinaryPatchEngine:
    """Real binary patching engine for defeating licensing protections."""

    def __init__(self):
        """Initialize the patch engine with x86/x64 instruction sets."""
        # x86/x64 instruction opcodes for patching
        self.instructions = {
            "nop": b"\x90",  # No operation
            "ret": b"\xc3",  # Return
            "jmp": b"\xeb",  # Short jump
            "jmp_long": b"\xe9",  # Near jump
            "xor_eax_eax": b"\x31\xc0",  # XOR EAX, EAX (return 0)
            "mov_eax_1": b"\xb8\x01\x00\x00\x00",  # MOV EAX, 1 (return success)
            "mov_eax_0": b"\xb8\x00\x00\x00\x00",  # MOV EAX, 0 (return failure)
            "push_ebp": b"\x55",  # Function prologue
            "pop_ebp": b"\x5d",  # Function epilogue
        }

        # Conditional jump conversions for bypassing checks
        self.jmp_conversions = {
            0x74: 0xEB,  # JE -> JMP (always jump)
            0x75: 0xEB,  # JNE -> JMP
            0x76: 0xEB,  # JBE -> JMP
            0x77: 0xEB,  # JA -> JMP
            0x78: 0xEB,  # JS -> JMP
            0x79: 0xEB,  # JNS -> JMP
            0x7A: 0xEB,  # JP -> JMP
            0x7B: 0xEB,  # JNP -> JMP
            0x7C: 0xEB,  # JL -> JMP
            0x7D: 0xEB,  # JGE -> JMP
            0x7E: 0xEB,  # JLE -> JMP
            0x7F: 0xEB,  # JG -> JMP
        }

        # Long conditional jumps (0F 8x)
        self.long_jmp_conversions = {
            b"\x0f\x84": b"\xe9",  # JE -> JMP
            b"\x0f\x85": b"\xe9",  # JNE -> JMP
            b"\x0f\x86": b"\xe9",  # JBE -> JMP
            b"\x0f\x87": b"\xe9",  # JA -> JMP
            b"\x0f\x88": b"\xe9",  # JS -> JMP
            b"\x0f\x89": b"\xe9",  # JNS -> JMP
            b"\x0f\x8a": b"\xe9",  # JP -> JMP
            b"\x0f\x8b": b"\xe9",  # JNP -> JMP
            b"\x0f\x8c": b"\xe9",  # JL -> JMP
            b"\x0f\x8d": b"\xe9",  # JGE -> JMP
            b"\x0f\x8e": b"\xe9",  # JLE -> JMP
            b"\x0f\x8f": b"\xe9",  # JG -> JMP
        }

    def apply_patches(self, binary_path: str, patches: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Apply patches to binary to defeat licensing protections.

        Args:
            binary_path: Path to target binary
            patches: List of patch configurations

        Returns:
            Dict with patching results
        """
        result = {
            "success": False,
            "binary_path": binary_path,
            "patches_applied": 0,
            "patches_failed": 0,
            "backup_created": False,
            "details": [],
        }

        try:
            # Verify file exists
            if not os.path.exists(binary_path):
                result["error"] = f"Binary not found: {binary_path}"
                return result

            # Create backup
            backup_path = f"{binary_path}.backup"
            if not os.path.exists(backup_path):
                shutil.copy2(binary_path, backup_path)
                result["backup_created"] = True
                result["backup_path"] = backup_path
                logger.info(f"Backup created: {backup_path}")

            # Read binary
            with open(binary_path, "rb") as f:
                binary_data = bytearray(f.read())

            original_hash = hashlib.sha256(bytes(binary_data)).hexdigest()
            result["original_hash"] = original_hash

            # Apply each patch
            for patch in patches:
                patch_result = self._apply_single_patch(binary_data, patch)
                result["details"].append(patch_result)

                if patch_result["success"]:
                    result["patches_applied"] += 1
                else:
                    result["patches_failed"] += 1

            # Write patched binary
            if result["patches_applied"] > 0:
                with open(binary_path, "wb") as f:
                    f.write(binary_data)

                patched_hash = hashlib.sha256(bytes(binary_data)).hexdigest()
                result["patched_hash"] = patched_hash
                result["success"] = True

                logger.info(f"Applied {result['patches_applied']} patches to {binary_path}")

        except Exception as e:
            result["error"] = str(e)
            logger.error(f"Patching failed: {e}")

        return result

    def _apply_single_patch(self, binary_data: bytearray, patch: Dict[str, Any]) -> Dict[str, Any]:
        """Apply a single patch to the binary data.

        Args:
            binary_data: Binary data to patch
            patch: Patch configuration

        Returns:
            Patch result dict
        """
        result = {
            "success": False,
            "offset": patch.get("offset", 0),
            "type": patch.get("type", "direct"),
            "description": patch.get("description", ""),
        }

        try:
            offset = patch["offset"]
            patch_type = patch.get("type", "direct")

            # Validate offset
            if offset < 0 or offset >= len(binary_data):
                result["error"] = f"Invalid offset: {hex(offset)}"
                return result

            # Apply patch based on type
            if patch_type == "nop":
                # NOP out instructions
                size = patch.get("size", 1)
                binary_data[offset : offset + size] = self.instructions["nop"] * size
                result["bytes_patched"] = size

            elif patch_type == "ret":
                # Force early return
                binary_data[offset] = self.instructions["ret"][0]
                # NOP remaining bytes if specified
                if "size" in patch and patch["size"] > 1:
                    for i in range(1, patch["size"]):
                        binary_data[offset + i] = self.instructions["nop"][0]
                result["bytes_patched"] = patch.get("size", 1)

            elif patch_type == "jmp":
                # Convert conditional jump to unconditional
                current_byte = binary_data[offset]

                # Check if it's a short conditional jump
                if current_byte in self.jmp_conversions:
                    binary_data[offset] = self.jmp_conversions[current_byte]
                    result["conversion"] = f"{hex(current_byte)} -> {hex(self.jmp_conversions[current_byte])}"
                    result["bytes_patched"] = 1

                # Check for long conditional jump
                elif offset + 1 < len(binary_data):
                    two_bytes = bytes(binary_data[offset : offset + 2])
                    if two_bytes in self.long_jmp_conversions:
                        # Replace with unconditional jump
                        binary_data[offset : offset + 1] = self.long_jmp_conversions[two_bytes]
                        # Adjust the offset byte
                        binary_data[offset + 5] = self.instructions["nop"][0]
                        result["conversion"] = "Long jump converted"
                        result["bytes_patched"] = 6

            elif patch_type == "success":
                # Patch to always return success (1/true)
                mov_success = self.instructions["mov_eax_1"]
                binary_data[offset : offset + len(mov_success)] = mov_success
                # Add return if specified
                if patch.get("add_ret", False):
                    binary_data[offset + len(mov_success)] = self.instructions["ret"][0]
                result["bytes_patched"] = len(mov_success) + (1 if patch.get("add_ret") else 0)

            elif patch_type == "bypass_check":
                # Complex bypass - replace function with success return
                # MOV EAX, 1
                # RET
                bypass_code = self.instructions["mov_eax_1"] + self.instructions["ret"]
                binary_data[offset : offset + len(bypass_code)] = bypass_code
                # NOP remaining bytes
                size = patch.get("size", len(bypass_code))
                if size > len(bypass_code):
                    nop_count = size - len(bypass_code)
                    binary_data[offset + len(bypass_code) : offset + size] = self.instructions["nop"] * nop_count
                result["bytes_patched"] = size

            elif patch_type == "direct":
                # Direct byte replacement
                new_bytes = patch.get("bytes", b"")
                if isinstance(new_bytes, str):
                    new_bytes = bytes.fromhex(new_bytes)
                binary_data[offset : offset + len(new_bytes)] = new_bytes
                result["bytes_patched"] = len(new_bytes)

            elif patch_type == "pattern":
                # Find and replace pattern
                pattern = patch.get("pattern", b"")
                replacement = patch.get("replacement", b"")
                if isinstance(pattern, str):
                    pattern = bytes.fromhex(pattern)
                if isinstance(replacement, str):
                    replacement = bytes.fromhex(replacement)

                # Search for pattern near offset
                search_range = patch.get("search_range", 0x100)
                start = max(0, offset - search_range)
                end = min(len(binary_data), offset + search_range)

                search_area = bytes(binary_data[start:end])
                pattern_offset = search_area.find(pattern)

                if pattern_offset != -1:
                    actual_offset = start + pattern_offset
                    binary_data[actual_offset : actual_offset + len(replacement)] = replacement
                    result["pattern_found_at"] = hex(actual_offset)
                    result["bytes_patched"] = len(replacement)
                else:
                    result["error"] = "Pattern not found"
                    return result

            result["success"] = True

        except Exception as e:
            result["error"] = str(e)
            logger.error(f"Patch failed: {e}")

        return result

    def find_licensing_patterns(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find common licensing check patterns in binary.

        Args:
            binary_path: Path to binary file

        Returns:
            List of found patterns with offsets
        """
        patterns = []

        # Common licensing check patterns
        check_patterns = [
            # Trial check patterns
            {
                "name": "GetSystemTime call",
                "pattern": b"\xff\x15",  # CALL DWORD PTR
                "context": b"GetSystemTime",
                "type": "trial",
            },
            {
                "name": "Days remaining check",
                "pattern": b"\x83\xf8\x1e",  # CMP EAX, 30 (30 days)
                "type": "trial",
            },
            # Registration check patterns
            {
                "name": "IsRegistered check",
                "pattern": b"\x84\xc0\x74",  # TEST AL, AL; JE
                "type": "registration",
            },
            {
                "name": "License valid check",
                "pattern": b"\x85\xc0\x74",  # TEST EAX, EAX; JE
                "type": "license",
            },
            # Serial validation patterns
            {
                "name": "Serial length check",
                "pattern": b"\x83\xf8\x10",  # CMP EAX, 16 (16 char serial)
                "type": "serial",
            },
        ]

        try:
            with open(binary_path, "rb") as f:
                binary_data = f.read()

            for check in check_patterns:
                pattern = check["pattern"]
                offset = 0
                while True:
                    offset = binary_data.find(pattern, offset)
                    if offset == -1:
                        break

                    patterns.append(
                        {
                            "offset": offset,
                            "name": check["name"],
                            "type": check["type"],
                            "pattern": pattern.hex(),
                            "context": binary_data[max(0, offset - 10) : min(len(binary_data), offset + 20)].hex(),
                        }
                    )

                    offset += len(pattern)

        except Exception as e:
            logger.error(f"Pattern search failed: {e}")

        return patterns

    def generate_patch_config(self, binary_path: str, auto_detect: bool = True) -> List[Dict[str, Any]]:
        """Generate patch configuration for binary.

        Args:
            binary_path: Path to binary
            auto_detect: Auto-detect licensing checks

        Returns:
            List of patch configurations
        """
        patches = []

        if auto_detect:
            patterns = self.find_licensing_patterns(binary_path)

            for pattern in patterns:
                if pattern["type"] == "registration":
                    # Bypass registration check
                    patches.append(
                        {
                            "offset": pattern["offset"] + 2,  # Skip TEST, patch JE
                            "type": "jmp",
                            "description": f"Bypass {pattern['name']}",
                        }
                    )
                elif pattern["type"] == "trial":
                    # Bypass trial check
                    patches.append({"offset": pattern["offset"], "type": "nop", "size": 3, "description": f"Remove {pattern['name']}"})
                elif pattern["type"] == "license":
                    # Force license valid
                    patches.append({"offset": pattern["offset"], "type": "success", "description": f"Force {pattern['name']} success"})
                elif pattern["type"] == "serial":
                    # Bypass serial check
                    patches.append({"offset": pattern["offset"], "type": "nop", "size": 3, "description": f"Bypass {pattern['name']}"})

        return patches


def run_patch_validation(binary_path: str, patches: List[Dict[str, Any]], test_mode: bool = False) -> Dict[str, Any]:
    """Apply patches to defeat software licensing protections.

    Args:
        binary_path: Path to binary file
        patches: List of patch configurations
        test_mode: If True, only validate without applying

    Returns:
        Patching results
    """
    engine = BinaryPatchEngine()

    if test_mode:
        # Just find patterns, don't apply
        patterns = engine.find_licensing_patterns(binary_path)
        return {
            "success": True,
            "binary_path": binary_path,
            "test_mode": True,
            "patterns_found": len(patterns),
            "patterns": patterns,
            "patches_validated": len(patches),
            "validation_results": patches,
        }

    # Apply patches for real
    return engine.apply_patches(binary_path, patches)


def show_analysis_results(results: Dict[str, Any], display_mode: str = "console") -> None:
    """Display patch analysis and application results.

    Args:
        results: Analysis/patching results
        display_mode: Display format
    """
    if not results:
        logger.warning("No results to display")
        return

    if display_mode == "json":
        import json

        print(json.dumps(results, indent=2))
        return

    # Console display
    print("\n" + "=" * 60)
    print("PATCH ANALYSIS RESULTS")
    print("=" * 60)

    if results.get("success"):
        print(f"✓ SUCCESS - Binary patched: {results.get('binary_path')}")
    else:
        print(f"✗ FAILED - {results.get('error', 'Unknown error')}")

    if "patches_applied" in results:
        print(f"\nPatches Applied: {results['patches_applied']}")
        print(f"Patches Failed: {results.get('patches_failed', 0)}")

    if "backup_path" in results:
        print(f"Backup Created: {results['backup_path']}")

    if "original_hash" in results and "patched_hash" in results:
        print(f"\nOriginal Hash: {results['original_hash'][:16]}...")
        print(f"Patched Hash:  {results['patched_hash'][:16]}...")

    if "details" in results:
        print("\nPatch Details:")
        for i, detail in enumerate(results["details"], 1):
            status = "✓" if detail.get("success") else "✗"
            print(f"  {status} Patch {i}: {detail.get('description', 'N/A')}")
            print(f"     Offset: {hex(detail.get('offset', 0))}")
            print(f"     Type: {detail.get('type', 'unknown')}")
            if detail.get("success"):
                print(f"     Bytes Patched: {detail.get('bytes_patched', 0)}")
            else:
                print(f"     Error: {detail.get('error', 'Unknown')}")

    print("=" * 60 + "\n")
