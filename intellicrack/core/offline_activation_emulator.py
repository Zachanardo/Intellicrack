"""Offline activation emulator for bypassing software activation mechanisms."""

import base64
import hashlib
import hmac
import json
import os
import platform
import random
import socket
import string
import struct
import subprocess
import time
import uuid
import winreg
from dataclasses import dataclass
from datetime import UTC, datetime, timedelta
from enum import Enum
from typing import Any

try:
    import defusedxml.ElementTree as ET  # noqa: N817
except ImportError:
    import xml.etree.ElementTree as ET

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC as PBKDF2

from intellicrack.handlers.wmi_handler import wmi
from intellicrack.utils.logger import log_all_methods, logger

SERIAL_NUMBER_LABEL = "Serial Number:"


class ActivationType(Enum):
    """Enumeration of offline activation types used by software licensing systems."""

    CHALLENGE_RESPONSE = "challenge_response"
    HARDWARE_LOCKED = "hardware_locked"
    LICENSE_FILE = "license_file"
    REGISTRY_BASED = "registry_based"
    PHONE_ACTIVATION = "phone_activation"
    OFFLINE_TOKEN = "offline_token"  # noqa: S105
    SIGNED_CERTIFICATE = "signed_certificate"
    REQUEST_RESPONSE = "request_response"
    FILE_BASED = "file_based"
    QR_CODE = "qr_code"
    TOKEN = "token"  # noqa: S105


class RequestFormat(Enum):
    """Activation request encoding formats."""

    XML = "xml"
    JSON = "json"
    BASE64 = "base64"
    BINARY = "binary"
    PROPRIETARY = "proprietary"


@dataclass
class HardwareProfile:
    """Hardware profile for generating activation requests."""

    cpu_id: str
    motherboard_serial: str
    disk_serial: str
    mac_addresses: list[str]
    bios_serial: str
    system_uuid: str
    volume_serial: str
    machine_guid: str


@dataclass
class ActivationRequest:
    """Activation request data structure for offline activation."""

    product_id: str
    product_version: str
    hardware_id: str
    installation_id: str
    request_code: str
    timestamp: datetime
    additional_data: dict[str, Any]


@dataclass
class ActivationResponse:
    """Activation response data structure generated by emulator."""

    activation_code: str
    license_key: str
    expiry_date: datetime | None
    features: list[str]
    hardware_locked: bool
    signature: bytes | None
    # Additional fields for exploitation version compatibility
    response_id: str | None = None
    request_id: str | None = None
    expiration: int | None = None
    restrictions: dict[str, Any] | None = None
    format: RequestFormat | None = None


@dataclass
class MachineProfile:
    """Hardware and system profile for activation (from exploitation version)."""

    machine_id: str
    cpu_id: str
    motherboard_serial: str
    disk_serial: str
    mac_address: str
    hostname: str
    username: str
    os_version: str
    install_date: int
    install_path: str
    product_version: str


@dataclass
class ExtendedActivationRequest:
    """Extended activation request data (from exploitation version)."""

    request_id: str
    product_id: str
    product_version: str
    machine_profile: MachineProfile
    serial_number: str
    timestamp: int
    signature: bytes | None = None
    encrypted: bool = False
    format: RequestFormat = RequestFormat.XML


@log_all_methods
class OfflineActivationEmulator:
    """Production-ready offline activation emulation system."""

    def __init__(self) -> None:
        """Initialize the OfflineActivationEmulator with cryptographic backend and WMI client."""
        self.backend = default_backend()
        self.wmi_client = wmi.WMI() if platform.system() == "Windows" else None
        self.activation_algorithms = self._initialize_algorithms()
        self.known_schemes = self._load_known_schemes()

    def _initialize_algorithms(self) -> dict[str, Any]:
        """Initialize known activation algorithms."""
        algorithms = {
            "microsoft": self._microsoft_activation,
            "adobe": self._adobe_activation,
            "autodesk": self._autodesk_activation,
            "vmware": self._vmware_activation,
            "matlab": self._matlab_activation,
            "solidworks": self._solidworks_activation,
            "custom_rsa": self._rsa_based_activation,
            "custom_aes": self._aes_based_activation,
            "custom_ecc": self._ecc_based_activation,
        }
        logger.debug(f"Initialized {len(algorithms)} activation algorithms.")
        return algorithms

    def _load_known_schemes(self) -> dict[str, dict]:
        """Load database of known activation schemes."""
        schemes = {
            "microsoft_office": {
                "type": ActivationType.CHALLENGE_RESPONSE,
                "algorithm": "microsoft",
                "hardware_locked": True,
                "key_length": 25,
            },
            "adobe_cc": {"type": ActivationType.LICENSE_FILE, "algorithm": "adobe", "hardware_locked": True, "file_format": "xml"},
            "autodesk": {
                "type": ActivationType.CHALLENGE_RESPONSE,
                "algorithm": "autodesk",
                "hardware_locked": True,
                "request_format": "alphanumeric",
            },
        }
        logger.debug(f"Loaded {len(schemes)} known activation schemes.")
        return schemes

    def get_hardware_profile(self) -> HardwareProfile:
        """Get actual hardware profile from system."""
        logger.debug("Retrieving CPU ID...")
        cpu_id = self._get_cpu_id()
        logger.debug(f"CPU ID: {cpu_id}")

        logger.debug("Retrieving Motherboard Serial...")
        motherboard_serial = self._get_motherboard_serial()
        logger.debug(f"Motherboard Serial: {motherboard_serial}")

        logger.debug("Retrieving Disk Serial...")
        disk_serial = self._get_disk_serial()
        logger.debug(f"Disk Serial: {disk_serial}")

        logger.debug("Retrieving MAC Addresses...")
        mac_addresses = self._get_mac_addresses()
        logger.debug(f"MAC Addresses: {mac_addresses}")

        logger.debug("Retrieving BIOS Serial...")
        bios_serial = self._get_bios_serial()
        logger.debug(f"BIOS Serial: {bios_serial}")

        logger.debug("Retrieving System UUID...")
        system_uuid = self._get_system_uuid()
        logger.debug(f"System UUID: {system_uuid}")

        logger.debug("Retrieving Volume Serial...")
        volume_serial = self._get_volume_serial()
        logger.debug(f"Volume Serial: {volume_serial}")

        logger.debug("Retrieving Machine GUID...")
        machine_guid = self._get_machine_guid()
        logger.debug(f"Machine GUID: {machine_guid}")

        profile = HardwareProfile(
            cpu_id=cpu_id,
            motherboard_serial=motherboard_serial,
            disk_serial=disk_serial,
            mac_addresses=mac_addresses,
            bios_serial=bios_serial,
            system_uuid=system_uuid,
            volume_serial=volume_serial,
            machine_guid=machine_guid,
        )
        logger.debug("Hardware profile generated.")
        return profile

    def _get_cpu_id(self) -> str:
        """Retrieve CPU identifier from system BIOS or DMI table.

        Queries WMI on Windows or dmidecode on Linux/Unix for processor ID.
        Falls back to SHA256 hash of platform processor string on failure.

        Returns:
            16-character hexadecimal CPU identifier string.

        """
        try:
            if platform.system() == "Windows" and self.wmi_client:
                for cpu in self.wmi_client.Win32_Processor():
                    return cpu.ProcessorId.strip()
            else:
                # Linux/Unix
                result = subprocess.run(["dmidecode", "-t", "processor"], capture_output=True, text=True)
                for line in result.stdout.split("\n"):
                    if "ID:" in line:
                        return line.split("ID:")[1].strip()
        except Exception as e:
            logger.debug(f"Processor ID extraction failed: {e}")

        # Fallback
        return hashlib.sha256(platform.processor().encode()).hexdigest()[:16].upper()

    def _get_motherboard_serial(self) -> str:
        """Retrieve motherboard serial number from system firmware.

        Queries WMI on Windows or dmidecode on Linux for baseboard serial number.
        Falls back to SHA256 hash of system hostname on failure.

        Returns:
            Motherboard serial number string, uppercased.

        """
        try:
            if platform.system() == "Windows" and self.wmi_client:
                for board in self.wmi_client.Win32_BaseBoard():
                    return board.SerialNumber.strip()
            else:
                result = subprocess.run(["dmidecode", "-t", "baseboard"], capture_output=True, text=True)
                for line in result.stdout.split("\n"):
                    if SERIAL_NUMBER_LABEL in line:
                        return line.split(":")[1].strip()
        except Exception as e:
            logger.debug(f"Serial number extraction failed: {e}")

        return hashlib.sha256(socket.gethostname().encode()).hexdigest()[:16].upper()

    def _get_disk_serial(self) -> str:
        """Retrieve primary disk serial number from storage device.

        Queries WMI on Windows or hdparm on Linux for physical media serial.
        Falls back to generated random serial on failure.

        Returns:
            Disk serial number string with SER prefix.

        """
        try:
            if platform.system() == "Windows" and self.wmi_client:
                for disk in self.wmi_client.Win32_PhysicalMedia():
                    if disk.SerialNumber:
                        return disk.SerialNumber.strip()
            else:
                result = subprocess.run(["hdparm", "-I", "/dev/sda"], capture_output=True, text=True)
                for line in result.stdout.split("\n"):
                    if SERIAL_NUMBER_LABEL in line:
                        return line.split(":")[1].strip()
        except Exception as e:
            logger.debug(f"Disk serial extraction failed: {e}")

        serial_length = random.randint(12, 16)  # noqa: S311
        serial_part = "".join(random.choices(string.ascii_uppercase + string.digits, k=serial_length))  # noqa: S311
        return f"SER{serial_part}"

    def _get_mac_addresses(self) -> list[str]:
        """Retrieve MAC addresses from all network interfaces.

        Queries system for active network adapter MAC addresses on Windows/Linux.
        Falls back to UUID-based MAC generation on failure.

        Returns:
            List of MAC address strings, up to 4 addresses.

        """
        macs = []
        system = platform.system()
        if system == "Windows" and self.wmi_client:
            macs = self._get_windows_macs()
        else:
            macs = self._get_non_windows_macs()

        if not macs:
            macs = self._get_fallback_mac()

        return macs[:4]  # Return up to 4 MACs

    def _get_windows_macs(self) -> list[str]:
        """Retrieve MAC addresses from Windows network adapters.

        Queries WMI for all enabled network adapter configurations and extracts
        their MAC addresses, removing colon separators for standardized format.

        Returns:
            List of MAC addresses from enabled network adapters on Windows.

        """
        macs: list[str] = []
        for nic in self.wmi_client.Win32_NetworkAdapterConfiguration(IPEnabled=True):
            if nic.MACAddress:
                macs.append(nic.MACAddress.replace(":", ""))
        return macs

    def _get_non_windows_macs(self) -> list[str]:
        """Retrieve MAC addresses from non-Windows network interfaces.

        Uses netifaces library to query network interface addresses on Unix-like
        systems, extracting link-layer addresses and standardizing their format.

        Returns:
            List of MAC addresses from all network interfaces on Unix-like systems.

        """
        macs: list[str] = []
        import netifaces

        for interface in netifaces.interfaces():
            addrs = netifaces.ifaddresses(interface)
            if netifaces.AF_LINK in addrs:
                for addr in addrs[netifaces.AF_LINK]:
                    if "addr" in addr:
                        macs.append(addr["addr"].replace(":", "").upper())
        return macs

    def _get_fallback_mac(self) -> list[str]:
        """Generate fallback MAC address from system UUID.

        When standard MAC address retrieval fails, derives a MAC address from
        the system's UUID node identifier using hexadecimal formatting.

        Returns:
            List containing a single fallback MAC address derived from system UUID.

        """
        node = uuid.getnode()
        mac = ":".join((f"{node:012X}")[i : i + 2] for i in range(0, 12, 2))
        return [mac.replace(":", "")]

    def _get_bios_serial(self) -> str:
        """Retrieve BIOS serial number from system firmware.

        Queries WMI on Windows or dmidecode on Linux for BIOS serial identifier.
        Falls back to SHA256 hash of system node name on failure.

        Returns:
            BIOS serial number string, uppercased.

        """
        try:
            if platform.system() == "Windows" and self.wmi_client:
                for bios in self.wmi_client.Win32_BIOS():
                    return bios.SerialNumber.strip()
            else:
                result = subprocess.run(["dmidecode", "-t", "bios"], capture_output=True, text=True)
                for line in result.stdout.split("\n"):
                    if SERIAL_NUMBER_LABEL in line:
                        return line.split(":")[1].strip()
        except Exception as e:
            logger.debug(f"BIOS serial extraction failed: {e}")

        return hashlib.sha256(platform.node().encode()).hexdigest()[:16].upper()

    def _get_system_uuid(self) -> str:
        """Retrieve system UUID from firmware or generate random UUID.

        Queries WMI on Windows or dmidecode on Linux for system UUID.
        Generates UUID4 on failure.

        Returns:
            System UUID string, uppercased.

        """
        try:
            if platform.system() == "Windows" and self.wmi_client:
                for system in self.wmi_client.Win32_ComputerSystemProduct():
                    return system.UUID.strip()
            else:
                result = subprocess.run(["dmidecode", "-s", "system-uuid"], capture_output=True, text=True)
                return result.stdout.strip()
        except Exception as e:
            logger.debug(f"System UUID extraction failed: {e}")

        return str(uuid.uuid4()).upper()

    def _get_volume_serial(self) -> str:
        """Retrieve system volume serial number from primary partition.

        Queries vol command on Windows or blkid on Linux for volume UUID.
        Falls back to random hash on failure.

        Returns:
            Volume serial number string, uppercased.

        """
        try:
            if platform.system() == "Windows":
                result = subprocess.run(["vol", "C:"], capture_output=True, text=True)
                for line in result.stdout.split("\n"):
                    if "Serial Number" in line:
                        return line.split()[-1]
            else:
                result = subprocess.run(["blkid", "-o", "value", "-s", "UUID", "/dev/sda1"], capture_output=True, text=True)
                return result.stdout.strip()[:8].upper()
        except Exception as e:
            logger.debug(f"Block device UUID extraction failed: {e}")

        return hashlib.sha256(os.urandom(8)).hexdigest()[:8].upper()

    def _get_machine_guid(self) -> str:
        r"""Retrieve Windows machine GUID from Registry or machine-id file.

        Queries Windows Registry HKLM\SOFTWARE\Microsoft\Cryptography on Windows.
        On Linux, reads /etc/machine-id file. Generates UUID4 on failure.

        Returns:
            Machine GUID string, uppercased.

        """
        try:
            if platform.system() == "Windows":
                with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Cryptography") as key:
                    return winreg.QueryValueEx(key, "MachineGuid")[0]
            else:
                # Linux machine-id
                with open("/etc/machine-id") as f:
                    return f.read().strip()
        except Exception as e:
            logger.debug(f"Machine ID extraction failed: {e}")

        return str(uuid.uuid4()).upper()

    def generate_hardware_id(self, profile: HardwareProfile | None = None, algorithm: str = "standard") -> str:
        """Generate hardware ID from profile."""
        logger.debug(f"Generating hardware ID using algorithm: {algorithm}")
        if not profile:
            profile = self.get_hardware_profile()
            logger.debug("Using current system hardware profile.")
        else:
            logger.debug("Using provided hardware profile.")

        if algorithm == "standard":
            logger.debug("Using standard hardware ID generation.")
            # Combine hardware components
            components = [
                profile.cpu_id,
                profile.motherboard_serial,
                profile.disk_serial,
                profile.mac_addresses[0] if profile.mac_addresses else "",
                profile.bios_serial,
            ]

            # Hash combined components
            combined = "".join(components)
            hw_hash = hashlib.sha256(combined.encode()).digest()

            # Format as hardware ID
            hw_id = base64.b32encode(hw_hash[:20]).decode("ascii").rstrip("=")

            # Add separators for readability
            formatted = "-".join([hw_id[i : i + 5] for i in range(0, len(hw_id), 5)])
            logger.debug(f"Generated standard hardware ID: {formatted}")
            return formatted

        if algorithm == "microsoft":
            logger.debug("Using Microsoft-style hardware ID generation.")
            # Microsoft-style hardware hash
            components = [
                profile.cpu_id[:8],
                profile.disk_serial[:8],
                profile.motherboard_serial[:8],
                profile.mac_addresses[0][:12] if profile.mac_addresses else "000000000000",
            ]

            # XOR components
            result = 0
            for comp in components:
                try:
                    result ^= int(comp, 16)
                except ValueError:
                    result ^= int(hashlib.sha256(comp.encode()).hexdigest()[:8], 16)

            formatted = format(result, "08X")
            logger.debug(f"Generated Microsoft-style hardware ID: {formatted}")
            return formatted

        if algorithm == "adobe":
            logger.debug("Using Adobe-style hardware ID generation.")
            # Adobe-style LEID (License Encryption ID) - using SHA256 instead of SHA1 for security
            h = hashlib.sha256()
            h.update(profile.cpu_id.encode())
            h.update(profile.motherboard_serial.encode())
            h.update(profile.system_uuid.encode())

            digest = h.hexdigest().upper()
            formatted = f"{digest[:8]}-{digest[8:12]}-{digest[12:16]}-{digest[16:20]}"
            logger.debug(f"Generated Adobe-style hardware ID: {formatted}")
            return formatted

        logger.debug("Using custom hardware ID generation.")
        # Custom algorithm
        formatted = self._custom_hardware_id(profile)
        logger.debug(f"Generated custom hardware ID: {formatted}")
        return formatted

    def _custom_hardware_id(self, profile: HardwareProfile) -> str:
        """Generate custom hardware ID using PBKDF2 key derivation.

        Creates a hardware identifier by deriving a cryptographic key from the
        system's CPU ID and motherboard serial using PBKDF2. This ID is used
        for protecting activations against hardware spoofing and cloning attacks.

        Args:
            profile: Hardware profile containing system identifiers.

        Returns:
            Base64-encoded hardware ID string derived from PBKDF2 key derivation.

        """
        # Use PBKDF2 for key derivation
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC as PBKDF2

        salt = profile.machine_guid.encode()[:16]
        password = (profile.cpu_id + profile.motherboard_serial).encode()

        try:
            kdf = PBKDF2(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=10000, backend=self.backend)
            key = kdf.derive(password)
            hw_id = base64.b64encode(key[:24]).decode("ascii")
            return hw_id
        except Exception:
            return hashlib.sha256((profile.cpu_id + profile.motherboard_serial).encode()).hexdigest()[:32]

    def generate_installation_id(self, product_id: str, hardware_id: str) -> str:
        """Generate installation ID binding product to hardware.

        Creates an installation identifier by computing HMAC-SHA256 of the
        hardware ID using the product ID as the key. This ties the license
        to specific hardware and prevents unauthorized license transfer.

        Args:
            product_id: Commercial software product identifier.
            hardware_id: System hardware identifier from current or spoofed hardware.

        Returns:
            Formatted installation ID with groups of 6 hexadecimal characters.

        """
        logger.debug(f"Generating installation ID for product '{product_id}' with hardware ID '{hardware_id}'.")
        # Combine product and hardware

        # Generate installation ID
        h = hmac.new(key=product_id.encode(), msg=hardware_id.encode(), digestmod=hashlib.sha256)

        install_id = h.hexdigest().upper()

        # Format as groups
        groups = [install_id[i : i + 6] for i in range(0, 36, 6)]
        formatted_install_id = "-".join(groups)
        logger.debug(f"Generated installation ID: {formatted_install_id}")
        return formatted_install_id

    def generate_request_code(self, installation_id: str) -> str:
        """Generate offline activation request code from installation ID.

        Transforms an installation ID into a numeric request code suitable for
        phone activation or offline activation scenarios. Converts SHA256 hash
        to decimal representation and formats in 6-digit groups.

        Args:
            installation_id: Installation identifier bound to hardware and product.

        Returns:
            Numeric request code formatted as groups of 6 digits separated by hyphens.

        """
        logger.debug(f"Generating request code for installation ID: {installation_id}")
        # Hash installation ID
        h = hashlib.sha256(installation_id.encode())

        # Convert to numeric code
        digest_int = int.from_bytes(h.digest()[:8], "big")

        # Format as request code (groups of 6 digits)
        request_code = str(digest_int)[:54]
        request_code = request_code.ljust(54, "0")

        groups = [request_code[i : i + 6] for i in range(0, 54, 6)]
        formatted_request_code = "-".join(groups)
        logger.debug(f"Generated request code: {formatted_request_code}")
        return formatted_request_code

    def generate_activation_response(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate activation response for offline activation request.

        Analyzes the activation request, detects the appropriate algorithm based
        on product ID, and generates a valid activation response including
        license key, activation code, and digital signature. Supports multiple
        commercial software activation schemes.

        Args:
            request: Activation request containing product, hardware, and request codes.
            product_key: Optional pre-generated product key; generates if None.

        Returns:
            ActivationResponse object with activation code, license key, and signature.

        """
        logger.debug(f"Generating activation response for product ID: {request.product_id}")
        # Determine activation algorithm
        algorithm = self._detect_activation_algorithm(request.product_id)
        logger.debug(f"Detected activation algorithm: {algorithm}")

        if algorithm in self.activation_algorithms:
            response = self.activation_algorithms[algorithm](request, product_key)
            logger.debug(f"Generated activation response using {algorithm} algorithm.")
            return response
        # Default activation
        response = self._default_activation(request, product_key)
        logger.debug("Generated activation response using default algorithm.")
        return response

    def _detect_activation_algorithm(self, product_id: str) -> str:
        """Detect appropriate activation algorithm from product identifier.

        Maps product identifiers to known vendor-specific activation algorithms
        (Microsoft, Adobe, Autodesk, VMware, MATLAB, SolidWorks). Falls back to
        RSA-based algorithm for unknown products.

        Args:
            product_id: Product identifier string to analyze.

        Returns:
            Algorithm identifier string for activation implementation.

        """
        product_lower = product_id.lower()

        if "microsoft" in product_lower or "office" in product_lower:
            detected_algo = "microsoft"
        elif "adobe" in product_lower:
            detected_algo = "adobe"
        elif "autodesk" in product_lower:
            detected_algo = "autodesk"
        elif "vmware" in product_lower:
            detected_algo = "vmware"
        elif "matlab" in product_lower:
            detected_algo = "matlab"
        elif "solidworks" in product_lower:
            detected_algo = "solidworks"
        else:
            detected_algo = "custom_rsa"
        logger.debug(f"Detected activation algorithm for product '{product_id}': {detected_algo}")
        return detected_algo

    def _microsoft_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate Microsoft Office activation response with MAK/KMS emulation.

        Emulates Microsoft's Multiple Activation Key (MAK) or Key Management
        Service (KMS) activation by deriving confirmation IDs from installation
        IDs using Microsoft-compatible algorithms. Produces hardware-locked
        responses with extended trial periods.

        Args:
            request: Activation request from Microsoft Office product.
            product_key: Optional pre-defined product key for Office edition.

        Returns:
            ActivationResponse with confirmation ID, license key, and expiry.

        """
        # Parse installation ID
        install_id_parts = request.installation_id.replace("-", "")

        # Generate confirmation ID
        confirmation_blocks = []

        for i in range(8):
            # Each block derived from installation ID
            block_seed = install_id_parts[i * 6 : (i + 1) * 6]

            # Transform using Microsoft-like algorithm
            value = 0
            for char in block_seed:
                value = (value * 10 + ord(char)) % 1000000

            # Apply product-specific transformation
            if product_key:
                key_value = sum(ord(c) for c in product_key)
                value = (value * key_value) % 1000000

            confirmation_blocks.append(str(value).zfill(6))

        confirmation_id = "-".join(confirmation_blocks)
        logger.debug(f"Generated Microsoft-style confirmation ID: {confirmation_id}")

        return ActivationResponse(
            activation_code=confirmation_id,
            license_key=product_key or self._generate_product_key("microsoft"),
            expiry_date=datetime.now() + timedelta(days=180),
            features=["Professional", "Enterprise"],
            hardware_locked=True,
            signature=None,
        )

    def _adobe_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate Adobe Creative Cloud activation response.

        Produces Adobe activation codes by hashing request codes with hardware
        identifiers, then formats as Adobe-compatible response codes. Generates
        signed XML license files for offline activation.

        Args:
            request: Activation request from Adobe Creative Cloud product.
            product_key: Optional pre-defined Adobe license key.

        Returns:
            ActivationResponse with Adobe-formatted code, license key, and signature.

        """
        # Generate response based on request code
        request_bytes = request.request_code.encode()

        # Adobe uses specific transformation
        h = hashlib.sha256()
        h.update(request_bytes)
        h.update(request.hardware_id.encode())

        response_hash = h.hexdigest()
        logger.debug(f"Adobe activation response hash: {response_hash}")

        # Format as Adobe response code
        response_code = response_hash[:24].upper()
        formatted = "-".join([response_code[i : i + 4] for i in range(0, 24, 4)])
        logger.debug(f"Formatted Adobe activation code: {formatted}")

        # Generate license content
        license_data = self._generate_adobe_license(request, response_code)

        return ActivationResponse(
            activation_code=formatted,
            license_key=product_key or self._generate_product_key("adobe"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=["Creative Cloud", "All Apps"],
            hardware_locked=True,
            signature=self._sign_license_data(license_data),
        )

    def _generate_adobe_license(self, request: ActivationRequest, response_code: str) -> bytes:
        """Generate Adobe Creative Cloud XML license file content.

        Creates XML license structure with product, version, serial number,
        hardware ID, activation/expiry dates, and feature list compatible with
        Adobe's offline license validation.

        Args:
            request: Activation request with product and hardware identifiers.
            response_code: Generated Adobe response/serial code.

        Returns:
            XML license file content in UTF-8 bytes format.

        """
        root = ET.Element("License")

        # Add license elements
        product = ET.SubElement(root, "Product")
        product.text = request.product_id

        version = ET.SubElement(root, "Version")
        version.text = request.product_version

        serial = ET.SubElement(root, "SerialNumber")
        serial.text = response_code

        hwid = ET.SubElement(root, "HardwareID")
        hwid.text = request.hardware_id

        activation = ET.SubElement(root, "ActivationDate")
        activation.text = datetime.now().isoformat()

        expiry = ET.SubElement(root, "ExpiryDate")
        expiry.text = (datetime.now() + timedelta(days=365)).isoformat()

        # Features
        features = ET.SubElement(root, "Features")
        for feature in ["Photoshop", "Illustrator", "Premiere", "AfterEffects"]:
            feat = ET.SubElement(features, "Feature")
            feat.text = feature

        return ET.tostring(root, encoding="utf-8")

    def _autodesk_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate Autodesk activation response with XOR-based transformation.

        Creates Autodesk AutoCAD or Inventor activation codes using XOR operations
        with magic constants derived from Autodesk's protection schemes.
        Produces hardware-locked responses for design software.

        Args:
            request: Activation request from Autodesk design software.
            product_key: Optional pre-defined Autodesk product key.

        Returns:
            ActivationResponse with Autodesk-formatted code and license key.

        """
        # Autodesk uses specific XOR-based algorithm
        request_numeric = "".join(c for c in request.request_code if c.isdigit())

        # Magic constants for Autodesk
        magic1 = 0x56789ABC
        magic2 = 0xDEF01234

        # Process request code
        request_value = int(request_numeric[:8]) if request_numeric else 0

        # Generate response
        response_value = (request_value ^ magic1) + magic2
        logger.debug(f"Autodesk activation raw response value: {response_value}")
        response_code = format(response_value, "016X")

        # Format as Autodesk activation code
        formatted = "-".join([response_code[i : i + 4] for i in range(0, 16, 4)])
        logger.debug(f"Formatted Autodesk activation code: {formatted}")

        return ActivationResponse(
            activation_code=formatted,
            license_key=product_key or self._generate_product_key("autodesk"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=["AutoCAD", "3D Modeling", "Rendering"],
            hardware_locked=True,
            signature=None,
        )

    def _vmware_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate VMware vSphere activation response.

        Creates VMware license keys by encoding hardware hash values using
        base32-compatible character sets. Produces perpetual licenses suitable
        for ESXi and vCenter deployments.

        Args:
            request: Activation request from VMware virtualization platform.
            product_key: Optional pre-defined VMware license key.

        Returns:
            ActivationResponse with perpetual VMware license code.

        """
        # VMware uses specific format
        chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"  # pragma: allowlist secret

        # Generate based on hardware ID
        hw_hash = hashlib.sha256(request.hardware_id.encode()).digest()

        activation_code = ""
        for i in range(20):
            idx = hw_hash[i] % len(chars)
            activation_code += chars[idx]
        logger.debug(f"VMware activation raw activation code: {activation_code}")

        # Format as VMware key
        formatted = "-".join([activation_code[i : i + 5] for i in range(0, 20, 5)])
        logger.debug(f"Formatted VMware activation key: {formatted}")

        return ActivationResponse(
            activation_code=formatted,
            license_key=product_key or self._generate_product_key("vmware"),
            expiry_date=None,  # Perpetual license
            features=["vSphere", "ESXi", "vCenter"],
            hardware_locked=False,
            signature=None,
        )

    def _matlab_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate MATLAB activation response with license file generation.

        Creates MathWorks MATLAB activation codes and associated license files
        using HMAC and license server emulation. Produces signed license files
        compatible with FLEXlm-based MATLAB licensing.

        Args:
            request: Activation request from MathWorks MATLAB product.
            product_key: Optional pre-defined MATLAB license key.

        Returns:
            ActivationResponse with MATLAB activation code and signed license file.

        """
        # MATLAB uses file installation key and license file

        # Generate activation key
        h = hashlib.sha256()
        h.update(request.installation_id.encode())
        h.update(request.hardware_id.encode())

        activation_hash = h.hexdigest().upper()
        logger.debug(f"MATLAB activation hash: {activation_hash}")
        activation_code = "-".join([activation_hash[i : i + 5] for i in range(0, 20, 5)])
        logger.debug(f"Formatted MATLAB activation code: {activation_code}")

        # Generate license file content
        license_content = self._generate_matlab_license(request)

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("matlab"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=["MATLAB", "Simulink", "Toolboxes"],
            hardware_locked=True,
            signature=self._sign_license_data(license_content),
        )

    def _generate_matlab_license(self, request: ActivationRequest) -> bytes:
        """Generate MATLAB FLEXlm-compatible license file content.

        Creates license file in FLEXlm format with SERVER, DAEMON, and FEATURE
        lines suitable for MATLAB offline licensing with floating-point licensing.

        Args:
            request: Activation request with product and hardware identifiers.

        Returns:
            License file content in UTF-8 bytes format.

        """
        lines = [
            "# MATLAB license file",
            f"SERVER {socket.gethostname()} {request.hardware_id} 27000",
            "USE_SERVER",
            "DAEMON MLM",
            "",
            f"FEATURE MATLAB MLM 99 {(datetime.now() + timedelta(days=365)).strftime('%d-%b-%Y')} uncounted \\",
            f"        HOSTID={request.hardware_id} \\",
            f"        ISSUED={datetime.now().strftime('%d-%b-%Y')} \\",
            f"        START={datetime.now().strftime('%d-%b-%Y')} \\",
            "        SIGN=ABCD1234EFGH5678",
        ]

        return "\n".join(lines).encode()

    def _solidworks_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate SolidWorks activation response with proprietary algorithm.

        Creates Dassault SystÃ¨mes SolidWorks activation codes using multiplication
        and modulo arithmetic on request code components. Produces hardware-locked
        responses for CAD/CAM software.

        Args:
            request: Activation request from SolidWorks CAD software.
            product_key: Optional pre-defined SolidWorks license key.

        Returns:
            ActivationResponse with SolidWorks-formatted code and license key.

        """
        # SolidWorks uses specific activation format

        # Process request code
        request_parts = request.request_code.split("-")

        # Generate response using SolidWorks algorithm
        response_parts = []
        for part in request_parts[:4]:
            # Transform each part
            value = sum(ord(c) for c in part)
            transformed = (value * 12345) % 1000000
            response_parts.append(str(transformed).zfill(6))
        logger.debug(f"SolidWorks activation response parts: {response_parts}")

        activation_code = "-".join(response_parts)
        logger.debug(f"Formatted SolidWorks activation code: {activation_code}")

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("solidworks"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=["Professional", "FEA", "CAM"],
            hardware_locked=True,
            signature=None,
        )

    def _rsa_based_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate RSA 2048-bit signature-based activation response.

        Creates cryptographic activation codes by generating RSA key pairs and
        signing activation data with PSS padding. Suitable for custom licensing
        systems using RSA cryptography.

        Args:
            request: Activation request for RSA-protected software.
            product_key: Optional pre-defined product key.

        Returns:
            ActivationResponse with RSA-signed activation code and key.

        """
        # Generate RSA key pair
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=self.backend)

        # Create activation data
        activation_data = {
            "installation_id": request.installation_id,
            "hardware_id": request.hardware_id,
            "product_id": request.product_id,
            "timestamp": datetime.now().isoformat(),
            "features": ["Premium", "Enterprise"],
        }

        # Sign activation data
        data_bytes = json.dumps(activation_data).encode()
        signature = private_key.sign(
            data_bytes, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256(),
        )

        # Generate activation code
        activation_code = base64.b64encode(signature[:32]).decode("ascii")
        logger.debug(f"Generated RSA-based activation code: {activation_code}")

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("custom"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=activation_data["features"],
            hardware_locked=True,
            signature=signature,
        )

    def _aes_based_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate AES 256-bit encryption-based activation response.

        Creates encrypted activation codes using AES-CBC mode with random
        initialization vectors. Suitable for licensing systems using symmetric
        encryption for activation protection.

        Args:
            request: Activation request for AES-encrypted licensing system.
            product_key: Optional pre-defined product key.

        Returns:
            ActivationResponse with AES-encrypted activation code.

        """
        import os

        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

        # Generate AES key from hardware ID
        key = hashlib.sha256(request.hardware_id.encode()).digest()

        # Create activation data
        activation_data = f"{request.installation_id}:{datetime.now().timestamp()}"

        # Encrypt activation data
        iv = os.urandom(16)
        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=self.backend)
        encryptor = cipher.encryptor()

        # Pad data to 16 bytes
        padded_data = activation_data.ljust((len(activation_data) // 16 + 1) * 16)
        encrypted = encryptor.update(padded_data.encode()) + encryptor.finalize()

        # Create activation code
        activation_code = base64.b64encode(iv + encrypted[:32]).decode("ascii")
        logger.debug(f"Generated AES-based activation code: {activation_code}")

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("custom"),
            expiry_date=datetime.now() + timedelta(days=180),
            features=["Standard"],
            hardware_locked=True,
            signature=None,
        )

    def _ecc_based_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate ECDSA P-256 signature-based activation response.

        Creates elliptic curve cryptography-based activation codes using
        ECDSA with SHA256 hashing. Suitable for modern licensing systems
        using efficient elliptic curve signatures.

        Args:
            request: Activation request for ECDSA-protected software.
            product_key: Optional pre-defined product key.

        Returns:
            ActivationResponse with ECDSA-signed activation code.

        """
        from cryptography.hazmat.primitives.asymmetric import ec

        # Generate ECC key pair
        private_key = ec.generate_private_key(ec.SECP256R1(), backend=self.backend)

        # Create activation message
        message = f"{request.installation_id}:{request.hardware_id}".encode()

        # Sign message
        signature = private_key.sign(message, ec.ECDSA(hashes.SHA256()))

        # Create activation code from signature
        activation_code = base64.b32encode(signature[:30]).decode("ascii").rstrip("=")
        logger.debug(f"Generated ECC-based activation code: {activation_code}")

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("custom"),
            expiry_date=datetime.now() + timedelta(days=365),
            features=["Professional"],
            hardware_locked=True,
            signature=signature,
        )

    def _default_activation(self, request: ActivationRequest, product_key: str | None = None) -> ActivationResponse:
        """Generate default activation response for unrecognized products.

        Provides fallback activation mechanism using SHA256-based code generation
        when a specific product algorithm cannot be detected. Suitable for reverse
        engineering unknown licensing schemes.

        Args:
            request: Activation request from unrecognized product.
            product_key: Optional pre-defined product key.

        Returns:
            ActivationResponse with hash-based activation code.

        """
        # Simple hash-based activation
        h = hashlib.sha256()
        h.update(request.installation_id.encode())
        h.update(request.request_code.encode())
        h.update(request.hardware_id.encode())

        activation_hash = h.hexdigest()
        activation_code = "-".join([activation_hash[i : i + 8] for i in range(0, 32, 8)])
        logger.debug(f"Generated default activation code: {activation_code}")

        return ActivationResponse(
            activation_code=activation_code,
            license_key=product_key or self._generate_product_key("default"),
            expiry_date=datetime.now() + timedelta(days=90),
            features=["Basic"],
            hardware_locked=True,
            signature=None,
        )

    def _generate_product_key(self, product_type: str) -> str:
        """Generate product license key matching vendor format specifications.

        Creates product keys in format-specific patterns for major vendors including
        Microsoft (25 alphanumeric), Adobe (24 numeric), and Autodesk (11 digit).
        Keys are cryptographically random and follow standard commercial patterns.

        Args:
            product_type: Vendor identifier (microsoft, adobe, autodesk, or custom).

        Returns:
            Formatted license key string matching specified product vendor pattern.

        """
        if product_type == "microsoft":
            # Microsoft format: 5 groups of 5 chars (BCDFG-HJKMP-QRTVW-XY234-6789B)
            chars = "BCDFGHJKMPQRTVWXY2346789"  # pragma: allowlist secret
            key_parts = []
            for _ in range(5):
                part = "".join(random.choices(chars, k=5))  # noqa: S311
                key_parts.append(part)
            return "-".join(key_parts)

        if product_type == "adobe":
            # Adobe format: 1234-5678-9012-3456-7890-1234
            key_parts = []
            for _ in range(6):
                part = str(random.randint(0, 9999)).zfill(4)  # noqa: S311
                key_parts.append(part)
            return "-".join(key_parts)

        if product_type == "autodesk":
            # Autodesk format: 123-45678901
            part1 = str(random.randint(100, 999))  # noqa: S311
            part2 = str(random.randint(10000000, 99999999))  # noqa: S311
            return f"{part1}-{part2}"

        # Generic format
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"  # pragma: allowlist secret
        key = "".join(random.choices(chars, k=25))  # noqa: S311
        formatted_key = "-".join([key[i : i + 5] for i in range(0, 25, 5)])
        logger.debug(f"Generated generic product key: {formatted_key}")
        return formatted_key

    def _sign_license_data(self, data: bytes) -> bytes:
        """Sign license data using RSA 2048-bit private key with PSS padding.

        Generates cryptographic signatures for license files using RSA
        private key operations with PSS padding and SHA256 hashing. Creates
        verifiable digital signatures for offline license files.

        Args:
            data: License file data in bytes format (XML, JSON, or binary).

        Returns:
            RSA PSS signature bytes suitable for license file embedding.

        """
        # Generate signing key
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=self.backend)

        # Sign data
        signature = private_key.sign(
            data, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256(),
        )

        return signature

    def create_license_file(self, response: ActivationResponse, format: str = "xml") -> bytes:
        """Create offline license file in XML, JSON, binary, or text format.

        Generates license files compatible with various commercial licensing
        systems from activation response data. Supports multiple output formats
        for maximum compatibility with different license verification mechanisms.

        Args:
            response: Activation response containing license and activation codes.
            format: Output format (xml, json, binary, or text).

        Returns:
            License file data in bytes format ready for deployment.

        """
        logger.debug(f"Creating license file in format: {format}")
        if format == "xml":
            return self._create_xml_license(response)
        if format == "json":
            return self._create_json_license(response)
        if format == "binary":
            return self._create_binary_license(response)
        return self._create_text_license(response)

    def _create_xml_license(self, response: ActivationResponse) -> bytes:
        """Create XML-formatted license file with digital signature.

        Generates XML license file containing activation codes, features,
        hardware lock status, and digital signature. Compatible with
        commercial licensing systems that use XML-based license files.

        Args:
            response: Activation response with license and signature data.

        Returns:
            XML license file in UTF-8 bytes format.

        """
        root = ET.Element("License")

        key = ET.SubElement(root, "LicenseKey")
        key.text = response.license_key

        activation = ET.SubElement(root, "ActivationCode")
        activation.text = response.activation_code

        if response.expiry_date:
            expiry = ET.SubElement(root, "ExpiryDate")
            expiry.text = response.expiry_date.isoformat()

        features = ET.SubElement(root, "Features")
        for feature in response.features:
            feat = ET.SubElement(features, "Feature")
            feat.text = feature

        hw_locked = ET.SubElement(root, "HardwareLocked")
        hw_locked.text = str(response.hardware_locked)

        if response.signature:
            sig = ET.SubElement(root, "Signature")
            sig.text = base64.b64encode(response.signature).decode("ascii")

        return ET.tostring(root, encoding="utf-8")

    def _create_json_license(self, response: ActivationResponse) -> bytes:
        """Create JSON-formatted license file with structured metadata.

        Generates JSON license file containing all activation response data
        in structured format. Suitable for modern licensing systems using
        JSON for configuration and license file storage.

        Args:
            response: Activation response with license data and signature.

        Returns:
            JSON license file in UTF-8 bytes format.

        """
        license_data = {
            "license_key": response.license_key,
            "activation_code": response.activation_code,
            "expiry_date": response.expiry_date.isoformat() if response.expiry_date else None,
            "features": response.features,
            "hardware_locked": response.hardware_locked,
            "signature": base64.b64encode(response.signature).decode("ascii") if response.signature else None,
        }

        return json.dumps(license_data, indent=2).encode()

    def _create_binary_license(self, response: ActivationResponse) -> bytes:
        """Create binary-format license file with packed structure.

        Generates compact binary license file using struct packing. Includes
        magic header, license key, activation code, expiry timestamp, features,
        and signature. Suitable for proprietary licensing systems.

        Args:
            response: Activation response with complete license data.

        Returns:
            Binary license file in compact packed format.

        """
        # Binary format with magic header
        data = b"LICX"  # Magic
        data += struct.pack("<I", 1)  # Version

        # License key
        key_bytes = response.license_key.encode()
        data += struct.pack("<I", len(key_bytes))
        data += key_bytes

        # Activation code
        act_bytes = response.activation_code.encode()
        data += struct.pack("<I", len(act_bytes))
        data += act_bytes

        # Expiry timestamp
        if response.expiry_date:
            data += struct.pack("<Q", int(response.expiry_date.timestamp()))
        else:
            data += struct.pack("<Q", 0)

        # Features
        data += struct.pack("<I", len(response.features))
        for feature in response.features:
            feat_bytes = feature.encode()
            data += struct.pack("<I", len(feat_bytes))
            data += feat_bytes

        # Hardware locked flag
        data += struct.pack("<?", response.hardware_locked)

        # Signature
        if response.signature:
            data += struct.pack("<I", len(response.signature))
            data += response.signature
        else:
            data += struct.pack("<I", 0)

        return data

    def _create_text_license(self, response: ActivationResponse) -> bytes:
        """Create human-readable text format license file.

        Generates plaintext license file with readable formatting for debugging
        and manual inspection. Suitable for text-based licensing systems or
        human review of license contents.

        Args:
            response: Activation response with license information.

        Returns:
            Text format license file in UTF-8 bytes format.

        """
        lines = [
            "LICENSE INFORMATION",
            "=" * 50,
            f"License Key: {response.license_key}",
            f"Activation Code: {response.activation_code}",
            f"Hardware Locked: {response.hardware_locked}",
        ]

        if response.expiry_date:
            lines.append(f"Expiry Date: {response.expiry_date.strftime('%Y-%m-%d')}")

        lines.append("")
        lines.append("Features:")
        for feature in response.features:
            lines.append(f"  - {feature}")

        if response.signature:
            lines.append("")
            lines.append("Digital Signature:")
            sig_b64 = base64.b64encode(response.signature).decode("ascii")
            for i in range(0, len(sig_b64), 64):
                lines.append(sig_b64[i : i + 64])

        return "\n".join(lines).encode()

    def emulate_phone_activation(self, installation_id: str) -> str:
        """Generate phone activation confirmation ID from installation ID.

        Transforms installation ID into 9-group numeric confirmation code
        suitable for phone-based activation systems. Performs custom base-36
        transformation on installation ID groups and pads with random data.

        Args:
            installation_id: Installation identifier from activation request.

        Returns:
            9-group confirmation code in hyphen-separated format for phone entry.

        """
        # Convert installation ID to numeric groups
        id_numeric = "".join(c for c in installation_id if c.isalnum())

        # Generate confirmation ID using phone activation algorithm
        confirmation_groups = []

        for i in range(0, min(54, len(id_numeric)), 6):
            group = id_numeric[i : i + 6]

            # Transform group
            value = 0
            for char in group:
                if char.isdigit():
                    value = (value * 10 + int(char)) % 1000000
                else:
                    value = (value * 36 + ord(char) - ord("A") + 10) % 1000000

            confirmation_groups.append(str(value).zfill(6))

        # Ensure we have 9 groups
        while len(confirmation_groups) < 9:
            confirmation_groups.append(str(random.randint(0, 999999)).zfill(6))  # noqa: S311

        return "-".join(confirmation_groups[:9])

    def bypass_trial_restrictions(self, product_id: str) -> dict[str, Any]:
        """Generate comprehensive trial restriction bypass data package.

        Creates multi-vector trial reset data including file deletion targets,
        registry key modifications, date manipulation settings, and network
        blocking rules. Provides complete toolkit for defeating trial limitations
        and expiration checks in commercial software.

        Args:
            product_id: Commercial software product identifier to target.

        Returns:
            Dictionary containing trial reset, registry keys, license files,
            date bypass, and network bypass strategies.

        """
        logger.debug(f"Generating trial restriction bypass data for product: {product_id}")
        bypass_data = {
            "trial_reset": self._generate_trial_reset_data(product_id),
            "registry_keys": self._generate_registry_keys(product_id),
            "license_files": self._generate_license_files(product_id),
            "date_bypass": self._generate_date_bypass_data(),
            "network_bypass": self._generate_network_bypass_data(),
        }
        logger.debug(f"Generated trial bypass data: {bypass_data}")
        return bypass_data

    def _generate_trial_reset_data(self, product_id: str) -> dict[str, Any]:
        """Generate trial expiration reset payload for target product.

        Identifies Windows Registry keys and configuration files used by
        commercial software to track trial status and expiration. Provides
        deletion targets and machine ID spoofing data for trial reset attacks.

        Args:
            product_id: Target software product identifier.

        Returns:
            Dictionary with file paths, registry keys, and spoofing GUIDs.

        """
        return {
            "delete_files": [
                f"C:\\ProgramData\\{product_id}\\trial.dat",
                f"C:\\Users\\{{username}}\\AppData\\Local\\{product_id}\\license.lic",
            ],
            "registry_keys_to_delete": [
                f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\Trial",
                f"HKEY_CURRENT_USER\\SOFTWARE\\{product_id}\\FirstRun",
            ],
            "guid_to_regenerate": str(uuid.uuid4()),
            "machine_id_spoof": hashlib.sha256(os.urandom(16)).hexdigest(),
        }

    def _generate_registry_keys(self, product_id: str) -> dict[str, str]:
        """Generate Windows Registry keys for product activation emulation.

        Creates Registry entries in HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER hives
        that commercial software checks during licensing validation. Includes
        license keys, activation dates, expiration dates, and feature flags.

        Args:
            product_id: Target software product identifier.

        Returns:
            Dictionary mapping Registry paths to activation values.

        """
        return {
            f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\License": "Activated",
            f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\LicenseKey": self._generate_product_key("default"),
            f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\ActivationDate": datetime.now().isoformat(),
            f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\ExpiryDate": (datetime.now() + timedelta(days=3650)).isoformat(),
            f"HKEY_LOCAL_MACHINE\\SOFTWARE\\{product_id}\\Features": "Premium;Enterprise;Unlimited",
        }

    def _generate_license_files(self, product_id: str) -> dict[str, bytes]:
        """Generate multi-format license files for offline activation.

        Produces complete license file set in XML, JSON, binary, and text formats
        using the standard activation flow. Suitable for deploying to product
        license directories.

        Args:
            product_id: Target software product identifier.

        Returns:
            Dictionary mapping filename to license file bytes (XML, JSON, DAT, TXT).

        """
        # Generate proper activation response
        hardware_id = self.generate_hardware_id()
        installation_id = self.generate_installation_id(product_id, hardware_id)
        request_code = self.generate_request_code(installation_id)

        # Create activation request
        request = ActivationRequest(
            product_id=product_id,
            product_version="1.0",
            hardware_id=hardware_id,
            installation_id=installation_id,
            request_code=request_code,
            timestamp=datetime.now(),
            additional_data={},
        )

        # Generate proper response using the activation system
        response = self.generate_activation_response(request)

        return {
            "license.xml": self._create_xml_license(response),
            "license.json": self._create_json_license(response),
            "license.dat": self._create_binary_license(response),
            "license.txt": self._create_text_license(response),
        }

    def _generate_date_bypass_data(self) -> dict[str, Any]:
        """Generate system date manipulation tactics for trial bypass.

        Creates configuration for freezing or spoofing system time to defeat
        trial expiration checks. Includes NTP override targets and date values
        suitable for resetting trial evaluation periods.

        Returns:
            Dictionary with system time freeze dates and NTP override configuration.

        """
        from datetime import timezone
        utc_tz = UTC
        return {
            "system_time_freeze": datetime(2020, 1, 1, tzinfo=utc_tz),
            "trial_start_date": datetime(2020, 1, 1, tzinfo=utc_tz),
            "last_check_date": datetime(2020, 1, 1, tzinfo=utc_tz),
            "time_zone": "UTC",
            "ntp_server_override": "127.0.0.1",
        }

    def _generate_network_bypass_data(self) -> dict[str, Any]:
        """Generate network blocking configuration for license validation bypass.

        Creates Windows Firewall rules, hosts file entries, and proxy configurations
        to prevent software from contacting activation/licensing servers. Includes
        common activation domains for major software vendors.

        Returns:
            Dictionary with hosts entries, firewall rules, and proxy configuration.

        """
        return {
            "hosts_file_entries": [
                "127.0.0.1 activation.adobe.com",
                "127.0.0.1 lmlicenses.wip4.adobe.com",
                "127.0.0.1 lm.licenses.adobe.com",
                "127.0.0.1 validation.autodesk.com",
                "127.0.0.1 register.microsoft.com",
            ],
            "firewall_rules": [
                "Block outbound TCP 443 to *.adobe.com",
                "Block outbound TCP 443 to *.autodesk.com",
                "Block outbound TCP 443 to *.microsoft.com",
            ],
            "proxy_config": {"http": "http://127.0.0.1:8888", "https": "http://127.0.0.1:8888"},
        }

    def _generate_machine_profile(self) -> MachineProfile:
        """Generate complete machine profile for activation request generation.

        Constructs a comprehensive hardware and system profile by gathering CPU ID,
        motherboard serial, disk serial, MAC address, and OS information from
        the current system. Applies fallback mechanisms when system queries fail.
        This profile is used for crafting activation requests and bypassing
        hardware-locked activation schemes.

        Returns:
            MachineProfile object containing complete system identification data
            for activation request generation and license bypass operations.

        """
        hostname = socket.gethostname()

        # Get MAC address
        mac_address = self._generate_realistic_mac()
        try:
            import psutil

            for _interface, addrs in psutil.net_if_addrs().items():
                for addr in addrs:
                    if hasattr(psutil, "AF_LINK") and addr.family == psutil.AF_LINK:
                        mac_address = addr.address
                        break
                if mac_address != self._generate_realistic_mac():
                    break
        except (AttributeError, TypeError) as e:
            logger.debug(f"Failed to generate activation response: {e}")

        # Get disk serial
        disk_serial = self._get_disk_serial()

        # Get CPU ID
        cpu_id = self._get_cpu_id()

        # Get motherboard serial
        mb_serial = self._get_motherboard_serial()

        return MachineProfile(
            machine_id=hashlib.sha256(f"{hostname}{mac_address}".encode()).hexdigest()[:16].upper(),
            cpu_id=cpu_id,
            motherboard_serial=mb_serial,
            disk_serial=disk_serial,
            mac_address=mac_address,
            hostname=hostname,
            username=os.environ.get("USERNAME", "user"),
            os_version=platform.platform(),
            install_date=int(time.time() - 86400 * 30),  # 30 days ago
            install_path="C:\\Program Files\\Application",
            product_version="1.0.0",
        )

    def _generate_realistic_mac(self) -> str:
        """Generate MAC address using realistic manufacturer OUI prefixes.

        Constructs a MAC address by combining legitimate Organizationally Unique
        Identifier (OUI) prefixes from known hardware manufacturers with random
        device identifiers. Used for generating authentic-looking hardware profiles
        for activation request crafting and hardware-locked license bypasses.

        Returns:
            MAC address string in standard colon-separated hexadecimal format.

        """
        # Real OUI prefixes from major manufacturers
        oui_prefixes = [
            "00:1B:44",  # Cisco
            "00:50:56",  # VMware
            "00:0C:29",  # VMware
            "00:1C:42",  # Parallels
            "08:00:27",  # VirtualBox
            "AC:DE:48",  # Private
            "00:25:90",  # Dell
            "F4:CE:46",  # HP
            "00:1E:67",  # Intel
            "3C:97:0E",  # Wistron
        ]

        prefix = random.choice(oui_prefixes)  # noqa: S311
        suffix = ":".join([f"{random.randint(0, 255):02X}" for _ in range(3)])  # noqa: S311
        return f"{prefix}:{suffix}"

    def _load_product_database(self) -> dict[str, dict[str, Any]]:
        """Load database of known commercial product activation patterns.

        Provides a reference database of activation scheme characteristics for
        major commercial software products including Adobe, Autodesk, Microsoft,
        and VMware. Contains information about request formats, encryption methods,
        signature algorithms, and machine binding mechanisms used by these products.

        Returns:
            Dictionary mapping product identifiers to their activation pattern
            specifications including request format, encryption, signatures, and
            validation mechanisms.

        """
        return {
            "adobe_cc": {
                "request_format": RequestFormat.XML,
                "encryption": "AES256",
                "signature": "RSA2048",
                "machine_binding": ["cpu_id", "disk_serial"],
                "response_validation": "HMAC-SHA256",
            },
            "autodesk": {
                "request_format": RequestFormat.BASE64,
                "encryption": None,
                "signature": "ECDSA",
                "machine_binding": ["mac_address", "hostname"],
                "response_validation": "CRC32",
            },
            "microsoft": {
                "request_format": RequestFormat.XML,
                "encryption": "RSA",
                "signature": "RSA4096",
                "machine_binding": ["machine_id"],
                "response_validation": "digital_signature",
            },
            "vmware": {
                "request_format": RequestFormat.JSON,
                "encryption": None,
                "signature": "SHA256",
                "machine_binding": ["cpu_id", "mac_address"],
                "response_validation": "checksum",
            },
        }

    def generate_activation_request(self, product_id: str, serial_number: str, format: RequestFormat = RequestFormat.XML) -> str:
        """Generate offline activation request in specified format.

        Creates activation request containing product ID, machine profile, serial
        number, and request timestamp. Formats output as XML, JSON, base64, or
        binary for compatibility with various licensing server implementations.

        Args:
            product_id: Target software product identifier.
            serial_number: Software product serial number or license code.
            format: Request output format (XML, JSON, BASE64, or BINARY).

        Returns:
            Activation request string in specified format, ready for server submission.

        """
        logger.debug(f"Generating activation request for product '{product_id}' with serial '{serial_number}' in format: {format.value}")
        # Generate machine profile if not exists
        if not hasattr(self, "machine_profile"):
            self.machine_profile = self._generate_machine_profile()
            logger.debug("Generated new machine profile for activation request.")
        else:
            logger.debug("Using existing machine profile for activation request.")

        request = ExtendedActivationRequest(
            request_id=str(uuid.uuid4()),
            product_id=product_id,
            product_version=self.machine_profile.product_version,
            machine_profile=self.machine_profile,
            serial_number=serial_number,
            timestamp=int(time.time()),
            format=format,
        )
        logger.debug(f"Generated activation request ID: {request.request_id}")

        # Format based on type
        if format == RequestFormat.XML:
            return self._format_xml_request(request)
        if format == RequestFormat.JSON:
            return self._format_json_request(request)
        if format == RequestFormat.BASE64:
            return self._format_base64_request(request)
        return self._format_binary_request(request)

    def _format_xml_request(self, request: ExtendedActivationRequest) -> str:
        """Format activation request as XML with digital signature.

        Encodes activation request data into XML format with embedded RSA
        signature for tamper detection. Compatible with XML-based licensing servers.

        Args:
            request: Extended activation request containing all machine and product data.

        Returns:
            XML-formatted activation request string with signature element.

        """
        root = ET.Element("ActivationRequest")

        # Add request metadata
        ET.SubElement(root, "RequestID").text = request.request_id
        ET.SubElement(root, "ProductID").text = request.product_id
        ET.SubElement(root, "ProductVersion").text = request.product_version
        ET.SubElement(root, "SerialNumber").text = request.serial_number
        ET.SubElement(root, "Timestamp").text = str(request.timestamp)

        # Add machine profile
        machine = ET.SubElement(root, "MachineProfile")
        ET.SubElement(machine, "MachineID").text = request.machine_profile.machine_id
        ET.SubElement(machine, "CPUID").text = request.machine_profile.cpu_id
        ET.SubElement(machine, "MotherboardSerial").text = request.machine_profile.motherboard_serial
        ET.SubElement(machine, "DiskSerial").text = request.machine_profile.disk_serial
        ET.SubElement(machine, "MACAddress").text = request.machine_profile.mac_address
        ET.SubElement(machine, "Hostname").text = request.machine_profile.hostname
        ET.SubElement(machine, "Username").text = request.machine_profile.username
        ET.SubElement(machine, "OSVersion").text = request.machine_profile.os_version
        ET.SubElement(machine, "InstallDate").text = str(request.machine_profile.install_date)
        ET.SubElement(machine, "InstallPath").text = request.machine_profile.install_path

        # Sign the request
        xml_str = ET.tostring(root, encoding="unicode")
        signature = self._sign_request(xml_str.encode())
        ET.SubElement(root, "Signature").text = base64.b64encode(signature).decode()

        return ET.tostring(root, encoding="unicode")

    def _format_json_request(self, request: ExtendedActivationRequest) -> str:
        """Format activation request as JSON with RSA signature.

        Encodes activation request into JSON format with signed metadata.
        Suitable for modern licensing systems using JSON APIs.

        Args:
            request: Extended activation request with machine profile.

        Returns:
            JSON-formatted activation request string with signature field.

        """
        data = {
            "request_id": request.request_id,
            "product_id": request.product_id,
            "product_version": request.product_version,
            "serial_number": request.serial_number,
            "timestamp": request.timestamp,
            "machine_profile": {
                "machine_id": request.machine_profile.machine_id,
                "cpu_id": request.machine_profile.cpu_id,
                "motherboard_serial": request.machine_profile.motherboard_serial,
                "disk_serial": request.machine_profile.disk_serial,
                "mac_address": request.machine_profile.mac_address,
                "hostname": request.machine_profile.hostname,
                "username": request.machine_profile.username,
                "os_version": request.machine_profile.os_version,
                "install_date": request.machine_profile.install_date,
                "install_path": request.machine_profile.install_path,
            },
        }

        # Sign the request
        json_str = json.dumps(data, sort_keys=True)
        signature = self._sign_request(json_str.encode())
        data["signature"] = base64.b64encode(signature).decode()

        return json.dumps(data, indent=2)

    def _format_base64_request(self, request: ExtendedActivationRequest) -> str:
        """Format activation request as base64-encoded binary structure.

        Packs activation request into binary format using struct operations,
        appends RSA signature, and encodes result as base64. Suitable for
        binary activation protocols.

        Args:
            request: Extended activation request with packed binary data.

        Returns:
            Base64-encoded activation request with embedded signature.

        """
        # Pack data into binary format
        data = struct.pack(
            ">16s16s16s16s6s32s32s",
            request.request_id[:16].encode().ljust(16, b"\0"),
            request.product_id[:16].encode().ljust(16, b"\0"),
            request.machine_profile.machine_id[:16].encode().ljust(16, b"\0"),
            request.machine_profile.cpu_id[:16].encode().ljust(16, b"\0"),
            bytes.fromhex(request.machine_profile.mac_address.replace(":", "")),
            request.serial_number[:32].encode().ljust(32, b"\0"),
            request.machine_profile.hostname[:32].encode().ljust(32, b"\0"),
        )

        # Add timestamp
        data += struct.pack(">I", request.timestamp)

        # Sign and append signature
        signature = self._sign_request(data)
        data += signature

        # Encode to base64
        return base64.b64encode(data).decode("ascii")

    def _format_binary_request(self, request: ExtendedActivationRequest) -> str:
        """Format activation request as binary with magic header and signature.

        Constructs compact binary activation request with ACTREQ01 magic header,
        packed request ID, product hash, machine fingerprint, and RSA signature.
        Returns hex-encoded representation for transmission.

        Args:
            request: Extended activation request for binary packing.

        Returns:
            Hexadecimal string representation of binary activation request.

        """
        # Create binary packet
        packet = bytearray()

        # Header
        packet.extend(b"ACTREQ01")  # Magic + version

        # Request ID (16 bytes)
        packet.extend(uuid.UUID(request.request_id).bytes)

        # Product ID hash (32 bytes)
        packet.extend(hashlib.sha256(request.product_id.encode()).digest())

        # Machine fingerprint
        fingerprint = hashlib.sha256(
            f"{request.machine_profile.machine_id}{request.machine_profile.cpu_id}{request.machine_profile.disk_serial}".encode(),
        ).digest()
        packet.extend(fingerprint)

        # Serial number hash
        packet.extend(hashlib.sha256(request.serial_number.encode()).digest())

        # Timestamp
        packet.extend(struct.pack(">I", request.timestamp))

        # Sign the packet
        signature = self._sign_request(bytes(packet))
        packet.extend(signature)

        # Return hex representation
        return packet.hex()

    def _sign_request(self, data: bytes) -> bytes:
        """Sign activation request data using RSA 2048 private key.

        Generates RSA PSS signatures for activation request data with SHA256
        hashing. Used for tamper-proof request transmission to servers.

        Args:
            data: Raw activation request data to sign.

        Returns:
            RSA PSS signature bytes.

        """
        # Generate signing key
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())

        # Sign data
        signature = private_key.sign(
            data, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256(),
        )

        return signature

    def _generate_license_key(self, request: ExtendedActivationRequest) -> str:
        """Generate license key using PBKDF2 derivation from request data.

        Creates product license key from activation request data using PBKDF2
        with 100,000 iterations. Key format: 5-character groups separated by hyphens.

        Args:
            request: Extended activation request with product and machine identifiers.

        Returns:
            Formatted license key string derived from request cryptographic material.

        """
        # Create license data
        data = f"{request.product_id}:{request.machine_profile.machine_id}:{request.serial_number}"

        # Generate key using PBKDF2
        kdf = PBKDF2(
            algorithm=hashes.SHA256(), length=32, salt=request.machine_profile.cpu_id.encode(), iterations=100000, backend=default_backend(),
        )
        key = kdf.derive(data.encode())

        # Format as license key
        key_hex = key.hex().upper()
        formatted = "-".join(key_hex[i : i + 5] for i in range(0, 40, 5))

        return formatted

    def _generate_activation_code(self, request: ExtendedActivationRequest) -> str:
        """Generate activation code using HMAC-SHA256 from machine and serial data.

        Creates activation confirmation code by computing HMAC of machine
        identifiers using serial number as key. Format: 5-character groups.

        Args:
            request: Extended activation request with machine profile and serial.

        Returns:
            Formatted activation code string from HMAC computation.

        """
        # Combine machine identifiers
        machine_data = f"{request.machine_profile.cpu_id}{request.machine_profile.disk_serial}{request.machine_profile.mac_address}"

        # Generate activation code
        h = hmac.new(request.serial_number.encode(), machine_data.encode(), hashlib.sha256)

        code = h.hexdigest()[:20].upper()
        return "-".join(code[i : i + 4] for i in range(0, 20, 4))

    def create_activation_file(self, response: ActivationResponse, output_path: str) -> str:
        """Create encrypted activation file with magic header and AES encryption.

        Generates offline activation file by AES-encrypting activation response
        data with the license key as key material. Writes binary file with
        ACTFILE1 magic header and IV for offline deployment.

        Args:
            response: Activation response with license key and codes.
            output_path: File system path where activation file will be written.

        Returns:
            Path to created activation file.

        """
        data = {
            "version": "1.0",
            "response": {
                "id": response.response_id or str(uuid.uuid4()),
                "license_key": response.license_key,
                "activation_code": response.activation_code,
                "expiration": response.expiration or int(time.time() + 365 * 86400),
                "features": response.features,
            },
            "signature": base64.b64encode(response.signature or b"").decode(),
        }

        # Encrypt the activation data
        key = hashlib.sha256(response.license_key.encode()).digest()
        iv = os.urandom(16)

        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()

        # Pad data
        json_data = json.dumps(data).encode()
        pad_len = 16 - (len(json_data) % 16)
        json_data += bytes([pad_len] * pad_len)

        # Encrypt
        encrypted = encryptor.update(json_data) + encryptor.finalize()

        # Write file
        with open(output_path, "wb") as f:
            f.write(b"ACTFILE1")  # Magic
            f.write(iv)
            f.write(encrypted)

        return output_path

    def bypass_challenge_response(self, challenge: str) -> str:
        """Generate valid response for challenge-response activation mechanism.

        Decodes challenge data and generates cryptographically valid response
        using SHA256 hash of nonce and challenge data combined with machine
        profile identifiers. Suitable for defeating challenge-response activation.

        Args:
            challenge: Challenge string from licensing server (base64 or raw bytes).

        Returns:
            Base64-encoded response suitable for server validation.

        """
        logger.debug(f"Bypassing challenge-response for challenge: {challenge}")
        # Decode challenge
        try:
            challenge_bytes = base64.b64decode(challenge)
            logger.debug("Challenge successfully base64 decoded.")
        except (base64.binascii.Error, ValueError):
            challenge_bytes = challenge.encode()
            logger.debug("Challenge not base64 encoded, using raw bytes.")

        # Extract challenge components
        if len(challenge_bytes) >= 16:
            nonce = challenge_bytes[:16]
            data = challenge_bytes[16:]
            logger.debug(f"Extracted nonce ({nonce.hex()}) and data ({data.hex()}) from challenge.")
        else:
            nonce = challenge_bytes
            data = b""
            logger.debug(f"Challenge too short, using full challenge as nonce ({nonce.hex()}).")

        # Generate machine profile if not exists
        if not hasattr(self, "machine_profile"):
            self.machine_profile = self._generate_machine_profile()
            logger.debug("Generated new machine profile for challenge-response bypass.")
        else:
            logger.debug("Using existing machine profile for challenge-response bypass.")

        # Generate response using machine profile and challenge data
        response_data = hashlib.sha256(
            nonce + data + self.machine_profile.machine_id.encode() + self.machine_profile.cpu_id.encode(),
        ).digest()
        logger.debug(f"Generated raw response data: {response_data.hex()}")

        # Format response
        response = base64.b64encode(response_data).decode("ascii")
        logger.debug(f"Formatted challenge-response: {response}")

        return response
