"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""
Base Analyzer Class

Common functionality for vulnerability research analyzers.
"""

import logging
import time
from typing import Any

from ..shared.result_utils import ResultMixin

logger = logging.getLogger(__name__)


class BaseAnalyzer(ResultMixin):
    """Base class for vulnerability research analyzers."""

    def __init__(self):
        """Initialize the base analyzer with logging for vulnerability research."""
        self.logger = logging.getLogger(self.__class__.__name__)

    def handle_analysis_error(self, result: dict[str, Any], error: Exception, start_time: float) -> dict[str, Any]:
        """Common error handling for analysis methods.

        Args:
            result: Result dictionary to update
            error: Exception that occurred
            start_time: Analysis start time

        Returns:
            Updated result dictionary

        """
        self.logger.error(f"Analysis failed: {error}")
        result["error"] = str(error)
        result["analysis_time"] = time.time() - start_time
        return result

    def finalize_analysis_result(self, result: dict[str, Any], start_time: float,
                               success_message: str = None, count_key: str = None) -> dict[str, Any]:
        """Finalize analysis result with success status and timing.

        Args:
            result: Result dictionary to finalize
            start_time: Analysis start time
            success_message: Success message template (use {count} placeholder)
            count_key: Key in result containing count for message

        Returns:
            Finalized result dictionary

        """
        result["analysis_time"] = time.time() - start_time
        result["success"] = True

        if success_message and count_key and count_key in result:
            count = len(result[count_key]) if isinstance(result[count_key], (list, dict)) else result[count_key]
            self.logger.info(success_message.format(count=count))

        return result
