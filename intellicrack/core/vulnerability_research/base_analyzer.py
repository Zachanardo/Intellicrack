"""Base analyzer for Intellicrack vulnerability research.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import time
from typing import Any

from ..shared.result_utils import ResultMixin


"""
Base Analyzer Class

Common functionality for vulnerability research analyzers.
"""

logger = logging.getLogger(__name__)


class BaseAnalyzer(ResultMixin):
    """Base class for vulnerability research analyzers in Intellicrack.

    This class provides core functionality and utility methods for conducting
    vulnerability research and analysis across different types of binary protection
    mechanisms. It serves as a foundational component for specialized analyzer
    implementations, offering standardized error handling, logging, and result
    finalization capabilities.

    Attributes:
        logger (logging.Logger): Logging instance specific to the analyzer instance.

    Inherits from:
        ResultMixin: Provides additional result handling and tracking capabilities.

    """

    def __init__(self) -> None:
        """Initialize the base analyzer with a custom logger for vulnerability research.

        Sets up a logger with the specific class name to enable detailed,
        context-aware logging for each analyzer instance. This helps in tracking
        and debugging vulnerability research processes.
        """
        self.logger = logging.getLogger(self.__class__.__name__)

    def handle_analysis_error(
        self, result: dict[str, Any], error: Exception, start_time: float
    ) -> dict[str, Any]:
        """Standardized error handling method for vulnerability research analyses.

        This method provides a consistent approach to capturing and logging
        errors during vulnerability research and analysis processes. It updates
        the result dictionary with error details and calculates analysis time.

        Args:
            result (dict[str, Any]): Mutable result dictionary to update with error information.
            error (Exception): The exception that occurred during analysis.
            start_time (float): The timestamp when the analysis started, used to calculate total analysis time.

        Returns:
            dict[str, Any]: Updated result dictionary with error details and analysis time.

        Note:
            - Logs the error using the instance's logger
            - Adds 'error' and 'analysis_time' keys to the result dictionary
            - Helps in maintaining a consistent error reporting mechanism

        """
        self.logger.error(f"Analysis failed: {error}")
        result["error"] = str(error)
        result["analysis_time"] = time.time() - start_time
        return result

    def finalize_analysis_result(
        self,
        result: dict[str, Any],
        start_time: float,
        success_message: str = None,
        count_key: str = None,
    ) -> dict[str, Any]:
        """Finalize and standardize the result of a vulnerability research analysis.

        This method provides a uniform way to complete an analysis, marking it
        as successful, calculating total analysis time, and optionally logging
        a success message with a count of discovered items.

        Args:
            result (dict[str, Any]): Result dictionary to finalize and update.
            start_time (float): The timestamp when the analysis started.
            success_message (str, optional): A message template for logging success.
                Expects a {count} placeholder for the number of discovered items.
            count_key (str, optional): Key in the result dictionary containing
                the count of discovered items.

        Returns:
            dict[str, Any]: Finalized result dictionary with analysis time and success status.

        Note:
            - Calculates and adds 'analysis_time' to the result
            - Sets 'success' flag to True
            - Logs a success message if all conditions are met
            - Supports different count types (list, dict, or primitive)

        """
        result["analysis_time"] = time.time() - start_time
        result["success"] = True

        if success_message and count_key and count_key in result:
            count = (
                len(result[count_key])
                if isinstance(result[count_key], (list, dict))
                else result[count_key]
            )
            self.logger.info(success_message.format(count=count))

        return result
