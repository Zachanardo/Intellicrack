"""
Patch Analyzer Module

Analyzes patches and security updates to identify potential vulnerabilities
and understand the evolution of security issues.
"""

import logging
import os
import re
from datetime import datetime
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class PatchAnalyzer:
    """
    Analyzes patches and security updates to extract vulnerability information.
    """

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.PatchAnalyzer")
        self.patch_patterns = {
            'buffer_overflow': [
                r'buffer\s+overflow',
                r'stack\s+overflow',
                r'heap\s+overflow',
                r'strcpy\s*\(',
                r'sprintf\s*\(',
                r'gets\s*\('
            ],
            'format_string': [
                r'format\s+string',
                r'printf\s*\([^,]*\)',
                r'%n',
                r'%x'
            ],
            'integer_overflow': [
                r'integer\s+overflow',
                r'integer\s+wraparound',
                r'size_t\s+overflow'
            ],
            'use_after_free': [
                r'use\s+after\s+free',
                r'dangling\s+pointer',
                r'freed\s+memory'
            ],
            'race_condition': [
                r'race\s+condition',
                r'time\s+of\s+check',
                r'TOCTOU'
            ]
        }

    def analyze_patch_file(self, patch_path: str) -> Dict[str, Any]:
        """
        Analyze a patch file to extract vulnerability information.

        Args:
            patch_path: Path to the patch file

        Returns:
            Analysis results including vulnerability types and severity
        """
        try:
            if not os.path.exists(patch_path):
                return {
                    'success': False,
                    'error': f'Patch file not found: {patch_path}'
                }

            with open(patch_path, 'r', encoding='utf-8', errors='ignore') as f:
                patch_content = f.read()

            analysis = self._analyze_patch_content(patch_content)
            analysis['patch_file'] = patch_path
            analysis['success'] = True

            return analysis

        except Exception as e:
            self.logger.error(f"Failed to analyze patch file {patch_path}: {e}")
            return {
                'success': False,
                'error': str(e),
                'patch_file': patch_path
            }

    def _analyze_patch_content(self, content: str) -> Dict[str, Any]:
        """Analyze patch content for vulnerability patterns."""
        vulnerabilities = []
        severity_score = 0

        for vuln_type, patterns in self.patch_patterns.items():
            matches = []
            for pattern in patterns:
                found = re.findall(pattern, content, re.IGNORECASE)
                if found:
                    matches.extend(found)

            if matches:
                vulnerability = {
                    'type': vuln_type,
                    'matches': len(matches),
                    'confidence': min(0.9, len(matches) * 0.2),
                    'patterns_found': list(set(matches))
                }
                vulnerabilities.append(vulnerability)
                severity_score += len(matches) * 2

        # Calculate overall severity
        if severity_score >= 10:
            severity = 'critical'
        elif severity_score >= 6:
            severity = 'high'
        elif severity_score >= 3:
            severity = 'medium'
        elif severity_score > 0:
            severity = 'low'
        else:
            severity = 'none'

        return {
            'vulnerabilities': vulnerabilities,
            'vulnerability_count': len(vulnerabilities),
            'severity': severity,
            'severity_score': severity_score,
            'analysis_timestamp': datetime.now().isoformat()
        }

    def compare_patches(self, patch1_path: str, patch2_path: str) -> Dict[str, Any]:
        """
        Compare two patches to identify evolution of vulnerabilities.

        Args:
            patch1_path: Path to first patch
            patch2_path: Path to second patch

        Returns:
            Comparison results
        """
        try:
            analysis1 = self.analyze_patch_file(patch1_path)
            analysis2 = self.analyze_patch_file(patch2_path)

            if not (analysis1['success'] and analysis2['success']):
                return {
                    'success': False,
                    'error': 'Failed to analyze one or both patches'
                }

            comparison = {
                'patch1': analysis1,
                'patch2': analysis2,
                'evolution': self._compare_vulnerabilities(
                    analysis1['vulnerabilities'],
                    analysis2['vulnerabilities']
                ),
                'success': True
            }

            return comparison

        except Exception as e:
            self.logger.error(f"Failed to compare patches: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _compare_vulnerabilities(self, vulns1: List[Dict], vulns2: List[Dict]) -> Dict[str, Any]:
        """Compare vulnerability lists between patches."""
        types1 = {v['type'] for v in vulns1}
        types2 = {v['type'] for v in vulns2}

        new_vulns = types2 - types1
        fixed_vulns = types1 - types2
        persistent_vulns = types1 & types2

        return {
            'new_vulnerabilities': list(new_vulns),
            'fixed_vulnerabilities': list(fixed_vulns),
            'persistent_vulnerabilities': list(persistent_vulns),
            'trend': 'improving' if len(fixed_vulns) > len(new_vulns) else 'worsening' if len(new_vulns) > len(fixed_vulns) else 'stable'
        }

    def analyze_patch_series(self, patch_directory: str) -> Dict[str, Any]:
        """
        Analyze a series of patches in a directory.

        Args:
            patch_directory: Directory containing patch files

        Returns:
            Series analysis results
        """
        try:
            if not os.path.isdir(patch_directory):
                return {
                    'success': False,
                    'error': f'Directory not found: {patch_directory}'
                }

            patch_files = [f for f in os.listdir(patch_directory)
                          if f.endswith(('.patch', '.diff', '.txt'))]

            if not patch_files:
                return {
                    'success': False,
                    'error': 'No patch files found in directory'
                }

            # Sort patch files by name (assuming chronological order)
            patch_files.sort()

            series_analysis = {
                'patch_count': len(patch_files),
                'patches': [],
                'timeline': [],
                'vulnerability_evolution': {},
                'success': True
            }

            for patch_file in patch_files:
                patch_path = os.path.join(patch_directory, patch_file)
                analysis = self.analyze_patch_file(patch_path)

                if analysis['success']:
                    series_analysis['patches'].append(analysis)
                    series_analysis['timeline'].append({
                        'file': patch_file,
                        'vulnerability_count': analysis['vulnerability_count'],
                        'severity': analysis['severity']
                    })

            # Analyze evolution
            series_analysis['vulnerability_evolution'] = self._analyze_vulnerability_evolution(
                series_analysis['patches']
            )

            return series_analysis

        except Exception as e:
            self.logger.error(f"Failed to analyze patch series: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _analyze_vulnerability_evolution(self, patches: List[Dict]) -> Dict[str, Any]:
        """Analyze how vulnerabilities evolve across a patch series."""
        all_types = set()
        type_frequency = {}
        severity_trend = []

        for patch in patches:
            severity_trend.append(patch.get('severity_score', 0))

            for vuln in patch.get('vulnerabilities', []):
                vuln_type = vuln['type']
                all_types.add(vuln_type)
                type_frequency[vuln_type] = type_frequency.get(vuln_type, 0) + 1

        # Calculate trends
        if len(severity_trend) >= 2:
            recent_avg = sum(severity_trend[-3:]) / min(3, len(severity_trend))
            early_avg = sum(severity_trend[:3]) / min(3, len(severity_trend))
            trend = 'improving' if recent_avg < early_avg else 'worsening' if recent_avg > early_avg else 'stable'
        else:
            trend = 'insufficient_data'

        return {
            'unique_vulnerability_types': len(all_types),
            'most_common_types': sorted(type_frequency.items(), key=lambda x: x[1], reverse=True)[:5],
            'severity_trend': trend,
            'total_patches_analyzed': len(patches)
        }


__all__ = ['PatchAnalyzer']
