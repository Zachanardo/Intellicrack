"""Patch analyzer for Intellicrack vulnerability research.

This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Any


"""
Patch Analyzer Module

Analyzes patches and security updates to identify potential vulnerabilities
and understand the evolution of security issues.
"""

logger = logging.getLogger(__name__)


class PatchAnalyzer:
    """Analyzes patches and security updates to extract vulnerability information."""

    def __init__(self) -> None:
        """Initialize the patch analyzer with vulnerability patterns for patch detection."""
        self.logger = logging.getLogger("IntellicrackLogger.PatchAnalyzer")
        self.patch_patterns = {
            "buffer_overflow": [
                r"buffer\s+overflow",
                r"stack\s+overflow",
                r"heap\s+overflow",
                r"strcpy\s*\(",
                r"sprintf\s*\(",
                r"gets\s*\(",
            ],
            "format_string": [
                r"format\s+string",
                r"printf\s*\([^,]*\)",
                r"%n",
                r"%x",
            ],
            "integer_overflow": [
                r"integer\s+overflow",
                r"integer\s+wraparound",
                r"size_t\s+overflow",
            ],
            "use_after_free": [
                r"use\s+after\s+free",
                r"dangling\s+pointer",
                r"freed\s+memory",
            ],
            "race_condition": [
                r"race\s+condition",
                r"time\s+of\s+check",
                r"TOCTOU",
            ],
        }

    def analyze_patch_file(self, patch_path: str) -> dict[str, Any]:
        """Analyze a patch file to extract vulnerability information.

        Args:
            patch_path: Path to the patch file

        Returns:
            Analysis results including vulnerability types and severity

        """
        try:
            if not os.path.exists(patch_path):
                return {
                    "success": False,
                    "error": f"Patch file not found: {patch_path}",
                }

            with open(patch_path, encoding="utf-8", errors="ignore") as f:
                patch_content = f.read()

            analysis = self._analyze_patch_content(patch_content)
            analysis["patch_file"] = patch_path
            analysis["success"] = True

            return analysis

        except Exception as e:
            self.logger.exception("Failed to analyze patch file %s: %s", patch_path, e)
            return {
                "success": False,
                "error": str(e),
                "patch_file": patch_path,
            }

    def _analyze_patch_content(self, content: str) -> dict[str, Any]:
        """Analyze patch content for vulnerability patterns."""
        vulnerabilities = []
        severity_score = 0

        for vuln_type, patterns in self.patch_patterns.items():
            matches = []
            for pattern in patterns:
                if found := re.findall(pattern, content, re.IGNORECASE):
                    matches.extend(found)

            if matches:
                vulnerability = {
                    "type": vuln_type,
                    "matches": len(matches),
                    "confidence": min(0.9, len(matches) * 0.2),
                    "patterns_found": list(set(matches)),
                }
                vulnerabilities.append(vulnerability)
                severity_score += len(matches) * 2

        # Calculate overall severity
        if severity_score >= 10:
            severity = "critical"
        elif severity_score >= 6:
            severity = "high"
        elif severity_score >= 3:
            severity = "medium"
        elif severity_score > 0:
            severity = "low"
        else:
            severity = "none"

        return {
            "vulnerabilities": vulnerabilities,
            "vulnerability_count": len(vulnerabilities),
            "severity": severity,
            "severity_score": severity_score,
            "analysis_timestamp": datetime.now().isoformat(),
        }

    def compare_patches(self, patch1_path: str, patch2_path: str) -> dict[str, Any]:
        """Compare two patches to identify evolution of vulnerabilities.

        Args:
            patch1_path: Path to first patch
            patch2_path: Path to second patch

        Returns:
            Comparison results

        """
        try:
            analysis1 = self.analyze_patch_file(patch1_path)
            analysis2 = self.analyze_patch_file(patch2_path)

            if not (analysis1["success"] and analysis2["success"]):
                return {
                    "success": False,
                    "error": "Failed to analyze one or both patches",
                }

            return {
                "patch1": analysis1,
                "patch2": analysis2,
                "evolution": self._compare_vulnerabilities(
                    analysis1["vulnerabilities"],
                    analysis2["vulnerabilities"],
                ),
                "success": True,
            }
        except Exception as e:
            self.logger.exception("Failed to compare patches: %s", e)
            return {
                "success": False,
                "error": str(e),
            }

    def _compare_vulnerabilities(self, vulns1: list[dict[str, Any]], vulns2: list[dict[str, Any]]) -> dict[str, Any]:
        """Compare vulnerability lists between patches."""
        types1 = {v["type"] for v in vulns1}
        types2 = {v["type"] for v in vulns2}

        new_vulns = types2 - types1
        fixed_vulns = types1 - types2
        persistent_vulns = types1 & types2

        return {
            "new_vulnerabilities": list(new_vulns),
            "fixed_vulnerabilities": list(fixed_vulns),
            "persistent_vulnerabilities": list(persistent_vulns),
            "trend": "improving" if len(fixed_vulns) > len(new_vulns) else "worsening" if len(new_vulns) > len(fixed_vulns) else "stable",
        }

    def analyze_patch_series(self, patch_directory: str) -> dict[str, Any]:
        """Analyze a series of patches in a directory.

        Args:
            patch_directory: Directory containing patch files

        Returns:
            Series analysis results

        """
        try:
            if not Path(patch_directory).is_dir():
                return {
                    "success": False,
                    "error": f"Directory not found: {patch_directory}",
                }

            patch_files = [f for f in os.listdir(patch_directory) if f.endswith((".patch", ".diff", ".txt"))]

            if not patch_files:
                return {
                    "success": False,
                    "error": "No patch files found in directory",
                }

            # Sort patch files by name (assuming chronological order)
            patch_files.sort()

            series_analysis: dict[str, Any] = {
                "patch_count": len(patch_files),
                "patches": [],
                "timeline": [],
                "vulnerability_evolution": {},
                "success": True,
            }

            patches_list: list[dict[str, Any]] = []
            timeline_list: list[dict[str, Any]] = []

            for patch_file in patch_files:
                patch_path = os.path.join(patch_directory, patch_file)
                analysis = self.analyze_patch_file(patch_path)

                if analysis.get("success", False):
                    patches_list.append(analysis)
                    timeline_list.append(
                        {
                            "file": patch_file,
                            "vulnerability_count": analysis.get("vulnerability_count", 0),
                            "severity": analysis.get("severity", "unknown"),
                        },
                    )

            series_analysis["patches"] = patches_list
            series_analysis["timeline"] = timeline_list

            # Analyze evolution
            series_analysis["vulnerability_evolution"] = self._analyze_vulnerability_evolution(
                patches_list,
            )

            return series_analysis

        except Exception as e:
            self.logger.exception("Failed to analyze patch series: %s", e)
            return {
                "success": False,
                "error": str(e),
            }

    def _analyze_vulnerability_evolution(self, patches: list[dict[str, Any]]) -> dict[str, Any]:
        """Analyze how vulnerabilities evolve across a patch series."""
        all_types: set[str] = set()
        type_frequency: dict[str, int] = {}
        severity_trend: list[int] = []

        for patch in patches:
            severity_score_val = patch.get("severity_score", 0)
            if isinstance(severity_score_val, int):
                severity_trend.append(severity_score_val)

            vulnerabilities_list = patch.get("vulnerabilities", [])
            if isinstance(vulnerabilities_list, list):
                for vuln in vulnerabilities_list:
                    if isinstance(vuln, dict):
                        vuln_type = vuln.get("type", "")
                        if isinstance(vuln_type, str):
                            all_types.add(vuln_type)
                            type_frequency[vuln_type] = type_frequency.get(vuln_type, 0) + 1

        # Calculate trends
        if len(severity_trend) >= 2:
            recent_avg = sum(severity_trend[-3:]) / min(3, len(severity_trend))
            early_avg = sum(severity_trend[:3]) / min(3, len(severity_trend))
            trend = "improving" if recent_avg < early_avg else "worsening" if recent_avg > early_avg else "stable"
        else:
            trend = "insufficient_data"

        return {
            "unique_vulnerability_types": len(all_types),
            "most_common_types": sorted(type_frequency.items(), key=lambda x: x[1], reverse=True)[:5],
            "severity_trend": trend,
            "total_patches_analyzed": len(patches),
        }


__all__ = ["PatchAnalyzer"]
