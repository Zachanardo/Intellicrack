"""
Advanced Vulnerability Detection Engine 

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""


import logging
import re
from typing import Any, Dict, List

# Third-party imports
try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

# Configure module logger
logger = logging.getLogger(__name__)


# Import shared entropy calculation
from ...utils.protection_utils import calculate_entropy


class AdvancedVulnerabilityEngine:
    """
    Comprehensive vulnerability detection and analysis framework
    """

    # Class logger for all AdvancedVulnerabilityEngine methods
    logger = logging.getLogger('Intellicrack.AdvancedVulnerabilityEngine')

    @classmethod
    def scan_binary(cls, binary_path: str) -> List[Dict[str, Any]]:
        """
        Comprehensive multi-stage binary vulnerability scanning.

        Performs a series of vulnerability checks on the binary including import table analysis,
        section analysis, export table analysis, weak crypto detection, and licensing weakness
        detection. Each check is executed in sequence to build a complete vulnerability profile.

        Args:
            cls: Class reference
            binary_path: Path to the binary file to scan

        Returns:
            list: Collection of detected vulnerabilities, each represented as a dictionary
                 with details about the vulnerability type, location, and severity
        """
        vulnerabilities = []

        if not PEFILE_AVAILABLE:
            cls.logger.error("pefile library not available, cannot scan PE binaries")
            return vulnerabilities

        try:
            # Use pefile for in-depth PE file analysis
            pe = pefile.PE(binary_path, fast_load=False)

            # Comprehensive vulnerability checks
            vulnerability_checks = [
                cls._analyze_import_table,
                cls._analyze_sections,
                cls._analyze_export_table,
                cls._detect_weak_crypto,
                cls._detect_licensing_weaknesses
            ]

            # Run all vulnerability checks
            for _check in vulnerability_checks:
                vulnerabilities.extend(_check(pe, binary_path))

        except (OSError, ValueError, RuntimeError) as e:
            cls.logger.error("Comprehensive binary scanning error: %s", e)

        return vulnerabilities

    @staticmethod
    def _analyze_import_table(pe, _binary_path: str) -> List[Dict[str, Any]]:  # pylint: disable=unused-argument
        """
        Advanced import table vulnerability analysis.

        Examines the binary's import table for potentially dangerous API calls that might
        indicate security weaknesses or licensing vulnerabilities. Categorizes imports into
        risk categories including system execution, memory manipulation, crypto weakness,
        and network risk.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected import-related vulnerabilities with risk categorization
        """
        vulnerabilities = []

        # Comprehensive dangerous import keywords
        dangerous_imports = {
            'system_execution': [
                'system', 'exec', 'shellexecute', 'createprocess',
                'winexec', 'loadlibrary'
            ],
            'memory_manipulation': [
                'virtualalloc', 'virtualprotect', 'writeprocessmemory',
                'readprocessmemory'
            ],
            'crypto_weakness': [
                'crypt', 'decrypt', 'encrypt', 'hash', 'md5', 'sha1'
            ],
            'network_risk': [
                'connect', 'send', 'recv', 'wsasend', 'wsarecv',
                'internetopen', 'httpsendrequestw'
            ]
        }

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            import_entries = getattr(pe, 'DIRECTORY_ENTRY_IMPORT', [])
            for _entry in import_entries:
                for _imp in _entry.imports:
                    try:
                        func_name = _imp.name.decode(
                            'utf-8', errors='ignore').lower()

                        for risk_category, keywords in dangerous_imports.items():
                            if any(
                                    _keyword in func_name for _keyword in keywords):
                                vulnerabilities.append({
                                    'type': 'import_vulnerability',
                                    'risk_category': risk_category,
                                    'function': func_name,
                                    'module': _entry.dll.decode('utf-8', errors='ignore'),
                                    'severity': 'high'
                                })
                    except (OSError, ValueError, RuntimeError) as e:
                        logger.warning("Import analysis error: %s", e)

        return vulnerabilities

    @classmethod
    def _analyze_sections(cls, pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced section-level vulnerability analysis.

        Analyzes each section in the PE file for suspicious characteristics including:
        - High entropy sections (potential encryption/obfuscation)
        - Sections with dangerous permission combinations (executable + writable)
        - Unusual section characteristics that may indicate protection mechanisms

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected section-related vulnerabilities with details about each issue
        """
        cls.logger.debug("Analyzing sections for binary: %s", binary_path)
        vulnerabilities = []

        for _section in pe.sections:
            section_data = _section.get_data()
            entropy = calculate_entropy(section_data)
            section_name = _section.Name.decode(
                'utf-8', errors='ignore').strip('\x00')

            # High entropy sections might indicate packed/encrypted code
            if entropy > 7.0:
                vulnerabilities.append({
                    'type': 'high_entropy_section',
                    'section_name': section_name,
                    'entropy': entropy,
                    'risk': 'Potential Obfuscation/Packing'
                })

            # Check section permissions
            characteristics = _section.Characteristics
            is_executable = bool(characteristics & 0x20000000)
            is_writable = bool(characteristics & 0x80000000)

            cls.logger.debug(f"Section '{section_name}': Entropy={entropy}, Executable={is_executable}, Writable={is_writable}")

            if is_executable and is_writable:
                vulnerabilities.append({
                    'type': 'section_permission_vulnerability',
                    'section_name': section_name,
                    'risk': 'Executable and Writable Section'
                })

        cls.logger.info("Found %d section-related vulnerabilities.", len(vulnerabilities))
        return vulnerabilities

    @staticmethod
    def _analyze_export_table(pe, binary_path: str) -> List[Dict[str, Any]]:  # pylint: disable=unused-argument
        """
        Advanced export table vulnerability analysis.

        Examines the binary's export table for sensitive function names that might
        reveal licensing mechanisms, authentication routines, or other security-critical
        components. Identifies exports that could be targeted for patching or hooking.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected export-related vulnerabilities with details about each sensitive export
        """
        vulnerabilities = []

        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for _exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if _exp.name:
                    try:
                        func_name = _exp.name.decode('utf-8', errors='ignore')

                        # Sensitive export detection
                        sensitive_patterns = [
                            'license', 'auth', 'crypt', 'validate',
                            'check', 'verify', 'admin', 'key'
                        ]

                        for _pattern in sensitive_patterns:
                            if _pattern in func_name.lower():
                                vulnerabilities.append({
                                    'type': 'export_vulnerability',
                                    'function': func_name,
                                    'risk': 'Potential Information Disclosure'
                                })
                    except (OSError, ValueError, RuntimeError) as e:
                        logger.warning("Export analysis error: %s", e)

        return vulnerabilities

    @staticmethod
    def _detect_weak_crypto(pe, binary_path: str) -> List[Dict[str, Any]]:  # pylint: disable=unused-argument
        """
        Advanced cryptographic weakness detection.

        Scans the binary for indicators of weak cryptographic implementations including:
        - Hardcoded cryptographic keys or hashes (MD5/SHA1)
        - Base64-encoded secrets
        - References to outdated or vulnerable encryption algorithms
        - Patterns suggesting improper cryptographic usage

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected cryptographic weaknesses with details about each issue
        """
        vulnerabilities = []

        try:
            with open(binary_path, 'rb') as f:
                binary_data = f.read()

            # Enhanced crypto weakness patterns
            weak_crypto_patterns = [
                # MD5/SHA1 hash representations
                rb'[0-9a-f]{32}',  # MD5
                rb'[0-9a-f]{40}',  # SHA1

                # Base64/weak encoding patterns
                rb'([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)',

                # Potential encryption/decryption keywords
                rb'decrypt', rb'encrypt', rb'key', rb'cipher',
                rb'aes', rb'des', rb'rsa', rb'xor'
            ]

            for _pattern in weak_crypto_patterns:
                matches = list(re.finditer(
                    _pattern, binary_data, re.IGNORECASE))
                for _match in matches[:5]:  # Limit matches
                    vulnerabilities.append({
                        'type': 'crypto_weakness',
                        'pattern': _pattern.decode('utf-8', errors='ignore'),
                        'offset': f'0x{_match.start():X}',
                        'risk': 'Potential Cryptographic Vulnerability'
                    })

        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Crypto weakness detection error: %s", e)

        return vulnerabilities

    @staticmethod
    def _detect_licensing_weaknesses(pe, binary_path: str) -> List[Dict[str, Any]]:  # pylint: disable=unused-argument
        """
        Advanced licensing-specific weakness detection.

        Performs targeted analysis to identify licensing mechanisms and potential
        weaknesses in license validation routines. Searches for patterns related to:
        - License keys and validation
        - Trial period implementations
        - Activation mechanisms
        - Registration routines
        - Serial number verification

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected licensing weaknesses with details about each vulnerability
        """
        vulnerabilities = []

        try:
            with open(binary_path, 'rb') as f:
                binary_data = f.read()

            # Enhanced licensing-related patterns
            license_patterns = [
                rb'licen[cs]e',
                rb'trial',
                rb'expire',
                rb'activation',
                rb'serial',
                rb'key\s*valid',
                rb'registration',
                rb'check\s*license',
                rb'validate\s*key'
            ]

            for _pattern in license_patterns:
                matches = list(re.finditer(
                    _pattern, binary_data, re.IGNORECASE))
                for _match in matches[:5]:  # Limit matches
                    vulnerabilities.append({
                        'type': 'licensing_weakness',
                        'pattern': _pattern.decode('utf-8', errors='ignore'),
                        'offset': f'0x{_match.start():X}',
                        'risk': 'High Potential for License Bypass'
                    })

        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Licensing weakness detection error: %s", e)

        return vulnerabilities

    @classmethod
    def generate_exploit_strategy(cls, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Advanced exploit strategy generation.

        Analyzes detected vulnerabilities and generates targeted exploitation strategies
        based on vulnerability types. Maps each vulnerability to appropriate bypass techniques
        including function hijacking, memory manipulation, license bypass, and cryptographic
        bypass approaches.

        Args:
            cls: Class reference
            vulnerabilities: List of vulnerability dictionaries from previous scanning steps

        Returns:
            list: Exploitation strategies with detailed descriptions and techniques for each
                 vulnerability, prioritized by effectiveness
        """
        cls.logger.info("Generating exploit strategies for %d vulnerabilities.", len(vulnerabilities))
        strategies = []

        exploit_mapping = {
            'import_vulnerability': {
                'strategy': 'function_hijacking',
                'description': 'Intercept and modify critical imported functions',
                'technique': 'Replace function implementation to bypass checks'},
            'high_entropy_section': {
                'strategy': 'memory_manipulation',
                'description': 'Inject alternative code into high-entropy sections',
                'technique': 'Modify obfuscated/packed code regions'},
            'licensing_weakness': {
                'strategy': 'license_bypass',
                'description': 'Direct manipulation of license validation logic',
                'technique': 'Patch or modify license checking mechanisms'},
            'crypto_weakness': {
                'strategy': 'cryptographic_bypass',
                'description': 'Exploit weak cryptographic implementations',
                'technique': 'Circumvent or fake cryptographic validation'}}

        for _vuln in vulnerabilities:
            strategy = exploit_mapping.get(_vuln['type'], {
                'strategy': 'generic_bypass',
                'description': 'Generic exploit strategy',
                'technique': 'Attempt to bypass protection mechanism'
            })

            strategy['source_vulnerability'] = _vuln
            strategies.append(strategy)
            cls.logger.debug("Generated strategy for vuln type '%s': %s", _vuln['type'], strategy['strategy'])

        cls.logger.info("Generated %d exploit strategies.", len(strategies))
        return strategies


class VulnerabilityReport:
    """
    Vulnerability analysis reporting utilities
    """

    @staticmethod
    def generate_report(vulnerabilities: List[Dict[str, Any]], binary_path: str) -> Dict[str, Any]:
        """Generate a comprehensive vulnerability report"""
        report = {
            'binary_path': binary_path,
            'total_vulnerabilities': len(vulnerabilities),
            'vulnerability_types': {},
            'severity_breakdown': {'high': 0, 'medium': 0, 'low': 0},
            'vulnerabilities': vulnerabilities,
            'recommendations': []
        }

        # Analyze vulnerability types
        for _vuln in vulnerabilities:
            vuln_type = _vuln.get('type', 'unknown')
            report['vulnerability_types'][vuln_type] = report['vulnerability_types'].get(vuln_type, 0) + 1

            # Count severity levels
            severity = _vuln.get('severity', 'medium')
            if severity in report['severity_breakdown']:
                report['severity_breakdown'][severity] += 1

        # Generate recommendations
        if report['vulnerability_types'].get('licensing_weakness', 0) > 0:
            report['recommendations'].append('Consider implementing stronger license validation mechanisms')

        if report['vulnerability_types'].get('crypto_weakness', 0) > 0:
            report['recommendations'].append('Review cryptographic implementations for hardcoded keys or weak algorithms')

        if report['vulnerability_types'].get('high_entropy_section', 0) > 0:
            report['recommendations'].append('High entropy sections detected - verify packing/obfuscation is intentional')

        return report


# Export classes and functions
__all__ = [
    'AdvancedVulnerabilityEngine',
    'VulnerabilityReport',
    'calculate_entropy'
]
