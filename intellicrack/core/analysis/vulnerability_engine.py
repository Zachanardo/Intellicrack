"""
Advanced Vulnerability Detection Engine

This module provides comprehensive vulnerability detection and analysis capabilities
for binary analysis and security research. It includes advanced static analysis,
cryptographic weakness detection, and exploit strategy generation.
"""

import logging
import math
import re
from collections import Counter
from typing import Dict, List, Any, Optional

# Third-party imports
try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

# Configure module logger
logger = logging.getLogger(__name__)


def calculate_entropy(data: bytes) -> float:
    """
    Calculates Shannon entropy of given data.
    Higher values (>7.0) typically indicate encryption, compression, or obfuscation.

    Args:
        data: Binary data (bytes or bytearray)

    Returns:
        float: Shannon entropy value between 0 and 8
    """
    if not data:
        return 0

    entropy = 0
    counter = Counter(bytearray(data))
    data_len = len(data)

    for count in counter.values():
        probability = count / data_len
        entropy -= probability * math.log2(probability)

    return entropy


class AdvancedVulnerabilityEngine:
    """
    Comprehensive vulnerability detection and analysis framework
    """

    # Class logger for all AdvancedVulnerabilityEngine methods
    logger = logging.getLogger('Intellicrack.AdvancedVulnerabilityEngine')

    @classmethod
    def scan_binary(cls, binary_path: str) -> List[Dict[str, Any]]:
        """
        Comprehensive multi-stage binary vulnerability scanning.

        Performs a series of vulnerability checks on the binary including import table analysis,
        section analysis, export table analysis, weak crypto detection, and licensing weakness
        detection. Each check is executed in sequence to build a complete vulnerability profile.

        Args:
            cls: Class reference
            binary_path: Path to the binary file to scan

        Returns:
            list: Collection of detected vulnerabilities, each represented as a dictionary
                 with details about the vulnerability type, location, and severity
        """
        vulnerabilities = []

        if not PEFILE_AVAILABLE:
            cls.logger.error("pefile library not available, cannot scan PE binaries")
            return vulnerabilities

        try:
            # Use pefile for in-depth PE file analysis
            pe = pefile.PE(binary_path, fast_load=False)

            # Comprehensive vulnerability checks
            vulnerability_checks = [
                cls._analyze_import_table,
                cls._analyze_sections,
                cls._analyze_export_table,
                cls._detect_weak_crypto,
                cls._detect_licensing_weaknesses
            ]

            # Run all vulnerability checks
            for check in vulnerability_checks:
                vulnerabilities.extend(check(pe, binary_path))

        except Exception as e:
            cls.logger.error(f"Comprehensive binary scanning error: {e}")

        return vulnerabilities

    @staticmethod
    def _analyze_import_table(pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced import table vulnerability analysis.

        Examines the binary's import table for potentially dangerous API calls that might
        indicate security weaknesses or licensing vulnerabilities. Categorizes imports into
        risk categories including system execution, memory manipulation, crypto weakness,
        and network risk.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected import-related vulnerabilities with risk categorization
        """
        vulnerabilities = []

        # Comprehensive dangerous import keywords
        dangerous_imports = {
            'system_execution': [
                'system', 'exec', 'shellexecute', 'createprocess',
                'winexec', 'loadlibrary'
            ],
            'memory_manipulation': [
                'virtualalloc', 'virtualprotect', 'writeprocessmemory',
                'readprocessmemory'
            ],
            'crypto_weakness': [
                'crypt', 'decrypt', 'encrypt', 'hash', 'md5', 'sha1'
            ],
            'network_risk': [
                'connect', 'send', 'recv', 'wsasend', 'wsarecv',
                'internetopen', 'httpsendrequestw'
            ]
        }

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            import_entries = getattr(pe, 'DIRECTORY_ENTRY_IMPORT', [])
            for entry in import_entries:
                for imp in entry.imports:
                    try:
                        func_name = imp.name.decode(
                            'utf-8', errors='ignore').lower()

                        for risk_category, keywords in dangerous_imports.items():
                            if any(
                                    keyword in func_name for keyword in keywords):
                                vulnerabilities.append({
                                    'type': 'import_vulnerability',
                                    'risk_category': risk_category,
                                    'function': func_name,
                                    'module': entry.dll.decode('utf-8', errors='ignore'),
                                    'severity': 'high'
                                })
                    except Exception as e:
                        logger.warning(f"Import analysis error: {e}")

        return vulnerabilities

    @classmethod
    def _analyze_sections(cls, pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced section-level vulnerability analysis.

        Analyzes each section in the PE file for suspicious characteristics including:
        - High entropy sections (potential encryption/obfuscation)
        - Sections with dangerous permission combinations (executable + writable)
        - Unusual section characteristics that may indicate protection mechanisms

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected section-related vulnerabilities with details about each issue
        """
        cls.logger.debug(f"Analyzing sections for binary: {binary_path}")
        vulnerabilities = []

        for section in pe.sections:
            section_data = section.get_data()
            entropy = calculate_entropy(section_data)
            section_name = section.Name.decode(
                'utf-8', errors='ignore').strip('\x00')

            # High entropy sections might indicate packed/encrypted code
            if entropy > 7.0:
                vulnerabilities.append({
                    'type': 'high_entropy_section',
                    'section_name': section_name,
                    'entropy': entropy,
                    'risk': 'Potential Obfuscation/Packing'
                })

            # Check section permissions
            characteristics = section.Characteristics
            is_executable = bool(characteristics & 0x20000000)
            is_writable = bool(characteristics & 0x80000000)

            cls.logger.debug(f"Section '{section_name}': Entropy={entropy}, Executable={is_executable}, Writable={is_writable}")

            if is_executable and is_writable:
                vulnerabilities.append({
                    'type': 'section_permission_vulnerability',
                    'section_name': section_name,
                    'risk': 'Executable and Writable Section'
                })

        cls.logger.info(f"Found {len(vulnerabilities)} section-related vulnerabilities.")
        return vulnerabilities

    @staticmethod
    def _analyze_export_table(pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced export table vulnerability analysis.

        Examines the binary's export table for sensitive function names that might
        reveal licensing mechanisms, authentication routines, or other security-critical
        components. Identifies exports that could be targeted for patching or hooking.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected export-related vulnerabilities with details about each sensitive export
        """
        vulnerabilities = []

        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if exp.name:
                    try:
                        func_name = exp.name.decode('utf-8', errors='ignore')

                        # Sensitive export detection
                        sensitive_patterns = [
                            'license', 'auth', 'crypt', 'validate',
                            'check', 'verify', 'admin', 'key'
                        ]

                        for pattern in sensitive_patterns:
                            if pattern in func_name.lower():
                                vulnerabilities.append({
                                    'type': 'export_vulnerability',
                                    'function': func_name,
                                    'risk': 'Potential Information Disclosure'
                                })
                    except Exception as e:
                        logger.warning(f"Export analysis error: {e}")

        return vulnerabilities

    @staticmethod
    def _detect_weak_crypto(pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced cryptographic weakness detection.

        Scans the binary for indicators of weak cryptographic implementations including:
        - Hardcoded cryptographic keys or hashes (MD5/SHA1)
        - Base64-encoded secrets
        - References to outdated or vulnerable encryption algorithms
        - Patterns suggesting improper cryptographic usage

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected cryptographic weaknesses with details about each issue
        """
        vulnerabilities = []

        try:
            with open(binary_path, 'rb') as f:
                binary_data = f.read()

            # Enhanced crypto weakness patterns
            weak_crypto_patterns = [
                # MD5/SHA1 hash representations
                rb'[0-9a-f]{32}',  # MD5
                rb'[0-9a-f]{40}',  # SHA1

                # Base64/weak encoding patterns
                rb'([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)',

                # Potential encryption/decryption keywords
                rb'decrypt', rb'encrypt', rb'key', rb'cipher',
                rb'aes', rb'des', rb'rsa', rb'xor'
            ]

            for pattern in weak_crypto_patterns:
                matches = list(re.finditer(
                    pattern, binary_data, re.IGNORECASE))
                for match in matches[:5]:  # Limit matches
                    vulnerabilities.append({
                        'type': 'crypto_weakness',
                        'pattern': pattern.decode('utf-8', errors='ignore'),
                        'offset': f'0x{match.start():X}',
                        'risk': 'Potential Cryptographic Vulnerability'
                    })

        except Exception as e:
            logger.error(f"Crypto weakness detection error: {e}")

        return vulnerabilities

    @staticmethod
    def _detect_licensing_weaknesses(pe, binary_path: str) -> List[Dict[str, Any]]:
        """
        Advanced licensing-specific weakness detection.

        Performs targeted analysis to identify licensing mechanisms and potential
        weaknesses in license validation routines. Searches for patterns related to:
        - License keys and validation
        - Trial period implementations
        - Activation mechanisms
        - Registration routines
        - Serial number verification

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected licensing weaknesses with details about each vulnerability
        """
        vulnerabilities = []

        try:
            with open(binary_path, 'rb') as f:
                binary_data = f.read()

            # Enhanced licensing-related patterns
            license_patterns = [
                rb'licen[cs]e',
                rb'trial',
                rb'expire',
                rb'activation',
                rb'serial',
                rb'key\s*valid',
                rb'registration',
                rb'check\s*license',
                rb'validate\s*key'
            ]

            for pattern in license_patterns:
                matches = list(re.finditer(
                    pattern, binary_data, re.IGNORECASE))
                for match in matches[:5]:  # Limit matches
                    vulnerabilities.append({
                        'type': 'licensing_weakness',
                        'pattern': pattern.decode('utf-8', errors='ignore'),
                        'offset': f'0x{match.start():X}',
                        'risk': 'High Potential for License Bypass'
                    })

        except Exception as e:
            logger.error(f"Licensing weakness detection error: {e}")

        return vulnerabilities

    @classmethod
    def generate_exploit_strategy(cls, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Advanced exploit strategy generation.

        Analyzes detected vulnerabilities and generates targeted exploitation strategies
        based on vulnerability types. Maps each vulnerability to appropriate bypass techniques
        including function hijacking, memory manipulation, license bypass, and cryptographic
        bypass approaches.

        Args:
            cls: Class reference
            vulnerabilities: List of vulnerability dictionaries from previous scanning steps

        Returns:
            list: Exploitation strategies with detailed descriptions and techniques for each
                 vulnerability, prioritized by effectiveness
        """
        cls.logger.info(f"Generating exploit strategies for {len(vulnerabilities)} vulnerabilities.")
        strategies = []

        exploit_mapping = {
            'import_vulnerability': {
                'strategy': 'function_hijacking',
                'description': 'Intercept and modify critical imported functions',
                'technique': 'Replace function implementation to bypass checks'},
            'high_entropy_section': {
                'strategy': 'memory_manipulation',
                'description': 'Inject alternative code into high-entropy sections',
                'technique': 'Modify obfuscated/packed code regions'},
            'licensing_weakness': {
                'strategy': 'license_bypass',
                'description': 'Direct manipulation of license validation logic',
                'technique': 'Patch or modify license checking mechanisms'},
            'crypto_weakness': {
                'strategy': 'cryptographic_bypass',
                'description': 'Exploit weak cryptographic implementations',
                'technique': 'Circumvent or fake cryptographic validation'}}

        for vuln in vulnerabilities:
            strategy = exploit_mapping.get(vuln['type'], {
                'strategy': 'generic_bypass',
                'description': 'Generic exploit strategy',
                'technique': 'Attempt to bypass protection mechanism'
            })

            strategy['source_vulnerability'] = vuln
            strategies.append(strategy)
            cls.logger.debug(f"Generated strategy for vuln type '{vuln['type']}': {strategy['strategy']}")

        cls.logger.info(f"Generated {len(strategies)} exploit strategies.")
        return strategies


class VulnerabilityReport:
    """
    Vulnerability analysis reporting utilities
    """
    
    @staticmethod
    def generate_report(vulnerabilities: List[Dict[str, Any]], binary_path: str) -> Dict[str, Any]:
        """Generate a comprehensive vulnerability report"""
        report = {
            'binary_path': binary_path,
            'total_vulnerabilities': len(vulnerabilities),
            'vulnerability_types': {},
            'severity_breakdown': {'high': 0, 'medium': 0, 'low': 0},
            'vulnerabilities': vulnerabilities,
            'recommendations': []
        }
        
        # Analyze vulnerability types
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'unknown')
            report['vulnerability_types'][vuln_type] = report['vulnerability_types'].get(vuln_type, 0) + 1
            
            # Count severity levels
            severity = vuln.get('severity', 'medium')
            if severity in report['severity_breakdown']:
                report['severity_breakdown'][severity] += 1
        
        # Generate recommendations
        if report['vulnerability_types'].get('licensing_weakness', 0) > 0:
            report['recommendations'].append('Consider implementing stronger license validation mechanisms')
        
        if report['vulnerability_types'].get('crypto_weakness', 0) > 0:
            report['recommendations'].append('Review cryptographic implementations for hardcoded keys or weak algorithms')
            
        if report['vulnerability_types'].get('high_entropy_section', 0) > 0:
            report['recommendations'].append('High entropy sections detected - verify packing/obfuscation is intentional')
        
        return report


# Export classes and functions
__all__ = [
    'AdvancedVulnerabilityEngine',
    'VulnerabilityReport',
    'calculate_entropy'
]