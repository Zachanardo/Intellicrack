"""Advanced vulnerability detection and analysis engine for binary security assessment.

This module provides comprehensive vulnerability scanning capabilities for PE binaries,
including import table analysis, section analysis, cryptographic weakness detection,
and licensing vulnerability identification. The engine generates detailed vulnerability
reports and exploitation strategies for security research purposes.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import re
from typing import Any

from ...utils.protection_utils import calculate_entropy


# Type alias for pefile PE object
PE_TYPE = Any

# Configure module logger
logger = logging.getLogger(__name__)

# Third-party imports
try:
    from intellicrack.handlers.pefile_handler import pefile

    PEFILE_AVAILABLE = True
except ImportError as e:
    logger.debug("Optional dependency pefile not available: %s", e)
    PEFILE_AVAILABLE = False


# Import shared entropy calculation


class AdvancedVulnerabilityEngine:
    """Comprehensive vulnerability detection and analysis framework."""

    # Class logger for all AdvancedVulnerabilityEngine methods
    logger = logging.getLogger("Intellicrack.AdvancedVulnerabilityEngine")

    @classmethod
    def scan_binary(cls, binary_path: str) -> list[dict[str, Any]]:
        """Comprehensive multi-stage binary vulnerability scanning.

        Performs a series of vulnerability checks on the binary including import table analysis,
        section analysis, export table analysis, weak crypto detection, and licensing weakness
        detection. Each check is executed in sequence to build a complete vulnerability profile.

        Args:
            cls: Class reference
            binary_path: Path to the binary file to scan

        Returns:
            list: Collection of detected vulnerabilities, each represented as a dictionary
                 with details about the vulnerability type, location, and severity

        """
        vulnerabilities = []

        if not PEFILE_AVAILABLE:
            cls.logger.error("pefile library not available, cannot scan PE binaries")
            return vulnerabilities

        try:
            # Use pefile for in-depth PE file analysis
            pe = pefile.PE(binary_path, fast_load=False)

            # Comprehensive vulnerability checks
            vulnerability_checks = [
                cls._analyze_import_table,
                cls._analyze_sections,
                cls._analyze_export_table,
                cls._detect_weak_crypto,
                cls._detect_licensing_weaknesses,
            ]

            # Run all vulnerability checks
            for check in vulnerability_checks:
                vulnerabilities.extend(check(pe, binary_path))

        except (OSError, ValueError, RuntimeError) as e:
            cls.logger.error("Comprehensive binary scanning error: %s", e, exc_info=True)

        return vulnerabilities

    @staticmethod
    def _analyze_import_table(pe: PE_TYPE, _binary_path: str) -> list[dict[str, Any]]:  # pylint: disable=unused-argument
        """Advanced import table vulnerability analysis.

        Examines the binary's import table for potentially dangerous API calls that might
        indicate security weaknesses or licensing vulnerabilities. Categorizes imports into
        risk categories including system execution, memory manipulation, crypto weakness,
        and network risk.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected import-related vulnerabilities with risk categorization

        """
        vulnerabilities = []

        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            import_entries = getattr(pe, "DIRECTORY_ENTRY_IMPORT", [])
            # Comprehensive dangerous import keywords
            dangerous_imports = {
                "system_execution": [
                    "system",
                    "exec",
                    "shellexecute",
                    "createprocess",
                    "winexec",
                    "loadlibrary",
                ],
                "memory_manipulation": [
                    "virtualalloc",
                    "virtualprotect",
                    "writeprocessmemory",
                    "readprocessmemory",
                ],
                "crypto_weakness": [
                    "crypt",
                    "decrypt",
                    "encrypt",
                    "hash",
                    "md5",
                    "sha1",
                ],
                "network_risk": [
                    "connect",
                    "send",
                    "recv",
                    "wsasend",
                    "wsarecv",
                    "internetopen",
                    "httpsendrequestw",
                ],
            }

            for entry in import_entries:
                for imp in entry.imports:
                    try:
                        func_name = imp.name.decode("utf-8", errors="ignore").lower()

                        for risk_category, keywords in dangerous_imports.items():
                            if any(keyword in func_name for keyword in keywords):
                                vulnerabilities.append(
                                    {
                                        "type": "import_vulnerability",
                                        "risk_category": risk_category,
                                        "function": func_name,
                                        "module": entry.dll.decode("utf-8", errors="ignore"),
                                        "severity": "high",
                                    },
                                )
                    except (OSError, ValueError, RuntimeError) as e:
                        logger.warning("Import analysis error: %s", e, exc_info=True)

        return vulnerabilities

    @classmethod
    def _analyze_sections(cls, pe: PE_TYPE, binary_path: str) -> list[dict[str, Any]]:
        """Advanced section-level vulnerability analysis.

        Analyzes each section in the PE file for suspicious characteristics including:
        - High entropy sections (potential encryption/obfuscation)
        - Sections with dangerous permission combinations (executable + writable)
        - Unusual section characteristics that may indicate protection mechanisms

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected section-related vulnerabilities with details about each issue

        """
        cls.logger.debug("Analyzing sections for binary: %s", binary_path)
        vulnerabilities = []

        for section in pe.sections:
            section_data = section.get_data()
            entropy = calculate_entropy(section_data)
            section_name = section.Name.decode("utf-8", errors="ignore").strip("\x00")

            # High entropy sections might indicate packed/encrypted code
            if entropy > 7.0:
                vulnerabilities.append(
                    {
                        "type": "high_entropy_section",
                        "section_name": section_name,
                        "entropy": entropy,
                        "risk": "Potential Obfuscation/Packing",
                    },
                )

            # Check section permissions
            characteristics = section.Characteristics
            is_executable = bool(characteristics & 0x20000000)
            is_writable = bool(characteristics & 0x80000000)

            cls.logger.debug("Section '%s': Entropy=%s, Executable=%s, Writable=%s", section_name, entropy, is_executable, is_writable)

            if is_executable and is_writable:
                vulnerabilities.append(
                    {
                        "type": "section_permission_vulnerability",
                        "section_name": section_name,
                        "risk": "Executable and Writable Section",
                    },
                )

        cls.logger.info("Found %d section-related vulnerabilities.", len(vulnerabilities))
        return vulnerabilities

    @staticmethod
    def _analyze_export_table(pe: PE_TYPE, binary_path: str) -> list[dict[str, Any]]:
        """Advanced export table vulnerability analysis.

        Examines the binary's export table for sensitive function names that might
        reveal licensing mechanisms, authentication routines, or other security-critical
        components. Identifies exports that could be targeted for patching or hooking.

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for reference)

        Returns:
            list: Detected export-related vulnerabilities with details about each sensitive export

        """
        vulnerabilities = []
        AdvancedVulnerabilityEngine.logger.debug("Analyzing export table for binary: %s", binary_path)

        if hasattr(pe, "DIRECTORY_ENTRY_EXPORT"):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if exp.name:
                    try:
                        func_name = exp.name.decode("utf-8", errors="ignore")

                        # Sensitive export detection
                        sensitive_patterns = [
                            "license",
                            "auth",
                            "crypt",
                            "validate",
                            "check",
                            "verify",
                            "admin",
                            "key",
                        ]

                        vulnerabilities.extend(
                            {
                                "type": "export_vulnerability",
                                "function": func_name,
                                "risk": "Potential Information Disclosure",
                                "binary_path": binary_path,
                                "pattern_matched": pattern,
                            }
                            for pattern in sensitive_patterns
                            if pattern in func_name.lower()
                        )
                    except (OSError, ValueError, RuntimeError) as e:
                        logger.warning("Export analysis error: %s", e, exc_info=True)

        return vulnerabilities

    @staticmethod
    def _detect_weak_crypto(pe: PE_TYPE, binary_path: str) -> list[dict[str, Any]]:
        """Advanced cryptographic weakness detection.

        Scans the binary for indicators of weak cryptographic implementations including:
        - Hardcoded cryptographic keys or hashes (MD5/SHA1)
        - Base64-encoded secrets
        - References to outdated or vulnerable encryption algorithms
        - Patterns suggesting improper cryptographic usage

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected cryptographic weaknesses with details about each issue

        """
        vulnerabilities = []
        logger.debug("Analyzing cryptographic weaknesses for binary: %s", binary_path)

        # Analyze PE imports for crypto libraries
        crypto_imports = []
        if pe and hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode("utf-8", errors="ignore").lower()
                if any(crypto_lib in dll_name for crypto_lib in ["crypt", "ssl", "tls", "bcrypt", "wincrypt"]):
                    crypto_imports.append(dll_name)

        try:
            with open(binary_path, "rb") as f:
                binary_data = f.read()

            # Enhanced crypto weakness patterns
            weak_crypto_patterns = [
                # MD5/SHA1 hash representations
                rb"[0-9a-f]{32}",  # MD5
                rb"[0-9a-f]{40}",  # SHA1
                # Base64/weak encoding patterns
                rb"([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)",
                # Potential encryption/decryption keywords
                rb"decrypt",
                rb"encrypt",
                rb"key",
                rb"cipher",
                rb"aes",
                rb"des",
                rb"rsa",
                rb"xor",
            ]

            for pattern in weak_crypto_patterns:
                matches = list(re.finditer(pattern, binary_data, re.IGNORECASE))
                vulnerabilities.extend(
                    {
                        "type": "crypto_weakness",
                        "pattern": pattern.decode("utf-8", errors="ignore"),
                        "offset": f"0x{match.start():X}",
                        "risk": "Potential Cryptographic Vulnerability",
                    }
                    for match in matches[:5]
                )
        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Crypto weakness detection error: %s", e, exc_info=True)

        # Add crypto library analysis
        for crypto_lib in crypto_imports:
            vulnerabilities.append(
                {
                    "type": "crypto_library",
                    "library": crypto_lib,
                    "risk": "Crypto library usage detected",
                    "analysis": "May contain cryptographic implementations to analyze",
                },
            )

        return vulnerabilities

    @staticmethod
    def _detect_licensing_weaknesses(pe: PE_TYPE, binary_path: str) -> list[dict[str, Any]]:
        """Advanced licensing-specific weakness detection.

        Performs targeted analysis to identify licensing mechanisms and potential
        weaknesses in license validation routines. Searches for patterns related to:
        - License keys and validation
        - Trial period implementations
        - Activation mechanisms
        - Registration routines
        - Serial number verification

        Args:
            pe: Loaded PE file object from pefile
            binary_path: Path to the binary file (for direct content analysis)

        Returns:
            list: Detected licensing weaknesses with details about each vulnerability

        """
        vulnerabilities = []
        logger.debug("Analyzing licensing weaknesses for binary: %s", binary_path)

        # Analyze PE exports for licensing functions
        licensing_exports = []
        if pe and hasattr(pe, "DIRECTORY_ENTRY_EXPORT"):
            for export in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if export.name:
                    export_name = export.name.decode("utf-8", errors="ignore").lower()
                    if any(term in export_name for term in ["license", "trial", "serial", "key", "activate", "register"]):
                        licensing_exports.append(export_name)

        try:
            with open(binary_path, "rb") as f:
                binary_data = f.read()

            # Enhanced licensing-related patterns
            license_patterns = [
                rb"licen[cs]e",
                rb"trial",
                rb"expire",
                rb"activation",
                rb"serial",
                rb"key\s*valid",
                rb"registration",
                rb"check\s*license",
                rb"validate\s*key",
            ]

            for pattern in license_patterns:
                matches = list(re.finditer(pattern, binary_data, re.IGNORECASE))
                vulnerabilities.extend(
                    {
                        "type": "licensing_weakness",
                        "pattern": pattern.decode("utf-8", errors="ignore"),
                        "offset": f"0x{match.start():X}",
                        "risk": "High Potential for License Bypass",
                    }
                    for match in matches[:5]
                )
        except (OSError, ValueError, RuntimeError) as e:
            logger.error("Licensing weakness detection error: %s", e, exc_info=True)

        # Add licensing export analysis
        for export in licensing_exports:
            vulnerabilities.append(
                {
                    "type": "licensing_export",
                    "function": export,
                    "risk": "Potential licensing function",
                    "analysis": "Function may contain license validation logic",
                },
            )

        return vulnerabilities

    @classmethod
    def generate_exploit_strategy(cls, vulnerabilities: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Advanced exploit strategy generation.

        Analyzes detected vulnerabilities and generates targeted exploitation strategies
        based on vulnerability types. Maps each vulnerability to appropriate bypass techniques
        including function hijacking, memory manipulation, license bypass, and cryptographic
        bypass approaches.

        Args:
            cls: Class reference
            vulnerabilities: List of vulnerability dictionaries from previous scanning steps

        Returns:
            list: Exploitation strategies with detailed descriptions and techniques for each
                 vulnerability, prioritized by effectiveness

        """
        cls.logger.info("Generating exploit strategies for %d vulnerabilities.", len(vulnerabilities))
        strategies = []

        exploit_mapping = {
            "import_vulnerability": {
                "strategy": "function_hijacking",
                "description": "Intercept and modify critical imported functions",
                "technique": "Replace function implementation to bypass checks",
            },
            "high_entropy_section": {
                "strategy": "memory_manipulation",
                "description": "Inject alternative code into high-entropy sections",
                "technique": "Modify obfuscated/packed code regions",
            },
            "licensing_weakness": {
                "strategy": "license_bypass",
                "description": "Direct manipulation of license validation logic",
                "technique": "Patch or modify license checking mechanisms",
            },
            "crypto_weakness": {
                "strategy": "cryptographic_bypass",
                "description": "Exploit weak cryptographic implementations",
                "technique": "Extract cryptographic keys, replace validation routines, or replicate weak algorithms",
            },
        }

        for vuln in vulnerabilities:
            strategy = exploit_mapping.get(
                vuln["type"],
                {
                    "strategy": "generic_bypass",
                    "description": "Generic exploit strategy",
                    "technique": "Attempt to bypass protection mechanism",
                },
            )

            strategy["source_vulnerability"] = vuln
            strategies.append(strategy)
            cls.logger.debug("Generated strategy for vuln type '%s': %s", vuln["type"], strategy["strategy"])

        cls.logger.info("Generated %d exploit strategies.", len(strategies))
        return strategies


class VulnerabilityReport:
    """Vulnerability analysis reporting utilities."""

    @staticmethod
    def generate_report(vulnerabilities: list[dict[str, Any]], binary_path: str) -> dict[str, Any]:
        """Generate a comprehensive vulnerability report."""
        report = {
            "binary_path": binary_path,
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerability_types": {},
            "severity_breakdown": {"high": 0, "medium": 0, "low": 0},
            "vulnerabilities": vulnerabilities,
            "recommendations": [],
        }

        # Analyze vulnerability types
        for vuln in vulnerabilities:
            vuln_type = vuln.get("type", "unknown")
            report["vulnerability_types"][vuln_type] = report["vulnerability_types"].get(vuln_type, 0) + 1

            # Count severity levels
            severity = vuln.get("severity", "medium")
            if severity in report["severity_breakdown"]:
                report["severity_breakdown"][severity] += 1

        # Generate recommendations
        if report["vulnerability_types"].get("licensing_weakness", 0) > 0:
            report["recommendations"].append("Consider implementing stronger license validation mechanisms")

        if report["vulnerability_types"].get("crypto_weakness", 0) > 0:
            report["recommendations"].append("Review cryptographic implementations for hardcoded keys or weak algorithms")

        if report["vulnerability_types"].get("high_entropy_section", 0) > 0:
            report["recommendations"].append("High entropy sections detected - verify packing/obfuscation is intentional")

        return report


# Create alias for backward compatibility
VulnerabilityEngine = AdvancedVulnerabilityEngine

# Export classes and functions
__all__ = [
    "AdvancedVulnerabilityEngine",
    "VulnerabilityEngine",
    "VulnerabilityReport",
    "calculate_entropy",
]
