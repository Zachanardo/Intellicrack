"""
Radare2 Advanced Vulnerability Detection Engine

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import logging
import re
from typing import Any, Dict, List, Optional

from ...utils.tools.radare2_utils import R2Exception, R2Session, r2_session
from .radare2_decompiler import R2DecompilationEngine
from .radare2_esil import ESILAnalysisEngine
from .radare2_imports import R2ImportExportAnalyzer
from .radare2_strings import R2StringAnalyzer


class R2VulnerabilityEngine:
    """
    Advanced vulnerability detection engine combining all radare2 analysis capabilities.

    Provides comprehensive vulnerability detection through:
    - Static code analysis via decompilation
    - Dynamic analysis via ESIL emulation
    - Pattern recognition in strings and imports
    - Cross-reference analysis
    - Automated exploit generation
    - CVE pattern matching
    """

    def __init__(self, binary_path: str, radare2_path: Optional[str] = None):
        """
        Initialize vulnerability detection engine.

        Args:
            binary_path: Path to binary file
            radare2_path: Optional path to radare2 executable
        """
        self.binary_path = binary_path
        self.radare2_path = radare2_path
        self.logger = logging.getLogger(__name__)

        # Initialize sub-engines
        self.decompiler = R2DecompilationEngine(binary_path, radare2_path)
        self.esil_engine = ESILAnalysisEngine(binary_path, radare2_path)
        self.string_analyzer = R2StringAnalyzer(binary_path, radare2_path)
        self.import_analyzer = R2ImportExportAnalyzer(binary_path, radare2_path)

        # Vulnerability patterns database
        self.vulnerability_patterns = self._load_vulnerability_patterns()

    def analyze_vulnerabilities(self) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability analysis.

        Returns:
            Complete vulnerability analysis results
        """
        result = {
            'binary_path': self.binary_path,
            'vulnerability_summary': {},
            'buffer_overflows': [],
            'format_string_bugs': [],
            'integer_overflows': [],
            'use_after_free': [],
            'double_free': [],
            'null_pointer_dereferences': [],
            'race_conditions': [],
            'privilege_escalation': [],
            'code_injection': [],
            'path_traversal': [],
            'information_disclosure': [],
            'cryptographic_weaknesses': [],
            'license_bypass_vulnerabilities': [],
            'cve_matches': [],
            'exploit_generation': {},
            'severity_assessment': {},
            'remediation_suggestions': {},
            'automated_patches': []
        }

        try:
            with r2_session(self.binary_path, self.radare2_path) as r2:
                # Get functions for analysis
                functions = r2.get_functions()

                # Perform multi-layered vulnerability detection
                result.update(self._detect_buffer_overflows(r2, functions))
                result.update(self._detect_format_string_bugs(r2, functions))
                result.update(self._detect_integer_overflows(r2, functions))
                result.update(self._detect_memory_corruption(r2, functions))
                result.update(self._detect_race_conditions(r2, functions))
                result.update(self._detect_privilege_escalation(r2, functions))
                result.update(self._detect_code_injection(r2, functions))
                result.update(self._detect_path_traversal(r2, functions))
                result.update(self._detect_information_disclosure(r2, functions))
                result.update(self._detect_crypto_weaknesses(r2, functions))
                result.update(self._detect_license_bypass_vulns(r2, functions))

                # Match against CVE database
                result['cve_matches'] = self._match_cve_patterns(result)

                # Generate automated exploits
                result['exploit_generation'] = self._generate_exploits(result)

                # Assess severity
                result['severity_assessment'] = self._assess_vulnerability_severity(result)

                # Generate remediation suggestions
                result['remediation_suggestions'] = self._generate_remediation_suggestions(result)

                # Generate automated patches
                result['automated_patches'] = self._generate_automated_patches(result)

                # Create summary
                result['vulnerability_summary'] = self._create_vulnerability_summary(result)

        except R2Exception as e:
            result['error'] = str(e)
            self.logger.error(f"Vulnerability analysis failed: {e}")

        return result

    def _load_vulnerability_patterns(self) -> Dict[str, Any]:
        """Load vulnerability pattern database."""
        return {
            'buffer_overflow': {
                'functions': ['strcpy', 'strcat', 'sprintf', 'gets', 'scanf', 'strncpy'],
                'patterns': [
                    r'strcpy\s*\([^,]+,\s*[^)]+\)',
                    r'sprintf\s*\([^,]+,\s*[^,]+,.*\)',
                    r'gets\s*\([^)]+\)',
                    r'memcpy\s*\([^,]+,\s*[^,]+,\s*[^)]+\)'
                ],
                'severity': 'high'
            },
            'format_string': {
                'functions': ['printf', 'fprintf', 'sprintf', 'snprintf', 'syslog'],
                'patterns': [
                    r'printf\s*\(\s*[^"]*[^,\s]+\s*\)',
                    r'fprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)',
                    r'sprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)'
                ],
                'severity': 'high'
            },
            'integer_overflow': {
                'functions': ['malloc', 'calloc', 'realloc', 'new'],
                'patterns': [
                    r'malloc\s*\(\s*[^)]*\*[^)]*\)',
                    r'calloc\s*\([^,]*,\s*[^)]*\*[^)]*\)',
                    r'new\s+\w+\[[^]]*\*[^]]*\]'
                ],
                'severity': 'medium'
            },
            'use_after_free': {
                'functions': ['free', 'delete'],
                'patterns': [
                    r'free\s*\([^)]+\).*(?:(?!\bfree\b).)*\1',
                    r'delete\s+[^;]+;.*(?:(?!\bdelete\b).)*\1'
                ],
                'severity': 'high'
            },
            'race_condition': {
                'functions': ['CreateThread', 'pthread_create', '_beginthread'],
                'patterns': [
                    r'(?:CreateThread|pthread_create).*(?:shared|global).*variable',
                    r'(?:mutex|lock).*(?:unlock).*(?:access|modify)'
                ],
                'severity': 'medium'
            }
        }

    def _detect_buffer_overflows(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect buffer overflow vulnerabilities."""
        buffer_overflows = []

        dangerous_functions = self.vulnerability_patterns['buffer_overflow']['functions']

        for func in functions[:50]:  # Analyze first 50 functions for performance
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue

            try:
                # Get function disassembly
                disasm = r2._execute_command(f'pdf @ {hex(func_addr)}')

                # Check for dangerous function calls
                for dangerous_func in dangerous_functions:
                    if dangerous_func.lower() in disasm.lower():
                        # Get more context through decompilation
                        decompiled = self.decompiler.decompile_function(func_addr)

                        if decompiled.get('pseudocode'):
                            # Analyze pseudocode for buffer overflow patterns
                            patterns = self._analyze_buffer_overflow_patterns(
                                decompiled['pseudocode'], dangerous_func
                            )

                            if patterns:
                                buffer_overflows.append({
                                    'function': func,
                                    'dangerous_function': dangerous_func,
                                    'patterns': patterns,
                                    'severity': 'high',
                                    'exploitable': self._assess_exploitability(patterns),
                                    'decompiled_code': decompiled['pseudocode'],
                                    'suggested_fix': self._suggest_buffer_overflow_fix(dangerous_func)
                                })

            except R2Exception:
                continue

        return {'buffer_overflows': buffer_overflows}

    def _detect_format_string_bugs(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect format string vulnerabilities."""
        format_string_bugs = []

        format_functions = self.vulnerability_patterns['format_string']['functions']

        for func in functions[:50]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue

            try:
                # Get assembly code for additional analysis
                asm_code = r2._execute_command(f'pdf @ {hex(func_addr)}')

                # Decompile function to analyze format string usage
                decompiled = self.decompiler.decompile_function(func_addr)
                pseudocode = decompiled.get('pseudocode', '')

                if pseudocode or asm_code:
                    # Check for format string vulnerabilities in pseudocode
                    for format_func in format_functions:
                        patterns = re.findall(
                            rf'{format_func}\s*\([^)]*\)',
                            pseudocode,
                            re.IGNORECASE
                        )

                        for pattern in patterns:
                            # Check if format string is user-controlled
                            if self._is_format_string_vulnerable(pattern):
                                format_string_bugs.append({
                                    'function': func,
                                    'format_function': format_func,
                                    'vulnerable_call': pattern,
                                    'severity': 'high',
                                    'exploit_method': 'Format string exploitation',
                                    'suggested_fix': self._suggest_format_string_fix(format_func)
                                })

                    # Also check assembly code for format string calls
                    if asm_code:
                        for format_func in format_functions:
                            if format_func.lower() in asm_code.lower():
                                # Use r2 to get cross-references for this function call
                                try:
                                    xrefs = r2._execute_command(f'axtj @ sym.imp.{format_func}', expect_json=True)
                                    if xrefs:
                                        format_string_bugs.append({
                                            'function': func,
                                            'format_function': format_func,
                                            'vulnerable_call': f'ASM call to {format_func}',
                                            'severity': 'medium',
                                            'exploit_method': 'Assembly-level format string',
                                            'suggested_fix': self._suggest_format_string_fix(format_func),
                                            'cross_references': len(xrefs) if isinstance(xrefs, list) else 1
                                        })
                                except Exception:
                                    pass

            except R2Exception:
                continue

        return {'format_string_bugs': format_string_bugs}

    def _detect_integer_overflows(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect integer overflow vulnerabilities."""
        integer_overflows = []
        
        # Use r2 to search for integer overflow patterns
        try:
            # Search for multiplication operations before allocation
            mul_patterns = r2.run_command('/x 0faf')  # IMUL instruction
            add_patterns = r2.run_command('/x 4801')  # ADD with potential overflow
            
            # Get all malloc/calloc calls
            malloc_calls = r2.run_command('axt @ sym.imp.malloc')
            calloc_calls = r2.run_command('axt @ sym.imp.calloc')
            
        except Exception as e:
            self.logger.debug(f"Failed to search for integer overflow patterns: {e}")
            mul_patterns = add_patterns = malloc_calls = calloc_calls = ""

        allocation_functions = self.vulnerability_patterns['integer_overflow']['functions']

        for func in functions[:50]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze function for integer overflow
                func_asm = r2.run_command(f'pdf @ {func_addr}')
                
                # Check if this function has multiplication near malloc/calloc
                has_mul_before_alloc = False
                if 'imul' in func_asm or 'mul' in func_asm:
                    # Check if multiplication result is used in allocation
                    if any(alloc in func_asm for alloc in ['malloc', 'calloc', 'realloc']):
                        has_mul_before_alloc = True
                        
                # Use r2 to check for integer overflow checks
                overflow_checks = r2.run_command(f'pdf @ {func_addr} | grep -E "jo|jno|jc|jnc"')
                has_overflow_check = bool(overflow_checks)
                
                # Get function complexity
                func_info = r2.run_command(f'afij @ {func_addr}')
                
                # Decompile for detailed analysis
                decompiled = self.decompiler.decompile_function(func_addr)
                pseudocode = decompiled.get('pseudocode', '')

                if pseudocode:
                    # Look for multiplication in allocation size
                    patterns = re.findall(
                        r'(malloc|calloc|realloc)\s*\([^)]*\*[^)]*\)',
                        pseudocode,
                        re.IGNORECASE
                    )

                    for pattern in patterns:
                        # Check if multiplication could overflow
                        if self._could_integer_overflow(pattern):
                            # Enhanced analysis with r2 info
                            severity = 'high' if has_mul_before_alloc and not has_overflow_check else 'medium'
                            
                            integer_overflows.append({
                                'function': func,
                                'allocation_call': pattern,
                                'severity': severity,
                                'risk_factor': 'Integer overflow in allocation size',
                                'has_overflow_check': has_overflow_check,
                                'r2_analysis': {
                                    'has_multiplication': has_mul_before_alloc,
                                    'has_overflow_protection': has_overflow_check,
                                    'allocation_in_function': True
                                },
                                'suggested_fix': 'Add bounds checking before multiplication'
                            })

            except R2Exception:
                continue

        return {'integer_overflows': integer_overflows}

    def _detect_memory_corruption(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect use-after-free and double-free vulnerabilities."""
        use_after_free = []
        double_free = []
        
        # Use r2 to search for memory corruption patterns
        try:
            # Search for free calls
            free_xrefs = r2.run_command('axt @ sym.imp.free')
            
            # Search for common UAF patterns
            mov_after_call = r2.run_command('/x e8........48')  # call followed by mov
            
            # Get heap-related functions
            heap_funcs = r2.run_command('afl~malloc|free|realloc|calloc')
            
        except Exception as e:
            self.logger.debug(f"Failed to search for memory corruption patterns: {e}")
            free_xrefs = mov_after_call = heap_funcs = ""

        for func in functions[:50]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze memory operations in function
                func_asm = r2.run_command(f'pdf @ {func_addr}')
                
                # Track free operations and subsequent memory accesses
                free_calls = []
                memory_accesses_after_free = []
                
                lines = func_asm.split('\n')
                for i, line in enumerate(lines):
                    if 'call sym.imp.free' in line:
                        free_calls.append((i, line))
                        
                        # Check for memory access after free
                        for j in range(i+1, min(i+20, len(lines))):
                            if any(pattern in lines[j] for pattern in ['mov', 'lea', 'push', 'pop']):
                                # Check if it's accessing the same register/memory
                                if any(reg in lines[j] for reg in ['rdi', 'rsi', 'rdx', 'rcx'] if reg in line):
                                    memory_accesses_after_free.append((j, lines[j]))
                
                # Use r2 ESIL for more detailed analysis
                esil_result = None
                try:
                    # Initialize ESIL for this function
                    r2.run_command(f's {func_addr}')
                    r2.run_command('aei')  # Initialize ESIL VM
                    r2.run_command('aeim')  # Initialize ESIL memory
                    
                    # Emulate function with ESIL
                    esil_trace = r2.run_command(f'aetr @ {func_addr}')
                    
                    # Parse ESIL trace for memory operations
                    esil_result = self._parse_esil_trace(esil_trace)
                except:
                    # Fallback to static analysis
                    esil_result = self.esil_engine.emulate_function_execution(func_addr, max_steps=100)

                # Analyze memory access patterns
                memory_accesses = esil_result.get('memory_accesses', []) if esil_result else []

                # Track free operations
                free_operations = []
                access_after_free = []

                for access in memory_accesses:
                    instruction = access.get('instruction', '').lower()

                    if 'free' in instruction:
                        free_operations.append(access)
                    elif free_operations and any(
                        self._same_memory_region(access, free_op)
                        for free_op in free_operations
                    ):
                        access_after_free.append(access)

                if access_after_free:
                    use_after_free.append({
                        'function': func,
                        'free_operations': free_operations,
                        'access_after_free': access_after_free,
                        'severity': 'high',
                        'exploitable': True,
                        'r2_analysis': {
                            'free_calls_found': len(free_calls),
                            'accesses_after_free': len(memory_accesses_after_free),
                            'esil_emulated': esil_result is not None
                        }
                    })
                elif memory_accesses_after_free:
                    # Add r2 static analysis results
                    use_after_free.append({
                        'function': func,
                        'free_operations': free_calls,
                        'access_after_free': memory_accesses_after_free,
                        'severity': 'medium',
                        'exploitable': True,
                        'r2_static_analysis': True
                    })

                # Detect double free
                double_frees = self._detect_double_free_pattern(memory_accesses)
                if double_frees:
                    double_free.extend(double_frees)

            except R2Exception:
                continue

        return {
            'use_after_free': use_after_free,
            'double_free': double_free
        }

    def _detect_race_conditions(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect race condition vulnerabilities."""
        race_conditions = []

        # Look for threading functions
        threading_functions = ['CreateThread', 'pthread_create', '_beginthread', 'std::thread']

        for func in functions[:50]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue

            try:
                disasm = r2._execute_command(f'pdf @ {hex(func_addr)}')

                # Check for threading patterns
                has_threading = any(
                    thread_func.lower() in disasm.lower()
                    for thread_func in threading_functions
                )

                if has_threading:
                    # Check for shared resource access without synchronization
                    decompiled = self.decompiler.decompile_function(func_addr)
                    pseudocode = decompiled.get('pseudocode', '')

                    if self._has_unsynchronized_access(pseudocode):
                        race_conditions.append({
                            'function': func,
                            'threading_detected': True,
                            'unsynchronized_access': True,
                            'severity': 'medium',
                            'suggested_fix': 'Add proper synchronization (mutex/lock)'
                        })

            except R2Exception:
                continue

        return {'race_conditions': race_conditions}

    def _detect_privilege_escalation(self, _r2: R2Session, _functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect privilege escalation vulnerabilities."""
        privilege_escalation = []

        # Get imports to check for privilege-related APIs
        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get('imports', [])

        priv_apis = [
            'AdjustTokenPrivileges', 'ImpersonateLoggedOnUser', 'SetThreadToken',
            'LookupPrivilegeValue', 'OpenProcessToken', 'DuplicateToken'
        ]

        found_priv_apis = [
            imp for imp in imports
            if any(api.lower() in imp.get('name', '').lower() for api in priv_apis)
        ]

        if found_priv_apis:
            for api in found_priv_apis:
                privilege_escalation.append({
                    'api': api,
                    'type': 'privilege_manipulation',
                    'severity': 'high',
                    'description': 'Direct privilege manipulation detected',
                    'r2_analysis': {
                        'setuid_calls': bool(setuid_refs),
                        'setgid_calls': bool(setgid_refs),
                        'token_apis': bool(priv_apis_search),
                        'capability_apis': bool(cap_refs)
                    }
                })
                
        # Use r2 to analyze functions for privilege escalation patterns
        for func in functions[:30]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue
                
            try:
                # Get function disassembly
                func_asm = r2.run_command(f'pdf @ {func_addr}')
                
                # Check for setuid/setgid calls
                if 'setuid' in func_asm or 'setgid' in func_asm:
                    # Check if it's dropping privileges (good) or escalating (bad)
                    if 'push 0' in func_asm or 'xor' in func_asm:
                        privilege_escalation.append({
                            'type': 'setuid_to_root',
                            'function': func,
                            'severity': 'high',
                            'description': 'Function appears to escalate to root privileges'
                        })
                        
                # Check for unsafe system calls
                if 'system' in func_asm or 'execve' in func_asm:
                    # Check if input is controlled
                    func_xrefs = r2.run_command(f'axtj @ {func_addr}')
                    if 'user' in str(func_xrefs).lower() or 'input' in str(func_xrefs).lower():
                        privilege_escalation.append({
                            'type': 'command_injection_risk',
                            'function': func,
                            'severity': 'high',
                            'description': 'System call with potential user input'
                        })
                        
            except Exception as e:
                self.logger.debug(f"Failed to analyze function {func_addr}: {e}")

        return {'privilege_escalation': privilege_escalation}

    def _detect_code_injection(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect code injection vulnerabilities."""
        code_injection = []

        # Use r2 to search for code injection patterns
        try:
            # Search for memory allocation/write APIs
            valloc_refs = r2.run_command('axt @ sym.imp.VirtualAllocEx')
            write_mem_refs = r2.run_command('axt @ sym.imp.WriteProcessMemory')
            create_thread_refs = r2.run_command('axt @ sym.imp.CreateRemoteThread')
            
            # Search for shellcode patterns
            shellcode_pattern = r2.run_command('/x 31c0')  # xor eax, eax (common in shellcode)
            nop_sleds = r2.run_command('/x 909090')  # NOP sleds
            
            # Search for dynamic code generation
            jit_patterns = r2.run_command('/x 48c7')  # mov instruction patterns
            
        except Exception as e:
            self.logger.debug(f"Failed to search for code injection patterns: {e}")
            valloc_refs = write_mem_refs = create_thread_refs = shellcode_pattern = nop_sleds = jit_patterns = ""

        injection_apis = [
            'VirtualAllocEx', 'WriteProcessMemory', 'CreateRemoteThread',
            'SetWindowsHookEx', 'QueueUserAPC', 'NtMapViewOfSection'
        ]

        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get('imports', [])

        found_injection_apis = [
            imp for imp in imports
            if any(api.lower() in imp.get('name', '').lower() for api in injection_apis)
        ]

        if found_injection_apis:
            for api in found_injection_apis:
                code_injection.append({
                    'api': api,
                    'injection_method': self._identify_injection_method(api['name']),
                    'severity': 'critical',
                    'exploitable': True,
                    'r2_analysis': {
                        'has_valloc': bool(valloc_refs),
                        'has_write_process_memory': bool(write_mem_refs),
                        'has_create_remote_thread': bool(create_thread_refs),
                        'shellcode_patterns_found': bool(shellcode_pattern),
                        'nop_sleds_found': bool(nop_sleds)
                    }
                })
                
        # Analyze functions for injection patterns
        for func in functions[:30]:
            func_addr = func.get('offset', 0)
            if not func_addr:
                continue
                
            try:
                # Get function assembly
                func_asm = r2.run_command(f'pdf @ {func_addr}')
                
                # Check for process injection sequence
                if 'VirtualAllocEx' in func_asm and 'WriteProcessMemory' in func_asm:
                    code_injection.append({
                        'type': 'process_injection_sequence',
                        'function': func,
                        'severity': 'high',
                        'description': 'Function performs classic process injection'
                    })
                    
                # Check for eval/exec patterns
                if any(pattern in func_asm for pattern in ['eval', 'exec', 'compile']):
                    code_injection.append({
                        'type': 'dynamic_code_execution',
                        'function': func,
                        'severity': 'medium',
                        'description': 'Function uses dynamic code execution'
                    })
                    
            except Exception as e:
                self.logger.debug(f"Failed to analyze function for injection: {e}")

        return {'code_injection': code_injection}

    def _detect_path_traversal(self, _r2: R2Session, _functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect path traversal vulnerabilities."""
        path_traversal = []

        # Analyze strings for path traversal patterns
        string_analysis = self.string_analyzer.analyze_all_strings()
        strings = string_analysis.get('file_path_strings', [])

        traversal_patterns = ['../', '..\\', '%2e%2e%2f', '%2e%2e%5c']

        for string_data in strings:
            content = string_data.get('content', '')
            if any(pattern in content.lower() for pattern in traversal_patterns):
                path_traversal.append({
                    'string': string_data,
                    'pattern': 'directory_traversal',
                    'severity': 'medium',
                    'description': 'Potential path traversal string detected',
                    'r2_analysis': {
                        'traversal_strings_found': bool(traversal_strings),
                        'file_operations_found': bool(fopen_refs or open_refs or createfile_refs),
                        'path_validation_found': bool(realpath_refs)
                    }
                })

        return {'path_traversal': path_traversal}

    def _detect_information_disclosure(self, _r2: R2Session, _functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect information disclosure vulnerabilities."""
        information_disclosure = []

        # Check for debug information exposure
        string_analysis = self.string_analyzer.analyze_all_strings()
        debug_strings = string_analysis.get('debug_strings', [])

        sensitive_patterns = [
            'password', 'secret', 'key', 'token', 'credential',
            'username', 'login', 'admin', 'root'
        ]

        for debug_string in debug_strings:
            content = debug_string.get('content', '').lower()
            if any(pattern in content for pattern in sensitive_patterns):
                information_disclosure.append({
                    'string': debug_string,
                    'disclosure_type': 'sensitive_debug_info',
                    'severity': 'medium',
                    'description': 'Sensitive information in debug strings'
                })

        return {'information_disclosure': information_disclosure}

    def _detect_crypto_weaknesses(self, _r2: R2Session, _functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect cryptographic weaknesses."""
        crypto_weaknesses = []

        # Analyze crypto API usage
        import_analysis = self.import_analyzer.analyze_imports_exports()
        crypto_apis = import_analysis.get('crypto_apis', [])

        weak_algorithms = ['des', 'md5', 'rc4', 'sha1']

        for crypto_api in crypto_apis:
            api_name = crypto_api.get('api', {}).get('name', '').lower()

            if any(weak_algo in api_name for weak_algo in weak_algorithms):
                crypto_weaknesses.append({
                    'api': crypto_api,
                    'weakness_type': 'weak_algorithm',
                    'severity': 'medium',
                    'recommended_alternative': self._get_crypto_alternative(api_name)
                })

        return {'cryptographic_weaknesses': crypto_weaknesses}

    def _detect_license_bypass_vulns(self, r2: R2Session, functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Detect license bypass vulnerabilities."""
        license_bypass_vulns = []
        
        # Use r2 to search for license validation patterns
        try:
            # Search for license-related strings
            license_strings = r2.run_command('iz~license|trial|demo|activation|serial')
            
            # Search for time checks (trial expiration)
            time_refs = r2.run_command('axt @ sym.imp.time')
            gettime_refs = r2.run_command('axt @ sym.imp.GetSystemTime')
            
            # Search for registry/file checks (license storage)
            reg_refs = r2.run_command('axt @ sym.imp.RegQueryValue')
            file_refs = r2.run_command('axt @ sym.imp.fopen')
            
            # Search for conditional jumps that might be patchable
            jz_patterns = r2.run_command('/x 74')  # JZ instruction
            jnz_patterns = r2.run_command('/x 75')  # JNZ instruction
            
        except Exception as e:
            self.logger.debug(f"Failed to search for license bypass patterns: {e}")
            license_strings = time_refs = gettime_refs = reg_refs = file_refs = jz_patterns = jnz_patterns = ""

        # Analyze license validation functions
        for func in functions[:50]:
            func_addr = func.get('offset', 0)
            func_name = func.get('name', '').lower()

            if any(keyword in func_name for keyword in ['license', 'valid', 'check', 'trial']):
                try:
                    # Use r2 to analyze the function
                    func_asm = r2.run_command(f'pdf @ {func_addr}')
                    
                    # Look for patchable conditions
                    patchable_jumps = []
                    lines = func_asm.split('\n')
                    for i, line in enumerate(lines):
                        if 'jz' in line or 'jnz' in line or 'je' in line or 'jne' in line:
                            # Check context - is this after a comparison?
                            if i > 0 and ('cmp' in lines[i-1] or 'test' in lines[i-1]):
                                patchable_jumps.append({
                                    'offset': line.split()[0] if line.split() else '',
                                    'instruction': line,
                                    'type': 'conditional_jump'
                                })
                    
                    # Get decompiled code for deeper analysis
                    decompiled = self.decompiler.decompile_function(func_addr)
                    license_patterns = decompiled.get('license_patterns', [])

                    if license_patterns or patchable_jumps:
                        # Analyze bypass possibilities
                        bypass_methods = self._analyze_license_bypass_methods(decompiled)
                        
                        # Add r2-discovered bypass methods
                        if patchable_jumps:
                            bypass_methods.append('conditional_jump_patching')
                        if time_refs and str(func_addr) in time_refs:
                            bypass_methods.append('time_manipulation')

                        license_bypass_vulns.append({
                            'function': func,
                            'license_patterns': license_patterns,
                            'bypass_methods': bypass_methods,
                            'difficulty': self._assess_bypass_difficulty(bypass_methods),
                            'automated_patches': self._generate_license_patches(decompiled),
                            'r2_analysis': {
                                'patchable_jumps': patchable_jumps,
                                'has_time_checks': bool(time_refs) and str(func_addr) in time_refs,
                                'has_registry_checks': bool(reg_refs) and str(func_addr) in reg_refs,
                                'license_strings_found': license_strings.count('\n') if license_strings else 0
                            }
                        })

                except R2Exception:
                    continue

        return {'license_bypass_vulnerabilities': license_bypass_vulns}

    def _match_cve_patterns(self, vulnerabilities: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Match detected vulnerabilities against CVE patterns."""
        cve_matches = []

        # Simple CVE pattern matching (in production, use actual CVE database)
        cve_patterns = {
            'CVE-2021-44228': {
                'pattern': 'log4j',
                'description': 'Log4Shell vulnerability',
                'severity': 'critical'
            },
            'CVE-2020-1472': {
                'pattern': 'netlogon',
                'description': 'Zerologon vulnerability',
                'severity': 'critical'
            }
        }

        # Check buffer overflows against known CVE patterns
        for vuln_type, vulns in vulnerabilities.items():
            if isinstance(vulns, list):
                for vuln in vulns:
                    # Simple pattern matching logic
                    for cve_id, cve_data in cve_patterns.items():
                        if self._matches_cve_pattern(vuln, cve_data):
                            cve_matches.append({
                                'cve_id': cve_id,
                                'vulnerability': vuln,
                                'confidence': 0.8,
                                'description': cve_data['description']
                            })

        return cve_matches

    def _generate_exploits(self, vulnerabilities: Dict[str, Any]) -> Dict[str, Any]:
        """Generate automated exploits for detected vulnerabilities."""
        exploits = {}

        # Generate buffer overflow exploits
        buffer_overflows = vulnerabilities.get('buffer_overflows', [])
        for i, vuln in enumerate(buffer_overflows):
            if vuln.get('exploitable'):
                exploits[f'buffer_overflow_{i}'] = {
                    'type': 'buffer_overflow',
                    'target_function': vuln['function']['name'],
                    'exploit_method': 'Stack-based buffer overflow',
                    'payload_generation': self._generate_bof_payload(vuln),
                    'reliability': 'medium'
                }

        # Generate format string exploits
        format_bugs = vulnerabilities.get('format_string_bugs', [])
        for i, vuln in enumerate(format_bugs):
            exploits[f'format_string_{i}'] = {
                'type': 'format_string',
                'target_function': vuln['function']['name'],
                'exploit_method': 'Format string exploitation',
                'payload_generation': self._generate_format_string_payload(vuln),
                'reliability': 'high'
            }

        return exploits

    def _assess_vulnerability_severity(self, vulnerabilities: Dict[str, Any]) -> Dict[str, Any]:
        """Assess overall vulnerability severity."""
        severity_scores = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0
        }

        # Count vulnerabilities by severity
        for vuln_type, vulns in vulnerabilities.items():
            if isinstance(vulns, list):
                for vuln in vulns:
                    severity = vuln.get('severity', 'low')
                    if severity in severity_scores:
                        severity_scores[severity] += 1

        # Calculate overall risk
        total_vulns = sum(severity_scores.values())
        risk_score = (
            severity_scores['critical'] * 10 +
            severity_scores['high'] * 7 +
            severity_scores['medium'] * 4 +
            severity_scores['low'] * 1
        )

        return {
            'severity_distribution': severity_scores,
            'total_vulnerabilities': total_vulns,
            'risk_score': risk_score,
            'overall_rating': self._calculate_overall_rating(risk_score, total_vulns)
        }

    def _generate_remediation_suggestions(self, vulnerabilities: Dict[str, Any]) -> Dict[str, List[str]]:
        """Generate remediation suggestions for vulnerabilities."""
        suggestions = {}

        if vulnerabilities.get('buffer_overflows'):
            suggestions['buffer_overflow'] = [
                'Replace unsafe functions with safe alternatives (strncpy, snprintf)',
                'Implement input validation and bounds checking',
                'Enable stack canaries and DEP/NX bit',
                'Use AddressSanitizer during development'
            ]

        if vulnerabilities.get('format_string_bugs'):
            suggestions['format_string'] = [
                'Use format string literals instead of variables',
                'Validate all user input before using in format functions',
                'Enable compiler warnings for format string issues'
            ]

        if vulnerabilities.get('integer_overflows'):
            suggestions['integer_overflow'] = [
                'Check for integer overflow before arithmetic operations',
                'Use safe integer libraries',
                'Implement size limits for allocation requests'
            ]

        return suggestions

    def _generate_automated_patches(self, vulnerabilities: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate automated patches for vulnerabilities."""
        patches = []

        # Generate patches for buffer overflows
        for vuln in vulnerabilities.get('buffer_overflows', []):
            patches.append(self._generate_buffer_overflow_patch(vuln))

        # Generate patches for format string bugs
        for vuln in vulnerabilities.get('format_string_bugs', []):
            patches.append(self._generate_format_string_patch(vuln))

        return patches

    def _create_vulnerability_summary(self, vulnerabilities: Dict[str, Any]) -> Dict[str, Any]:
        """Create vulnerability summary."""
        summary = {
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'most_critical': None,
            'exploit_ready': 0,
            'cve_matches': len(vulnerabilities.get('cve_matches', [])),
            'overall_risk': 'low'
        }

        # Count vulnerabilities
        for vuln_type, vulns in vulnerabilities.items():
            if isinstance(vulns, list):
                summary['total_vulnerabilities'] += len(vulns)

                for vuln in vulns:
                    severity = vuln.get('severity', 'low')
                    if severity == 'critical':
                        summary['critical_count'] += 1
                    elif severity == 'high':
                        summary['high_count'] += 1
                    elif severity == 'medium':
                        summary['medium_count'] += 1
                    else:
                        summary['low_count'] += 1

                    if vuln.get('exploitable'):
                        summary['exploit_ready'] += 1

        # Determine overall risk
        if summary['critical_count'] > 0:
            summary['overall_risk'] = 'critical'
        elif summary['high_count'] > 2:
            summary['overall_risk'] = 'high'
        elif summary['medium_count'] > 5:
            summary['overall_risk'] = 'medium'

        return summary

    # Helper methods for vulnerability analysis
    def _analyze_buffer_overflow_patterns(self, pseudocode: str, dangerous_func: str) -> List[Dict[str, Any]]:
        """Analyze buffer overflow patterns in pseudocode."""
        patterns = []

        # Look for function usage without bounds checking
        lines = pseudocode.split('\n')
        for i, line in enumerate(lines):
            if dangerous_func.lower() in line.lower():
                # Check if there's bounds checking nearby
                context_lines = lines[max(0, i-3):i+4]
                has_bounds_check = any(
                    'sizeof' in context_line.lower() or
                    'length' in context_line.lower() or
                    'size' in context_line.lower()
                    for context_line in context_lines
                )

                if not has_bounds_check:
                    patterns.append({
                        'line_number': i + 1,
                        'vulnerable_call': line.strip(),
                        'missing_bounds_check': True,
                        'severity': 'high'
                    })

        return patterns

    def _assess_exploitability(self, patterns: List[Dict[str, Any]]) -> bool:
        """Assess if vulnerability is exploitable."""
        return len(patterns) > 0 and all(p.get('missing_bounds_check') for p in patterns)

    def _suggest_buffer_overflow_fix(self, dangerous_func: str) -> str:
        """Suggest fix for buffer overflow."""
        fixes = {
            'strcpy': 'Use strncpy() with proper size limits',
            'strcat': 'Use strncat() with proper size limits',
            'sprintf': 'Use snprintf() with buffer size',
            'gets': 'Use fgets() with buffer size limit',
            'scanf': 'Use format specifiers with width limits'
        }
        return fixes.get(dangerous_func.lower(), 'Implement proper bounds checking')

    def _is_format_string_vulnerable(self, pattern: str) -> bool:
        """Check if format string pattern is vulnerable."""
        # Check if format string is not a literal
        return not ('"' in pattern and pattern.count('"') >= 2)

    def _suggest_format_string_fix(self, format_func: str) -> str:
        """Suggest fix for format string vulnerability."""
        return f'Use {format_func}(buffer, "%s", user_input) instead of {format_func}(buffer, user_input)'

    def _could_integer_overflow(self, pattern: str) -> bool:
        """Check if pattern could cause integer overflow."""
        # Simple heuristic: multiplication without bounds checking
        return '*' in pattern and not any(
            check in pattern.lower()
            for check in ['check', 'limit', 'max', 'bound']
        )

    def _same_memory_region(self, access1: Dict[str, Any], access2: Dict[str, Any]) -> bool:
        """Check if two memory accesses are to the same region."""
        # Simplified implementation
        addr1 = access1.get('address', '')
        addr2 = access2.get('address', '')
        return addr1 == addr2

    def _detect_double_free_pattern(self, memory_accesses: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Detect double free patterns."""
        double_frees = []
        freed_addresses = set()

        for access in memory_accesses:
            instruction = access.get('instruction', '').lower()
            address = access.get('address', '')

            if 'free' in instruction:
                if address in freed_addresses:
                    double_frees.append({
                        'address': address,
                        'instruction': instruction,
                        'severity': 'high'
                    })
                else:
                    freed_addresses.add(address)

        return double_frees

    def _has_unsynchronized_access(self, pseudocode: str) -> bool:
        """Check for unsynchronized access to shared resources."""
        has_shared_access = any(
            keyword in pseudocode.lower()
            for keyword in ['global', 'static', 'shared']
        )
        has_synchronization = any(
            sync_keyword in pseudocode.lower()
            for sync_keyword in ['mutex', 'lock', 'critical', 'atomic']
        )

        return has_shared_access and not has_synchronization

    def _identify_injection_method(self, api_name: str) -> str:
        """Identify code injection method."""
        injection_methods = {
            'virtualallocex': 'Process memory allocation',
            'writeprocessmemory': 'Remote process writing',
            'createremotethread': 'Remote thread creation',
            'setwindowshookex': 'Windows hook injection',
            'queueuserapc': 'APC injection'
        }
        return injection_methods.get(api_name.lower(), 'Unknown injection method')

    def _get_crypto_alternative(self, weak_algo: str) -> str:
        """Get recommended alternative for weak crypto algorithm."""
        alternatives = {
            'des': 'AES-256',
            'md5': 'SHA-256',
            'rc4': 'AES-GCM',
            'sha1': 'SHA-256'
        }
        return alternatives.get(weak_algo.lower(), 'Use modern cryptographic algorithms')

    def _analyze_license_bypass_methods(self, decompiled: Dict[str, Any]) -> List[str]:
        """Analyze potential license bypass methods."""
        methods = []

        license_patterns = decompiled.get('license_patterns', [])

        for pattern in license_patterns:
            if pattern.get('type') == 'license_validation':
                methods.append('NOP out validation check')
                methods.append('Force return value to success')
                methods.append('Modify conditional jump')

        return methods

    def _assess_bypass_difficulty(self, bypass_methods: List[str]) -> str:
        """Assess difficulty of license bypass."""
        if len(bypass_methods) <= 2:
            return 'easy'
        elif len(bypass_methods) <= 4:
            return 'medium'
        else:
            return 'hard'

    def _generate_license_patches(self, decompiled: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate automated license patches."""
        patches = []

        license_patterns = decompiled.get('license_patterns', [])

        for pattern in license_patterns:
            if pattern.get('type') == 'license_validation':
                patches.append({
                    'type': 'nop_patch',
                    'target_line': pattern.get('line_number'),
                    'description': 'NOP out license validation',
                    'assembly_patch': 'Replace with NOP instructions'
                })

        return patches

    def _matches_cve_pattern(self, vuln: Dict[str, Any], cve_data: Dict[str, Any]) -> bool:
        """Check if vulnerability matches CVE pattern."""
        # Simplified pattern matching
        pattern = cve_data.get('pattern', '').lower()

        # Check function names, API calls, etc.
        func_name = vuln.get('function', {}).get('name', '').lower()
        return pattern in func_name

    def _generate_bof_payload(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """Generate buffer overflow payload."""
        return {
            'type': 'stack_overflow',
            'buffer_size': 'Analyze with fuzzing',
            'return_address': 'Overwrite with shellcode address',
            'shellcode': 'Platform-specific shellcode',
            'nop_sled': 'Add NOP sled for reliability'
        }

    def _generate_format_string_payload(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """Generate format string payload."""
        return {
            'type': 'format_string',
            'technique': 'Arbitrary write primitive',
            'payload': '%n specifier for memory writes',
            'target': 'GOT/PLT entries or return addresses'
        }

    def _generate_buffer_overflow_patch(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """Generate buffer overflow patch."""
        dangerous_func = vuln.get('dangerous_function', '')

        return {
            'vulnerability_type': 'buffer_overflow',
            'target_function': vuln['function']['name'],
            'patch_type': 'function_replacement',
            'original_function': dangerous_func,
            'replacement_function': self._get_safe_alternative(dangerous_func),
            'additional_checks': 'Add bounds checking'
        }

    def _generate_format_string_patch(self, vuln: Dict[str, Any]) -> Dict[str, Any]:
        """Generate format string patch."""
        return {
            'vulnerability_type': 'format_string',
            'target_function': vuln['function']['name'],
            'patch_type': 'format_string_fix',
            'fix_description': 'Use format string literals',
            'example_fix': 'printf("%s", user_input) instead of printf(user_input)'
        }

    def _get_safe_alternative(self, dangerous_func: str) -> str:
        """Get safe alternative for dangerous function."""
        alternatives = {
            'strcpy': 'strncpy',
            'strcat': 'strncat',
            'sprintf': 'snprintf',
            'gets': 'fgets',
            'scanf': 'scanf with width specifiers'
        }
        return alternatives.get(dangerous_func.lower(), 'Safe equivalent')

    def _calculate_overall_rating(self, risk_score: int, total_vulns: int) -> str:
        """Calculate overall security rating."""
        if risk_score >= 50 or total_vulns >= 10:
            return 'critical'
        elif risk_score >= 20 or total_vulns >= 5:
            return 'high'
        elif risk_score >= 10 or total_vulns >= 2:
            return 'medium'
        else:
            return 'low'


def analyze_binary_vulnerabilities(binary_path: str, radare2_path: Optional[str] = None) -> Dict[str, Any]:
    """
    Perform comprehensive vulnerability analysis on a binary.

    Args:
        binary_path: Path to binary file
        radare2_path: Optional path to radare2 executable

    Returns:
        Complete vulnerability analysis results
    """
    engine = R2VulnerabilityEngine(binary_path, radare2_path)
    return engine.analyze_vulnerabilities()


__all__ = ['R2VulnerabilityEngine', 'analyze_binary_vulnerabilities']
