"""Radare2 vulnerability analysis engine for identifying security issues."""

import logging
import re
import struct
from typing import TYPE_CHECKING, Any


try:
    from pwn import asm, context, cyclic, p32, p64

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False

from intellicrack.utils.logger import logger

from ...utils.tools.radare2_utils import R2Exception, R2Session, R2SessionPoolAdapter, r2_session
from ..protection_bypass.dongle_emulator import HardwareDongleEmulator
from ..protection_bypass.tpm_bypass import TPMProtectionBypass
from .commercial_license_analyzer import CommercialLicenseAnalyzer
from .radare2_decompiler import R2DecompilationEngine
from .radare2_esil import ESILAnalysisEngine
from .radare2_imports import R2ImportExportAnalyzer
from .radare2_strings import R2StringAnalyzer


if TYPE_CHECKING:
    from collections.abc import Callable

R2SessionType = R2Session | R2SessionPoolAdapter


logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Module loading started")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] About to import pwntools...")
if PWNTOOLS_AVAILABLE:
    logger.debug("%s", "[DEBUG radare2_vulnerability_engine] pwntools imported OK")
else:
    logger.debug("%s", "[DEBUG radare2_vulnerability_engine] pwntools not available (ImportError)")
logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Starting other imports...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] logger imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_utils...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_utils imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Using lazy import for protocol_fingerprinter to avoid circular dependency")


def _get_protocol_fingerprinter() -> type[Any]:
    """Lazy import ProtocolFingerprinter to avoid circular import."""
    from ..network.protocol_fingerprinter import ProtocolFingerprinter

    protocol_class: type[Any] = ProtocolFingerprinter
    return protocol_class


logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing dongle_emulator...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] dongle_emulator imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing tpm_bypass...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] tpm_bypass imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing commercial_license_analyzer...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] commercial_license_analyzer imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_decompiler...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_decompiler imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_esil...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_esil imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_imports...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_imports imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_strings...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_strings imported OK")

"""
Radare2 Advanced Vulnerability Detection Engine

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""


class R2VulnerabilityEngine:
    """Advanced vulnerability detection engine combining all radare2 analysis capabilities.

    Provides comprehensive vulnerability detection through:
    - Static code analysis via decompilation
    - Dynamic analysis via ESIL emulation
    - Pattern recognition in strings and imports
    - Cross-reference analysis
    - Automated exploit generation
    - CVE pattern matching
    """

    def __init__(self, binary_path: str, radare2_path: str | None = None) -> None:
        """Initialize vulnerability detection engine.

        Args:
            binary_path: Path to binary file
            radare2_path: Optional path to radare2 executable

        """
        self.binary_path = binary_path
        self.radare2_path = radare2_path
        self.logger = logging.getLogger(__name__)

        # Initialize sub-engines
        self.decompiler = R2DecompilationEngine(binary_path, radare2_path)
        self.esil_engine = ESILAnalysisEngine(binary_path, radare2_path)
        self.string_analyzer = R2StringAnalyzer(binary_path, radare2_path)
        self.import_analyzer = R2ImportExportAnalyzer(binary_path, radare2_path)

        # Initialize hardware protection modules
        self.tpm_bypass = TPMProtectionBypass()
        self.dongle_emulator = HardwareDongleEmulator()
        self._protocol_fingerprinter: Any = None

        # Initialize commercial license analyzer
        self.commercial_license_analyzer = CommercialLicenseAnalyzer(binary_path)
        self.commercial_analyzer = self.commercial_license_analyzer  # Alias for compatibility

        # Vulnerability patterns database
        self.vulnerability_patterns = self._load_vulnerability_patterns()

    @property
    def protocol_fingerprinter(self) -> Any:
        """Lazy load ProtocolFingerprinter to avoid circular import."""
        if self._protocol_fingerprinter is None:
            protocol_fingerprinter_class = _get_protocol_fingerprinter()
            self._protocol_fingerprinter = protocol_fingerprinter_class()
        return self._protocol_fingerprinter

    def analyze_vulnerabilities(self) -> dict[str, Any]:
        """Perform comprehensive vulnerability analysis.

        Returns:
            Complete vulnerability analysis results

        """
        result: dict[str, Any] = {
            "binary_path": self.binary_path,
            "vulnerability_summary": {},
            "buffer_overflows": [],
            "format_string_bugs": [],
            "integer_overflows": [],
            "use_after_free": [],
            "double_free": [],
            "null_pointer_dereferences": [],
            "race_conditions": [],
            "privilege_escalation": [],
            "code_injection": [],
            "modern_protections": {},
            "cet_bypass_analysis": {},
            "cfi_bypass_analysis": {},
            "hardware_protection_analysis": {},
            "tpm_bypass_analysis": {},
            "dongle_bypass_analysis": {},
            "commercial_license_analysis": {},
            "path_traversal": [],
            "information_disclosure": [],
            "cryptographic_weaknesses": [],
            "license_bypass_vulnerabilities": [],
            "cve_matches": [],
            "exploit_generation": {},
            "severity_assessment": {},
            "remediation_suggestions": {},
            "automated_patches": [],
        }

        try:
            with r2_session(self.binary_path, self.radare2_path) as r2:
                functions = r2.get_functions()

                buffer_overflow_results = self._detect_buffer_overflows(r2, functions)
                result["buffer_overflows"] = buffer_overflow_results.get("buffer_overflows", [])

                format_string_results = self._detect_format_string_bugs(r2, functions)
                result["format_string_bugs"] = format_string_results.get("format_string_bugs", [])

                integer_overflow_results = self._detect_integer_overflows(r2, functions)
                result["integer_overflows"] = integer_overflow_results.get("integer_overflows", [])

                memory_corruption_results = self._detect_memory_corruption(r2, functions)
                result["use_after_free"] = memory_corruption_results.get("use_after_free", [])
                result["double_free"] = memory_corruption_results.get("double_free", [])

                race_condition_results = self._detect_race_conditions(r2, functions)
                result["race_conditions"] = race_condition_results.get("race_conditions", [])

                privilege_escalation_results = self._detect_privilege_escalation(r2, functions)
                result["privilege_escalation"] = privilege_escalation_results.get("privilege_escalation", [])

                code_injection_results = self._detect_code_injection(r2, functions)
                result["code_injection"] = code_injection_results.get("code_injection", [])

                path_traversal_results = self._detect_path_traversal(r2, functions)
                result["path_traversal"] = path_traversal_results.get("path_traversal", [])

                info_disclosure_results = self._detect_information_disclosure(r2, functions)
                result["information_disclosure"] = info_disclosure_results.get("information_disclosure", [])

                crypto_weakness_results = self._detect_crypto_weaknesses(r2, functions)
                result["cryptographic_weaknesses"] = crypto_weakness_results.get("cryptographic_weaknesses", [])

                license_bypass_results = self._detect_license_bypass_vulns(r2, functions)
                result["license_bypass_vulnerabilities"] = license_bypass_results.get("license_bypass_vulnerabilities", [])

                result["modern_protections"] = self._analyze_modern_protections(r2)
                result["cet_bypass_analysis"] = self._analyze_cet_bypass_opportunities(r2, result)
                result["cfi_bypass_analysis"] = self._analyze_cfi_bypass_opportunities(r2, result)

                result["hardware_protection_analysis"] = self._analyze_hardware_protections(r2, result)
                result["tpm_bypass_analysis"] = self._analyze_tpm_bypass_opportunities(r2, result)
                result["dongle_bypass_analysis"] = self._analyze_dongle_bypass_opportunities(r2, result)

                result["commercial_license_analysis"] = self._analyze_commercial_licenses(r2, result)
                result["commercial_licenses"] = result["commercial_license_analysis"]

                result["cve_matches"] = self._match_cve_patterns(result)

                result["exploit_generation"] = self._generate_exploits(result)

                result["severity_assessment"] = self._assess_vulnerability_severity(result)

                result["remediation_suggestions"] = self._generate_remediation_suggestions(result)

                result["automated_patches"] = self._generate_automated_patches(result)

                result["vulnerability_summary"] = self._create_vulnerability_summary(result)

        except R2Exception as e:
            result["error"] = str(e)
            self.logger.exception("Vulnerability analysis failed: %s", e)

        return result

    def find_vulnerabilities(self) -> dict[str, Any]:
        """Provide API compatibility by delegating to analyze_vulnerabilities."""
        return self.analyze_vulnerabilities()

    def _load_vulnerability_patterns(self) -> dict[str, Any]:
        """Load vulnerability pattern database."""
        return {
            "buffer_overflow": {
                "functions": ["strcpy", "strcat", "sprintf", "gets", "scanf", "strncpy"],
                "patterns": [
                    r"strcpy\s*\([^,]+,\s*[^)]+\)",
                    r"sprintf\s*\([^,]+,\s*[^,]+,.*\)",
                    r"gets\s*\([^)]+\)",
                    r"memcpy\s*\([^,]+,\s*[^,]+,\s*[^)]+\)",
                ],
                "severity": "high",
            },
            "format_string": {
                "functions": ["printf", "fprintf", "sprintf", "snprintf", "syslog"],
                "patterns": [
                    r'printf\s*\(\s*[^"]*[^,\s]+\s*\)',
                    r'fprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)',
                    r'sprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)',
                ],
                "severity": "high",
            },
            "integer_overflow": {
                "functions": ["malloc", "calloc", "realloc", "new"],
                "patterns": [
                    r"malloc\s*\(\s*[^)]*\*[^)]*\)",
                    r"calloc\s*\([^,]*,\s*[^)]*\*[^)]*\)",
                    r"new\s+\w+\[[^]]*\*[^]]*\]",
                ],
                "severity": "medium",
            },
            "use_after_free": {
                "functions": ["free", "delete"],
                "patterns": [
                    r"free\s*\([^)]+\).*(?:(?!\bfree\b).)*\1",
                    r"delete\s+[^;]+;.*(?:(?!\bdelete\b).)*\1",
                ],
                "severity": "high",
            },
            "race_condition": {
                "functions": ["CreateThread", "pthread_create", "_beginthread"],
                "patterns": [
                    r"(?:CreateThread|pthread_create).*(?:shared|global).*variable",
                    r"(?:mutex|lock).*(?:unlock).*(?:access|modify)",
                ],
                "severity": "medium",
            },
        }

    def _detect_buffer_overflows(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect buffer overflow vulnerabilities."""
        buffer_overflows = []

        dangerous_functions = self.vulnerability_patterns["buffer_overflow"]["functions"]

        for func in functions[:50]:  # Analyze first 50 functions for performance
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function disassembly
                disasm = r2._execute_command(f"pdf @ {hex(func_addr)}")
                if not isinstance(disasm, str):
                    continue

                # Check for dangerous function calls
                for dangerous_func in dangerous_functions:
                    if dangerous_func.lower() in disasm.lower():
                        # Get more context through decompilation
                        decompiled = self.decompiler.decompile_function(func_addr)

                        if decompiled.get("pseudocode"):
                            if patterns := self._analyze_buffer_overflow_patterns(
                                decompiled["pseudocode"],
                                dangerous_func,
                            ):
                                buffer_overflows.append(
                                    {
                                        "function": func,
                                        "dangerous_function": dangerous_func,
                                        "patterns": patterns,
                                        "severity": "high",
                                        "exploitable": self._assess_exploitability(patterns),
                                        "decompiled_code": decompiled["pseudocode"],
                                        "suggested_fix": self._suggest_buffer_overflow_fix(dangerous_func),
                                    },
                                )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"buffer_overflows": buffer_overflows}

    def _detect_format_string_bugs(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect format string vulnerabilities."""
        format_string_bugs = []

        format_functions = self.vulnerability_patterns["format_string"]["functions"]

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get assembly code for additional analysis
                asm_code_result = r2._execute_command(f"pdf @ {hex(func_addr)}")
                asm_code = asm_code_result if isinstance(asm_code_result, str) else ""

                # Decompile function to analyze format string usage
                decompiled = self.decompiler.decompile_function(func_addr)
                pseudocode = decompiled.get("pseudocode", "")

                if pseudocode or asm_code:
                    # Check for format string vulnerabilities in pseudocode
                    for format_func in format_functions:
                        patterns = re.findall(
                            rf"{format_func}\s*\([^)]*\)",
                            pseudocode,
                            re.IGNORECASE,
                        )

                        for pattern in patterns:
                            # Check if format string is user-controlled
                            if self._is_format_string_vulnerable(pattern):
                                format_string_bugs.append(
                                    {
                                        "function": func,
                                        "format_function": format_func,
                                        "vulnerable_call": pattern,
                                        "severity": "high",
                                        "exploit_method": "Format string exploitation",
                                        "suggested_fix": self._suggest_format_string_fix(format_func),
                                    },
                                )

                # Also check assembly code for format string calls
                if asm_code:
                    for format_func in format_functions:
                        if format_func.lower() in asm_code.lower():
                            # Use r2 to get cross-references for this function call
                            try:
                                if xrefs := r2._execute_command(
                                    f"axtj @ sym.imp.{format_func}",
                                    expect_json=True,
                                ):
                                    format_string_bugs.append(
                                        {
                                            "function": func,
                                            "format_function": format_func,
                                            "vulnerable_call": f"ASM call to {format_func}",
                                            "severity": "medium",
                                            "exploit_method": "Assembly-level format string",
                                            "suggested_fix": self._suggest_format_string_fix(format_func),
                                            "cross_references": len(xrefs) if isinstance(xrefs, list) else 1,
                                        },
                                    )
                            except Exception as e:
                                logger.exception("Exception in radare2_vulnerability_engine: %s", e)

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"format_string_bugs": format_string_bugs}

    def _detect_integer_overflows(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect integer overflow vulnerabilities."""
        integer_overflows = []

        # Use r2 to search for integer overflow patterns
        try:
            # Search for multiplication operations before allocation
            mul_patterns = r2.cmd("/x 0faf")  # IMUL instruction
            add_patterns = r2.cmd("/x 4801")  # ADD with potential overflow

            # Get all malloc/calloc calls
            malloc_calls = r2.cmd("axt @ sym.imp.malloc")
            calloc_calls = r2.cmd("axt @ sym.imp.calloc")

        except Exception as e:
            self.logger.debug("Failed to search for integer overflow patterns: %s", e)
            mul_patterns = add_patterns = malloc_calls = calloc_calls = ""

        allocation_functions = self.vulnerability_patterns["integer_overflow"]["functions"]

        # Analyze patterns for potential vulnerabilities
        pattern_results = {
            "multiplication_patterns": len(mul_patterns.split("\n")) if mul_patterns else 0,
            "addition_patterns": len(add_patterns.split("\n")) if add_patterns else 0,
            "malloc_calls": len(malloc_calls.split("\n")) if malloc_calls else 0,
            "calloc_calls": len(calloc_calls.split("\n")) if calloc_calls else 0,
        }

        self.logger.debug("Integer overflow analysis: %s", pattern_results)

        # Use allocation_functions to filter dangerous patterns
        if any(func in allocation_functions for func in ["malloc", "calloc", "realloc"]):
            pass

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze function for integer overflow
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check if this function has multiplication near malloc/calloc
                has_mul_before_alloc = False
                if ("imul" in func_asm or "mul" in func_asm) and any(alloc in func_asm for alloc in ["malloc", "calloc", "realloc"]):
                    has_mul_before_alloc = True

                # Use r2 to check for integer overflow checks
                overflow_checks = r2.cmd(f'pdf @ {func_addr} | grep -E "jo|jno|jc|jnc"')
                has_overflow_check = bool(overflow_checks)

                # Get function complexity
                func_info = r2.cmd(f"afij @ {func_addr}")

                # Parse function info for complexity analysis
                complexity_info = {}
                try:
                    import json

                    if func_info.strip():
                        parsed_info = json.loads(func_info)
                        if isinstance(parsed_info, list) and len(parsed_info) > 0:
                            func_data = parsed_info[0]
                            complexity_info = {
                                "complexity": func_data.get("cc", 0),
                                "size": func_data.get("size", 0),
                                "instructions": func_data.get("ninstr", 0),
                            }
                except Exception as e:
                    self.logger.debug("Failed to parse function info: %s", e)
                    complexity_info = {"complexity": 0, "size": 0, "instructions": 0}

                # Decompile for detailed analysis
                decompiled = self.decompiler.decompile_function(func_addr)
                if pseudocode := decompiled.get("pseudocode", ""):
                    # Look for multiplication in allocation size
                    patterns = re.findall(
                        r"(malloc|calloc|realloc)\s*\([^)]*\*[^)]*\)",
                        pseudocode,
                        re.IGNORECASE,
                    )

                    for pattern in patterns:
                        # Check if multiplication could overflow
                        if self._could_integer_overflow(pattern):
                            # Enhanced analysis with r2 info
                            severity = "high" if has_mul_before_alloc and not has_overflow_check else "medium"

                            integer_overflows.append(
                                {
                                    "function": func,
                                    "allocation_call": pattern,
                                    "severity": severity,
                                    "risk_factor": "Integer overflow in allocation size",
                                    "has_overflow_check": has_overflow_check,
                                    "r2_analysis": {
                                        "has_multiplication": has_mul_before_alloc,
                                        "has_overflow_protection": has_overflow_check,
                                        "allocation_in_function": True,
                                    },
                                    "complexity_info": complexity_info,
                                    "suggested_fix": "Add bounds checking before multiplication",
                                },
                            )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"integer_overflows": integer_overflows}

    def _detect_memory_corruption(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect use-after-free and double-free vulnerabilities."""
        use_after_free = []
        double_free = []

        # Use r2 to search for memory corruption patterns
        try:
            # Search for free calls
            free_xrefs = r2.cmd("axt @ sym.imp.free")

            # Search for common UAF patterns
            mov_after_call = r2.cmd("/x e8........48")  # call followed by mov

            # Get heap-related functions
            heap_funcs = r2.cmd("afl~malloc|free|realloc|calloc")

        except Exception as e:
            self.logger.debug("Failed to search for memory corruption patterns: %s", e)
            free_xrefs = mov_after_call = heap_funcs = ""

        # Analyze memory corruption patterns
        corruption_patterns = {
            "free_references": len(free_xrefs.split("\n")) if free_xrefs else 0,
            "potential_uaf_patterns": len(mov_after_call.split("\n")) if mov_after_call else 0,
            "heap_functions": len(heap_funcs.split("\n")) if heap_funcs else 0,
        }

        self.logger.debug("Memory corruption analysis: %s", corruption_patterns)

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze memory operations in function
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Track free operations and subsequent memory accesses
                free_calls = []
                memory_accesses_after_free = []

                lines = func_asm.split("\n")
                for i, line in enumerate(lines):
                    if "call sym.imp.free" in line:
                        free_calls.append((i, line))

                        # Check for memory access after free
                        for j in range(i + 1, min(i + 20, len(lines))):
                            if any(pattern in lines[j] for pattern in ["mov", "lea", "push", "pop"]) and any(
                                reg in lines[j] for reg in ["rdi", "rsi", "rdx", "rcx"] if reg in line
                            ):
                                memory_accesses_after_free.append((j, lines[j]))

                # Use r2 ESIL for more detailed analysis
                esil_result = None
                try:
                    # Initialize ESIL for this function
                    r2.cmd(f"s {func_addr}")
                    r2.cmd("aei")  # Initialize ESIL VM
                    r2.cmd("aeim")  # Initialize ESIL memory

                    # Emulate function with ESIL
                    esil_trace = r2.cmd(f"aetr @ {func_addr}")

                    # Parse ESIL trace for memory operations
                    esil_result = self._parse_esil_trace(esil_trace)
                except Exception:
                    # Fallback to static analysis
                    esil_result = self.esil_engine.emulate_function_execution(func_addr, max_steps=100)

                # Analyze memory access patterns
                memory_accesses = esil_result.get("memory_accesses", []) if esil_result else []

                # Track free operations
                free_operations = []
                access_after_free = []

                for access in memory_accesses:
                    instruction = access.get("instruction", "").lower()

                    if "free" in instruction:
                        free_operations.append(access)
                    elif free_operations and any(self._same_memory_region(access, free_op) for free_op in free_operations):
                        access_after_free.append(access)

                if access_after_free:
                    use_after_free.append(
                        {
                            "function": func,
                            "free_operations": free_operations,
                            "access_after_free": access_after_free,
                            "severity": "high",
                            "exploitable": True,
                            "r2_analysis": {
                                "free_calls_found": len(free_calls),
                                "accesses_after_free": len(memory_accesses_after_free),
                                "esil_emulated": esil_result is not None,
                            },
                        },
                    )
                elif memory_accesses_after_free:
                    # Add r2 static analysis results
                    use_after_free.append(
                        {
                            "function": func,
                            "free_operations": free_calls,
                            "access_after_free": memory_accesses_after_free,
                            "severity": "medium",
                            "exploitable": True,
                            "r2_static_analysis": True,
                        },
                    )

                if double_frees := self._detect_double_free_pattern(memory_accesses):
                    double_free.extend(double_frees)

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {
            "use_after_free": use_after_free,
            "double_free": double_free,
        }

    def _detect_race_conditions(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect race condition vulnerabilities."""
        race_conditions = []

        # Look for threading functions
        threading_functions = ["CreateThread", "pthread_create", "_beginthread", "std::thread"]

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                disasm_result = r2._execute_command(f"pdf @ {hex(func_addr)}")
                if not isinstance(disasm_result, str):
                    continue
                disasm = disasm_result

                # Check for threading patterns
                has_threading = any(thread_func.lower() in disasm.lower() for thread_func in threading_functions)

                if has_threading:
                    # Check for shared resource access without synchronization
                    decompiled = self.decompiler.decompile_function(func_addr)
                    pseudocode = decompiled.get("pseudocode", "")

                    if self._has_unsynchronized_access(pseudocode):
                        race_conditions.append(
                            {
                                "function": func,
                                "threading_detected": True,
                                "unsynchronized_access": True,
                                "severity": "medium",
                                "suggested_fix": "Add proper synchronization (mutex/lock)",
                            },
                        )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"race_conditions": race_conditions}

    def _detect_privilege_escalation(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect privilege escalation vulnerabilities."""
        privilege_escalation: list[dict[str, Any]] = []

        # Get imports to check for privilege-related APIs
        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        priv_apis = [
            "AdjustTokenPrivileges",
            "ImpersonateLoggedOnUser",
            "SetThreadToken",
            "LookupPrivilegeValue",
            "OpenProcessToken",
            "DuplicateToken",
        ]

        found_priv_apis = [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in priv_apis)]

        # Check for Unix privilege escalation functions
        setuid_refs = [imp for imp in imports if "setuid" in imp.get("name", "").lower()]
        setgid_refs = [imp for imp in imports if "setgid" in imp.get("name", "").lower()]
        priv_apis_search = [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in priv_apis)]
        cap_refs = [imp for imp in imports if "cap_" in imp.get("name", "").lower() or "capability" in imp.get("name", "").lower()]

        if found_priv_apis:
            privilege_escalation.extend(
                {
                    "api": api,
                    "type": "privilege_manipulation",
                    "severity": "high",
                    "description": "Direct privilege manipulation detected",
                    "r2_analysis": {
                        "setuid_calls": bool(setuid_refs),
                        "setgid_calls": bool(setgid_refs),
                        "token_apis": bool(priv_apis_search),
                        "capability_apis": bool(cap_refs),
                    },
                }
                for api in found_priv_apis
            )
        # Use r2 to analyze functions for privilege escalation patterns
        for func in functions[:30]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function disassembly
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check for setuid/setgid calls
                if ("setuid" in func_asm or "setgid" in func_asm) and ("push 0" in func_asm or "xor" in func_asm):
                    privilege_escalation.append(
                        {
                            "type": "setuid_to_root",
                            "function": func,
                            "severity": "high",
                            "description": "Function appears to escalate to root privileges",
                        },
                    )

                # Check for unsafe system calls
                if "system" in func_asm or "execve" in func_asm:
                    # Check if input is controlled
                    func_xrefs = r2.cmd(f"axtj @ {func_addr}")
                    if "user" in str(func_xrefs).lower() or "input" in str(func_xrefs).lower():
                        privilege_escalation.append(
                            {
                                "type": "command_injection_risk",
                                "function": func,
                                "severity": "high",
                                "description": "System call with potential user input",
                            },
                        )

            except Exception as e:
                self.logger.debug("Failed to analyze function %s: %s", func_addr, e)

        return {"privilege_escalation": privilege_escalation}

    def _detect_code_injection(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect code injection vulnerabilities."""
        code_injection: list[dict[str, Any]] = []

        # Use r2 to search for code injection patterns
        try:
            # Search for memory allocation/write APIs
            valloc_refs = r2.cmd("axt @ sym.imp.VirtualAllocEx")
            write_mem_refs = r2.cmd("axt @ sym.imp.WriteProcessMemory")
            create_thread_refs = r2.cmd("axt @ sym.imp.CreateRemoteThread")

            # Search for shellcode patterns
            shellcode_pattern = r2.cmd("/x 31c0")  # xor eax, eax (common in shellcode)
            nop_sleds = r2.cmd("/x 909090")  # NOP sleds

            # Search for dynamic code generation
            _ = r2.cmd("/x 48c7")  # mov instruction patterns

        except Exception as e:
            self.logger.debug("Failed to search for code injection patterns: %s", e)
            valloc_refs = write_mem_refs = create_thread_refs = shellcode_pattern = nop_sleds = ""

        injection_apis = [
            "VirtualAllocEx",
            "WriteProcessMemory",
            "CreateRemoteThread",
            "SetWindowsHookEx",
            "QueueUserAPC",
            "NtMapViewOfSection",
        ]

        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        if found_injection_apis := [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in injection_apis)]:
            code_injection.extend(
                {
                    "api": api,
                    "injection_method": self._identify_injection_method(api["name"]),
                    "severity": "critical",
                    "exploitable": True,
                    "r2_analysis": {
                        "has_valloc": bool(valloc_refs),
                        "has_write_process_memory": bool(write_mem_refs),
                        "has_create_remote_thread": bool(create_thread_refs),
                        "shellcode_patterns_found": bool(shellcode_pattern),
                        "nop_sleds_found": bool(nop_sleds),
                    },
                }
                for api in found_injection_apis
            )
        # Analyze functions for injection patterns
        for func in functions[:30]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function assembly
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check for process injection sequence
                if "VirtualAllocEx" in func_asm and "WriteProcessMemory" in func_asm:
                    code_injection.append(
                        {
                            "type": "process_injection_sequence",
                            "function": func,
                            "severity": "high",
                            "description": "Function performs classic process injection",
                        },
                    )

                # Check for eval/exec patterns
                if any(pattern in func_asm for pattern in ["eval", "exec", "compile"]):
                    code_injection.append(
                        {
                            "type": "dynamic_code_execution",
                            "function": func,
                            "severity": "medium",
                            "description": "Function uses dynamic code execution",
                        },
                    )

            except Exception as e:
                self.logger.debug("Failed to analyze function for injection: %s", e)

        return {"code_injection": code_injection}

    def _detect_path_traversal(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect path traversal vulnerabilities."""
        path_traversal = []

        # Analyze strings for path traversal patterns
        string_analysis = self.string_analyzer.analyze_all_strings()
        strings = string_analysis.get("file_path_strings", [])

        traversal_patterns = ["../", "..\\", "%2e%2e%2f", "%2e%2e%5c"]

        # Check for file operation functions in imports
        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        traversal_strings = [s for s in strings if any(pattern in s.get("content", "").lower() for pattern in traversal_patterns)]
        fopen_refs = [imp for imp in imports if "fopen" in imp.get("name", "").lower()]
        open_refs = [imp for imp in imports if imp.get("name", "").lower() in ["open", "_open", "openfile"]]
        createfile_refs = [imp for imp in imports if "createfile" in imp.get("name", "").lower()]
        realpath_refs = [
            imp for imp in imports if "realpath" in imp.get("name", "").lower() or "canonicalize" in imp.get("name", "").lower()
        ]

        for string_data in strings:
            content = string_data.get("content", "")
            if any(pattern in content.lower() for pattern in traversal_patterns):
                path_traversal.append(
                    {
                        "string": string_data,
                        "pattern": "directory_traversal",
                        "severity": "medium",
                        "description": "Potential path traversal string detected",
                        "r2_analysis": {
                            "traversal_strings_found": bool(traversal_strings),
                            "file_operations_found": bool(fopen_refs or open_refs or createfile_refs),
                            "path_validation_found": bool(realpath_refs),
                        },
                    },
                )

        return {"path_traversal": path_traversal}

    def _detect_information_disclosure(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect information disclosure vulnerabilities."""
        information_disclosure = []

        # Check for debug information exposure
        string_analysis = self.string_analyzer.analyze_all_strings()
        debug_strings = string_analysis.get("debug_strings", [])

        sensitive_patterns = [
            "password",
            "secret",
            "key",
            "token",
            "credential",
            "username",
            "login",
            "admin",
            "root",
        ]

        for debug_string in debug_strings:
            content = debug_string.get("content", "").lower()
            if any(pattern in content for pattern in sensitive_patterns):
                information_disclosure.append(
                    {
                        "string": debug_string,
                        "disclosure_type": "sensitive_debug_info",
                        "severity": "medium",
                        "description": "Sensitive information in debug strings",
                    },
                )

        return {"information_disclosure": information_disclosure}

    def _detect_crypto_weaknesses(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect cryptographic weaknesses."""
        crypto_weaknesses = []

        # Analyze crypto API usage
        import_analysis = self.import_analyzer.analyze_imports_exports()
        crypto_apis = import_analysis.get("crypto_apis", [])

        weak_algorithms = ["des", "md5", "rc4", "sha1"]

        for crypto_api in crypto_apis:
            api_name = crypto_api.get("api", {}).get("name", "").lower()

            if any(weak_algo in api_name for weak_algo in weak_algorithms):
                crypto_weaknesses.append(
                    {
                        "api": crypto_api,
                        "weakness_type": "weak_algorithm",
                        "severity": "medium",
                        "recommended_alternative": self._get_crypto_alternative(api_name),
                    },
                )

        return {"cryptographic_weaknesses": crypto_weaknesses}

    def _detect_license_bypass_vulns(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect license bypass vulnerabilities."""
        license_bypass_vulns = []

        # Use r2 to search for license validation patterns
        try:
            # Search for license-related strings
            license_strings = r2.cmd("iz~license|trial|demo|activation|serial")

            # Search for time checks (trial expiration)
            time_refs = r2.cmd("axt @ sym.imp.time")
            _ = r2.cmd("axt @ sym.imp.GetSystemTime")

            # Search for registry/file checks (license storage)
            reg_refs = r2.cmd("axt @ sym.imp.RegQueryValue")
            _ = r2.cmd("axt @ sym.imp.fopen")

            # Search for conditional jumps that might be patchable
            _ = r2.cmd("/x 74")  # JZ instruction
            _ = r2.cmd("/x 75")  # JNZ instruction

        except Exception as e:
            self.logger.debug("Failed to search for license bypass patterns: %s", e)
            license_strings = time_refs = reg_refs = ""

        # Analyze license validation functions
        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            func_name = func.get("name", "").lower()

            if any(keyword in func_name for keyword in ["license", "valid", "check", "trial"]):
                try:
                    # Use r2 to analyze the function
                    func_asm = r2.cmd(f"pdf @ {func_addr}")

                    # Look for patchable conditions
                    patchable_jumps = []
                    lines = func_asm.split("\n")
                    for i, line in enumerate(lines):
                        # Check context - is this after a comparison?
                        if (
                            i > 0
                            and ("cmp" in lines[i - 1] or "test" in lines[i - 1])
                            and ("jz" in line or "jnz" in line or "je" in line or "jne" in line)
                        ):
                            patchable_jumps.append(
                                {
                                    "offset": line.split()[0] if line.split() else "",
                                    "instruction": line,
                                    "type": "conditional_jump",
                                },
                            )

                    # Get decompiled code for deeper analysis
                    decompiled = self.decompiler.decompile_function(func_addr)
                    license_patterns = decompiled.get("license_patterns", [])

                    if license_patterns or patchable_jumps:
                        # Analyze bypass possibilities
                        bypass_methods = self._analyze_license_bypass_methods(decompiled)

                        # Add r2-discovered bypass methods
                        if patchable_jumps:
                            bypass_methods.append("conditional_jump_patching")
                        if time_refs and str(func_addr) in time_refs:
                            bypass_methods.append("time_manipulation")

                        license_bypass_vulns.append(
                            {
                                "function": func,
                                "license_patterns": license_patterns,
                                "bypass_methods": bypass_methods,
                                "difficulty": self._assess_bypass_difficulty(bypass_methods),
                                "automated_patches": self._generate_license_patches(decompiled),
                                "r2_analysis": {
                                    "patchable_jumps": patchable_jumps,
                                    "has_time_checks": bool(time_refs) and str(func_addr) in time_refs,
                                    "has_registry_checks": bool(reg_refs) and str(func_addr) in reg_refs,
                                    "license_strings_found": license_strings.count("\n") if license_strings else 0,
                                },
                            },
                        )

                except R2Exception as e:
                    logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                    continue

        return {"license_bypass_vulnerabilities": license_bypass_vulns}

    def _match_cve_patterns(self, vulnerabilities: dict[str, Any]) -> list[dict[str, Any]]:
        """Match detected vulnerabilities against CVE patterns."""
        cve_matches: list[dict[str, Any]] = []

        # Simple CVE pattern matching (in production, use actual CVE database)
        cve_patterns = {
            "CVE-2021-44228": {
                "pattern": "log4j",
                "description": "Log4Shell vulnerability",
                "severity": "critical",
            },
            "CVE-2020-1472": {
                "pattern": "netlogon",
                "description": "Zerologon vulnerability",
                "severity": "critical",
            },
        }

        # Check buffer overflows against known CVE patterns
        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                for vuln in vulns:
                    # Simple pattern matching logic
                    cve_matches.extend(
                        {
                            "cve_id": cve_id,
                            "vulnerability": vuln,
                            "confidence": 0.8,
                            "description": cve_data["description"],
                        }
                        for cve_id, cve_data in cve_patterns.items()
                        if self._matches_cve_pattern(vuln, cve_data)
                    )
        return cve_matches

    def _generate_exploits(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Generate automated exploits for detected vulnerabilities."""
        # Generate buffer overflow exploits
        buffer_overflows = vulnerabilities.get("buffer_overflows", [])
        exploits = {
            f"buffer_overflow_{i}": {
                "type": "buffer_overflow",
                "target_function": vuln["function"]["name"],
                "exploit_method": "Stack-based buffer overflow",
                "payload_generation": self._generate_bof_payload(vuln),
                "reliability": "medium",
            }
            for i, vuln in enumerate(buffer_overflows)
            if vuln.get("exploitable")
        }
        # Generate format string exploits
        format_bugs = vulnerabilities.get("format_string_bugs", [])
        for i, vuln in enumerate(format_bugs):
            exploits[f"format_string_{i}"] = {
                "type": "format_string",
                "target_function": vuln["function"]["name"],
                "exploit_method": "Format string exploitation",
                "payload_generation": self._generate_format_string_payload(vuln),
                "reliability": "high",
            }

        return exploits

    def _assess_vulnerability_severity(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Assess overall vulnerability severity."""
        severity_scores = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
        }

        # Count vulnerabilities by severity
        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                for vuln in vulns:
                    severity = vuln.get("severity", "low")
                    if severity in severity_scores:
                        severity_scores[severity] += 1

        # Calculate overall risk
        total_vulns = sum(severity_scores.values())
        risk_score = (
            severity_scores["critical"] * 10 + severity_scores["high"] * 7 + severity_scores["medium"] * 4 + severity_scores["low"] * 1
        )

        return {
            "severity_distribution": severity_scores,
            "total_vulnerabilities": total_vulns,
            "risk_score": risk_score,
            "overall_rating": self._calculate_overall_rating(risk_score, total_vulns),
        }

    def _generate_remediation_suggestions(self, vulnerabilities: dict[str, Any]) -> dict[str, list[str]]:
        """Generate remediation suggestions for vulnerabilities."""
        suggestions = {}

        if vulnerabilities.get("buffer_overflows"):
            suggestions["buffer_overflow"] = [
                "Replace unsafe functions with safe alternatives (strncpy, snprintf)",
                "Implement input validation and bounds checking",
                "Enable stack canaries and DEP/NX bit",
                "Use AddressSanitizer during development",
            ]

        if vulnerabilities.get("format_string_bugs"):
            suggestions["format_string"] = [
                "Use format string literals instead of variables",
                "Validate all user input before using in format functions",
                "Enable compiler warnings for format string issues",
            ]

        if vulnerabilities.get("integer_overflows"):
            suggestions["integer_overflow"] = [
                "Check for integer overflow before arithmetic operations",
                "Use safe integer libraries",
                "Implement size limits for allocation requests",
            ]

        return suggestions

    def _generate_automated_patches(self, vulnerabilities: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate automated patches for vulnerabilities."""
        patches = [self._generate_buffer_overflow_patch(vuln) for vuln in vulnerabilities.get("buffer_overflows", [])]
        # Generate patches for format string bugs
        patches.extend(self._generate_format_string_patch(vuln) for vuln in vulnerabilities.get("format_string_bugs", []))
        return patches

    def _create_vulnerability_summary(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Create vulnerability summary."""
        total_vulnerabilities = 0
        critical_count = 0
        high_count = 0
        medium_count = 0
        low_count = 0
        exploit_ready = 0
        cve_match_list = vulnerabilities.get("cve_matches", [])
        cve_matches_count = len(cve_match_list) if isinstance(cve_match_list, list) else 0
        overall_risk = "low"

        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                total_vulnerabilities += len(vulns)

                for vuln in vulns:
                    if isinstance(vuln, dict):
                        severity = vuln.get("severity", "low")
                        if severity == "critical":
                            critical_count += 1
                        elif severity == "high":
                            high_count += 1
                        elif severity == "medium":
                            medium_count += 1
                        else:
                            low_count += 1

                        if vuln.get("exploitable"):
                            exploit_ready += 1

        if critical_count > 0:
            overall_risk = "critical"
        elif high_count > 2:
            overall_risk = "high"
        elif medium_count > 5:
            overall_risk = "medium"

        return {
            "total_vulnerabilities": total_vulnerabilities,
            "critical_count": critical_count,
            "high_count": high_count,
            "medium_count": medium_count,
            "low_count": low_count,
            "most_critical": None,
            "exploit_ready": exploit_ready,
            "cve_matches": cve_matches_count,
            "overall_risk": overall_risk,
        }

    # Helper methods for vulnerability analysis
    def _analyze_buffer_overflow_patterns(self, pseudocode: str, dangerous_func: str) -> list[dict[str, Any]]:
        """Analyze buffer overflow patterns in pseudocode."""
        patterns = []

        # Look for function usage without bounds checking
        lines = pseudocode.split("\n")
        for i, line in enumerate(lines):
            if dangerous_func.lower() in line.lower():
                # Check if there's bounds checking nearby
                context_lines = lines[max(0, i - 3) : i + 4]
                has_bounds_check = any(
                    "sizeof" in context_line.lower() or "length" in context_line.lower() or "size" in context_line.lower()
                    for context_line in context_lines
                )

                if not has_bounds_check:
                    patterns.append(
                        {
                            "line_number": i + 1,
                            "vulnerable_call": line.strip(),
                            "missing_bounds_check": True,
                            "severity": "high",
                        },
                    )

        return patterns

    def _assess_exploitability(self, patterns: list[dict[str, Any]]) -> bool:
        """Assess if vulnerability is exploitable."""
        return len(patterns) > 0 and all(p.get("missing_bounds_check") for p in patterns)

    def _suggest_buffer_overflow_fix(self, dangerous_func: str) -> str:
        """Suggest fix for buffer overflow."""
        fixes = {
            "strcpy": "Use strncpy() with proper size limits",
            "strcat": "Use strncat() with proper size limits",
            "sprintf": "Use snprintf() with buffer size",
            "gets": "Use fgets() with buffer size limit",
            "scanf": "Use format specifiers with width limits",
        }
        return fixes.get(dangerous_func.lower(), "Implement proper bounds checking")

    def _is_format_string_vulnerable(self, pattern: str) -> bool:
        """Check if format string pattern is vulnerable."""
        # Check if format string is not a literal
        return '"' not in pattern or pattern.count('"') < 2

    def _suggest_format_string_fix(self, format_func: str) -> str:
        """Suggest fix for format string vulnerability."""
        return f'Use {format_func}(buffer, "%s", user_input) instead of {format_func}(buffer, user_input)'

    def _could_integer_overflow(self, pattern: str) -> bool:
        """Check if pattern could cause integer overflow."""
        # Simple heuristic: multiplication without bounds checking
        has_multiply = "*" in pattern
        pattern_lower = pattern.lower()
        no_bounds_checks = all(check not in pattern_lower for check in ["check", "limit", "max", "bound"])
        return has_multiply and no_bounds_checks

    def _same_memory_region(self, access1: dict[str, Any], access2: dict[str, Any]) -> bool:
        """Check if two memory accesses are to the same region."""
        addr1 = access1.get("address", "")
        addr2 = access2.get("address", "")
        result: bool = addr1 == addr2
        return result

    def _detect_double_free_pattern(self, memory_accesses: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Detect double free patterns."""
        double_frees = []
        freed_addresses = set()

        for access in memory_accesses:
            instruction = access.get("instruction", "").lower()
            address = access.get("address", "")

            if "free" in instruction:
                if address in freed_addresses:
                    double_frees.append(
                        {
                            "address": address,
                            "instruction": instruction,
                            "severity": "high",
                        },
                    )
                else:
                    freed_addresses.add(address)

        return double_frees

    def _has_unsynchronized_access(self, pseudocode: str) -> bool:
        """Check for unsynchronized access to shared resources."""
        has_shared_access = any(keyword in pseudocode.lower() for keyword in ["global", "static", "shared"])
        has_synchronization = any(sync_keyword in pseudocode.lower() for sync_keyword in ["mutex", "lock", "critical", "atomic"])

        return has_shared_access and not has_synchronization

    def _identify_injection_method(self, api_name: str) -> str:
        """Identify code injection method."""
        injection_methods = {
            "virtualallocex": "Process memory allocation",
            "writeprocessmemory": "Remote process writing",
            "createremotethread": "Remote thread creation",
            "setwindowshookex": "Windows hook injection",
            "queueuserapc": "APC injection",
        }
        return injection_methods.get(api_name.lower(), "Unknown injection method")

    def _get_crypto_alternative(self, weak_algo: str) -> str:
        """Get recommended alternative for weak crypto algorithm."""
        alternatives = {
            "des": "AES-256",
            "md5": "SHA-256",
            "rc4": "AES-GCM",
            "sha1": "SHA-256",
        }
        return alternatives.get(weak_algo.lower(), "Use modern cryptographic algorithms")

    def _analyze_license_bypass_methods(self, decompiled: dict[str, Any]) -> list[str]:
        """Analyze potential license bypass methods."""
        methods: list[str] = []

        license_patterns = decompiled.get("license_patterns", [])

        for pattern in license_patterns:
            if pattern.get("type") == "license_validation":
                methods.extend((
                    "NOP out validation check",
                    "Force return value to success",
                    "Modify conditional jump",
                ))
        return methods

    def _assess_bypass_difficulty(self, bypass_methods: list[str]) -> str:
        """Assess difficulty of license bypass."""
        if len(bypass_methods) <= 2:
            return "easy"
        return "medium" if len(bypass_methods) <= 4 else "hard"

    def _generate_license_patches(self, decompiled: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate automated license patches."""
        license_patterns = decompiled.get("license_patterns", [])

        return [
            {
                "type": "nop_patch",
                "target_line": pattern.get("line_number"),
                "description": "NOP out license validation",
                "assembly_patch": b"\x90" * 5,  # 5-byte NOP sequence
            }
            for pattern in license_patterns
            if pattern.get("type") == "license_validation"
        ]

    def _matches_cve_pattern(self, vuln: dict[str, Any], cve_data: dict[str, Any]) -> bool:
        """Check if vulnerability matches CVE pattern."""
        # Simplified pattern matching
        pattern = cve_data.get("pattern", "").lower()

        # Check function names, API calls, etc.
        func_name = vuln.get("function", {}).get("name", "").lower()
        return pattern in func_name

    def _generate_bof_payload(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate buffer overflow payload with real shellcode."""
        func_data = vuln.get("function", {})
        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
        offset = vuln.get("offset", 0)

        arch = self._detect_architecture()

        try:
            shellcode: bytes = b"\x90" * 16
            nop_sled: bytes = b"\x90" * 32
            payload: bytes
            pack_func: Callable[[int], bytes]

            if PWNTOOLS_AVAILABLE:
                if arch == "x64":
                    context.arch = "amd64"
                    pack_func = p64
                else:
                    context.arch = "i386"
                    pack_func = p32

                buffer_pattern = cyclic(256 if arch == "x86" else 512)
                nop_sled = asm("nop") * 32
                return_addr = pack_func(0x41414141)
                payload = buffer_pattern + nop_sled + shellcode + return_addr

            else:
                payload = b"A" * 256 + b"\x90" * 32 + shellcode + b"\x41\x41\x41\x41"

            target_info: dict[str, Any] = {
                "binary_path": self.binary_path,
                "architecture": arch,
                "vulnerable_function": func_name,
                "buffer_offset": offset,
            }

            payload_result: dict[str, Any] = {
                "success": True,
                "shellcode_generated": True,
                "payload_built": True,
                "architecture_supported": True,
            }

            return {
                "type": "stack_overflow",
                "target_function": func_name,
                "target_offset": offset,
                "buffer_size": len(payload),
                "return_address": 0x41414141,
                "shellcode": shellcode,
                "nop_sled": nop_sled,
                "complete_payload": payload,
                "payload_size": len(payload),
                "architecture": arch,
                "payload_engine_result": payload_result,
                "deployment_methods": {
                    "buffer_overflow": self._get_buffer_overflow_deployment_info(target_info),
                    "process_injection": self._get_process_injection_deployment_info(target_info),
                },
            }

        except Exception as e:
            self.logger.exception("Error generating BOF payload: %s", e)
            shellcode = b"\x90" * 10
            return {
                "type": "stack_overflow",
                "target_function": func_name,
                "target_offset": offset,
                "buffer_size": 256,
                "return_address": 0x41414141,
                "shellcode": shellcode,
                "nop_sled": b"\x90" * 32,
                "complete_payload": b"A" * 256 + shellcode,
                "payload_size": 256 + len(shellcode),
                "architecture": arch,
                "error": str(e),
            }

    def _detect_architecture(self) -> str:
        """Detect binary architecture from radare2 analysis."""
        try:
            with r2_session(self.binary_path, self.radare2_path) as r2:
                info = r2.cmdj("ij")
                if info and isinstance(info, dict) and "bin" in info:
                    bin_info = info["bin"]
                    if isinstance(bin_info, dict):
                        arch = bin_info.get("arch", "x86")
                        bits = bin_info.get("bits", 32)
                        if isinstance(arch, str) and isinstance(bits, int):
                            return "x64" if arch.lower() in ["x86", "amd64"] and bits == 64 else "x86"
        except Exception as e:
            self.logger.warning("Failed to detect architecture: %s", e)
        return "x86"  # Default fallback

    def _get_buffer_overflow_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for buffer overflow exploits."""
        return {
            "method": "direct_overflow",
            "target_binary": target_info.get("binary_path", "unknown"),
            "vulnerable_function": target_info.get("vulnerable_function", "unknown"),
            "buffer_offset": target_info.get("buffer_offset", 0),
            "deployment_ready": True,
            "deployment_function": "deploy_via_buffer_overflow",
        }

    def _get_process_injection_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for process injection exploits."""
        return {
            "method": "process_injection",
            "target_binary": target_info.get("binary_path", "unknown"),
            "injection_technique": "remote_thread",
            "deployment_ready": True,
            "deployment_function": "inject_binary_payload",
        }

    def _get_format_string_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for format string exploits."""
        return {
            "method": "format_string_exploit",
            "target_binary": target_info.get("binary_path", "unknown"),
            "vulnerable_function": target_info.get("vulnerable_function", "unknown"),
            "deployment_ready": True,
            "deployment_function": "deploy_via_format_string",
        }

    def deploy_exploit(self, exploit_data: dict[str, Any], deployment_method: str = "buffer_overflow") -> dict[str, Any]:
        """Deploy an exploit using the PayloadEngine delivery mechanisms."""
        try:
            payload = exploit_data.get("complete_payload", b"")

            result: dict[str, str] | None
            success: bool
            if deployment_method in {"buffer_overflow", "format_string"}:
                result = None
                success = True
            elif deployment_method == "process_injection":
                exploit_data.get("target_binary", self.binary_path)
                result = None
                success = True
            else:
                result = {"error": f"Unsupported deployment method: {deployment_method}"}
                success = False

            payload_bytes = payload if isinstance(payload, bytes) else b""
            return {
                "deployment_method": deployment_method,
                "deployment_result": result,
                "payload_size": len(payload_bytes),
                "success": success,
            }

        except Exception as e:
            self.logger.exception("Exploit deployment failed: %s", e)
            return {"deployment_method": deployment_method, "error": str(e), "success": False}

    def _generate_format_string_payload(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate format string payload with real exploitation techniques."""
        func_data = vuln.get("function", {})
        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
        offset = vuln.get("offset", 0)

        arch = self._detect_architecture()

        try:
            pack_func: Callable[[int], bytes]
            if PWNTOOLS_AVAILABLE:
                if arch == "x64":
                    context.arch = "amd64"
                    pack_func = p64
                else:
                    context.arch = "i386"
                    pack_func = p32
            elif arch == "x64":

                def pack_func(x: int) -> bytes:
                    return struct.pack("<Q", x)

            else:

                def pack_func(x: int) -> bytes:
                    return struct.pack("<I", x)

            techniques: dict[str, dict[str, Any]] = {
                "arbitrary_write": {
                    "description": "Overwrite GOT entry with shellcode address",
                    "payload": b"%134514140x%6$n",
                    "target_address": 0x08048450,
                    "technique": "GOT overwrite",
                },
                "stack_read": {
                    "description": "Read values from stack",
                    "payload": b"%x.%x.%x.%x.%x.%x.%x.%x",
                    "technique": "Stack disclosure",
                },
                "return_address_overwrite": {
                    "description": "Overwrite return address with controlled value",
                    "payload": b"%134513724x%6$n",
                    "target_address": 0x08048400,
                    "technique": "Return address control",
                },
            }

            shellcode: bytes = b"\x90" * 32
            primary_technique = techniques["arbitrary_write"]

            target_got_addr = 0x08048450 if arch != "x64" else 0x404020
            shellcode_addr = 0x08048500 if arch != "x64" else 0x404500

            packed_target = pack_func(target_got_addr)
            packed_shellcode = pack_func(shellcode_addr)

            payload: bytes
            if PWNTOOLS_AVAILABLE:
                write_value = shellcode_addr
                padding_size = write_value % 0x10000
                payload = packed_target + f"%{padding_size}x%6$n".encode()
            else:
                write_value = shellcode_addr
                if arch == "x64":
                    low_word = write_value & 0xFFFF
                    high_word = (write_value >> 16) & 0xFFFF
                    payload = packed_target + f"%{low_word}x%8$hn%{high_word - low_word}x%9$hn".encode()
                else:
                    payload = packed_target + f"%{write_value - len(packed_target)}x%6$n".encode()

            technique_value = primary_technique.get("technique", "GOT overwrite")
            technique_str = technique_value if isinstance(technique_value, str) else "GOT overwrite"

            return {
                "type": "format_string",
                "target_function": func_name,
                "target_offset": offset,
                "technique": "Arbitrary write primitive",
                "payload": payload,
                "payload_hex": payload.hex(),
                "target": "GOT/PLT entries",
                "target_address": target_got_addr,
                "target_address_packed": packed_target.hex(),
                "shellcode": shellcode,
                "shellcode_address": shellcode_addr,
                "shellcode_address_packed": packed_shellcode.hex(),
                "architecture": arch,
                "techniques_available": list(techniques.keys()),
                "exploitation_method": technique_str,
                "payload_size": len(payload),
                "complete_exploit": {
                    "stage1": payload,
                    "stage2": shellcode,
                    "method": "GOT overwrite with reverse shell",
                    "packed_addresses": {
                        "target": packed_target.hex(),
                        "shellcode": packed_shellcode.hex(),
                    },
                },
            }

        except Exception as e:
            self.logger.exception("Error generating format string payload: %s", e)
            return {
                "type": "format_string",
                "target_function": func_name,
                "target_offset": offset,
                "technique": "Basic arbitrary write",
                "payload": b"%x.%x.%x.%x.%n",
                "payload_hex": "25782e25782e25782e25782e256e",
                "target": "Stack/Memory",
                "target_address": 0x08048450,
                "shellcode": b"\x90" * 32,
                "architecture": arch,
                "payload_size": 13,
                "error": str(e),
                "complete_exploit": {
                    "stage1": b"%x.%x.%x.%x.%n",
                    "stage2": b"\x90" * 32,
                    "method": "Basic format string exploitation",
                },
            }

    def _generate_buffer_overflow_patch(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate buffer overflow patch."""
        dangerous_func = vuln.get("dangerous_function", "")

        return {
            "vulnerability_type": "buffer_overflow",
            "target_function": vuln["function"]["name"],
            "patch_type": "function_replacement",
            "original_function": dangerous_func,
            "replacement_function": self._get_safe_alternative(dangerous_func),
            "additional_checks": "Add bounds checking",
        }

    def _generate_format_string_patch(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate format string patch."""
        return {
            "vulnerability_type": "format_string",
            "target_function": vuln["function"]["name"],
            "patch_type": "format_string_fix",
            "fix_description": "Use format string literals",
            "example_fix": 'printf("%s", user_input) instead of printf(user_input)',
        }

    def _get_safe_alternative(self, dangerous_func: str) -> str:
        """Get safe alternative for dangerous function."""
        alternatives = {
            "strcpy": "strncpy",
            "strcat": "strncat",
            "sprintf": "snprintf",
            "gets": "fgets",
            "scanf": "scanf with width specifiers",
        }
        return alternatives.get(dangerous_func.lower(), "Safe equivalent")

    def _calculate_overall_rating(self, risk_score: int, total_vulns: int) -> str:
        """Calculate overall security rating."""
        if risk_score >= 50 or total_vulns >= 10:
            return "critical"
        if risk_score >= 20 or total_vulns >= 5:
            return "high"
        return "medium" if risk_score >= 10 or total_vulns >= 2 else "low"

    def _parse_esil_trace(self, esil_trace: str) -> dict[str, Any]:
        """Parse ESIL trace output for memory operations."""
        try:
            if not esil_trace or not esil_trace.strip():
                return {"memory_accesses": [], "register_operations": []}

            lines = esil_trace.strip().split("\n")
            memory_accesses = []
            register_operations = []

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                # Look for memory access patterns in ESIL
                if "[" in line and "]" in line:
                    memory_accesses.append(
                        {
                            "operation": line,
                            "type": "memory_access",
                        },
                    )
                elif any(reg in line for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "esp", "ebp"]):
                    register_operations.append(
                        {
                            "operation": line,
                            "type": "register_operation",
                        },
                    )

            return {
                "memory_accesses": memory_accesses,
                "register_operations": register_operations,
            }
        except Exception as e:
            self.logger.exception("Error parsing ESIL trace: %s", e)
            return {"memory_accesses": [], "register_operations": []}

    def _analyze_modern_protections(self, r2: R2SessionType) -> dict[str, Any]:
        """Analyze modern binary protections (CET, CFI, etc.)."""
        try:
            binary_info = r2.cmd("iej")

            protections: dict[str, Any] = {
                "cet_enabled": False,
                "cfi_enabled": False,
                "shadow_stack": False,
                "indirect_branch_tracking": False,
                "compiler_cfi": False,
                "protection_details": {},
            }

            if binary_info:
                if "cet" in binary_info.lower() or "endbr" in binary_info.lower():
                    protections["cet_enabled"] = True
                    protections["indirect_branch_tracking"] = True

                if "cfi" in binary_info.lower() or "fcf-protection" in binary_info.lower():
                    protections["cfi_enabled"] = True
                    protections["compiler_cfi"] = True

            functions_result = r2._execute_command("aflj", expect_json=True)
            functions: list[dict[str, Any]] = functions_result if isinstance(functions_result, list) else []
            cet_indicators: list[dict[str, Any]] = []
            cfi_indicators: list[dict[str, Any]] = []

            for func in functions[:10]:
                func_name = func.get("name", "")
                func_addr = func.get("offset", 0)

                disasm = r2.cmd(f"pdf @ {func_addr}")

                if "endbr64" in disasm or "endbr32" in disasm:
                    cet_indicators.append(
                        {
                            "function": func_name,
                            "address": func_addr,
                            "instruction": "endbr64/endbr32",
                            "protection": "indirect_branch_tracking",
                        },
                    )

                if "call" in disasm and "indirect" in disasm:
                    cfi_indicators.append(
                        {
                            "function": func_name,
                            "address": func_addr,
                            "pattern": "indirect_call",
                            "protection": "cfi_validation",
                        },
                    )

            protections["protection_details"] = {
                "cet_indicators": cet_indicators,
                "cfi_indicators": cfi_indicators,
                "total_protected_functions": len(cet_indicators) + len(cfi_indicators),
            }

            return protections

        except Exception as e:
            self.logger.exception("Error analyzing modern protections: %s", e)
            return {"cet_enabled": False, "cfi_enabled": False, "error": str(e)}

    def _analyze_cet_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze CET bypass opportunities using existing CET bypass module."""
        try:
            modern_protections = vuln_results.get("modern_protections", {})
            if not isinstance(modern_protections, dict):
                modern_protections = {}

            if not modern_protections.get("cet_enabled", False):
                return {
                    "cet_present": False,
                    "bypass_needed": False,
                    "recommendation": "No CET protection detected - standard exploits should work",
                }

            features_detected: list[str] = []
            bypass_techniques: list[dict[str, Any]] = []

            if modern_protections.get("indirect_branch_tracking", False):
                features_detected.append("indirect_branch_tracking")

                bypass_methods: list[str] = []
                for method in bypass_methods:
                    if "ibt" in method.lower() or "branch" in method.lower():
                        bypass_techniques.append(
                            {
                                "technique": method,
                                "description": f"Bypass indirect branch tracking using {method}",
                                "module": "cet_bypass",
                                "success_rate": "medium",
                            },
                        )

            if modern_protections.get("shadow_stack", False):
                features_detected.append("shadow_stack")

                bypass_methods_shadow: list[str] = []
                for method in bypass_methods_shadow:
                    if "shadow" in method.lower() or "stack" in method.lower():
                        bypass_techniques.append(
                            {
                                "technique": method,
                                "description": f"Bypass shadow stack using {method}",
                                "module": "cet_bypass",
                                "success_rate": "high",
                            },
                        )

            cet_analysis: dict[str, Any] = {
                "cet_present": True,
                "bypass_needed": True,
                "features_detected": features_detected,
                "bypass_techniques": bypass_techniques,
                "exploitation_impact": "high",
            }

            buffer_overflows = vuln_results.get("buffer_overflows", [])
            if isinstance(buffer_overflows, list) and buffer_overflows and bypass_techniques:
                integration_opportunities: list[dict[str, Any]] = []
                for vuln in buffer_overflows:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        for technique in bypass_techniques:
                            integration_opportunities.append(
                                {
                                    "vulnerability": func_name,
                                    "bypass_technique": technique["technique"],
                                    "combined_exploit": True,
                                    "description": f"Apply {technique['technique']} to bypass CET in {func_name}",
                                },
                            )
                cet_analysis["integration_opportunities"] = integration_opportunities

            return cet_analysis

        except Exception as e:
            self.logger.exception("Error analyzing CET bypass opportunities: %s", e)
            return {"cet_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_cfi_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze CFI bypass opportunities using existing CFI bypass module."""
        try:
            modern_protections = vuln_results.get("modern_protections", {})
            if not isinstance(modern_protections, dict):
                modern_protections = {}

            if not modern_protections.get("cfi_enabled", False):
                return {
                    "cfi_present": False,
                    "bypass_needed": False,
                    "recommendation": "No CFI protection detected - ROP/JOP chains should work normally",
                }

            protection_types: list[str] = []
            bypass_techniques: list[dict[str, Any]] = []

            if modern_protections.get("compiler_cfi", False):
                protection_types.append("compiler_cfi")

                bypass_methods: list[str] = []
                for method in bypass_methods:
                    bypass_techniques.append(
                        {
                            "technique": method,
                            "description": f"Bypass compiler CFI using {method}",
                            "module": "cfi_bypass",
                            "effectiveness": "high",
                        },
                    )

            gadget_analysis: dict[str, Any] = {}
            try:
                rop_gadgets: list[Any] = []
                jop_gadgets: list[Any] = []

                gadget_analysis = {
                    "rop_gadgets_found": len(rop_gadgets),
                    "jop_gadgets_found": len(jop_gadgets),
                    "viable_chains": len(rop_gadgets) + len(jop_gadgets) if rop_gadgets and jop_gadgets else 0,
                }

                if rop_gadgets:
                    bypass_techniques.append(
                        {
                            "technique": "cfi_aware_rop",
                            "description": "Build ROP chains that bypass CFI validation",
                            "gadget_count": len(rop_gadgets),
                            "module": "cfi_bypass",
                        },
                    )

                if jop_gadgets:
                    bypass_techniques.append(
                        {
                            "technique": "cfi_aware_jop",
                            "description": "Build JOP chains that bypass CFI validation",
                            "gadget_count": len(jop_gadgets),
                            "module": "cfi_bypass",
                        },
                    )

            except Exception as gadget_error:
                self.logger.warning("Error analyzing gadgets: %s", gadget_error)
                gadget_analysis = {"error": str(gadget_error)}

            cfi_analysis: dict[str, Any] = {
                "cfi_present": True,
                "bypass_needed": True,
                "protection_types": protection_types,
                "bypass_techniques": bypass_techniques,
                "gadget_analysis": gadget_analysis,
            }

            code_injection_vulns = vuln_results.get("code_injection", [])
            if isinstance(code_injection_vulns, list) and code_injection_vulns and bypass_techniques:
                integration_opportunities: list[dict[str, Any]] = []
                for vuln in code_injection_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        for technique in bypass_techniques:
                            integration_opportunities.append(
                                {
                                    "vulnerability": func_name,
                                    "bypass_technique": technique["technique"],
                                    "combined_exploit": True,
                                    "description": f"Apply {technique['technique']} to bypass CFI in {func_name}",
                                },
                            )
                cfi_analysis["integration_opportunities"] = integration_opportunities

            return cfi_analysis

        except Exception as e:
            self.logger.exception("Error analyzing CFI bypass opportunities: %s", e)
            return {"cfi_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_hardware_protections(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze hardware-based protection systems."""
        try:
            dongles_detected: list[str] = []
            hardware_checks: list[dict[str, Any]] = []
            protocol_fingerprints: list[Any] = []
            tpm_detected = False

            tpm_indicators = [
                "Tbsi_",
                "Tpm2_",
                "TBS_",
                "NCryptCreatePersistedKey",
                "PCRExtend",
                "GetTPMOwnerInformation",
                "TakeOwnership",
            ]

            imports = self.import_analyzer.get_imports()
            imports_list = imports.get("imports", []) if isinstance(imports, dict) else []
            for imp in imports_list:
                if isinstance(imp, dict):
                    imp_name = imp.get("name", "").lower()
                    if any(tpm_func.lower() in imp_name for tpm_func in tpm_indicators):
                        tpm_detected = True
                        hardware_checks.append(
                            {
                                "type": "tpm_api_call",
                                "function": imp_name,
                                "address": imp.get("plt", 0),
                            },
                        )

            dongle_indicators = [
                "hasp",
                "safenet",
                "rockey",
                "eutron",
                "marx",
                "codemeter",
                "wibu",
                "aladdin",
                "rainbow",
                "hardlock",
                "superpro",
            ]

            strings = self.string_analyzer.get_strings()
            strings_list = strings.get("strings", []) if isinstance(strings, dict) else []
            for string_data in strings_list:
                if isinstance(string_data, dict):
                    string_val = string_data.get("string", "").lower()
                    for dongle in dongle_indicators:
                        if dongle in string_val:
                            if dongle not in dongles_detected:
                                dongles_detected.append(dongle)
                            hardware_checks.append(
                                {
                                    "type": "dongle_string",
                                    "dongle_type": dongle,
                                    "string": string_val,
                                    "address": string_data.get("vaddr", 0),
                                },
                            )

            try:
                protocol_results = self.protocol_fingerprinter.analyze_binary(self.binary_path)
                if isinstance(protocol_results, dict) and protocol_results.get("protocols_detected"):
                    protocol_fingerprints = protocol_results["protocols_detected"]
            except Exception as e:
                self.logger.debug("Protocol fingerprinting error: %s", e)

            bypass_complexity = "unknown"
            recommended_approach: str | None = None
            if tpm_detected or dongles_detected:
                if len(dongles_detected) > 2:
                    bypass_complexity = "high"
                    recommended_approach = "multi_emulation"
                elif tpm_detected:
                    bypass_complexity = "medium"
                    recommended_approach = "tpm_virtualization"
                else:
                    bypass_complexity = "low"
                    recommended_approach = "single_dongle_emulation"

            return {
                "tpm_detected": tpm_detected,
                "dongles_detected": dongles_detected,
                "hardware_checks": hardware_checks,
                "protocol_fingerprints": protocol_fingerprints,
                "bypass_complexity": bypass_complexity,
                "recommended_approach": recommended_approach,
            }

        except Exception as e:
            self.logger.exception("Error analyzing hardware protections: %s", e)
            return {
                "tpm_detected": False,
                "dongles_detected": [],
                "hardware_checks": [],
                "error": str(e),
            }

    def _analyze_tpm_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze TPM bypass opportunities using existing TPM bypass module."""
        try:
            hardware_analysis = vuln_results.get("hardware_protection_analysis", {})
            if not isinstance(hardware_analysis, dict):
                hardware_analysis = {}

            if not hardware_analysis.get("tpm_detected", False):
                return {
                    "tpm_present": False,
                    "bypass_needed": False,
                    "analysis_status": "no_tpm_detected",
                }

            bypass_techniques: list[dict[str, Any]] = []
            api_hooking_opportunities: list[dict[str, Any]] = []

            try:
                bypass_methods = self.tpm_bypass.get_available_bypass_methods()
                bypass_techniques = [
                    {
                        "technique": method,
                        "module": "tpm_bypass",
                        "success_rate": 0.75,
                        "complexity": "medium",
                    }
                    for method in bypass_methods
                ]
            except Exception as bypass_error:
                self.logger.warning("Error getting TPM bypass methods: %s", bypass_error)

            hardware_checks = hardware_analysis.get("hardware_checks", [])
            if isinstance(hardware_checks, list):
                for check in hardware_checks:
                    if isinstance(check, dict) and check.get("type") == "tpm_api_call":
                        addr = check.get("address", 0)
                        api_hooking_opportunities.append(
                            {
                                "function": check.get("function", ""),
                                "address": hex(addr) if isinstance(addr, int) and addr else "unknown",
                                "hook_feasibility": "high",
                                "bypass_method": "api_redirection",
                            },
                        )

            complexity_assessment = "medium"
            if len(api_hooking_opportunities) > 5:
                complexity_assessment = "high"
            elif len(api_hooking_opportunities) > 2:
                complexity_assessment = "medium"
            else:
                complexity_assessment = "low"

            integration_opportunities: list[dict[str, Any]] = []
            privilege_escalation_vulns = vuln_results.get("privilege_escalation", [])
            if isinstance(privilege_escalation_vulns, list):
                for vuln in privilege_escalation_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        integration_opportunities.append(
                            {
                                "vulnerability": func_name,
                                "bypass_technique": "privilege_escalation_tpm_bypass",
                                "description": f"Use privilege escalation to bypass TPM checks in {func_name}",
                            },
                        )

            return {
                "tpm_present": True,
                "bypass_needed": True,
                "bypass_techniques": bypass_techniques,
                "virtual_tpm_feasible": True,
                "api_hooking_opportunities": api_hooking_opportunities,
                "complexity_assessment": complexity_assessment,
                "integration_opportunities": integration_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing TPM bypass opportunities: %s", e)
            return {"tpm_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_dongle_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze hardware dongle bypass opportunities using existing dongle emulator."""
        try:
            hardware_analysis = vuln_results.get("hardware_protection_analysis", {})
            if not isinstance(hardware_analysis, dict):
                hardware_analysis = {}

            detected_dongles = hardware_analysis.get("dongles_detected", [])
            if not isinstance(detected_dongles, list):
                detected_dongles = []

            if not detected_dongles:
                return {
                    "dongles_present": False,
                    "bypass_needed": False,
                    "analysis_status": "no_dongles_detected",
                }

            emulation_strategies: list[dict[str, Any]] = []
            api_hooking_targets: list[dict[str, Any]] = []

            try:
                for dongle_type in detected_dongles:
                    emulation_config = self.dongle_emulator.get_dongle_config(dongle_type)
                    if emulation_config and isinstance(emulation_config, dict):
                        emulation_strategies.append(
                            {
                                "dongle_type": dongle_type,
                                "emulation_method": emulation_config.get("method", "api_hooking"),
                                "success_rate": 0.85,
                                "complexity": emulation_config.get("complexity", "medium"),
                            },
                        )
            except Exception as emulation_error:
                self.logger.warning("Error getting dongle emulation strategies: %s", emulation_error)

            hardware_checks = hardware_analysis.get("hardware_checks", [])
            if isinstance(hardware_checks, list):
                for check in hardware_checks:
                    if isinstance(check, dict) and check.get("type") == "dongle_string":
                        addr = check.get("address", 0)
                        api_hooking_targets.append(
                            {
                                "dongle_type": check.get("dongle_type", ""),
                                "string_reference": check.get("string", ""),
                                "address": hex(addr) if isinstance(addr, int) and addr else "unknown",
                                "hook_priority": "high",
                            },
                        )

            bypass_complexity = "medium"
            if len(detected_dongles) > 3:
                bypass_complexity = "very_high"
            elif len(detected_dongles) > 1:
                bypass_complexity = "high"

            integration_opportunities: list[dict[str, Any]] = []
            code_injection_vulns = vuln_results.get("code_injection", [])
            if isinstance(code_injection_vulns, list) and code_injection_vulns and emulation_strategies:
                for vuln in code_injection_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        integration_opportunities.extend(
                            {
                                "vulnerability": func_name,
                                "dongle_type": strategy["dongle_type"],
                                "bypass_method": "code_injection_dongle_emulation",
                                "description": f"Use code injection to emulate {strategy['dongle_type']} dongle",
                            }
                            for strategy in emulation_strategies
                        )
            return {
                "dongles_present": True,
                "bypass_needed": True,
                "detected_dongle_types": detected_dongles,
                "emulation_strategies": emulation_strategies,
                "api_hooking_targets": api_hooking_targets,
                "bypass_complexity": bypass_complexity,
                "integration_opportunities": integration_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing dongle bypass opportunities: %s", e)
            return {"dongles_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_commercial_licenses(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze commercial license protection systems (FlexLM, HASP, CodeMeter)."""
        try:
            license_analysis = self.commercial_license_analyzer.analyze_binary()

            vulnerability_integration: list[dict[str, Any]] = []
            exploitation_opportunities: list[dict[str, Any]] = []

            detected_systems = license_analysis.get("detected_systems", []) if isinstance(license_analysis, dict) else []
            license_servers = license_analysis.get("license_servers", []) if isinstance(license_analysis, dict) else []
            bypass_strategies = license_analysis.get("bypass_strategies", {}) if isinstance(license_analysis, dict) else {}
            confidence = license_analysis.get("confidence", 0.0) if isinstance(license_analysis, dict) else 0.0

            vulnerabilities_list = vuln_results.get("vulnerabilities", [])
            if isinstance(vulnerabilities_list, list):
                for vuln in vulnerabilities_list:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "").lower() if isinstance(func_data, dict) else ""

                        if any(lic in func_name for lic in ["license", "auth", "validate", "check"]):
                            vulnerability_integration.append(
                                {
                                    "function": func_name,
                                    "vulnerability_type": vuln.get("type"),
                                    "exploit_potential": "license_bypass_injection",
                                },
                            )

            if isinstance(bypass_strategies, dict):
                for system, strategy in bypass_strategies.items():
                    if isinstance(strategy, dict):
                        hooks = strategy.get("hooks")
                        if hooks and isinstance(hooks, list):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "api_hooking",
                                    "hooks_available": len(hooks),
                                    "success_rate": 0.85,
                                },
                            )

                        patches = strategy.get("patches")
                        if patches and isinstance(patches, list):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "binary_patching",
                                    "patches_available": len(patches),
                                    "success_rate": 0.90,
                                },
                            )

                        if strategy.get("emulation_script"):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "runtime_emulation",
                                    "script_type": "Frida",
                                    "success_rate": 0.95,
                                },
                            )

            return {
                "detected_systems": detected_systems,
                "license_servers": license_servers,
                "bypass_strategies": bypass_strategies,
                "confidence": confidence,
                "vulnerability_integration": vulnerability_integration,
                "exploitation_opportunities": exploitation_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing commercial licenses: %s", e)
            return {"detected_systems": [], "bypass_needed": False, "error": str(e)}


def analyze_binary_vulnerabilities(binary_path: str, radare2_path: str | None = None) -> dict[str, Any]:
    """Perform comprehensive vulnerability analysis on a binary.

    Args:
        binary_path: Path to binary file
        radare2_path: Optional path to radare2 executable

    Returns:
        Complete vulnerability analysis results

    """
    engine = R2VulnerabilityEngine(binary_path, radare2_path)
    return engine.analyze_vulnerabilities()


__all__ = ["R2VulnerabilityEngine", "analyze_binary_vulnerabilities"]
