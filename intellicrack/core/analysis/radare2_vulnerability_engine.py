"""Radare2 vulnerability analysis engine for identifying security issues."""

import logging
import re
import struct
from typing import TYPE_CHECKING, Any


try:
    from pwn import asm, context, cyclic, p32, p64

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False

from intellicrack.utils.logger import logger

from ...utils.tools.radare2_utils import R2Exception, R2Session, R2SessionPoolAdapter, r2_session
from ..protection_bypass.dongle_emulator import HardwareDongleEmulator
from ..protection_bypass.tpm_bypass import TPMProtectionBypass
from .commercial_license_analyzer import CommercialLicenseAnalyzer
from .radare2_decompiler import R2DecompilationEngine
from .radare2_esil import ESILAnalysisEngine
from .radare2_imports import R2ImportExportAnalyzer
from .radare2_strings import R2StringAnalyzer


if TYPE_CHECKING:
    from collections.abc import Callable

R2SessionType = R2Session | R2SessionPoolAdapter


logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Module loading started")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] About to import pwntools...")
if PWNTOOLS_AVAILABLE:
    logger.debug("%s", "[DEBUG radare2_vulnerability_engine] pwntools imported OK")
else:
    logger.debug("%s", "[DEBUG radare2_vulnerability_engine] pwntools not available (ImportError)")
logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Starting other imports...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] logger imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_utils...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_utils imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Using lazy import for protocol_fingerprinter to avoid circular dependency")


def _get_protocol_fingerprinter() -> type[Any]:
    """Lazy import ProtocolFingerprinter to avoid circular import.

    Returns:
        ProtocolFingerprinter class for protocol analysis.

    """
    from ..network.protocol_fingerprinter import ProtocolFingerprinter

    protocol_class: type[Any] = ProtocolFingerprinter
    return protocol_class


logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing dongle_emulator...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] dongle_emulator imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing tpm_bypass...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] tpm_bypass imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing commercial_license_analyzer...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] commercial_license_analyzer imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_decompiler...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_decompiler imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_esil...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_esil imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_imports...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_imports imported OK")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] Importing radare2_strings...")

logger.debug("%s", "[DEBUG radare2_vulnerability_engine] radare2_strings imported OK")

"""
Radare2 Advanced Vulnerability Detection Engine

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""


class R2VulnerabilityEngine:
    """Advanced vulnerability detection engine combining all radare2 analysis capabilities.

    Provides comprehensive vulnerability detection through:
    - Static code analysis via decompilation
    - Dynamic analysis via ESIL emulation
    - Pattern recognition in strings and imports
    - Cross-reference analysis
    - Automated exploit generation
    - CVE pattern matching
    """

    def __init__(self, binary_path: str, radare2_path: str | None = None) -> None:
        """Initialize vulnerability detection engine.

        Args:
            binary_path: Path to binary file
            radare2_path: Optional path to radare2 executable

        """
        self.binary_path = binary_path
        self.radare2_path = radare2_path
        self.logger = logging.getLogger(__name__)

        # Initialize sub-engines
        self.decompiler = R2DecompilationEngine(binary_path, radare2_path)
        self.esil_engine = ESILAnalysisEngine(binary_path, radare2_path)
        self.string_analyzer = R2StringAnalyzer(binary_path, radare2_path)
        self.import_analyzer = R2ImportExportAnalyzer(binary_path, radare2_path)

        # Initialize hardware protection modules
        self.tpm_bypass = TPMProtectionBypass()
        self.dongle_emulator = HardwareDongleEmulator()
        self._protocol_fingerprinter: Any = None

        # Initialize commercial license analyzer
        self.commercial_license_analyzer = CommercialLicenseAnalyzer(binary_path)
        self.commercial_analyzer = self.commercial_license_analyzer  # Alias for compatibility

        # Vulnerability patterns database
        self.vulnerability_patterns = self._load_vulnerability_patterns()

    @property
    def protocol_fingerprinter(self) -> Any:
        """Lazy load ProtocolFingerprinter to avoid circular import.

        Returns:
            ProtocolFingerprinter instance for protocol analysis.

        """
        if self._protocol_fingerprinter is None:
            protocol_fingerprinter_class = _get_protocol_fingerprinter()
            self._protocol_fingerprinter = protocol_fingerprinter_class()
        return self._protocol_fingerprinter

    def analyze_vulnerabilities(self) -> dict[str, Any]:
        """Perform comprehensive vulnerability analysis.

        Returns:
            Complete vulnerability analysis results

        """
        result: dict[str, Any] = {
            "binary_path": self.binary_path,
            "vulnerability_summary": {},
            "buffer_overflows": [],
            "format_string_bugs": [],
            "integer_overflows": [],
            "use_after_free": [],
            "double_free": [],
            "null_pointer_dereferences": [],
            "race_conditions": [],
            "privilege_escalation": [],
            "code_injection": [],
            "modern_protections": {},
            "cet_bypass_analysis": {},
            "cfi_bypass_analysis": {},
            "hardware_protection_analysis": {},
            "tpm_bypass_analysis": {},
            "dongle_bypass_analysis": {},
            "commercial_license_analysis": {},
            "path_traversal": [],
            "information_disclosure": [],
            "cryptographic_weaknesses": [],
            "license_bypass_vulnerabilities": [],
            "cve_matches": [],
            "exploit_generation": {},
            "severity_assessment": {},
            "remediation_suggestions": {},
            "automated_patches": [],
        }

        try:
            with r2_session(self.binary_path, self.radare2_path) as r2:
                functions = r2.get_functions()

                buffer_overflow_results = self._detect_buffer_overflows(r2, functions)
                result["buffer_overflows"] = buffer_overflow_results.get("buffer_overflows", [])

                format_string_results = self._detect_format_string_bugs(r2, functions)
                result["format_string_bugs"] = format_string_results.get("format_string_bugs", [])

                integer_overflow_results = self._detect_integer_overflows(r2, functions)
                result["integer_overflows"] = integer_overflow_results.get("integer_overflows", [])

                memory_corruption_results = self._detect_memory_corruption(r2, functions)
                result["use_after_free"] = memory_corruption_results.get("use_after_free", [])
                result["double_free"] = memory_corruption_results.get("double_free", [])

                race_condition_results = self._detect_race_conditions(r2, functions)
                result["race_conditions"] = race_condition_results.get("race_conditions", [])

                privilege_escalation_results = self._detect_privilege_escalation(r2, functions)
                result["privilege_escalation"] = privilege_escalation_results.get("privilege_escalation", [])

                code_injection_results = self._detect_code_injection(r2, functions)
                result["code_injection"] = code_injection_results.get("code_injection", [])

                path_traversal_results = self._detect_path_traversal(r2, functions)
                result["path_traversal"] = path_traversal_results.get("path_traversal", [])

                info_disclosure_results = self._detect_information_disclosure(r2, functions)
                result["information_disclosure"] = info_disclosure_results.get("information_disclosure", [])

                crypto_weakness_results = self._detect_crypto_weaknesses(r2, functions)
                result["cryptographic_weaknesses"] = crypto_weakness_results.get("cryptographic_weaknesses", [])

                license_bypass_results = self._detect_license_bypass_vulns(r2, functions)
                result["license_bypass_vulnerabilities"] = license_bypass_results.get("license_bypass_vulnerabilities", [])

                result["modern_protections"] = self._analyze_modern_protections(r2)
                result["cet_bypass_analysis"] = self._analyze_cet_bypass_opportunities(r2, result)
                result["cfi_bypass_analysis"] = self._analyze_cfi_bypass_opportunities(r2, result)

                result["hardware_protection_analysis"] = self._analyze_hardware_protections(r2, result)
                result["tpm_bypass_analysis"] = self._analyze_tpm_bypass_opportunities(r2, result)
                result["dongle_bypass_analysis"] = self._analyze_dongle_bypass_opportunities(r2, result)

                result["commercial_license_analysis"] = self._analyze_commercial_licenses(r2, result)
                result["commercial_licenses"] = result["commercial_license_analysis"]

                result["cve_matches"] = self._match_cve_patterns(result)

                result["exploit_generation"] = self._generate_exploits(result)

                result["severity_assessment"] = self._assess_vulnerability_severity(result)

                result["remediation_suggestions"] = self._generate_remediation_suggestions(result)

                result["automated_patches"] = self._generate_automated_patches(result)

                result["vulnerability_summary"] = self._create_vulnerability_summary(result)

        except R2Exception as e:
            result["error"] = str(e)
            self.logger.exception("Vulnerability analysis failed: %s", e)

        return result

    def find_vulnerabilities(self) -> dict[str, Any]:
        """Provide API compatibility by delegating to analyze_vulnerabilities.

        Returns:
            Complete vulnerability analysis results.

        """
        return self.analyze_vulnerabilities()

    def _load_vulnerability_patterns(self) -> dict[str, Any]:
        """Load vulnerability pattern database.

        Returns:
            Dictionary of vulnerability patterns with detection rules.

        """
        return {
            "buffer_overflow": {
                "functions": ["strcpy", "strcat", "sprintf", "gets", "scanf", "strncpy"],
                "patterns": [
                    r"strcpy\s*\([^,]+,\s*[^)]+\)",
                    r"sprintf\s*\([^,]+,\s*[^,]+,.*\)",
                    r"gets\s*\([^)]+\)",
                    r"memcpy\s*\([^,]+,\s*[^,]+,\s*[^)]+\)",
                ],
                "severity": "high",
            },
            "format_string": {
                "functions": ["printf", "fprintf", "sprintf", "snprintf", "syslog"],
                "patterns": [
                    r'printf\s*\(\s*[^"]*[^,\s]+\s*\)',
                    r'fprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)',
                    r'sprintf\s*\([^,]*,\s*[^"]*[^,\s]+\s*\)',
                ],
                "severity": "high",
            },
            "integer_overflow": {
                "functions": ["malloc", "calloc", "realloc", "new"],
                "patterns": [
                    r"malloc\s*\(\s*[^)]*\*[^)]*\)",
                    r"calloc\s*\([^,]*,\s*[^)]*\*[^)]*\)",
                    r"new\s+\w+\[[^]]*\*[^]]*\]",
                ],
                "severity": "medium",
            },
            "use_after_free": {
                "functions": ["free", "delete"],
                "patterns": [
                    r"free\s*\([^)]+\).*(?:(?!\bfree\b).)*\1",
                    r"delete\s+[^;]+;.*(?:(?!\bdelete\b).)*\1",
                ],
                "severity": "high",
            },
            "race_condition": {
                "functions": ["CreateThread", "pthread_create", "_beginthread"],
                "patterns": [
                    r"(?:CreateThread|pthread_create).*(?:shared|global).*variable",
                    r"(?:mutex|lock).*(?:unlock).*(?:access|modify)",
                ],
                "severity": "medium",
            },
        }

    def _detect_buffer_overflows(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect buffer overflow vulnerabilities in binary functions.

        Analyzes binary functions to identify dangerous function calls like strcpy
        and sprintf that can lead to buffer overflow vulnerabilities. Uses radare2
        disassembly and decompilation to correlate dangerous function usage with
        vulnerable patterns in the pseudocode.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "buffer_overflows" key containing list of detected
            buffer overflow vulnerabilities with patterns, severity, and fix suggestions.

        """
        buffer_overflows = []

        dangerous_functions = self.vulnerability_patterns["buffer_overflow"]["functions"]

        for func in functions[:50]:  # Analyze first 50 functions for performance
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function disassembly
                disasm = r2._execute_command(f"pdf @ {hex(func_addr)}")
                if not isinstance(disasm, str):
                    continue

                # Check for dangerous function calls
                for dangerous_func in dangerous_functions:
                    if dangerous_func.lower() in disasm.lower():
                        # Get more context through decompilation
                        decompiled = self.decompiler.decompile_function(func_addr)

                        if decompiled.get("pseudocode"):
                            if patterns := self._analyze_buffer_overflow_patterns(
                                decompiled["pseudocode"],
                                dangerous_func,
                            ):
                                buffer_overflows.append(
                                    {
                                        "function": func,
                                        "dangerous_function": dangerous_func,
                                        "patterns": patterns,
                                        "severity": "high",
                                        "exploitable": self._assess_exploitability(patterns),
                                        "decompiled_code": decompiled["pseudocode"],
                                        "suggested_fix": self._suggest_buffer_overflow_fix(dangerous_func),
                                    },
                                )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"buffer_overflows": buffer_overflows}

    def _detect_format_string_bugs(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect format string vulnerabilities in binary functions.

        Scans functions for dangerous format string function calls like printf
        and fprintf that use user-controlled format strings. Performs both static
        analysis via decompilation and assembly-level analysis via radare2 commands
        to identify vulnerable patterns.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "format_string_bugs" key containing list of detected
            format string vulnerabilities with exploit methods and suggested fixes.

        """
        format_string_bugs = []

        format_functions = self.vulnerability_patterns["format_string"]["functions"]

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get assembly code for additional analysis
                asm_code_result = r2._execute_command(f"pdf @ {hex(func_addr)}")
                asm_code = asm_code_result if isinstance(asm_code_result, str) else ""

                # Decompile function to analyze format string usage
                decompiled = self.decompiler.decompile_function(func_addr)
                pseudocode = decompiled.get("pseudocode", "")

                if pseudocode or asm_code:
                    # Check for format string vulnerabilities in pseudocode
                    for format_func in format_functions:
                        patterns = re.findall(
                            rf"{format_func}\s*\([^)]*\)",
                            pseudocode,
                            re.IGNORECASE,
                        )

                        for pattern in patterns:
                            # Check if format string is user-controlled
                            if self._is_format_string_vulnerable(pattern):
                                format_string_bugs.append(
                                    {
                                        "function": func,
                                        "format_function": format_func,
                                        "vulnerable_call": pattern,
                                        "severity": "high",
                                        "exploit_method": "Format string exploitation",
                                        "suggested_fix": self._suggest_format_string_fix(format_func),
                                    },
                                )

                # Also check assembly code for format string calls
                if asm_code:
                    for format_func in format_functions:
                        if format_func.lower() in asm_code.lower():
                            # Use r2 to get cross-references for this function call
                            try:
                                if xrefs := r2._execute_command(
                                    f"axtj @ sym.imp.{format_func}",
                                    expect_json=True,
                                ):
                                    format_string_bugs.append(
                                        {
                                            "function": func,
                                            "format_function": format_func,
                                            "vulnerable_call": f"ASM call to {format_func}",
                                            "severity": "medium",
                                            "exploit_method": "Assembly-level format string",
                                            "suggested_fix": self._suggest_format_string_fix(format_func),
                                            "cross_references": len(xrefs) if isinstance(xrefs, list) else 1,
                                        },
                                    )
                            except Exception as e:
                                logger.exception("Exception in radare2_vulnerability_engine: %s", e)

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"format_string_bugs": format_string_bugs}

    def _detect_integer_overflows(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect integer overflow vulnerabilities in binary functions.

        Identifies integer overflow conditions in memory allocation routines by
        analyzing multiplication operations before malloc/calloc calls. Uses radare2
        binary pattern matching to find multiplication instructions and memory
        allocation sequences, then correlates with decompiled pseudocode.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "integer_overflows" key containing list of detected
            integer overflow vulnerabilities with complexity metrics and fix suggestions.

        """
        integer_overflows = []

        # Use r2 to search for integer overflow patterns
        try:
            # Search for multiplication operations before allocation
            mul_patterns = r2.cmd("/x 0faf")  # IMUL instruction
            add_patterns = r2.cmd("/x 4801")  # ADD with potential overflow

            # Get all malloc/calloc calls
            malloc_calls = r2.cmd("axt @ sym.imp.malloc")
            calloc_calls = r2.cmd("axt @ sym.imp.calloc")

        except Exception as e:
            self.logger.debug("Failed to search for integer overflow patterns: %s", e)
            mul_patterns = add_patterns = malloc_calls = calloc_calls = ""

        allocation_functions = self.vulnerability_patterns["integer_overflow"]["functions"]

        # Analyze patterns for potential vulnerabilities
        pattern_results = {
            "multiplication_patterns": len(mul_patterns.split("\n")) if mul_patterns else 0,
            "addition_patterns": len(add_patterns.split("\n")) if add_patterns else 0,
            "malloc_calls": len(malloc_calls.split("\n")) if malloc_calls else 0,
            "calloc_calls": len(calloc_calls.split("\n")) if calloc_calls else 0,
        }

        self.logger.debug("Integer overflow analysis: %s", pattern_results)

        # Use allocation_functions to filter dangerous patterns
        if any(func in allocation_functions for func in ["malloc", "calloc", "realloc"]):
            pass

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze function for integer overflow
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check if this function has multiplication near malloc/calloc
                has_mul_before_alloc = False
                if ("imul" in func_asm or "mul" in func_asm) and any(alloc in func_asm for alloc in ["malloc", "calloc", "realloc"]):
                    has_mul_before_alloc = True

                # Use r2 to check for integer overflow checks
                overflow_checks = r2.cmd(f'pdf @ {func_addr} | grep -E "jo|jno|jc|jnc"')
                has_overflow_check = bool(overflow_checks)

                # Get function complexity
                func_info = r2.cmd(f"afij @ {func_addr}")

                # Parse function info for complexity analysis
                complexity_info = {}
                try:
                    import json

                    if func_info.strip():
                        parsed_info = json.loads(func_info)
                        if isinstance(parsed_info, list) and len(parsed_info) > 0:
                            func_data = parsed_info[0]
                            complexity_info = {
                                "complexity": func_data.get("cc", 0),
                                "size": func_data.get("size", 0),
                                "instructions": func_data.get("ninstr", 0),
                            }
                except Exception as e:
                    self.logger.debug("Failed to parse function info: %s", e)
                    complexity_info = {"complexity": 0, "size": 0, "instructions": 0}

                # Decompile for detailed analysis
                decompiled = self.decompiler.decompile_function(func_addr)
                if pseudocode := decompiled.get("pseudocode", ""):
                    # Look for multiplication in allocation size
                    patterns = re.findall(
                        r"(malloc|calloc|realloc)\s*\([^)]*\*[^)]*\)",
                        pseudocode,
                        re.IGNORECASE,
                    )

                    for pattern in patterns:
                        # Check if multiplication could overflow
                        if self._could_integer_overflow(pattern):
                            # Enhanced analysis with r2 info
                            severity = "high" if has_mul_before_alloc and not has_overflow_check else "medium"

                            integer_overflows.append(
                                {
                                    "function": func,
                                    "allocation_call": pattern,
                                    "severity": severity,
                                    "risk_factor": "Integer overflow in allocation size",
                                    "has_overflow_check": has_overflow_check,
                                    "r2_analysis": {
                                        "has_multiplication": has_mul_before_alloc,
                                        "has_overflow_protection": has_overflow_check,
                                        "allocation_in_function": True,
                                    },
                                    "complexity_info": complexity_info,
                                    "suggested_fix": "Add bounds checking before multiplication",
                                },
                            )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"integer_overflows": integer_overflows}

    def _detect_memory_corruption(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect use-after-free and double-free memory corruption vulnerabilities.

        Analyzes memory operations to identify use-after-free and double-free
        conditions by tracking free() calls and subsequent memory accesses. Uses
        radare2 assembly analysis and ESIL emulation for dynamic memory tracking
        to correlate freed objects with post-free access patterns.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "use_after_free" and "double_free" keys containing
            lists of detected memory corruption vulnerabilities with exploit status.

        """
        use_after_free = []
        double_free = []

        # Use r2 to search for memory corruption patterns
        try:
            # Search for free calls
            free_xrefs = r2.cmd("axt @ sym.imp.free")

            # Search for common UAF patterns
            mov_after_call = r2.cmd("/x e8........48")  # call followed by mov

            # Get heap-related functions
            heap_funcs = r2.cmd("afl~malloc|free|realloc|calloc")

        except Exception as e:
            self.logger.debug("Failed to search for memory corruption patterns: %s", e)
            free_xrefs = mov_after_call = heap_funcs = ""

        # Analyze memory corruption patterns
        corruption_patterns = {
            "free_references": len(free_xrefs.split("\n")) if free_xrefs else 0,
            "potential_uaf_patterns": len(mov_after_call.split("\n")) if mov_after_call else 0,
            "heap_functions": len(heap_funcs.split("\n")) if heap_funcs else 0,
        }

        self.logger.debug("Memory corruption analysis: %s", corruption_patterns)

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Use r2 to analyze memory operations in function
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Track free operations and subsequent memory accesses
                free_calls = []
                memory_accesses_after_free = []

                lines = func_asm.split("\n")
                for i, line in enumerate(lines):
                    if "call sym.imp.free" in line:
                        free_calls.append((i, line))

                        # Check for memory access after free
                        for j in range(i + 1, min(i + 20, len(lines))):
                            if any(pattern in lines[j] for pattern in ["mov", "lea", "push", "pop"]) and any(
                                reg in lines[j] for reg in ["rdi", "rsi", "rdx", "rcx"] if reg in line
                            ):
                                memory_accesses_after_free.append((j, lines[j]))

                # Use r2 ESIL for more detailed analysis
                esil_result = None
                try:
                    # Initialize ESIL for this function
                    r2.cmd(f"s {func_addr}")
                    r2.cmd("aei")  # Initialize ESIL VM
                    r2.cmd("aeim")  # Initialize ESIL memory

                    # Emulate function with ESIL
                    esil_trace = r2.cmd(f"aetr @ {func_addr}")

                    # Parse ESIL trace for memory operations
                    esil_result = self._parse_esil_trace(esil_trace)
                except Exception:
                    # Fallback to static analysis
                    esil_result = self.esil_engine.emulate_function_execution(func_addr, max_steps=100)

                # Analyze memory access patterns
                memory_accesses = esil_result.get("memory_accesses", []) if esil_result else []

                # Track free operations
                free_operations = []
                access_after_free = []

                for access in memory_accesses:
                    instruction = access.get("instruction", "").lower()

                    if "free" in instruction:
                        free_operations.append(access)
                    elif free_operations and any(self._same_memory_region(access, free_op) for free_op in free_operations):
                        access_after_free.append(access)

                if access_after_free:
                    use_after_free.append(
                        {
                            "function": func,
                            "free_operations": free_operations,
                            "access_after_free": access_after_free,
                            "severity": "high",
                            "exploitable": True,
                            "r2_analysis": {
                                "free_calls_found": len(free_calls),
                                "accesses_after_free": len(memory_accesses_after_free),
                                "esil_emulated": esil_result is not None,
                            },
                        },
                    )
                elif memory_accesses_after_free:
                    # Add r2 static analysis results
                    use_after_free.append(
                        {
                            "function": func,
                            "free_operations": free_calls,
                            "access_after_free": memory_accesses_after_free,
                            "severity": "medium",
                            "exploitable": True,
                            "r2_static_analysis": True,
                        },
                    )

                if double_frees := self._detect_double_free_pattern(memory_accesses):
                    double_free.extend(double_frees)

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {
            "use_after_free": use_after_free,
            "double_free": double_free,
        }

    def _detect_race_conditions(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect race condition vulnerabilities in multithreaded code.

        Identifies race conditions by detecting threading function calls and
        analyzing patterns of shared resource access without synchronization.
        Scans for CreateThread, pthread_create and similar threading APIs,
        then checks for unsynchronized access to shared memory regions.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "race_conditions" key containing list of detected
            race condition vulnerabilities with suggested synchronization fixes.

        """
        race_conditions = []

        # Look for threading functions
        threading_functions = ["CreateThread", "pthread_create", "_beginthread", "std::thread"]

        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                disasm_result = r2._execute_command(f"pdf @ {hex(func_addr)}")
                if not isinstance(disasm_result, str):
                    continue
                disasm = disasm_result

                # Check for threading patterns
                has_threading = any(thread_func.lower() in disasm.lower() for thread_func in threading_functions)

                if has_threading:
                    # Check for shared resource access without synchronization
                    decompiled = self.decompiler.decompile_function(func_addr)
                    pseudocode = decompiled.get("pseudocode", "")

                    if self._has_unsynchronized_access(pseudocode):
                        race_conditions.append(
                            {
                                "function": func,
                                "threading_detected": True,
                                "unsynchronized_access": True,
                                "severity": "medium",
                                "suggested_fix": "Add proper synchronization (mutex/lock)",
                            },
                        )

            except R2Exception as e:
                logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                continue

        return {"race_conditions": race_conditions}

    def _detect_privilege_escalation(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect privilege escalation vulnerabilities in binary code.

        Identifies privilege escalation opportunities by analyzing imports for
        dangerous APIs like AdjustTokenPrivileges, setuid, and capability-related
        functions. Correlates dangerous API usage with assembly patterns that
        suggest elevation of privileges or direct privilege manipulation.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "privilege_escalation" key containing list of detected
            privilege escalation vulnerabilities with API names and descriptions.

        """
        privilege_escalation: list[dict[str, Any]] = []

        # Get imports to check for privilege-related APIs
        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        priv_apis = [
            "AdjustTokenPrivileges",
            "ImpersonateLoggedOnUser",
            "SetThreadToken",
            "LookupPrivilegeValue",
            "OpenProcessToken",
            "DuplicateToken",
        ]

        found_priv_apis = [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in priv_apis)]

        # Check for Unix privilege escalation functions
        setuid_refs = [imp for imp in imports if "setuid" in imp.get("name", "").lower()]
        setgid_refs = [imp for imp in imports if "setgid" in imp.get("name", "").lower()]
        priv_apis_search = [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in priv_apis)]
        cap_refs = [imp for imp in imports if "cap_" in imp.get("name", "").lower() or "capability" in imp.get("name", "").lower()]

        if found_priv_apis:
            privilege_escalation.extend(
                {
                    "api": api,
                    "type": "privilege_manipulation",
                    "severity": "high",
                    "description": "Direct privilege manipulation detected",
                    "r2_analysis": {
                        "setuid_calls": bool(setuid_refs),
                        "setgid_calls": bool(setgid_refs),
                        "token_apis": bool(priv_apis_search),
                        "capability_apis": bool(cap_refs),
                    },
                }
                for api in found_priv_apis
            )
        # Use r2 to analyze functions for privilege escalation patterns
        for func in functions[:30]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function disassembly
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check for setuid/setgid calls
                if ("setuid" in func_asm or "setgid" in func_asm) and ("push 0" in func_asm or "xor" in func_asm):
                    privilege_escalation.append(
                        {
                            "type": "setuid_to_root",
                            "function": func,
                            "severity": "high",
                            "description": "Function appears to escalate to root privileges",
                        },
                    )

                # Check for unsafe system calls
                if "system" in func_asm or "execve" in func_asm:
                    # Check if input is controlled
                    func_xrefs = r2.cmd(f"axtj @ {func_addr}")
                    if "user" in str(func_xrefs).lower() or "input" in str(func_xrefs).lower():
                        privilege_escalation.append(
                            {
                                "type": "command_injection_risk",
                                "function": func,
                                "severity": "high",
                                "description": "System call with potential user input",
                            },
                        )

            except Exception as e:
                self.logger.debug("Failed to analyze function %s: %s", func_addr, e)

        return {"privilege_escalation": privilege_escalation}

    def _detect_code_injection(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect code injection and process injection vulnerabilities.

        Identifies code injection vulnerabilities by analyzing imports for
        dangerous APIs like VirtualAllocEx and WriteProcessMemory that enable
        process injection attacks. Uses radare2 pattern matching to detect
        shellcode patterns and NOP sleds that indicate injected code.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "code_injection" key containing list of detected
            code injection vulnerabilities with injection methods and exploitability.

        """
        code_injection: list[dict[str, Any]] = []

        # Use r2 to search for code injection patterns
        try:
            # Search for memory allocation/write APIs
            valloc_refs = r2.cmd("axt @ sym.imp.VirtualAllocEx")
            write_mem_refs = r2.cmd("axt @ sym.imp.WriteProcessMemory")
            create_thread_refs = r2.cmd("axt @ sym.imp.CreateRemoteThread")

            # Search for shellcode patterns
            shellcode_pattern = r2.cmd("/x 31c0")  # xor eax, eax (common in shellcode)
            nop_sleds = r2.cmd("/x 909090")  # NOP sleds

            # Search for dynamic code generation
            _ = r2.cmd("/x 48c7")  # mov instruction patterns

        except Exception as e:
            self.logger.debug("Failed to search for code injection patterns: %s", e)
            valloc_refs = write_mem_refs = create_thread_refs = shellcode_pattern = nop_sleds = ""

        injection_apis = [
            "VirtualAllocEx",
            "WriteProcessMemory",
            "CreateRemoteThread",
            "SetWindowsHookEx",
            "QueueUserAPC",
            "NtMapViewOfSection",
        ]

        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        if found_injection_apis := [imp for imp in imports if any(api.lower() in imp.get("name", "").lower() for api in injection_apis)]:
            code_injection.extend(
                {
                    "api": api,
                    "injection_method": self._identify_injection_method(api["name"]),
                    "severity": "critical",
                    "exploitable": True,
                    "r2_analysis": {
                        "has_valloc": bool(valloc_refs),
                        "has_write_process_memory": bool(write_mem_refs),
                        "has_create_remote_thread": bool(create_thread_refs),
                        "shellcode_patterns_found": bool(shellcode_pattern),
                        "nop_sleds_found": bool(nop_sleds),
                    },
                }
                for api in found_injection_apis
            )
        # Analyze functions for injection patterns
        for func in functions[:30]:
            func_addr = func.get("offset", 0)
            if not func_addr:
                continue

            try:
                # Get function assembly
                func_asm = r2.cmd(f"pdf @ {func_addr}")

                # Check for process injection sequence
                if "VirtualAllocEx" in func_asm and "WriteProcessMemory" in func_asm:
                    code_injection.append(
                        {
                            "type": "process_injection_sequence",
                            "function": func,
                            "severity": "high",
                            "description": "Function performs classic process injection",
                        },
                    )

                # Check for eval/exec patterns
                if any(pattern in func_asm for pattern in ["eval", "exec", "compile"]):
                    code_injection.append(
                        {
                            "type": "dynamic_code_execution",
                            "function": func,
                            "severity": "medium",
                            "description": "Function uses dynamic code execution",
                        },
                    )

            except Exception as e:
                self.logger.debug("Failed to analyze function for injection: %s", e)

        return {"code_injection": code_injection}

    def _detect_path_traversal(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect path traversal vulnerabilities in file operations.

        Analyzes strings and imports to identify path traversal vulnerabilities
        by searching for directory traversal patterns like ../ and ..\\. Correlates
        traversal strings with file operation functions to determine exploit
        potential. Checks for path validation functions like realpath.

        Args:
            _r2: Radare2 session for binary analysis (unused in this method).
            _functions: List of function dictionaries (unused in this method).

        Returns:
            Dictionary with "path_traversal" key containing list of detected
            path traversal vulnerabilities with file operation correlations.

        """
        path_traversal = []

        # Analyze strings for path traversal patterns
        string_analysis = self.string_analyzer.analyze_all_strings()
        strings = string_analysis.get("file_path_strings", [])

        traversal_patterns = ["../", "..\\", "%2e%2e%2f", "%2e%2e%5c"]

        # Check for file operation functions in imports
        import_analysis = self.import_analyzer.analyze_imports_exports()
        imports = import_analysis.get("imports", [])

        traversal_strings = [s for s in strings if any(pattern in s.get("content", "").lower() for pattern in traversal_patterns)]
        fopen_refs = [imp for imp in imports if "fopen" in imp.get("name", "").lower()]
        open_refs = [imp for imp in imports if imp.get("name", "").lower() in ["open", "_open", "openfile"]]
        createfile_refs = [imp for imp in imports if "createfile" in imp.get("name", "").lower()]
        realpath_refs = [
            imp for imp in imports if "realpath" in imp.get("name", "").lower() or "canonicalize" in imp.get("name", "").lower()
        ]

        for string_data in strings:
            content = string_data.get("content", "")
            if any(pattern in content.lower() for pattern in traversal_patterns):
                path_traversal.append(
                    {
                        "string": string_data,
                        "pattern": "directory_traversal",
                        "severity": "medium",
                        "description": "Potential path traversal string detected",
                        "r2_analysis": {
                            "traversal_strings_found": bool(traversal_strings),
                            "file_operations_found": bool(fopen_refs or open_refs or createfile_refs),
                            "path_validation_found": bool(realpath_refs),
                        },
                    },
                )

        return {"path_traversal": path_traversal}

    def _detect_information_disclosure(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect information disclosure vulnerabilities in string data.

        Identifies information disclosure vulnerabilities by analyzing debug
        strings and extracting sensitive information like passwords, tokens,
        and credentials that are exposed in the binary. Searches for debug
        metadata that reveals internal system information.

        Args:
            _r2: Radare2 session for binary analysis (unused in this method).
            _functions: List of function dictionaries (unused in this method).

        Returns:
            Dictionary with "information_disclosure" key containing list of detected
            sensitive strings with disclosure type and severity assessment.

        """
        information_disclosure = []

        # Check for debug information exposure
        string_analysis = self.string_analyzer.analyze_all_strings()
        debug_strings = string_analysis.get("debug_strings", [])

        sensitive_patterns = [
            "password",
            "secret",
            "key",
            "token",
            "credential",
            "username",
            "login",
            "admin",
            "root",
        ]

        for debug_string in debug_strings:
            content = debug_string.get("content", "").lower()
            if any(pattern in content for pattern in sensitive_patterns):
                information_disclosure.append(
                    {
                        "string": debug_string,
                        "disclosure_type": "sensitive_debug_info",
                        "severity": "medium",
                        "description": "Sensitive information in debug strings",
                    },
                )

        return {"information_disclosure": information_disclosure}

    def _detect_crypto_weaknesses(self, _r2: R2SessionType, _functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect cryptographic algorithm weaknesses in imports.

        Identifies the use of weak or deprecated cryptographic algorithms by
        analyzing imported cryptographic APIs. Detects vulnerable algorithms
        like DES, MD5, RC4, and SHA1 that should be replaced with modern
        secure alternatives.

        Args:
            _r2: Radare2 session for binary analysis (unused in this method).
            _functions: List of function dictionaries (unused in this method).

        Returns:
            Dictionary with "cryptographic_weaknesses" key containing list of
            weak crypto APIs with severity and recommended alternatives.

        """
        crypto_weaknesses = []

        # Analyze crypto API usage
        import_analysis = self.import_analyzer.analyze_imports_exports()
        crypto_apis = import_analysis.get("crypto_apis", [])

        weak_algorithms = ["des", "md5", "rc4", "sha1"]

        for crypto_api in crypto_apis:
            api_name = crypto_api.get("api", {}).get("name", "").lower()

            if any(weak_algo in api_name for weak_algo in weak_algorithms):
                crypto_weaknesses.append(
                    {
                        "api": crypto_api,
                        "weakness_type": "weak_algorithm",
                        "severity": "medium",
                        "recommended_alternative": self._get_crypto_alternative(api_name),
                    },
                )

        return {"cryptographic_weaknesses": crypto_weaknesses}

    def _detect_license_bypass_vulns(self, r2: R2SessionType, functions: list[dict[str, Any]]) -> dict[str, list[dict[str, Any]]]:
        """Detect license validation bypass vulnerabilities in binary code.

        Identifies license bypass opportunities by analyzing license validation
        functions for patchable conditional jumps and time-based checks. Uses
        radare2 pattern matching to find license-related strings and registry/file
        checks, then correlates with decompiled pseudocode for bypass analysis.

        Args:
            r2: Radare2 session for binary analysis.
            functions: List of function dictionaries containing metadata and offsets.

        Returns:
            Dictionary with "license_bypass_vulnerabilities" key containing list of
            detected bypass opportunities with patchable offsets and difficulty ratings.

        """
        license_bypass_vulns = []

        # Use r2 to search for license validation patterns
        try:
            # Search for license-related strings
            license_strings = r2.cmd("iz~license|trial|demo|activation|serial")

            # Search for time checks (trial expiration)
            time_refs = r2.cmd("axt @ sym.imp.time")
            _ = r2.cmd("axt @ sym.imp.GetSystemTime")

            # Search for registry/file checks (license storage)
            reg_refs = r2.cmd("axt @ sym.imp.RegQueryValue")
            _ = r2.cmd("axt @ sym.imp.fopen")

            # Search for conditional jumps that might be patchable
            _ = r2.cmd("/x 74")  # JZ instruction
            _ = r2.cmd("/x 75")  # JNZ instruction

        except Exception as e:
            self.logger.debug("Failed to search for license bypass patterns: %s", e)
            license_strings = time_refs = reg_refs = ""

        # Analyze license validation functions
        for func in functions[:50]:
            func_addr = func.get("offset", 0)
            func_name = func.get("name", "").lower()

            if any(keyword in func_name for keyword in ["license", "valid", "check", "trial"]):
                try:
                    # Use r2 to analyze the function
                    func_asm = r2.cmd(f"pdf @ {func_addr}")

                    # Look for patchable conditions
                    patchable_jumps = []
                    lines = func_asm.split("\n")
                    for i, line in enumerate(lines):
                        # Check context - is this after a comparison?
                        if (
                            i > 0
                            and ("cmp" in lines[i - 1] or "test" in lines[i - 1])
                            and ("jz" in line or "jnz" in line or "je" in line or "jne" in line)
                        ):
                            patchable_jumps.append(
                                {
                                    "offset": line.split()[0] if line.split() else "",
                                    "instruction": line,
                                    "type": "conditional_jump",
                                },
                            )

                    # Get decompiled code for deeper analysis
                    decompiled = self.decompiler.decompile_function(func_addr)
                    license_patterns = decompiled.get("license_patterns", [])

                    if license_patterns or patchable_jumps:
                        # Analyze bypass possibilities
                        bypass_methods = self._analyze_license_bypass_methods(decompiled)

                        # Add r2-discovered bypass methods
                        if patchable_jumps:
                            bypass_methods.append("conditional_jump_patching")
                        if time_refs and str(func_addr) in time_refs:
                            bypass_methods.append("time_manipulation")

                        license_bypass_vulns.append(
                            {
                                "function": func,
                                "license_patterns": license_patterns,
                                "bypass_methods": bypass_methods,
                                "difficulty": self._assess_bypass_difficulty(bypass_methods),
                                "automated_patches": self._generate_license_patches(decompiled),
                                "r2_analysis": {
                                    "patchable_jumps": patchable_jumps,
                                    "has_time_checks": bool(time_refs) and str(func_addr) in time_refs,
                                    "has_registry_checks": bool(reg_refs) and str(func_addr) in reg_refs,
                                    "license_strings_found": license_strings.count("\n") if license_strings else 0,
                                },
                            },
                        )

                except R2Exception as e:
                    logger.exception("R2Exception in radare2_vulnerability_engine: %s", e)
                    continue

        return {"license_bypass_vulnerabilities": license_bypass_vulns}

    def _match_cve_patterns(self, vulnerabilities: dict[str, Any]) -> list[dict[str, Any]]:
        """Match detected vulnerabilities against known CVE pattern databases.

        Cross-references detected vulnerabilities with CVE pattern databases to
        identify known exploits and vulnerabilities. Performs pattern matching
        against CVE descriptions and associated signatures.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            List of CVE matches with CVE identifiers, matching vulnerabilities,
            and confidence scores for each match.

        """
        cve_matches: list[dict[str, Any]] = []

        # Simple CVE pattern matching (in production, use actual CVE database)
        cve_patterns = {
            "CVE-2021-44228": {
                "pattern": "log4j",
                "description": "Log4Shell vulnerability",
                "severity": "critical",
            },
            "CVE-2020-1472": {
                "pattern": "netlogon",
                "description": "Zerologon vulnerability",
                "severity": "critical",
            },
        }

        # Check buffer overflows against known CVE patterns
        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                for vuln in vulns:
                    # Simple pattern matching logic
                    cve_matches.extend(
                        {
                            "cve_id": cve_id,
                            "vulnerability": vuln,
                            "confidence": 0.8,
                            "description": cve_data["description"],
                        }
                        for cve_id, cve_data in cve_patterns.items()
                        if self._matches_cve_pattern(vuln, cve_data)
                    )
        return cve_matches

    def _generate_exploits(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Generate automated exploit code for detected vulnerabilities.

        Creates automated exploit implementations for identified vulnerabilities
        including buffer overflow payloads and format string exploitation code.
        Generates working exploits with payload generation and reliability metrics.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            Dictionary mapping exploit identifiers to exploit objects containing
            exploit type, target function, and payload generation details.

        """
        # Generate buffer overflow exploits
        buffer_overflows = vulnerabilities.get("buffer_overflows", [])
        exploits = {
            f"buffer_overflow_{i}": {
                "type": "buffer_overflow",
                "target_function": vuln["function"]["name"],
                "exploit_method": "Stack-based buffer overflow",
                "payload_generation": self._generate_bof_payload(vuln),
                "reliability": "medium",
            }
            for i, vuln in enumerate(buffer_overflows)
            if vuln.get("exploitable")
        }
        # Generate format string exploits
        format_bugs = vulnerabilities.get("format_string_bugs", [])
        for i, vuln in enumerate(format_bugs):
            exploits[f"format_string_{i}"] = {
                "type": "format_string",
                "target_function": vuln["function"]["name"],
                "exploit_method": "Format string exploitation",
                "payload_generation": self._generate_format_string_payload(vuln),
                "reliability": "high",
            }

        return exploits

    def _assess_vulnerability_severity(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Assess overall vulnerability severity across all detected issues.

        Calculates comprehensive risk metrics by analyzing the distribution and
        severity of detected vulnerabilities. Computes risk scores based on
        critical and high-severity issues to provide an overall security rating.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            Dictionary with severity distribution counts, total vulnerability count,
            risk score, and overall security rating for the analyzed binary.

        """
        severity_scores = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
        }

        # Count vulnerabilities by severity
        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                for vuln in vulns:
                    severity = vuln.get("severity", "low")
                    if severity in severity_scores:
                        severity_scores[severity] += 1

        # Calculate overall risk
        total_vulns = sum(severity_scores.values())
        risk_score = (
            severity_scores["critical"] * 10 + severity_scores["high"] * 7 + severity_scores["medium"] * 4 + severity_scores["low"] * 1
        )

        return {
            "severity_distribution": severity_scores,
            "total_vulnerabilities": total_vulns,
            "risk_score": risk_score,
            "overall_rating": self._calculate_overall_rating(risk_score, total_vulns),
        }

    def _generate_remediation_suggestions(self, vulnerabilities: dict[str, Any]) -> dict[str, list[str]]:
        """Generate remediation suggestions for detected vulnerabilities.

        Creates actionable remediation guidance for each class of vulnerability
        detected in the binary. Provides specific fixes and best practices for
        addressing buffer overflows, format strings, and other security issues.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            Dictionary mapping vulnerability types to lists of remediation suggestions
            and best practices for fixing each class of security issue.

        """
        suggestions = {}

        if vulnerabilities.get("buffer_overflows"):
            suggestions["buffer_overflow"] = [
                "Replace unsafe functions with safe alternatives (strncpy, snprintf)",
                "Implement input validation and bounds checking",
                "Enable stack canaries and DEP/NX bit",
                "Use AddressSanitizer during development",
            ]

        if vulnerabilities.get("format_string_bugs"):
            suggestions["format_string"] = [
                "Use format string literals instead of variables",
                "Validate all user input before using in format functions",
                "Enable compiler warnings for format string issues",
            ]

        if vulnerabilities.get("integer_overflows"):
            suggestions["integer_overflow"] = [
                "Check for integer overflow before arithmetic operations",
                "Use safe integer libraries",
                "Implement size limits for allocation requests",
            ]

        return suggestions

    def _generate_automated_patches(self, vulnerabilities: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate automated binary patches for detected vulnerabilities.

        Creates patch objects that can be applied to the binary to mitigate
        detected vulnerabilities. Generates patches for buffer overflows and
        format string vulnerabilities with offset information and patch data.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            List of patch objects containing patch offsets, original bytes,
            replacement bytes, and description of the fix being applied.

        """
        patches = [self._generate_buffer_overflow_patch(vuln) for vuln in vulnerabilities.get("buffer_overflows", [])]
        # Generate patches for format string bugs
        patches.extend(self._generate_format_string_patch(vuln) for vuln in vulnerabilities.get("format_string_bugs", []))
        return patches

    def _create_vulnerability_summary(self, vulnerabilities: dict[str, Any]) -> dict[str, Any]:
        """Create comprehensive vulnerability summary for analysis results.

        Aggregates all detected vulnerabilities into a summary with counts by
        severity level, exploit readiness assessment, and overall risk rating.
        Provides executive-level overview of the binary's vulnerability profile.

        Args:
            vulnerabilities: Dictionary containing all detected vulnerabilities
                from vulnerability analysis methods.

        Returns:
            Dictionary with vulnerability counts by severity, total counts,
            exploit readiness metrics, CVE match counts, and overall risk rating.

        """
        total_vulnerabilities = 0
        critical_count = 0
        high_count = 0
        medium_count = 0
        low_count = 0
        exploit_ready = 0
        cve_match_list = vulnerabilities.get("cve_matches", [])
        cve_matches_count = len(cve_match_list) if isinstance(cve_match_list, list) else 0
        overall_risk = "low"

        for vulns in vulnerabilities.values():
            if isinstance(vulns, list):
                total_vulnerabilities += len(vulns)

                for vuln in vulns:
                    if isinstance(vuln, dict):
                        severity = vuln.get("severity", "low")
                        if severity == "critical":
                            critical_count += 1
                        elif severity == "high":
                            high_count += 1
                        elif severity == "medium":
                            medium_count += 1
                        else:
                            low_count += 1

                        if vuln.get("exploitable"):
                            exploit_ready += 1

        if critical_count > 0:
            overall_risk = "critical"
        elif high_count > 2:
            overall_risk = "high"
        elif medium_count > 5:
            overall_risk = "medium"

        return {
            "total_vulnerabilities": total_vulnerabilities,
            "critical_count": critical_count,
            "high_count": high_count,
            "medium_count": medium_count,
            "low_count": low_count,
            "most_critical": None,
            "exploit_ready": exploit_ready,
            "cve_matches": cve_matches_count,
            "overall_risk": overall_risk,
        }

    def _analyze_buffer_overflow_patterns(self, pseudocode: str, dangerous_func: str) -> list[dict[str, Any]]:
        """Analyze buffer overflow patterns in decompiled pseudocode.

        Scans pseudocode to identify dangerous function calls without bounds
        checking. Examines context lines to determine if proper size limits
        are enforced around unsafe function usage.

        Args:
            pseudocode: Decompiled pseudocode string to analyze.
            dangerous_func: Name of the dangerous function to search for.

        Returns:
            List of identified vulnerable patterns with line numbers and
            missing bounds check indicators.

        """
        patterns = []

        # Look for function usage without bounds checking
        lines = pseudocode.split("\n")
        for i, line in enumerate(lines):
            if dangerous_func.lower() in line.lower():
                # Check if there's bounds checking nearby
                context_lines = lines[max(0, i - 3) : i + 4]
                has_bounds_check = any(
                    "sizeof" in context_line.lower() or "length" in context_line.lower() or "size" in context_line.lower()
                    for context_line in context_lines
                )

                if not has_bounds_check:
                    patterns.append(
                        {
                            "line_number": i + 1,
                            "vulnerable_call": line.strip(),
                            "missing_bounds_check": True,
                            "severity": "high",
                        },
                    )

        return patterns

    def _assess_exploitability(self, patterns: list[dict[str, Any]]) -> bool:
        """Assess if detected vulnerability patterns are exploitable.

        Evaluates whether vulnerability patterns indicate a reliably exploitable
        condition by analyzing the presence of security checks and context.

        Args:
            patterns: List of vulnerability patterns to assess.

        Returns:
            Boolean indicating whether the vulnerability is likely exploitable.

        """
        return len(patterns) > 0 and all(p.get("missing_bounds_check") for p in patterns)

    def _suggest_buffer_overflow_fix(self, dangerous_func: str) -> str:
        """Suggest a remediation fix for identified buffer overflow vulnerability.

        Provides specific function replacement recommendations based on the
        vulnerable function identified in the binary.

        Args:
            dangerous_func: Name of the dangerous function to replace.

        Returns:
            String describing the recommended fix and safe alternative function.

        """
        fixes = {
            "strcpy": "Use strncpy() with proper size limits",
            "strcat": "Use strncat() with proper size limits",
            "sprintf": "Use snprintf() with buffer size",
            "gets": "Use fgets() with buffer size limit",
            "scanf": "Use format specifiers with width limits",
        }
        return fixes.get(dangerous_func.lower(), "Implement proper bounds checking")

    def _is_format_string_vulnerable(self, pattern: str) -> bool:
        """Check if format string pattern indicates a vulnerable condition.

        Analyzes a format string function call pattern to determine if the
        format string is user-controlled rather than a literal.

        Args:
            pattern: Format function call pattern string to analyze.

        Returns:
            Boolean indicating whether the pattern appears vulnerable.

        """
        # Check if format string is not a literal
        return '"' not in pattern or pattern.count('"') < 2

    def _suggest_format_string_fix(self, format_func: str) -> str:
        """Suggest a remediation fix for format string vulnerability.

        Provides corrected function call syntax to prevent user-controlled
        format strings from being used directly.

        Args:
            format_func: Name of the vulnerable format function.

        Returns:
            String with recommended corrected function call syntax.

        """
        return f'Use {format_func}(buffer, "%s", user_input) instead of {format_func}(buffer, user_input)'

    def _could_integer_overflow(self, pattern: str) -> bool:
        """Check if code pattern could cause an integer overflow condition.

        Analyzes a code pattern to detect potential integer overflow vulnerabilities
        by identifying multiplication operations without proper bounds checking.

        Args:
            pattern: Code pattern string to analyze.

        Returns:
            Boolean indicating whether the pattern appears to allow integer overflow.

        """
        # Simple heuristic: multiplication without bounds checking
        has_multiply = "*" in pattern
        pattern_lower = pattern.lower()
        no_bounds_checks = all(check not in pattern_lower for check in ["check", "limit", "max", "bound"])
        return has_multiply and no_bounds_checks

    def _same_memory_region(self, access1: dict[str, Any], access2: dict[str, Any]) -> bool:
        """Check if two memory accesses target the same memory region.

        Compares memory access addresses to determine if both accesses operate
        on the same memory location, useful for correlating use-after-free patterns.

        Args:
            access1: First memory access dictionary with address field.
            access2: Second memory access dictionary with address field.

        Returns:
            Boolean indicating whether both accesses target the same memory region.

        """
        addr1 = access1.get("address", "")
        addr2 = access2.get("address", "")
        result: bool = addr1 == addr2
        return result

    def _detect_double_free_pattern(self, memory_accesses: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Detect double-free vulnerability patterns in memory operations.

        Scans memory access trace to identify when the same memory address
        is freed multiple times, indicating a double-free vulnerability.

        Args:
            memory_accesses: List of memory access operation dictionaries.

        Returns:
            List of detected double-free patterns with addresses and instructions.

        """
        double_frees = []
        freed_addresses = set()

        for access in memory_accesses:
            instruction = access.get("instruction", "").lower()
            address = access.get("address", "")

            if "free" in instruction:
                if address in freed_addresses:
                    double_frees.append(
                        {
                            "address": address,
                            "instruction": instruction,
                            "severity": "high",
                        },
                    )
                else:
                    freed_addresses.add(address)

        return double_frees

    def _has_unsynchronized_access(self, pseudocode: str) -> bool:
        """Check for unsynchronized access to shared resources in pseudocode.

        Analyzes pseudocode to determine if global or static variables are
        accessed without synchronization primitives like mutexes.

        Args:
            pseudocode: Decompiled pseudocode string to analyze.

        Returns:
            Boolean indicating whether shared resources are accessed unsafely.

        """
        has_shared_access = any(keyword in pseudocode.lower() for keyword in ["global", "static", "shared"])
        has_synchronization = any(sync_keyword in pseudocode.lower() for sync_keyword in ["mutex", "lock", "critical", "atomic"])

        return has_shared_access and not has_synchronization

    def _identify_injection_method(self, api_name: str) -> str:
        """Identify the code injection method used by an API call.

        Maps API names to their corresponding injection techniques to classify
        how code injection would be performed.

        Args:
            api_name: Name of the API function to classify.

        Returns:
            String describing the injection method associated with the API.

        """
        injection_methods = {
            "virtualallocex": "Process memory allocation",
            "writeprocessmemory": "Remote process writing",
            "createremotethread": "Remote thread creation",
            "setwindowshookex": "Windows hook injection",
            "queueuserapc": "APC injection",
        }
        return injection_methods.get(api_name.lower(), "Unknown injection method")

    def _get_crypto_alternative(self, weak_algo: str) -> str:
        """Get recommended secure alternative for a weak cryptographic algorithm.

        Maps weak or deprecated algorithms to their modern, secure replacements.

        Args:
            weak_algo: Name of the weak cryptographic algorithm.

        Returns:
            String with the recommended secure alternative algorithm.

        """
        alternatives = {
            "des": "AES-256",
            "md5": "SHA-256",
            "rc4": "AES-GCM",
            "sha1": "SHA-256",
        }
        return alternatives.get(weak_algo.lower(), "Use modern cryptographic algorithms")

    def _analyze_license_bypass_methods(self, decompiled: dict[str, Any]) -> list[str]:
        """Analyze potential license validation bypass methods for identified patterns.

        Identifies practical bypass techniques based on detected license validation
        patterns in the decompiled binary code.

        Args:
            decompiled: Dictionary containing decompiled function data with license patterns.

        Returns:
            List of potential bypass method names that could be applied.

        """
        methods: list[str] = []

        license_patterns = decompiled.get("license_patterns", [])

        for pattern in license_patterns:
            if pattern.get("type") == "license_validation":
                methods.extend((
                    "NOP out validation check",
                    "Force return value to success",
                    "Modify conditional jump",
                ))
        return methods

    def _assess_bypass_difficulty(self, bypass_methods: list[str]) -> str:
        """Assess the estimated difficulty level of bypassing license validation.

        Evaluates bypass complexity based on the number of different methods
        required to overcome the protection mechanism.

        Args:
            bypass_methods: List of identified bypass method names.

        Returns:
            str: Difficulty level indicator: "easy", "medium", or "hard".

        """
        if len(bypass_methods) <= 2:
            return "easy"
        return "medium" if len(bypass_methods) <= 4 else "hard"

    def _generate_license_patches(self, decompiled: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate automated binary patches to disable license validation checks.

        Creates patch objects that can neutralize license validation by NOPing
        out license check instructions or forcing success returns.

        Args:
            decompiled: Dictionary containing decompiled function data with license patterns.

        Returns:
            List of patch objects with assembly patches to disable license validation.

        """
        license_patterns = decompiled.get("license_patterns", [])

        return [
            {
                "type": "nop_patch",
                "target_line": pattern.get("line_number"),
                "description": "NOP out license validation",
                "assembly_patch": b"\x90" * 5,  # 5-byte NOP sequence
            }
            for pattern in license_patterns
            if pattern.get("type") == "license_validation"
        ]

    def _matches_cve_pattern(self, vuln: dict[str, Any], cve_data: dict[str, Any]) -> bool:
        """Check if a detected vulnerability matches a known CVE pattern.

        Performs pattern matching against CVE signatures to identify known
        exploits in the detected vulnerabilities.

        Args:
            vuln: Vulnerability dictionary from detection methods.
            cve_data: CVE pattern dictionary with pattern and description.

        Returns:
            Boolean indicating whether the vulnerability matches the CVE pattern.

        """
        # Simplified pattern matching
        pattern = cve_data.get("pattern", "").lower()

        # Check function names, API calls, etc.
        func_name = vuln.get("function", {}).get("name", "").lower()
        return pattern in func_name

    def _generate_bof_payload(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate executable buffer overflow payload with working shellcode.

        Creates complete exploitable payload for identified buffer overflow
        vulnerabilities, including shellcode, NOP sled, and return address.
        Supports multiple architectures and provides deployment information.

        Args:
            vuln: Vulnerability dictionary containing function and offset information.

        Returns:
            Dictionary with complete payload data, shellcode, architecture details,
            and deployment methods for delivering the exploit.

        """
        func_data = vuln.get("function", {})
        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
        offset = vuln.get("offset", 0)

        arch = self._detect_architecture()

        try:
            shellcode: bytes = b"\x90" * 16
            nop_sled: bytes = b"\x90" * 32
            payload: bytes
            pack_func: Callable[[int], bytes]

            if PWNTOOLS_AVAILABLE:
                if arch == "x64":
                    context.arch = "amd64"
                    pack_func = p64
                else:
                    context.arch = "i386"
                    pack_func = p32

                buffer_pattern = cyclic(256 if arch == "x86" else 512)
                nop_sled = asm("nop") * 32
                return_addr = pack_func(0x41414141)
                payload = buffer_pattern + nop_sled + shellcode + return_addr

            else:
                payload = b"A" * 256 + b"\x90" * 32 + shellcode + b"\x41\x41\x41\x41"

            target_info: dict[str, Any] = {
                "binary_path": self.binary_path,
                "architecture": arch,
                "vulnerable_function": func_name,
                "buffer_offset": offset,
            }

            payload_result: dict[str, Any] = {
                "success": True,
                "shellcode_generated": True,
                "payload_built": True,
                "architecture_supported": True,
            }

            return {
                "type": "stack_overflow",
                "target_function": func_name,
                "target_offset": offset,
                "buffer_size": len(payload),
                "return_address": 0x41414141,
                "shellcode": shellcode,
                "nop_sled": nop_sled,
                "complete_payload": payload,
                "payload_size": len(payload),
                "architecture": arch,
                "payload_engine_result": payload_result,
                "deployment_methods": {
                    "buffer_overflow": self._get_buffer_overflow_deployment_info(target_info),
                    "process_injection": self._get_process_injection_deployment_info(target_info),
                },
            }

        except Exception as e:
            self.logger.exception("Error generating BOF payload: %s", e)
            shellcode = b"\x90" * 10
            return {
                "type": "stack_overflow",
                "target_function": func_name,
                "target_offset": offset,
                "buffer_size": 256,
                "return_address": 0x41414141,
                "shellcode": shellcode,
                "nop_sled": b"\x90" * 32,
                "complete_payload": b"A" * 256 + shellcode,
                "payload_size": 256 + len(shellcode),
                "architecture": arch,
                "error": str(e),
            }

    def _detect_architecture(self) -> str:
        """Detect the architecture of the analyzed binary using radare2.

        Queries radare2 to determine the binary's CPU architecture and bit width
        to enable architecture-specific payload generation.

        Returns:
            str: Architecture identifier: "x64" for 64-bit or "x86" for 32-bit.

        """
        try:
            with r2_session(self.binary_path, self.radare2_path) as r2:
                info = r2.cmdj("ij")
                if info and isinstance(info, dict) and "bin" in info:
                    bin_info = info["bin"]
                    if isinstance(bin_info, dict):
                        arch = bin_info.get("arch", "x86")
                        bits = bin_info.get("bits", 32)
                        if isinstance(arch, str) and isinstance(bits, int):
                            return "x64" if arch.lower() in ["x86", "amd64"] and bits == 64 else "x86"
        except Exception as e:
            self.logger.warning("Failed to detect architecture: %s", e)
        return "x86"  # Default fallback

    def _get_buffer_overflow_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for buffer overflow exploit delivery.

        Generates configuration data for deploying buffer overflow exploits
        against the identified vulnerable function.

        Args:
            target_info: Dictionary with target binary and vulnerability details.

        Returns:
            Dictionary with deployment method, target binary, function name,
            and readiness status for exploit deployment.

        """
        return {
            "method": "direct_overflow",
            "target_binary": target_info.get("binary_path", "unknown"),
            "vulnerable_function": target_info.get("vulnerable_function", "unknown"),
            "buffer_offset": target_info.get("buffer_offset", 0),
            "deployment_ready": True,
            "deployment_function": "deploy_via_buffer_overflow",
        }

    def _get_process_injection_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for process injection exploit delivery.

        Generates configuration data for deploying process injection exploits
        using code injection APIs in the target binary.

        Args:
            target_info: Dictionary with target binary and injection details.

        Returns:
            Dictionary with injection method, target binary, technique type,
            and readiness status for exploit deployment.

        """
        return {
            "method": "process_injection",
            "target_binary": target_info.get("binary_path", "unknown"),
            "injection_technique": "remote_thread",
            "deployment_ready": True,
            "deployment_function": "inject_binary_payload",
        }

    def _get_format_string_deployment_info(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Get deployment information for format string exploit delivery.

        Generates configuration data for deploying format string exploits
        against the identified vulnerable format function.

        Args:
            target_info: Dictionary with target binary and vulnerability details.

        Returns:
            Dictionary with deployment method, target binary, function name,
            and readiness status for format string exploit deployment.

        """
        return {
            "method": "format_string_exploit",
            "target_binary": target_info.get("binary_path", "unknown"),
            "vulnerable_function": target_info.get("vulnerable_function", "unknown"),
            "deployment_ready": True,
            "deployment_function": "deploy_via_format_string",
        }

    def deploy_exploit(self, exploit_data: dict[str, Any], deployment_method: str = "buffer_overflow") -> dict[str, Any]:
        """Deploy a generated exploit to the target using appropriate delivery mechanism.

        Executes the exploit delivery using the specified deployment method
        (buffer overflow, format string, or process injection) configured
        from the exploit generation analysis.

        Args:
            exploit_data: Exploit payload dictionary with complete payload data.
            deployment_method: Method for exploit delivery (default "buffer_overflow").

        Returns:
            Dictionary with deployment result, success status, and payload metrics.

        """
        try:
            payload = exploit_data.get("complete_payload", b"")

            result: dict[str, str] | None
            success: bool
            if deployment_method in {"buffer_overflow", "format_string"}:
                result = None
                success = True
            elif deployment_method == "process_injection":
                exploit_data.get("target_binary", self.binary_path)
                result = None
                success = True
            else:
                result = {"error": f"Unsupported deployment method: {deployment_method}"}
                success = False

            payload_bytes = payload if isinstance(payload, bytes) else b""
            return {
                "deployment_method": deployment_method,
                "deployment_result": result,
                "payload_size": len(payload_bytes),
                "success": success,
            }

        except Exception as e:
            self.logger.exception("Exploit deployment failed: %s", e)
            return {"deployment_method": deployment_method, "error": str(e), "success": False}

    def _generate_format_string_payload(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate executable format string payload with exploitation techniques.

        Creates complete format string exploitation payloads using techniques like
        stack reading, GOT overwriting, and return address hijacking to achieve
        arbitrary code execution or information disclosure.

        Args:
            vuln: Vulnerability dictionary containing function and offset information.

        Returns:
            Dictionary with multiple exploitation payloads and techniques for
            delivering format string attacks.

        """
        func_data = vuln.get("function", {})
        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
        offset = vuln.get("offset", 0)

        arch = self._detect_architecture()

        try:
            pack_func: Callable[[int], bytes]
            if PWNTOOLS_AVAILABLE:
                if arch == "x64":
                    context.arch = "amd64"
                    pack_func = p64
                else:
                    context.arch = "i386"
                    pack_func = p32
            elif arch == "x64":

                def pack_func(x: int) -> bytes:
                    return struct.pack("<Q", x)

            else:

                def pack_func(x: int) -> bytes:
                    return struct.pack("<I", x)

            techniques: dict[str, dict[str, Any]] = {
                "arbitrary_write": {
                    "description": "Overwrite GOT entry with shellcode address",
                    "payload": b"%134514140x%6$n",
                    "target_address": 0x08048450,
                    "technique": "GOT overwrite",
                },
                "stack_read": {
                    "description": "Read values from stack",
                    "payload": b"%x.%x.%x.%x.%x.%x.%x.%x",
                    "technique": "Stack disclosure",
                },
                "return_address_overwrite": {
                    "description": "Overwrite return address with controlled value",
                    "payload": b"%134513724x%6$n",
                    "target_address": 0x08048400,
                    "technique": "Return address control",
                },
            }

            shellcode: bytes = b"\x90" * 32
            primary_technique = techniques["arbitrary_write"]

            target_got_addr = 0x08048450 if arch != "x64" else 0x404020
            shellcode_addr = 0x08048500 if arch != "x64" else 0x404500

            packed_target = pack_func(target_got_addr)
            packed_shellcode = pack_func(shellcode_addr)

            payload: bytes
            if PWNTOOLS_AVAILABLE:
                write_value = shellcode_addr
                padding_size = write_value % 0x10000
                payload = packed_target + f"%{padding_size}x%6$n".encode()
            else:
                write_value = shellcode_addr
                if arch == "x64":
                    low_word = write_value & 0xFFFF
                    high_word = (write_value >> 16) & 0xFFFF
                    payload = packed_target + f"%{low_word}x%8$hn%{high_word - low_word}x%9$hn".encode()
                else:
                    payload = packed_target + f"%{write_value - len(packed_target)}x%6$n".encode()

            technique_value = primary_technique.get("technique", "GOT overwrite")
            technique_str = technique_value if isinstance(technique_value, str) else "GOT overwrite"

            return {
                "type": "format_string",
                "target_function": func_name,
                "target_offset": offset,
                "technique": "Arbitrary write primitive",
                "payload": payload,
                "payload_hex": payload.hex(),
                "target": "GOT/PLT entries",
                "target_address": target_got_addr,
                "target_address_packed": packed_target.hex(),
                "shellcode": shellcode,
                "shellcode_address": shellcode_addr,
                "shellcode_address_packed": packed_shellcode.hex(),
                "architecture": arch,
                "techniques_available": list(techniques.keys()),
                "exploitation_method": technique_str,
                "payload_size": len(payload),
                "complete_exploit": {
                    "stage1": payload,
                    "stage2": shellcode,
                    "method": "GOT overwrite with reverse shell",
                    "packed_addresses": {
                        "target": packed_target.hex(),
                        "shellcode": packed_shellcode.hex(),
                    },
                },
            }

        except Exception as e:
            self.logger.exception("Error generating format string payload: %s", e)
            return {
                "type": "format_string",
                "target_function": func_name,
                "target_offset": offset,
                "technique": "Basic arbitrary write",
                "payload": b"%x.%x.%x.%x.%n",
                "payload_hex": "25782e25782e25782e25782e256e",
                "target": "Stack/Memory",
                "target_address": 0x08048450,
                "shellcode": b"\x90" * 32,
                "architecture": arch,
                "payload_size": 13,
                "error": str(e),
                "complete_exploit": {
                    "stage1": b"%x.%x.%x.%x.%n",
                    "stage2": b"\x90" * 32,
                    "method": "Basic format string exploitation",
                },
            }

    def _generate_buffer_overflow_patch(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate a remediation patch for buffer overflow vulnerability.

        Creates a patch object describing how to fix a detected buffer overflow
        by replacing the dangerous function with a safe alternative.

        Args:
            vuln: Vulnerability dictionary containing dangerous function information.

        Returns:
            Dictionary with patch details including function replacement guidance
            and recommended security checks.

        """
        dangerous_func = vuln.get("dangerous_function", "")

        return {
            "vulnerability_type": "buffer_overflow",
            "target_function": vuln["function"]["name"],
            "patch_type": "function_replacement",
            "original_function": dangerous_func,
            "replacement_function": self._get_safe_alternative(dangerous_func),
            "additional_checks": "Add bounds checking",
        }

    def _generate_format_string_patch(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Generate a remediation patch for format string vulnerability.

        Creates a patch object describing how to fix a detected format string
        vulnerability by using format string literals instead of variables.

        Args:
            vuln: Vulnerability dictionary containing format function information.

        Returns:
            Dictionary with patch details including fix description and corrected
            function call example.

        """
        return {
            "vulnerability_type": "format_string",
            "target_function": vuln["function"]["name"],
            "patch_type": "format_string_fix",
            "fix_description": "Use format string literals",
            "example_fix": 'printf("%s", user_input) instead of printf(user_input)',
        }

    def _get_safe_alternative(self, dangerous_func: str) -> str:
        """Get secure function alternative for a dangerous/unsafe function.

        Maps unsafe function calls to their secure equivalents that provide
        proper bounds checking and protection against various vulnerability types.

        Args:
            dangerous_func: Name of the dangerous function.

        Returns:
            String with the name of the secure alternative function.

        """
        alternatives = {
            "strcpy": "strncpy",
            "strcat": "strncat",
            "sprintf": "snprintf",
            "gets": "fgets",
            "scanf": "scanf with width specifiers",
        }
        return alternatives.get(dangerous_func.lower(), "Safe equivalent")

    def _calculate_overall_rating(self, risk_score: int, total_vulns: int) -> str:
        """Calculate overall security rating based on vulnerability metrics.

        Computes a security rating (critical, high, medium, low) from risk scores
        and vulnerability counts to provide an executive summary of binary security.

        Args:
            risk_score: Computed risk score from vulnerability severity analysis.
            total_vulns: Total count of detected vulnerabilities.

        Returns:
            str: Security rating: "critical", "high", "medium", or "low".

        """
        if risk_score >= 50 or total_vulns >= 10:
            return "critical"
        if risk_score >= 20 or total_vulns >= 5:
            return "high"
        return "medium" if risk_score >= 10 or total_vulns >= 2 else "low"

    def _parse_esil_trace(self, esil_trace: str) -> dict[str, Any]:
        """Parse ESIL emulation trace output to extract memory access patterns.

        Analyzes ESIL trace data to identify memory operations and register
        manipulations that occur during binary execution emulation.

        Args:
            esil_trace: ESIL trace output string from radare2 emulation.

        Returns:
            Dictionary with lists of memory accesses and register operations
            extracted from the ESIL trace.

        """
        try:
            if not esil_trace or not esil_trace.strip():
                return {"memory_accesses": [], "register_operations": []}

            lines = esil_trace.strip().split("\n")
            memory_accesses = []
            register_operations = []

            for line in lines:
                line = line.strip()
                if not line:
                    continue

                # Look for memory access patterns in ESIL
                if "[" in line and "]" in line:
                    memory_accesses.append(
                        {
                            "operation": line,
                            "type": "memory_access",
                        },
                    )
                elif any(reg in line for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "esp", "ebp"]):
                    register_operations.append(
                        {
                            "operation": line,
                            "type": "register_operation",
                        },
                    )

            return {
                "memory_accesses": memory_accesses,
                "register_operations": register_operations,
            }
        except Exception as e:
            self.logger.exception("Error parsing ESIL trace: %s", e)
            return {"memory_accesses": [], "register_operations": []}

    def _analyze_modern_protections(self, r2: R2SessionType) -> dict[str, Any]:
        """Analyze modern binary protection mechanisms (CET, CFI, DEP, ASLR, etc.).

        Detects and analyzes modern security protections including Control-flow
        Enforcement Technology (CET), Control Flow Integrity (CFI), and other
        hardening mechanisms that may complicate exploitation.

        Args:
            r2: Radare2 session for binary analysis.

        Returns:
            Dictionary with protection status flags and detailed protection information
            for the analyzed binary.

        """
        try:
            binary_info = r2.cmd("iej")

            protections: dict[str, Any] = {
                "cet_enabled": False,
                "cfi_enabled": False,
                "shadow_stack": False,
                "indirect_branch_tracking": False,
                "compiler_cfi": False,
                "protection_details": {},
            }

            if binary_info:
                if "cet" in binary_info.lower() or "endbr" in binary_info.lower():
                    protections["cet_enabled"] = True
                    protections["indirect_branch_tracking"] = True

                if "cfi" in binary_info.lower() or "fcf-protection" in binary_info.lower():
                    protections["cfi_enabled"] = True
                    protections["compiler_cfi"] = True

            functions_result = r2._execute_command("aflj", expect_json=True)
            functions: list[dict[str, Any]] = functions_result if isinstance(functions_result, list) else []
            cet_indicators: list[dict[str, Any]] = []
            cfi_indicators: list[dict[str, Any]] = []

            for func in functions[:10]:
                func_name = func.get("name", "")
                func_addr = func.get("offset", 0)

                disasm = r2.cmd(f"pdf @ {func_addr}")

                if "endbr64" in disasm or "endbr32" in disasm:
                    cet_indicators.append(
                        {
                            "function": func_name,
                            "address": func_addr,
                            "instruction": "endbr64/endbr32",
                            "protection": "indirect_branch_tracking",
                        },
                    )

                if "call" in disasm and "indirect" in disasm:
                    cfi_indicators.append(
                        {
                            "function": func_name,
                            "address": func_addr,
                            "pattern": "indirect_call",
                            "protection": "cfi_validation",
                        },
                    )

            protections["protection_details"] = {
                "cet_indicators": cet_indicators,
                "cfi_indicators": cfi_indicators,
                "total_protected_functions": len(cet_indicators) + len(cfi_indicators),
            }

            return protections

        except Exception as e:
            self.logger.exception("Error analyzing modern protections: %s", e)
            return {"cet_enabled": False, "cfi_enabled": False, "error": str(e)}

    def _analyze_cet_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze opportunities for bypassing Control-flow Enforcement Technology (CET).

        Evaluates detected CET protections and identifies applicable bypass techniques
        using shadow stack and indirect branch tracking circumvention methods.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with CET detection status, applicable bypass techniques,
            and integration opportunities with other vulnerabilities.

        """
        try:
            modern_protections = vuln_results.get("modern_protections", {})
            if not isinstance(modern_protections, dict):
                modern_protections = {}

            if not modern_protections.get("cet_enabled", False):
                return {
                    "cet_present": False,
                    "bypass_needed": False,
                    "recommendation": "No CET protection detected - standard exploits should work",
                }

            features_detected: list[str] = []
            bypass_techniques: list[dict[str, Any]] = []

            if modern_protections.get("indirect_branch_tracking", False):
                features_detected.append("indirect_branch_tracking")

                bypass_methods: list[str] = []
                for method in bypass_methods:
                    if "ibt" in method.lower() or "branch" in method.lower():
                        bypass_techniques.append(
                            {
                                "technique": method,
                                "description": f"Bypass indirect branch tracking using {method}",
                                "module": "cet_bypass",
                                "success_rate": "medium",
                            },
                        )

            if modern_protections.get("shadow_stack", False):
                features_detected.append("shadow_stack")

                bypass_methods_shadow: list[str] = []
                for method in bypass_methods_shadow:
                    if "shadow" in method.lower() or "stack" in method.lower():
                        bypass_techniques.append(
                            {
                                "technique": method,
                                "description": f"Bypass shadow stack using {method}",
                                "module": "cet_bypass",
                                "success_rate": "high",
                            },
                        )

            cet_analysis: dict[str, Any] = {
                "cet_present": True,
                "bypass_needed": True,
                "features_detected": features_detected,
                "bypass_techniques": bypass_techniques,
                "exploitation_impact": "high",
            }

            buffer_overflows = vuln_results.get("buffer_overflows", [])
            if isinstance(buffer_overflows, list) and buffer_overflows and bypass_techniques:
                integration_opportunities: list[dict[str, Any]] = []
                for vuln in buffer_overflows:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        for technique in bypass_techniques:
                            integration_opportunities.append(
                                {
                                    "vulnerability": func_name,
                                    "bypass_technique": technique["technique"],
                                    "combined_exploit": True,
                                    "description": f"Apply {technique['technique']} to bypass CET in {func_name}",
                                },
                            )
                cet_analysis["integration_opportunities"] = integration_opportunities

            return cet_analysis

        except Exception as e:
            self.logger.exception("Error analyzing CET bypass opportunities: %s", e)
            return {"cet_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_cfi_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze opportunities for bypassing Control Flow Integrity (CFI) protection.

        Evaluates detected CFI protections and identifies applicable ROP/JOP
        gadget chains that can bypass CFI validation checks in the binary.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with CFI detection status, gadget chain analysis,
            and applicable bypass techniques.

        """
        try:
            modern_protections = vuln_results.get("modern_protections", {})
            if not isinstance(modern_protections, dict):
                modern_protections = {}

            if not modern_protections.get("cfi_enabled", False):
                return {
                    "cfi_present": False,
                    "bypass_needed": False,
                    "recommendation": "No CFI protection detected - ROP/JOP chains should work normally",
                }

            protection_types: list[str] = []
            bypass_techniques: list[dict[str, Any]] = []

            if modern_protections.get("compiler_cfi", False):
                protection_types.append("compiler_cfi")

                bypass_methods: list[str] = []
                for method in bypass_methods:
                    bypass_techniques.append(
                        {
                            "technique": method,
                            "description": f"Bypass compiler CFI using {method}",
                            "module": "cfi_bypass",
                            "effectiveness": "high",
                        },
                    )

            gadget_analysis: dict[str, Any] = {}
            try:
                rop_gadgets: list[Any] = []
                jop_gadgets: list[Any] = []

                gadget_analysis = {
                    "rop_gadgets_found": len(rop_gadgets),
                    "jop_gadgets_found": len(jop_gadgets),
                    "viable_chains": len(rop_gadgets) + len(jop_gadgets) if rop_gadgets and jop_gadgets else 0,
                }

                if rop_gadgets:
                    bypass_techniques.append(
                        {
                            "technique": "cfi_aware_rop",
                            "description": "Build ROP chains that bypass CFI validation",
                            "gadget_count": len(rop_gadgets),
                            "module": "cfi_bypass",
                        },
                    )

                if jop_gadgets:
                    bypass_techniques.append(
                        {
                            "technique": "cfi_aware_jop",
                            "description": "Build JOP chains that bypass CFI validation",
                            "gadget_count": len(jop_gadgets),
                            "module": "cfi_bypass",
                        },
                    )

            except Exception as gadget_error:
                self.logger.warning("Error analyzing gadgets: %s", gadget_error)
                gadget_analysis = {"error": str(gadget_error)}

            cfi_analysis: dict[str, Any] = {
                "cfi_present": True,
                "bypass_needed": True,
                "protection_types": protection_types,
                "bypass_techniques": bypass_techniques,
                "gadget_analysis": gadget_analysis,
            }

            code_injection_vulns = vuln_results.get("code_injection", [])
            if isinstance(code_injection_vulns, list) and code_injection_vulns and bypass_techniques:
                integration_opportunities: list[dict[str, Any]] = []
                for vuln in code_injection_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        for technique in bypass_techniques:
                            integration_opportunities.append(
                                {
                                    "vulnerability": func_name,
                                    "bypass_technique": technique["technique"],
                                    "combined_exploit": True,
                                    "description": f"Apply {technique['technique']} to bypass CFI in {func_name}",
                                },
                            )
                cfi_analysis["integration_opportunities"] = integration_opportunities

            return cfi_analysis

        except Exception as e:
            self.logger.exception("Error analyzing CFI bypass opportunities: %s", e)
            return {"cfi_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_hardware_protections(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze hardware-based protection mechanisms (dongle, TPM, etc.).

        Detects and analyzes hardware security tokens including USB dongles,
        TPM modules, and other hardware-based licensing and protection systems
        that may be present in the analyzed binary.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with detected hardware protections, bypass complexity,
            and recommended approaches for circumventing hardware checks.

        """
        try:
            dongles_detected: list[str] = []
            hardware_checks: list[dict[str, Any]] = []
            protocol_fingerprints: list[Any] = []
            tpm_detected = False

            tpm_indicators = [
                "Tbsi_",
                "Tpm2_",
                "TBS_",
                "NCryptCreatePersistedKey",
                "PCRExtend",
                "GetTPMOwnerInformation",
                "TakeOwnership",
            ]

            imports = self.import_analyzer.get_imports()
            imports_list = imports.get("imports", []) if isinstance(imports, dict) else []
            for imp in imports_list:
                if isinstance(imp, dict):
                    imp_name = imp.get("name", "").lower()
                    if any(tpm_func.lower() in imp_name for tpm_func in tpm_indicators):
                        tpm_detected = True
                        hardware_checks.append(
                            {
                                "type": "tpm_api_call",
                                "function": imp_name,
                                "address": imp.get("plt", 0),
                            },
                        )

            dongle_indicators = [
                "hasp",
                "safenet",
                "rockey",
                "eutron",
                "marx",
                "codemeter",
                "wibu",
                "aladdin",
                "rainbow",
                "hardlock",
                "superpro",
            ]

            strings = self.string_analyzer.get_strings()
            strings_list = strings.get("strings", []) if isinstance(strings, dict) else []
            for string_data in strings_list:
                if isinstance(string_data, dict):
                    string_val = string_data.get("string", "").lower()
                    for dongle in dongle_indicators:
                        if dongle in string_val:
                            if dongle not in dongles_detected:
                                dongles_detected.append(dongle)
                            hardware_checks.append(
                                {
                                    "type": "dongle_string",
                                    "dongle_type": dongle,
                                    "string": string_val,
                                    "address": string_data.get("vaddr", 0),
                                },
                            )

            try:
                protocol_results = self.protocol_fingerprinter.analyze_binary(self.binary_path)
                if isinstance(protocol_results, dict) and protocol_results.get("protocols_detected"):
                    protocol_fingerprints = protocol_results["protocols_detected"]
            except Exception as e:
                self.logger.debug("Protocol fingerprinting error: %s", e)

            bypass_complexity = "unknown"
            recommended_approach: str | None = None
            if tpm_detected or dongles_detected:
                if len(dongles_detected) > 2:
                    bypass_complexity = "high"
                    recommended_approach = "multi_emulation"
                elif tpm_detected:
                    bypass_complexity = "medium"
                    recommended_approach = "tpm_virtualization"
                else:
                    bypass_complexity = "low"
                    recommended_approach = "single_dongle_emulation"

            return {
                "tpm_detected": tpm_detected,
                "dongles_detected": dongles_detected,
                "hardware_checks": hardware_checks,
                "protocol_fingerprints": protocol_fingerprints,
                "bypass_complexity": bypass_complexity,
                "recommended_approach": recommended_approach,
            }

        except Exception as e:
            self.logger.exception("Error analyzing hardware protections: %s", e)
            return {
                "tpm_detected": False,
                "dongles_detected": [],
                "hardware_checks": [],
                "error": str(e),
            }

    def _analyze_tpm_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze opportunities for bypassing TPM-based licensing and protection checks.

        Evaluates detected TPM usage and identifies API hooking targets and
        virtualization approaches to circumvent TPM-based licensing protections.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with TPM detection status, bypass techniques, API hooking
            opportunities, and integration options with privilege escalation.

        """
        try:
            hardware_analysis = vuln_results.get("hardware_protection_analysis", {})
            if not isinstance(hardware_analysis, dict):
                hardware_analysis = {}

            if not hardware_analysis.get("tpm_detected", False):
                return {
                    "tpm_present": False,
                    "bypass_needed": False,
                    "analysis_status": "no_tpm_detected",
                }

            bypass_techniques: list[dict[str, Any]] = []
            api_hooking_opportunities: list[dict[str, Any]] = []

            try:
                bypass_methods = self.tpm_bypass.get_available_bypass_methods()
                bypass_techniques = [
                    {
                        "technique": method,
                        "module": "tpm_bypass",
                        "success_rate": 0.75,
                        "complexity": "medium",
                    }
                    for method in bypass_methods
                ]
            except Exception as bypass_error:
                self.logger.warning("Error getting TPM bypass methods: %s", bypass_error)

            hardware_checks = hardware_analysis.get("hardware_checks", [])
            if isinstance(hardware_checks, list):
                for check in hardware_checks:
                    if isinstance(check, dict) and check.get("type") == "tpm_api_call":
                        addr = check.get("address", 0)
                        api_hooking_opportunities.append(
                            {
                                "function": check.get("function", ""),
                                "address": hex(addr) if isinstance(addr, int) and addr else "unknown",
                                "hook_feasibility": "high",
                                "bypass_method": "api_redirection",
                            },
                        )

            complexity_assessment = "medium"
            if len(api_hooking_opportunities) > 5:
                complexity_assessment = "high"
            elif len(api_hooking_opportunities) > 2:
                complexity_assessment = "medium"
            else:
                complexity_assessment = "low"

            integration_opportunities: list[dict[str, Any]] = []
            privilege_escalation_vulns = vuln_results.get("privilege_escalation", [])
            if isinstance(privilege_escalation_vulns, list):
                for vuln in privilege_escalation_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        integration_opportunities.append(
                            {
                                "vulnerability": func_name,
                                "bypass_technique": "privilege_escalation_tpm_bypass",
                                "description": f"Use privilege escalation to bypass TPM checks in {func_name}",
                            },
                        )

            return {
                "tpm_present": True,
                "bypass_needed": True,
                "bypass_techniques": bypass_techniques,
                "virtual_tpm_feasible": True,
                "api_hooking_opportunities": api_hooking_opportunities,
                "complexity_assessment": complexity_assessment,
                "integration_opportunities": integration_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing TPM bypass opportunities: %s", e)
            return {"tpm_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_dongle_bypass_opportunities(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze opportunities for emulating and bypassing USB dongle protections.

        Identifies detected hardware dongles and formulates emulation strategies
        for common dongle types (HASP, SafeNet, etc.) based on API hooking patterns.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with detected dongle types, emulation strategies, API hooking
            targets, and overall bypass complexity assessment.

        """
        try:
            hardware_analysis = vuln_results.get("hardware_protection_analysis", {})
            if not isinstance(hardware_analysis, dict):
                hardware_analysis = {}

            detected_dongles = hardware_analysis.get("dongles_detected", [])
            if not isinstance(detected_dongles, list):
                detected_dongles = []

            if not detected_dongles:
                return {
                    "dongles_present": False,
                    "bypass_needed": False,
                    "analysis_status": "no_dongles_detected",
                }

            emulation_strategies: list[dict[str, Any]] = []
            api_hooking_targets: list[dict[str, Any]] = []

            try:
                for dongle_type in detected_dongles:
                    emulation_config = self.dongle_emulator.get_dongle_config(dongle_type)
                    if emulation_config and isinstance(emulation_config, dict):
                        emulation_strategies.append(
                            {
                                "dongle_type": dongle_type,
                                "emulation_method": emulation_config.get("method", "api_hooking"),
                                "success_rate": 0.85,
                                "complexity": emulation_config.get("complexity", "medium"),
                            },
                        )
            except Exception as emulation_error:
                self.logger.warning("Error getting dongle emulation strategies: %s", emulation_error)

            hardware_checks = hardware_analysis.get("hardware_checks", [])
            if isinstance(hardware_checks, list):
                for check in hardware_checks:
                    if isinstance(check, dict) and check.get("type") == "dongle_string":
                        addr = check.get("address", 0)
                        api_hooking_targets.append(
                            {
                                "dongle_type": check.get("dongle_type", ""),
                                "string_reference": check.get("string", ""),
                                "address": hex(addr) if isinstance(addr, int) and addr else "unknown",
                                "hook_priority": "high",
                            },
                        )

            bypass_complexity = "medium"
            if len(detected_dongles) > 3:
                bypass_complexity = "very_high"
            elif len(detected_dongles) > 1:
                bypass_complexity = "high"

            integration_opportunities: list[dict[str, Any]] = []
            code_injection_vulns = vuln_results.get("code_injection", [])
            if isinstance(code_injection_vulns, list) and code_injection_vulns and emulation_strategies:
                for vuln in code_injection_vulns:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "unknown") if isinstance(func_data, dict) else "unknown"
                        integration_opportunities.extend(
                            {
                                "vulnerability": func_name,
                                "dongle_type": strategy["dongle_type"],
                                "bypass_method": "code_injection_dongle_emulation",
                                "description": f"Use code injection to emulate {strategy['dongle_type']} dongle",
                            }
                            for strategy in emulation_strategies
                        )
            return {
                "dongles_present": True,
                "bypass_needed": True,
                "detected_dongle_types": detected_dongles,
                "emulation_strategies": emulation_strategies,
                "api_hooking_targets": api_hooking_targets,
                "bypass_complexity": bypass_complexity,
                "integration_opportunities": integration_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing dongle bypass opportunities: %s", e)
            return {"dongles_present": False, "bypass_needed": False, "error": str(e)}

    def _analyze_commercial_licenses(self, r2: R2SessionType, vuln_results: dict[str, Any]) -> dict[str, Any]:
        """Analyze commercial license protection systems (FlexLM, HASP, CodeMeter).

        Identifies and analyzes common commercial license protection systems used
        in the binary, including available bypass strategies through API hooking,
        binary patching, and runtime emulation.

        Args:
            r2: Radare2 session for binary analysis.
            vuln_results: Dictionary containing vulnerability analysis results.

        Returns:
            Dictionary with detected license systems, bypass strategies, API hooks,
            available patches, and exploitation opportunity assessment.

        """
        try:
            license_analysis = self.commercial_license_analyzer.analyze_binary()

            vulnerability_integration: list[dict[str, Any]] = []
            exploitation_opportunities: list[dict[str, Any]] = []

            detected_systems = license_analysis.get("detected_systems", []) if isinstance(license_analysis, dict) else []
            license_servers = license_analysis.get("license_servers", []) if isinstance(license_analysis, dict) else []
            bypass_strategies = license_analysis.get("bypass_strategies", {}) if isinstance(license_analysis, dict) else {}
            confidence = license_analysis.get("confidence", 0.0) if isinstance(license_analysis, dict) else 0.0

            vulnerabilities_list = vuln_results.get("vulnerabilities", [])
            if isinstance(vulnerabilities_list, list):
                for vuln in vulnerabilities_list:
                    if isinstance(vuln, dict):
                        func_data = vuln.get("function", {})
                        func_name = func_data.get("name", "").lower() if isinstance(func_data, dict) else ""

                        if any(lic in func_name for lic in ["license", "auth", "validate", "check"]):
                            vulnerability_integration.append(
                                {
                                    "function": func_name,
                                    "vulnerability_type": vuln.get("type"),
                                    "exploit_potential": "license_bypass_injection",
                                },
                            )

            if isinstance(bypass_strategies, dict):
                for system, strategy in bypass_strategies.items():
                    if isinstance(strategy, dict):
                        hooks = strategy.get("hooks")
                        if hooks and isinstance(hooks, list):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "api_hooking",
                                    "hooks_available": len(hooks),
                                    "success_rate": 0.85,
                                },
                            )

                        patches = strategy.get("patches")
                        if patches and isinstance(patches, list):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "binary_patching",
                                    "patches_available": len(patches),
                                    "success_rate": 0.90,
                                },
                            )

                        if strategy.get("emulation_script"):
                            exploitation_opportunities.append(
                                {
                                    "system": system,
                                    "method": "runtime_emulation",
                                    "script_type": "Frida",
                                    "success_rate": 0.95,
                                },
                            )

            return {
                "detected_systems": detected_systems,
                "license_servers": license_servers,
                "bypass_strategies": bypass_strategies,
                "confidence": confidence,
                "vulnerability_integration": vulnerability_integration,
                "exploitation_opportunities": exploitation_opportunities,
            }

        except Exception as e:
            self.logger.exception("Error analyzing commercial licenses: %s", e)
            return {"detected_systems": [], "bypass_needed": False, "error": str(e)}


def analyze_binary_vulnerabilities(binary_path: str, radare2_path: str | None = None) -> dict[str, Any]:
    """Perform comprehensive vulnerability analysis on a binary.

    Args:
        binary_path: Path to binary file
        radare2_path: Optional path to radare2 executable

    Returns:
        Complete vulnerability analysis results

    """
    engine = R2VulnerabilityEngine(binary_path, radare2_path)
    return engine.analyze_vulnerabilities()


__all__ = ["R2VulnerabilityEngine", "analyze_binary_vulnerabilities"]
