"""Bypass Engine Module - Central engine for exploit mitigation bypasses.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see https://www.gnu.org/licenses/.
"""

import struct
from enum import Enum
from typing import Any

from ...utils.logger import get_logger
from ..shared.bypass_config import BypassConfig


class PayloadType(Enum):
    """Types of license bypass payloads that can be generated."""

    LICENSE_CHECK_BYPASS = "license_check_bypass"
    TRIAL_EXTENSION = "trial_extension"
    ACTIVATION_BYPASS = "activation_bypass"
    SERIAL_VALIDATION_BYPASS = "serial_validation_bypass"
    HARDWARE_ID_SPOOF = "hardware_id_spoof"
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    STAGED_PAYLOAD = "staged_payload"


class BypassEngine:
    """Engine for exploit mitigation bypass techniques."""

    def __init__(self) -> None:
        """Initialize the bypass engine with detection and exploitation capabilities."""
        self.logger = get_logger(__name__)

    def analyze_bypass_capabilities(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Analyze available bypass capabilities for a target.

        Args:
            target_info: Dictionary containing target protection information with keys like
                'aslr_enabled', 'dep_enabled', 'cfi_enabled', 'cfg_enabled', 'cet_enabled'.

        Returns:
            Dictionary containing 'bypasses_available' list, 'target_info' dict, and 'bypass_count' int.

        """
        return BypassConfig.analyze_bypass_capabilities(target_info)

    def get_available_bypasses(self) -> list[str]:
        """Get list of all available bypass types.

        Returns:
            List of available bypass type identifiers.

        """
        return BypassConfig.get_available_bypasses()

    def get_bypass_info(self, bypass_type: str) -> dict[str, Any]:
        """Get detailed information about a specific bypass type.

        Args:
            bypass_type: The bypass type identifier (e.g., 'aslr_bypass', 'dep_bypass').

        Returns:
            Dictionary containing bypass details including description, target_protection,
            difficulty, and reliability rating.

        """
        return BypassConfig.get_bypass_info(bypass_type)

    def get_recommended_bypasses(self, target_info: dict[str, Any], min_reliability: int = 6) -> list[str]:
        """Get recommended bypasses based on target and reliability threshold.

        Args:
            target_info: Dictionary containing target protection information with keys like
                'aslr_enabled', 'dep_enabled', 'cfi_enabled', 'cfg_enabled', 'cet_enabled'.
            min_reliability: Minimum reliability rating (0-10) for recommended bypasses. Defaults to 6.

        Returns:
            List of recommended bypass type identifiers that meet the reliability threshold.

        """
        return BypassConfig.get_recommended_bypasses(target_info, min_reliability)

    def generate_payload(
        self,
        payload_type: PayloadType | str,
        architecture: Any,
        target_info: dict[str, Any],
        options: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Generate a license bypass payload for the specified target.

        Creates architecture-specific binary code sequences designed to bypass
        software licensing protections including license checks, trial limitations,
        activation requirements, and serial validation.

        Args:
            payload_type: Type of bypass payload to generate (PayloadType enum or string).
            architecture: Target architecture (Architecture enum or string like 'x86', 'x64').
            target_info: Dictionary containing target information with keys:
                - os_type: Operating system type ('windows', 'linux', 'macos')
                - os_version: OS version string
                - architecture: Target arch string
                - protections: List of detected protections
                - av_products: List of AV products to evade
                - network_config: Network configuration dict
                - process_info: Target process information
            options: Optional dictionary with generation options:
                - lhost: Listener host for callbacks
                - lport: Listener port
                - encoding_schemes: List of encoding transformations to apply
                - output_format: Output format ('raw', 'exe', 'dll', 'powershell', 'python', 'c')
                - mode: Generation mode ('template' or 'custom')
                - template: Template name when mode is 'template'
                - return_value: Value to return from bypassed function (default: 1)
                - preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Dictionary containing:
                - payload: Generated binary payload bytes
                - size: Payload size in bytes
                - architecture: Target architecture used
                - payload_type: Type of payload generated
                - null_bytes: Count of null bytes in payload
                - metadata: Additional payload metadata

        Raises:
            ValueError: If payload_type or architecture is invalid.
        """
        if options is None:
            options = {}

        if isinstance(payload_type, str):
            try:
                payload_type = PayloadType[payload_type.upper()]
            except KeyError:
                payload_type = PayloadType.LICENSE_CHECK_BYPASS

        arch_str = architecture.value if hasattr(architecture, "value") else str(architecture).lower()

        self.logger.info("Generating %s payload for %s", payload_type.value, arch_str)

        payload_generators = {
            PayloadType.LICENSE_CHECK_BYPASS: self._generate_license_check_bypass,
            PayloadType.TRIAL_EXTENSION: self._generate_trial_extension,
            PayloadType.ACTIVATION_BYPASS: self._generate_activation_bypass,
            PayloadType.SERIAL_VALIDATION_BYPASS: self._generate_serial_validation_bypass,
            PayloadType.HARDWARE_ID_SPOOF: self._generate_hardware_id_spoof,
            PayloadType.REVERSE_SHELL: self._generate_license_check_bypass,
            PayloadType.BIND_SHELL: self._generate_license_check_bypass,
            PayloadType.STAGED_PAYLOAD: self._generate_license_check_bypass,
        }

        generator = payload_generators.get(payload_type, self._generate_license_check_bypass)
        payload = generator(arch_str, target_info, options)

        output_format = options.get("output_format", "raw")
        if output_format != "raw":
            payload = self._format_payload(payload, output_format, arch_str)

        encoding_schemes = options.get("encoding_schemes", [])
        for scheme in encoding_schemes:
            payload = self._apply_encoding(payload, scheme)

        return {
            "payload": payload,
            "size": len(payload),
            "architecture": arch_str,
            "payload_type": payload_type.value,
            "null_bytes": payload.count(b"\x00"),
            "metadata": {
                "encoding_applied": encoding_schemes,
                "output_format": output_format,
                "target_os": target_info.get("os_type", "unknown"),
            },
        }

    def _generate_license_check_bypass(
        self,
        architecture: str,
        target_info: dict[str, Any],
        options: dict[str, Any],
    ) -> bytes:
        """Generate license check bypass shellcode."""
        _ = target_info
        return_value = options.get("return_value", 1)
        preserve_stack = options.get("preserve_stack", True)

        if architecture in {"x64", "x86_64", "amd64"}:
            return self._generate_x64_license_bypass(return_value, preserve_stack)
        elif architecture in {"x86", "i386", "i686"}:
            return self._generate_x86_license_bypass(return_value, preserve_stack)
        elif architecture in {"arm64", "aarch64"}:
            return self._generate_arm64_license_bypass(return_value, preserve_stack)
        elif architecture in {"arm", "armv7"}:
            return self._generate_arm_license_bypass(return_value, preserve_stack)
        else:
            self.logger.warning("Unknown architecture %s, defaulting to x64", architecture)
            return self._generate_x64_license_bypass(return_value, preserve_stack)

    def _generate_x64_license_bypass(self, return_value: int, preserve_stack: bool) -> bytes:
        """Generate x64 Windows license bypass with proper calling convention."""
        code = bytearray()

        if preserve_stack:
            code.extend(b"\x55")
            code.extend(b"\x48\x89\xe5")
            code.extend(b"\x48\x83\xec\x20")

        code.extend(b"\x48\xc7\xc0")
        code.extend(struct.pack("<I", return_value & 0xFFFFFFFF))

        if preserve_stack:
            code.extend(b"\x48\x83\xc4\x20")
            code.extend(b"\x5d")

        code.extend(b"\xc3")

        return bytes(code)

    def _generate_x86_license_bypass(self, return_value: int, preserve_stack: bool) -> bytes:
        """Generate x86 license bypass with cdecl calling convention."""
        code = bytearray()

        if preserve_stack:
            code.extend(b"\x55")
            code.extend(b"\x89\xe5")

        code.extend(b"\xb8")
        code.extend(struct.pack("<I", return_value & 0xFFFFFFFF))

        if preserve_stack:
            code.extend(b"\x5d")

        code.extend(b"\xc3")

        return bytes(code)

    def _generate_arm64_license_bypass(self, return_value: int, preserve_stack: bool) -> bytes:
        """Generate ARM64 license bypass shellcode."""
        code = bytearray()

        if preserve_stack:
            code.extend(struct.pack("<I", 0xA9BF7BFD))
            code.extend(struct.pack("<I", 0x910003FD))

        if return_value == 0:
            code.extend(struct.pack("<I", 0xD2800000))
        elif return_value == 1:
            code.extend(struct.pack("<I", 0xD2800020))
        else:
            code.extend(struct.pack("<I", 0xD2800000 | ((return_value & 0xFFFF) << 5)))

        if preserve_stack:
            code.extend(struct.pack("<I", 0xA8C17BFD))

        code.extend(struct.pack("<I", 0xD65F03C0))

        return bytes(code)

    def _generate_arm_license_bypass(self, return_value: int, preserve_stack: bool) -> bytes:
        """Generate ARM32 license bypass shellcode."""
        code = bytearray()

        if preserve_stack:
            code.extend(struct.pack("<I", 0xE92D4800))
            code.extend(struct.pack("<I", 0xE28DB000))

        code.extend(struct.pack("<I", 0xE3A00000 | (return_value & 0xFF)))

        if preserve_stack:
            code.extend(struct.pack("<I", 0xE8BD8800))
        else:
            code.extend(struct.pack("<I", 0xE12FFF1E))

        return bytes(code)

    def _generate_trial_extension(
        self,
        architecture: str,
        target_info: dict[str, Any],
        options: dict[str, Any],
    ) -> bytes:
        """Generate trial period extension bypass."""
        return self._generate_license_check_bypass(architecture, target_info, {**options, "return_value": 0x7FFFFFFF})

    def _generate_activation_bypass(
        self,
        architecture: str,
        target_info: dict[str, Any],
        options: dict[str, Any],
    ) -> bytes:
        """Generate activation check bypass."""
        return self._generate_license_check_bypass(architecture, target_info, {**options, "return_value": 1})

    def _generate_serial_validation_bypass(
        self,
        architecture: str,
        target_info: dict[str, Any],
        options: dict[str, Any],
    ) -> bytes:
        """Generate serial validation bypass."""
        return self._generate_license_check_bypass(architecture, target_info, {**options, "return_value": 1})

    def _generate_hardware_id_spoof(
        self,
        architecture: str,
        target_info: dict[str, Any],
        options: dict[str, Any],
    ) -> bytes:
        """Generate hardware ID spoofing shellcode."""
        spoofed_hwid = options.get("spoofed_hwid", b"\x00" * 16)

        if architecture not in {"x64", "x86_64", "amd64"}:
            return self._generate_license_check_bypass(architecture, target_info, options)
        code = bytearray()
        code.extend(b"\x55")
        code.extend(b"\x48\x89\xe5")
        code.extend(b"\x48\x83\xec\x20")

        code.extend(b"\x48\x8d\x05")
        offset = len(spoofed_hwid) + 10
        code.extend(struct.pack("<i", offset))

        code.extend(b"\x48\x83\xc4\x20")
        code.extend(b"\x5d")
        code.extend(b"\xc3")

        code.extend(spoofed_hwid[:16].ljust(16, b"\x00"))

        return bytes(code)

    def _format_payload(self, payload: bytes, output_format: str, architecture: str) -> bytes:
        """Format payload for different output types."""
        if output_format == "c":
            c_array = ", ".join(f"0x{b:02x}" for b in payload)
            return f"unsigned char payload[] = {{{c_array}}};\n".encode()

        elif output_format == "python":
            hex_str = payload.hex()
            return f'payload = bytes.fromhex("{hex_str}")\n'.encode()

        elif output_format == "powershell":
            hex_bytes = ",".join(f"0x{b:02x}" for b in payload)
            return f"[Byte[]]$payload = {hex_bytes}\n".encode()

        elif output_format in {"exe", "dll"}:
            return self._wrap_as_pe(payload, architecture, output_format == "dll")

        return payload

    def _wrap_as_pe(self, shellcode: bytes, architecture: str, is_dll: bool) -> bytes:
        """Wrap shellcode in minimal PE structure."""
        is_64bit = architecture in {"x64", "x86_64", "amd64"}

        dos_header = bytearray(64)
        dos_header[:2] = b"MZ"
        dos_header[60:64] = struct.pack("<I", 64)

        if is_64bit:
            machine = struct.pack("<H", 0x8664)
            optional_header_size = struct.pack("<H", 112)
            magic = struct.pack("<H", 0x20B)
        else:
            machine = struct.pack("<H", 0x14C)
            optional_header_size = struct.pack("<H", 96)
            magic = struct.pack("<H", 0x10B)

        pe_sig = b"PE\x00\x00"
        characteristics = struct.pack("<H", 0x0022 if is_dll else 0x0002)

        file_header = pe_sig + machine + struct.pack("<H", 1) + b"\x00" * 12 + optional_header_size + characteristics

        section_alignment = 0x1000
        file_alignment = 0x200
        code_rva = 0x1000
        code_size = ((len(shellcode) + file_alignment - 1) // file_alignment) * file_alignment

        optional_header = bytearray(112 if is_64bit else 96)
        optional_header[:2] = magic
        optional_header[16:20] = struct.pack("<I", code_rva)

        if is_64bit:
            optional_header[24:32] = struct.pack("<Q", 0x10000)
            optional_header[32:36] = struct.pack("<I", section_alignment)
            optional_header[36:40] = struct.pack("<I", file_alignment)
            optional_header[56:60] = struct.pack("<I", code_rva + code_size)
            optional_header[60:64] = struct.pack("<I", code_size)
        else:
            optional_header[28:32] = struct.pack("<I", 0x10000)
            optional_header[32:36] = struct.pack("<I", section_alignment)
            optional_header[36:40] = struct.pack("<I", file_alignment)
            optional_header[52:56] = struct.pack("<I", code_rva + code_size)
            optional_header[56:60] = struct.pack("<I", code_size)

        section_header = bytearray(40)
        section_header[:8] = b".text\x00\x00\x00"
        section_header[8:12] = struct.pack("<I", len(shellcode))
        section_header[12:16] = struct.pack("<I", code_rva)
        section_header[16:20] = struct.pack("<I", code_size)
        section_header[20:24] = struct.pack("<I", 0x200)
        section_header[36:40] = struct.pack("<I", 0x60000020)

        headers = bytes(dos_header) + bytes(file_header) + bytes(optional_header) + bytes(section_header)
        headers = headers.ljust(0x200, b"\x00")

        code_section = shellcode.ljust(code_size, b"\x00")

        return headers + code_section

    def _apply_encoding(self, payload: bytes, scheme: str) -> bytes:
        """Apply encoding transformation to payload."""
        if scheme == "base64":
            import base64

            return base64.b64encode(payload)

        elif scheme == "null_free":
            result = bytearray()
            for b in payload:
                if b == 0:
                    result.extend(b"\x90\x90")
                else:
                    result.append(b)
            return bytes(result)

        elif scheme == "reverse":
            return payload[::-1]

        elif scheme == "rot13":
            return bytes((b + 13) % 256 for b in payload)

        elif scheme == "xor":
            return bytes(b ^ 0x41 for b in payload)

        return payload


__all__ = ["BypassEngine", "PayloadType"]
