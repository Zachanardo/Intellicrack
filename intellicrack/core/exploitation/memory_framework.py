"""
Core Memory Manipulation Framework

Advanced memory manipulation capabilities using direct syscalls
to bypass API hooks and enable low-level memory operations.

Copyright (C) 2025 Zachary Flint
Licensed under GNU General Public License v3.0
"""

import ctypes
import logging
import platform
import struct
import sys
from ctypes import wintypes, windll
from typing import Any, Dict, List, Optional, Tuple, Union

logger = logging.getLogger(__name__)


class WindowsVersion:
    """Windows version detection for syscall compatibility"""
    
    def __init__(self):
        self.major, self.minor, self.build = self._get_version()
        self.is_win10_or_later = self.major >= 10
        self.is_win11 = self.major >= 10 and self.build >= 22000
    
    def _get_version(self) -> Tuple[int, int, int]:
        """Get Windows version information"""
        try:
            version = platform.version().split('.')
            major = int(version[0])
            minor = int(version[1]) if len(version) > 1 else 0
            build = int(version[2]) if len(version) > 2 else 0
            return major, minor, build
        except (ValueError, IndexError):
            return 10, 0, 19041  # Default to Win10


class SyscallNumbers:
    """Dynamic syscall number resolution for different Windows versions"""
    
    def __init__(self, win_version: WindowsVersion):
        self.win_version = win_version
        self._syscall_map = self._initialize_syscall_map()
    
    def _initialize_syscall_map(self) -> Dict[str, int]:
        """Initialize syscall numbers based on Windows version"""
        if self.win_version.is_win11:
            return self._get_win11_syscalls()
        elif self.win_version.is_win10_or_later:
            return self._get_win10_syscalls()
        else:
            return self._get_legacy_syscalls()
    
    def _get_win11_syscalls(self) -> Dict[str, int]:
        """Windows 11 syscall numbers"""
        return {
            'NtAllocateVirtualMemory': 0x18,
            'NtFreeVirtualMemory': 0x1E,
            'NtProtectVirtualMemory': 0x50,
            'NtReadVirtualMemory': 0x3F,
            'NtWriteVirtualMemory': 0x3A,
            'NtQueryVirtualMemory': 0x23,
            'NtOpenProcess': 0x26,
            'NtClose': 0x0F,
            'NtCreateSection': 0x4A,
            'NtMapViewOfSection': 0x28,
            'NtUnmapViewOfSection': 0x2A,
            'NtSuspendProcess': 0x19D,
            'NtResumeProcess': 0x19E,
            'NtCreateThread': 0x4E,
            'NtSetContextThread': 0x18A,
            'NtGetContextThread': 0x18B,
        }
    
    def _get_win10_syscalls(self) -> Dict[str, int]:
        """Windows 10 syscall numbers"""
        return {
            'NtAllocateVirtualMemory': 0x18,
            'NtFreeVirtualMemory': 0x1E,
            'NtProtectVirtualMemory': 0x50,
            'NtReadVirtualMemory': 0x3F,
            'NtWriteVirtualMemory': 0x3A,
            'NtQueryVirtualMemory': 0x23,
            'NtOpenProcess': 0x26,
            'NtClose': 0x0F,
            'NtCreateSection': 0x4A,
            'NtMapViewOfSection': 0x28,
            'NtUnmapViewOfSection': 0x2A,
            'NtSuspendProcess': 0x19A,
            'NtResumeProcess': 0x19B,
            'NtCreateThread': 0x4E,
            'NtSetContextThread': 0x187,
            'NtGetContextThread': 0x188,
        }
    
    def _get_legacy_syscalls(self) -> Dict[str, int]:
        """Legacy Windows syscall numbers"""
        return {
            'NtAllocateVirtualMemory': 0x15,
            'NtFreeVirtualMemory': 0x1B,
            'NtProtectVirtualMemory': 0x4D,
            'NtReadVirtualMemory': 0x3C,
            'NtWriteVirtualMemory': 0x37,
            'NtQueryVirtualMemory': 0x20,
            'NtOpenProcess': 0x23,
            'NtClose': 0x0C,
            'NtCreateSection': 0x47,
            'NtMapViewOfSection': 0x25,
            'NtUnmapViewOfSection': 0x27,
            'NtSuspendProcess': 0x197,
            'NtResumeProcess': 0x198,
            'NtCreateThread': 0x4B,
            'NtSetContextThread': 0x184,
            'NtGetContextThread': 0x185,
        }
    
    def get_syscall_number(self, function_name: str) -> Optional[int]:
        """Get syscall number for a function"""
        return self._syscall_map.get(function_name)


class DirectSyscallManager:
    """Direct syscall interface bypassing API hooks"""
    
    def __init__(self):
        self.win_version = WindowsVersion()
        self.syscalls = SyscallNumbers(self.win_version)
        self._is_initialized = False
        self._initialize_syscalls()
    
    def _initialize_syscalls(self):
        """Initialize direct syscall capabilities"""
        try:
            # Prepare syscall stub templates
            self._prepare_syscall_stubs()
            self._is_initialized = True
            logger.info("Direct syscall manager initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize direct syscalls: {e}")
            self._is_initialized = False
    
    def _prepare_syscall_stubs(self):
        """Prepare syscall stub assembly code"""
        # x64 syscall stub template
        self.x64_syscall_stub = bytes([
            0x4C, 0x8B, 0xD1,        # mov r10, rcx
            0xB8, 0x00, 0x00, 0x00, 0x00,  # mov eax, syscall_number (placeholder)
            0x0F, 0x05,              # syscall
            0xC3                     # ret
        ])
        
        # x86 syscall stub template for WoW64
        self.x86_syscall_stub = bytes([
            0xB8, 0x00, 0x00, 0x00, 0x00,  # mov eax, syscall_number (placeholder)
            0xBA, 0x00, 0x00, 0x00, 0x00,  # mov edx, wow64_transition (placeholder)
            0xFF, 0xD2,              # call edx
            0xC2, 0x10, 0x00         # ret 0x10
        ])
    
    def _create_syscall_function(self, syscall_name: str) -> Optional[ctypes.CFUNCTYPE]:
        """Create a callable syscall function"""
        if not self._is_initialized:
            return None
        
        syscall_number = self.syscalls.get_syscall_number(syscall_name)
        if syscall_number is None:
            logger.error(f"Unknown syscall: {syscall_name}")
            return None
        
        try:
            # Allocate executable memory for syscall stub
            stub_size = len(self.x64_syscall_stub)
            stub_addr = windll.kernel32.VirtualAlloc(
                None, stub_size, 0x3000, 0x40  # MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
            )
            
            if not stub_addr:
                logger.error("Failed to allocate memory for syscall stub")
                return None
            
            # Create syscall stub with correct syscall number
            stub_code = bytearray(self.x64_syscall_stub)
            struct.pack_into('<I', stub_code, 4, syscall_number)
            
            # Copy stub to allocated memory
            ctypes.memmove(stub_addr, bytes(stub_code), stub_size)
            
            # Create function prototype
            if syscall_name == 'NtAllocateVirtualMemory':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,  # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.POINTER(ctypes.c_void_p),  # BaseAddress
                    ctypes.c_ulong,   # ZeroBits
                    ctypes.POINTER(ctypes.c_size_t),  # RegionSize
                    wintypes.ULONG,   # AllocationType
                    wintypes.ULONG    # Protect
                )
            elif syscall_name == 'NtWriteVirtualMemory':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.c_void_p,  # BaseAddress
                    ctypes.c_void_p,  # Buffer
                    ctypes.c_size_t,  # NumberOfBytesToWrite
                    ctypes.POINTER(ctypes.c_size_t)  # NumberOfBytesWritten
                )
            elif syscall_name == 'NtReadVirtualMemory':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.c_void_p,  # BaseAddress
                    ctypes.c_void_p,  # Buffer
                    ctypes.c_size_t,  # NumberOfBytesToRead
                    ctypes.POINTER(ctypes.c_size_t)  # NumberOfBytesRead
                )
            elif syscall_name == 'NtProtectVirtualMemory':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.POINTER(ctypes.c_void_p),  # BaseAddress
                    ctypes.POINTER(ctypes.c_size_t),  # RegionSize
                    wintypes.ULONG,   # NewProtect
                    ctypes.POINTER(wintypes.ULONG)    # OldProtect
                )
            elif syscall_name == 'NtOpenProcess':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    ctypes.POINTER(wintypes.HANDLE),  # ProcessHandle
                    wintypes.ULONG,   # DesiredAccess
                    ctypes.c_void_p,  # ObjectAttributes
                    ctypes.c_void_p   # ClientId
                )
            elif syscall_name == 'NtClose':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE   # Handle
                )
            elif syscall_name == 'NtCreateSection':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    ctypes.POINTER(wintypes.HANDLE),  # SectionHandle
                    wintypes.ULONG,   # DesiredAccess
                    ctypes.c_void_p,  # ObjectAttributes
                    ctypes.POINTER(wintypes.LARGE_INTEGER),  # MaximumSize
                    wintypes.ULONG,   # PageAttributes
                    wintypes.ULONG,   # SectionAttributes
                    wintypes.HANDLE   # FileHandle
                )
            elif syscall_name == 'NtMapViewOfSection':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # SectionHandle
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.POINTER(ctypes.c_void_p),  # BaseAddress
                    ctypes.c_ulong,   # ZeroBits
                    ctypes.c_size_t,  # CommitSize
                    ctypes.POINTER(wintypes.LARGE_INTEGER),  # SectionOffset
                    ctypes.POINTER(ctypes.c_size_t),  # ViewSize
                    wintypes.ULONG,   # InheritDisposition
                    wintypes.ULONG,   # AllocationType
                    wintypes.ULONG    # Protect
                )
            elif syscall_name == 'NtUnmapViewOfSection':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.c_void_p   # BaseAddress
                )
            elif syscall_name == 'NtCreateThread':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    ctypes.POINTER(wintypes.HANDLE),  # ThreadHandle
                    wintypes.ULONG,   # DesiredAccess
                    ctypes.c_void_p,  # ObjectAttributes
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.c_void_p,  # ClientId
                    ctypes.c_void_p,  # ThreadContext
                    ctypes.c_void_p,  # InitialTeb
                    wintypes.BOOL     # CreateSuspended
                )
            elif syscall_name == 'NtQueryVirtualMemory':
                func_type = ctypes.WINFUNCTYPE(
                    wintypes.ULONG,   # NTSTATUS
                    wintypes.HANDLE,  # ProcessHandle
                    ctypes.c_void_p,  # BaseAddress
                    wintypes.ULONG,   # MemoryInformationClass
                    ctypes.c_void_p,  # MemoryInformation
                    ctypes.c_size_t,  # MemoryInformationLength
                    ctypes.POINTER(ctypes.c_size_t)  # ReturnLength
                )
            else:
                # Generic function type for other syscalls
                func_type = ctypes.WINFUNCTYPE(wintypes.ULONG)
                logger.warning(f"Using generic prototype for {syscall_name}")
            
            # Flush instruction cache to ensure CPU sees our changes
            windll.kernel32.FlushInstructionCache(
                windll.kernel32.GetCurrentProcess(),
                stub_addr,
                stub_size
            )
            
            return func_type(stub_addr)
            
        except Exception as e:
            logger.error(f"Failed to create syscall function {syscall_name}: {e}")
            if stub_addr:
                windll.kernel32.VirtualFree(stub_addr, 0, 0x8000)  # MEM_RELEASE
            return None
    
    def allocate_memory(self, process_handle: int, size: int, 
                       allocation_type: int = 0x3000, protection: int = 0x40) -> Optional[int]:
        """Allocate memory using direct syscall"""
        if not self._is_initialized:
            return None
        
        try:
            nt_allocate = self._create_syscall_function('NtAllocateVirtualMemory')
            if not nt_allocate:
                return None
            
            base_address = ctypes.c_void_p(0)
            region_size = ctypes.c_size_t(size)
            
            status = nt_allocate(
                process_handle,
                ctypes.byref(base_address),
                0,  # ZeroBits
                ctypes.byref(region_size),
                allocation_type,
                protection
            )
            
            if status == 0:  # STATUS_SUCCESS
                return base_address.value
            else:
                logger.error(f"NtAllocateVirtualMemory failed with status: 0x{status:08X}")
                return None
                
        except Exception as e:
            logger.error(f"Memory allocation failed: {e}")
            return None
    
    def write_memory(self, process_handle: int, address: int, data: bytes) -> bool:
        """Write memory using direct syscall"""
        if not self._is_initialized:
            return False
        
        try:
            nt_write = self._create_syscall_function('NtWriteVirtualMemory')
            if not nt_write:
                return False
            
            bytes_written = ctypes.c_size_t(0)
            
            status = nt_write(
                process_handle,
                address,
                data,
                len(data),
                ctypes.byref(bytes_written)
            )
            
            if status == 0:  # STATUS_SUCCESS
                return bytes_written.value == len(data)
            else:
                logger.error(f"NtWriteVirtualMemory failed with status: 0x{status:08X}")
                return False
                
        except Exception as e:
            logger.error(f"Memory write failed: {e}")
            return False
    
    def read_memory(self, process_handle: int, address: int, size: int) -> Optional[bytes]:
        """Read memory using direct syscall"""
        if not self._is_initialized:
            return None
        
        try:
            nt_read = self._create_syscall_function('NtReadVirtualMemory')
            if not nt_read:
                return None
            
            buffer = ctypes.create_string_buffer(size)
            bytes_read = ctypes.c_size_t(0)
            
            status = nt_read(
                process_handle,
                address,
                buffer,
                size,
                ctypes.byref(bytes_read)
            )
            
            if status == 0:  # STATUS_SUCCESS
                return buffer.raw[:bytes_read.value]
            else:
                logger.error(f"NtReadVirtualMemory failed with status: 0x{status:08X}")
                return None
                
        except Exception as e:
            logger.error(f"Memory read failed: {e}")
            return None
    
    def protect_memory(self, process_handle: int, address: int, size: int, 
                      new_protection: int) -> Optional[int]:
        """Change memory protection using direct syscall"""
        if not self._is_initialized:
            return None
        
        try:
            nt_protect = self._create_syscall_function('NtProtectVirtualMemory')
            if not nt_protect:
                return None
            
            base_address = ctypes.c_void_p(address)
            region_size = ctypes.c_size_t(size)
            old_protection = wintypes.ULONG(0)
            
            status = nt_protect(
                process_handle,
                ctypes.byref(base_address),
                ctypes.byref(region_size),
                new_protection,
                ctypes.byref(old_protection)
            )
            
            if status == 0:  # STATUS_SUCCESS
                return old_protection.value
            else:
                logger.error(f"NtProtectVirtualMemory failed with status: 0x{status:08X}")
                return None
                
        except Exception as e:
            logger.error(f"Memory protection change failed: {e}")
            return None


class AdvancedMemoryOperations:
    """Advanced memory manipulation techniques"""
    
    def __init__(self):
        self.syscall_manager = DirectSyscallManager()
        self.current_process = windll.kernel32.GetCurrentProcess()
    
    def allocate_executable_memory(self, size: int) -> Optional[int]:
        """Allocate executable memory"""
        return self.syscall_manager.allocate_memory(
            self.current_process, size, 0x3000, 0x40  # RWX
        )
    
    def inject_shellcode(self, target_process: int, shellcode: bytes) -> Optional[int]:
        """Inject shellcode into target process"""
        # Allocate memory in target process
        alloc_addr = self.syscall_manager.allocate_memory(target_process, len(shellcode))
        if not alloc_addr:
            return None
        
        # Write shellcode
        if not self.syscall_manager.write_memory(target_process, alloc_addr, shellcode):
            return None
        
        # Make memory executable
        old_protect = self.syscall_manager.protect_memory(
            target_process, alloc_addr, len(shellcode), 0x20  # PAGE_EXECUTE_READ
        )
        
        if old_protect is not None:
            return alloc_addr
        else:
            return None
    
    def create_code_cave(self, target_process: int, size: int) -> Optional[int]:
        """Create a code cave in target process"""
        return self.syscall_manager.allocate_memory(
            target_process, size, 0x3000, 0x40  # RWX
        )
    
    def patch_memory(self, target_process: int, address: int, 
                    original_bytes: bytes, patch_bytes: bytes) -> bool:
        """Patch memory with backup capability"""
        # Verify original bytes match
        current_bytes = self.syscall_manager.read_memory(
            target_process, address, len(original_bytes)
        )
        
        if current_bytes != original_bytes:
            logger.warning("Original bytes don't match, patching anyway")
        
        # Apply patch
        return self.syscall_manager.write_memory(target_process, address, patch_bytes)
    
    def scan_memory_pattern(self, target_process: int, start_addr: int, 
                          end_addr: int, pattern: bytes, mask: Optional[str] = None) -> List[int]:
        """Scan memory for byte patterns"""
        matches = []
        chunk_size = 4096  # Scan in 4KB chunks
        
        current_addr = start_addr
        while current_addr < end_addr:
            # Read memory chunk
            read_size = min(chunk_size, end_addr - current_addr)
            data = self.syscall_manager.read_memory(target_process, current_addr, read_size)
            
            if not data:
                current_addr += chunk_size
                continue
            
            # Search for pattern
            if mask:
                # Pattern matching with mask
                pattern_matches = self._pattern_search_with_mask(data, pattern, mask)
            else:
                # Simple pattern search
                pattern_matches = self._pattern_search(data, pattern)
            
            # Add absolute addresses
            for offset in pattern_matches:
                matches.append(current_addr + offset)
            
            current_addr += chunk_size
        
        return matches
    
    def _pattern_search(self, data: bytes, pattern: bytes) -> List[int]:
        """Simple pattern search"""
        matches = []
        start = 0
        
        while True:
            pos = data.find(pattern, start)
            if pos == -1:
                break
            matches.append(pos)
            start = pos + 1
        
        return matches
    
    def _pattern_search_with_mask(self, data: bytes, pattern: bytes, mask: str) -> List[int]:
        """Pattern search with mask support - REAL IMPLEMENTATION."""
        matches = []
        
        if len(pattern) != len(mask):
            logger.error("Pattern and mask length mismatch")
            return matches
        
        # Convert mask string to binary mask
        binary_mask = []
        for char in mask:
            if char in ['x', 'X']:
                binary_mask.append(True)  # Must match
            elif char in ['?', '.']:
                binary_mask.append(False)  # Wildcard
            else:
                logger.warning(f"Unknown mask character: {char}")
                binary_mask.append(True)
        
        # Search through data
        data_len = len(data)
        pattern_len = len(pattern)
        
        if pattern_len > data_len:
            return matches
        
        # Optimize search with skip table
        skip_table = self._build_skip_table(pattern, binary_mask)
        
        i = 0
        while i <= data_len - pattern_len:
            # Check if pattern matches at current position
            match = True
            last_match_pos = 0
            
            for j in range(pattern_len):
                if binary_mask[j] and data[i + j] != pattern[j]:
                    match = False
                    last_match_pos = j
                    break
            
            if match:
                matches.append(i)
                i += 1  # Continue searching for overlapping matches
            else:
                # Use skip table for optimization
                skip = skip_table.get(data[i + last_match_pos], pattern_len)
                i += max(1, skip - last_match_pos)
        
        return matches
    
    def _build_skip_table(self, pattern: bytes, mask: List[bool]) -> Dict[int, int]:
        """Build Boyer-Moore style skip table for pattern search."""
        table = {}
        pattern_len = len(pattern)
        
        # Default skip is pattern length
        for i in range(256):
            table[i] = pattern_len
        
        # Calculate skip values for pattern bytes
        for i in range(pattern_len - 1):
            if mask[i]:  # Only for non-wildcard positions
                table[pattern[i]] = pattern_len - 1 - i
        
        return table


# Memory protection constants
PAGE_NOACCESS = 0x01
PAGE_READONLY = 0x02
PAGE_READWRITE = 0x04
PAGE_WRITECOPY = 0x08
PAGE_EXECUTE = 0x10
PAGE_EXECUTE_READ = 0x20
PAGE_EXECUTE_READWRITE = 0x40
PAGE_EXECUTE_WRITECOPY = 0x80

# Memory allocation constants
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
MEM_RESET = 0x80000
MEM_TOP_DOWN = 0x100000
MEM_WRITE_WATCH = 0x200000
MEM_PHYSICAL = 0x400000
MEM_ROTATE = 0x800000
MEM_LARGE_PAGES = 0x20000000