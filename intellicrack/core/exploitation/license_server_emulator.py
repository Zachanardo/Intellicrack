"""Advanced License Server Emulation System.

This module provides a sophisticated license server emulator that can intercept,
respond to, and bypass network-based license validation requests from modern
software protection systems.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import base64
import hashlib
import hmac
import ipaddress
import json
import logging
import socket
import ssl
import struct
import threading
import time
import uuid
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn
from typing import Any, Dict, List

from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID

logger = logging.getLogger(__name__)


class LicenseProtocol(Enum):
    """License server communication protocols."""

    HTTP = "http"
    HTTPS = "https"
    TCP_CUSTOM = "tcp_custom"
    UDP = "udp"
    SOAP = "soap"
    REST = "rest"
    FLEXLM = "flexlm"
    SENTINEL = "sentinel"


class ResponseType(Enum):
    """License server response types."""

    GRANT = "grant"
    DENY = "deny"
    REDIRECT = "redirect"
    CHALLENGE = "challenge"
    RENEW = "renew"
    FLOAT = "float"


@dataclass
class LicenseRequest:
    """Incoming license request data."""

    request_id: str
    client_ip: str
    product_id: str
    product_version: str
    feature: str
    username: str
    hostname: str
    mac_address: str
    timestamp: int
    protocol: LicenseProtocol
    raw_data: bytes


@dataclass
class LicenseGrant:
    """License grant response."""

    license_id: str
    feature: str
    expiration: int
    seats: int
    floating: bool
    restrictions: Dict[str, Any]
    signature: bytes


class LicenseServerEmulator:
    """Advanced license server bypass system."""

    def __init__(self, host: str = "0.0.0.0", base_port: int = 27000):
        """Initialize license server emulator."""
        self.host = host
        self.base_port = base_port
        self.servers: Dict[LicenseProtocol, Any] = {}
        self.running = False

        # License database
        self.licenses: Dict[str, LicenseGrant] = {}
        self.active_sessions: Dict[str, Dict[str, Any]] = {}

        # SSL/TLS setup
        self.ssl_context = self._create_ssl_context()

        # Protocol handlers
        self.protocol_handlers = {
            LicenseProtocol.HTTP: self._handle_http_request,
            LicenseProtocol.HTTPS: self._handle_https_request,
            LicenseProtocol.TCP_CUSTOM: self._handle_tcp_request,
            LicenseProtocol.FLEXLM: self._handle_flexlm_request,
            LicenseProtocol.SENTINEL: self._handle_sentinel_request,
        }

        # Product configurations
        self.product_configs = self._load_product_configs()

    def _create_ssl_context(self) -> ssl.SSLContext:
        """Create SSL context with self-signed certificate."""
        # Generate private key
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())

        # Create certificate
        subject = issuer = x509.Name(
            [
                x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "California"),
                x509.NameAttribute(NameOID.LOCALITY_NAME, "San Francisco"),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, "License Server"),
                x509.NameAttribute(NameOID.COMMON_NAME, "license.local"),
            ]
        )

        cert = (
            x509.CertificateBuilder()
            .subject_name(subject)
            .issuer_name(issuer)
            .public_key(private_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.utcnow())
            .not_valid_after(datetime.utcnow() + timedelta(days=365))
            .add_extension(
                x509.SubjectAlternativeName(
                    [
                        x509.DNSName("*.license.local"),
                        x509.DNSName("localhost"),
                        x509.IPAddress(ipaddress.IPv4Address("127.0.0.1")),
                    ]
                ),
                critical=False,
            )
            .add_extension(
                x509.BasicConstraints(ca=True, path_length=0),
                critical=True,
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_encipherment=True,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=True,
                    crl_sign=False,
                    encipher_only=False,
                    decipher_only=False,
                ),
                critical=True,
            )
            .sign(private_key, hashes.SHA256(), backend=default_backend())
        )

        # Create SSL context
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

        # Save cert and key to temp files (required for context)
        import tempfile

        with tempfile.NamedTemporaryFile(mode="wb", delete=False, suffix=".pem") as cert_file:
            cert_file.write(cert.public_bytes(serialization.Encoding.PEM))
            cert_path = cert_file.name

        with tempfile.NamedTemporaryFile(mode="wb", delete=False, suffix=".key") as key_file:
            key_file.write(
                private_key.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.TraditionalOpenSSL,
                    encryption_algorithm=serialization.NoEncryption(),
                )
            )
            key_path = key_file.name

        context.load_cert_chain(cert_path, key_path)

        return context

    def _load_product_configs(self) -> Dict[str, Dict[str, Any]]:
        """Load product-specific license configurations."""
        return {
            "autodesk": {
                "protocol": LicenseProtocol.FLEXLM,
                "port": 27000,
                "features": ["autocad", "maya", "3dsmax", "revit"],
                "daemon": "adskflex",
                "vendor_daemon_port": 2080,
            },
            "matlab": {
                "protocol": LicenseProtocol.FLEXLM,
                "port": 27000,
                "features": ["matlab", "simulink", "signal_toolbox"],
                "daemon": "MLM",
                "vendor_daemon_port": 27001,
            },
            "ansys": {
                "protocol": LicenseProtocol.FLEXLM,
                "port": 1055,
                "features": ["ansys", "cfd", "mechanical"],
                "daemon": "ansyslmd",
                "vendor_daemon_port": 2325,
            },
            "solidworks": {
                "protocol": LicenseProtocol.TCP_CUSTOM,
                "port": 25734,
                "features": ["solidworks", "analysis", "cam"],
                "encryption": "AES256",
            },
            "adobe": {"protocol": LicenseProtocol.HTTPS, "port": 443, "endpoint": "/licenses/v2/validate", "auth": "bearer_token"},
        }

    def start(self):
        """Start all license server emulators."""
        self.running = True

        # Start HTTP/HTTPS server
        self._start_http_server()

        # Start FlexLM server
        self._start_flexlm_server()

        # Start custom TCP server
        self._start_tcp_server()

        logger.info(f"License server emulator started on {self.host}:{self.base_port}")

    def stop(self):
        """Stop all license servers."""
        self.running = False

        for server in self.servers.values():
            if hasattr(server, "shutdown"):
                server.shutdown()

        logger.info("License server emulator stopped")

    def _start_http_server(self):
        """Start HTTP/HTTPS license server."""

        class LicenseHTTPHandler(BaseHTTPRequestHandler):
            def do_POST(handler_self):
                content_length = int(handler_self.headers["Content-Length"])
                post_data = handler_self.rfile.read(content_length)

                # Parse request
                request = self.server._parse_http_request(handler_self.path, handler_self.headers, post_data)

                # Generate response
                response = self.server._generate_http_response(request)

                # Send response
                handler_self.send_response(200)
                handler_self.send_header("Content-Type", response["content_type"])
                handler_self.end_headers()
                handler_self.wfile.write(response["body"])

            def do_GET(handler_self):
                # Handle GET requests for status/health checks
                handler_self.send_response(200)
                handler_self.send_header("Content-Type", "application/json")
                handler_self.end_headers()
                handler_self.wfile.write(json.dumps({"status": "active", "server": "License Server Emulator", "version": "1.0.0"}).encode())

            def log_message(self, format, *args):
                # Custom logging for license server requests
                import logging
                logger = logging.getLogger("LicenseServerEmulator")
                if logger.isEnabledFor(logging.DEBUG):
                    logger.debug(f"[{self.address_string()}] {format % args}")

        class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
            pass

        # Store reference to outer self
        LicenseHTTPHandler.server = self

        # Start HTTP server
        http_server = ThreadedHTTPServer((self.host, self.base_port + 80), LicenseHTTPHandler)
        http_thread = threading.Thread(target=http_server.serve_forever)
        http_thread.daemon = True
        http_thread.start()
        self.servers[LicenseProtocol.HTTP] = http_server

        # Start HTTPS server
        https_server = ThreadedHTTPServer((self.host, self.base_port + 443), LicenseHTTPHandler)
        https_server.socket = self.ssl_context.wrap_socket(https_server.socket, server_side=True)
        https_thread = threading.Thread(target=https_server.serve_forever)
        https_thread.daemon = True
        https_thread.start()
        self.servers[LicenseProtocol.HTTPS] = https_server

    def _parse_http_request(self, path: str, headers: Dict, body: bytes) -> LicenseRequest:
        """Parse HTTP license request."""
        # Determine content type
        content_type = headers.get("Content-Type", "application/json")

        if "json" in content_type:
            data = json.loads(body.decode())
        elif "xml" in content_type:
            root = ET.fromstring(body.decode())
            data = self._xml_to_dict(root)
        else:
            data = {"raw": body.hex()}

        return LicenseRequest(
            request_id=str(uuid.uuid4()),
            client_ip=headers.get("X-Forwarded-For", "127.0.0.1"),
            product_id=data.get("product_id", "unknown"),
            product_version=data.get("version", "1.0"),
            feature=data.get("feature", "base"),
            username=data.get("username", "user"),
            hostname=data.get("hostname", "localhost"),
            mac_address=data.get("mac_address", "00:00:00:00:00:00"),
            timestamp=int(time.time()),
            protocol=LicenseProtocol.HTTP,
            raw_data=body,
        )

    def _xml_to_dict(self, element: ET.Element) -> Dict[str, Any]:
        """Convert XML element to dictionary."""
        result = {}
        for child in element:
            if len(child) == 0:
                result[child.tag] = child.text
            else:
                result[child.tag] = self._xml_to_dict(child)
        return result

    def _generate_http_response(self, request: LicenseRequest) -> Dict[str, Any]:
        """Generate HTTP license response."""
        # Create license grant
        grant = self._create_license_grant(request)

        # Determine response format
        if b"xml" in request.raw_data[:100]:
            # XML response
            root = ET.Element("LicenseResponse")
            ET.SubElement(root, "Status").text = "granted"
            ET.SubElement(root, "LicenseID").text = grant.license_id
            ET.SubElement(root, "Feature").text = grant.feature
            ET.SubElement(root, "Expiration").text = str(grant.expiration)
            ET.SubElement(root, "Signature").text = base64.b64encode(grant.signature).decode()

            body = ET.tostring(root, encoding="utf-8")
            content_type = "application/xml"
        else:
            # JSON response
            response_data = {
                "status": "granted",
                "license_id": grant.license_id,
                "feature": grant.feature,
                "expiration": grant.expiration,
                "seats": grant.seats,
                "signature": base64.b64encode(grant.signature).decode(),
            }
            body = json.dumps(response_data).encode()
            content_type = "application/json"

        return {"body": body, "content_type": content_type}

    def _start_flexlm_server(self):
        """Start FlexLM license server emulation."""

        def handle_flexlm_connection(client_socket, client_address):
            try:
                while self.running:
                    # Receive data
                    data = client_socket.recv(4096)
                    if not data:
                        break

                    # Parse FlexLM request
                    request = self._parse_flexlm_request(data, client_address[0])

                    # Generate response
                    response = self._generate_flexlm_response(request)

                    # Send response
                    client_socket.send(response)

            except Exception as e:
                logger.error(f"FlexLM handler error: {e}")
            finally:
                client_socket.close()

        # Create FlexLM server socket
        flexlm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        flexlm_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        flexlm_socket.bind((self.host, self.base_port))
        flexlm_socket.listen(10)

        def flexlm_accept_loop():
            while self.running:
                try:
                    client_socket, client_address = flexlm_socket.accept()
                    thread = threading.Thread(target=handle_flexlm_connection, args=(client_socket, client_address))
                    thread.daemon = True
                    thread.start()
                except:
                    if self.running:
                        logger.error("FlexLM accept error")

        flexlm_thread = threading.Thread(target=flexlm_accept_loop)
        flexlm_thread.daemon = True
        flexlm_thread.start()

        self.servers[LicenseProtocol.FLEXLM] = flexlm_socket

    def _parse_flexlm_request(self, data: bytes, client_ip: str) -> LicenseRequest:
        """Parse FlexLM protocol request."""
        # FlexLM protocol structure
        if len(data) < 8:
            return None

        # Parse packet header
        packet_type = struct.unpack(">I", data[:4])[0]

        request_data = {"feature": "unknown", "version": "1.0", "username": "user", "hostname": "localhost"}

        # Parse based on packet type
        if packet_type == 0x01:  # License checkout
            # Extract feature name
            offset = 8
            feature_len = struct.unpack(">I", data[offset : offset + 4])[0]
            offset += 4
            if offset + feature_len <= len(data):
                request_data["feature"] = data[offset : offset + feature_len].decode("ascii", errors="ignore")

        elif packet_type == 0x02:  # License query
            # Parse query data
            pass

        return LicenseRequest(
            request_id=str(uuid.uuid4()),
            client_ip=client_ip,
            product_id="flexlm_product",
            product_version=request_data["version"],
            feature=request_data["feature"],
            username=request_data["username"],
            hostname=request_data["hostname"],
            mac_address="00:00:00:00:00:00",
            timestamp=int(time.time()),
            protocol=LicenseProtocol.FLEXLM,
            raw_data=data,
        )

    def _generate_flexlm_response(self, request: LicenseRequest) -> bytes:
        """Generate FlexLM protocol response."""
        # Create response packet
        response = bytearray()

        # Packet type (license grant)
        response.extend(struct.pack(">I", 0x10))

        # Status code (0 = success)
        response.extend(struct.pack(">I", 0))

        # License data
        license_data = f"LICENSE {request.feature} 1.0 permanent uncounted HOSTID=ANY".encode()
        response.extend(struct.pack(">I", len(license_data)))
        response.extend(license_data)

        # Signature
        signature = hashlib.sha256(license_data).digest()[:16]
        response.extend(signature)

        return bytes(response)

    def _start_tcp_server(self):
        """Start custom TCP license server."""

        def handle_tcp_connection(client_socket, client_address):
            try:
                # Receive request
                data = client_socket.recv(4096)

                # Parse custom protocol
                request = self._parse_tcp_request(data, client_address[0])

                # Generate response
                response = self._generate_tcp_response(request)

                # Send response
                client_socket.send(response)

            except Exception as e:
                logger.error(f"TCP handler error: {e}")
            finally:
                client_socket.close()

        # Create TCP server socket
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tcp_socket.bind((self.host, self.base_port + 1000))
        tcp_socket.listen(10)

        def tcp_accept_loop():
            while self.running:
                try:
                    client_socket, client_address = tcp_socket.accept()
                    thread = threading.Thread(target=handle_tcp_connection, args=(client_socket, client_address))
                    thread.daemon = True
                    thread.start()
                except:
                    if self.running:
                        logger.error("TCP accept error")

        tcp_thread = threading.Thread(target=tcp_accept_loop)
        tcp_thread.daemon = True
        tcp_thread.start()

        self.servers[LicenseProtocol.TCP_CUSTOM] = tcp_socket

    def _parse_tcp_request(self, data: bytes, client_ip: str) -> LicenseRequest:
        """Parse custom TCP protocol request."""
        # Try to detect protocol format
        if data.startswith(b"{"):
            # JSON format
            try:
                req_data = json.loads(data.decode())
                return LicenseRequest(
                    request_id=req_data.get("id", str(uuid.uuid4())),
                    client_ip=client_ip,
                    product_id=req_data.get("product", "unknown"),
                    product_version=req_data.get("version", "1.0"),
                    feature=req_data.get("feature", "base"),
                    username=req_data.get("user", "user"),
                    hostname=req_data.get("host", "localhost"),
                    mac_address=req_data.get("mac", "00:00:00:00:00:00"),
                    timestamp=int(time.time()),
                    protocol=LicenseProtocol.TCP_CUSTOM,
                    raw_data=data,
                )
            except:
                pass

        # Binary protocol
        return LicenseRequest(
            request_id=str(uuid.uuid4()),
            client_ip=client_ip,
            product_id="custom_product",
            product_version="1.0",
            feature="base",
            username="user",
            hostname="localhost",
            mac_address="00:00:00:00:00:00",
            timestamp=int(time.time()),
            protocol=LicenseProtocol.TCP_CUSTOM,
            raw_data=data,
        )

    def _generate_tcp_response(self, request: LicenseRequest, grant: LicenseGrant = None) -> bytes:
        """Generate custom TCP protocol response."""
        # Use provided grant or create new one
        if grant is None:
            grant = self._create_license_grant(request)

        # Format response based on request format
        if request.raw_data.startswith(b"{"):
            # JSON response
            response_data = {
                "status": "granted",
                "license": {"id": grant.license_id, "feature": grant.feature, "expiration": grant.expiration, "seats": grant.seats},
                "signature": base64.b64encode(grant.signature).decode(),
            }
            return json.dumps(response_data).encode()
        else:
            # Binary response
            response = bytearray()
            response.extend(b"LICGRANT")  # Magic
            response.extend(struct.pack(">I", 0))  # Status (0 = success)
            response.extend(uuid.UUID(grant.license_id).bytes)
            response.extend(struct.pack(">I", grant.expiration))
            response.extend(grant.signature[:32])
            return bytes(response)

    def _create_license_grant(self, request: LicenseRequest) -> LicenseGrant:
        """Create license grant for request."""
        # Generate license ID
        license_id = str(uuid.uuid4())

        # Calculate expiration (30 days from now)
        expiration = int(time.time() + 30 * 86400)

        # Create grant data
        grant_data = f"{license_id}:{request.feature}:{expiration}:{request.client_ip}"

        # Sign grant
        signature = hmac.new(b"license_server_key", grant_data.encode(), hashlib.sha256).digest()

        grant = LicenseGrant(
            license_id=license_id,
            feature=request.feature,
            expiration=expiration,
            seats=100,  # Unlimited seats
            floating=True,
            restrictions={},
            signature=signature,
        )

        # Store in database
        self.licenses[license_id] = grant

        # Track session
        self.active_sessions[request.client_ip] = {
            "license_id": license_id,
            "feature": request.feature,
            "username": request.username,
            "hostname": request.hostname,
            "started": int(time.time()),
        }

        return grant

    def _handle_http_request(self, request: LicenseRequest) -> Dict[str, Any]:
        """Handle HTTP/HTTPS license request."""
        grant = self._create_license_grant(request)
        return {"status": "granted", "license": grant}

    def _handle_https_request(self, request: LicenseRequest) -> Dict[str, Any]:
        """Handle HTTPS license request."""
        return self._handle_http_request(request)

    def _handle_tcp_request(self, request: LicenseRequest) -> bytes:
        """Handle custom TCP license request."""
        grant = self._create_license_grant(request)
        return self._generate_tcp_response(request, grant)

    def _handle_flexlm_request(self, request: LicenseRequest) -> bytes:
        """Handle FlexLM license request."""
        return self._generate_flexlm_response(request)

    def _handle_sentinel_request(self, request: LicenseRequest) -> bytes:
        """Handle Sentinel HASP license request."""
        # Sentinel protocol emulation
        response = bytearray()

        # Header
        response.extend(b"HASP")
        response.extend(struct.pack("<I", 0x100))  # Version

        # Status
        response.extend(struct.pack("<I", 0))  # Success

        # License info
        response.extend(struct.pack("<I", 0xFFFFFFFF))  # Feature ID
        response.extend(struct.pack("<I", int(time.time() + 365 * 86400)))  # Expiration

        # Signature
        sig_data = bytes(response)
        signature = hashlib.sha256(sig_data).digest()
        response.extend(signature)

        return bytes(response)

    def add_floating_license(self, feature: str, seats: int):
        """Add floating license configuration."""
        license_id = str(uuid.uuid4())

        grant = LicenseGrant(
            license_id=license_id,
            feature=feature,
            expiration=0,  # No expiration
            seats=seats,
            floating=True,
            restrictions={},
            signature=b"",
        )

        self.licenses[license_id] = grant
        logger.info(f"Added floating license for {feature} with {seats} seats")

    def get_active_sessions(self) -> List[Dict[str, Any]]:
        """Get list of active license sessions."""
        sessions = []
        for client_ip, session in self.active_sessions.items():
            sessions.append(
                {
                    "client_ip": client_ip,
                    "license_id": session["license_id"],
                    "feature": session["feature"],
                    "username": session["username"],
                    "hostname": session["hostname"],
                    "duration": int(time.time()) - session["started"],
                }
            )
        return sessions

    def revoke_license(self, license_id: str):
        """Revoke a license."""
        if license_id in self.licenses:
            del self.licenses[license_id]

            # Remove associated sessions
            for client_ip, session in list(self.active_sessions.items()):
                if session["license_id"] == license_id:
                    del self.active_sessions[client_ip]

            logger.info(f"Revoked license {license_id}")

    def export_config(self, output_file: str):
        """Export server configuration."""
        config = {
            "host": self.host,
            "base_port": self.base_port,
            "products": self.product_configs,
            "licenses": [
                {
                    "id": license_id,
                    "feature": grant.feature,
                    "seats": grant.seats,
                    "floating": grant.floating,
                    "expiration": grant.expiration,
                }
                for license_id, grant in self.licenses.items()
            ],
            "active_sessions": self.get_active_sessions(),
        }

        with open(output_file, "w") as f:
            json.dump(config, f, indent=2)

        logger.info(f"Exported configuration to {output_file}")
