"""
Advanced Keygen Generator for Intellicrack
Extracts key validation algorithms from binaries and generates valid license keys
using constraint solving, pattern analysis, and cryptographic techniques.
"""

import hashlib
import itertools
import json
import logging
import random
import re
import string
import struct
from dataclasses import dataclass, field
from enum import IntEnum
from typing import Any, Callable, Dict, List, Optional, Tuple

import capstone
import pefile
import z3

logger = logging.getLogger(__name__)


class KeyAlgorithmType(IntEnum):
    """Types of key validation algorithms"""

    UNKNOWN = 0
    CHECKSUM = 1
    CRYPTOGRAPHIC = 2
    MATHEMATICAL = 3
    PATTERN_BASED = 4
    BLACKLIST = 5
    HARDWARE_TIED = 6
    TIME_BASED = 7
    RSA_SIGNATURE = 8
    ECC_SIGNATURE = 9
    SYMMETRIC_CRYPTO = 10
    CUSTOM_ALGORITHM = 11


@dataclass
class KeyConstraint:
    """Represents a constraint for key generation"""

    name: str
    type: str  # 'length', 'charset', 'checksum', 'pattern', 'crypto'
    value: Any
    priority: int = 1
    optional: bool = False


@dataclass
class ValidationAlgorithm:
    """Extracted validation algorithm details"""

    type: KeyAlgorithmType
    offset: int
    instructions: List[Tuple[str, str]]  # (mnemonic, operands)
    constants: List[int]
    strings: List[str]
    crypto_operations: List[str]
    constraints: List[KeyConstraint] = field(default_factory=list)
    confidence: float = 0.0


@dataclass
class KeygenTemplate:
    """Template for generating keys"""

    format: str  # Pattern where each position represents an alphanumeric character
    charset: str  # Characters to use
    checksum_algorithm: Optional[str] = None
    crypto_params: Dict[str, Any] = field(default_factory=dict)
    constraints: List[KeyConstraint] = field(default_factory=list)


class AlgorithmExtractor:
    """Extracts key validation algorithms from binaries"""

    def __init__(self):
        self.md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        self.md.detail = True
        self.crypto_signatures = self._load_crypto_signatures()
        self.validation_patterns = self._load_validation_patterns()

    def _load_crypto_signatures(self) -> Dict[bytes, str]:
        """Load signatures for cryptographic operations"""
        return {
            # SHA256 constants
            b"\x67\xe6\x09\x6a": "SHA256_K0",
            b"\x85\xae\x67\xbb": "SHA256_K1",
            b"\x72\xf3\x6e\x3c": "SHA256_K2",
            b"\x3a\xf5\x4f\xa5": "SHA256_K3",
            # MD5 constants
            b"\x78\xa4\x6a\xd7": "MD5_T0",
            b"\x56\xb7\xc7\xe8": "MD5_T1",
            b"\xdb\x70\x20\x24": "MD5_T2",
            b"\xee\xce\xbd\xc1": "MD5_T3",
            # AES S-Box
            b"\x63\x7c\x77\x7b": "AES_SBOX_START",
            # RSA operations
            b"\xff\x25": "BIGNUM_CALL",  # Common in RSA ops
            # CRC32 polynomial
            b"\xdb\x71\x06\x41": "CRC32_POLY",
            b"\x04\xc1\x1d\xb7": "CRC32_POLY_REV",
        }

    def _load_validation_patterns(self) -> List[Dict]:
        """Load common validation patterns"""
        return [
            {"name": "length_check", "pattern": [("cmp", "length"), ("j", "fail")], "type": KeyAlgorithmType.PATTERN_BASED},
            {"name": "checksum_validation", "pattern": [("xor", ""), ("add", ""), ("cmp", "checksum")], "type": KeyAlgorithmType.CHECKSUM},
            {"name": "rsa_verify", "pattern": [("call", "RSA"), ("test", ""), ("j", "fail")], "type": KeyAlgorithmType.RSA_SIGNATURE},
            {"name": "strcmp_check", "pattern": [("call", "strcmp"), ("test", ""), ("j", "")], "type": KeyAlgorithmType.PATTERN_BASED},
            {
                "name": "hardware_check",
                "pattern": [("call", "GetVolumeInformation"), ("xor", ""), ("cmp", "")],
                "type": KeyAlgorithmType.HARDWARE_TIED,
            },
        ]

    def extract_algorithm(self, binary_path: str, search_strings: List[str] = None) -> List[ValidationAlgorithm]:
        """Extract validation algorithms from binary"""
        algorithms = []

        try:
            pe = pefile.PE(binary_path)

            # Search for validation functions
            validation_functions = self._find_validation_functions(pe, search_strings)

            for func_addr in validation_functions:
                # Analyze function
                algorithm = self._analyze_validation_function(pe, func_addr)
                if algorithm:
                    algorithms.append(algorithm)

            pe.close()

        except Exception as e:
            logger.error(f"Algorithm extraction failed: {e}")

        return algorithms

    def _find_validation_functions(self, pe: pefile.PE, search_strings: List[str] = None) -> List[int]:
        """Find potential validation functions"""
        functions = []

        # Default search strings if none provided
        if not search_strings:
            search_strings = ["Invalid", "License", "Key", "Serial", "Registration", "Activation", "Product", "Check", "Verify", "Validate"]

        # Search for string references
        for section in pe.sections:
            section_data = section.get_data()

            for search_str in search_strings:
                for encoding in [search_str.encode(), search_str.encode("utf-16le")]:
                    offset = 0
                    while True:
                        pos = section_data.find(encoding, offset)
                        if pos == -1:
                            break

                        # Find xrefs to this string
                        str_rva = section.VirtualAddress + pos
                        xrefs = self._find_xrefs(pe, str_rva)

                        for xref in xrefs:
                            # Find function containing xref
                            func_addr = self._find_function_start(pe, xref)
                            if func_addr and func_addr not in functions:
                                functions.append(func_addr)

                        offset = pos + 1

        return functions

    def _find_xrefs(self, pe: pefile.PE, target_rva: int) -> List[int]:
        """Find cross-references to an address"""
        xrefs = []
        target_va = pe.OPTIONAL_HEADER.ImageBase + target_rva
        packed_addr = struct.pack("<I", target_va)

        for section in pe.sections:
            section_data = section.get_data()
            offset = 0

            while True:
                pos = section_data.find(packed_addr, offset)
                if pos == -1:
                    break

                xref_rva = section.VirtualAddress + pos
                xrefs.append(xref_rva)
                offset = pos + 1

        return xrefs

    def _find_function_start(self, pe: pefile.PE, addr: int) -> Optional[int]:
        """Find the start of function containing address"""
        # Search backwards for function prologue
        for section in pe.sections:
            if section.VirtualAddress <= addr < section.VirtualAddress + section.Misc_VirtualSize:
                section_offset = addr - section.VirtualAddress
                section_data = section.get_data()

                # Common function prologues
                prologues = [
                    b"\x55\x8b\xec",  # push ebp; mov ebp, esp
                    b"\x55\x89\xe5",  # push ebp; mov ebp, esp (GCC)
                    b"\x48\x83\xec",  # sub rsp, ... (x64)
                    b"\x48\x89\x5c",  # mov [rsp+...], rbx (x64)
                ]

                # Search backwards from current position
                for back_offset in range(section_offset, max(0, section_offset - 0x1000), -1):
                    for prologue in prologues:
                        if section_data[back_offset : back_offset + len(prologue)] == prologue:
                            return section.VirtualAddress + back_offset

        return None

    def _analyze_validation_function(self, pe: pefile.PE, func_addr: int) -> Optional[ValidationAlgorithm]:
        """Analyze a validation function to extract algorithm"""
        try:
            # Get function code
            func_code = self._get_function_code(pe, func_addr)
            if not func_code:
                return None

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.UNKNOWN, offset=func_addr, instructions=[], constants=[], strings=[], crypto_operations=[]
            )

            # Disassemble function
            for insn in self.md.disasm(func_code, func_addr):
                algorithm.instructions.append((insn.mnemonic, insn.op_str))

                # Extract constants
                if insn.operands:
                    for op in insn.operands:
                        if op.type == capstone.x86.X86_OP_IMM:
                            algorithm.constants.append(op.imm)

                # Detect crypto operations
                self._detect_crypto_operations(insn, algorithm)

            # Pattern matching for algorithm type
            algorithm.type = self._identify_algorithm_type(algorithm)

            # Extract constraints
            algorithm.constraints = self._extract_constraints(algorithm)

            # Calculate confidence
            algorithm.confidence = self._calculate_confidence(algorithm)

            return algorithm

        except Exception as e:
            logger.debug(f"Function analysis failed: {e}")
            return None

    def _get_function_code(self, pe: pefile.PE, func_addr: int, max_size: int = 0x10000) -> Optional[bytes]:
        """Get function code bytes"""
        for section in pe.sections:
            if section.VirtualAddress <= func_addr < section.VirtualAddress + section.Misc_VirtualSize:
                offset = func_addr - section.VirtualAddress
                return section.get_data()[offset : offset + max_size]
        return None

    def _detect_crypto_operations(self, insn, algorithm: ValidationAlgorithm):
        """Detect cryptographic operations in instruction"""
        # Check for crypto API calls
        if insn.mnemonic == "call":
            call_target = insn.op_str

            crypto_apis = [
                "CryptHashData",
                "CryptCreateHash",
                "CryptVerifySignature",
                "RSA_public_decrypt",
                "RSA_verify",
                "SHA256_Init",
                "MD5_Init",
                "AES_encrypt",
                "DES_encrypt",
            ]

            for api in crypto_apis:
                if api.lower() in call_target.lower():
                    algorithm.crypto_operations.append(api)
                    break

        # Check for crypto constants
        if insn.operands:
            for op in insn.operands:
                if op.type == capstone.x86.X86_OP_IMM:
                    # Check against known crypto constants
                    for const_bytes, const_name in self.crypto_signatures.items():
                        if struct.pack("<I", op.imm) == const_bytes:
                            algorithm.crypto_operations.append(const_name)

    def _identify_algorithm_type(self, algorithm: ValidationAlgorithm) -> KeyAlgorithmType:
        """Identify the type of validation algorithm"""
        # Check for crypto operations
        if algorithm.crypto_operations:
            if any("RSA" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.RSA_SIGNATURE
            elif any("ECC" in op or "ECDSA" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.ECC_SIGNATURE
            elif any("AES" in op or "DES" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.SYMMETRIC_CRYPTO
            elif any("SHA" in op or "MD5" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.CRYPTOGRAPHIC

        # Check instruction patterns
        instruction_stats = self._analyze_instruction_patterns(algorithm.instructions)

        if instruction_stats["xor_count"] > 5 and instruction_stats["add_count"] > 5:
            return KeyAlgorithmType.CHECKSUM

        if instruction_stats["mul_count"] > 3 or instruction_stats["div_count"] > 2:
            return KeyAlgorithmType.MATHEMATICAL

        if instruction_stats["cmp_count"] > 10:
            return KeyAlgorithmType.PATTERN_BASED

        return KeyAlgorithmType.CUSTOM_ALGORITHM

    def _analyze_instruction_patterns(self, instructions: List[Tuple[str, str]]) -> Dict:
        """Analyze instruction patterns"""
        stats = {
            "xor_count": 0,
            "add_count": 0,
            "sub_count": 0,
            "mul_count": 0,
            "div_count": 0,
            "cmp_count": 0,
            "call_count": 0,
            "jmp_count": 0,
        }

        for mnemonic, _ in instructions:
            if mnemonic == "xor":
                stats["xor_count"] += 1
            elif mnemonic in ["add", "adc"]:
                stats["add_count"] += 1
            elif mnemonic in ["sub", "sbb"]:
                stats["sub_count"] += 1
            elif mnemonic in ["mul", "imul"]:
                stats["mul_count"] += 1
            elif mnemonic in ["div", "idiv"]:
                stats["div_count"] += 1
            elif mnemonic == "cmp":
                stats["cmp_count"] += 1
            elif mnemonic == "call":
                stats["call_count"] += 1
            elif mnemonic.startswith("j"):
                stats["jmp_count"] += 1

        return stats

    def _extract_constraints(self, algorithm: ValidationAlgorithm) -> List[KeyConstraint]:
        """Extract constraints from algorithm"""
        constraints = []

        # Length constraints
        for i, (mnem, _ops) in enumerate(algorithm.instructions):
            if mnem == "cmp" and i > 0:
                # Check if comparing string length
                prev_mnem, prev_ops = algorithm.instructions[i - 1]
                if prev_mnem in ["mov", "movzx"] and "strlen" in str(algorithm.instructions[:i]):
                    # Extract length value
                    for const in algorithm.constants:
                        if 10 <= const <= 100:  # Reasonable key length
                            constraints.append(KeyConstraint(name="length", type="length", value=const, priority=1))
                            break

        # Charset constraints
        for const in algorithm.constants:
            if 0x20 <= const <= 0x7E:  # Printable ASCII
                # Check if it's used in range check
                for mnem, ops in algorithm.instructions:
                    if mnem == "cmp" and hex(const) in ops:
                        constraints.append(KeyConstraint(name="charset", type="charset", value=chr(const), priority=2, optional=True))

        # Checksum constraints
        if algorithm.type == KeyAlgorithmType.CHECKSUM:
            constraints.append(
                KeyConstraint(
                    name="checksum",
                    type="checksum",
                    value="crc32",  # Default, refine based on analysis
                    priority=1,
                )
            )

        # Pattern constraints
        pattern = self._extract_key_pattern(algorithm)
        if pattern:
            constraints.append(KeyConstraint(name="format", type="pattern", value=pattern, priority=1))

        return constraints

    def _extract_key_pattern(self, algorithm: ValidationAlgorithm) -> Optional[str]:
        """Extract key format pattern"""
        # Look for delimiter checks
        delimiters = []
        for const in algorithm.constants:
            if const in [ord("-"), ord(" "), ord("_"), ord(".")]:
                delimiters.append(chr(const))

        # Look for segment length patterns
        segment_lengths = []
        for const in algorithm.constants:
            if 2 <= const <= 8:  # Common segment lengths
                segment_lengths.append(const)

        # Build pattern
        if delimiters and segment_lengths:
            delimiter = delimiters[0] if delimiters else "-"

            if len(segment_lengths) >= 3:
                pattern_parts = []
                for length in segment_lengths[:4]:  # Max 4 segments
                    pattern_parts.append("#" * length)
                return delimiter.join(pattern_parts)

        return None

    def _calculate_confidence(self, algorithm: ValidationAlgorithm) -> float:
        """Calculate confidence in extracted algorithm"""
        confidence = 0.0

        # Base confidence on algorithm type
        if algorithm.type != KeyAlgorithmType.UNKNOWN:
            confidence += 0.3

        # Crypto operations increase confidence
        if algorithm.crypto_operations:
            confidence += min(0.3, len(algorithm.crypto_operations) * 0.1)

        # Constraints increase confidence
        if algorithm.constraints:
            confidence += min(0.2, len(algorithm.constraints) * 0.05)

        # Instruction complexity
        if len(algorithm.instructions) > 50:
            confidence += 0.1

        # Constants found
        if algorithm.constants:
            confidence += 0.1

        return min(1.0, confidence)


class ConstraintSolver:
    """Solves constraints to generate valid keys"""

    def __init__(self):
        self.solver = z3.Solver()
        self.crypto_engines = self._init_crypto_engines()

    def _init_crypto_engines(self) -> Dict[str, Any]:
        """Initialize cryptographic engines"""
        return {
            "md5": hashlib.md5,
            "sha1": hashlib.sha1,
            "sha256": hashlib.sha256,
            "sha512": hashlib.sha512,
            "crc32": self._crc32,
            "luhn": self._luhn_checksum,
        }

    def solve_constraints(self, constraints: List[KeyConstraint], template: KeygenTemplate) -> Optional[str]:
        """Solve constraints to generate a valid key"""
        try:
            # Create Z3 variables for key parts
            key_vars = self._create_key_variables(template)

            # Add constraints to solver
            for constraint in constraints:
                self._add_constraint(constraint, key_vars, template)

            # Check satisfiability
            if self.solver.check() == z3.sat:
                model = self.solver.model()

                # Extract solution
                key = self._extract_key_from_model(model, key_vars, template)

                # Verify against all constraints
                if self._verify_key(key, constraints):
                    return key

            # If Z3 fails, try heuristic approach
            return self._heuristic_solve(constraints, template)

        except Exception as e:
            logger.debug(f"Constraint solving failed: {e}")
            return None

    def _create_key_variables(self, template: KeygenTemplate) -> List[z3.BitVec]:
        """Create Z3 variables for key segments"""
        variables = []

        # Parse template format
        segments = template.format.split("-")

        for i, segment in enumerate(segments):
            segment_len = len(segment)

            for j in range(segment_len):
                var = z3.BitVec(f"k_{i}_{j}", 8)  # 8-bit character
                variables.append(var)

        return variables

    def _add_constraint(self, constraint: KeyConstraint, key_vars: List, template: KeygenTemplate):
        """Add constraint to Z3 solver"""
        if constraint.type == "length":
            # Key length constraint
            self.solver.add(len(key_vars) == constraint.value)

        elif constraint.type == "charset":
            # Character set constraint
            charset = constraint.value
            for var in key_vars:
                char_constraints = []
                for char in charset:
                    char_constraints.append(var == ord(char))
                self.solver.add(z3.Or(char_constraints))

        elif constraint.type == "checksum":
            # Checksum constraint (simplified for Z3)
            checksum_type = constraint.value
            if checksum_type == "sum":
                # Sum of all characters equals specific value
                total = z3.Sum(key_vars)
                self.solver.add(total % 256 == 0)  # Example constraint

        elif constraint.type == "pattern":
            # Pattern constraint
            # Add format constraints based on pattern
            pass

    def _extract_key_from_model(self, model, key_vars: List, template: KeygenTemplate) -> str:
        """Extract key string from Z3 model"""
        key_chars = []

        for var in key_vars:
            val = model[var]
            if val is not None:
                char_val = val.as_long()

                # Ensure valid character
                if 0x20 <= char_val <= 0x7E:
                    key_chars.append(chr(char_val))
                else:
                    # Use random valid character
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    key_chars.append(random.choice(template.charset))  # noqa: S311
            else:
                # Variable not constrained, use random
                # Note: Using random module for generating license keys, not cryptographic purposes
                key_chars.append(random.choice(template.charset))  # noqa: S311

        # Format according to template
        return self._format_key(key_chars, template.format)

    def _format_key(self, chars: List[str], format_str: str) -> str:
        """Format key according to template"""
        result = []
        char_idx = 0

        for char in format_str:
            if char == "#":
                if char_idx < len(chars):
                    result.append(chars[char_idx])
                    char_idx += 1
                else:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    result.append(random.choice(string.ascii_uppercase + string.digits))  # noqa: S311
            else:
                result.append(char)

        return "".join(result)

    def _verify_key(self, key: str, constraints: List[KeyConstraint]) -> bool:
        """Verify key against all constraints"""
        for constraint in constraints:
            if not self._check_constraint(key, constraint):
                return False
        return True

    def _check_constraint(self, key: str, constraint: KeyConstraint) -> bool:
        """Check if key satisfies constraint"""
        if constraint.type == "length":
            return len(key.replace("-", "")) == constraint.value

        elif constraint.type == "charset":
            charset = set(constraint.value)
            key_chars = set(key.replace("-", ""))
            return key_chars.issubset(charset)

        elif constraint.type == "checksum":
            return self._verify_checksum(key, constraint.value)

        elif constraint.type == "pattern":
            return self._match_pattern(key, constraint.value)

        return True

    def _verify_checksum(self, key: str, checksum_type: str) -> bool:
        """Verify key checksum"""
        key_clean = key.replace("-", "")

        if checksum_type == "crc32":
            crc = self._crc32(key_clean.encode())
            # Check if last 8 chars are CRC
            if len(key_clean) >= 8:
                expected_crc = key_clean[-8:]
                return f"{crc:08X}" == expected_crc.upper()

        elif checksum_type == "luhn":
            return self._verify_luhn(key_clean)

        elif checksum_type in self.crypto_engines:
            hasher = self.crypto_engines[checksum_type]()
            hasher.update(key_clean.encode())
            digest = hasher.hexdigest()

            # Check if part of key matches digest
            return digest[:8].upper() in key_clean.upper()

        return True

    def _match_pattern(self, key: str, pattern: str) -> bool:
        """Check if key matches pattern"""
        # Convert pattern to regex
        regex_pattern = pattern.replace("#", "[A-Z0-9]")
        return bool(re.match(regex_pattern, key))

    def _heuristic_solve(self, constraints: List[KeyConstraint], template: KeygenTemplate) -> str:
        """Heuristic approach to key generation"""
        # Start with template format
        key_parts = []
        segments = template.format.split("-")

        for segment in segments:
            segment_chars = []

            for _ in range(len(segment)):
                # Choose character based on constraints
                if template.charset:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    char = random.choice(template.charset)  # noqa: S311
                else:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    char = random.choice(string.ascii_uppercase + string.digits)  # noqa: S311
                segment_chars.append(char)

            key_parts.append("".join(segment_chars))

        key = "-".join(key_parts)

        # Apply checksum if needed
        for constraint in constraints:
            if constraint.type == "checksum":
                key = self._apply_checksum(key, constraint.value)
                break

        return key

    def _apply_checksum(self, key: str, checksum_type: str) -> str:
        """Apply checksum to key"""
        key_parts = key.split("-")

        if checksum_type == "crc32":
            # Calculate CRC of first parts
            data = "".join(key_parts[:-1])
            crc = self._crc32(data.encode())

            # Replace last segment with CRC
            if key_parts:
                key_parts[-1] = f"{crc:08X}"[: len(key_parts[-1])]

        elif checksum_type == "luhn":
            # Apply Luhn algorithm
            key_clean = "".join(key_parts)
            check_digit = self._calculate_luhn(key_clean[:-1])

            # Replace last character with check digit
            if key_parts and key_parts[-1]:
                last_part = list(key_parts[-1])
                last_part[-1] = str(check_digit)
                key_parts[-1] = "".join(last_part)

        return "-".join(key_parts)

    def _crc32(self, data: bytes) -> int:
        """Calculate CRC32"""
        import binascii

        return binascii.crc32(data) & 0xFFFFFFFF

    def _luhn_checksum(self, data: str) -> int:
        """Calculate Luhn checksum"""

        def digits_of(n):
            return [int(d) for d in str(n)]

        digits = digits_of(data)
        odd_digits = digits[-1::-2]
        even_digits = digits[-2::-2]

        checksum = sum(odd_digits)
        for d in even_digits:
            checksum += sum(digits_of(d * 2))

        return checksum % 10

    def _calculate_luhn(self, data: str) -> int:
        """Calculate Luhn check digit"""
        checksum = self._luhn_checksum(data + "0")
        return (10 - checksum) % 10

    def _verify_luhn(self, data: str) -> bool:
        """Verify Luhn checksum"""
        return self._luhn_checksum(data) == 0


class KeySpaceExplorer:
    """Explores key space for valid keys"""

    def __init__(self):
        self.tested_keys = set()
        self.valid_keys = []
        self.worker_threads = []

    def explore_keyspace(
        self, template: KeygenTemplate, constraints: List[KeyConstraint], validator: Callable[[str], bool], max_keys: int = 1000
    ) -> List[str]:
        """Explore key space to find valid keys"""
        self.valid_keys = []

        # Estimate key space size
        space_size = self._estimate_space_size(template)

        if space_size < 1000000:
            # Small space, exhaustive search
            return self._exhaustive_search(template, constraints, validator, max_keys)
        else:
            # Large space, use intelligent sampling
            return self._intelligent_search(template, constraints, validator, max_keys)

    def _estimate_space_size(self, template: KeygenTemplate) -> int:
        """Estimate total key space size"""
        segments = template.format.split("-")
        total_size = 1

        for segment in segments:
            segment_len = len(segment)
            charset_size = len(template.charset)
            total_size *= charset_size**segment_len

        return total_size

    def _exhaustive_search(
        self, template: KeygenTemplate, constraints: List[KeyConstraint], validator: Callable[[str], bool], max_keys: int
    ) -> List[str]:
        """Exhaustive search of key space"""
        valid_keys = []

        # Generate all possible keys
        for key in self._generate_all_keys(template):
            if len(valid_keys) >= max_keys:
                break

            # Check constraints
            if all(self._check_constraint(key, c) for c in constraints):
                # Validate key
                if validator(key):
                    valid_keys.append(key)
                    logger.info(f"Found valid key: {key}")

        return valid_keys

    def _intelligent_search(
        self, template: KeygenTemplate, constraints: List[KeyConstraint], validator: Callable[[str], bool], max_keys: int
    ) -> List[str]:
        """Intelligent search using genetic algorithm"""
        population_size = 100
        generations = 50
        mutation_rate = 0.1

        # Initialize population
        population = [self._random_key(template) for _ in range(population_size)]

        for generation in range(generations):
            # Evaluate fitness
            fitness_scores = []
            for individual in population:
                fitness = self._evaluate_fitness(individual, constraints, validator)
                fitness_scores.append((individual, fitness))

            # Sort by fitness
            fitness_scores.sort(key=lambda x: x[1], reverse=True)

            # Check for valid keys
            for key, fitness in fitness_scores:
                if fitness >= 1.0 and key not in self.valid_keys:
                    self.valid_keys.append(key)
                    logger.info(f"Generation {generation}: Found valid key: {key}")

                    if len(self.valid_keys) >= max_keys:
                        return self.valid_keys

            # Selection
            parents = [key for key, _ in fitness_scores[: population_size // 2]]

            # Crossover and mutation
            new_population = parents.copy()

            while len(new_population) < population_size:
                # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
                parent1 = random.choice(parents)  # noqa: S311
                parent2 = random.choice(parents)  # noqa: S311

                child = self._crossover(parent1, parent2)

                # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
                if random.random() < mutation_rate:  # noqa: S311
                    child = self._mutate(child, template)

                new_population.append(child)

            population = new_population

        return self.valid_keys

    def _generate_all_keys(self, template: KeygenTemplate):
        """Generator for all possible keys"""
        segments = template.format.split("-")
        segment_lengths = [len(s) for s in segments]

        # Generate all combinations
        for combo in itertools.product(template.charset, repeat=sum(segment_lengths)):
            # Format as key
            key_parts = []
            idx = 0

            for length in segment_lengths:
                part = "".join(combo[idx : idx + length])
                key_parts.append(part)
                idx += length

            yield "-".join(key_parts)

    def _random_key(self, template: KeygenTemplate) -> str:
        """Generate random key from template"""
        key_parts = []
        segments = template.format.split("-")

        for segment in segments:
            part = "".join(
                random.choice(template.charset)  # noqa: S311
                for _ in range(len(segment))
            )
            key_parts.append(part)

        return "-".join(key_parts)

    def _evaluate_fitness(self, key: str, constraints: List[KeyConstraint], validator: Callable[[str], bool]) -> float:
        """Evaluate key fitness (0.0 to 1.0)"""
        fitness = 0.0
        total_weight = 0

        # Check constraints
        for constraint in constraints:
            weight = constraint.priority
            total_weight += weight

            if self._check_constraint(key, constraint):
                fitness += weight

        if total_weight > 0:
            fitness /= total_weight

        # Bonus for passing validation
        if validator(key):
            fitness = 1.0

        return fitness

    def _check_constraint(self, key: str, constraint: KeyConstraint) -> bool:
        """Check if key satisfies constraint"""
        solver = ConstraintSolver()
        return solver._check_constraint(key, constraint)

    def _crossover(self, parent1: str, parent2: str) -> str:
        """Crossover two keys to create offspring"""
        # Single-point crossover
        parts1 = parent1.split("-")
        parts2 = parent2.split("-")

        if len(parts1) != len(parts2):
            # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
            return random.choice([parent1, parent2])  # noqa: S311

        # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
        crossover_point = random.randint(1, len(parts1) - 1)  # noqa: S311

        child_parts = parts1[:crossover_point] + parts2[crossover_point:]
        return "-".join(child_parts)

    def _mutate(self, key: str, template: KeygenTemplate) -> str:
        """Mutate key by changing random character"""
        parts = key.split("-")

        if parts:
            # Choose random part
            # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
            part_idx = random.randint(0, len(parts) - 1)  # noqa: S311
            part = list(parts[part_idx])

            if part:
                # Change random character
                # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
                char_idx = random.randint(0, len(part) - 1)  # noqa: S311
                # Note: Using random module for genetic algorithm simulation, not cryptographic purposes
                part[char_idx] = random.choice(template.charset)  # noqa: S311
                parts[part_idx] = "".join(part)

        return "-".join(parts)


class KeygenGenerator:
    """Main keygen generator orchestrator"""

    def __init__(self):
        self.extractor = AlgorithmExtractor()
        self.solver = ConstraintSolver()
        self.explorer = KeySpaceExplorer()
        self.templates = self._load_templates()

    def _load_templates(self) -> Dict[str, KeygenTemplate]:
        """Load common keygen templates"""
        return {
            "standard": KeygenTemplate(
                format="####-####-####-####", charset=string.ascii_uppercase + string.digits, checksum_algorithm="crc32"
            ),
            "windows": KeygenTemplate(
                format="#####-#####-#####-#####-#####",
                charset="23456789ABCDEFGHJKLMNPQRSTUVWXYZ",  # No ambiguous chars
                checksum_algorithm="mod7",
            ),
            "adobe": KeygenTemplate(format="####-####-####-####-####-####", charset=string.digits, checksum_algorithm="luhn"),
            "simple": KeygenTemplate(format="##########", charset=string.ascii_uppercase + string.digits, checksum_algorithm=None),
        }

    def generate_keygen(self, binary_path: str, template_name: str = "standard", num_keys: int = 10) -> List[str]:
        """Generate valid keys for target binary"""
        logger.info(f"Generating keygen for: {binary_path}")

        # Extract validation algorithm
        algorithms = self.extractor.extract_algorithm(binary_path)

        if not algorithms:
            logger.warning("No validation algorithms found, using heuristic generation")
            return self._heuristic_generation(template_name, num_keys)

        # Use best algorithm
        best_algorithm = max(algorithms, key=lambda a: a.confidence)
        logger.info(f"Using algorithm: {best_algorithm.type.name} (confidence: {best_algorithm.confidence:.2f})")

        # Get template
        template = self.templates.get(template_name, self.templates["standard"])

        # Apply algorithm constraints to template
        template.constraints = best_algorithm.constraints

        # Create validator based on algorithm
        validator = self._create_validator(best_algorithm, binary_path)

        # Generate keys
        keys = []

        # Try constraint solver first
        for _ in range(min(num_keys, 10)):
            key = self.solver.solve_constraints(best_algorithm.constraints, template)
            if key and validator(key):
                keys.append(key)

        # If not enough keys, use space exploration
        if len(keys) < num_keys:
            additional_keys = self.explorer.explore_keyspace(template, best_algorithm.constraints, validator, num_keys - len(keys))
            keys.extend(additional_keys)

        return keys[:num_keys]

    def _heuristic_generation(self, template_name: str, num_keys: int) -> List[str]:
        """Generate keys using heuristics when no algorithm found"""
        template = self.templates.get(template_name, self.templates["standard"])
        keys = []

        for _ in range(num_keys):
            key = self.explorer._random_key(template)

            # Apply checksum if configured
            if template.checksum_algorithm:
                key = self.solver._apply_checksum(key, template.checksum_algorithm)

            keys.append(key)

        return keys

    def _create_validator(self, algorithm: ValidationAlgorithm, binary_path: str) -> Callable[[str], bool]:
        """Create validator function based on algorithm"""

        def validator(key: str) -> bool:
            # Simplified validation - in production would patch binary
            # or use debugging to test key

            # Check basic constraints
            for constraint in algorithm.constraints:
                if not self.solver._check_constraint(key, constraint):
                    return False

            # Algorithm-specific validation
            if algorithm.type == KeyAlgorithmType.CHECKSUM:
                # Verify checksum
                return self._validate_checksum_key(key, algorithm)

            elif algorithm.type == KeyAlgorithmType.RSA_SIGNATURE:
                # Would need to extract public key and verify signature
                return self._validate_rsa_key(key, algorithm)

            elif algorithm.type == KeyAlgorithmType.PATTERN_BASED:
                # Pattern matching
                return self._validate_pattern_key(key, algorithm)

            # Default: assume valid if constraints pass
            return True

        return validator

    def _validate_checksum_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate key with checksum algorithm"""
        # Extract checksum type from algorithm
        checksum_type = "crc32"  # Default

        for op in algorithm.crypto_operations:
            if "CRC" in op:
                checksum_type = "crc32"
                break
            elif "MD5" in op:
                checksum_type = "md5"
                break
            elif "SHA" in op:
                checksum_type = "sha256"
                break

        return self.solver._verify_checksum(key, checksum_type)

    def _validate_rsa_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate RSA signed key"""
        # Would need to extract public key from binary
        # For now, return true for valid format
        return len(key.replace("-", "")) >= 16

    def _validate_pattern_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate pattern-based key"""
        # Check against extracted pattern
        for constraint in algorithm.constraints:
            if constraint.type == "pattern":
                return self.solver._match_pattern(key, constraint.value)
        return True

    def batch_generate(self, binary_path: str, output_file: str, num_keys: int = 1000, template: str = "standard"):
        """Generate batch of keys and save to file"""
        logger.info(f"Generating {num_keys} keys...")

        keys = self.generate_keygen(binary_path, template, num_keys)

        # Save to file
        with open(output_file, "w") as f:
            for key in keys:
                f.write(key + "\n")

        logger.info(f"Generated {len(keys)} keys saved to: {output_file}")

        # Generate statistics
        stats = {
            "total_generated": len(keys),
            "unique_keys": len(set(keys)),
            "template_used": template,
            "algorithm_extracted": True if self.extractor.extract_algorithm(binary_path) else False,
        }

        # Save statistics
        stats_file = output_file.replace(".txt", "_stats.json")
        with open(stats_file, "w") as f:
            json.dump(stats, f, indent=2)

        return keys


def main():
    """Testing entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="Intellicrack Keygen Generator")
    parser.add_argument("binary", help="Target binary path")
    parser.add_argument("-n", "--num-keys", type=int, default=10, help="Number of keys to generate")
    parser.add_argument(
        "-t", "--template", default="standard", choices=["standard", "windows", "adobe", "simple"], help="Key template to use"
    )
    parser.add_argument("-o", "--output", help="Output file for batch generation")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    generator = KeygenGenerator()

    if args.output:
        # Batch generation
        generator.batch_generate(args.binary, args.output, args.num_keys, args.template)
    else:
        # Generate and display keys
        keys = generator.generate_keygen(args.binary, args.template, args.num_keys)

        print(f"\n=== Generated Keys ({args.template} template) ===")
        for i, key in enumerate(keys, 1):
            print(f"{i:3d}. {key}")

        if not keys:
            print("No valid keys generated. Try a different template or check the binary.")


if __name__ == "__main__":
    main()
