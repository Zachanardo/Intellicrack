"""Advanced Keygen Generator for Intellicrack.

Extracts key validation algorithms from binaries and generates valid license keys
using constraint solving, pattern analysis, and cryptographic techniques.
"""

from __future__ import annotations

import hashlib
import itertools
import json
import logging
import os
import platform
import random
import re
import shutil
import string
import struct
import subprocess
import sys
import tempfile
import threading
import time
import types
from collections.abc import Callable, Generator
from dataclasses import dataclass, field
from enum import IntEnum
from pathlib import Path
from typing import Any

default_backend: Callable[..., Any] | None
hashes: types.ModuleType | None
serialization: types.ModuleType | None
padding: types.ModuleType | None
rsa: types.ModuleType | None
RSAPublicKey: type[Any] | None
RSAPublicNumbers: type[Any] | None
load_der_x509_certificate: Callable[..., Any] | None
load_pem_x509_certificate: Callable[..., Any] | None

try:
    import capstone

    CAPSTONE_AVAILABLE = True
except ImportError:
    capstone = None
    CAPSTONE_AVAILABLE = False

try:
    import pefile

    PEFILE_AVAILABLE = True
except ImportError:
    pefile = None
    PEFILE_AVAILABLE = False

try:
    import z3

    Z3_AVAILABLE = True
except ImportError:
    z3 = None
    Z3_AVAILABLE = False

try:
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding, rsa
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey, RSAPublicNumbers
    from cryptography.x509 import load_der_x509_certificate, load_pem_x509_certificate

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    default_backend = None
    hashes = None
    serialization = None
    padding = None
    rsa = None
    RSAPublicKey = None
    RSAPublicNumbers = None
    load_der_x509_certificate = None
    load_pem_x509_certificate = None
    CRYPTOGRAPHY_AVAILABLE = False

try:
    import frida

    FRIDA_AVAILABLE = True
except ImportError:
    frida = None  # type: ignore[assignment]
    FRIDA_AVAILABLE = False

try:
    import r2pipe

    R2PIPE_AVAILABLE = True
except ImportError:
    r2pipe = None  # type: ignore[assignment]
    R2PIPE_AVAILABLE = False

logger = logging.getLogger(__name__)


class KeyAlgorithmType(IntEnum):
    """Enumeration of key validation algorithm types.

    Represents different categories of license key validation algorithms that can be
    detected in binary analysis, from simple checksums to complex cryptographic signatures.
    """

    UNKNOWN = 0
    CHECKSUM = 1
    CRYPTOGRAPHIC = 2
    MATHEMATICAL = 3
    PATTERN_BASED = 4
    BLACKLIST = 5
    HARDWARE_TIED = 6
    TIME_BASED = 7
    RSA_SIGNATURE = 8
    ECC_SIGNATURE = 9
    SYMMETRIC_CRYPTO = 10
    CUSTOM_ALGORITHM = 11


@dataclass
class KeyConstraint:
    """Constraint for license key generation.

    Encapsulates validation requirements discovered during algorithm extraction,
    including length limits, character set restrictions, checksum types, and patterns.
    """

    name: str
    type: str  # 'length', 'charset', 'checksum', 'pattern', 'crypto'
    value: Any
    priority: int = 1
    optional: bool = False


@dataclass
class ValidationAlgorithm:
    """Extracted validation algorithm from binary analysis.

    Represents a complete analysis of a license key validation function including
    instructions, constants, cryptographic operations, extracted constraints, and confidence.
    """

    type: KeyAlgorithmType
    offset: int
    instructions: list[tuple[str, str]]  # (mnemonic, operands)
    constants: list[int]
    strings: list[str]
    crypto_operations: list[str]
    constraints: list[KeyConstraint] = field(default_factory=list)
    confidence: float = 0.0


@dataclass
class KeygenTemplate:
    """Template for license key generation.

    Defines the format, character set, and constraints used for generating license keys
    that conform to specific patterns and algorithms detected in target software.
    """

    format: str  # Pattern where each position represents an alphanumeric character
    charset: str  # Characters to use
    checksum_algorithm: str | None = None
    crypto_params: dict[str, Any] = field(default_factory=dict)
    constraints: list[KeyConstraint] = field(default_factory=list)


class RSAPaddingScheme(IntEnum):
    """RSA padding schemes used in license validation."""

    PKCS1_V1_5 = 1
    PSS = 2
    OAEP = 3
    RAW = 4


@dataclass
class RSAPublicKeyInfo:
    """Information about an extracted RSA public key."""

    modulus: int
    exponent: int
    key_size: int
    address: int
    format_type: str
    pem_format: str | None = None
    der_format: bytes | None = None
    source: str = "binary"
    is_weak: bool = False
    weakness_reason: str | None = None


@dataclass
class RSASignatureInfo:
    """Information about RSA signature validation in binary."""

    padding_scheme: RSAPaddingScheme
    hash_algorithm: str
    public_keys: list[RSAPublicKeyInfo]
    signature_offset: int | None = None
    validation_function_address: int | None = None


class AlgorithmExtractor:
    """Extracts key validation algorithms from PE binaries.

    Analyzes binary executables using disassembly, string analysis, and pattern matching
    to identify and classify license key validation functions and extract their algorithms.
    """

    def __init__(self) -> None:
        """Initialize the AlgorithmExtractor with disassembler and signatures."""
        if CAPSTONE_AVAILABLE:
            self.md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            self.md.detail = True
        else:
            self.md = None
            logger.warning("Capstone not available - disassembly features disabled")

        self.crypto_signatures = self._load_crypto_signatures()
        self.validation_patterns = self._load_validation_patterns()

    def _load_crypto_signatures(self) -> dict[bytes, str]:
        """Load signatures for cryptographic operations.

        Returns:
            Dictionary mapping byte sequences to cryptographic operation names, including
            SHA256, MD5, AES, RSA, and CRC32 constants for detection during binary analysis.
        """
        return {
            # SHA256 constants
            b"\x67\xe6\x09\x6a": "SHA256_K0",
            b"\x85\xae\x67\xbb": "SHA256_K1",
            b"\x72\xf3\x6e\x3c": "SHA256_K2",
            b"\x3a\xf5\x4f\xa5": "SHA256_K3",
            # MD5 constants
            b"\x78\xa4\x6a\xd7": "MD5_T0",
            b"\x56\xb7\xc7\xe8": "MD5_T1",
            b"\xdb\x70\x20\x24": "MD5_T2",
            b"\xee\xce\xbd\xc1": "MD5_T3",
            # AES S-Box
            b"\x63\x7c\x77\x7b": "AES_SBOX_START",
            # RSA operations
            b"\xff\x25": "BIGNUM_CALL",  # Common in RSA ops
            # CRC32 polynomial
            b"\xdb\x71\x06\x41": "CRC32_POLY",
            b"\x04\xc1\x1d\xb7": "CRC32_POLY_REV",
        }

    def _load_validation_patterns(self) -> list[dict[str, Any]]:
        """Load common validation patterns.

        Returns:
            List of dictionaries describing common validation algorithm patterns, each containing
            pattern name, instruction sequence, and associated algorithm type for pattern matching.
        """
        return [
            {
                "name": "length_check",
                "pattern": [("cmp", "length"), ("j", "fail")],
                "type": KeyAlgorithmType.PATTERN_BASED,
            },
            {
                "name": "checksum_validation",
                "pattern": [("xor", ""), ("add", ""), ("cmp", "checksum")],
                "type": KeyAlgorithmType.CHECKSUM,
            },
            {
                "name": "rsa_verify",
                "pattern": [("call", "RSA"), ("test", ""), ("j", "fail")],
                "type": KeyAlgorithmType.RSA_SIGNATURE,
            },
            {
                "name": "strcmp_check",
                "pattern": [("call", "strcmp"), ("test", ""), ("j", "")],
                "type": KeyAlgorithmType.PATTERN_BASED,
            },
            {
                "name": "hardware_check",
                "pattern": [("call", "GetVolumeInformation"), ("xor", ""), ("cmp", "")],
                "type": KeyAlgorithmType.HARDWARE_TIED,
            },
        ]

    def extract_algorithm(self, binary_path: str, search_strings: list[str] | None = None) -> list[ValidationAlgorithm]:
        """Extract validation algorithms from binary.

        Analyzes PE binary to identify validation functions and extracts their algorithms
        using string references, cross-references, and disassembly analysis.

        Args:
            binary_path: Absolute or relative path to the target PE binary file.
            search_strings: Optional list of strings to search for in binary sections to locate
                validation functions. Defaults to common validation-related keywords if not provided.

        Returns:
            List of ValidationAlgorithm objects extracted from binary, each with detected algorithm
            type, instructions, constants, and confidence scoring.
        """
        algorithms = []

        try:
            pe = pefile.PE(binary_path)

            # Search for validation functions
            validation_functions = self._find_validation_functions(pe, search_strings)

            for func_addr in validation_functions:
                if algorithm := self._analyze_validation_function(pe, func_addr):
                    algorithms.append(algorithm)

            pe.close()

        except Exception as e:
            logger.exception("Algorithm extraction failed: %s", e)

        return algorithms

    def _find_validation_functions(self, pe: pefile.PE, search_strings: list[str] | None = None) -> list[int]:
        """Find potential validation functions.

        Locates validation functions by searching for string references in binary sections
        and tracing cross-references to identify functions that validate license keys.

        Args:
            pe: Loaded pefile.PE object representing the parsed PE binary.
            search_strings: Optional list of strings to search for in binary. Uses predefined
                common validation keywords if not provided.

        Returns:
            List of virtual addresses (RVAs) pointing to functions containing validation-related strings.
        """
        functions = []

        # Default search strings if none provided
        if not search_strings:
            search_strings = [
                "Invalid",
                "License",
                "Key",
                "Serial",
                "Registration",
                "Activation",
                "Product",
                "Check",
                "Verify",
                "Validate",
            ]

        # Search for string references
        for section in pe.sections:
            section_data = section.get_data()

            for search_str in search_strings:
                for encoding in [search_str.encode(), search_str.encode("utf-16le")]:
                    offset = 0
                    while True:
                        pos = section_data.find(encoding, offset)
                        if pos == -1:
                            break

                        # Find xrefs to this string
                        str_rva = section.VirtualAddress + pos
                        xrefs = self._find_xrefs(pe, str_rva)

                        for xref in xrefs:
                            # Find function containing xref
                            func_addr = self._find_function_start(pe, xref)
                            if func_addr and func_addr not in functions:
                                functions.append(func_addr)

                        offset = pos + 1

        return functions

    def _find_xrefs(self, pe: pefile.PE, target_rva: int) -> list[int]:
        """Find cross-references to an address.

        Scans binary sections to find all locations containing references (pointers) to a target address,
        useful for identifying where strings or functions are referenced in code.

        Args:
            pe: Loaded pefile.PE object representing the parsed PE binary.
            target_rva: Relative virtual address of the target to find references to.

        Returns:
            List of RVAs where the target address is referenced in the binary.
        """
        xrefs = []
        target_va = pe.OPTIONAL_HEADER.ImageBase + target_rva
        packed_addr = struct.pack("<I", target_va)

        for section in pe.sections:
            section_data = section.get_data()
            offset = 0

            while True:
                pos = section_data.find(packed_addr, offset)
                if pos == -1:
                    break

                xref_rva = section.VirtualAddress + pos
                xrefs.append(xref_rva)
                offset = pos + 1

        return xrefs

    def _find_function_start(self, pe: pefile.PE, addr: int) -> int | None:
        """Find the start of function containing address.

        Scans backward from an address to find the function prologue and determine where
        the containing function begins, supporting both x86 32-bit and x64 architectures.

        Args:
            pe: Loaded pefile.PE object representing the parsed PE binary.
            addr: Address within a function to search backward from.

        Returns:
            Virtual address of the function start containing the given address, or None if not found.
        """
        # Search backwards for function prologue
        for section in pe.sections:
            if section.VirtualAddress <= addr < section.VirtualAddress + section.Misc_VirtualSize:
                section_offset = addr - section.VirtualAddress
                section_data = section.get_data()

                # Common function prologues
                prologues = [
                    b"\x55\x8b\xec",  # push ebp; mov ebp, esp
                    b"\x55\x89\xe5",  # push ebp; mov ebp, esp (GCC)
                    b"\x48\x83\xec",  # sub rsp, ... (x64)
                    b"\x48\x89\x5c",  # mov [rsp+...], rbx (x64)
                ]

                # Search backwards from current position
                for back_offset, prologue in itertools.product(range(section_offset, max(0, section_offset - 0x1000), -1), prologues):
                    if section_data[back_offset : back_offset + len(prologue)] == prologue:
                        func_start: int = section.VirtualAddress + back_offset
                        return func_start

        return None

    def _analyze_validation_function(self, pe: pefile.PE, func_addr: int) -> ValidationAlgorithm | None:
        """Analyze a validation function to extract algorithm.

        Disassembles a validation function using Capstone to extract instructions, constants,
        cryptographic operations, and constraints used for license key validation.

        Args:
            pe: Loaded pefile.PE object representing the parsed PE binary.
            func_addr: Virtual address of the validation function to analyze.

        Returns:
            ValidationAlgorithm object with extracted algorithm details, or None if analysis fails.
        """
        try:
            # Get function code
            func_code = self._get_function_code(pe, func_addr)
            if not func_code:
                return None

            algorithm = ValidationAlgorithm(
                type=KeyAlgorithmType.UNKNOWN,
                offset=func_addr,
                instructions=[],
                constants=[],
                strings=[],
                crypto_operations=[],
            )

            # Disassemble function
            for insn in self.md.disasm(func_code, func_addr):
                algorithm.instructions.append((insn.mnemonic, insn.op_str))

                # Extract constants
                if insn.operands:
                    for op in insn.operands:
                        if op.type == capstone.x86.X86_OP_IMM:
                            algorithm.constants.append(op.imm)

                # Detect crypto operations
                self._detect_crypto_operations(insn, algorithm)

            # Pattern matching for algorithm type
            algorithm.type = self._identify_algorithm_type(algorithm)

            # Extract constraints
            algorithm.constraints = self._extract_constraints(algorithm)

            # Calculate confidence
            algorithm.confidence = self._calculate_confidence(algorithm)

            return algorithm

        except Exception as e:
            logger.debug("Function analysis failed: %s", e)
            return None

    def _get_function_code(self, pe: pefile.PE, func_addr: int, max_size: int = 0x10000) -> bytes | None:
        """Get function code bytes.

        Extracts raw machine code bytes for a function from the appropriate binary section.

        Args:
            pe: Loaded pefile.PE object representing the parsed PE binary.
            func_addr: Virtual address of the function to extract code from.
            max_size: Maximum number of bytes to extract for the function.

        Returns:
            Raw bytes of function code, or None if address is not in any section.
        """
        for section in pe.sections:
            if section.VirtualAddress <= func_addr < section.VirtualAddress + section.Misc_VirtualSize:
                offset = func_addr - section.VirtualAddress
                code_bytes: bytes = section.get_data()[offset : offset + max_size]
                return code_bytes
        return None

    def _detect_crypto_operations(self, insn: object, algorithm: ValidationAlgorithm) -> None:
        """Detect cryptographic operations in instruction.

        Args:
            insn: Capstone instruction object with mnemonic, op_str, and operands attributes.
            algorithm: ValidationAlgorithm instance to update with detected operations.
        """
        # Check for crypto API calls
        if getattr(insn, "mnemonic", None) == "call":
            call_target = getattr(insn, "op_str", "")

            crypto_apis = [
                "CryptHashData",
                "CryptCreateHash",
                "CryptVerifySignature",
                "RSA_public_decrypt",
                "RSA_verify",
                "SHA256_Init",
                "MD5_Init",
                "AES_encrypt",
                "DES_encrypt",
            ]

            for api in crypto_apis:
                if api.lower() in call_target.lower():
                    algorithm.crypto_operations.append(api)
                    break

        # Check for crypto constants
        insn_operands = getattr(insn, "operands", None)
        if insn_operands is not None:
            for op in insn_operands:
                if getattr(op, "type", None) == capstone.x86.X86_OP_IMM:
                    imm_val = getattr(op, "imm", None)
                    if imm_val is not None:
                        for const_bytes, const_name in self.crypto_signatures.items():
                            if struct.pack("<I", imm_val) == const_bytes:
                                algorithm.crypto_operations.append(const_name)

    def _identify_algorithm_type(self, algorithm: ValidationAlgorithm) -> KeyAlgorithmType:
        """Identify the type of validation algorithm.

        Classifies extracted validation algorithms by analyzing cryptographic operations,
        instruction patterns, and complexity metrics to determine algorithm category.

        Args:
            algorithm: ValidationAlgorithm object with extracted instruction and operation data.

        Returns:
            KeyAlgorithmType enum value indicating the identified algorithm type or UNKNOWN.
        """
        # Check for crypto operations
        if algorithm.crypto_operations:
            if any("RSA" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.RSA_SIGNATURE
            if any("ECC" in op or "ECDSA" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.ECC_SIGNATURE
            if any("AES" in op or "DES" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.SYMMETRIC_CRYPTO
            if any("SHA" in op or "MD5" in op for op in algorithm.crypto_operations):
                return KeyAlgorithmType.CRYPTOGRAPHIC

        # Check instruction patterns
        instruction_stats = self._analyze_instruction_patterns(algorithm.instructions)

        if instruction_stats["xor_count"] > 5 and instruction_stats["add_count"] > 5:
            return KeyAlgorithmType.CHECKSUM

        if instruction_stats["mul_count"] > 3 or instruction_stats["div_count"] > 2:
            return KeyAlgorithmType.MATHEMATICAL

        if instruction_stats["cmp_count"] > 10:
            return KeyAlgorithmType.PATTERN_BASED

        return KeyAlgorithmType.CUSTOM_ALGORITHM

    def _analyze_instruction_patterns(self, instructions: list[tuple[str, str]]) -> dict[str, int]:
        """Analyze instruction patterns.

        Counts occurrences of different instruction types to identify patterns indicative
        of specific algorithm types like checksums, mathematical operations, or comparisons.

        Args:
            instructions: List of tuples containing instruction mnemonics and operand strings.

        Returns:
            Dictionary with counts for each instruction type (xor, add, mul, cmp, etc.).
        """
        stats: dict[str, int] = {
            "xor_count": 0,
            "add_count": 0,
            "sub_count": 0,
            "mul_count": 0,
            "div_count": 0,
            "cmp_count": 0,
            "call_count": 0,
            "jmp_count": 0,
        }

        for mnemonic, _ in instructions:
            if mnemonic == "xor":
                stats["xor_count"] += 1
            elif mnemonic in ["add", "adc"]:
                stats["add_count"] += 1
            elif mnemonic in ["sub", "sbb"]:
                stats["sub_count"] += 1
            elif mnemonic in ["mul", "imul"]:
                stats["mul_count"] += 1
            elif mnemonic in ["div", "idiv"]:
                stats["div_count"] += 1
            elif mnemonic == "cmp":
                stats["cmp_count"] += 1
            elif mnemonic == "call":
                stats["call_count"] += 1
            elif mnemonic.startswith("j"):
                stats["jmp_count"] += 1

        return stats

    def _extract_constraints(self, algorithm: ValidationAlgorithm) -> list[KeyConstraint]:
        """Extract constraints from algorithm.

        Analyzes extracted algorithm to identify key constraints such as length requirements,
        character set restrictions, checksum validations, and format patterns.

        Args:
            algorithm: ValidationAlgorithm object with extracted instructions and constants.

        Returns:
            List of KeyConstraint objects representing the validation requirements discovered.
        """
        constraints = []

        # Length constraints
        for i, (mnem, _ops) in enumerate(algorithm.instructions):
            if mnem == "cmp" and i > 0:
                # Check if comparing string length
                prev_mnem, _prev_ops = algorithm.instructions[i - 1]
                if prev_mnem in ["mov", "movzx"] and "strlen" in str(algorithm.instructions[:i]):
                    # Extract length value
                    for const in algorithm.constants:
                        if 10 <= const <= 100:  # Reasonable key length
                            constraints.append(KeyConstraint(name="length", type="length", value=const, priority=1))
                            break

        # Charset constraints
        for const in algorithm.constants:
            if 0x20 <= const <= 0x7E:  # Printable ASCII
                # Check if it's used in range check
                constraints.extend(
                    KeyConstraint(
                        name="charset",
                        type="charset",
                        value=chr(const),
                        priority=2,
                        optional=True,
                    )
                    for mnem, ops in algorithm.instructions
                    if mnem == "cmp" and hex(const) in ops
                )
        # Checksum constraints
        if algorithm.type == KeyAlgorithmType.CHECKSUM:
            constraints.append(
                KeyConstraint(
                    name="checksum",
                    type="checksum",
                    value="crc32",  # Default, refine based on analysis
                    priority=1,
                ),
            )

        if pattern := self._extract_key_pattern(algorithm):
            constraints.append(KeyConstraint(name="format", type="pattern", value=pattern, priority=1))

        return constraints

    def _extract_key_pattern(self, algorithm: ValidationAlgorithm) -> str | None:
        """Extract key format pattern.

        Identifies key format patterns from algorithm constants by detecting delimiters
        and segment lengths used in license key validation logic.

        Args:
            algorithm: ValidationAlgorithm object with extracted constants and instructions.

        Returns:
            Format string pattern using '#' for alphanumeric characters and delimiters, or None if no pattern found.
        """
        delimiters = [chr(const) for const in algorithm.constants if const in [ord("-"), ord(" "), ord("_"), ord(".")]]
        segment_lengths = [const for const in algorithm.constants if 2 <= const <= 8]
        # Build pattern
        if delimiters and segment_lengths:
            delimiter = delimiters[0] if delimiters else "-"

            if len(segment_lengths) >= 3:
                pattern_parts = ["#" * length for length in segment_lengths[:4]]
                return delimiter.join(pattern_parts)

        return None

    def _calculate_confidence(self, algorithm: ValidationAlgorithm) -> float:
        """Calculate confidence in extracted algorithm.

        Computes a confidence score (0.0 to 1.0) based on the presence and complexity
        of extracted algorithm features, constraints, and cryptographic operations.

        Args:
            algorithm: ValidationAlgorithm object with extracted algorithm details.

        Returns:
            Confidence score between 0.0 and 1.0 indicating reliability of the extraction.
        """
        confidence = 0.0

        # Base confidence on algorithm type
        if algorithm.type != KeyAlgorithmType.UNKNOWN:
            confidence += 0.3

        # Crypto operations increase confidence
        if algorithm.crypto_operations:
            confidence += min(0.3, len(algorithm.crypto_operations) * 0.1)

        # Constraints increase confidence
        if algorithm.constraints:
            confidence += min(0.2, len(algorithm.constraints) * 0.05)

        # Instruction complexity
        if len(algorithm.instructions) > 50:
            confidence += 0.1

        # Constants found
        if algorithm.constants:
            confidence += 0.1

        return min(1.0, confidence)


class ConstraintSolver:
    """Solves license key validation constraints using Z3 or heuristic methods.

    Uses SMT solving with Z3 to find keys satisfying extracted constraints, with fallback
    to heuristic generation including checksums, pattern matching, and genetic algorithms.
    """

    def __init__(self) -> None:
        """Initialize the ConstraintSolver with Z3 solver and crypto engines."""
        if Z3_AVAILABLE:
            self.solver = z3.Solver()
        else:
            self.solver = None
            logger.warning("Z3 not available - constraint solving disabled")

        self.crypto_engines = self._init_crypto_engines()

    def _init_crypto_engines(self) -> dict[str, Any]:
        """Initialize cryptographic engines.

        Creates dictionary of available cryptographic hash and checksum functions
        for constraint solving and key verification.

        Returns:
            Dictionary mapping algorithm names to their corresponding callable functions.
        """
        return {
            "md5": hashlib.md5,
            "sha1": hashlib.sha1,
            "sha256": hashlib.sha256,
            "sha512": hashlib.sha512,
            "crc32": self._crc32,
            "luhn": self._luhn_checksum,
        }

    def solve_constraints(self, constraints: list[KeyConstraint], template: KeygenTemplate) -> str | None:
        """Solve constraints to generate a valid key.

        Uses Z3 constraint solver to find a key satisfying all constraints, with fallback
        to heuristic solving if Z3 is unavailable or cannot find a solution.

        Args:
            constraints: List of KeyConstraint objects to satisfy during generation.
            template: KeygenTemplate defining key format and character set.

        Returns:
            Valid license key string satisfying all constraints, or None if no solution found.
        """
        try:
            # Create Z3 variables for key parts
            key_vars = self._create_key_variables(template)

            # Add constraints to solver
            for constraint in constraints:
                self._add_constraint(constraint, key_vars, template)

            # Check satisfiability
            if self.solver.check() == z3.sat:
                model = self.solver.model()

                # Extract solution
                key = self._extract_key_from_model(model, key_vars, template)

                # Verify against all constraints
                if self._verify_key(key, constraints):
                    return key

            # If Z3 fails, try heuristic approach
            return self._heuristic_solve(constraints, template)

        except Exception as e:
            logger.debug("Constraint solving failed: %s", e)
            return None

    def _create_key_variables(self, template: KeygenTemplate) -> list[Any]:
        """Create Z3 variables for key segments.

        Generates Z3 BitVec variables for constraint solving, one per character position
        in the template format.

        Args:
            template: KeygenTemplate defining the key format and structure.

        Returns:
            List of Z3 BitVec variables representing key characters.
        """
        variables: list[Any] = []

        # Parse template format
        segments = template.format.split("-")

        for i, segment in enumerate(segments):
            segment_len = len(segment)

            for j in range(segment_len):
                var = z3.BitVec(f"k_{i}_{j}", 8)  # 8-bit character
                variables.append(var)

        return variables

    def _add_constraint(self, constraint: KeyConstraint, key_vars: list[Any], template: KeygenTemplate) -> None:
        """Add constraint to Z3 solver.

        Translates a KeyConstraint into Z3 solver assertions for length, character set,
        and checksum requirements.

        Args:
            constraint: KeyConstraint to add to the solver.
            key_vars: List of Z3 variables representing key characters.
            template: KeygenTemplate providing context for constraint application.
        """
        if constraint.type == "pattern":
            return
        if constraint.type == "length":
            # Key length constraint
            self.solver.add(len(key_vars) == constraint.value)

        elif constraint.type == "charset":
            # Character set constraint
            charset = constraint.value
            for var in key_vars:
                char_constraints = [var == ord(char) for char in charset]
                self.solver.add(z3.Or(char_constraints))

        elif constraint.type == "checksum":
            # Checksum constraint (simplified for Z3)
            checksum_type = constraint.value
            if checksum_type == "sum":
                # Sum of all characters equals specific value
                total = z3.Sum(key_vars)
                self.solver.add(total % 256 == 0)  # Example constraint

    def _extract_key_from_model(self, model: Any, key_vars: list[Any], template: KeygenTemplate) -> str:
        """Extract key string from Z3 model.

        Args:
            model: Z3 model object returned by solver with bracket indexing support.
            key_vars: List of Z3 BitVec variables to extract values from.
            template: KeygenTemplate defining the key format and character set.

        Returns:
            Formatted key string according to template.
        """
        key_chars = []

        for var in key_vars:
            val = model[var]
            if val is not None:
                char_val: int = val.as_long()

                # Ensure valid character
                if 0x20 <= char_val <= 0x7E:
                    key_chars.append(chr(char_val))
                else:
                    # Use random valid character
                    key_chars.append(random.choice(template.charset))  # noqa: S311
            else:
                # Variable not constrained, use random
                key_chars.append(random.choice(template.charset))  # noqa: S311

        # Format according to template
        return self._format_key(key_chars, template.format)

    def _format_key(self, chars: list[str], format_str: str) -> str:
        """Format key according to template.

        Applies template formatting to character list by substituting alphanumeric positions
        with characters from input list and preserving delimiters specified in format string.

        Args:
            chars: List of character strings to format into the key.
            format_str: Template string with alphanumeric markers for character positions and delimiters.

        Returns:
            Formatted license key string according to template.
        """
        result = []
        char_idx = 0

        for char in format_str:
            if char == "#":
                if char_idx < len(chars):
                    result.append(chars[char_idx])
                    char_idx += 1
                else:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    result.append(random.choice(string.ascii_uppercase + string.digits))  # noqa: S311
            else:
                result.append(char)

        return "".join(result)

    def _verify_key(self, key: str, constraints: list[KeyConstraint]) -> bool:
        """Verify key against all constraints.

        Validates a generated key against all specified constraints to ensure it meets
        all validation requirements discovered during algorithm extraction.

        Args:
            key: License key string to verify.
            constraints: List of KeyConstraint objects to validate against.

        Returns:
            True if key satisfies all constraints, False otherwise.
        """
        result: bool = all(self._check_constraint(key, constraint) for constraint in constraints)
        return result

    def _check_constraint(self, key: str, constraint: KeyConstraint) -> bool:
        """Check if key satisfies constraint.

        Evaluates whether a license key meets a specific validation constraint such as
        length, character set, checksum, or pattern requirements.

        Args:
            key: License key string to validate.
            constraint: KeyConstraint to check against.

        Returns:
            True if key satisfies the constraint, False otherwise.
        """
        if constraint.type == "length":
            if isinstance(constraint.value, int):
                return len(key.replace("-", "")) == constraint.value
            return False

        if constraint.type == "charset":
            if isinstance(constraint.value, str):
                charset = set(constraint.value)
                key_chars = set(key.replace("-", ""))
                return key_chars.issubset(charset)
            return False

        if constraint.type == "checksum":
            if isinstance(constraint.value, str):
                return self._verify_checksum(key, constraint.value)
            return False

        if constraint.type == "pattern":
            if isinstance(constraint.value, str):
                return self._match_pattern(key, constraint.value)
            return False

        return True

    def _verify_checksum(self, key: str, checksum_type: str) -> bool:
        """Verify key checksum.

        Validates a license key's checksum using the specified algorithm (CRC32, Luhn, MD5, etc.)
        to ensure data integrity and authenticity.

        Args:
            key: License key string to verify.
            checksum_type: Algorithm type for verification (crc32, luhn, md5, sha256, sha1, sha512).

        Returns:
            True if key checksum is valid, False otherwise.
        """
        key_clean = key.replace("-", "")

        if checksum_type == "crc32":
            if len(key_clean) >= 8:
                data_part = key_clean[:-8]
                expected_crc = key_clean[-8:]
                crc = self._crc32(data_part.encode())
                return f"{crc:08X}" == expected_crc.upper()

        elif checksum_type == "luhn":
            return self._verify_luhn(key_clean)

        elif checksum_type in self.crypto_engines:
            hasher = self.crypto_engines[checksum_type]()
            hasher.update(key_clean.encode())
            digest = hasher.hexdigest()

            # Check if part of key matches digest
            return digest[:8].upper() in key_clean.upper()

        return True

    def _match_pattern(self, key: str, pattern: str) -> bool:
        """Check if key matches pattern.

        Validates whether a license key conforms to a specified format pattern
        using regular expression matching.

        Args:
            key: License key string to validate.
            pattern: Format pattern using alphanumeric markers and delimiters.

        Returns:
            True if key matches the pattern, False otherwise.
        """
        # Convert pattern to regex
        regex_pattern = pattern.replace("#", "[A-Z0-9]")
        return bool(re.match(regex_pattern, key))

    def _heuristic_solve(self, constraints: list[KeyConstraint], template: KeygenTemplate) -> str:
        """Heuristic approach to key generation.

        Generates a valid license key using heuristic methods when Z3 constraint solving
        is unavailable or fails, building key from template and applying constraints.

        Args:
            constraints: List of KeyConstraint objects to satisfy.
            template: KeygenTemplate defining key format and character set.

        Returns:
            Generated license key string satisfying constraints to the extent possible.
        """
        # Start with template format
        key_parts = []
        segments = template.format.split("-")

        for segment in segments:
            segment_chars = []

            for _ in range(len(segment)):
                # Choose character based on constraints
                if template.charset:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    char = random.choice(template.charset)  # noqa: S311
                else:
                    # Note: Using random module for generating license keys, not cryptographic purposes
                    char = random.choice(string.ascii_uppercase + string.digits)  # noqa: S311
                segment_chars.append(char)

            key_parts.append("".join(segment_chars))

        key = "-".join(key_parts)

        # Apply checksum if needed
        for constraint in constraints:
            if constraint.type == "checksum":
                key = self._apply_checksum(key, constraint.value)
                break

        return key

    def _apply_checksum(self, key: str, checksum_type: str) -> str:
        """Apply checksum to key.

        Computes and appends or modifies checksum portion of a license key using the
        specified algorithm to ensure key authenticity and integrity.

        Args:
            key: License key string to apply checksum to.
            checksum_type: Algorithm type for checksum calculation (crc32, luhn).

        Returns:
            License key with checksum applied or modified.
        """
        key_parts = key.split("-")

        if checksum_type == "crc32":
            # Calculate CRC of first parts
            data = "".join(key_parts[:-1])
            crc = self._crc32(data.encode())

            # Replace last segment with CRC
            if key_parts:
                key_parts[-1] = f"{crc:08X}"[: len(key_parts[-1])]

        elif checksum_type == "luhn":
            # Apply Luhn algorithm
            key_clean = "".join(key_parts)
            check_digit = self._calculate_luhn(key_clean[:-1])

            # Replace last character with check digit
            if key_parts and key_parts[-1]:
                last_part = list(key_parts[-1])
                last_part[-1] = str(check_digit)
                key_parts[-1] = "".join(last_part)

        return "-".join(key_parts)

    def _crc32(self, data: bytes) -> int:
        """Calculate CRC32.

        Computes 32-bit cyclic redundancy check for data validation in license keys.

        Args:
            data: Binary data to compute CRC32 checksum for.

        Returns:
            CRC32 checksum value as integer.
        """
        import binascii

        return binascii.crc32(data) & 0xFFFFFFFF

    def _luhn_checksum(self, data: str) -> int:
        """Calculate Luhn checksum.

        Computes Luhn algorithm checksum used in financial license key validation,
        commonly employed for generating and validating numeric license identifiers.

        Args:
            data: String of digits to compute Luhn checksum for.

        Returns:
            Luhn checksum value as integer.
        """

        def digits_of(n: int | str) -> list[int]:
            return [int(d) for d in str(n)]

        digits = digits_of(data)
        odd_digits = digits[-1::-2]
        even_digits = digits[-2::-2]

        checksum = sum(odd_digits)
        for d in even_digits:
            checksum += sum(digits_of(d * 2))

        return checksum % 10

    def _calculate_luhn(self, data: str) -> int:
        """Calculate Luhn check digit.

        Computes the check digit needed to make a numeric string valid under Luhn algorithm,
        used for generating license keys with proper checksums.

        Args:
            data: String of digits to calculate check digit for.

        Returns:
            Luhn check digit as integer (0-9).
        """
        checksum = self._luhn_checksum(f"{data}0")
        return (10 - checksum) % 10

    def _verify_luhn(self, data: str) -> bool:
        """Verify Luhn checksum.

        Validates a numeric license key string using Luhn algorithm verification.

        Args:
            data: String of digits to verify with Luhn algorithm.

        Returns:
            True if data passes Luhn validation, False otherwise.
        """
        return self._luhn_checksum(data) == 0


class KeySpaceExplorer:
    """Explores license key space to discover valid keys.

    Uses exhaustive search for small key spaces or genetic algorithm for large spaces
    to systematically find license keys that pass validation and constraint checking.
    """

    def __init__(self) -> None:
        """Initialize the KeySpaceExplorer with empty key collections."""
        self.tested_keys: set[str] = set()
        self.valid_keys: list[str] = []
        self.worker_threads: list[Any] = []

    def explore_keyspace(
        self,
        template: KeygenTemplate,
        constraints: list[KeyConstraint],
        validator: Callable[[str], bool],
        max_keys: int = 1000,
    ) -> list[str]:
        """Explore key space to find valid keys.

        Searches key space using exhaustive or genetic algorithm approach based on
        space size estimation, collecting valid keys that pass validator function.

        Args:
            template: KeygenTemplate defining key format and character set.
            constraints: List of KeyConstraint objects to satisfy.
            validator: Callable that returns True for valid keys.
            max_keys: Maximum number of valid keys to find.

        Returns:
            List of valid license keys found during exploration.
        """
        self.valid_keys = []

        # Estimate key space size
        space_size = self._estimate_space_size(template)

        if space_size < 1000000:
            # Small space, exhaustive search
            return self._exhaustive_search(template, constraints, validator, max_keys)
        # Large space, use intelligent sampling
        return self._intelligent_search(template, constraints, validator, max_keys)

    def _estimate_space_size(self, template: KeygenTemplate) -> int:
        """Estimate total key space size.

        Calculates the total number of possible keys that can be generated from a template
        by computing charset size raised to the power of total key length.

        Args:
            template: KeygenTemplate defining key format and character set.

        Returns:
            Estimated total number of possible keys in the key space.
        """
        segments = template.format.split("-")
        total_size = 1

        for segment in segments:
            segment_len = len(segment)
            charset_size = len(template.charset)
            total_size *= charset_size**segment_len

        return total_size

    def _exhaustive_search(
        self,
        template: KeygenTemplate,
        constraints: list[KeyConstraint],
        validator: Callable[[str], bool],
        max_keys: int,
    ) -> list[str]:
        """Exhaustive search of key space.

        Performs complete enumeration of all possible keys from template, testing each
        against constraints and validator until max_keys limit is reached.

        Args:
            template: KeygenTemplate defining key format and character set.
            constraints: List of KeyConstraint objects to satisfy.
            validator: Callable that returns True for valid keys.
            max_keys: Maximum number of valid keys to find before stopping.

        Returns:
            List of valid license keys found during exhaustive search.
        """
        valid_keys: list[str] = []

        # Generate all possible keys
        for key in self._generate_all_keys(template):
            if len(valid_keys) >= max_keys:
                break

            # Check constraints
            if all(self._check_constraint(key, c) for c in constraints) and validator(key):
                valid_keys.append(key)
                logger.info("Found valid key: %s", key)

        return valid_keys

    def _intelligent_search(
        self,
        template: KeygenTemplate,
        constraints: list[KeyConstraint],
        validator: Callable[[str], bool],
        max_keys: int,
    ) -> list[str]:
        """Intelligent search using genetic algorithm.

        Applies genetic algorithm with fitness-based selection, crossover, and mutation
        to efficiently explore large key spaces and discover valid license keys.

        Args:
            template: KeygenTemplate defining key format and character set.
            constraints: List of KeyConstraint objects to satisfy.
            validator: Callable that returns True for valid keys.
            max_keys: Maximum number of valid keys to find before stopping.

        Returns:
            List of valid license keys found through genetic algorithm evolution.
        """
        population_size = 100
        generations = 50
        mutation_rate = 0.1

        # Initialize population
        population = [self._random_key(template) for _ in range(population_size)]

        for generation in range(generations):
            # Evaluate fitness
            fitness_scores = []
            for individual in population:
                fitness = self._evaluate_fitness(individual, constraints, validator)
                fitness_scores.append((individual, fitness))

            # Sort by fitness
            fitness_scores.sort(key=lambda x: x[1], reverse=True)

            # Check for valid keys
            for key, fitness in fitness_scores:
                if fitness >= 1.0 and key not in self.valid_keys:
                    self.valid_keys.append(key)
                    logger.info("Generation %d: Found valid key: %s", generation, key)

                    if len(self.valid_keys) >= max_keys:
                        return self.valid_keys

            # Selection
            parents = [key for key, _ in fitness_scores[: population_size // 2]]

            # Crossover and mutation
            new_population = parents.copy()

            while len(new_population) < population_size:
                parent1 = random.choice(parents)  # noqa: S311
                parent2 = random.choice(parents)  # noqa: S311

                child = self._crossover(parent1, parent2)

                if random.random() < mutation_rate:  # noqa: S311
                    child = self._mutate(child, template)

                new_population.append(child)

            population = new_population

        return self.valid_keys

    def _generate_all_keys(self, template: KeygenTemplate) -> Generator[str, None, None]:
        """Generate all possible keys.

        Yields every possible license key combination from template using itertools.product,
        suitable for exhaustive key space exploration of smaller key spaces.

        Args:
            template: KeygenTemplate defining key format and character set.

        Yields:
            License key strings representing all possible combinations.
        """
        segments = template.format.split("-")
        segment_lengths = [len(s) for s in segments]

        # Generate all combinations
        for combo in itertools.product(template.charset, repeat=sum(segment_lengths)):
            # Format as key
            key_parts = []
            idx = 0

            for length in segment_lengths:
                part = "".join(combo[idx : idx + length])
                key_parts.append(part)
                idx += length

            yield "-".join(key_parts)

    def _random_key(self, template: KeygenTemplate) -> str:
        """Generate random key from template.

        Creates a random license key by selecting characters from template charset,
        respecting the format structure and segment boundaries.

        Args:
            template: KeygenTemplate defining key format and character set.

        Returns:
            Randomly generated license key string conforming to template.
        """
        key_parts = []
        segments = template.format.split("-")

        for segment in segments:
            part = "".join(
                random.choice(template.charset)  # noqa: S311
                for _ in range(len(segment))
            )
            key_parts.append(part)

        return "-".join(key_parts)

    def _evaluate_fitness(self, key: str, constraints: list[KeyConstraint], validator: Callable[[str], bool]) -> float:
        """Evaluate key fitness (0.0 to 1.0).

        Computes fitness score for a license key based on constraint satisfaction and validator success,
        used for genetic algorithm selection and evolution.

        Args:
            key: License key string to evaluate.
            constraints: List of KeyConstraint objects to check against.
            validator: Callable that returns True for valid keys.

        Returns:
            Fitness score between 0.0 and 1.0 indicating key quality.
        """
        fitness = 0.0
        total_weight = 0

        # Check constraints
        for constraint in constraints:
            weight = constraint.priority
            total_weight += weight

            if self._check_constraint(key, constraint):
                fitness += weight

        if total_weight > 0:
            fitness /= total_weight

        # Bonus for passing validation
        if validator(key):
            fitness = 1.0

        return fitness

    def _check_constraint(self, key: str, constraint: KeyConstraint) -> bool:
        """Check if key satisfies constraint.

        Evaluates whether a license key meets a specific validation constraint using
        the ConstraintSolver validation logic.

        Args:
            key: License key string to validate.
            constraint: KeyConstraint to check against.

        Returns:
            True if key satisfies the constraint, False otherwise.
        """
        solver = ConstraintSolver()
        return solver._check_constraint(key, constraint)

    def _crossover(self, parent1: str, parent2: str) -> str:
        """Crossover two keys to create offspring.

        Performs single-point crossover genetic operator by combining segments from
        two parent keys to create a child key.

        Args:
            parent1: First parent license key string.
            parent2: Second parent license key string.

        Returns:
            Child license key created through crossover of parent segments.
        """
        # Single-point crossover
        parts1 = parent1.split("-")
        parts2 = parent2.split("-")

        if len(parts1) != len(parts2):
            return random.choice([parent1, parent2])  # noqa: S311

        crossover_point = random.randint(1, len(parts1) - 1)  # noqa: S311

        child_parts = parts1[:crossover_point] + parts2[crossover_point:]
        return "-".join(child_parts)

    def _mutate(self, key: str, template: KeygenTemplate) -> str:
        """Mutate key by changing random character.

        Applies mutation genetic operator by replacing a random character in the key
        with a random character from the template charset.

        Args:
            key: License key string to mutate.
            template: KeygenTemplate providing character set for mutation.

        Returns:
            Mutated license key string with one character potentially changed.
        """
        parts = key.split("-")

        if parts:
            part_idx = random.randint(0, len(parts) - 1)  # noqa: S311
            if part := list(parts[part_idx]):
                char_idx = random.randint(0, len(part) - 1)  # noqa: S311
                part[char_idx] = random.choice(template.charset)  # noqa: S311
                parts[part_idx] = "".join(part)

        return "-".join(parts)


class RSAKeyValidator:
    """Validates RSA-signed license keys by extracting and verifying signatures.

    Extracts RSA public keys from binaries, detects padding schemes and hash algorithms,
    and performs actual cryptographic verification of license key signatures.
    """

    COMMON_EXPONENTS = [3, 5, 17, 257, 65537]
    KNOWN_WEAK_MODULI = {
        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF,
        0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74,
    }
    TEST_KEY_PATTERNS = [
        b"-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\n",
        b"MIICXAIBAAKBgQC",
        b"test",
        b"example",
        b"demo",
    ]

    def __init__(self, binary_path: str) -> None:
        """Initialize RSA validator with binary path.

        Args:
            binary_path: Path to binary to extract RSA keys from.
        """
        self.binary_path = Path(binary_path)
        self.extracted_keys: list[RSAPublicKeyInfo] = []
        self.signature_info: RSASignatureInfo | None = None
        self._binary_data: bytes | None = None

    def _load_binary_data(self) -> bytes:
        """Load binary data from file.

        Returns:
            Binary file contents.
        """
        if self._binary_data is None:
            with open(self.binary_path, "rb") as f:
                self._binary_data = f.read()
        return self._binary_data

    def extract_rsa_keys(self) -> list[RSAPublicKeyInfo]:
        """Extract RSA public keys from binary.

        Searches for RSA keys in multiple formats including DER, PEM, raw modulus/exponent,
        X.509 certificates, and Windows CryptoAPI structures.

        Returns:
            List of extracted RSA public key information.
        """
        if self.extracted_keys:
            return self.extracted_keys

        if not CRYPTOGRAPHY_AVAILABLE:
            logger.error("Cryptography library required for RSA key extraction")
            return []

        data = self._load_binary_data()
        keys: list[RSAPublicKeyInfo] = []

        keys.extend(self._extract_der_keys(data))
        keys.extend(self._extract_pem_keys(data))
        keys.extend(self._extract_x509_certificates(data))
        keys.extend(self._extract_raw_modulus_exponent(data))
        keys.extend(self._extract_cryptoapi_keys(data))

        for key in keys:
            key.is_weak, key.weakness_reason = self._check_key_weakness(key)

        self.extracted_keys = keys
        return keys

    def _extract_der_keys(self, data: bytes) -> list[RSAPublicKeyInfo]:
        """Extract DER-encoded RSA public keys.

        Args:
            data: Binary data to search.

        Returns:
            List of RSA public keys found in DER format.
        """
        keys = []
        rsa_encryption_oid = bytes.fromhex("06092a864886f70d010101")

        offset = 0
        while True:
            offset = data.find(rsa_encryption_oid, offset)
            if offset == -1:
                break

            try:
                search_start = max(0, offset - 100)
                potential_key_data = data[search_start : offset + 612]
                pub_key_obj = serialization.load_der_public_key(potential_key_data, backend=default_backend())

                if isinstance(pub_key_obj, RSAPublicKey):
                    pub_numbers = pub_key_obj.public_numbers()
                    pem_data = pub_key_obj.public_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PublicFormat.SubjectPublicKeyInfo,
                    )

                    key_info = RSAPublicKeyInfo(
                        modulus=pub_numbers.n,
                        exponent=pub_numbers.e,
                        key_size=pub_key_obj.key_size,
                        address=search_start,
                        format_type="DER",
                        pem_format=pem_data.decode("utf-8"),
                        der_format=potential_key_data,
                        source="binary_der",
                    )
                    keys.append(key_info)
                    logger.info("Extracted DER RSA public key at offset 0x%x (%d bits)", search_start, pub_key_obj.key_size)

            except (ValueError, TypeError, AttributeError) as e:
                logger.debug("Failed to parse potential DER key at offset 0x%x: %s", offset, e)

            offset += 1

        return keys

    def _extract_pem_keys(self, data: bytes) -> list[RSAPublicKeyInfo]:
        """Extract PEM-encoded RSA public keys.

        Args:
            data: Binary data to search.

        Returns:
            List of RSA public keys found in PEM format.
        """
        keys = []
        pem_markers = [
            (b"-----BEGIN PUBLIC KEY-----", b"-----END PUBLIC KEY-----"),
            (b"-----BEGIN RSA PUBLIC KEY-----", b"-----END RSA PUBLIC KEY-----"),
        ]

        for start_marker, end_marker in pem_markers:
            offset = 0
            while True:
                start_pos = data.find(start_marker, offset)
                if start_pos == -1:
                    break

                end_pos = data.find(end_marker, start_pos)
                if end_pos == -1:
                    offset = start_pos + 1
                    continue

                try:
                    pem_data = data[start_pos : end_pos + len(end_marker)]
                    pub_key_obj = serialization.load_pem_public_key(pem_data, backend=default_backend())

                    if isinstance(pub_key_obj, RSAPublicKey):
                        pub_numbers = pub_key_obj.public_numbers()
                        der_data = pub_key_obj.public_bytes(
                            encoding=serialization.Encoding.DER,
                            format=serialization.PublicFormat.SubjectPublicKeyInfo,
                        )

                        key_info = RSAPublicKeyInfo(
                            modulus=pub_numbers.n,
                            exponent=pub_numbers.e,
                            key_size=pub_key_obj.key_size,
                            address=start_pos,
                            format_type="PEM",
                            pem_format=pem_data.decode("utf-8"),
                            der_format=der_data,
                            source="binary_pem",
                        )
                        keys.append(key_info)
                        logger.info("Extracted PEM RSA public key at offset 0x%x (%d bits)", start_pos, pub_key_obj.key_size)

                except (ValueError, TypeError, AttributeError) as e:
                    logger.debug("Failed to parse PEM key at offset 0x%x: %s", start_pos, e)

                offset = start_pos + 1

        return keys

    def _extract_x509_certificates(self, data: bytes) -> list[RSAPublicKeyInfo]:
        """Extract RSA keys from embedded X.509 certificates.

        Args:
            data: Binary data to search.

        Returns:
            List of RSA public keys extracted from certificates.
        """
        keys = []

        pem_cert_start = b"-----BEGIN CERTIFICATE-----"
        pem_cert_end = b"-----END CERTIFICATE-----"
        offset = 0
        while True:
            start_pos = data.find(pem_cert_start, offset)
            if start_pos == -1:
                break

            end_pos = data.find(pem_cert_end, start_pos)
            if end_pos == -1:
                offset = start_pos + 1
                continue

            try:
                cert_data = data[start_pos : end_pos + len(pem_cert_end)]
                cert = load_pem_x509_certificate(cert_data, default_backend())
                pub_key_obj = cert.public_key()

                if isinstance(pub_key_obj, RSAPublicKey):
                    pub_numbers = pub_key_obj.public_numbers()
                    pem_data = pub_key_obj.public_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PublicFormat.SubjectPublicKeyInfo,
                    )

                    key_info = RSAPublicKeyInfo(
                        modulus=pub_numbers.n,
                        exponent=pub_numbers.e,
                        key_size=pub_key_obj.key_size,
                        address=start_pos,
                        format_type="X509_PEM",
                        pem_format=pem_data.decode("utf-8"),
                        source="x509_certificate",
                    )
                    keys.append(key_info)
                    logger.info("Extracted RSA key from X.509 certificate at offset 0x%x (%d bits)", start_pos, pub_key_obj.key_size)

            except (ValueError, TypeError, AttributeError) as e:
                logger.debug("Failed to parse X.509 certificate at offset 0x%x: %s", start_pos, e)

            offset = start_pos + 1

        der_cert_header = bytes.fromhex("3082")
        offset = 0
        while True:
            offset = data.find(der_cert_header, offset)
            if offset == -1:
                break

            try:
                cert_data = data[offset : offset + 4096]
                cert = load_der_x509_certificate(cert_data, default_backend())
                pub_key_obj = cert.public_key()

                if isinstance(pub_key_obj, RSAPublicKey):
                    pub_numbers = pub_key_obj.public_numbers()
                    pem_data = pub_key_obj.public_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PublicFormat.SubjectPublicKeyInfo,
                    )

                    key_info = RSAPublicKeyInfo(
                        modulus=pub_numbers.n,
                        exponent=pub_numbers.e,
                        key_size=pub_key_obj.key_size,
                        address=offset,
                        format_type="X509_DER",
                        pem_format=pem_data.decode("utf-8"),
                        source="x509_certificate_der",
                    )
                    keys.append(key_info)
                    logger.info("Extracted RSA key from DER X.509 certificate at offset 0x%x (%d bits)", offset, pub_key_obj.key_size)

            except (ValueError, TypeError, AttributeError) as e:
                logger.debug("Failed to parse DER X.509 certificate at offset 0x%x: %s", offset, e)

            offset += 1

        return keys

    def _extract_raw_modulus_exponent(self, data: bytes) -> list[RSAPublicKeyInfo]:
        """Extract raw RSA modulus and exponent pairs.

        Searches for raw RSA components by first locating common exponent patterns,
        then searching nearby regions for potential modulus values to improve performance.

        Args:
            data: Binary data to search.

        Returns:
            List of RSA public keys reconstructed from raw components.
        """
        keys = []
        exponent_locations: list[tuple[int, int]] = []

        for exp in self.COMMON_EXPONENTS:
            exp_bytes_le = struct.pack("<I", exp)
            exp_bytes_be = struct.pack(">I", exp)

            offset = 0
            while True:
                pos_le = data.find(exp_bytes_le, offset)
                pos_be = data.find(exp_bytes_be, offset)

                if pos_le == -1 and pos_be == -1:
                    break

                pos = pos_le if pos_le != -1 and (pos_be == -1 or pos_le < pos_be) else pos_be

                exponent_locations.append((pos, exp))
                offset = pos + 1

        for exp_offset, exp in exponent_locations:
            for key_size_bits in [1024, 2048, 3072, 4096]:
                byte_size = key_size_bits // 8

                search_start = max(0, exp_offset - 512)
                search_end = min(len(data), exp_offset + 512)

                for i in range(search_start, min(search_end - byte_size, len(data) - byte_size)):
                    if not (data[i] & 0x80 and data[i + byte_size - 1] & 0x01):
                        continue

                    modulus_bytes = data[i : i + byte_size]
                    modulus = int.from_bytes(modulus_bytes, "big")

                    if modulus < (1 << (key_size_bits - 1)):
                        continue

                    try:
                        public_numbers = RSAPublicNumbers(exp, modulus)
                        public_key = public_numbers.public_key(default_backend())

                        pem_data = public_key.public_bytes(
                            encoding=serialization.Encoding.PEM,
                            format=serialization.PublicFormat.SubjectPublicKeyInfo,
                        )

                        key_info = RSAPublicKeyInfo(
                            modulus=modulus,
                            exponent=exp,
                            key_size=key_size_bits,
                            address=i,
                            format_type="RAW",
                            pem_format=pem_data.decode("utf-8"),
                            source="raw_modulus_exponent",
                        )
                        keys.append(key_info)
                        logger.info("Extracted raw RSA key at offset 0x%x (%d bits, e=%d)", i, key_size_bits, exp)
                        break

                    except (ValueError, TypeError, AttributeError) as e:
                        logger.debug("Failed to reconstruct RSA key from raw components at 0x%x: %s", i, e)

        return keys

    def _extract_cryptoapi_keys(self, data: bytes) -> list[RSAPublicKeyInfo]:
        """Extract RSA keys from Windows CryptoAPI structures.

        Searches for PUBLICKEYSTRUC and RSAPUBKEY structures used by Windows
        CryptoAPI and CNG.

        Args:
            data: Binary data to search.

        Returns:
            List of RSA public keys from CryptoAPI structures.
        """
        keys = []

        rsa_pubkey_magic = [
            b"RSA1",
            b"RSA2",
            struct.pack("<I", 0x31415352),
            struct.pack("<I", 0x32415352),
        ]

        for magic in rsa_pubkey_magic:
            offset = 0
            while True:
                offset = data.find(magic, offset)
                if offset == -1:
                    break

                try:
                    if offset + 256 > len(data):
                        offset += 1
                        continue

                    magic_start = offset
                    header_data = data[magic_start : magic_start + 256]

                    if len(header_data) < 20:
                        offset += 1
                        continue

                    bitlen = struct.unpack("<I", header_data[4:8])[0]
                    if bitlen not in [1024, 2048, 3072, 4096]:
                        offset += 1
                        continue

                    pubexp_offset = 8
                    if len(header_data) < pubexp_offset + 4:
                        offset += 1
                        continue

                    pubexp = struct.unpack("<I", header_data[pubexp_offset : pubexp_offset + 4])[0]

                    modulus_offset = 12
                    modulus_size = bitlen // 8
                    if len(header_data) < modulus_offset + modulus_size:
                        offset += 1
                        continue

                    modulus_bytes_le = header_data[modulus_offset : modulus_offset + modulus_size]
                    modulus_bytes = bytes(reversed(modulus_bytes_le))
                    modulus = int.from_bytes(modulus_bytes, "big")

                    try:
                        public_numbers = RSAPublicNumbers(pubexp, modulus)
                        public_key = public_numbers.public_key(default_backend())

                        pem_data = public_key.public_bytes(
                            encoding=serialization.Encoding.PEM,
                            format=serialization.PublicFormat.SubjectPublicKeyInfo,
                        )

                        key_info = RSAPublicKeyInfo(
                            modulus=modulus,
                            exponent=pubexp,
                            key_size=bitlen,
                            address=magic_start,
                            format_type="CRYPTOAPI",
                            pem_format=pem_data.decode("utf-8"),
                            source="windows_cryptoapi",
                        )
                        keys.append(key_info)
                        logger.info("Extracted CryptoAPI RSA key at offset 0x%x (%d bits)", magic_start, bitlen)

                    except (ValueError, TypeError, AttributeError) as e:
                        logger.debug("Failed to reconstruct CryptoAPI RSA key at 0x%x: %s", offset, e)

                except (struct.error, IndexError) as e:
                    logger.debug("Error parsing CryptoAPI structure at 0x%x: %s", offset, e)

                offset += 1

        return keys

    def _check_key_weakness(self, key_info: RSAPublicKeyInfo) -> tuple[bool, str | None]:
        """Check if RSA key is weak or is a test/demo key.

        Args:
            key_info: RSA public key information to check.

        Returns:
            Tuple of (is_weak, weakness_reason).
        """
        if key_info.key_size < 1024:
            return True, f"Key size too small: {key_info.key_size} bits"

        if key_info.exponent < 3:
            return True, f"Exponent too small: {key_info.exponent}"

        if key_info.exponent == 3 and key_info.key_size < 2048:
            return True, "Low exponent (3) with small modulus"

        if key_info.modulus in self.KNOWN_WEAK_MODULI:
            return True, "Known weak/test modulus"

        if key_info.pem_format:
            pem_bytes = key_info.pem_format.encode().lower()
            for pattern in self.TEST_KEY_PATTERNS:
                if pattern.lower() in pem_bytes:
                    return True, "Appears to be a test/demo key"

        gcd_check = self._gcd(key_info.modulus, key_info.exponent)
        if gcd_check != 1:
            return True, f"GCD(n, e) = {gcd_check}, not coprime"

        return False, None

    def _gcd(self, a: int, b: int) -> int:
        """Calculate greatest common divisor.

        Args:
            a: First integer.
            b: Second integer.

        Returns:
            Greatest common divisor of a and b.
        """
        while b:
            a, b = b, a % b
        return a

    def detect_padding_scheme(self, algorithm: ValidationAlgorithm) -> RSAPaddingScheme:
        """Detect RSA padding scheme from algorithm operations.

        Args:
            algorithm: Validation algorithm information.

        Returns:
            Detected RSA padding scheme.
        """
        crypto_ops_str = " ".join(algorithm.crypto_operations).upper()
        strings_str = " ".join(algorithm.strings).upper()
        combined = crypto_ops_str + " " + strings_str

        if "PSS" in combined or "RSASSA-PSS" in combined:
            return RSAPaddingScheme.PSS
        if "OAEP" in combined:
            return RSAPaddingScheme.OAEP
        if "PKCS" in combined or "PKCS1" in combined:
            return RSAPaddingScheme.PKCS1_V1_5

        return RSAPaddingScheme.PKCS1_V1_5

    def detect_hash_algorithm(self, algorithm: ValidationAlgorithm) -> str:
        """Detect hash algorithm from algorithm operations.

        Args:
            algorithm: Validation algorithm information.

        Returns:
            Hash algorithm name (e.g., 'SHA256', 'SHA1', 'MD5').
        """
        crypto_ops_str = " ".join(algorithm.crypto_operations).upper()
        strings_str = " ".join(algorithm.strings).upper()
        combined = crypto_ops_str + " " + strings_str

        if "SHA512" in combined or "SHA-512" in combined:
            return "SHA512"
        if "SHA384" in combined or "SHA-384" in combined:
            return "SHA384"
        if "SHA256" in combined or "SHA-256" in combined:
            return "SHA256"
        if "SHA224" in combined or "SHA-224" in combined:
            return "SHA224"
        if "SHA1" in combined or "SHA-1" in combined:
            return "SHA1"
        if "MD5" in combined:
            return "MD5"

        return "SHA256"

    def validate_license_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate a license key using RSA signature verification.

        Extracts public keys, detects padding/hash algorithms, and attempts to verify
        the license key as an RSA signature.

        Args:
            key: License key string to validate.
            algorithm: Validation algorithm information.

        Returns:
            True if key is valid according to RSA verification, False otherwise.
        """
        extracted_keys = self.extract_rsa_keys()

        if not extracted_keys:
            logger.error("No RSA public keys found in binary for validation")
            return False

        padding_scheme = self.detect_padding_scheme(algorithm)
        hash_alg = self.detect_hash_algorithm(algorithm)

        logger.info("Detected RSA padding: %s, hash: %s", padding_scheme.name, hash_alg)

        key_clean = key.replace("-", "").replace(" ", "").upper()

        try:
            key_bytes = bytes.fromhex(key_clean) if all(c in "0123456789ABCDEF" for c in key_clean) else key.encode("utf-8")
        except (ValueError, AttributeError):
            key_bytes = key.encode("utf-8")

        for key_info in extracted_keys:
            if key_info.is_weak:
                logger.warning("Skipping weak key at 0x%x: %s", key_info.address, key_info.weakness_reason)
                continue

            try:
                if self._verify_signature(key_bytes, key_info, padding_scheme, hash_alg):
                    logger.info("License key validated successfully with RSA key at 0x%x", key_info.address)
                    return True
            except Exception as e:
                logger.debug("Verification failed with key at 0x%x: %s", key_info.address, e)
                continue

        logger.info("License key did not validate with any extracted RSA keys")
        return False

    def _verify_signature(
        self,
        license_data: bytes,
        key_info: RSAPublicKeyInfo,
        padding_scheme: RSAPaddingScheme,
        hash_alg: str,
    ) -> bool:
        """Verify RSA signature on license data.

        Args:
            license_data: License key bytes containing message and signature.
            key_info: RSA public key information.
            padding_scheme: Padding scheme to use.
            hash_alg: Hash algorithm name.

        Returns:
            True if signature is valid, False otherwise.
        """
        try:
            public_numbers = RSAPublicNumbers(key_info.exponent, key_info.modulus)
            public_key = public_numbers.public_key(default_backend())

            hash_obj = self._get_hash_object(hash_alg)
            if hash_obj is None:
                return False

            if padding_scheme == RSAPaddingScheme.PSS:
                pad = padding.PSS(mgf=padding.MGF1(hash_obj), salt_length=padding.PSS.MAX_LENGTH)
            elif padding_scheme == RSAPaddingScheme.PKCS1_V1_5:
                pad = padding.PKCS1v15()
            else:
                logger.warning("Unsupported padding scheme: %s", padding_scheme)
                return False

            sig_size = key_info.key_size // 8

            if len(license_data) < sig_size:
                logger.debug("License data too short for signature verification")
                return False

            signature = license_data[-sig_size:]
            message = license_data[:-sig_size]

            if not message:
                logger.debug("No message data found after extracting signature")
                return False

            public_key.verify(signature, message, pad, hash_obj)
            return True

        except Exception as e:
            logger.debug("Signature verification failed: %s", e)
            return False

    def _get_hash_object(self, hash_name: str) -> hashes.HashAlgorithm | None:
        """Get hash algorithm object from name.

        Args:
            hash_name: Hash algorithm name.

        Returns:
            Hash algorithm object or None if not found.
        """
        if not CRYPTOGRAPHY_AVAILABLE or hashes is None:
            logger.error("Cryptography library not available for hash operations")
            return None

        hash_map = {
            "MD5": hashes.MD5(),
            "SHA1": hashes.SHA1(),
            "SHA224": hashes.SHA224(),
            "SHA256": hashes.SHA256(),
            "SHA384": hashes.SHA384(),
            "SHA512": hashes.SHA512(),
        }
        return hash_map.get(hash_name.upper())


class BinaryKeyValidator:
    """Production-ready license key validator using dynamic instrumentation and binary patching.

    Validates license keys by actually testing them against the target binary using multiple
    sophisticated approaches: Frida dynamic instrumentation, radare2 binary patching, and
    process spawning with monitoring. Defeats anti-debugging and handles packed binaries.

    Attributes:
        binary_path: Path to target binary for validation.
        algorithm: Extracted validation algorithm with function addresses.
        validation_addresses: List of detected validation function addresses.
        timeout: Maximum time (seconds) to wait for validation results.
    """

    def __init__(self, binary_path: str, algorithm: ValidationAlgorithm, timeout: float = 5.0) -> None:
        """Initialize binary key validator.

        Args:
            binary_path: Path to target binary.
            algorithm: ValidationAlgorithm with detected validation functions.
            timeout: Maximum seconds to wait for validation (default 5.0).
        """
        self.binary_path = Path(binary_path).resolve()
        self.algorithm = algorithm
        self.timeout = timeout
        self.validation_addresses = self._extract_validation_addresses()
        self._validation_result: bool | None = None
        self._result_lock = threading.Lock()

    def _extract_validation_addresses(self) -> list[int]:
        """Extract validation function addresses from algorithm.

        Returns:
            List of virtual addresses of validation functions.
        """
        addresses: list[int] = []

        if hasattr(self.algorithm, "function_address") and self.algorithm.function_address:
            addresses.append(self.algorithm.function_address)

        for constraint in self.algorithm.constraints:
            if hasattr(constraint, "address") and constraint.address:
                addresses.append(constraint.address)

        if not addresses and PEFILE_AVAILABLE:
            addresses = self._fallback_validation_search()

        return list(set(addresses))

    def _fallback_validation_search(self) -> list[int]:
        """Fallback: search for validation functions using heuristics.

        Returns:
            List of potential validation function addresses.
        """
        if pefile is None:
            return []

        try:
            pe = pefile.PE(str(self.binary_path))
            addresses: list[int] = []

            common_validation_strings = [
                b"license", b"serial", b"key", b"registration", b"activate",
                b"validation", b"verify", b"check", b"valid", b"invalid"
            ]

            for section in pe.sections:
                if b".text" in section.Name or b"CODE" in section.Name:
                    section_data = section.get_data()
                    for search_str in common_validation_strings:
                        offset = 0
                        while True:
                            offset = section_data.find(search_str, offset)
                            if offset == -1:
                                break
                            addr = pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress + offset
                            addresses.append(addr)
                            offset += 1

            return addresses[:10]

        except Exception as e:
            logger.debug("Fallback validation search failed: %s", e)
            return []

    def validate_key(self, key: str) -> bool:
        """Validate license key against real binary using multiple strategies.

        Attempts validation in order of preference:
        1. Frida dynamic instrumentation (most reliable)
        2. Radare2 binary patching (fallback)
        3. Process spawning with monitoring (last resort)

        Args:
            key: License key to validate.

        Returns:
            True if key is accepted by binary, False otherwise.
        """
        if FRIDA_AVAILABLE and self.validation_addresses:
            result = self._validate_with_frida(key)
            if result is not None:
                return result

        if R2PIPE_AVAILABLE:
            result = self._validate_with_radare2(key)
            if result is not None:
                return result

        result = self._validate_with_process_spawn(key)
        if result is not None:
            return result

        logger.warning("All validation methods failed, falling back to heuristic")
        return self._heuristic_validate(key)

    def _validate_with_frida(self, key: str) -> bool | None:
        """Validate key using Frida dynamic instrumentation.

        Spawns target process, hooks validation functions, feeds the key,
        and captures the validation result from return values.

        Args:
            key: License key to test.

        Returns:
            True if key accepted, False if rejected, None if validation failed.
        """
        if frida is None:
            return None

        try:
            if not self.binary_path.exists():
                logger.error("Binary not found: %s", self.binary_path)
                return None

            script_code = self._generate_frida_hook_script(key)

            pid = os.spawnl(os.P_NOWAIT, str(self.binary_path), str(self.binary_path))
            time.sleep(0.5)

            try:
                session = frida.attach(pid)
            except Exception as attach_error:
                logger.debug("Failed to attach to process %d: %s", pid, attach_error)
                self._kill_process(pid)
                return None

            script = session.create_script(script_code)
            script.on("message", self._on_frida_message)
            script.load()

            start_time = time.time()
            while time.time() - start_time < self.timeout:
                with self._result_lock:
                    if self._validation_result is not None:
                        result = self._validation_result
                        self._validation_result = None
                        session.detach()
                        self._kill_process(pid)
                        return result
                time.sleep(0.1)

            session.detach()
            self._kill_process(pid)
            return None

        except Exception as e:
            logger.debug("Frida validation failed: %s", e)
            return None

    def _generate_frida_hook_script(self, key: str) -> str:
        """Generate Frida script to hook validation functions.

        Args:
            key: License key to inject during validation.

        Returns:
            JavaScript code for Frida script.
        """
        hooks = []
        for addr in self.validation_addresses:
            hooks.append(f"""
Interceptor.attach(ptr("0x{addr:x}"), {{
    onEnter: function(args) {{
        this.key = "{key}";
        send({{type: "enter", address: "0x{addr:x}", key: this.key}});

        for (var i = 0; i < 4; i++) {{
            try {{
                var str = args[i].readUtf8String();
                if (str) {{
                    args[i].writeUtf8String("{key}");
                    send({{type: "inject", param: i, value: "{key}"}});
                }}
            }} catch(e) {{}}

            try {{
                var wstr = args[i].readUtf16String();
                if (wstr) {{
                    args[i].writeUtf16String("{key}");
                    send({{type: "inject", param: i, value: "{key}"}});
                }}
            }} catch(e) {{}}
        }}
    }},
    onLeave: function(retval) {{
        send({{type: "exit", address: "0x{addr:x}", result: retval.toInt32()}});
    }}
}});
""")

        script = f"""
{chr(10).join(hooks)}

var validated = false;
var validationResult = false;

Interceptor.attach(Module.getExportByName(null, "ExitProcess"), {{
    onEnter: function(args) {{
        if (validated) {{
            send({{type: "final", result: validationResult}});
        }}
    }}
}});
"""
        return script

    def _on_frida_message(self, message: dict[str, Any], data: Any) -> None:
        """Handle messages from Frida script.

        Args:
            message: Message dictionary from Frida.
            data: Binary data from Frida (unused).
        """
        if message.get("type") == "send":
            payload = message.get("payload", {})
            msg_type = payload.get("type")

            if msg_type == "exit":
                result_code = payload.get("result", 0)
                with self._result_lock:
                    if result_code == 1 or result_code > 0:
                        self._validation_result = True
                    elif result_code == 0:
                        self._validation_result = False

            elif msg_type == "final":
                with self._result_lock:
                    self._validation_result = payload.get("result", False)

            logger.debug("Frida message: %s", payload)

    def _validate_with_radare2(self, key: str) -> bool | None:
        """Validate key using radare2 binary patching.

        Creates temporary copy of binary, patches validation functions to
        accept test key, executes and monitors for success indicators.

        Args:
            key: License key to test.

        Returns:
            True if key accepted, False if rejected, None if patching failed.
        """
        if r2pipe is None:
            return None

        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as tmp_file:
                tmp_path = tmp_file.name
                shutil.copy2(self.binary_path, tmp_path)

            r2 = r2pipe.open(tmp_path, flags=["-w"])

            r2.cmd("aaa")

            for addr in self.validation_addresses:
                r2.cmd(f"s 0x{addr:x}")

                r2.cmd(f'wx b801000000c3 @ 0x{addr:x}')

            r2.quit()

            result = self._execute_patched_binary(tmp_path, key)

            try:
                os.unlink(tmp_path)
            except Exception:
                pass

            return result

        except Exception as e:
            logger.debug("Radare2 validation failed: %s", e)
            return None

    def _execute_patched_binary(self, binary_path: str, key: str) -> bool | None:
        """Execute patched binary and monitor for validation success.

        Args:
            binary_path: Path to patched binary.
            key: License key being tested.

        Returns:
            True if execution suggests key was accepted, False otherwise.
        """
        try:
            env = os.environ.copy()
            env["LICENSE_KEY"] = key
            env["SERIAL"] = key
            env["REGISTRATION"] = key

            if platform.system() == "Windows":
                startupinfo = subprocess.STARTUPINFO()  # type: ignore[attr-defined]
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW  # type: ignore[attr-defined]
                process = subprocess.Popen(
                    [binary_path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env,
                    startupinfo=startupinfo,
                )
            else:
                process = subprocess.Popen(
                    [binary_path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env,
                )

            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                returncode = process.returncode

                success_indicators = [
                    b"success", b"valid", b"accepted", b"registered",
                    b"activated", b"thank you", b"welcome"
                ]
                failure_indicators = [
                    b"invalid", b"error", b"failed", b"incorrect",
                    b"denied", b"rejected"
                ]

                output = stdout + stderr
                output_lower = output.lower()

                for indicator in success_indicators:
                    if indicator in output_lower:
                        return True

                for indicator in failure_indicators:
                    if indicator in output_lower:
                        return False

                return returncode == 0

            except subprocess.TimeoutExpired:
                process.kill()
                return None

        except Exception as e:
            logger.debug("Patched binary execution failed: %s", e)
            return None

    def _validate_with_process_spawn(self, key: str) -> bool | None:
        """Validate key by spawning process with key in environment/args.

        Args:
            key: License key to test.

        Returns:
            True if process behavior indicates acceptance, None otherwise.
        """
        try:
            env = os.environ.copy()
            env["LICENSE_KEY"] = key
            env["SERIAL_NUMBER"] = key

            test_args = [str(self.binary_path), "-key", key, "--license", key, "/serial", key]

            if platform.system() == "Windows":
                startupinfo = subprocess.STARTUPINFO()  # type: ignore[attr-defined]
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW  # type: ignore[attr-defined]
                process = subprocess.Popen(
                    test_args,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env,
                    startupinfo=startupinfo,
                )
            else:
                process = subprocess.Popen(
                    test_args,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env,
                )

            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                output = (stdout + stderr).lower()

                if b"valid" in output or b"success" in output or b"registered" in output:
                    return True

                return None

            except subprocess.TimeoutExpired:
                process.kill()
                return None

        except Exception as e:
            logger.debug("Process spawn validation failed: %s", e)
            return None

    def _heuristic_validate(self, key: str) -> bool:
        """Fallback heuristic validation when instrumentation unavailable.

        Args:
            key: License key to validate.

        Returns:
            True if key passes basic heuristic checks.
        """
        key_clean = key.replace("-", "").replace(" ", "")

        if len(key_clean) < 8:
            return False

        for constraint in self.algorithm.constraints:
            if constraint.type == "length":
                if len(key_clean) != constraint.value:
                    return False
            elif constraint.type == "pattern":
                pattern = constraint.value.replace("#", "[A-Z0-9]")
                if not re.match(pattern, key):
                    return False

        return True

    def _kill_process(self, pid: int) -> None:
        """Safely kill process by PID.

        Args:
            pid: Process ID to terminate.
        """
        try:
            if platform.system() == "Windows":
                subprocess.run(["taskkill", "/F", "/PID", str(pid)],
                             capture_output=True, check=False, timeout=2)
            else:
                os.kill(pid, 9)
        except Exception as e:
            logger.debug("Failed to kill process %d: %s", pid, e)


class KeygenGenerator:
    """Orchestrates complete license key generation pipeline.

    Coordinates algorithm extraction, constraint solving, and key space exploration
    to generate valid license keys for target software with production-ready results.
    """

    def __init__(self) -> None:
        """Initialize the KeygenGenerator with all required components."""
        self.extractor = AlgorithmExtractor()
        self.solver = ConstraintSolver()
        self.explorer = KeySpaceExplorer()
        self.templates = self._load_templates()

    def _load_templates(self) -> dict[str, KeygenTemplate]:
        """Load common keygen templates.

        Initializes predefined license key templates for common software protection
        schemes like Windows, Adobe, and standard formats.

        Returns:
            Dictionary mapping template names to KeygenTemplate objects with format and checksum settings.
        """
        return {
            "standard": KeygenTemplate(
                format="####-####-####-####",
                charset=string.ascii_uppercase + string.digits,
                checksum_algorithm="crc32",
            ),
            "windows": KeygenTemplate(
                format="#####-#####-#####-#####-#####",
                charset="23456789ABCDEFGHJKLMNPQRSTUVWXYZ",  # No ambiguous chars
                checksum_algorithm="mod7",
            ),
            "adobe": KeygenTemplate(
                format="####-####-####-####-####-####",
                charset=string.digits,
                checksum_algorithm="luhn",
            ),
            "simple": KeygenTemplate(
                format="##########",
                charset=string.ascii_uppercase + string.digits,
                checksum_algorithm=None,
            ),
        }

    def generate_keygen(self, binary_path: str, template_name: str = "standard", num_keys: int = 10) -> list[str]:
        """Generate valid keys for target binary.

        Orchestrates complete key generation by extracting validation algorithm from binary,
        solving constraints, and exploring key space to find valid license keys.

        Args:
            binary_path: Absolute or relative path to the target PE binary.
            template_name: Name of template to use (standard, windows, adobe, simple).
            num_keys: Number of valid keys to generate.

        Returns:
            List of generated valid license keys for the target binary.
        """
        logger.info("Generating keygen for: %s", binary_path)

        # Extract validation algorithm
        algorithms = self.extractor.extract_algorithm(binary_path)

        if not algorithms:
            logger.warning("No validation algorithms found, using heuristic generation")
            return self._heuristic_generation(template_name, num_keys)

        # Use best algorithm
        best_algorithm = max(algorithms, key=lambda a: a.confidence)
        logger.info("Using algorithm: %s (confidence: %.2f)", best_algorithm.type.name, best_algorithm.confidence)

        # Get template
        template = self.templates.get(template_name, self.templates["standard"])

        # Apply algorithm constraints to template
        template.constraints = best_algorithm.constraints

        # Create validator based on algorithm
        validator = self._create_validator(best_algorithm, binary_path)

        # Generate keys
        keys = []

        # Try constraint solver first
        for _ in range(min(num_keys, 10)):
            key = self.solver.solve_constraints(best_algorithm.constraints, template)
            if key and validator(key):
                keys.append(key)

        # If not enough keys, use space exploration
        if len(keys) < num_keys:
            additional_keys = self.explorer.explore_keyspace(template, best_algorithm.constraints, validator, num_keys - len(keys))
            keys.extend(additional_keys)

        return keys[:num_keys]

    def _heuristic_generation(self, template_name: str, num_keys: int) -> list[str]:
        """Generate keys using heuristics when no algorithm found.

        Generates license keys using random selection and optional checksum application
        when algorithm extraction fails from the target binary.

        Args:
            template_name: Name of template to use for key generation.
            num_keys: Number of keys to generate.

        Returns:
            List of generated license keys using heuristic methods.
        """
        template = self.templates.get(template_name, self.templates["standard"])
        keys = []

        for _ in range(num_keys):
            key = self.explorer._random_key(template)

            # Apply checksum if configured
            if template.checksum_algorithm:
                key = self.solver._apply_checksum(key, template.checksum_algorithm)

            keys.append(key)

        return keys

    def _create_validator(self, algorithm: ValidationAlgorithm, binary_path: str) -> Callable[[str], bool]:
        """Create validator function based on algorithm.

        Builds a production-ready validator that tests keys against the actual binary using
        dynamic instrumentation (Frida), binary patching (radare2), or process monitoring.

        Args:
            algorithm: ValidationAlgorithm extracted from the target binary.
            binary_path: Absolute or relative path to the target PE binary.

        Returns:
            Callable function that validates license keys by testing against real binary.
        """
        setattr(algorithm, "_binary_path", binary_path)

        binary_validator = BinaryKeyValidator(binary_path, algorithm, timeout=5.0)

        def validator(key: str) -> bool:
            for constraint in algorithm.constraints:
                if not self.solver._check_constraint(key, constraint):
                    return False

            if algorithm.type == KeyAlgorithmType.CHECKSUM:
                if not self._validate_checksum_key(key, algorithm):
                    return False

            if algorithm.type == KeyAlgorithmType.RSA_SIGNATURE:
                if not self._validate_rsa_key(key, algorithm):
                    return False

            if algorithm.type == KeyAlgorithmType.PATTERN_BASED:
                if not self._validate_pattern_key(key, algorithm):
                    return False

            result = binary_validator.validate_key(key)
            logger.debug("Binary validation for key %s: %s", key[:8] + "...", result)
            return result

        return validator

    def _validate_checksum_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate key with checksum algorithm.

        Tests a license key against checksum-based validation algorithm by identifying
        the checksum type from algorithm operations and verifying accordingly.

        Args:
            key: License key string to validate.
            algorithm: ValidationAlgorithm with detected checksum requirements.

        Returns:
            True if key passes checksum validation, False otherwise.
        """
        # Extract checksum type from algorithm
        checksum_type = "crc32"  # Default

        for op in algorithm.crypto_operations:
            if "CRC" in op:
                checksum_type = "crc32"
                break
            if "MD5" in op:
                checksum_type = "md5"
                break
            if "SHA" in op:
                checksum_type = "sha256"
                break

        return self.solver._verify_checksum(key, checksum_type)

    def _validate_rsa_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate RSA signed key.

        Tests a license key against RSA signature-based validation by extracting the public
        key from the binary, parsing the key structure, and performing actual RSA signature
        verification using cryptographic primitives.

        Args:
            key: License key string to validate.
            algorithm: ValidationAlgorithm with RSA signature detection.

        Returns:
            True if key passes RSA signature validation, False otherwise.
        """
        if not CRYPTOGRAPHY_AVAILABLE:
            logger.warning("Cryptography library not available, falling back to basic validation")
            return len(key.replace("-", "").replace(" ", "")) >= 16

        binary_path = getattr(algorithm, "_binary_path", None)
        if not binary_path:
            logger.warning("Binary path not available for RSA validation")
            return len(key.replace("-", "").replace(" ", "")) >= 16

        validator = RSAKeyValidator(binary_path)
        return validator.validate_license_key(key, algorithm)

    def _validate_pattern_key(self, key: str, algorithm: ValidationAlgorithm) -> bool:
        """Validate pattern-based key.

        Tests a license key against pattern-based validation by matching key format
        against patterns extracted from the validation algorithm.

        Args:
            key: License key string to validate.
            algorithm: ValidationAlgorithm with detected format patterns.

        Returns:
            True if key matches detected patterns, False otherwise.
        """
        return next(
            (self.solver._match_pattern(key, constraint.value) for constraint in algorithm.constraints if constraint.type == "pattern"),
            True,
        )

    def batch_generate(self, binary_path: str, output_file: str, num_keys: int = 1000, template: str = "standard") -> list[str]:
        """Generate batch of keys and save to file.

        Generates a large batch of license keys from target binary, saves them to output file,
        and writes generation statistics to accompanying JSON file.

        Args:
            binary_path: Absolute or relative path to the target PE binary.
            output_file: Path to output text file for saving generated keys.
            num_keys: Number of keys to generate.
            template: Name of template to use for key generation.

        Returns:
            List of generated valid license keys.
        """
        logger.info("Generating %d keys...", num_keys)

        keys = self.generate_keygen(binary_path, template, num_keys)

        # Save to file
        with open(output_file, "w") as f:
            f.writelines(key + "\n" for key in keys)

        logger.info("Generated %d keys saved to: %s", len(keys), output_file)

        # Generate statistics
        stats = {
            "total_generated": len(keys),
            "unique_keys": len(set(keys)),
            "template_used": template,
            "algorithm_extracted": bool(self.extractor.extract_algorithm(binary_path)),
        }

        # Save statistics
        stats_file = output_file.replace(".txt", "_stats.json")
        with open(stats_file, "w") as f:
            json.dump(stats, f, indent=2)

        return keys


def main() -> None:
    """Generate license keys from binary using extraction and constraint solving.

    Parses command-line arguments and executes keygen generation for target PE binary,
    with support for batch generation and multiple template formats.
    """
    import argparse

    parser = argparse.ArgumentParser(description="Intellicrack Keygen Generator")
    parser.add_argument("binary", help="Target binary path")
    parser.add_argument("-n", "--num-keys", type=int, default=10, help="Number of keys to generate")
    parser.add_argument(
        "-t",
        "--template",
        default="standard",
        choices=["standard", "windows", "adobe", "simple"],
        help="Key template to use",
    )
    parser.add_argument("-o", "--output", help="Output file for batch generation")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    generator = KeygenGenerator()

    if args.output:
        # Batch generation
        generator.batch_generate(args.binary, args.output, args.num_keys, args.template)
    else:
        # Generate and display keys
        keys = generator.generate_keygen(args.binary, args.template, args.num_keys)

        print(f"\n=== Generated Keys ({args.template} template) ===")
        for i, key in enumerate(keys, 1):
            print(f"{i:3d}. {key}")

        if not keys:
            print("No valid keys generated. Try a different template or check the binary.")


if __name__ == "__main__":
    main()
