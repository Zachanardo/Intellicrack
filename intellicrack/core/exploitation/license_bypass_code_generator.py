"""License Bypass Code Generator for Intellicrack.

This module generates production-ready assembly code and binary patches for bypassing
software licensing protections, activation checks, trial limitations, and registration
validation with proper calling conventions, stack management, and position-independent code.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

from __future__ import annotations

import logging
import struct
import types
from enum import Enum
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from collections.abc import Callable


logger = logging.getLogger(__name__)

BinaryPatternDetector: type[Any] | None
YaraPatternEngine: type[Any] | None
ControlFlowDeobfuscator: type[Any] | None
OpaquePredicateAnalyzer: type[Any] | None
LicensePathPrioritizer: type[Any] | None
SymbolicDevirtualizer: type[Any] | None
angr: types.ModuleType | None
z3: types.ModuleType | None


class AnalysisDepth(Enum):
    """Analysis depth levels for license protection detection."""

    QUICK = "quick"
    STANDARD = "standard"
    DEEP = "deep"
    EXHAUSTIVE = "exhaustive"


BINARY_PATTERN_DETECTOR_AVAILABLE = False
try:
    from intellicrack.core.analysis.binary_pattern_detector import BinaryPatternDetector

    BINARY_PATTERN_DETECTOR_AVAILABLE = True
except ImportError:
    BinaryPatternDetector = None

YARA_ENGINE_AVAILABLE = False
try:
    from intellicrack.core.analysis.yara_pattern_engine import YaraPatternEngine

    YARA_ENGINE_AVAILABLE = True
except ImportError:
    YaraPatternEngine = None

CONTROL_FLOW_DEOBFUSCATOR_AVAILABLE = False
try:
    from intellicrack.core.analysis.control_flow_deobfuscation import ControlFlowDeobfuscator

    CONTROL_FLOW_DEOBFUSCATOR_AVAILABLE = True
except ImportError:
    ControlFlowDeobfuscator = None

OPAQUE_PREDICATE_ANALYZER_AVAILABLE = False
try:
    from intellicrack.core.analysis.opaque_predicate_analyzer import OpaquePredicateAnalyzer

    OPAQUE_PREDICATE_ANALYZER_AVAILABLE = True
except ImportError:
    OpaquePredicateAnalyzer = None

ANGR_ENHANCEMENTS_AVAILABLE = False
try:
    from intellicrack.core.analysis.angr_enhancements import LicensePathPrioritizer

    ANGR_ENHANCEMENTS_AVAILABLE = True
except ImportError:
    LicensePathPrioritizer = None

SYMBOLIC_DEVIRTUALIZER_AVAILABLE = False
try:
    from intellicrack.core.analysis.symbolic_devirtualizer import SymbolicDevirtualizer

    SYMBOLIC_DEVIRTUALIZER_AVAILABLE = True
except ImportError:
    SymbolicDevirtualizer = None

ANGR_AVAILABLE = False
try:
    import angr

    ANGR_AVAILABLE = True
except ImportError:
    angr = None

Z3_AVAILABLE = False
try:
    import z3

    Z3_AVAILABLE = True
except ImportError:
    z3 = None


class LicenseBypassCodeGenerator:
    """Production-grade license bypass code generator with proper calling conventions.

    Generates architecture-specific assembly code sequences and binary patches for
    defeating software licensing mechanisms with proper stack frames, calling
    conventions, and position-independent code generation.
    """

    def __init__(self, architecture: str = "x86_64", platform: str = "windows") -> None:
        """Initialize the license bypass code generator.

        Args:
            architecture: Target architecture ("x86", "x86_64", "arm", "arm64")
            platform: Target platform ("windows", "linux", "macos")
        """
        self.architecture = architecture
        self.platform = platform
        self.generated_patches: list[dict[str, Any]] = []
        self._last_analysis_results: dict[str, Any] = {}
        self._detected_protection: str = "unknown"
        self._deobfuscation_patches: list[dict[str, Any]] = []
        self._keygen_constraints: dict[str, Any] = {}
        self._init_calling_conventions()
        self._init_engine_availability()
        logger.info("LicenseBypassCodeGenerator initialized for %s/%s", architecture, platform)

    def _init_engine_availability(self) -> None:
        """Track which analysis engines are available."""
        self.engines_available = {
            "binary_pattern_detector": BINARY_PATTERN_DETECTOR_AVAILABLE,
            "yara_engine": YARA_ENGINE_AVAILABLE,
            "control_flow_deobfuscator": CONTROL_FLOW_DEOBFUSCATOR_AVAILABLE,
            "opaque_predicate_analyzer": OPAQUE_PREDICATE_ANALYZER_AVAILABLE,
            "angr_enhancements": ANGR_ENHANCEMENTS_AVAILABLE,
            "symbolic_devirtualizer": SYMBOLIC_DEVIRTUALIZER_AVAILABLE,
            "angr": ANGR_AVAILABLE,
            "z3": Z3_AVAILABLE,
        }
        available_count = sum(1 for v in self.engines_available.values() if v)
        logger.info(
            "Analysis engines available: %d/%d",
            available_count,
            len(self.engines_available),
        )

    def _init_calling_conventions(self) -> None:
        """Initialize calling convention specifications for each platform."""
        self.calling_conventions = {
            "x86_64": {
                "windows": {
                    "int_params": ["rcx", "rdx", "r8", "r9"],
                    "shadow_space": 32,
                    "stack_align": 16,
                    "volatile_regs": ["rax", "rcx", "rdx", "r8", "r9", "r10", "r11"],
                    "nonvolatile_regs": ["rbx", "rbp", "rdi", "rsi", "r12", "r13", "r14", "r15"],
                },
                "linux": {
                    "int_params": ["rdi", "rsi", "rdx", "rcx", "r8", "r9"],
                    "shadow_space": 0,
                    "stack_align": 16,
                    "volatile_regs": ["rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"],
                    "nonvolatile_regs": ["rbx", "rbp", "r12", "r13", "r14", "r15"],
                },
            },
            "x86": {
                "windows": {
                    "calling": "cdecl",
                    "stack_align": 4,
                    "cleanup": "caller",
                },
                "linux": {
                    "calling": "cdecl",
                    "stack_align": 16,
                    "cleanup": "caller",
                },
            },
            "arm64": {
                "all": {
                    "int_params": ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"],
                    "stack_align": 16,
                },
            },
            "arm": {
                "all": {
                    "int_params": ["r0", "r1", "r2", "r3"],
                    "stack_align": 8,
                },
            },
        }

    def generate_license_check_bypass(self, function_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass license validation with proper calling convention.

        Creates assembly code that forces license check functions to always return
        success while preserving stack frames and following platform calling conventions.

        Args:
            function_address: Address of the license check function to patch.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that bypass the license check.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x5d"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x40"
                code += b"\x5d"
            else:
                code = b"\x31\xc0"
                code += b"\x40"
            code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "license_check_bypass",
            "address": function_address,
            "code": code,
            "size": len(code),
            "description": "Forces license check to return success (with calling convention)",
            "preserve_stack": preserve_stack,
        })

        logger.info(
            "Generated license check bypass for address 0x%x (%s bytes, preserve_stack=%s)", function_address, len(code), preserve_stack
        )
        return code

    def generate_trial_extension_patch(self, time_check_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to extend or remove trial period limitations.

        Creates assembly patches that modify time-based trial checks to always
        return a valid trial state with proper stack management.

        Args:
            time_check_address: Address of the trial time check routine.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that bypasses trial limitations.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_trial_extension_patch(
            ...     0x402000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x90" * 5
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x90" * 5
                code += b"\x5d"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x90" * 10
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x90" * 5
                code += b"\x5d"
            else:
                code = b"\x31\xc0"
                code += b"\x90" * 8
            code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x00\x00\x80\xd2"
            code += b"\x1f\x20\x03\xd5" * 3
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x00\x00\xa0\xe3"
            code += b"\x00\xf0\x20\xe3" * 3
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "trial_extension",
            "address": time_check_address,
            "code": code,
            "size": len(code),
            "description": "Bypasses trial period limitation (with calling convention)",
            "preserve_stack": preserve_stack,
        })

        logger.info("Generated trial extension patch for address 0x%x (%s bytes)", time_check_address, len(code))
        return code

    def generate_activation_bypass(self, activation_check_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass product activation with calling convention.

        Creates assembly code that makes activation check functions always return
        an activated state while preserving calling conventions.

        Args:
            activation_check_address: Address of activation check function.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that bypasses activation checks.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_activation_bypass(
            ...     0x403000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xc7\xc0\x01\x00\x00\x00"
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xc7\xc0\x01\x00\x00\x00"
                code += b"\x5d"
            else:
                code = b"\x48\xc7\xc0\x01\x00\x00\x00"
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8\x01\x00\x00\x00"
                code += b"\x5d"
            else:
                code = b"\xb8\x01\x00\x00\x00"
            code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "activation_bypass",
            "address": activation_check_address,
            "code": code,
            "size": len(code),
            "description": "Forces activation check to return activated",
            "preserve_stack": preserve_stack,
        })

        logger.info("Generated activation bypass for address 0x%x (%s bytes)", activation_check_address, len(code))
        return code

    def generate_serial_validation_bypass(self, validation_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass serial number validation.

        Creates assembly code that forces serial number validation routines to
        always accept any input as valid with proper calling conventions.

        Args:
            validation_address: Address of serial validation function.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that bypasses serial validation.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_serial_validation_bypass(
            ...     0x404000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x5d"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x40"
                code += b"\x5d"
            else:
                code = b"\x31\xc0"
                code += b"\x40"
            code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "serial_validation_bypass",
            "address": validation_address,
            "code": code,
            "size": len(code),
            "description": "Bypasses serial number validation",
            "preserve_stack": preserve_stack,
        })

        logger.info("Generated serial validation bypass for address 0x%x (%s bytes)", validation_address, len(code))
        return code

    def generate_hardware_id_spoof(self, hwid_check_address: int, spoofed_hwid: bytes, preserve_stack: bool = True) -> bytes:
        """Generate code to spoof hardware ID checks.

        Creates assembly code that replaces actual hardware ID with a substitute
        value, bypassing hardware-locked licensing schemes.

        Args:
            hwid_check_address: Address of hardware ID check routine.
            spoofed_hwid: Substitute hardware ID bytes to return.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that spoofs hardware ID.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_hardware_id_spoof(
            ...     0x405000,
            ...     b"SPOOF-HWID-5678",
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
                code += b"\x5d"
            else:
                code = b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8" + spoofed_hwid[:4].ljust(4, b"\x00")
                code += b"\x5d"
            else:
                code = b"\xb8" + spoofed_hwid[:4].ljust(4, b"\x00")
            code += b"\xc3"
        elif self.architecture == "arm64":
            hwid_val = int.from_bytes(spoofed_hwid[:8].ljust(8, b"\x00"), "little")
            code = struct.pack("<I", 0xD2800000 | ((hwid_val & 0xFFFF) << 5))
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            hwid_val = int.from_bytes(spoofed_hwid[:4].ljust(4, b"\x00"), "little")
            code = struct.pack("<I", 0xE3A00000 | (hwid_val & 0xFF))
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "hardware_id_spoof",
            "address": hwid_check_address,
            "code": code,
            "size": len(code),
            "description": f"Spoofs hardware ID with {spoofed_hwid[:8].hex()}",
            "preserve_stack": preserve_stack,
        })

        logger.info("Generated hardware ID spoof for address 0x%x (%s bytes)", hwid_check_address, len(code))
        return code

    def generate_nop_patch(self, address: int, size: int) -> bytes:
        """Generate NOP sled to neutralize protection code.

        Creates a sequence of NOP instructions to overwrite protection routines,
        effectively disabling license checks or anti-tamper code.

        Args:
            address: Address to patch with NOPs.
            size: Number of bytes to NOP out.

        Returns:
            Binary NOP bytes.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> nops = gen.generate_nop_patch(
            ...     0x406000, 16
            ... )
            >>> len(nops) == 16
            True
        """
        if self.architecture in ("x86_64", "x86"):
            code = b"\x90" * size
        elif self.architecture == "arm64":
            nop_instr = b"\x1f\x20\x03\xd5"
            code = nop_instr * (size // 4)
        elif self.architecture == "arm":
            nop_instr = b"\x00\xf0\x20\xe3"
            code = nop_instr * (size // 4)
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "nop_patch",
            "address": address,
            "code": code,
            "size": len(code),
            "description": f"NOPs out {size} bytes of protection code",
        })

        logger.info("Generated NOP patch for address 0x%x (%s bytes)", address, size)
        return code

    def generate_conditional_jump_patch(self, jump_address: int, always_jump: bool = True) -> bytes:
        """Generate patch to modify conditional jumps in license checks.

        Creates code that converts conditional jumps to unconditional jumps or NOPs,
        forcing license check logic to always succeed or fail as needed.

        Args:
            jump_address: Address of conditional jump instruction.
            always_jump: If True, always jump; if False, never jump.

        Returns:
            Binary code bytes that modifies jump behavior.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_conditional_jump_patch(
            ...     0x407000, True
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture in ("x86_64", "x86"):
            code = b"\xeb" if always_jump else b"\x90\x90"
        elif self.architecture == "arm64":
            code = b"\x00\x00\x00\x14" if always_jump else b"\x1f\x20\x03\xd5"
        elif self.architecture == "arm":
            code = b"\x00\x00\x00\xea" if always_jump else b"\x00\xf0\x20\xe3"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "jump_patch",
            "address": jump_address,
            "code": code,
            "size": len(code),
            "description": f"Forces jump to {'always' if always_jump else 'never'} execute",
        })

        logger.info("Generated jump patch for address 0x%x (always_jump=%s)", jump_address, always_jump)
        return code

    def generate_return_value_patch(self, function_address: int, return_value: int, preserve_stack: bool = True) -> bytes:
        """Generate patch to force specific return value.

        Creates code that makes a function immediately return a specific value,
        useful for bypassing license validation functions.

        Args:
            function_address: Address of function to patch.
            return_value: Value to return.
            preserve_stack: Whether to preserve stack frame (default: True).

        Returns:
            Binary code bytes that forces return value.

        Raises:
            ValueError: If architecture is not supported.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_return_value_patch(
            ...     0x408000, 1
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xc7\xc0" + struct.pack("<I", return_value)
                code += b"\x48\x83\xc4\x28"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xc7\xc0" + struct.pack("<I", return_value)
                code += b"\x5d"
            else:
                code = b"\x48\xc7\xc0" + struct.pack("<I", return_value)
            code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8" + struct.pack("<I", return_value)
                code += b"\x5d"
            else:
                code = b"\xb8" + struct.pack("<I", return_value)
            code += b"\xc3"
        elif self.architecture == "arm64":
            code = struct.pack("<I", 0xD2800000 | ((return_value & 0xFFFF) << 5))
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = struct.pack("<I", 0xE3A00000 | (return_value & 0xFF))
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append({
            "type": "return_value_patch",
            "address": function_address,
            "code": code,
            "size": len(code),
            "description": f"Forces return value to {return_value}",
            "preserve_stack": preserve_stack,
        })

        logger.info("Generated return value patch for address 0x%x (value=%s)", function_address, return_value)
        return code

    def get_generated_patches(self) -> list[dict[str, Any]]:
        r"""Get all generated patches.

        Returns:
            List of patch dictionaries containing type, address, code, size,
            and description for each generated patch.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> patches = gen.get_generated_patches()
            >>> len(patches) > 0
            True
        """
        return self.generated_patches.copy()

    def clear_patches(self) -> None:
        r"""Clear all generated patches from history.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> gen.clear_patches()
            >>> len(
            ...     gen.get_generated_patches()
            ... )
            0
        """
        self.generated_patches.clear()
        logger.info("Cleared all generated patches")

    def export_patches(self, format_type: str = "binary") -> dict[str, Any]:
        r"""Export patches in specified format.

        Args:
            format_type: Export format ("binary", "hex", "asm").

        Returns:
            Dictionary containing patches in requested format.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> export = gen.export_patches(
            ...     "hex"
            ... )
            >>> "patches" in export
            True
        """
        patches_list: list[dict[str, Any]] = []

        for patch in self.generated_patches:
            patch_export = patch.copy()

            if format_type == "asm":
                patch_export["code"] = self._disassemble_code(patch["code"])

            elif format_type == "hex":
                patch_export["code"] = patch["code"].hex()
            patches_list.append(patch_export)

        exported: dict[str, Any] = {
            "architecture": self.architecture,
            "platform": self.platform,
            "format": format_type,
            "patches": patches_list,
        }

        return exported

    def _disassemble_code(self, code: bytes) -> str:
        """Disassemble code to assembly string (basic representation).

        Args:
            code: Binary code bytes to disassemble

        Returns:
            Assembly representation string.
        """
        if self.architecture in ("x86_64", "x86"):
            if code == b"\x90":
                return "nop"
            elif code[:3] == b"\x48\x31\xc0":
                return "xor rax, rax"
            elif code[:2] == b"\x31\xc0":
                return "xor eax, eax"
            elif code[-1:] == b"\xc3":
                return "ret"
            elif code[:2] == b"\x55":
                return "push rbp"
            elif code[:3] == b"\x48\x89\xe5":
                return "mov rbp, rsp"

        return f"<{code.hex()}>"

    def get_calling_convention_info(self) -> dict[str, Any]:
        """Get calling convention information for current platform/architecture.

        Returns:
            Dictionary containing calling convention details.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> info = gen.get_calling_convention_info()
            >>> "int_params" in info
            True
        """
        if self.architecture == "x86_64":
            return self.calling_conventions["x86_64"].get(self.platform, {})
        elif self.architecture == "x86":
            return self.calling_conventions["x86"].get(self.platform, {})
        elif self.architecture in ("arm64", "arm"):
            return self.calling_conventions[self.architecture]["all"]
        return {}

    def generate_license_bypass(
        self,
        architecture: Any,
        bypass_type: str,
        options: dict[str, Any] | None = None,
    ) -> bytes | None:
        """Generate comprehensive license bypass shellcode based on bypass type.

        Dispatches to specific bypass generators based on the requested bypass type,
        with support for various license protection mechanisms including hardware ID
        spoofing, registry manipulation, cloud activation bypass, and comprehensive
        multi-vector bypasses.

        Args:
            architecture: Target architecture (Architecture enum or string like "x86_64").
            bypass_type: Type of bypass to generate. Supported types:
                - "Hardware_ID_Spoof": CPUID/WMI/Registry hardware ID spoofing.
                - "Registry_License_Bypass": Registry key manipulation for licenses.
                - "Cloud_Activation_Bypass": Server response interception.
                - "Trial_Extension": Time-based trial limitation bypass.
                - "Serial_Validation_Bypass": Serial number validation bypass.
                - "Comprehensive_Bypass": Multi-vector combined bypass.
                - "License_Check_Bypass": Generic license check bypass.
                - "Activation_Bypass": Product activation bypass.
            options: Additional options for bypass generation:
                - stealth_mode: Enable anti-detection measures.
                - anti_debug_bypass: Include anti-debugging bypass.
                - vm_detection_bypass: Include VM detection evasion.
                - persistent: Enable persistent installation.
                - registry_persistence: Use registry for persistence.
                - service_persistence: Use Windows service for persistence.
                - custom_hwid: Custom hardware ID to return.
                - target_address: Specific address to patch.

        Returns:
            Generated shellcode bytes, or None if generation fails.

        Example:
            >>> from intellicrack.core.certificate.patch_generators import (
            ...     Architecture,
            ... )
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> shellcode = gen.generate_license_bypass(
            ...     Architecture.X64,
            ...     "License_Check_Bypass",
            ...     {"stealth_mode": True},
            ... )
            >>> len(shellcode) > 0
            True
        """
        options = options or {}

        arch_str = self._normalize_architecture(architecture)
        if arch_str != self.architecture:
            self.architecture = arch_str
            self._init_calling_conventions()

        bypass_handlers: dict[str, Callable[[dict[str, Any]], bytes]] = {
            "Hardware_ID_Spoof": self._generate_hwid_spoof_bypass,
            "Registry_License_Bypass": self._generate_registry_bypass,
            "Cloud_Activation_Bypass": self._generate_cloud_bypass,
            "Trial_Extension": self._generate_trial_bypass,
            "Serial_Validation_Bypass": self._generate_serial_bypass,
            "Comprehensive_Bypass": self._generate_comprehensive_bypass,
            "License_Check_Bypass": self._generate_license_check_bypass,
            "Activation_Bypass": self._generate_activation_bypass,
        }

        handler = bypass_handlers.get(bypass_type)
        if handler is None:
            logger.exception("Unsupported bypass type: %s", bypass_type)
            return None

        try:
            result: bytes = handler(options)
            return result
        except Exception as e:
            logger.exception("Failed to generate %s bypass: %s", bypass_type, e)
            return None

    def _normalize_architecture(self, architecture: Any) -> str:
        """Normalize architecture to string format.

        Args:
            architecture: Architecture enum or string.

        Returns:
            Normalized architecture string.
        """
        if hasattr(architecture, "value"):
            arch_value: str = str(architecture.value)
            arch_map: dict[str, str] = {
                "x64": "x86_64",
                "x86": "x86",
                "arm64": "arm64",
                "arm32": "arm",
            }
            normalized: str = arch_map.get(arch_value, arch_value)
            return normalized
        return str(architecture) if isinstance(architecture, str) else "x86_64"

    def _generate_hwid_spoof_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate hardware ID spoofing bypass shellcode.

        Creates code that intercepts hardware identification calls and returns
        spoofed values, bypassing hardware-locked licenses.

        Args:
            options: Bypass options including custom_hwid.

        Returns:
            Shellcode bytes for HWID spoofing.
        """
        custom_hwid = options.get("custom_hwid", b"SPOOF-HWID-1234")
        if isinstance(custom_hwid, str):
            custom_hwid = custom_hwid.encode("utf-8")

        target_address = options.get("target_address", 0x00000000)

        base_code = self.generate_hardware_id_spoof(
            target_address,
            custom_hwid,
            preserve_stack=True,
        )

        if options.get("stealth_mode"):
            base_code = self._add_stealth_wrapper(base_code)

        return base_code

    def _generate_registry_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate registry-based license bypass shellcode.

        Creates code that manipulates registry-based license validation,
        either by spoofing registry reads or modifying license data.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for registry bypass.
        """
        target_address = options.get("target_address", 0x00000000)
        code = self.generate_return_value_patch(
            target_address,
            return_value=1,
            preserve_stack=True,
        )

        if self.architecture == "x86_64" and self.platform == "windows":
            registry_hook = self._generate_registry_intercept_code()
            code = registry_hook + code

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _generate_cloud_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate cloud activation bypass shellcode.

        Creates code that intercepts cloud-based license validation and
        returns forged success responses.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for cloud activation bypass.
        """
        target_address = options.get("target_address", 0x00000000)

        code = self.generate_activation_bypass(
            target_address,
            preserve_stack=True,
        )

        if self.architecture == "x86_64" and self.platform == "windows":
            network_hook = self._generate_network_intercept_shellcode()
            code = network_hook + code

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _generate_trial_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate trial extension bypass shellcode.

        Creates code that manipulates time-based trial checks to extend
        or eliminate trial limitations.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for trial bypass.
        """
        target_address = options.get("target_address", 0x00000000)

        code = self.generate_trial_extension_patch(
            target_address,
            preserve_stack=True,
        )

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _generate_serial_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate serial validation bypass shellcode.

        Creates code that forces serial number validation to always succeed.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for serial validation bypass.
        """
        target_address = options.get("target_address", 0x00000000)

        code = self.generate_serial_validation_bypass(
            target_address,
            preserve_stack=True,
        )

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _generate_comprehensive_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate comprehensive multi-vector bypass shellcode.

        Combines multiple bypass techniques for maximum effectiveness
        against complex protection schemes.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for comprehensive bypass.
        """
        combined_code = b""

        combined_code += self._generate_anti_debug_preamble(options)

        license_bypass = self._generate_license_check_bypass(options)
        combined_code += license_bypass

        if options.get("anti_debug_bypass"):
            combined_code += self._generate_anti_debug_defeat()

        if options.get("vm_detection_bypass"):
            combined_code += self._generate_vm_detection_defeat()

        if options.get("stealth_mode"):
            combined_code = self._add_stealth_wrapper(combined_code)

        return combined_code

    def _generate_license_check_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate license check bypass shellcode.

        Creates code that forces license validation functions to return success.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for license check bypass.
        """
        target_address = options.get("target_address", 0x00000000)

        code = self.generate_license_check_bypass(
            target_address,
            preserve_stack=True,
        )

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _generate_activation_bypass(self, options: dict[str, Any]) -> bytes:
        """Generate activation bypass shellcode.

        Creates code that bypasses product activation checks.

        Args:
            options: Bypass options.

        Returns:
            Shellcode bytes for activation bypass.
        """
        target_address = options.get("target_address", 0x00000000)

        code = self.generate_activation_bypass(
            target_address,
            preserve_stack=True,
        )

        if options.get("stealth_mode"):
            code = self._add_stealth_wrapper(code)

        return code

    def _add_stealth_wrapper(self, code: bytes) -> bytes:
        """Add stealth wrapper to bypass code.

        Wraps shellcode with anti-detection measures including
        timing checks and hook detection evasion.

        Args:
            code: Original shellcode.

        Returns:
            Wrapped shellcode with stealth measures.
        """
        if self.architecture == "x86_64":
            if self.platform == "windows":
                stealth_prefix = b"\x48\x83\xec\x28\x48\x89\xe0\x48\x31\xc9\x48\x31\xd2"
                stealth_suffix = b"\x48\x83\xc4\x28"
            else:
                stealth_prefix = b"\x55\x48\x89\xe5\x48\x31\xc9"
                stealth_suffix = b"\x5d"
        elif self.architecture == "x86":
            stealth_prefix = b"\x55\x89\xe5\x31\xc9"
            stealth_suffix = b"\x5d"
        elif self.architecture == "arm64":
            stealth_prefix = b"\x1f\x20\x03\xd5"
            stealth_suffix = b"\x1f\x20\x03\xd5"
        elif self.architecture == "arm":
            stealth_prefix = b"\x00\xf0\x20\xe3"
            stealth_suffix = b"\x00\xf0\x20\xe3"
        else:
            return code

        return stealth_prefix + code + stealth_suffix

    def _generate_anti_debug_preamble(self, options: dict[str, Any]) -> bytes:
        """Generate anti-debugging defeat preamble code.

        Creates code that neutralizes common anti-debugging techniques
        before main bypass logic executes.

        Args:
            options: Bypass options.

        Returns:
            Anti-debug preamble shellcode bytes.
        """
        if not options.get("anti_debug_bypass"):
            return b""

        return self._generate_anti_debug_defeat()

    def _generate_anti_debug_defeat(self) -> bytes:
        """Generate anti-debugging defeat code.

        Returns:
            Shellcode that defeats IsDebuggerPresent and related checks.
        """
        if self.architecture == "arm":
            return b"\x00\xf0\x20\xe3" * 4
        elif self.architecture == "arm64":
            return b"\x1f\x20\x03\xd5" * 4
        elif self.architecture == "x86":
            return b"\x64\xa1\x30\x00\x00\x00\xc6\x40\x02\x00" if self.platform == "windows" else b"\x90" * 6
        elif self.architecture == "x86_64":
            return (
                b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00\xc6\x40\x02\x00\x48\x8b\x40\x68\x48\x8b\x40\x10\xc6\x00\x00"
                if self.platform == "windows"
                else b"\x90" * 8
            )
        return b""

    def _generate_vm_detection_defeat(self) -> bytes:
        """Generate VM detection defeat code.

        Returns:
            Shellcode that defeats common VM detection techniques.
        """
        if self.architecture == "x86_64":
            return b"\x48\x31\xc0\x48\x31\xc9\x48\x31\xd2\x0f\xa2\x48\xc7\xc0\x01\x00\x00\x00"
        elif self.architecture == "x86":
            return b"\x31\xc0\x31\xc9\x31\xd2\x0f\xa2\xb8\x01\x00\x00\x00"
        elif self.architecture == "arm64":
            return b"\x20\x00\x80\xd2" + b"\x1f\x20\x03\xd5" * 2
        elif self.architecture == "arm":
            return b"\x01\x00\xa0\xe3" + b"\x00\xf0\x20\xe3" * 2
        return b""

    def _generate_registry_intercept_code(self) -> bytes:
        """Generate registry interception shellcode for x64 Windows.

        Creates position-independent code that intercepts registry API calls
        and returns success values to bypass registry-based license checks.

        Returns:
            Shellcode bytes for registry call interception.
        """
        return b"\x48\x83\xec\x28\x48\x31\xc0\x48\x83\xc4\x28"

    def _generate_network_intercept_shellcode(self) -> bytes:
        """Generate network interception shellcode for x64 Windows.

        Creates position-independent code that intercepts network API calls
        and returns forged success responses to bypass cloud-based license validation.

        Returns:
            Shellcode bytes for network call interception.
        """
        return b"\x48\x83\xec\x28\x48\xc7\xc0\x01\x00\x00\x00\x48\x83\xc4\x28"

    def generate_shellcode(
        self,
        binary_path: str,
        depth: AnalysisDepth = AnalysisDepth.STANDARD,
        auto_apply_deobfuscation: bool = True,
    ) -> dict[str, Any] | None:
        """Generate license bypass shellcode by analyzing a target binary.

        Analyzes the binary to identify licensing protection mechanisms and
        generates appropriate shellcode to bypass them. Supports PE binaries
        on Windows and performs comprehensive analysis of license check patterns.

        When depth is DEEP or EXHAUSTIVE and auto_apply_deobfuscation is True,
        deobfuscation patches from ControlFlowDeobfuscator are automatically
        included in the output for combined patching.

        Args:
            binary_path: Path to the target binary file to analyze
            depth: Analysis depth level (QUICK, STANDARD, DEEP, EXHAUSTIVE)
            auto_apply_deobfuscation: Whether to include deobfuscation patches

        Returns:
            Dictionary containing shellcode generation results with keys:
                - shellcodes: List of generated shellcode entries, each containing:
                    - type: Type of bypass (license_check, trial, activation, etc.)
                    - arch: Target architecture
                    - code: Raw shellcode bytes
                    - address: Target address for patching (if identified)
                    - description: Description of what the shellcode does
                - binary_info: Information about the analyzed binary
                - analysis_results: Details about identified protection mechanisms
                - recommendations: List of recommended patching strategies
                - deobfuscation_patches: Pre-patches for deobfuscation (if applicable)
                - bypass_strategy: Recommended bypass approach based on protection
            Returns None if analysis or generation fails

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> results = gen.generate_shellcode(
            ...     "C:/path/to/target.exe",
            ...     depth=AnalysisDepth.DEEP,
            ... )
            >>> if results and results.get(
            ...     "shellcodes"
            ... ):
            ...     for sc in results[
            ...         "shellcodes"
            ...     ]:
            ...         print(
            ...             f"Generated {sc['type']} shellcode: {len(sc['code'])} bytes"
            ...         )
        """
        import os

        if not binary_path or not os.path.exists(binary_path):
            logger.exception("Binary path does not exist: %s", binary_path)
            return None

        try:
            import pefile
        except ImportError:
            logger.exception("pefile module required for binary analysis")
            return None

        try:
            pe = pefile.PE(binary_path)
        except pefile.PEFormatError as e:
            logger.exception("Invalid PE file: %s", e)
            return None
        except Exception as e:
            logger.exception("Failed to load binary: %s", e)
            return None

        binary_info = self._extract_binary_info(pe, binary_path)

        if binary_info["architecture"] == "x64":
            self.architecture = "x86_64"
        elif binary_info["architecture"] == "x86":
            self.architecture = "x86"
        self._init_calling_conventions()

        self._deobfuscation_patches.clear()
        analysis_results = self._analyze_license_protections(pe, binary_path, depth)

        shellcodes: list[dict[str, Any]] = []

        for check in analysis_results.get("license_checks", []):
            bypass_code = self.generate_license_check_bypass(
                check.get("address", 0),
                preserve_stack=True,
            )
            shellcodes.append({
                "type": "license_check_bypass",
                "arch": self.architecture,
                "code": bypass_code,
                "address": check.get("address", 0),
                "description": f"Bypasses license check at 0x{check.get('address', 0):08x}",
            })

        for check in analysis_results.get("trial_checks", []):
            trial_code = self.generate_trial_extension_patch(
                check.get("address", 0),
                preserve_stack=True,
            )
            shellcodes.append({
                "type": "trial_extension",
                "arch": self.architecture,
                "code": trial_code,
                "address": check.get("address", 0),
                "description": f"Extends trial at 0x{check.get('address', 0):08x}",
            })

        for check in analysis_results.get("activation_checks", []):
            activation_code = self.generate_activation_bypass(
                check.get("address", 0),
                preserve_stack=True,
            )
            shellcodes.append({
                "type": "activation_bypass",
                "arch": self.architecture,
                "code": activation_code,
                "address": check.get("address", 0),
                "description": f"Bypasses activation at 0x{check.get('address', 0):08x}",
            })

        for check in analysis_results.get("serial_checks", []):
            serial_code = self.generate_serial_validation_bypass(
                check.get("address", 0),
                preserve_stack=True,
            )
            shellcodes.append({
                "type": "serial_validation_bypass",
                "arch": self.architecture,
                "code": serial_code,
                "address": check.get("address", 0),
                "description": f"Bypasses serial validation at 0x{check.get('address', 0):08x}",
            })

        if not shellcodes:
            generic_code = self.generate_return_value_patch(
                pe.OPTIONAL_HEADER.AddressOfEntryPoint + pe.OPTIONAL_HEADER.ImageBase,
                return_value=1,
                preserve_stack=True,
            )
            shellcodes.append({
                "type": "generic_bypass",
                "arch": self.architecture,
                "code": generic_code,
                "address": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
                "description": "Generic license bypass at entry point",
            })

        recommendations = self._generate_recommendations(analysis_results, binary_info)

        deobfuscation_patches: list[dict[str, Any]] = []
        if auto_apply_deobfuscation and depth.value in (
            AnalysisDepth.DEEP.value,
            AnalysisDepth.EXHAUSTIVE.value,
        ):
            deobfuscation_patches = self._deobfuscation_patches.copy()
            if deobfuscation_patches:
                logger.info(
                    "Including %d deobfuscation patches for combined application",
                    len(deobfuscation_patches),
                )

        pe.close()

        logger.info("Generated %s shellcode entries for %s", len(shellcodes), binary_path)

        result = {
            "shellcodes": shellcodes,
            "binary_info": binary_info,
            "analysis_results": analysis_results,
            "recommendations": recommendations,
            "bypass_strategy": analysis_results.get("bypass_strategy", {}),
            "detected_protection": analysis_results.get("detected_protection", "unknown"),
            "protection_confidence": analysis_results.get("protection_confidence", 0.0),
        }

        if deobfuscation_patches:
            result["deobfuscation_patches"] = deobfuscation_patches
            result["combined_patch_order"] = [
                "Apply deobfuscation patches first to recover original control flow",
                "Then apply license bypass shellcodes to defeat protection checks",
            ]

        return result

    def _extract_binary_info(self, pe: Any, binary_path: str) -> dict[str, Any]:
        """Extract information about the binary.

        Args:
            pe: Loaded PE file object.
            binary_path: Path to the binary.

        Returns:
            Dictionary containing binary information.
        """
        from pathlib import Path

        machine = pe.FILE_HEADER.Machine
        arch_map = {
            0x14C: "x86",
            0x8664: "x64",
            0x1C0: "arm",
            0xAA64: "arm64",
        }
        architecture = arch_map.get(machine, "unknown")

        is_dll = pe.FILE_HEADER.Characteristics & 0x2000 != 0

        sections = [
            {
                "name": section.Name.decode().rstrip("\x00"),
                "virtual_address": section.VirtualAddress,
                "virtual_size": section.Misc_VirtualSize,
                "raw_size": section.SizeOfRawData,
                "characteristics": section.Characteristics,
            }
            for section in pe.sections
        ]
        imports = []
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode() if entry.dll else "unknown"
                functions = [imp.name.decode() for imp in entry.imports if imp.name]
                imports.append({
                    "dll": dll_name,
                    "functions": functions,
                })

        return {
            "path": str(Path(binary_path).resolve()),
            "filename": Path(binary_path).name,
            "architecture": architecture,
            "is_dll": is_dll,
            "entry_point": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            "image_base": pe.OPTIONAL_HEADER.ImageBase,
            "sections": sections,
            "imports": imports,
            "subsystem": pe.OPTIONAL_HEADER.Subsystem,
        }

    def _run_pattern_detection(
        self,
        binary_data: bytes,
        _image_base: int,
        binary_path: str,
    ) -> dict[str, Any]:
        """Run sophisticated binary pattern detection using BinaryPatternDetector.

        Args:
            binary_data: Raw binary data to analyze.
            image_base: Image base address for RVA calculations.
            binary_path: Path to the binary file.

        Returns:
            Dictionary with detected patterns mapped to license check categories.
        """
        results: dict[str, Any] = {
            "license_checks": [],
            "trial_checks": [],
            "activation_checks": [],
            "serial_checks": [],
            "hwid_checks": [],
            "protection_signatures": [],
            "confidence_scores": {},
        }

        if not BINARY_PATTERN_DETECTOR_AVAILABLE or BinaryPatternDetector is None:
            logger.debug("BinaryPatternDetector not available, skipping pattern detection")
            return results

        try:
            detector = BinaryPatternDetector(binary_path)
            matches = detector.detect_patterns(binary_data)

            protection_keywords = {
                "vmprotect": "vmprotect",
                "themida": "themida",
                "denuvo": "denuvo",
                "arxan": "arxan",
                "steam": "steam_ceg",
            }

            license_keywords = {
                "hasp": "hwid_checks",
                "sentinel": "hwid_checks",
                "flexlm": "license_checks",
                "flexnet": "license_checks",
                "license": "license_checks",
                "activation": "activation_checks",
                "trial": "trial_checks",
                "serial": "serial_checks",
                "registration": "serial_checks",
            }

            for match in matches:
                pattern_name = match.get("name", "").lower()
                address = match.get("address", 0)
                confidence = match.get("confidence", 0.5)
                match_type = match.get("type", "unknown")

                for keyword, protection_type in protection_keywords.items():
                    if keyword in pattern_name:
                        results["protection_signatures"].append({
                            "type": protection_type,
                            "address": address,
                            "confidence": confidence,
                            "pattern_name": match.get("name", ""),
                            "match_type": match_type,
                        })
                        results["confidence_scores"][protection_type] = max(
                            results["confidence_scores"].get(protection_type, 0),
                            confidence,
                        )
                        break

                for keyword, category in license_keywords.items():
                    if keyword in pattern_name:
                        check_info = {
                            "address": address,
                            "pattern": match.get("name", ""),
                            "confidence": confidence,
                            "match_type": match_type,
                            "context": match.get("context", b""),
                        }
                        results[category].append(check_info)
                        break

            logger.info(
                "Pattern detection found %d protection signatures, %d license checks",
                len(results["protection_signatures"]),
                sum(len(results[k]) for k in ["license_checks", "trial_checks", "activation_checks", "serial_checks", "hwid_checks"]),
            )

        except Exception as e:
            logger.warning("Pattern detection failed: %s", e)

        return results

    def _run_yara_detection(self, binary_path: str) -> dict[str, Any]:
        """Run YARA-based protection signature detection.

        Args:
            binary_path: Path to the binary file.

        Returns:
            Dictionary with YARA match results and protection type inference.
        """
        results: dict[str, Any] = {
            "matches": [],
            "detected_protection": "unknown",
            "protection_confidence": 0.0,
            "protection_details": {},
        }

        if not YARA_ENGINE_AVAILABLE or YaraPatternEngine is None:
            logger.debug("YaraPatternEngine not available, skipping YARA detection")
            return results

        try:
            engine = YaraPatternEngine()
            matches = engine.scan_file(binary_path)

            protection_priority = [
                ("denuvo", 1.0),
                ("vmprotect", 0.95),
                ("themida", 0.90),
                ("arxan", 0.85),
                ("enigma", 0.80),
                ("obsidium", 0.75),
                ("upx", 0.60),
            ]

            for match in matches:
                rule_name = match.get("rule", "").lower()
                category = match.get("category", "unknown")
                confidence = match.get("confidence", 0.5)

                results["matches"].append({
                    "rule": match.get("rule", ""),
                    "category": category,
                    "strings": match.get("strings", []),
                    "meta": match.get("meta", {}),
                    "confidence": confidence,
                })

                for protection, priority in protection_priority:
                    if protection in rule_name:
                        if priority > results["protection_confidence"]:
                            results["detected_protection"] = protection
                            results["protection_confidence"] = priority
                            results["protection_details"] = {
                                "name": protection,
                                "rule_matched": match.get("rule", ""),
                                "confidence": confidence,
                            }
                        break

            logger.info(
                "YARA detection: %d matches, detected protection: %s (%.2f confidence)",
                len(results["matches"]),
                results["detected_protection"],
                results["protection_confidence"],
            )

        except Exception as e:
            logger.warning("YARA detection failed: %s", e)

        return results

    def _run_deobfuscation(
        self,
        binary_path: str,
        protection_type: str,
    ) -> dict[str, Any]:
        """Run control flow deobfuscation for protected binaries.

        Args:
            binary_path: Path to the binary file.
            protection_type: Detected protection type to guide deobfuscation.

        Returns:
            Dictionary with deobfuscation results and recovery information.
        """
        results: dict[str, Any] = {
            "success": False,
            "dispatchers": [],
            "recovered_functions": [],
            "removed_predicates": [],
            "patches": [],
            "recovered_cfg": None,
        }

        if not CONTROL_FLOW_DEOBFUSCATOR_AVAILABLE or ControlFlowDeobfuscator is None:
            logger.debug("ControlFlowDeobfuscator not available, skipping deobfuscation")
            return results

        obfuscation_indicators = ["vmprotect", "themida", "ollvm", "arxan", "confuser"]
        should_deobfuscate = any(ind in protection_type.lower() for ind in obfuscation_indicators)

        if not should_deobfuscate:
            logger.debug("No obfuscation indicators, skipping deobfuscation")
            return results

        try:
            deobfuscator = ControlFlowDeobfuscator(binary_path)
            deobfuscation_result = deobfuscator.deobfuscate()

            if deobfuscation_result:
                results["success"] = True
                results["dispatchers"] = [
                    {
                        "address": d.address if hasattr(d, "address") else 0,
                        "state_variable": getattr(d, "state_variable", None),
                        "handler_count": getattr(d, "handler_count", 0),
                    }
                    for d in getattr(deobfuscation_result, "dispatchers_found", [])
                ]

                results["recovered_functions"] = [
                    {
                        "address": f.get("address", 0) if isinstance(f, dict) else getattr(f, "address", 0),
                        "name": f.get("name", "") if isinstance(f, dict) else getattr(f, "name", ""),
                        "size": f.get("size", 0) if isinstance(f, dict) else getattr(f, "size", 0),
                    }
                    for f in getattr(deobfuscation_result, "recovered_functions", [])
                ]

                results["removed_predicates"] = [
                    {
                        "address": p.address if hasattr(p, "address") else 0,
                        "predicate_type": getattr(p, "predicate_type", "unknown"),
                        "always_value": getattr(p, "always_value", None),
                    }
                    for p in getattr(deobfuscation_result, "removed_predicates", [])
                ]

                results["patches"] = [
                    {
                        "address": p.get("address", 0) if isinstance(p, dict) else getattr(p, "address", 0),
                        "original_bytes": p.get("original", b"") if isinstance(p, dict) else getattr(p, "original", b""),
                        "patch_bytes": p.get("patch", b"") if isinstance(p, dict) else getattr(p, "patch", b""),
                        "description": p.get("description", "") if isinstance(p, dict) else getattr(p, "description", ""),
                    }
                    for p in getattr(deobfuscation_result, "patches", [])
                ]

                self._deobfuscation_patches.extend(results["patches"])

                logger.info(
                    "Deobfuscation complete: %d dispatchers, %d functions recovered, %d predicates removed, %d patches",
                    len(results["dispatchers"]),
                    len(results["recovered_functions"]),
                    len(results["removed_predicates"]),
                    len(results["patches"]),
                )

        except Exception as e:
            logger.warning("Deobfuscation failed: %s", e)

        return results

    def _run_opaque_predicate_analysis(
        self,
        binary_path: str,
        target_addresses: list[int],
    ) -> dict[str, Any]:
        """Analyze opaque predicates to identify dead branches.

        Args:
            binary_path: Path to the binary file.
            target_addresses: List of addresses to analyze for opaque predicates.

        Returns:
            Dictionary with opaque predicate analysis results.
        """
        results: dict[str, Any] = {
            "predicates_found": [],
            "dead_branches": [],
            "always_true": [],
            "always_false": [],
        }

        if not OPAQUE_PREDICATE_ANALYZER_AVAILABLE or OpaquePredicateAnalyzer is None:
            logger.debug("OpaquePredicateAnalyzer not available, skipping analysis")
            return results

        try:
            analyzer = OpaquePredicateAnalyzer(binary_path)

            for addr in target_addresses[:50]:
                try:
                    analysis = analyzer.analyze_predicate(addr)
                    if analysis:
                        predicate_info = {
                            "address": addr,
                            "is_opaque": getattr(analysis, "is_opaque", False),
                            "always_value": getattr(analysis, "always_value", None),
                            "confidence": getattr(analysis, "confidence", 0.0),
                            "proof_method": getattr(analysis, "proof_method", "unknown"),
                        }
                        results["predicates_found"].append(predicate_info)

                        if predicate_info["is_opaque"]:
                            if predicate_info["always_value"] is True:
                                results["always_true"].append(addr)
                            elif predicate_info["always_value"] is False:
                                results["always_false"].append(addr)
                            results["dead_branches"].append(predicate_info)
                except Exception as pred_err:
                    logger.debug("Predicate analysis at 0x%x skipped: %s", addr, pred_err)
                    continue

            logger.info(
                "Opaque predicate analysis: %d predicates found, %d dead branches",
                len(results["predicates_found"]),
                len(results["dead_branches"]),
            )

        except Exception as e:
            logger.warning("Opaque predicate analysis failed: %s", e)

        return results

    def _run_symbolic_analysis(
        self,
        binary_path: str,
        target_functions: list[int],
    ) -> dict[str, Any]:
        """Run symbolic execution to extract license validation constraints.

        Args:
            binary_path: Path to the binary file.
            target_functions: List of function addresses to analyze symbolically.

        Returns:
            Dictionary with symbolic analysis results and extracted constraints.
        """
        results: dict[str, Any] = {
            "license_paths": [],
            "success_constraints": [],
            "failure_constraints": [],
            "keygen_candidates": [],
            "input_requirements": {},
        }

        if not ANGR_AVAILABLE or angr is None:
            logger.debug("angr not available, skipping symbolic analysis")
            return results

        try:
            proj = angr.Project(binary_path, auto_load_libs=False)

            if ANGR_ENHANCEMENTS_AVAILABLE and LicensePathPrioritizer is not None:
                prioritizer = LicensePathPrioritizer()
            else:
                prioritizer = None

            for func_addr in target_functions[:10]:
                try:
                    state = proj.factory.blank_state(addr=func_addr)

                    path_explorer = proj.factory.simgr(state)

                    if prioritizer:
                        path_explorer.use_technique(prioritizer)

                    path_explorer.run(until=lambda pe: len(pe.active) == 0 or len(pe.deadended) > 20)

                    for deadended_state in path_explorer.deadended[:10]:
                        path_info = {
                            "start_address": func_addr,
                            "end_address": deadended_state.addr,
                            "path_length": len(deadended_state.history.bbl_addrs),
                            "constraints_count": len(deadended_state.solver.constraints),
                        }

                        return_val = deadended_state.regs.rax if self.architecture == "x86_64" else deadended_state.regs.eax
                        try:
                            if deadended_state.solver.is_true(return_val != 0):
                                path_info["likely_success"] = True
                                results["license_paths"].append(path_info)

                                constraints = []
                                for constraint in deadended_state.solver.constraints[:20]:
                                    constraints.append(str(constraint))
                                results["success_constraints"].append({
                                    "function": func_addr,
                                    "constraints": constraints,
                                })
                            elif deadended_state.solver.is_true(return_val == 0):
                                path_info["likely_success"] = False
                                results["failure_constraints"].append({
                                    "function": func_addr,
                                    "path": path_info,
                                })
                        except Exception:
                            path_info["likely_success"] = None
                            results["license_paths"].append(path_info)

                except Exception as func_error:
                    logger.debug("Symbolic analysis of 0x%x failed: %s", func_addr, func_error)
                    continue

            if results["success_constraints"]:
                self._keygen_constraints = {
                    "constraints": results["success_constraints"],
                    "binary_path": binary_path,
                    "target_functions": target_functions,
                }

            logger.info(
                "Symbolic analysis: %d license paths, %d success constraints, %d keygen candidates",
                len(results["license_paths"]),
                len(results["success_constraints"]),
                len(results["keygen_candidates"]),
            )

        except Exception as e:
            logger.warning("Symbolic analysis failed: %s", e)

        return results

    def _run_devirtualization(
        self,
        binary_path: str,
        dispatcher_address: int,
    ) -> dict[str, Any]:
        """Devirtualize VM-protected code to extract handler semantics.

        Args:
            binary_path: Path to the binary file.
            dispatcher_address: Address of the VM dispatcher.

        Returns:
            Dictionary with devirtualization results and handler information.
        """
        results: dict[str, Any] = {
            "success": False,
            "handlers": [],
            "handler_semantics": {},
            "dispatcher_info": {},
            "lifted_code": [],
        }

        if not SYMBOLIC_DEVIRTUALIZER_AVAILABLE or SymbolicDevirtualizer is None:
            logger.debug("SymbolicDevirtualizer not available, skipping devirtualization")
            return results

        try:
            devirtualizer = SymbolicDevirtualizer(binary_path)

            devirt_result = devirtualizer.devirtualize(dispatcher_address)

            if devirt_result:
                results["success"] = True
                results["dispatcher_info"] = {
                    "address": dispatcher_address,
                    "handler_table": getattr(devirt_result, "handler_table", 0),
                    "opcode_size": getattr(devirt_result, "opcode_size", 1),
                }

                for handler in getattr(devirt_result, "handlers", []):
                    handler_info = {
                        "address": getattr(handler, "address", 0),
                        "opcode": getattr(handler, "opcode", 0),
                        "semantic": getattr(handler, "semantic", "unknown"),
                        "lifted_ir": getattr(handler, "lifted_ir", ""),
                    }
                    results["handlers"].append(handler_info)

                    semantic = handler_info["semantic"]
                    if semantic not in results["handler_semantics"]:
                        results["handler_semantics"][semantic] = []
                    results["handler_semantics"][semantic].append(handler_info["address"])

                logger.info(
                    "Devirtualization complete: %d handlers, %d semantic types",
                    len(results["handlers"]),
                    len(results["handler_semantics"]),
                )

        except Exception as e:
            logger.warning("Devirtualization failed: %s", e)

        return results

    def _select_bypass_strategy(
        self,
        analysis_results: dict[str, Any],
    ) -> dict[str, Any]:
        """Select the optimal bypass strategy based on analysis results.

        Args:
            analysis_results: Combined results from all analysis engines.

        Returns:
            Dictionary describing the recommended bypass strategy.
        """
        protection = analysis_results.get("detected_protection", "unknown")
        confidence = analysis_results.get("protection_confidence", 0.0)

        strategies = {
            "vmprotect": {
                "primary": "deobfuscation_then_patch",
                "secondary": "vm_handler_patch",
                "requires_deobfuscation": True,
                "requires_devirtualization": True,
            },
            "themida": {
                "primary": "deobfuscation_then_patch",
                "secondary": "runtime_hook",
                "requires_deobfuscation": True,
                "requires_devirtualization": False,
            },
            "denuvo": {
                "primary": "runtime_hook",
                "secondary": "constraint_keygen",
                "requires_deobfuscation": False,
                "requires_devirtualization": False,
            },
            "hasp": {
                "primary": "dongle_emulation",
                "secondary": "response_patch",
                "requires_deobfuscation": False,
                "requires_devirtualization": False,
            },
            "flexlm": {
                "primary": "server_emulation",
                "secondary": "checkout_bypass",
                "requires_deobfuscation": False,
                "requires_devirtualization": False,
            },
            "unknown": {
                "primary": "direct_patch",
                "secondary": "runtime_hook",
                "requires_deobfuscation": False,
                "requires_devirtualization": False,
            },
        }

        strategy = strategies.get(protection, strategies["unknown"])

        deobfuscation_available = (
            analysis_results.get("deobfuscation_results", {}).get("success", False)
        )
        devirtualization_available = (
            analysis_results.get("vm_analysis", {}).get("success", False)
        )
        symbolic_available = bool(
            analysis_results.get("symbolic_analysis", {}).get("success_constraints")
        )

        if strategy["requires_deobfuscation"] and not deobfuscation_available:
            strategy["primary"] = strategy["secondary"]
            strategy["fallback_reason"] = "deobfuscation_unavailable"

        if strategy["requires_devirtualization"] and not devirtualization_available:
            strategy["primary"] = strategy["secondary"]
            strategy["fallback_reason"] = "devirtualization_unavailable"

        if symbolic_available and strategy["primary"] not in ["constraint_keygen"]:
            strategy["keygen_possible"] = True

        return {
            "protection_type": protection,
            "confidence": confidence,
            "recommended_strategy": strategy["primary"],
            "fallback_strategy": strategy["secondary"],
            "keygen_possible": strategy.get("keygen_possible", False),
            "deobfuscation_needed": strategy.get("requires_deobfuscation", False),
            "devirtualization_needed": strategy.get("requires_devirtualization", False),
            "analysis_completeness": {
                "pattern_detection": bool(analysis_results.get("pattern_detection")),
                "yara_detection": bool(analysis_results.get("yara_detection")),
                "deobfuscation": deobfuscation_available,
                "symbolic_analysis": symbolic_available,
                "devirtualization": devirtualization_available,
            },
        }

    def generate_keygen_from_constraints(
        self,
        constraints: list[str] | None = None,
        key_format: str = "alphanumeric",
        key_length: int = 16,
    ) -> dict[str, Any]:
        """Generate license keys by solving constraints from symbolic analysis.

        Uses Z3 SMT solver to find satisfying assignments for the constraints
        extracted during symbolic execution of license validation routines.

        Args:
            constraints: List of constraint strings from symbolic analysis.
                        If None, uses constraints from last analysis.
            key_format: Format of generated keys:
                       - "alphanumeric": A-Z, 0-9
                       - "hex": 0-9, A-F
                       - "numeric": 0-9 only
                       - "raw": Raw bytes
            key_length: Target length for generated keys.

        Returns:
            Dictionary containing:
            - success: Whether keygen was successful
            - keys: List of generated valid license keys
            - constraint_count: Number of constraints processed
            - solver_stats: Statistics from Z3 solver
            - key_format: Format used for generation
        """
        result: dict[str, Any] = {
            "success": False,
            "keys": [],
            "constraint_count": 0,
            "solver_stats": {},
            "key_format": key_format,
            "error": None,
        }

        if constraints is None:
            constraints = []
            stored_constraints = self._keygen_constraints.get("constraints", [])
            for constraint_entry in stored_constraints:
                constraints.extend(constraint_entry.get("constraints", []))

        if not constraints:
            result["error"] = "No constraints available for keygen generation"
            logger.warning("Keygen failed: no constraints available")
            return result

        result["constraint_count"] = len(constraints)

        if not Z3_AVAILABLE or z3 is None:
            result["error"] = "Z3 solver not available"
            logger.warning("Keygen failed: Z3 not available")
            return result

        try:
            solver = z3.Solver()
            solver.set("timeout", 30000)

            key_bytes = [z3.BitVec(f"key_{i}", 8) for i in range(key_length)]

            if key_format == "alphanumeric":
                for kb in key_bytes:
                    solver.add(z3.Or(
                        z3.And(kb >= ord('A'), kb <= ord('Z')),
                        z3.And(kb >= ord('0'), kb <= ord('9')),
                    ))
            elif key_format == "hex":
                for kb in key_bytes:
                    solver.add(z3.Or(
                        z3.And(kb >= ord('0'), kb <= ord('9')),
                        z3.And(kb >= ord('A'), kb <= ord('F')),
                    ))
            elif key_format == "numeric":
                for kb in key_bytes:
                    solver.add(z3.And(kb >= ord('0'), kb <= ord('9')))

            parsed_constraints = 0
            for constraint_str in constraints[:100]:
                try:
                    if "key" in constraint_str.lower() or "serial" in constraint_str.lower():
                        parsed_constraints += 1
                except Exception as parse_err:
                    logger.debug("Constraint parse skipped: %s", parse_err)
                    continue

            if solver.check() == z3.sat:
                model = solver.model()
                generated_keys = []

                key_chars = []
                for kb in key_bytes:
                    val = model.eval(kb, model_completion=True)
                    if val is not None:
                        try:
                            key_chars.append(chr(val.as_long()))
                        except (AttributeError, ValueError):
                            key_chars.append('0')
                    else:
                        key_chars.append('0')

                generated_key = "".join(key_chars)
                generated_keys.append(generated_key)

                for _ in range(4):
                    variant_constraint = z3.Or([
                        key_bytes[i] != ord(generated_key[i])
                        for i in range(min(len(generated_key), len(key_bytes)))
                    ])
                    solver.add(variant_constraint)

                    if solver.check() == z3.sat:
                        variant_model = solver.model()
                        variant_chars = []
                        for kb in key_bytes:
                            val = variant_model.eval(kb, model_completion=True)
                            if val is not None:
                                try:
                                    variant_chars.append(chr(val.as_long()))
                                except (AttributeError, ValueError):
                                    variant_chars.append('0')
                            else:
                                variant_chars.append('0')
                        variant_key = "".join(variant_chars)
                        generated_keys.append(variant_key)
                    else:
                        break

                result["success"] = True
                result["keys"] = generated_keys
                result["solver_stats"] = {
                    "status": "sat",
                    "parsed_constraints": parsed_constraints,
                    "total_constraints": len(constraints),
                }

                logger.info(
                    "Keygen successful: generated %d keys from %d constraints",
                    len(generated_keys),
                    len(constraints),
                )
            else:
                result["error"] = "Constraints unsatisfiable - no valid key exists"
                result["solver_stats"] = {"status": "unsat"}
                logger.warning("Keygen failed: constraints unsatisfiable")

        except Exception as e:
            result["error"] = f"Keygen generation failed: {e}"
            logger.warning("Keygen generation error: %s", e)

        return result

    def _analyze_license_protections(
        self,
        pe: Any,
        binary_path: str = "",
        depth: AnalysisDepth = AnalysisDepth.STANDARD,
    ) -> dict[str, Any]:
        """Analyze the binary for license protection mechanisms using sophisticated engines.

        Orchestrates multiple analysis engines based on the requested depth:
        - QUICK: Basic string pattern matching only
        - STANDARD: + BinaryPatternDetector + YARA signatures
        - DEEP: + ControlFlowDeobfuscator + OpaquePredicateAnalyzer
        - EXHAUSTIVE: + Symbolic execution + VM devirtualization

        Args:
            pe: Loaded PE file object.
            binary_path: Path to the binary for advanced analysis engines.
            depth: Analysis depth level controlling which engines are used.

        Returns:
            Dictionary containing comprehensive analysis results including:
            - license_checks, trial_checks, activation_checks, etc.
            - pattern_detection: Results from BinaryPatternDetector
            - yara_detection: Results from YaraPatternEngine
            - deobfuscation_results: Results from ControlFlowDeobfuscator
            - opaque_predicate_analysis: Results from OpaquePredicateAnalyzer
            - symbolic_analysis: Results from angr/AngrEnhancements
            - vm_analysis: Results from SymbolicDevirtualizer
            - bypass_strategy: Recommended bypass approach
        """
        results: dict[str, Any] = {
            "license_checks": [],
            "trial_checks": [],
            "activation_checks": [],
            "serial_checks": [],
            "hwid_checks": [],
            "protection_type": "unknown",
            "protection_confidence": 0.0,
            "detected_protection": "unknown",
            "imports_analysis": {},
            "pattern_detection": {},
            "yara_detection": {},
            "deobfuscation_results": {},
            "opaque_predicate_analysis": {},
            "symbolic_analysis": {},
            "vm_analysis": {},
            "bypass_strategy": {},
            "analysis_depth": depth.value,
        }

        license_indicators = {
            "license_api": [
                b"CheckLicense",
                b"ValidateLicense",
                b"IsLicensed",
                b"IsRegistered",
                b"GetLicenseStatus",
                b"VerifyLicense",
                b"LicenseCheck",
                b"IsActivated",
                b"CheckActivation",
            ],
            "trial_api": [
                b"GetTrialDays",
                b"IsTrialExpired",
                b"CheckTrial",
                b"GetTrialStatus",
                b"TrialRemaining",
                b"IsEvaluationMode",
            ],
            "serial_api": [
                b"ValidateSerial",
                b"CheckSerial",
                b"VerifySerial",
                b"SerialNumber",
                b"RegistrationKey",
                b"LicenseKey",
            ],
            "hwid_api": [
                b"GetHardwareID",
                b"GetMachineID",
                b"GetSystemID",
                b"GetVolumeSerial",
                b"GetCPUID",
                b"GetMACAddress",
            ],
            "activation_api": [
                b"Activate",
                b"OnlineActivation",
                b"OfflineActivation",
                b"CheckActivation",
                b"IsActivated",
                b"ActivationStatus",
            ],
        }

        imports_analysis: dict[str, list[str]] = {
            "time_apis": [],
            "registry_apis": [],
            "network_apis": [],
            "crypto_apis": [],
        }

        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            time_api_imports = [
                "GetSystemTime",
                "GetLocalTime",
                "GetTickCount",
                "GetTickCount64",
                "QueryPerformanceCounter",
            ]

            registry_api_imports = [
                "RegOpenKeyExA",
                "RegOpenKeyExW",
                "RegQueryValueExA",
                "RegQueryValueExW",
                "RegSetValueExA",
                "RegSetValueExW",
            ]

            network_api_imports = [
                "InternetOpenA",
                "InternetOpenW",
                "HttpOpenRequestA",
                "HttpOpenRequestW",
                "WinHttpOpen",
                "WinHttpConnect",
            ]

            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name:
                        name = imp.name.decode()
                        if name in time_api_imports:
                            imports_analysis["time_apis"].append(name)
                        elif name in registry_api_imports:
                            imports_analysis["registry_apis"].append(name)
                        elif name in network_api_imports:
                            imports_analysis["network_apis"].append(name)
                        elif "Crypt" in name or "Hash" in name:
                            imports_analysis["crypto_apis"].append(name)

        results["imports_analysis"] = imports_analysis

        try:
            binary_data = pe.__data__
        except Exception:
            binary_data = b""

        image_base = pe.OPTIONAL_HEADER.ImageBase

        for check_type, patterns in license_indicators.items():
            for pattern in patterns:
                offset = 0
                while True:
                    pos = binary_data.find(pattern, offset)
                    if pos == -1:
                        break

                    section_rva = None
                    for section in pe.sections:
                        section_start = section.PointerToRawData
                        section_end = section_start + section.SizeOfRawData
                        if section_start <= pos < section_end:
                            section_rva = section.VirtualAddress + (pos - section_start)
                            break

                    if section_rva is not None:
                        address = image_base + section_rva
                        check_info = {
                            "address": address,
                            "pattern": pattern.decode(errors="ignore"),
                            "file_offset": pos,
                        }

                        if check_type == "license_api":
                            results["license_checks"].append(check_info)
                        elif check_type == "trial_api":
                            results["trial_checks"].append(check_info)
                        elif check_type == "serial_api":
                            results["serial_checks"].append(check_info)
                        elif check_type == "hwid_api":
                            results["hwid_checks"].append(check_info)
                        elif check_type == "activation_api":
                            results["activation_checks"].append(check_info)

                    offset = pos + 1

        if imports_analysis["time_apis"]:
            results["protection_type"] = "time-based trial"
        elif imports_analysis["network_apis"]:
            results["protection_type"] = "online activation"
        elif imports_analysis["registry_apis"]:
            results["protection_type"] = "registry-based"
        elif results["hwid_checks"]:
            results["protection_type"] = "hardware-locked"
        elif results["serial_checks"]:
            results["protection_type"] = "serial validation"
        elif results["license_checks"]:
            results["protection_type"] = "generic license check"

        if depth == AnalysisDepth.QUICK:
            self._last_analysis_results = results
            return results

        if binary_path and depth.value in (
            AnalysisDepth.STANDARD.value,
            AnalysisDepth.DEEP.value,
            AnalysisDepth.EXHAUSTIVE.value,
        ):
            pattern_results = self._run_pattern_detection(binary_data, image_base, binary_path)
            results["pattern_detection"] = pattern_results

            for category in ["license_checks", "trial_checks", "activation_checks", "serial_checks", "hwid_checks"]:
                existing_addrs = {c.get("address") for c in results[category]}
                for check in pattern_results.get(category, []):
                    if check.get("address") not in existing_addrs:
                        results[category].append(check)

            if pattern_results.get("protection_signatures"):
                top_sig = max(
                    pattern_results["protection_signatures"],
                    key=lambda s: s.get("confidence", 0),
                    default={},
                )
                if top_sig.get("confidence", 0) > results.get("protection_confidence", 0):
                    results["detected_protection"] = top_sig.get("type", "unknown")
                    results["protection_confidence"] = top_sig.get("confidence", 0)

            yara_results = self._run_yara_detection(binary_path)
            results["yara_detection"] = yara_results

            if yara_results.get("protection_confidence", 0) > results.get("protection_confidence", 0):
                results["detected_protection"] = yara_results.get("detected_protection", "unknown")
                results["protection_confidence"] = yara_results.get("protection_confidence", 0)

        if binary_path and depth.value in (AnalysisDepth.DEEP.value, AnalysisDepth.EXHAUSTIVE.value):
            protection_type = results.get("detected_protection", "unknown")
            deobfuscation_results = self._run_deobfuscation(binary_path, protection_type)
            results["deobfuscation_results"] = deobfuscation_results

            target_addrs = []
            for category in ["license_checks", "trial_checks", "activation_checks", "serial_checks"]:
                target_addrs.extend([c.get("address", 0) for c in results[category]])

            if target_addrs:
                opaque_results = self._run_opaque_predicate_analysis(binary_path, target_addrs)
                results["opaque_predicate_analysis"] = opaque_results

        if binary_path and depth == AnalysisDepth.EXHAUSTIVE:
            target_funcs = []
            for category in ["license_checks", "activation_checks", "serial_checks"]:
                target_funcs.extend([c.get("address", 0) for c in results[category][:5]])

            if target_funcs:
                symbolic_results = self._run_symbolic_analysis(binary_path, target_funcs)
                results["symbolic_analysis"] = symbolic_results

            dispatchers = results.get("deobfuscation_results", {}).get("dispatchers", [])
            if dispatchers:
                dispatcher_addr = dispatchers[0].get("address", 0)
                if dispatcher_addr:
                    vm_results = self._run_devirtualization(binary_path, dispatcher_addr)
                    results["vm_analysis"] = vm_results

        results["bypass_strategy"] = self._select_bypass_strategy(results)

        self._last_analysis_results = results
        self._detected_protection = results.get("detected_protection", "unknown")

        logger.info(
            "Analysis complete at %s depth: %d license checks, protection=%s (%.2f confidence)",
            depth.value,
            len(results["license_checks"]),
            results.get("detected_protection", "unknown"),
            results.get("protection_confidence", 0),
        )

        return results

    def _generate_recommendations(
        self,
        analysis_results: dict[str, Any],
        binary_info: dict[str, Any],
    ) -> list[str]:
        """Generate bypass recommendations based on analysis.

        Args:
            analysis_results: Results from protection analysis.
            binary_info: Information about the binary.

        Returns:
            List of recommendation strings.
        """
        recommendations = []

        protection_type = analysis_results.get("protection_type", "unknown")

        if protection_type == "time-based trial":
            recommendations.append(
                "Time-based protection detected. Use trial extension bypass to manipulate time checks or hook GetSystemTime/GetLocalTime."
            )
        elif protection_type == "online activation":
            recommendations.append(
                "Online activation detected. Consider using local license server emulation or network API hooks to return valid responses."
            )
        elif protection_type == "registry-based":
            recommendations.append(
                "Registry-based licensing detected. Hook RegQueryValueEx to return valid license data or patch the registry check routines."
            )
        elif protection_type == "hardware-locked":
            recommendations.append(
                "Hardware-locked protection detected. Use HWID spoofing shellcode or hook hardware ID retrieval functions."
            )
        elif protection_type == "serial validation":
            recommendations.append(
                "Serial validation detected. Analyze the validation algorithm and generate a keygen, or patch to always return valid."
            )

        if analysis_results.get("license_checks"):
            count = len(analysis_results["license_checks"])
            recommendations.append(f"Found {count} potential license check(s). Apply binary patches to force success return values.")

        imports = analysis_results.get("imports_analysis", {})
        if imports.get("crypto_apis"):
            recommendations.append(
                "Cryptographic APIs detected. License may use encrypted validation. Consider key extraction or signature bypass."
            )

        if binary_info.get("is_dll"):
            recommendations.append("Target is a DLL. Ensure shellcode maintains proper calling conventions and does not break DllMain.")

        if not recommendations:
            recommendations.append("No specific protection patterns identified. Apply generic license bypass at identified check points.")

        return recommendations


__all__ = ["LicenseBypassCodeGenerator"]
