"""License Bypass Code Generator for Intellicrack.

This module generates production-ready assembly code and binary patches for bypassing
software licensing protections, activation checks, trial limitations, and registration
validation with proper calling conventions, stack management, and position-independent code.

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack. If not, see <https://www.gnu.org/licenses/>.
"""

import logging
import struct
from typing import Any


logger = logging.getLogger(__name__)


class LicenseBypassCodeGenerator:
    """Production-grade license bypass code generator with proper calling conventions.

    Generates architecture-specific assembly code sequences and binary patches for
    defeating software licensing mechanisms with proper stack frames, calling
    conventions, and position-independent code generation.
    """

    def __init__(self, architecture: str = "x86_64", platform: str = "windows") -> None:
        """Initialize the license bypass code generator.

        Args:
            architecture: Target architecture ("x86", "x86_64", "arm", "arm64")
            platform: Target platform ("windows", "linux", "macos")
        """
        self.architecture = architecture
        self.platform = platform
        self.generated_patches: list[dict[str, Any]] = []
        self._init_calling_conventions()
        logger.info(f"LicenseBypassCodeGenerator initialized for {architecture}/{platform}")

    def _init_calling_conventions(self) -> None:
        """Initialize calling convention specifications for each platform."""
        self.calling_conventions = {
            "x86_64": {
                "windows": {
                    "int_params": ["rcx", "rdx", "r8", "r9"],
                    "shadow_space": 32,
                    "stack_align": 16,
                    "volatile_regs": ["rax", "rcx", "rdx", "r8", "r9", "r10", "r11"],
                    "nonvolatile_regs": ["rbx", "rbp", "rdi", "rsi", "r12", "r13", "r14", "r15"],
                },
                "linux": {
                    "int_params": ["rdi", "rsi", "rdx", "rcx", "r8", "r9"],
                    "shadow_space": 0,
                    "stack_align": 16,
                    "volatile_regs": ["rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"],
                    "nonvolatile_regs": ["rbx", "rbp", "r12", "r13", "r14", "r15"],
                },
            },
            "x86": {
                "windows": {
                    "calling": "cdecl",
                    "stack_align": 4,
                    "cleanup": "caller",
                },
                "linux": {
                    "calling": "cdecl",
                    "stack_align": 16,
                    "cleanup": "caller",
                },
            },
            "arm64": {
                "all": {
                    "int_params": ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"],
                    "stack_align": 16,
                },
            },
            "arm": {
                "all": {
                    "int_params": ["r0", "r1", "r2", "r3"],
                    "stack_align": 8,
                },
            },
        }

    def generate_license_check_bypass(self, function_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass license validation with proper calling convention.

        Creates assembly code that forces license check functions to always return
        success while preserving stack frames and following platform calling conventions.

        Args:
            function_address: Address of the license check function to patch
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that bypass the license check

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x40"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x31\xc0"
                code += b"\x40"
                code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "license_check_bypass",
                "address": function_address,
                "code": code,
                "size": len(code),
                "description": "Forces license check to return success (with calling convention)",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(
            f"Generated license check bypass for address 0x{function_address:x} ({len(code)} bytes, preserve_stack={preserve_stack})"
        )
        return code

    def generate_trial_extension_patch(self, time_check_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to extend or remove trial period limitations.

        Creates assembly patches that modify time-based trial checks to always
        return a valid trial state with proper stack management.

        Args:
            time_check_address: Address of the trial time check routine
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that bypasses trial limitations

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_trial_extension_patch(
            ...     0x402000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x90" * 5
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x90" * 5
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x90" * 10
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x90" * 5
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x31\xc0"
                code += b"\x90" * 8
                code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x00\x00\x80\xd2"
            code += b"\x1f\x20\x03\xd5" * 3
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x00\x00\xa0\xe3"
            code += b"\x00\xf0\x20\xe3" * 3
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "trial_extension",
                "address": time_check_address,
                "code": code,
                "size": len(code),
                "description": "Bypasses trial period limitation (with calling convention)",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(f"Generated trial extension patch for address 0x{time_check_address:x} ({len(code)} bytes)")
        return code

    def generate_activation_bypass(self, activation_check_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass product activation with calling convention.

        Creates assembly code that makes activation check functions always return
        an activated state while preserving calling conventions.

        Args:
            activation_check_address: Address of activation check function
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that bypasses activation checks

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_activation_bypass(
            ...     0x403000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xc7\xc0\x01\x00\x00\x00"
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xc7\xc0\x01\x00\x00\x00"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\xc7\xc0\x01\x00\x00\x00"
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8\x01\x00\x00\x00"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\xb8\x01\x00\x00\x00"
                code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "activation_bypass",
                "address": activation_check_address,
                "code": code,
                "size": len(code),
                "description": "Forces activation check to return activated",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(f"Generated activation bypass for address 0x{activation_check_address:x} ({len(code)} bytes)")
        return code

    def generate_serial_validation_bypass(self, validation_address: int, preserve_stack: bool = True) -> bytes:
        """Generate code to bypass serial number validation.

        Creates assembly code that forces serial number validation routines to
        always accept any input as valid with proper calling conventions.

        Args:
            validation_address: Address of serial validation function
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that bypasses serial validation

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_serial_validation_bypass(
            ...     0x404000
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\x31\xc0"
                code += b"\x48\xff\xc0"
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\x31\xc0"
                code += b"\x40"
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x31\xc0"
                code += b"\x40"
                code += b"\xc3"
        elif self.architecture == "arm64":
            code = b"\x20\x00\x80\xd2"
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = b"\x01\x00\xa0\xe3"
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "serial_validation_bypass",
                "address": validation_address,
                "code": code,
                "size": len(code),
                "description": "Bypasses serial number validation",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(f"Generated serial validation bypass for address 0x{validation_address:x} ({len(code)} bytes)")
        return code

    def generate_hardware_id_spoof(self, hwid_check_address: int, spoofed_hwid: bytes, preserve_stack: bool = True) -> bytes:
        """Generate code to spoof hardware ID checks.

        Creates assembly code that replaces actual hardware ID with a substitute
        value, bypassing hardware-locked licensing schemes.

        Args:
            hwid_check_address: Address of hardware ID check routine
            spoofed_hwid: Substitute hardware ID bytes to return
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that spoofs hardware ID

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_hardware_id_spoof(
            ...     0x405000,
            ...     b"SPOOF-HWID-5678",
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\xb8" + spoofed_hwid[:8].ljust(8, b"\x00")
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8" + spoofed_hwid[:4].ljust(4, b"\x00")
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\xb8" + spoofed_hwid[:4].ljust(4, b"\x00")
                code += b"\xc3"
        elif self.architecture == "arm64":
            hwid_val = int.from_bytes(spoofed_hwid[:8].ljust(8, b"\x00"), "little")
            code = struct.pack("<I", 0xD2800000 | ((hwid_val & 0xFFFF) << 5))
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            hwid_val = int.from_bytes(spoofed_hwid[:4].ljust(4, b"\x00"), "little")
            code = struct.pack("<I", 0xE3A00000 | (hwid_val & 0xFF))
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "hardware_id_spoof",
                "address": hwid_check_address,
                "code": code,
                "size": len(code),
                "description": f"Spoofs hardware ID with {spoofed_hwid[:8].hex()}",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(f"Generated hardware ID spoof for address 0x{hwid_check_address:x} ({len(code)} bytes)")
        return code

    def generate_nop_patch(self, address: int, size: int) -> bytes:
        """Generate NOP sled to neutralize protection code.

        Creates a sequence of NOP instructions to overwrite protection routines,
        effectively disabling license checks or anti-tamper code.

        Args:
            address: Address to patch with NOPs
            size: Number of bytes to NOP out

        Returns:
            Binary NOP bytes

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> nops = gen.generate_nop_patch(
            ...     0x406000, 16
            ... )
            >>> len(nops) == 16
            True
        """
        if self.architecture in ("x86_64", "x86"):
            code = b"\x90" * size
        elif self.architecture == "arm64":
            nop_instr = b"\x1f\x20\x03\xd5"
            code = nop_instr * (size // 4)
        elif self.architecture == "arm":
            nop_instr = b"\x00\xf0\x20\xe3"
            code = nop_instr * (size // 4)
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "nop_patch",
                "address": address,
                "code": code,
                "size": len(code),
                "description": f"NOPs out {size} bytes of protection code",
            }
        )

        logger.info(f"Generated NOP patch for address 0x{address:x} ({size} bytes)")
        return code

    def generate_conditional_jump_patch(self, jump_address: int, always_jump: bool = True) -> bytes:
        """Generate patch to modify conditional jumps in license checks.

        Creates code that converts conditional jumps to unconditional jumps or NOPs,
        forcing license check logic to always succeed or fail as needed.

        Args:
            jump_address: Address of conditional jump instruction
            always_jump: If True, always jump; if False, never jump

        Returns:
            Binary code bytes that modifies jump behavior

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_conditional_jump_patch(
            ...     0x407000, True
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture in ("x86_64", "x86"):
            if always_jump:
                code = b"\xeb"
            else:
                code = b"\x90\x90"
        elif self.architecture == "arm64":
            if always_jump:
                code = b"\x00\x00\x00\x14"
            else:
                code = b"\x1f\x20\x03\xd5"
        elif self.architecture == "arm":
            if always_jump:
                code = b"\x00\x00\x00\xea"
            else:
                code = b"\x00\xf0\x20\xe3"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "jump_patch",
                "address": jump_address,
                "code": code,
                "size": len(code),
                "description": f"Forces jump to {'always' if always_jump else 'never'} execute",
            }
        )

        logger.info(f"Generated jump patch for address 0x{jump_address:x} (always_jump={always_jump})")
        return code

    def generate_return_value_patch(self, function_address: int, return_value: int, preserve_stack: bool = True) -> bytes:
        """Generate patch to force specific return value.

        Creates code that makes a function immediately return a specific value,
        useful for bypassing license validation functions.

        Args:
            function_address: Address of function to patch
            return_value: Value to return
            preserve_stack: Whether to preserve stack frame (default: True)

        Returns:
            Binary code bytes that forces return value

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> patch = gen.generate_return_value_patch(
            ...     0x408000, 1
            ... )
            >>> len(patch) > 0
            True
        """
        if self.architecture == "x86_64":
            if preserve_stack and self.platform == "windows":
                code = b"\x48\x83\xec\x28"
                code += b"\x48\xc7\xc0" + struct.pack("<I", return_value)
                code += b"\x48\x83\xc4\x28"
                code += b"\xc3"
            elif preserve_stack and self.platform == "linux":
                code = b"\x55"
                code += b"\x48\x89\xe5"
                code += b"\x48\xc7\xc0" + struct.pack("<I", return_value)
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\x48\xc7\xc0" + struct.pack("<I", return_value)
                code += b"\xc3"
        elif self.architecture == "x86":
            if preserve_stack:
                code = b"\x55"
                code += b"\x89\xe5"
                code += b"\xb8" + struct.pack("<I", return_value)
                code += b"\x5d"
                code += b"\xc3"
            else:
                code = b"\xb8" + struct.pack("<I", return_value)
                code += b"\xc3"
        elif self.architecture == "arm64":
            code = struct.pack("<I", 0xD2800000 | ((return_value & 0xFFFF) << 5))
            code += b"\xc0\x03\x5f\xd6"
        elif self.architecture == "arm":
            code = struct.pack("<I", 0xE3A00000 | (return_value & 0xFF))
            code += b"\x1e\xff\x2f\xe1"
        else:
            raise ValueError(f"Unsupported architecture: {self.architecture}")

        self.generated_patches.append(
            {
                "type": "return_value_patch",
                "address": function_address,
                "code": code,
                "size": len(code),
                "description": f"Forces return value to {return_value}",
                "preserve_stack": preserve_stack,
            }
        )

        logger.info(f"Generated return value patch for address 0x{function_address:x} (value={return_value})")
        return code

    def get_generated_patches(self) -> list[dict[str, Any]]:
        r"""Get all generated patches.

        Returns:
            List of patch dictionaries containing type, address, code, size,
            and description for each generated patch

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> patches = gen.get_generated_patches()
            >>> len(patches) > 0
            True
        """
        return self.generated_patches.copy()

    def clear_patches(self) -> None:
        r"""Clear all generated patches from history.

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> gen.clear_patches()
            >>> len(
            ...     gen.get_generated_patches()
            ... )
            0
        """
        self.generated_patches.clear()
        logger.info("Cleared all generated patches")

    def export_patches(self, format_type: str = "binary") -> dict[str, Any]:
        r"""Export patches in specified format.

        Args:
            format_type: Export format ("binary", "hex", "asm")

        Returns:
            Dictionary containing patches in requested format

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> gen.generate_license_check_bypass(
            ...     0x401000
            ... )
            b'H\\x83\\xec(H1\\xc0H\\xff\\xc0H\\x83\\xc4(\\xc3'
            >>> export = gen.export_patches(
            ...     "hex"
            ... )
            >>> "patches" in export
            True
        """
        exported = {
            "architecture": self.architecture,
            "platform": self.platform,
            "format": format_type,
            "patches": [],
        }

        for patch in self.generated_patches:
            patch_export = patch.copy()

            if format_type == "hex":
                patch_export["code"] = patch["code"].hex()
            elif format_type == "asm":
                patch_export["code"] = self._disassemble_code(patch["code"])

            exported["patches"].append(patch_export)

        return exported

    def _disassemble_code(self, code: bytes) -> str:
        """Disassemble code to assembly string (basic representation).

        Args:
            code: Binary code bytes to disassemble

        Returns:
            Assembly representation as string
        """
        if self.architecture in ("x86_64", "x86"):
            if code == b"\x90":
                return "nop"
            elif code[:3] == b"\x48\x31\xc0":
                return "xor rax, rax"
            elif code[:2] == b"\x31\xc0":
                return "xor eax, eax"
            elif code[-1:] == b"\xc3":
                return "ret"
            elif code[:2] == b"\x55":
                return "push rbp"
            elif code[:3] == b"\x48\x89\xe5":
                return "mov rbp, rsp"

        return f"<{code.hex()}>"

    def get_calling_convention_info(self) -> dict[str, Any]:
        """Get calling convention information for current platform/architecture.

        Returns:
            Dictionary containing calling convention details

        Example:
            >>> gen = LicenseBypassCodeGenerator(
            ...     "x86_64", "windows"
            ... )
            >>> info = gen.get_calling_convention_info()
            >>> "int_params" in info
            True
        """
        if self.architecture == "x86_64":
            return self.calling_conventions["x86_64"].get(self.platform, {})
        elif self.architecture == "x86":
            return self.calling_conventions["x86"].get(self.platform, {})
        elif self.architecture in ("arm64", "arm"):
            return self.calling_conventions[self.architecture]["all"]
        return {}


__all__ = ["LicenseBypassCodeGenerator"]
