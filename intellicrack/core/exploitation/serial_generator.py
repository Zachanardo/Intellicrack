"""Advanced Serial Number Generation Engine.

This module provides sophisticated algorithms for generating valid serial numbers
and license keys that work with modern protection schemes, including pattern
reconstruction, checksum calculation, and hardware binding.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import hashlib
import hmac
import struct
import base64
import time
import random
import string
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from typing import List, Dict, Any, Optional, Tuple, Union
from dataclasses import dataclass
from enum import Enum
import re
import logging

logger = logging.getLogger(__name__)


class SerialFormat(Enum):
    """Serial number encoding formats."""
    ALPHANUMERIC = "alphanumeric"
    HEXADECIMAL = "hexadecimal"
    BASE32 = "base32"
    BASE64 = "base64"
    NUMERIC = "numeric"
    CUSTOM = "custom"


class ChecksumType(Enum):
    """Checksum algorithms for validation."""
    LUHN = "luhn"
    CRC16 = "crc16"
    CRC32 = "crc32"
    SHA1 = "sha1"
    SHA256 = "sha256"
    CUSTOM = "custom"


@dataclass
class SerialPattern:
    """Analyzed serial number pattern."""
    format: SerialFormat
    segments: List[int]  # Segment lengths
    separator: str
    checksum_type: Optional[ChecksumType]
    checksum_position: int  # -1 for end, 0 for beginning
    encoding_base: int
    charset: str
    total_length: int


@dataclass
class GeneratedSerial:
    """Generated serial number with metadata."""
    serial: str
    raw_bytes: bytes
    checksum: Optional[str]
    hardware_id: Optional[str]
    expiration: Optional[int]
    features: List[str]
    algorithm: str
    confidence: float


class SerialNumberGenerator:
    """Advanced serial number generation engine."""

    def __init__(self):
        """Initialize the serial generator."""
        self.generated_serials: List[GeneratedSerial] = []

        # Standard charsets for different formats
        self.charsets = {
            SerialFormat.ALPHANUMERIC: string.ascii_uppercase + string.digits,
            SerialFormat.HEXADECIMAL: "0123456789ABCDEF",
            SerialFormat.BASE32: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
            SerialFormat.NUMERIC: "0123456789"
        }

        # CRC tables
        self.crc16_table = self._generate_crc16_table()
        self.crc32_table = self._generate_crc32_table()

        # Product codes database (common patterns)
        self.product_codes = self._build_product_codes()

    def _generate_crc16_table(self) -> List[int]:
        """Generate CRC16 lookup table."""
        table = []
        for i in range(256):
            crc = i << 8
            for _ in range(8):
                if crc & 0x8000:
                    crc = (crc << 1) ^ 0x1021
                else:
                    crc = crc << 1
            table.append(crc & 0xFFFF)
        return table

    def _generate_crc32_table(self) -> List[int]:
        """Generate CRC32 lookup table."""
        table = []
        for i in range(256):
            crc = i
            for _ in range(8):
                if crc & 1:
                    crc = (crc >> 1) ^ 0xEDB88320
                else:
                    crc = crc >> 1
            table.append(crc)
        return table

    def _build_product_codes(self) -> Dict[str, str]:
        """Build common product code patterns."""
        return {
            "windows": "55274-OEM-0011903-00102",
            "office": "H4GF2-2M9C7-RY3X4-8J6W9-VPQ7K",
            "adobe": "1234-5678-9012-3456-7890-1234",
            "autodesk": "666-69696969",
            "vmware": "JF6E2-2W3Q7-YU36R-4R6K8-9HT5F",
            "jetbrains": "A7B2-C9D4-E5F6-G8H1"
        }

    def analyze_serial_pattern(self, sample_serials: List[str]) -> SerialPattern:
        """Analyze serial numbers to extract pattern."""
        if not sample_serials:
            raise ValueError("No sample serials provided")

        # Analyze first serial for base pattern
        sample = sample_serials[0]

        # Detect separator
        separator = self._detect_separator(sample)

        # Split into segments
        if separator:
            segments = sample.split(separator)
            segment_lengths = [len(seg) for seg in segments]
        else:
            segment_lengths = [len(sample)]
            segments = [sample]

        # Detect charset and format
        charset = set()
        for serial in sample_serials:
            charset.update(serial.replace(separator, "") if separator else serial)

        charset_str = ''.join(sorted(charset))
        serial_format = self._detect_format(charset_str)

        # Detect checksum
        checksum_type, checksum_pos = self._detect_checksum(sample_serials)

        return SerialPattern(
            format=serial_format,
            segments=segment_lengths,
            separator=separator or "",
            checksum_type=checksum_type,
            checksum_position=checksum_pos,
            encoding_base=len(charset),
            charset=charset_str,
            total_length=len(sample)
        )

    def _detect_separator(self, serial: str) -> Optional[str]:
        """Detect separator character in serial."""
        common_separators = ['-', ' ', ':', '.', '_']
        for sep in common_separators:
            if sep in serial:
                return sep
        return None

    def _detect_format(self, charset: str) -> SerialFormat:
        """Detect serial number format from charset."""
        if set(charset) <= set("0123456789"):
            return SerialFormat.NUMERIC
        elif set(charset) <= set("0123456789ABCDEF"):
            return SerialFormat.HEXADECIMAL
        elif set(charset) <= set("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"):
            return SerialFormat.BASE32
        elif set(charset) <= set(string.ascii_uppercase + string.digits):
            return SerialFormat.ALPHANUMERIC
        else:
            return SerialFormat.CUSTOM

    def _detect_checksum(self, serials: List[str]) -> Tuple[Optional[ChecksumType], int]:
        """Detect checksum algorithm used in serials."""
        # Try Luhn algorithm
        if all(self._verify_luhn(s.replace('-', '').replace(' ', '')) for s in serials if s):
            return ChecksumType.LUHN, -1

        # Try CRC checks
        for serial in serials:
            clean_serial = serial.replace('-', '').replace(' ', '')
            if len(clean_serial) >= 4:
                # Check if last 4 chars could be CRC16
                try:
                    data = clean_serial[:-4].encode()
                    crc = int(clean_serial[-4:], 16)
                    if self._calculate_crc16(data) == crc:
                        return ChecksumType.CRC16, -1
                except:
                    pass

        return None, -1

    def _verify_luhn(self, number: str) -> bool:
        """Verify Luhn checksum."""
        if not number.isdigit():
            return False

        digits = [int(d) for d in number]
        checksum = digits[-1]
        digits = digits[:-1]

        # Double every second digit from right
        for i in range(len(digits) - 1, -1, -2):
            digits[i] *= 2
            if digits[i] > 9:
                digits[i] -= 9

        return (sum(digits) + checksum) % 10 == 0

    def _calculate_luhn(self, number: str) -> str:
        """Calculate Luhn checksum digit."""
        digits = [int(d) for d in number]

        # Double every second digit from right
        for i in range(len(digits) - 1, -1, -2):
            digits[i] *= 2
            if digits[i] > 9:
                digits[i] -= 9

        checksum = (10 - (sum(digits) % 10)) % 10
        return str(checksum)

    def _calculate_crc16(self, data: bytes) -> int:
        """Calculate CRC16 checksum."""
        crc = 0xFFFF
        for byte in data:
            tbl_idx = ((crc >> 8) ^ byte) & 0xFF
            crc = ((crc << 8) ^ self.crc16_table[tbl_idx]) & 0xFFFF
        return crc

    def _calculate_crc32(self, data: bytes) -> int:
        """Calculate CRC32 checksum."""
        crc = 0xFFFFFFFF
        for byte in data:
            tbl_idx = (crc ^ byte) & 0xFF
            crc = (crc >> 8) ^ self.crc32_table[tbl_idx]
        return crc ^ 0xFFFFFFFF

    def generate_from_pattern(self, pattern: SerialPattern,
                             hardware_id: Optional[str] = None,
                             features: Optional[List[str]] = None) -> GeneratedSerial:
        """Generate serial number from analyzed pattern."""
        segments = []

        for seg_len in pattern.segments:
            # Generate random segment
            segment = ''.join(random.choices(pattern.charset, k=seg_len))
            segments.append(segment)

        # Combine segments
        serial_base = pattern.separator.join(segments)

        # Apply checksum if detected
        if pattern.checksum_type:
            serial_base = self._apply_checksum(serial_base, pattern.checksum_type)

        # Apply hardware binding if requested
        if hardware_id:
            serial_base = self._bind_to_hardware(serial_base, hardware_id)

        return GeneratedSerial(
            serial=serial_base,
            raw_bytes=serial_base.encode(),
            checksum=pattern.checksum_type.value if pattern.checksum_type else None,
            hardware_id=hardware_id,
            expiration=None,
            features=features or [],
            algorithm="pattern_reconstruction",
            confidence=0.85
        )

    def _apply_checksum(self, serial: str, checksum_type: ChecksumType) -> str:
        """Apply checksum to serial number."""
        if checksum_type == ChecksumType.LUHN:
            # Remove non-digits for Luhn
            digits_only = ''.join(c for c in serial if c.isdigit())
            checksum = self._calculate_luhn(digits_only)
            # Replace last digit with checksum
            if serial[-1].isdigit():
                return serial[:-1] + checksum
            else:
                return serial + checksum

        elif checksum_type == ChecksumType.CRC16:
            crc = self._calculate_crc16(serial.encode())
            return serial + f"-{crc:04X}"

        elif checksum_type == ChecksumType.CRC32:
            crc = self._calculate_crc32(serial.encode())
            return serial + f"-{crc:08X}"

        return serial

    def _bind_to_hardware(self, serial: str, hardware_id: str) -> str:
        """Bind serial to hardware ID."""
        # Create HMAC of serial with hardware ID as key
        h = hmac.new(hardware_id.encode(), serial.encode(), hashlib.sha256)
        binding = h.hexdigest()[:8].upper()

        # Append binding code
        if '-' in serial:
            return f"{serial}-{binding}"
        else:
            return f"{serial}{binding}"

    def generate_rsa_signed(self, private_key: rsa.RSAPrivateKey,
                           product_id: str,
                           user_name: str,
                           features: Optional[List[str]] = None,
                           expiration: Optional[int] = None) -> GeneratedSerial:
        """Generate RSA-signed serial number."""
        # Create license data
        license_data = {
            "product_id": product_id,
            "user": user_name,
            "features": features or [],
            "issued": int(time.time()),
            "expiration": expiration or 0
        }

        # Serialize to bytes
        data_bytes = json.dumps(license_data, sort_keys=True).encode()

        # Sign with RSA
        signature = private_key.sign(
            data_bytes,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        # Encode serial
        serial_data = base64.b32encode(data_bytes + signature)
        serial = serial_data.decode('ascii').rstrip('=')

        # Format with dashes
        formatted = '-'.join(serial[i:i+5] for i in range(0, len(serial), 5))

        return GeneratedSerial(
            serial=formatted,
            raw_bytes=data_bytes + signature,
            checksum="RSA-PSS-SHA256",
            hardware_id=None,
            expiration=expiration,
            features=features or [],
            algorithm="rsa_signed",
            confidence=0.95
        )

    def generate_ecc_signed(self, private_key: ec.EllipticCurvePrivateKey,
                           product_id: str,
                           machine_code: str) -> GeneratedSerial:
        """Generate ECC-signed serial number."""
        # Create compact license data
        data = f"{product_id}:{machine_code}:{int(time.time())}"
        data_bytes = data.encode()

        # Sign with ECDSA
        signature = private_key.sign(
            data_bytes,
            ec.ECDSA(hashes.SHA256())
        )

        # Combine and encode
        serial_bytes = data_bytes + signature
        serial = base64.b32encode(serial_bytes).decode('ascii').rstrip('=')

        # Format
        formatted = '-'.join(serial[i:i+6] for i in range(0, len(serial), 6))

        return GeneratedSerial(
            serial=formatted,
            raw_bytes=serial_bytes,
            checksum="ECDSA-SHA256",
            hardware_id=machine_code,
            expiration=None,
            features=[],
            algorithm="ecc_signed",
            confidence=0.93
        )

    def generate_time_based(self, secret_key: bytes,
                           validity_days: int = 30,
                           product_id: Optional[str] = None) -> GeneratedSerial:
        """Generate time-based serial number (like TOTP)."""
        # Current time window
        time_counter = int(time.time()) // 86400  # Daily counter
        expiration = int(time.time()) + (validity_days * 86400)

        # Create data to hash
        data = struct.pack('>Q', time_counter)
        if product_id:
            data += product_id.encode()

        # Generate HMAC
        h = hmac.new(secret_key, data, hashlib.sha256)
        digest = h.digest()

        # Extract dynamic part (like TOTP)
        offset = digest[-1] & 0x0F
        code = struct.unpack('>I', digest[offset:offset+4])[0] & 0x7FFFFFFF

        # Format as serial
        serial_parts = []
        for i in range(5):
            part = (code >> (i * 6)) & 0x3F
            # Map to alphanumeric
            if part < 26:
                serial_parts.append(chr(ord('A') + part))
            elif part < 52:
                serial_parts.append(chr(ord('a') + part - 26))
            else:
                serial_parts.append(str(part - 52))

        # Add expiration encoding
        exp_encoded = base64.b32encode(struct.pack('>I', expiration)).decode()[:6]
        serial = f"{''.join(serial_parts)}-{exp_encoded}-{code % 10000:04d}"

        return GeneratedSerial(
            serial=serial,
            raw_bytes=digest,
            checksum="HMAC-SHA256",
            hardware_id=None,
            expiration=expiration,
            features=[],
            algorithm="time_based",
            confidence=0.88
        )

    def generate_feature_encoded(self, base_serial: str,
                                features: List[str]) -> GeneratedSerial:
        """Generate serial with encoded feature flags."""
        # Feature flag mapping
        feature_flags = {
            "pro": 0x01,
            "enterprise": 0x02,
            "unlimited": 0x04,
            "support": 0x08,
            "updates": 0x10,
            "api": 0x20,
            "export": 0x40,
            "multiuser": 0x80
        }

        # Encode features as bitfield
        flags = 0
        for feature in features:
            flags |= feature_flags.get(feature.lower(), 0)

        # Encode flags
        flags_encoded = f"{flags:04X}"

        # Combine with base serial
        if '-' in base_serial:
            parts = base_serial.split('-')
            # Insert feature code
            parts.insert(-1, flags_encoded)
            serial = '-'.join(parts)
        else:
            serial = f"{base_serial}-{flags_encoded}"

        # Add checksum
        checksum = self._calculate_crc16(serial.encode())
        serial = f"{serial}-{checksum:04X}"

        return GeneratedSerial(
            serial=serial,
            raw_bytes=serial.encode(),
            checksum="CRC16",
            hardware_id=None,
            expiration=None,
            features=features,
            algorithm="feature_encoded",
            confidence=0.82
        )

    def generate_mathematical(self, seed: int,
                            algorithm: str = "quadratic") -> GeneratedSerial:
        """Generate serial using mathematical relationship."""
        if algorithm == "quadratic":
            # f(x) = ax^2 + bx + c
            a, b, c = 1337, 42069, 314159
            result = (a * seed * seed + b * seed + c) & 0xFFFFFFFF

        elif algorithm == "fibonacci":
            # Fibonacci-based with seed
            f1, f2 = seed, seed + 1
            for _ in range(10):
                f1, f2 = f2, (f1 + f2) & 0xFFFFFFFF
            result = f2

        elif algorithm == "mersenne":
            # Mersenne prime based
            mersenne_primes = [3, 7, 31, 127, 8191, 131071, 524287]
            mp = mersenne_primes[seed % len(mersenne_primes)]
            result = (seed * mp) & 0xFFFFFFFF

        else:
            # Default: simple hash
            result = hashlib.md5(str(seed).encode()).hexdigest()[:8]
            result = int(result, 16)

        # Format as serial
        serial = f"{seed:05d}-{result:08X}"

        # Add validation code
        validation = self._calculate_crc32(serial.encode())
        serial = f"{serial}-{validation:08X}"

        return GeneratedSerial(
            serial=serial,
            raw_bytes=struct.pack('>II', seed, result),
            checksum="CRC32",
            hardware_id=None,
            expiration=None,
            features=[],
            algorithm=f"mathematical_{algorithm}",
            confidence=0.79
        )

    def generate_blackbox(self, input_data: bytes,
                         rounds: int = 1000) -> GeneratedSerial:
        """Generate serial using blackbox algorithm (unknown protection)."""
        # Apply proprietary transformation algorithm
        state = bytearray(input_data)

        # Multiple rounds of transformations
        for round_num in range(rounds):
            # Substitution
            for i in range(len(state)):
                state[i] = (state[i] + round_num) & 0xFF

            # Permutation
            for i in range(0, len(state) - 1, 2):
                state[i], state[i + 1] = state[i + 1], state[i]

            # Diffusion
            h = hashlib.sha256(state).digest()
            for i in range(min(len(state), len(h))):
                state[i] ^= h[i]

        # Extract serial
        serial_bytes = bytes(state[:16])
        serial = base64.b32encode(serial_bytes).decode().rstrip('=')

        # Format with separators
        formatted = '-'.join(serial[i:i+4] for i in range(0, len(serial), 4))

        return GeneratedSerial(
            serial=formatted,
            raw_bytes=serial_bytes,
            checksum=None,
            hardware_id=None,
            expiration=None,
            features=[],
            algorithm="blackbox",
            confidence=0.70
        )

    def reverse_engineer_algorithm(self, valid_serials: List[str],
                                  invalid_serials: Optional[List[str]] = None) -> Dict[str, Any]:
        """Reverse engineer serial algorithm from samples."""
        analysis = {
            "pattern": self.analyze_serial_pattern(valid_serials),
            "algorithm_type": "unknown",
            "confidence": 0.0,
            "parameters": {}
        }

        # Check for mathematical relationships
        numeric_parts = []
        for serial in valid_serials:
            # Extract numeric components
            numbers = re.findall(r'\d+', serial)
            if numbers:
                numeric_parts.append([int(n) for n in numbers])

        if numeric_parts and len(numeric_parts[0]) >= 2:
            # Check for mathematical relationship
            relationships = []
            for parts in numeric_parts:
                if len(parts) >= 2:
                    # Check various relationships
                    x, y = parts[0], parts[1]

                    # Quadratic
                    for a in range(1, 10000, 100):
                        for b in range(1, 10000, 100):
                            if abs(y - (a * x * x + b * x)) < 1000:
                                relationships.append(("quadratic", a, b))
                                break

            if relationships:
                analysis["algorithm_type"] = "mathematical"
                analysis["parameters"] = {"relationships": relationships}
                analysis["confidence"] = 0.75

        # Check for time-based patterns
        if len(valid_serials) > 1:
            # Check if serials change over time
            time_patterns = []
            for serial in valid_serials:
                # Look for timestamp-like values
                hex_parts = re.findall(r'[0-9A-F]{8}', serial)
                for part in hex_parts:
                    value = int(part, 16)
                    # Check if it's near current timestamp
                    if abs(value - int(time.time())) < 31536000:  # Within a year
                        time_patterns.append(value)

            if time_patterns:
                analysis["algorithm_type"] = "time_based"
                analysis["parameters"]["time_window"] = max(time_patterns) - min(time_patterns)
                analysis["confidence"] = 0.80

        # Check for signature-based (look for long base32/base64)
        for serial in valid_serials:
            clean = serial.replace('-', '').replace(' ', '')
            if len(clean) > 40 and all(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567" for c in clean):
                analysis["algorithm_type"] = "signature_based"
                analysis["confidence"] = 0.85
                break

        return analysis

    def brute_force_checksum(self, partial_serial: str,
                            checksum_length: int = 4) -> List[str]:
        """Brute force missing checksum digits."""
        candidates = []
        charset = "0123456789ABCDEF"

        # Try all possible checksums
        for i in range(16 ** checksum_length):
            checksum = ""
            val = i
            for _ in range(checksum_length):
                checksum = charset[val % 16] + checksum
                val //= 16

            full_serial = f"{partial_serial}-{checksum}"

            # Verify with different algorithms
            if self._verify_serial(full_serial):
                candidates.append(full_serial)

        return candidates

    def _verify_serial(self, serial: str) -> bool:
        """Verify if serial is valid using multiple algorithms."""
        clean = serial.replace('-', '').replace(' ', '')

        # Try Luhn
        if clean.isdigit() and self._verify_luhn(clean):
            return True

        # Try CRC16
        if len(clean) >= 4:
            try:
                data = clean[:-4].encode()
                crc = int(clean[-4:], 16)
                if self._calculate_crc16(data) == crc:
                    return True
            except:
                pass

        # Try CRC32
        if len(clean) >= 8:
            try:
                data = clean[:-8].encode()
                crc = int(clean[-8:], 16)
                if self._calculate_crc32(data) == crc:
                    return True
            except:
                pass

        return False

    def export_serials(self, output_file: str):
        """Export generated serials to file."""
        import json

        export_data = {
            "generated": len(self.generated_serials),
            "timestamp": time.time(),
            "serials": []
        }

        for serial in self.generated_serials:
            export_data["serials"].append({
                "serial": serial.serial,
                "algorithm": serial.algorithm,
                "confidence": serial.confidence,
                "checksum": serial.checksum,
                "hardware_id": serial.hardware_id,
                "expiration": serial.expiration,
                "features": serial.features,
                "hex": serial.raw_bytes.hex()
            })

        with open(output_file, 'w') as f:
            json.dump(export_data, f, indent=2)

        logger.info(f"Exported {len(self.generated_serials)} serials to {output_file}")

import json  # Add at top with other imports