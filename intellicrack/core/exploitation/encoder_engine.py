"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import base64
import logging
import random
import string
from typing import Any

from ...utils.logger import get_logger

"""
Encoder Engine for Payload Generation

Provides multiple encoding schemes for payload obfuscation
and evasion including XOR, Base64, custom algorithms.
"""

logger = logging.getLogger(__name__)


class EncoderEngine:
    """Advanced payload encoding engine with multiple encoding schemes
    and anti-analysis capabilities.
    """

    def __init__(self):
        """Initialize the encoder engine with multiple encoding and evasion capabilities."""
        self.logger = get_logger(__name__)

        # Available encoders
        self.encoders = {
            "xor": self._xor_encode,
            "alpha_mixed": self._alpha_mixed_encode,
            "alpha_upper": self._alpha_upper_encode,
            "alpha_lower": self._alpha_lower_encode,
            "unicode": self._unicode_encode,
            "base64": self._base64_encode,
            "fnstenv": self._fnstenv_encode,
            "call4_dword_xor": self._call4_dword_xor_encode,
            "countdown": self._countdown_encode,
            "shikata_ga_nai": self._shikata_ga_nai_encode,
        }

        # Available decoders (matching encoders)
        self.decoders = {
            "xor": self._xor_decode,
            "alpha_mixed": self._alpha_mixed_decode,
            "alpha_upper": self._alpha_upper_decode,
            "alpha_lower": self._alpha_lower_decode,
            "unicode": self._unicode_decode,
            "base64": self._base64_decode,
            "hex": self._hex_decode,
            "rot13": self._rot13_decode,
            "custom_shift": self._custom_shift_decode,
            "multi_xor": self._multi_xor_decode,
            "reverse": self._reverse_decode,
            "substitution": self._substitution_decode,
            "bit_manipulation": self._bit_manipulation_decode,
        }

        # Bad characters to avoid
        self.bad_chars = []

        # Target architecture
        self.arch = "x86"

        # Encoding statistics
        self.stats = {
            "total_encoded": 0,
            "successful_encodes": 0,
            "failed_encodes": 0,
            "avg_encode_ratio": 0.0,
        }

        # Cache for encoded payloads
        self.encode_cache = {}

        self.logger.info("EncoderEngine initialized")

    def encode_payload(
        self, payload: bytes, encoding_scheme: str, encoding_params: dict[str, Any] = None
    ) -> dict[str, Any]:
        """Encode payload using specified encoding scheme.

        Args:
            payload: Raw payload bytes
            encoding_scheme: Name of encoding scheme to use
            encoding_params: Parameters specific to encoding scheme

        Returns:
            Dictionary containing encoded payload and decoding information

        """
        try:
            if encoding_scheme not in self.encoders:
                raise ValueError(f"Unknown encoding scheme: {encoding_scheme}")

            self.logger.info(f"Encoding payload using {encoding_scheme} scheme")

            encoder_func = self.encoders[encoding_scheme]
            encoded_data, decode_info = encoder_func(payload, encoding_params or {})

            result = {
                "encoded_payload": encoded_data,
                "encoding_scheme": encoding_scheme,
                "decode_info": decode_info,
                "original_size": len(payload),
                "encoded_size": len(encoded_data)
                if isinstance(encoded_data, bytes)
                else len(str(encoded_data)),
                "decoder_stub": self._generate_decoder_stub(encoding_scheme, decode_info),
            }

            self.logger.info(f"Encoded payload: {len(payload)} -> {result['encoded_size']} bytes")
            return result

        except Exception as e:
            self.logger.error(f"Payload encoding failed: {e}")
            raise

    def multi_encode_payload(
        self,
        payload: bytes,
        encoding_schemes: list[str],
        encoding_params: list[dict[str, Any]] = None,
    ) -> dict[str, Any]:
        """Apply multiple encoding schemes in sequence.

        Args:
            payload: Raw payload bytes
            encoding_schemes: List of encoding schemes to apply
            encoding_params: List of parameters for each encoding scheme

        Returns:
            Dictionary containing multi-encoded payload and decoding chain

        """
        try:
            self.logger.info(f"Multi-encoding payload with {len(encoding_schemes)} schemes")

            current_payload = payload
            decode_chain = []

            if encoding_params is None:
                encoding_params = [{}] * len(encoding_schemes)

            # Apply encodings in sequence
            for i, scheme in enumerate(encoding_schemes):
                params = encoding_params[i] if i < len(encoding_params) else {}
                result = self.encode_payload(current_payload, scheme, params)

                current_payload = result["encoded_payload"]
                if isinstance(current_payload, str):
                    current_payload = current_payload.encode("utf-8")

                decode_chain.append(
                    {
                        "scheme": scheme,
                        "decode_info": result["decode_info"],
                    }
                )

            # Generate combined decoder
            combined_decoder = self._generate_multi_decoder_stub(decode_chain)

            return {
                "encoded_payload": current_payload,
                "encoding_schemes": encoding_schemes,
                "decode_chain": decode_chain,
                "original_size": len(payload),
                "final_size": len(current_payload),
                "decoder_stub": combined_decoder,
            }

        except Exception as e:
            self.logger.error(f"Multi-encoding failed: {e}")
            raise

    def decode_payload(
        self, encoded_data: Any, encoding_scheme: str, decode_info: dict[str, Any]
    ) -> bytes:
        """Decode payload using specified decoding information.

        Args:
            encoded_data: Encoded payload data
            encoding_scheme: Name of encoding scheme used
            decode_info: Decoding parameters

        Returns:
            Decoded payload bytes

        """
        try:
            if encoding_scheme not in self.decoders:
                raise ValueError(f"Unknown encoding scheme: {encoding_scheme}")

            decoder_func = self.decoders[encoding_scheme]
            decoded_payload = decoder_func(encoded_data, decode_info)

            self.logger.info(f"Decoded payload using {encoding_scheme}")
            return decoded_payload

        except Exception as e:
            self.logger.error(f"Payload decoding failed: {e}")
            raise

    # Encoding implementations

    def _xor_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[bytes, dict[str, Any]]:
        """XOR encoding with single or multi-byte key."""
        key = params.get("key")
        if key is None:
            key = bytes([random.randint(1, 255)])  # Avoid null byte
        elif isinstance(key, int):
            key = bytes([key])
        elif isinstance(key, str):
            key = key.encode("utf-8")

        encoded = bytearray()
        for i, byte in enumerate(payload):
            encoded.append(byte ^ key[i % len(key)])

        return bytes(encoded), {"key": key}

    def _xor_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """XOR decoding."""
        key = decode_info["key"]
        decoded = bytearray()
        for i, byte in enumerate(encoded_data):
            decoded.append(byte ^ key[i % len(key)])
        return bytes(decoded)

    def _base64_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[str, dict[str, Any]]:
        """Base64 encoding with optional custom alphabet."""
        custom_alphabet = params.get("alphabet")
        if custom_alphabet:
            # Custom base64 with different alphabet
            standard = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            encoded = base64.b64encode(payload).decode("utf-8")
            # Translate to custom alphabet
            translation = str.maketrans(standard, custom_alphabet)
            encoded = encoded.translate(translation)
            return encoded, {"alphabet": custom_alphabet}
        encoded = base64.b64encode(payload).decode("utf-8")
        return encoded, {}

    def _base64_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Base64 decoding."""
        custom_alphabet = decode_info.get("alphabet")
        if custom_alphabet:
            standard = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            translation = str.maketrans(custom_alphabet, standard)
            encoded_data = encoded_data.translate(translation)
        return base64.b64decode(encoded_data)

    def _hex_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[str, dict[str, Any]]:
        """Hexadecimal encoding with optional custom formatting."""
        uppercase = params.get("uppercase", False)
        separator = params.get("separator", "")
        prefix = params.get("prefix", "")

        hex_str = payload.hex()
        if uppercase:
            hex_str = hex_str.upper()

        if separator:
            hex_str = separator.join(hex_str[i : i + 2] for i in range(0, len(hex_str), 2))

        if prefix:
            hex_str = prefix + hex_str

        return hex_str, {"uppercase": uppercase, "separator": separator, "prefix": prefix}

    def _hex_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Hexadecimal decoding."""
        separator = decode_info.get("separator", "")
        prefix = decode_info.get("prefix", "")

        hex_str = encoded_data
        if prefix:
            hex_str = hex_str[len(prefix) :]
        if separator:
            hex_str = hex_str.replace(separator, "")

        return bytes.fromhex(hex_str)

    def _rot13_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[str, dict[str, Any]]:
        """ROT13 encoding for alphabetic characters."""
        shift = params.get("shift", 13)

        result = []
        for byte in payload:
            char = chr(byte)
            if char.isalpha():
                base = ord("A") if char.isupper() else ord("a")
                shifted = (ord(char) - base + shift) % 26 + base
                result.append(chr(shifted))
            else:
                result.append(char)

        return "".join(result), {"shift": shift}

    def _rot13_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """ROT13 decoding."""
        shift = decode_info.get("shift", 13)

        result = []
        for char in encoded_data:
            if char.isalpha():
                base = ord("A") if char.isupper() else ord("a")
                shifted = (ord(char) - base - shift) % 26 + base
                result.append(chr(shifted))
            else:
                result.append(char)

        return "".join(result).encode("utf-8")

    def _custom_shift_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[bytes, dict[str, Any]]:
        """Custom shift cipher with variable shift per byte."""
        base_shift = params.get("base_shift", random.randint(1, 255))
        shift_increment = params.get("shift_increment", random.randint(1, 7))

        encoded = bytearray()
        current_shift = base_shift

        for byte in payload:
            encoded_byte = (byte + current_shift) % 256
            encoded.append(encoded_byte)
            current_shift = (current_shift + shift_increment) % 256

        return bytes(encoded), {"base_shift": base_shift, "shift_increment": shift_increment}

    def _custom_shift_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """Custom shift cipher decoding."""
        base_shift = decode_info["base_shift"]
        shift_increment = decode_info["shift_increment"]

        decoded = bytearray()
        current_shift = base_shift

        for byte in encoded_data:
            decoded_byte = (byte - current_shift) % 256
            decoded.append(decoded_byte)
            current_shift = (current_shift + shift_increment) % 256

        return bytes(decoded)

    def _multi_xor_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[bytes, dict[str, Any]]:
        """Multi-pass XOR with different keys."""
        num_passes = params.get("passes", 3)
        keys = params.get("keys")

        if keys is None:
            keys = [bytes([random.randint(1, 255)]) for _ in range(num_passes)]

        current_data = payload
        for key in keys:
            encoded = bytearray()
            for i, byte in enumerate(current_data):
                encoded.append(byte ^ key[i % len(key)])
            current_data = bytes(encoded)

        return current_data, {"keys": keys}

    def _multi_xor_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """Multi-pass XOR decoding."""
        keys = decode_info["keys"]

        current_data = encoded_data
        # Decode in reverse order
        for key in reversed(keys):
            decoded = bytearray()
            for i, byte in enumerate(current_data):
                decoded.append(byte ^ key[i % len(key)])
            current_data = bytes(decoded)

        return current_data

    def _alpha_mixed_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[str, dict[str, Any]]:
        """Encode as mixed alphanumeric characters."""
        charset = params.get("charset", string.ascii_letters + string.digits)

        # Convert bytes to base representation using charset
        base = len(charset)
        result = []

        for byte in payload:
            # Convert byte to base representation
            if byte == 0:
                result.append(charset[0])
            else:
                chars = []
                while byte > 0:
                    chars.append(charset[byte % base])
                    byte //= base
                result.append("".join(reversed(chars)))
            result.append("|")  # Separator

        encoded = "".join(result).rstrip("|")
        return encoded, {"charset": charset}

    def _alpha_upper_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[str, dict[str, Any]]:
        """Encode as uppercase alphabetic characters only."""
        charset = string.ascii_uppercase
        base = len(charset)
        result = []

        for byte in payload:
            # Convert byte to base-26 representation
            if byte == 0:
                result.append(charset[0] * 2)  # AA for zero
            else:
                chars = []
                value = byte
                while value > 0:
                    chars.append(charset[value % base])
                    value //= base
                # Pad to at least 2 chars for consistency
                while len(chars) < 2:
                    chars.append(charset[0])
                result.append("".join(reversed(chars)))

        encoded = "".join(result)
        return encoded, {"charset": charset}

    def _alpha_lower_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[str, dict[str, Any]]:
        """Encode as lowercase alphabetic characters only."""
        charset = string.ascii_lowercase
        base = len(charset)
        result = []

        for byte in payload:
            # Convert byte to base-26 representation
            if byte == 0:
                result.append(charset[0] * 2)  # aa for zero
            else:
                chars = []
                value = byte
                while value > 0:
                    chars.append(charset[value % base])
                    value //= base
                # Pad to at least 2 chars for consistency
                while len(chars) < 2:
                    chars.append(charset[0])
                result.append("".join(reversed(chars)))

        encoded = "".join(result)
        return encoded, {"charset": charset}

    def _alpha_mixed_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Decode from mixed alphanumeric characters."""
        charset = decode_info["charset"]
        base = len(charset)

        decoded = bytearray()
        for chunk in encoded_data.split("|"):
            if not chunk:
                continue

            # Convert from base representation
            value = 0
            for char in chunk:
                value = value * base + charset.index(char)
            decoded.append(value % 256)

        return bytes(decoded)

    def _alpha_upper_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Decode from uppercase alphabetic characters."""
        charset = decode_info["charset"]
        base = len(charset)

        decoded = bytearray()
        # Process in 2-char chunks
        for i in range(0, len(encoded_data), 2):
            chunk = encoded_data[i:i+2]
            if len(chunk) < 2:
                break

            # Special case for AA (zero)
            if chunk == charset[0] * 2:
                decoded.append(0)
            else:
                # Convert from base-26
                value = 0
                for char in chunk:
                    value = value * base + charset.index(char)
                decoded.append(value % 256)

        return bytes(decoded)

    def _alpha_lower_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Decode from lowercase alphabetic characters."""
        charset = decode_info["charset"]
        base = len(charset)

        decoded = bytearray()
        # Process in 2-char chunks
        for i in range(0, len(encoded_data), 2):
            chunk = encoded_data[i:i+2]
            if len(chunk) < 2:
                break

            # Special case for aa (zero)
            if chunk == charset[0] * 2:
                decoded.append(0)
            else:
                # Convert from base-26
                value = 0
                for char in chunk:
                    value = value * base + charset.index(char)
                decoded.append(value % 256)

        return bytes(decoded)

    def _unicode_decode(self, encoded_data: str, decode_info: dict[str, Any]) -> bytes:
        """Decode from Unicode characters."""
        base_offset = decode_info["base_offset"]

        decoded = bytearray()
        for char in encoded_data:
            byte_value = ord(char) - base_offset
            if 0 <= byte_value <= 255:
                decoded.append(byte_value)

        return bytes(decoded)

    def _reverse_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[bytes, dict[str, Any]]:
        """Simple reversal with optional block-wise reversal."""
        block_size = params.get("block_size", 0)

        if block_size > 0:
            # Reverse in blocks
            result = bytearray()
            for i in range(0, len(payload), block_size):
                block = payload[i : i + block_size]
                result.extend(reversed(block))
            return bytes(result), {"block_size": block_size}
        # Simple full reversal
        return bytes(reversed(payload)), {"block_size": 0}

    def _reverse_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """Reverse decoding."""
        block_size = decode_info.get("block_size", 0)

        if block_size > 0:
            # Reverse in blocks
            result = bytearray()
            for i in range(0, len(encoded_data), block_size):
                block = encoded_data[i : i + block_size]
                result.extend(reversed(block))
            return bytes(result)
        # Simple full reversal
        return bytes(reversed(encoded_data))

    def _substitution_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[bytes, dict[str, Any]]:
        """Substitution cipher with custom mapping."""
        mapping = params.get("mapping")

        if mapping is None:
            # Generate random substitution mapping
            mapping = list(range(256))
            random.shuffle(mapping)

        encoded = bytearray()
        for byte in payload:
            encoded.append(mapping[byte])

        return bytes(encoded), {"mapping": mapping}

    def _substitution_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """Substitution cipher decoding."""
        mapping = decode_info["mapping"]

        # Create reverse mapping
        reverse_mapping = [0] * 256
        for i, mapped_value in enumerate(mapping):
            reverse_mapping[mapped_value] = i

        decoded = bytearray()
        for byte in encoded_data:
            decoded.append(reverse_mapping[byte])

        return bytes(decoded)

    def _bit_manipulation_encode(
        self, payload: bytes, params: dict[str, Any]
    ) -> tuple[bytes, dict[str, Any]]:
        """Bit-level manipulation encoding."""
        operation = params.get("operation", "flip")  # flip, rotate, swap
        param_value = params.get("value", random.randint(1, 7))

        encoded = bytearray()

        for byte in payload:
            if operation == "flip":
                # Flip specific bit
                encoded_byte = byte ^ (1 << (param_value % 8))
            elif operation == "rotate":
                # Rotate bits
                encoded_byte = ((byte << param_value) | (byte >> (8 - param_value))) & 0xFF
            elif operation == "swap":
                # Swap nibbles or specific bits
                if param_value == 4:  # Swap nibbles
                    encoded_byte = ((byte & 0x0F) << 4) | ((byte & 0xF0) >> 4)
                else:
                    encoded_byte = byte  # No change for other values
            else:
                encoded_byte = byte

            encoded.append(encoded_byte)

        return bytes(encoded), {"operation": operation, "value": param_value}

    def _bit_manipulation_decode(self, encoded_data: bytes, decode_info: dict[str, Any]) -> bytes:
        """Bit manipulation decoding."""
        operation = decode_info["operation"]
        param_value = decode_info["value"]

        decoded = bytearray()

        for byte in encoded_data:
            if operation == "flip":
                # Flip the same bit back
                decoded_byte = byte ^ (1 << (param_value % 8))
            elif operation == "rotate":
                # Rotate bits in opposite direction
                decoded_byte = ((byte >> param_value) | (byte << (8 - param_value))) & 0xFF
            elif operation == "swap":
                # Swap back
                if param_value == 4:  # Swap nibbles back
                    decoded_byte = ((byte & 0x0F) << 4) | ((byte & 0xF0) >> 4)
                else:
                    decoded_byte = byte
            else:
                decoded_byte = byte

            decoded.append(decoded_byte)

        return bytes(decoded)

    def _unicode_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[str, dict[str, Any]]:
        """Unicode-based encoding using various Unicode ranges."""
        base_offset = params.get("base_offset", 0x1000)  # Default to Ethiopic range

        encoded_chars = []
        for byte in payload:
            # Map byte to Unicode character
            unicode_char = chr(base_offset + byte)
            encoded_chars.append(unicode_char)

        encoded = "".join(encoded_chars)
        return encoded, {"base_offset": base_offset}

    def _fnstenv_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[bytes, dict[str, Any]]:
        """FPU-based GetPC encoding technique."""
        # Generate FPU instructions that use fnstenv to get EIP
        decoder_stub = bytearray([
            0xD9, 0xEE,        # fldz
            0xD9, 0x74, 0x24, 0xF4,  # fnstenv [esp-0xC]
            0x5B,              # pop ebx (EIP is now in EBX)
        ])

        # XOR encode the payload
        key = params.get("key", 0xAA)
        encoded_payload = bytearray(b ^ key for b in payload)

        # Combine decoder stub with encoded payload
        result = bytes(decoder_stub + encoded_payload)
        return result, {"key": key, "stub_size": len(decoder_stub)}

    def _call4_dword_xor_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[bytes, dict[str, Any]]:
        """Call+4 dword XOR encoder."""
        # Generate call+4 GetPC stub
        key = params.get("key", random.randint(0x10000000, 0x7FFFFFFF))

        decoder_stub = bytearray([
            0xE8, 0xFF, 0xFF, 0xFF, 0xFF,  # call +4
            0xC0,                           # (this byte gets skipped)
            0x5E,                           # pop esi
            0x81, 0x76, 0x0E,               # xor dword [esi+0x0E], key
        ])
        decoder_stub.extend(key.to_bytes(4, 'little'))

        # XOR encode payload with key
        encoded_payload = bytearray()
        key_bytes = key.to_bytes(4, 'little')
        for i in range(0, len(payload), 4):
            chunk = payload[i:i+4]
            while len(chunk) < 4:
                chunk += b'\x00'
            for j in range(4):
                encoded_payload.append(chunk[j] ^ key_bytes[j])

        result = bytes(decoder_stub + encoded_payload)
        return result, {"key": key, "stub_size": len(decoder_stub)}

    def _countdown_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[bytes, dict[str, Any]]:
        """Countdown (decrementing key) encoder."""
        initial_key = params.get("initial_key", random.randint(1, 255))

        encoded = bytearray()
        current_key = initial_key

        for byte in payload:
            encoded.append((byte ^ current_key) & 0xFF)
            current_key = (current_key - 1) & 0xFF
            if current_key == 0:
                current_key = initial_key

        return bytes(encoded), {"initial_key": initial_key}

    def _shikata_ga_nai_encode(self, payload: bytes, params: dict[str, Any]) -> tuple[bytes, dict[str, Any]]:
        """Polymorphic XOR additive feedback encoder (simplified version)."""
        # Generate random key
        key = params.get("key", random.randint(1, 0xFFFFFFFF))

        # Create polymorphic decoder stub
        decoder_stub = bytearray([
            0x31, 0xC9,              # xor ecx, ecx
            0xB1, len(payload) & 0xFF,  # mov cl, payload_len
            0xD9, 0xEE,              # fldz
            0xD9, 0x74, 0x24, 0xF4,  # fnstenv [esp-0xC]
            0x5B,                    # pop ebx
        ])

        # Encode with additive feedback
        encoded = bytearray()
        feedback = key & 0xFF

        for byte in payload:
            encoded_byte = (byte ^ feedback) & 0xFF
            encoded.append(encoded_byte)
            feedback = (feedback + encoded_byte) & 0xFF

        result = bytes(decoder_stub + encoded)
        return result, {"key": key, "initial_feedback": key & 0xFF, "stub_size": len(decoder_stub)}

    def _generate_decoder_stub(self, encoding_scheme: str, decode_info: dict[str, Any]) -> str:
        """Generate decoder stub code for specific encoding scheme."""
        if encoding_scheme == "xor":
            key = decode_info["key"]
            key_bytes = ", ".join(f"0x{b:02x}" for b in key)
            return f"""
# XOR Decoder
key = [{key_bytes}]
decoded = bytearray()
for i, byte in enumerate(encoded_data):
    decoded.append(byte ^ key[i % len(key)])
payload = bytes(decoded)
"""
        if encoding_scheme == "base64":
            alphabet = decode_info.get("alphabet")
            if alphabet:
                return f"""
# Custom Base64 Decoder
import base64
standard = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
custom = "{alphabet}"
translation = str.maketrans(custom, standard)
decoded_data = encoded_data.translate(translation)
payload = base64.b64decode(decoded_data)
"""
            return """
# Base64 Decoder
import base64
payload = base64.b64decode(encoded_data)
"""
        if encoding_scheme == "custom_shift":
            base_shift = decode_info["base_shift"]
            shift_increment = decode_info["shift_increment"]
            return f"""
# Custom Shift Decoder
decoded = bytearray()
current_shift = {base_shift}
for byte in encoded_data:
    decoded_byte = (byte - current_shift) % 256
    decoded.append(decoded_byte)
    current_shift = (current_shift + {shift_increment}) % 256
payload = bytes(decoded)
"""
        if encoding_scheme == "alpha_mixed":
            base_offset = decode_info.get("base_offset", 0x41)
            return f"""
# Alpha Mixed Decoder
decoded = bytearray()
for char in encoded_data:
    if char.isalpha():
        offset = ord(char.upper()) - {base_offset}
        decoded.append(offset)
payload = bytes(decoded)
"""
        if encoding_scheme == "alpha_upper":
            base_offset = decode_info.get("base_offset", 0x41)
            return f"""
# Alpha Upper Decoder
decoded = bytearray()
for char in encoded_data:
    if char.isupper():
        offset = ord(char) - {base_offset}
        decoded.append(offset)
payload = bytes(decoded)
"""
        if encoding_scheme == "alpha_lower":
            base_offset = decode_info.get("base_offset", 0x61)
            return f"""
# Alpha Lower Decoder
decoded = bytearray()
for char in encoded_data:
    if char.islower():
        offset = ord(char) - {base_offset}
        decoded.append(offset)
payload = bytes(decoded)
"""
        if encoding_scheme == "unicode":
            return """
# Unicode Decoder
decoded = bytearray()
for i in range(0, len(encoded_data), 2):
    if i + 1 < len(encoded_data):
        decoded.append(encoded_data[i])
payload = bytes(decoded)
"""
        if encoding_scheme == "fnstenv":
            key = decode_info.get("key", 0xAA)
            return f"""
# FPU-based GetPC Decoder (fnstenv)
# Assembly implementation required at runtime
# XOR key: 0x{key:02X}
decoded = bytearray()
for byte in encoded_data:
    decoded.append(byte ^ {key})
payload = bytes(decoded)
"""
        if encoding_scheme == "call4_dword_xor":
            key = decode_info.get("key", 0)
            return f"""
# Call+4 DWORD XOR Decoder
# Assembly implementation required at runtime
key = {key}
key_bytes = key.to_bytes(4, 'little')
decoded = bytearray()
for i in range(0, len(encoded_data), 4):
    chunk = encoded_data[i:i+4]
    for j in range(len(chunk)):
        decoded.append(chunk[j] ^ key_bytes[j % 4])
payload = bytes(decoded)
"""
        if encoding_scheme == "countdown":
            initial_key = decode_info.get("initial_key", 255)
            return f"""
# Countdown Decoder
decoded = bytearray()
current_key = {initial_key}
for byte in encoded_data:
    decoded.append((byte ^ current_key) & 0xFF)
    current_key = (current_key - 1) & 0xFF
    if current_key == 0:
        current_key = {initial_key}
payload = bytes(decoded)
"""
        if encoding_scheme == "shikata_ga_nai":
            key = decode_info.get("key", 0)
            initial_feedback = decode_info.get("initial_feedback", key & 0xFF)
            return f"""
# Shikata Ga Nai Decoder (Polymorphic XOR)
decoded = bytearray()
feedback = {initial_feedback}
for byte in encoded_data:
    original_byte = (byte ^ feedback) & 0xFF
    decoded.append(original_byte)
    feedback = (feedback + byte) & 0xFF
payload = bytes(decoded)
"""
        if encoding_scheme == "hex":
            return """
# Hex Decoder
import binascii
payload = binascii.unhexlify(encoded_data)
"""
        if encoding_scheme == "rot13":
            return """
# ROT13 Decoder
import codecs
decoded = codecs.decode(encoded_data, 'rot13')
payload = decoded.encode() if isinstance(decoded, str) else decoded
"""
        if encoding_scheme == "multi_xor":
            keys = decode_info.get("keys", [0xAA, 0xBB, 0xCC])
            return f"""
# Multi-XOR Decoder
keys = {keys}
decoded = bytearray()
for i, byte in enumerate(encoded_data):
    key_index = i % len(keys)
    decoded.append(byte ^ keys[key_index])
payload = bytes(decoded)
"""
        if encoding_scheme == "reverse":
            return """
# Reverse Decoder
payload = bytes(reversed(encoded_data))
"""
        if encoding_scheme == "substitution":
            mapping = decode_info.get("mapping", {})
            reverse_mapping = {v: k for k, v in mapping.items()}
            return f"""
# Substitution Decoder
reverse_mapping = {reverse_mapping}
decoded = bytearray()
for byte in encoded_data:
    decoded.append(reverse_mapping.get(byte, byte))
payload = bytes(decoded)
"""
        if encoding_scheme == "bit_manipulation":
            rotation = decode_info.get("rotation", 3)
            return f"""
# Bit Manipulation Decoder
decoded = bytearray()
for byte in encoded_data:
    # Rotate left (inverse of rotate right)
    rotated = ((byte << {rotation}) | (byte >> (8 - {rotation}))) & 0xFF
    decoded.append(rotated)
payload = bytes(decoded)
"""
        return f"""
# Generic Decoder for {encoding_scheme}
# Unknown encoding scheme - returning data as-is
payload = encoded_data
"""

    def _generate_multi_decoder_stub(self, decode_chain: list[dict[str, Any]]) -> str:
        """Generate decoder stub for multi-encoded payload."""
        decoder_code = "# Multi-stage Decoder\ncurrent_data = encoded_data\n\n"

        # Generate decoding steps in reverse order
        for step in reversed(decode_chain):
            scheme = step["scheme"]
            decode_info = step["decode_info"]

            step_code = self._generate_decoder_stub(scheme, decode_info)
            # Adapt the code to work on current_data
            step_code = step_code.replace("encoded_data", "current_data")
            step_code = step_code.replace("payload = ", "current_data = ")

            decoder_code += step_code + "\n"

        decoder_code += "payload = current_data\n"
        return decoder_code

    def get_random_encoding_scheme(self) -> str:
        """Get a random encoding scheme."""
        return random.choice(list(self.encoders.keys()))

    def get_encoding_schemes(self) -> list[str]:
        """Get list of available encoding schemes."""
        return list(self.encoders.keys())

    def benchmark_encoding_schemes(self, test_payload: bytes) -> dict[str, dict[str, Any]]:
        """Benchmark different encoding schemes."""
        results = {}

        for scheme in self.encoders.keys():
            try:
                import time

                start_time = time.time()

                result = self.encode_payload(test_payload, scheme)

                encode_time = time.time() - start_time

                # Test decoding
                start_time = time.time()
                decoded = self.decode_payload(
                    result["encoded_payload"],
                    scheme,
                    result["decode_info"],
                )
                decode_time = time.time() - start_time

                # Verify correctness
                correct = decoded == test_payload

                results[scheme] = {
                    "encode_time": encode_time,
                    "decode_time": decode_time,
                    "size_ratio": result["encoded_size"] / len(test_payload),
                    "correct": correct,
                    "encoded_size": result["encoded_size"],
                }

            except Exception as e:
                logger.error("Exception in encoder_engine: %s", e)
                results[scheme] = {"error": str(e)}

        return results
