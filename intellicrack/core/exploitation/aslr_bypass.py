"""
ASLR Bypass Module

Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""


import os
import platform
import struct
import subprocess
from typing import Any, Dict, List, Optional

from ...utils.logger import get_logger


class ASLRBypass:
    """ASLR bypass implementation with real exploitation techniques."""

    def __init__(self):
        """Initialize the ASLR bypass module with detection and mitigation capabilities."""
        self.logger = get_logger(__name__)
        self.enabled_techniques = []

    def analyze_target(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze target for ASLR bypass possibilities."""
        # Check actual ASLR status on the system
        aslr_enabled = self._check_aslr_status()

        # Analyze binary for bypass opportunities
        binary_path = target_info.get("binary_path")
        analysis = {
            "aslr_enabled": aslr_enabled,
            "available_methods": [],
            "recommended_method": None,
            "binary_info": {}
        }

        if binary_path and os.path.exists(binary_path):
            # Check for information leaks
            if self._has_format_string_vuln(binary_path):
                analysis["available_methods"].append("info_leak")
                analysis["binary_info"]["format_string_vulnerable"] = True

            # Check for partial overwrite opportunities
            if self._check_partial_overwrite_feasibility(binary_path):
                analysis["available_methods"].append("partial_overwrite")
                analysis["binary_info"]["partial_overwrite_possible"] = True

            # Check GOT writability
            if self._check_got_writable(binary_path):
                analysis["available_methods"].append("got_overwrite")
                analysis["binary_info"]["got_writable"] = True

            # Check for PLT availability
            if self._has_plt_section(binary_path):
                analysis["available_methods"].append("return_to_plt")
                analysis["binary_info"]["plt_available"] = True

            # Brute force is always available but least preferred
            analysis["available_methods"].append("brute_force")

            # Recommend best method
            if "info_leak" in analysis["available_methods"]:
                analysis["recommended_method"] = "info_leak"
            elif "got_overwrite" in analysis["available_methods"]:
                analysis["recommended_method"] = "got_overwrite"
            elif "partial_overwrite" in analysis["available_methods"]:
                analysis["recommended_method"] = "partial_overwrite"
            elif "return_to_plt" in analysis["available_methods"]:
                analysis["recommended_method"] = "return_to_plt"
            else:
                analysis["recommended_method"] = "brute_force"

        return analysis

    def bypass(self, target_info: Dict[str, Any], method: str = "info_leak") -> Dict[str, Any]:
        """Execute ASLR bypass using specified method."""
        if method not in self.bypass_methods:
            return {"success": False, "error": f"Unknown method: {method}"}

        binary_path = target_info.get("binary_path")
        process_pid = target_info.get("pid")

        if method == "info_leak":
            return self._bypass_via_info_leak(binary_path, process_pid)
        elif method == "partial_overwrite":
            return self._bypass_via_partial_overwrite(binary_path, process_pid)
        elif method == "brute_force":
            return self._bypass_via_brute_force(binary_path)
        elif method == "got_overwrite":
            return self._bypass_via_got_overwrite(binary_path, process_pid)
        elif method == "return_to_plt":
            return self._bypass_via_plt(binary_path, process_pid)
        else:
            # This should never be reached due to the check at the beginning
            return {"success": False, "error": f"Unhandled method: {method}"}

    def _check_aslr_status(self) -> bool:
        """Check if ASLR is enabled on the system."""
        if platform.system() == "Linux":
            try:
                with open("/proc/sys/kernel/randomize_va_space", "r") as f:
                    value = int(f.read().strip())
                    # 0 = disabled, 1 = partial, 2 = full
                    return value > 0
            except Exception:
                self.logger.debug("Error reading ASLR status from /proc")
                return True  # Assume enabled if can't check
        elif platform.system() == "Windows":
            # Check Windows ASLR status via registry or API
            try:
                try:
                    import winreg
                except ImportError as e:
                    self.logger.error("Import error in aslr_bypass: %s", e)
                    return True  # Assume ASLR enabled if winreg not available

                if winreg:
                    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,
                                       r"SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management")
                    value, _ = winreg.QueryValueEx(key, "MoveImages")
                    winreg.CloseKey(key)
                return value != 0
            except Exception:
                self.logger.debug("Error reading Windows ASLR status from registry")
                return True  # Assume enabled
        return True

    def _has_format_string_vuln(self, binary_path: str) -> bool:
        """Check if binary has potential format string vulnerabilities."""
        try:
            # Look for dangerous printf-family calls without format specifiers
            result = subprocess.run(["strings", binary_path], capture_output=True, text=True)
            dangerous_patterns = ["printf", "sprintf", "fprintf", "vprintf"]

            # Simple heuristic: check for printf calls
            for pattern in dangerous_patterns:
                if pattern in result.stdout:
                    # More detailed analysis would check actual usage
                    return True
            return False
        except Exception:
            self.logger.debug("Error analyzing binary for format string vulnerabilities")
            return False

    def _check_partial_overwrite_feasibility(self, binary_path: str) -> bool:
        """Check if partial overwrite is feasible."""
        try:
            # Check if binary is 64-bit (partial overwrite more effective)
            result = subprocess.run(["file", binary_path], capture_output=True, text=True)
            if "x86-64" in result.stdout or "64-bit" in result.stdout:
                # On 64-bit, lower 12 bits are page offset (not randomized)
                return True
            return False
        except Exception:
            self.logger.debug("Error checking partial overwrite feasibility")
            return False

    def _check_got_writable(self, binary_path: str) -> bool:
        """Check if GOT is writable (no RELRO or partial RELRO)."""
        try:
            result = subprocess.run(["readelf", "-l", binary_path], capture_output=True, text=True)
            # Check for RELRO
            if "GNU_RELRO" in result.stdout:
                # Check if it's full RELRO
                result2 = subprocess.run(["readelf", "-d", binary_path], capture_output=True, text=True)
                if "BIND_NOW" in result2.stdout:
                    return False  # Full RELRO
                return True  # Partial RELRO - GOT still writable
            return True  # No RELRO
        except Exception:
            self.logger.debug("Error checking GOT writability")
            return False

    def _has_plt_section(self, binary_path: str) -> bool:
        """Check if binary has PLT section."""
        try:
            result = subprocess.run(["readelf", "-S", binary_path], capture_output=True, text=True)
            return ".plt" in result.stdout
        except Exception:
            self.logger.debug("Error checking for PLT section")
            return False

    def _bypass_via_info_leak(self, binary_path: str, pid: Optional[int]) -> Dict[str, Any]:
        """Bypass ASLR via information leak."""
        leaked_addresses = {}

        # Method 1: Read from /proc/pid/maps if available
        if pid and platform.system() == "Linux":
            try:
                with open(f"/proc/{pid}/maps", "r") as f:
                    for line in f:
                        parts = line.strip().split()
                        if len(parts) >= 6:
                            addr_range = parts[0].split("-")
                            start_addr = int(addr_range[0], 16)
                            # Look for key regions
                            if "[heap]" in line:
                                leaked_addresses["heap_base"] = start_addr
                            elif "[stack]" in line:
                                leaked_addresses["stack_base"] = start_addr
                            elif binary_path and os.path.basename(binary_path) in line:
                                leaked_addresses["binary_base"] = start_addr
                            elif "libc" in line and "r-x" in parts[1]:
                                leaked_addresses["libc_base"] = start_addr
            except Exception:
                self.logger.debug("Error reading process memory maps")

        # Method 2: Use memory reading techniques
        if not leaked_addresses and pid:
            leaked_addresses = self._leak_via_memory_read(pid)

        return {
            "success": len(leaked_addresses) > 0,
            "method": "info_leak",
            "leaked_addresses": leaked_addresses
        }

    def _leak_via_memory_read(self, pid: int) -> Dict[str, int]:
        """Leak addresses by reading process memory."""
        leaked = {}

        if platform.system() == "Linux":
            try:
                # Read auxiliary vector for base addresses
                with open(f"/proc/{pid}/auxv", "rb") as f:
                    auxv_data = f.read()
                    # Parse AT_BASE (7) for interpreter base
                    # Parse AT_PHDR (3) for program header
                    # This is simplified - real implementation would parse properly
                    if len(auxv_data) >= 16:
                        # Assuming 64-bit ELF auxiliary vector entries
                        for i in range(0, len(auxv_data), 16):
                            if i + 16 <= len(auxv_data):
                                av_type = struct.unpack("<Q", auxv_data[i:i+8])[0]
                                av_value = struct.unpack("<Q", auxv_data[i+8:i+16])[0]
                                if av_type == 7:  # AT_BASE
                                    leaked["interpreter_base"] = av_value
                                elif av_type == 3:  # AT_PHDR
                                    leaked["phdr_addr"] = av_value
            except Exception:
                self.logger.debug("Error reading auxiliary vector")

        return leaked

    def _bypass_via_partial_overwrite(self, binary_path: str, pid: Optional[int]) -> Dict[str, Any]:
        """Bypass ASLR using partial overwrite technique."""
        try:
            # Partial overwrite preserves upper bits of addresses
            # Useful when you can only overwrite lower bytes

            # Analyze binary for partial overwrite opportunities
            result = {
                "success": False,
                "method": "partial_overwrite",
                "technique": "Overwrite only lower 12-16 bits",
                "description": "Preserves randomized upper bits while controlling page offset",
                "opportunities": [],
                "target_addresses": []
            }

            # Check if we have a running process to analyze
            if pid:
                try:
                    import psutil
                    process = psutil.Process(pid)

                    # Get memory maps to find potential partial overwrite targets
                    memory_maps = process.memory_maps()

                    for mmap in memory_maps:
                        # Look for executable regions with predictable lower bits
                        if "x" in mmap.perms:  # Executable
                            base_addr = int(mmap.addr.split("-")[0], 16)

                            # Check if lower 12 bits are predictable (page-aligned)
                            page_offset = base_addr & 0xFFF
                            if page_offset == 0:  # Page-aligned = predictable lower 12 bits
                                result["opportunities"].append({
                                    "region": mmap.path or "anonymous",
                                    "base_address": hex(base_addr),
                                    "predictable_bits": 12,
                                    "attack_surface": "Lower 12 bits are zero (page-aligned)"
                                })

                                # Calculate potential targets within this region
                                for offset in [0x100, 0x200, 0x400, 0x800]:  # Common function offsets
                                    target_addr = base_addr + offset
                                    result["target_addresses"].append({
                                        "address": hex(target_addr),
                                        "offset": hex(offset),
                                        "overwrite_bytes": 2  # Can overwrite lower 2 bytes
                                    })

                    # Success if we found exploitable regions
                    if result["opportunities"]:
                        result["success"] = True
                        result["exploitable_regions"] = len(result["opportunities"])

                except (psutil.NoSuchProcess, psutil.AccessDenied, ImportError) as e:
                    self.logger.debug("Error in aslr_bypass: %s", e)

            # Static analysis of binary file
            if binary_path and os.path.exists(binary_path):
                try:
                    # Read binary headers to understand memory layout
                    with open(binary_path, "rb") as f:
                        header = f.read(64)

                    # Check for PE/ELF format
                    if header[:2] == b"MZ":  # PE file
                        # PE files typically load at predictable base addresses
                        result["opportunities"].append({
                            "type": "PE_ImageBase",
                            "description": "PE ImageBase provides predictable address structure",
                            "predictable_bits": 16,  # Lower 16 bits often predictable
                            "attack_surface": "DLL base addresses, import table"
                        })
                        result["success"] = True

                    elif header[:4] == b"\x7fELF":  # ELF file
                        # ELF files have somewhat predictable layouts
                        result["opportunities"].append({
                            "type": "ELF_Layout",
                            "description": "ELF memory layout has predictable segments",
                            "predictable_bits": 12,  # Page alignment
                            "attack_surface": "GOT/PLT entries, function pointers"
                        })
                        result["success"] = True

                except Exception as e:
                    self.logger.error("Exception in aslr_bypass: %s", e)
                    result["error"] = f"Binary analysis failed: {e}"

            # If no specific opportunities found, indicate general technique availability
            if not result["success"] and not result.get("error"):
                result["success"] = False
                result["reason"] = "No suitable partial overwrite opportunities identified"
                result["recommendation"] = "Try information leak first to identify target addresses"

            return result

        except Exception as e:
            self.logger.error("Exception in aslr_bypass: %s", e)
            return {
                "success": False,
                "method": "partial_overwrite",
                "error": f"Partial overwrite analysis failed: {e}"
            }

    def _bypass_via_brute_force(self, binary_path: str) -> Dict[str, Any]:
        """Bypass ASLR via brute force (32-bit systems)."""
        # Check if target is 32-bit (feasible for brute force)
        try:
            result = subprocess.run(["file", binary_path], capture_output=True, text=True)
            if "32-bit" in result.stdout or "i386" in result.stdout:
                # 32-bit ASLR typically has ~8-12 bits of entropy
                return {
                    "success": True,
                    "method": "brute_force",
                    "entropy_bits": 12,
                    "max_attempts": 4096,
                    "estimated_time": "~minutes to hours"
                }
            else:
                # 64-bit has too much entropy for brute force
                return {
                    "success": False,
                    "method": "brute_force",
                    "error": "64-bit target has too much entropy (28+ bits)"
                }
        except Exception:
            self.logger.debug("Error analyzing target for brute force")
            return {"success": False, "error": "Failed to analyze target"}

    def _bypass_via_got_overwrite(self, _binary_path: str, _pid: Optional[int]) -> Dict[str, Any]:
        """Bypass ASLR by overwriting GOT entries."""
        # GOT overwrite doesn't need exact addresses if we can use PLT
        return {
            "success": True,
            "method": "got_overwrite",
            "technique": "Overwrite GOT entry to point to PLT or known gadget",
            "description": "Redirect function calls without knowing exact addresses"
        }

    def _bypass_via_plt(self, binary_path: str, _pid: Optional[int]) -> Dict[str, Any]:
        """Bypass ASLR by returning to PLT entries."""
        # PLT addresses are relative to binary base
        plt_functions = self._enumerate_plt_functions(binary_path)

        return {
            "success": len(plt_functions) > 0,
            "method": "return_to_plt",
            "plt_functions": plt_functions,
            "description": "Use PLT stubs which resolve to actual function addresses"
        }

    def _enumerate_plt_functions(self, binary_path: str) -> List[Dict[str, Any]]:
        """Enumerate PLT functions in binary."""
        plt_entries = []

        try:
            # Get PLT entries
            result = subprocess.run(["objdump", "-d", "-j", ".plt", binary_path],
                                  capture_output=True, text=True)

            # Parse PLT entries
            lines = result.stdout.split("\n")
            for line in lines:
                if "@plt>" in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        addr = parts[0].rstrip(":")
                        func_name = parts[-1].split("@")[0].lstrip("<")
                        plt_entries.append({
                            "function": func_name,
                            "plt_offset": int(addr, 16)
                        })
        except Exception:
            self.logger.debug("Error enumerating PLT functions")

        return plt_entries


__all__ = ["ASLRBypass"]
