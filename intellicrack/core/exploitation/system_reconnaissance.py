"""
Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

"""
System Reconnaissance Module

This module provides real system reconnaissance functionality for post-exploitation.
"""

import ctypes
import glob
import logging
import os
import platform
import socket
import subprocess
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class SystemRecon:
    """Handler for system reconnaissance operations with real enumeration."""

    def __init__(self):
        """Initialize system reconnaissance handler."""
        self.logger = logger
        self.is_windows = platform.system() == 'Windows'
        self.is_x64 = platform.machine() in ['AMD64', 'x86_64']

    def gather_system_info(self) -> Dict[str, Any]:
        """Gather comprehensive system information using real enumeration."""
        try:
            info = {
                "success": True,
                "system": self._get_system_info(),
                "environment": dict(os.environ),
                "users": self._enumerate_users(),
                "processes": self._enumerate_processes(),
                "network": self._gather_network_info(),
                "installed_software": self._enumerate_software(),
                "security_products": self._detect_security_products(),
                "privileges": self._check_privileges(),
                "drives": self._enumerate_drives(),
                "services": self._enumerate_services()
            }

            self.logger.info("System reconnaissance completed")
            return info

        except Exception as e:
            self.logger.error(f"System reconnaissance failed: {e}")
            return {"success": False, "error": str(e)}

    def _get_system_info(self) -> Dict[str, Any]:
        """Get detailed system information."""
        info = {
            "platform": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "hostname": platform.node(),
            "uptime": self._get_system_uptime(),
            "architecture": "x64" if self.is_x64 else "x86"
        }

        if self.is_windows:
            info.update(self._get_windows_system_info())
        else:
            info.update(self._get_linux_system_info())

        return info

    def _get_windows_system_info(self) -> Dict[str, Any]:
        """Get Windows-specific system information."""
        info = {}

        try:
            # Get Windows version details
            result = subprocess.run(['ver'], shell=True, capture_output=True, text=True)
            info['version_string'] = result.stdout.strip()

            # Get system info via wmic
            result = subprocess.run(['wmic', 'os', 'get', 'Caption,Version,BuildNumber,ServicePackMajorVersion'],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) > 1:
                    headers = lines[0].split()
                    values = lines[1].split()
                    if len(headers) == len(values):
                        for h, v in zip(headers, values):
                            info[h.lower()] = v

            # Get computer info
            result = subprocess.run(['wmic', 'computersystem', 'get', 'Name,Domain,Workgroup,TotalPhysicalMemory'],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) > 1:
                    for line in lines[1:]:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 4:
                                info['domain'] = parts[0] if parts[0] != 'WORKGROUP' else None
                                info['workgroup'] = parts[0] if parts[0] == 'WORKGROUP' else None
                                info['computer_name'] = parts[1]
                                info['total_memory'] = parts[2]

        except Exception as e:
            self.logger.debug(f"Windows system info error: {e}")

        return info

    def _get_linux_system_info(self) -> Dict[str, Any]:
        """Get Linux-specific system information."""
        info = {}

        try:
            # Get distribution info
            if os.path.exists('/etc/os-release'):
                with open('/etc/os-release', 'r') as f:
                    for line in f:
                        if '=' in line:
                            key, value = line.strip().split('=', 1)
                            info[key.lower()] = value.strip('"')

            # Get kernel info
            result = subprocess.run(['uname', '-a'], capture_output=True, text=True)
            if result.returncode == 0:
                info['kernel_full'] = result.stdout.strip()

            # Get memory info
            if os.path.exists('/proc/meminfo'):
                with open('/proc/meminfo', 'r') as f:
                    for line in f:
                        if line.startswith('MemTotal:'):
                            info['total_memory'] = line.split()[1] + ' kB'
                            break

            # Get CPU info
            if os.path.exists('/proc/cpuinfo'):
                with open('/proc/cpuinfo', 'r') as f:
                    cpu_count = 0
                    for line in f:
                        if line.startswith('processor'):
                            cpu_count += 1
                        elif line.startswith('model name'):
                            info['cpu_model'] = line.split(':', 1)[1].strip()
                    info['cpu_count'] = cpu_count

        except Exception as e:
            self.logger.debug(f"Linux system info error: {e}")

        return info

    def _get_system_uptime(self) -> str:
        """Get system uptime."""
        try:
            if self.is_windows:
                result = subprocess.run(['wmic', 'os', 'get', 'LastBootUpTime'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        return lines[1].strip()
            else:
                with open('/proc/uptime', 'r') as f:
                    uptime_seconds = float(f.read().split()[0])
                    days = int(uptime_seconds // 86400)
                    hours = int((uptime_seconds % 86400) // 3600)
                    minutes = int((uptime_seconds % 3600) // 60)
                    return f"{days} days, {hours} hours, {minutes} minutes"
        except Exception as e:
            self.logger.debug(f"Uptime error: {e}")

        return "Unknown"

    def _enumerate_users(self) -> List[Dict[str, Any]]:
        """Enumerate system users with real implementation."""
        users = []

        try:
            if self.is_windows:
                # Windows user enumeration
                result = subprocess.run(['wmic', 'useraccount', 'get', 'Name,Description,Disabled,LocalAccount,SID'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        headers = lines[0].split()
                        for line in lines[1:]:
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= len(headers):
                                    user_info = {
                                        'username': parts[headers.index('Name')] if 'Name' in headers else 'Unknown',
                                        'description': parts[headers.index('Description')] if 'Description' in headers else '',
                                        'disabled': parts[headers.index('Disabled')] if 'Disabled' in headers else False,
                                        'local': parts[headers.index('LocalAccount')] if 'LocalAccount' in headers else True,
                                        'sid': parts[headers.index('SID')] if 'SID' in headers else ''
                                    }
                                    users.append(user_info)

                # Get current user privileges
                current_user = os.getenv("USERNAME", "Unknown")
                user_privileges = self._get_windows_user_privileges(current_user)

                # Add current user info
                users.append({
                    "username": current_user,
                    "home": os.getenv("USERPROFILE", ""),
                    "is_admin": self._is_windows_admin(),
                    "privileges": user_privileges,
                    "current": True
                })

            else:
                # Unix/Linux user enumeration
                try:
                    import grp
                    import pwd

                    # Get all users from passwd
                    for user_entry in pwd.getpwall():
                        user_info = {
                            "username": user_entry.pw_name,
                            "uid": user_entry.pw_uid,
                            "gid": user_entry.pw_gid,
                            "home": user_entry.pw_dir,
                            "shell": user_entry.pw_shell,
                            "gecos": user_entry.pw_gecos
                        }

                        # Get groups for user
                        user_groups = []
                        for group_entry in grp.getgrall():
                            if user_entry.pw_name in group_entry.gr_mem:
                                user_groups.append(group_entry.gr_name)
                        user_info["groups"] = user_groups

                        # Check if current user
                        if user_entry.pw_name == os.getenv("USER"):
                            user_info["current"] = True
                            user_info["is_root"] = os.getuid() == 0 if hasattr(os, "getuid") else False

                        users.append(user_info)

                except ImportError:
                    # Fallback without pwd module
                    current_user = os.getenv("USER", "Unknown")
                    users.append({
                        "username": current_user,
                        "home": os.getenv("HOME", ""),
                        "uid": os.getuid() if hasattr(os, "getuid") else -1,
                        "is_root": os.getuid() == 0 if hasattr(os, "getuid") else False,
                        "current": True
                    })

        except Exception as e:
            self.logger.debug(f"User enumeration error: {e}")

        return users

    def _enumerate_processes(self) -> List[Dict[str, Any]]:
        """Enumerate running processes with real implementation."""
        processes = []

        try:
            if self.is_windows:
                # Windows process enumeration
                result = subprocess.run(['wmic', 'process', 'get', 'Name,ProcessId,ExecutablePath,CommandLine'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        for line in lines[1:]:
                            if line.strip():
                                # Parse process info (simplified)
                                parts = line.split()
                                if len(parts) >= 2:
                                    processes.append({
                                        "name": parts[1] if len(parts) > 1 else "Unknown",
                                        "pid": int(parts[0]) if parts[0].isdigit() else 0,
                                        "path": parts[2] if len(parts) > 2 else "",
                                        "cmdline": " ".join(parts[3:]) if len(parts) > 3 else ""
                                    })
            else:
                # Linux process enumeration
                # Method 1: Use ps command
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        for line in lines[1:]:
                            parts = line.split(None, 10)
                            if len(parts) >= 11:
                                processes.append({
                                    "user": parts[0],
                                    "pid": int(parts[1]),
                                    "cpu": float(parts[2]),
                                    "mem": float(parts[3]),
                                    "vsz": int(parts[4]),
                                    "rss": int(parts[5]),
                                    "tty": parts[6],
                                    "stat": parts[7],
                                    "start": parts[8],
                                    "time": parts[9],
                                    "command": parts[10]
                                })

                # Method 2: Parse /proc directly
                for pid_dir in glob.glob('/proc/[0-9]*'):
                    try:
                        pid = int(os.path.basename(pid_dir))

                        # Read process info
                        # Initialize variables to ensure they're always defined
                        name = "unknown"
                        cmdline = ""
                        
                        comm_path = os.path.join(pid_dir, 'comm')
                        if os.path.exists(comm_path):
                            with open(comm_path, 'r') as f:
                                name = f.read().strip()

                        cmdline_path = os.path.join(pid_dir, 'cmdline')
                        if os.path.exists(cmdline_path):
                            with open(cmdline_path, 'r') as f:
                                cmdline = f.read().replace('\x00', ' ').strip()

                        # Check if already added by ps
                        if not any(p.get('pid') == pid for p in processes):
                            processes.append({
                                "pid": pid,
                                "name": name,
                                "cmdline": cmdline
                            })
                    except (ValueError, OSError):
                        continue

        except Exception as e:
            self.logger.debug(f"Process enumeration error: {e}")
            # Fallback: add current process
            processes.append({
                "pid": os.getpid(),
                "name": "current_process",
                "path": os.path.abspath("."),
                "current": True
            })

        return processes

    def _gather_network_info(self) -> Dict[str, Any]:
        """Gather network configuration information with real implementation."""
        network_info = {
            "interfaces": [],
            "connections": [],
            "routing_table": [],
            "dns_servers": [],
            "firewall_rules": []
        }

        try:
            # Basic socket info
            network_info["hostname"] = socket.gethostname()
            network_info["fqdn"] = socket.getfqdn()

            if self.is_windows:
                # Windows network enumeration
                # Get interfaces
                result = subprocess.run(['ipconfig', '/all'], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["ipconfig_output"] = result.stdout

                # Get network connections
                result = subprocess.run(['netstat', '-ano'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[2:]:  # Skip headers
                        parts = line.split()
                        if len(parts) >= 4:
                            network_info["connections"].append({
                                "protocol": parts[0],
                                "local": parts[1],
                                "remote": parts[2],
                                "state": parts[3],
                                "pid": parts[4] if len(parts) > 4 else ""
                            })

                # Get routing table
                result = subprocess.run(['route', 'print'], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["routing_output"] = result.stdout

            else:
                # Linux network enumeration
                # Get interfaces
                result = subprocess.run(['ip', 'addr', 'show'], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["interfaces_output"] = result.stdout

                # Get network connections
                result = subprocess.run(['ss', '-tuln'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:  # Skip header
                        parts = line.split()
                        if len(parts) >= 5:
                            network_info["connections"].append({
                                "state": parts[0],
                                "recv_q": parts[1],
                                "send_q": parts[2],
                                "local": parts[3],
                                "peer": parts[4]
                            })

                # Get routing table
                result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["routing_output"] = result.stdout

                # Get DNS servers
                if os.path.exists('/etc/resolv.conf'):
                    with open('/etc/resolv.conf', 'r') as f:
                        for line in f:
                            if line.startswith('nameserver'):
                                dns_server = line.split()[1]
                                network_info["dns_servers"].append(dns_server)

        except Exception as e:
            self.logger.debug(f"Network info gathering error: {e}")

        return network_info

    def _enumerate_software(self) -> List[Dict[str, str]]:
        """Enumerate installed software with real implementation."""
        software = []

        try:
            if self.is_windows:
                # Windows software enumeration via registry and wmic
                result = subprocess.run(['wmic', 'product', 'get', 'Name,Version,Vendor'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        for line in lines[1:]:
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= 3:
                                    software.append({
                                        "name": parts[0],
                                        "version": parts[1],
                                        "vendor": " ".join(parts[2:])
                                    })
            else:
                # Linux software enumeration
                # Check dpkg (Debian/Ubuntu)
                result = subprocess.run(['dpkg', '-l'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ii'):  # Installed packages
                            parts = line.split()
                            if len(parts) >= 3:
                                software.append({
                                    "name": parts[1],
                                    "version": parts[2],
                                    "package_manager": "dpkg"
                                })

                # Check rpm (RedHat/CentOS/Fedora)
                result = subprocess.run(['rpm', '-qa'], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        if line:
                            software.append({
                                "name": line,
                                "package_manager": "rpm"
                            })

                # Check pacman (Arch Linux)
                result = subprocess.run(['pacman', '-Q'], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        if line:
                            parts = line.split()
                            if len(parts) >= 2:
                                software.append({
                                    "name": parts[0],
                                    "version": parts[1],
                                    "package_manager": "pacman"
                                })

            # Always add Python info
            software.append({
                "name": "Python",
                "version": platform.python_version(),
                "path": os.path.dirname(os.__file__)
            })

        except Exception as e:
            self.logger.debug(f"Software enumeration error: {e}")

        return software

    def _detect_security_products(self) -> List[Dict[str, str]]:
        """Detect installed security products."""
        security_products = []

        try:
            if self.is_windows:
                # Check Windows Defender
                result = subprocess.run(['powershell', '-Command', 'Get-MpComputerStatus'],
                                      capture_output=True, text=True)
                if result.returncode == 0 and 'AntivirusEnabled' in result.stdout:
                    security_products.append({
                        "name": "Windows Defender",
                        "type": "antivirus",
                        "status": "running"
                    })

                # Check for other AV products via WMI
                result = subprocess.run(['wmic', '/namespace:\\\\root\\securitycenter2', 'path', 'antivirusproduct', 'get', 'displayName'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip():
                            security_products.append({
                                "name": line.strip(),
                                "type": "antivirus",
                                "status": "detected"
                            })

            else:
                # Check common Linux security tools
                security_tools = ['fail2ban', 'ufw', 'iptables', 'apparmor', 'selinux', 'rkhunter', 'chkrootkit']

                for tool in security_tools:
                    result = subprocess.run(['which', tool], capture_output=True, text=True)
                    if result.returncode == 0:
                        security_products.append({
                            "name": tool,
                            "type": "security_tool",
                            "path": result.stdout.strip()
                        })

        except Exception as e:
            self.logger.debug(f"Security product detection error: {e}")

        return security_products

    def _check_privileges(self) -> Dict[str, Any]:
        """Check current user privileges."""
        privileges = {
            "current_user": os.getenv("USER") or os.getenv("USERNAME"),
            "is_admin": False,
            "is_root": False,
            "groups": [],
            "special_privileges": []
        }

        try:
            if self.is_windows:
                privileges["is_admin"] = self._is_windows_admin()
                privileges["special_privileges"] = self._get_windows_user_privileges()
            else:
                privileges["is_root"] = os.getuid() == 0 if hasattr(os, "getuid") else False

                # Get groups
                try:
                    import grp
                    gid = os.getgid() if hasattr(os, "getgid") else -1
                    if gid != -1:  # Only enumerate groups if we have a valid gid
                        for group in grp.getgrall():
                            if gid == group.gr_gid or privileges["current_user"] in group.gr_mem:
                                privileges["groups"].append(group.gr_name)
                except ImportError:
                    # grp module not available (Windows)
                    pass

                # Check sudo access
                result = subprocess.run(['sudo', '-l'], capture_output=True, text=True)
                if result.returncode == 0:
                    privileges["sudo_access"] = result.stdout

        except Exception as e:
            self.logger.debug(f"Privilege check error: {e}")

        return privileges

    def _enumerate_drives(self) -> List[Dict[str, Any]]:
        """Enumerate system drives/mounts."""
        drives = []

        try:
            if self.is_windows:
                result = subprocess.run(['wmic', 'logicaldisk', 'get', 'Size,FreeSpace,Caption,DriveType'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 4:
                                drives.append({
                                    "drive": parts[0],
                                    "type": parts[1],
                                    "free_space": parts[2],
                                    "size": parts[3]
                                })
            else:
                result = subprocess.run(['df', '-h'], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        parts = line.split()
                        if len(parts) >= 6:
                            drives.append({
                                "filesystem": parts[0],
                                "size": parts[1],
                                "used": parts[2],
                                "available": parts[3],
                                "use_percent": parts[4],
                                "mount_point": parts[5]
                            })

        except Exception as e:
            self.logger.debug(f"Drive enumeration error: {e}")

        return drives

    def _enumerate_services(self) -> List[Dict[str, Any]]:
        """Enumerate system services."""
        services = []

        try:
            if self.is_windows:
                result = subprocess.run(['sc', 'query'], capture_output=True, text=True)
                if result.returncode == 0:
                    # Parse sc query output
                    service_blocks = result.stdout.split('\n\n')
                    for block in service_blocks:
                        if 'SERVICE_NAME:' in block:
                            lines = block.strip().split('\n')
                            service_info = {}
                            for line in lines:
                                if ':' in line:
                                    key, value = line.split(':', 1)
                                    service_info[key.strip()] = value.strip()
                            services.append(service_info)
            else:
                # Check systemd services
                result = subprocess.run(['systemctl', 'list-units', '--type=service'],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        if '.service' in line:
                            parts = line.split()
                            if len(parts) >= 4:
                                services.append({
                                    "name": parts[0],
                                    "load": parts[1],
                                    "active": parts[2],
                                    "sub": parts[3],
                                    "description": " ".join(parts[4:]) if len(parts) > 4 else ""
                                })

        except Exception as e:
            self.logger.debug(f"Service enumeration error: {e}")

        return services

    def find_interesting_files(self, patterns: List[str] = None, search_paths: List[str] = None) -> List[Dict[str, Any]]:
        """Find interesting files on the system with real filesystem search."""
        if patterns is None:
            patterns = [
                "*.conf", "*.config", "*.key", "*.pem", "*.p12", "*.pfx",
                "password*", "secret*", "credential*", "*.sql", "*.db",
                "*.log", "backup*", "*.bak", "*.old", "id_rsa*", "*.ssh",
                "web.config", "application.properties", "*.yaml", "*.yml"
            ]

        if search_paths is None:
            if self.is_windows:
                search_paths = [
                    "C:\\Users", "C:\\Program Files", "C:\\Program Files (x86)",
                    "C:\\Windows\\System32\\config", "C:\\ProgramData"
                ]
            else:
                search_paths = [
                    "/home", "/etc", "/var", "/opt", "/usr/local",
                    "/root", "/tmp", "/var/log", "/var/www"
                ]

        interesting_files = []

        try:
            for search_path in search_paths:
                if not os.path.exists(search_path):
                    continue

                self.logger.info(f"Searching in {search_path}")

                for pattern in patterns:
                    try:
                        # Use glob for pattern matching
                        if self.is_windows:
                            search_pattern = os.path.join(search_path, "**", pattern)
                        else:
                            search_pattern = os.path.join(search_path, "**", pattern)

                        matches = glob.glob(search_pattern, recursive=True)

                        for match in matches:
                            try:
                                stat_info = os.stat(match)
                                file_info = {
                                    "path": match,
                                    "name": os.path.basename(match),
                                    "size": stat_info.st_size,
                                    "modified": stat_info.st_mtime,
                                    "pattern": pattern,
                                    "readable": os.access(match, os.R_OK),
                                    "writable": os.access(match, os.W_OK)
                                }

                                # Check if it's a known sensitive file
                                if self._is_sensitive_file(match):
                                    file_info["sensitivity"] = "high"

                                interesting_files.append(file_info)

                            except (OSError, PermissionError):
                                # Skip files we can't access
                                continue

                    except Exception as e:
                        self.logger.debug(f"Pattern search error for {pattern}: {e}")
                        continue

        except Exception as e:
            self.logger.error(f"File search error: {e}")

        self.logger.info(f"Found {len(interesting_files)} interesting files")
        return interesting_files

    def _is_sensitive_file(self, filepath: str) -> bool:
        """Check if file is known to be sensitive."""
        sensitive_files = [
            "shadow", "passwd", "id_rsa", "id_dsa", "id_ecdsa", "id_ed25519",
            "private.key", "server.key", "cert.pem", "private.pem",
            "web.config", "database.yml", "config.php", ".env",
            "credentials", "secrets", "passwords.txt", "pwd.db"
        ]

        filename = os.path.basename(filepath).lower()
        return any(sensitive in filename for sensitive in sensitive_files)

    def _is_windows_admin(self) -> bool:
        """Check if current user has Windows admin privileges."""
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except:
            return False

    def _get_windows_user_privileges(self, username: str = None) -> List[str]:
        """Get Windows user privileges."""
        privileges = []

        try:
            if username:
                result = subprocess.run(['whoami', '/priv'], capture_output=True, text=True)
            else:
                result = subprocess.run(['whoami', '/priv'], capture_output=True, text=True)

            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'Privilege Name' in line:
                        continue
                    if line.strip() and not line.startswith('='):
                        parts = line.split()
                        if len(parts) >= 2:
                            privileges.append(parts[0])

        except Exception as e:
            self.logger.debug(f"Privilege enumeration error: {e}")

        return privileges
