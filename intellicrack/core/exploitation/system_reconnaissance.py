"""
Copyright (C) 2025 Zachary Flint

This file is part of Intellicrack.

Intellicrack is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Intellicrack is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Intellicrack.  If not, see <https://www.gnu.org/licenses/>.
"""

import ctypes
import glob
import logging
import os
import platform
import socket
import subprocess
from typing import Any, Dict, List

"""
System Reconnaissance Module

This module provides real system reconnaissance functionality for post-exploitation.
"""

logger = logging.getLogger(__name__)


class SystemRecon:
    """Handler for system reconnaissance operations with real enumeration."""

    def __init__(self):
        """Initialize system reconnaissance handler."""
        self.logger = logger
        self.is_windows = platform.system() == "Windows"
        self.is_x64 = platform.machine() in ["AMD64", "x86_64"]

    def gather_system_info(self) -> Dict[str, Any]:
        """Gather comprehensive system information using real enumeration."""
        try:
            info = {
                "success": True,
                "system": self._get_system_info(),
                "environment": dict(os.environ),
                "users": self._enumerate_users(),
                "processes": self._enumerate_processes(),
                "network": self._gather_network_info(),
                "installed_software": self._enumerate_software(),
                "security_products": self._detect_security_products(),
                "privileges": self._check_privileges(),
                "drives": self._enumerate_drives(),
                "services": self._enumerate_services()
            }

            self.logger.info("System reconnaissance completed")
            return info

        except Exception as e:
            self.logger.error(f"System reconnaissance failed: {e}")
            return {"success": False, "error": str(e)}

    def _get_system_info(self) -> Dict[str, Any]:
        """Get detailed system information."""
        info = {
            "platform": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "hostname": platform.node(),
            "uptime": self._get_system_uptime(),
            "architecture": "x64" if self.is_x64 else "x86"
        }

        if self.is_windows:
            info.update(self._get_windows_system_info())
        else:
            info.update(self._get_linux_system_info())

        return info

    def _get_windows_system_info(self) -> Dict[str, Any]:
        """Get Windows-specific system information."""
        info = {}

        try:
            # Get Windows version details
            result = subprocess.run(["ver"], shell=True, capture_output=True, text=True)
            info["version_string"] = result.stdout.strip()

            # Get system info via wmic
            result = subprocess.run(["wmic", "os", "get", "Caption,Version,BuildNumber,ServicePackMajorVersion"],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split("\n")
                if len(lines) > 1:
                    headers = lines[0].split()
                    values = lines[1].split()
                    if len(headers) == len(values):
                        for h, v in zip(headers, values, strict=False):
                            info[h.lower()] = v

            # Get computer info
            result = subprocess.run(["wmic", "computersystem", "get", "Name,Domain,Workgroup,TotalPhysicalMemory"],
                                  capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split("\n")
                if len(lines) > 1:
                    for line in lines[1:]:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 4:
                                info["domain"] = parts[0] if parts[0] != "WORKGROUP" else None
                                info["workgroup"] = parts[0] if parts[0] == "WORKGROUP" else None
                                info["computer_name"] = parts[1]
                                info["total_memory"] = parts[2]

        except Exception as e:
            self.logger.debug(f"Windows system info error: {e}")

        return info

    def _get_linux_system_info(self) -> Dict[str, Any]:
        """Get Linux-specific system information."""
        info = {}

        try:
            # Get distribution info
            if os.path.exists("/etc/os-release"):
                with open("/etc/os-release", "r") as f:
                    for line in f:
                        if "=" in line:
                            key, value = line.strip().split("=", 1)
                            info[key.lower()] = value.strip('"')

            # Get kernel info
            result = subprocess.run(["uname", "-a"], capture_output=True, text=True)
            if result.returncode == 0:
                info["kernel_full"] = result.stdout.strip()

            # Get memory info
            if os.path.exists("/proc/meminfo"):
                with open("/proc/meminfo", "r") as f:
                    for line in f:
                        if line.startswith("MemTotal:"):
                            info["total_memory"] = line.split()[1] + " kB"
                            break

            # Get CPU info
            if os.path.exists("/proc/cpuinfo"):
                with open("/proc/cpuinfo", "r") as f:
                    cpu_count = 0
                    for line in f:
                        if line.startswith("processor"):
                            cpu_count += 1
                        elif line.startswith("model name"):
                            info["cpu_model"] = line.split(":", 1)[1].strip()
                    info["cpu_count"] = cpu_count

        except Exception as e:
            self.logger.debug(f"Linux system info error: {e}")

        return info

    def _get_system_uptime(self) -> str:
        """Get system uptime."""
        try:
            if self.is_windows:
                result = subprocess.run(["wmic", "os", "get", "LastBootUpTime"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        return lines[1].strip()
            else:
                with open("/proc/uptime", "r") as f:
                    uptime_seconds = float(f.read().split()[0])
                    days = int(uptime_seconds // 86400)
                    hours = int((uptime_seconds % 86400) // 3600)
                    minutes = int((uptime_seconds % 3600) // 60)
                    return f"{days} days, {hours} hours, {minutes} minutes"
        except Exception as e:
            self.logger.debug(f"Uptime error: {e}")

        return "Unknown"

    def _enumerate_users(self) -> List[Dict[str, Any]]:
        """Enumerate system users with real implementation."""
        users = []

        try:
            if self.is_windows:
                # Windows user enumeration
                result = subprocess.run(["wmic", "useraccount", "get", "Name,Description,Disabled,LocalAccount,SID"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        headers = lines[0].split()
                        for line in lines[1:]:
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= len(headers):
                                    user_info = {
                                        "username": parts[headers.index("Name")] if "Name" in headers else "Unknown",
                                        "description": parts[headers.index("Description")] if "Description" in headers else "",
                                        "disabled": parts[headers.index("Disabled")] if "Disabled" in headers else False,
                                        "local": parts[headers.index("LocalAccount")] if "LocalAccount" in headers else True,
                                        "sid": parts[headers.index("SID")] if "SID" in headers else ""
                                    }
                                    users.append(user_info)

                # Get current user privileges
                current_user = os.getenv("USERNAME", "Unknown")
                user_privileges = self._get_windows_user_privileges(current_user)

                # Add current user info
                users.append({
                    "username": current_user,
                    "home": os.getenv("USERPROFILE", ""),
                    "is_admin": self._is_windows_admin(),
                    "privileges": user_privileges,
                    "current": True
                })

            else:
                # Unix/Linux user enumeration
                try:
                    import grp
                    import pwd

                    # Get all users from passwd
                    for user_entry in pwd.getpwall():
                        user_info = {
                            "username": user_entry.pw_name,
                            "uid": user_entry.pw_uid,
                            "gid": user_entry.pw_gid,
                            "home": user_entry.pw_dir,
                            "shell": user_entry.pw_shell,
                            "gecos": user_entry.pw_gecos
                        }

                        # Get groups for user
                        user_groups = []
                        for group_entry in grp.getgrall():
                            if user_entry.pw_name in group_entry.gr_mem:
                                user_groups.append(group_entry.gr_name)
                        user_info["groups"] = user_groups

                        # Check if current user
                        if user_entry.pw_name == os.getenv("USER"):
                            user_info["current"] = True
                            user_info["is_root"] = os.getuid() == 0 if hasattr(os, "getuid") else False

                        users.append(user_info)

                except ImportError as e:
                    logger.error("Import error in system_reconnaissance: %s", e)
                    # Fallback without pwd module
                    current_user = os.getenv("USER", "Unknown")
                    users.append({
                        "username": current_user,
                        "home": os.getenv("HOME", ""),
                        "uid": os.getuid() if hasattr(os, "getuid") else -1,
                        "is_root": os.getuid() == 0 if hasattr(os, "getuid") else False,
                        "current": True
                    })

        except Exception as e:
            self.logger.debug(f"User enumeration error: {e}")

        return users

    def _enumerate_processes(self) -> List[Dict[str, Any]]:
        """Enumerate running processes with real implementation."""
        processes = []

        try:
            if self.is_windows:
                # Windows process enumeration
                result = subprocess.run(["wmic", "process", "get", "Name,ProcessId,ExecutablePath,CommandLine"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        for line in lines[1:]:
                            if line.strip():
                                # Parse process info (simplified)
                                parts = line.split()
                                if len(parts) >= 2:
                                    processes.append({
                                        "name": parts[1] if len(parts) > 1 else "Unknown",
                                        "pid": int(parts[0]) if parts[0].isdigit() else 0,
                                        "path": parts[2] if len(parts) > 2 else "",
                                        "cmdline": " ".join(parts[3:]) if len(parts) > 3 else ""
                                    })
            else:
                # Linux process enumeration
                # Method 1: Use ps command
                result = subprocess.run(["ps", "aux"], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        for line in lines[1:]:
                            parts = line.split(None, 10)
                            if len(parts) >= 11:
                                processes.append({
                                    "user": parts[0],
                                    "pid": int(parts[1]),
                                    "cpu": float(parts[2]),
                                    "mem": float(parts[3]),
                                    "vsz": int(parts[4]),
                                    "rss": int(parts[5]),
                                    "tty": parts[6],
                                    "stat": parts[7],
                                    "start": parts[8],
                                    "time": parts[9],
                                    "command": parts[10]
                                })

                # Method 2: Parse /proc directly
                for pid_dir in glob.glob("/proc/[0-9]*"):
                    try:
                        pid = int(os.path.basename(pid_dir))

                        # Read process info
                        # Initialize variables to ensure they're always defined
                        name = "unknown"
                        cmdline = ""

                        comm_path = os.path.join(pid_dir, "comm")
                        if os.path.exists(comm_path):
                            with open(comm_path, "r") as f:
                                name = f.read().strip()

                        cmdline_path = os.path.join(pid_dir, "cmdline")
                        if os.path.exists(cmdline_path):
                            with open(cmdline_path, "r") as f:
                                cmdline = f.read().replace("\x00", " ").strip()

                        # Check if already added by ps
                        if not any(p.get("pid") == pid for p in processes):
                            processes.append({
                                "pid": pid,
                                "name": name,
                                "cmdline": cmdline
                            })
                    except (ValueError, OSError) as e:
                        logger.error("Error in system_reconnaissance: %s", e)
                        continue

        except Exception as e:
            self.logger.debug(f"Process enumeration error: {e}")
            # Fallback: add current process
            processes.append({
                "pid": os.getpid(),
                "name": "current_process",
                "path": os.path.abspath("."),
                "current": True
            })

        return processes

    def _gather_network_info(self) -> Dict[str, Any]:
        """Gather network configuration information with real implementation."""
        network_info = {
            "interfaces": [],
            "connections": [],
            "routing_table": [],
            "dns_servers": [],
            "firewall_rules": []
        }

        try:
            # Basic socket info
            network_info["hostname"] = socket.gethostname()
            network_info["fqdn"] = socket.getfqdn()

            if self.is_windows:
                # Windows network enumeration
                # Get interfaces
                result = subprocess.run(["ipconfig", "/all"], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["ipconfig_output"] = result.stdout

                # Get network connections
                result = subprocess.run(["netstat", "-ano"], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[2:]:  # Skip headers
                        parts = line.split()
                        if len(parts) >= 4:
                            network_info["connections"].append({
                                "protocol": parts[0],
                                "local": parts[1],
                                "remote": parts[2],
                                "state": parts[3],
                                "pid": parts[4] if len(parts) > 4 else ""
                            })

                # Get routing table
                result = subprocess.run(["route", "print"], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["routing_output"] = result.stdout

            else:
                # Linux network enumeration
                # Get interfaces
                result = subprocess.run(["ip", "addr", "show"], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["interfaces_output"] = result.stdout

                # Get network connections
                result = subprocess.run(["ss", "-tuln"], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:  # Skip header
                        parts = line.split()
                        if len(parts) >= 5:
                            network_info["connections"].append({
                                "state": parts[0],
                                "recv_q": parts[1],
                                "send_q": parts[2],
                                "local": parts[3],
                                "peer": parts[4]
                            })

                # Get routing table
                result = subprocess.run(["ip", "route", "show"], capture_output=True, text=True)
                if result.returncode == 0:
                    network_info["routing_output"] = result.stdout

                # Get DNS servers
                if os.path.exists("/etc/resolv.conf"):
                    with open("/etc/resolv.conf", "r") as f:
                        for line in f:
                            if line.startswith("nameserver"):
                                dns_server = line.split()[1]
                                network_info["dns_servers"].append(dns_server)

        except Exception as e:
            self.logger.debug(f"Network info gathering error: {e}")

        return network_info

    def _enumerate_software(self) -> List[Dict[str, str]]:
        """Enumerate installed software with real implementation."""
        software = []

        try:
            if self.is_windows:
                # Windows software enumeration via registry and wmic
                result = subprocess.run(["wmic", "product", "get", "Name,Version,Vendor"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    if len(lines) > 1:
                        for line in lines[1:]:
                            if line.strip():
                                parts = line.split()
                                if len(parts) >= 3:
                                    software.append({
                                        "name": parts[0],
                                        "version": parts[1],
                                        "vendor": " ".join(parts[2:])
                                    })
            else:
                # Linux software enumeration
                # Check dpkg (Debian/Ubuntu)
                result = subprocess.run(["dpkg", "-l"], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines:
                        if line.startswith("ii"):  # Installed packages
                            parts = line.split()
                            if len(parts) >= 3:
                                software.append({
                                    "name": parts[1],
                                    "version": parts[2],
                                    "package_manager": "dpkg"
                                })

                # Check rpm (RedHat/CentOS/Fedora)
                result = subprocess.run(["rpm", "-qa"], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.strip().split("\n"):
                        if line:
                            software.append({
                                "name": line,
                                "package_manager": "rpm"
                            })

                # Check pacman (Arch Linux)
                result = subprocess.run(["pacman", "-Q"], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.strip().split("\n"):
                        if line:
                            parts = line.split()
                            if len(parts) >= 2:
                                software.append({
                                    "name": parts[0],
                                    "version": parts[1],
                                    "package_manager": "pacman"
                                })

            # Always add Python info
            software.append({
                "name": "Python",
                "version": platform.python_version(),
                "path": os.path.dirname(os.__file__)
            })

        except Exception as e:
            self.logger.debug(f"Software enumeration error: {e}")

        return software

    def _detect_security_products(self) -> List[Dict[str, str]]:
        """Detect installed security products."""
        security_products = []

        try:
            if self.is_windows:
                # Check Windows Defender
                result = subprocess.run(["powershell", "-Command", "Get-MpComputerStatus"],
                                      capture_output=True, text=True)
                if result.returncode == 0 and "AntivirusEnabled" in result.stdout:
                    security_products.append({
                        "name": "Windows Defender",
                        "type": "antivirus",
                        "status": "running"
                    })

                # Check for other AV products via WMI
                result = subprocess.run(["wmic", "/namespace:\\\\root\\securitycenter2", "path", "antivirusproduct", "get", "displayName"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        if line.strip():
                            security_products.append({
                                "name": line.strip(),
                                "type": "antivirus",
                                "status": "detected"
                            })

            else:
                # Check common Linux security tools
                security_tools = ["fail2ban", "ufw", "iptables", "apparmor", "selinux", "rkhunter", "chkrootkit"]

                for tool in security_tools:
                    result = subprocess.run(["which", tool], capture_output=True, text=True)
                    if result.returncode == 0:
                        security_products.append({
                            "name": tool,
                            "type": "security_tool",
                            "path": result.stdout.strip()
                        })

        except Exception as e:
            self.logger.debug(f"Security product detection error: {e}")

        return security_products

    def _check_privileges(self) -> Dict[str, Any]:
        """Check current user privileges."""
        privileges = {
            "current_user": os.getenv("USER") or os.getenv("USERNAME"),
            "is_admin": False,
            "is_root": False,
            "groups": [],
            "special_privileges": []
        }

        try:
            if self.is_windows:
                privileges["is_admin"] = self._is_windows_admin()
                privileges["special_privileges"] = self._get_windows_user_privileges()
            else:
                privileges["is_root"] = os.getuid() == 0 if hasattr(os, "getuid") else False

                # Get groups
                try:
                    import grp
                    gid = os.getgid() if hasattr(os, "getgid") else -1
                    if gid != -1:  # Only enumerate groups if we have a valid gid
                        for group in grp.getgrall():
                            if gid == group.gr_gid or privileges["current_user"] in group.gr_mem:
                                privileges["groups"].append(group.gr_name)
                except ImportError as e:
                    logger.error("Import error in system_reconnaissance: %s", e)
                    # grp module not available (Windows)
                    pass

                # Check sudo access
                result = subprocess.run(["sudo", "-l"], capture_output=True, text=True)
                if result.returncode == 0:
                    privileges["sudo_access"] = result.stdout

        except Exception as e:
            self.logger.debug(f"Privilege check error: {e}")

        return privileges

    def _enumerate_drives(self) -> List[Dict[str, Any]]:
        """Enumerate system drives/mounts."""
        drives = []

        try:
            if self.is_windows:
                result = subprocess.run(["wmic", "logicaldisk", "get", "Size,FreeSpace,Caption,DriveType"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        if line.strip():
                            parts = line.split()
                            if len(parts) >= 4:
                                drives.append({
                                    "drive": parts[0],
                                    "type": parts[1],
                                    "free_space": parts[2],
                                    "size": parts[3]
                                })
            else:
                result = subprocess.run(["df", "-h"], capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        parts = line.split()
                        if len(parts) >= 6:
                            drives.append({
                                "filesystem": parts[0],
                                "size": parts[1],
                                "used": parts[2],
                                "available": parts[3],
                                "use_percent": parts[4],
                                "mount_point": parts[5]
                            })

        except Exception as e:
            self.logger.debug(f"Drive enumeration error: {e}")

        return drives

    def _enumerate_services(self) -> List[Dict[str, Any]]:
        """Enumerate system services."""
        services = []

        try:
            if self.is_windows:
                result = subprocess.run(["sc", "query"], capture_output=True, text=True)
                if result.returncode == 0:
                    # Parse sc query output
                    service_blocks = result.stdout.split("\n\n")
                    for block in service_blocks:
                        if "SERVICE_NAME:" in block:
                            lines = block.strip().split("\n")
                            service_info = {}
                            for line in lines:
                                if ":" in line:
                                    key, value = line.split(":", 1)
                                    service_info[key.strip()] = value.strip()
                            services.append(service_info)
            else:
                # Check systemd services
                result = subprocess.run(["systemctl", "list-units", "--type=service"],
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        if ".service" in line:
                            parts = line.split()
                            if len(parts) >= 4:
                                services.append({
                                    "name": parts[0],
                                    "load": parts[1],
                                    "active": parts[2],
                                    "sub": parts[3],
                                    "description": " ".join(parts[4:]) if len(parts) > 4 else ""
                                })

        except Exception as e:
            self.logger.debug(f"Service enumeration error: {e}")

        return services

    def find_interesting_files(self, patterns: List[str] = None, search_paths: List[str] = None) -> List[Dict[str, Any]]:
        """Find interesting files on the system with real filesystem search."""
        if patterns is None:
            patterns = [
                "*.conf", "*.config", "*.key", "*.pem", "*.p12", "*.pfx",
                "password*", "secret*", "credential*", "*.sql", "*.db",
                "*.log", "backup*", "*.bak", "*.old", "id_rsa*", "*.ssh",
                "web.config", "application.properties", "*.yaml", "*.yml"
            ]

        if search_paths is None:
            if self.is_windows:
                search_paths = [
                    "C:\\Users", "C:\\Program Files", "C:\\Program Files (x86)",
                    "C:\\Windows\\System32\\config", "C:\\ProgramData"
                ]
            else:
                search_paths = [
                    "/home", "/etc", "/var", "/opt", "/usr/local",
                    "/root", "/tmp", "/var/log", "/var/www"
                ]

        interesting_files = []

        try:
            for search_path in search_paths:
                if not os.path.exists(search_path):
                    continue

                self.logger.info(f"Searching in {search_path}")

                for pattern in patterns:
                    try:
                        # Use glob for pattern matching
                        if self.is_windows:
                            search_pattern = os.path.join(search_path, "**", pattern)
                        else:
                            search_pattern = os.path.join(search_path, "**", pattern)

                        matches = glob.glob(search_pattern, recursive=True)

                        for match in matches:
                            try:
                                stat_info = os.stat(match)
                                file_info = {
                                    "path": match,
                                    "name": os.path.basename(match),
                                    "size": stat_info.st_size,
                                    "modified": stat_info.st_mtime,
                                    "pattern": pattern,
                                    "readable": os.access(match, os.R_OK),
                                    "writable": os.access(match, os.W_OK)
                                }

                                # Check if it's a known sensitive file
                                if self._is_sensitive_file(match):
                                    file_info["sensitivity"] = "high"

                                interesting_files.append(file_info)

                            except (OSError, PermissionError) as e:
                                logger.error("Error in system_reconnaissance: %s", e)
                                # Skip files we can't access
                                continue

                    except Exception as e:
                        self.logger.debug(f"Pattern search error for {pattern}: {e}")
                        continue

        except Exception as e:
            self.logger.error(f"File search error: {e}")

        self.logger.info(f"Found {len(interesting_files)} interesting files")
        return interesting_files

    def _is_sensitive_file(self, filepath: str) -> bool:
        """Check if file is known to be sensitive."""
        sensitive_files = [
            "shadow", "passwd", "id_rsa", "id_dsa", "id_ecdsa", "id_ed25519",
            "private.key", "server.key", "cert.pem", "private.pem",
            "web.config", "database.yml", "config.php", ".env",
            "credentials", "secrets", "passwords.txt", "pwd.db"
        ]

        filename = os.path.basename(filepath).lower()
        return any(sensitive in filename for sensitive in sensitive_files)

    def _is_windows_admin(self) -> bool:
        """Check if current user has Windows admin privileges."""
        try:
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except:
            return False

    def _get_windows_user_privileges(self, username: str = None) -> List[str]:
        """Get Windows user privileges."""
        privileges = []

        try:
            if username:
                result = subprocess.run(["whoami", "/priv"], capture_output=True, text=True)
            else:
                result = subprocess.run(["whoami", "/priv"], capture_output=True, text=True)

            if result.returncode == 0:
                lines = result.stdout.split("\n")
                for line in lines:
                    if "Privilege Name" in line:
                        continue
                    if line.strip() and not line.startswith("="):
                        parts = line.split()
                        if len(parts) >= 2:
                            privileges.append(parts[0])

        except Exception as e:
            self.logger.debug(f"Privilege enumeration error: {e}")

        return privileges
