"""
Persistence Manager

Orchestrates persistence establishment across multiple platforms and methods.
Provides intelligent selection of persistence techniques based on target environment.
"""

import logging
import time
from typing import Any, Dict, List, Optional

from ...utils.system.os_detection_mixin import OSDetectionMixin
from .base_persistence import BasePersistence

try:
    from .windows_persistence import WindowsPersistence
    WINDOWS_PERSISTENCE_AVAILABLE = True
except ImportError:
    WINDOWS_PERSISTENCE_AVAILABLE = False

try:
    from .linux_persistence import LinuxPersistence
    LINUX_PERSISTENCE_AVAILABLE = True
except ImportError:
    LINUX_PERSISTENCE_AVAILABLE = False

logger = logging.getLogger(__name__)


class PersistenceManager(BasePersistence, OSDetectionMixin):
    """
    Cross-platform persistence management with intelligent method selection.
    """

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger("IntellicrackLogger.PersistenceManager")

        # Initialize platform-specific handlers
        self.windows_handler = None
        self.linux_handler = None

        if WINDOWS_PERSISTENCE_AVAILABLE:
            self.windows_handler = WindowsPersistence()

        if LINUX_PERSISTENCE_AVAILABLE:
            self.linux_handler = LinuxPersistence()

        # Persistence method rankings by stealth and reliability
        self.method_rankings = {
            'windows': {
                'registry_run': {'stealth': 3, 'reliability': 9, 'privilege': 'user'},
                'scheduled_task': {'stealth': 6, 'reliability': 8, 'privilege': 'user'},
                'service': {'stealth': 8, 'reliability': 9, 'privilege': 'admin'},
                'wmi_event': {'stealth': 9, 'reliability': 7, 'privilege': 'admin'},
                'dll_hijacking': {'stealth': 9, 'reliability': 6, 'privilege': 'user'},
                'com_hijacking': {'stealth': 8, 'reliability': 7, 'privilege': 'user'},
                'startup_folder': {'stealth': 2, 'reliability': 8, 'privilege': 'user'},
                'accessibility_feature': {'stealth': 7, 'reliability': 8, 'privilege': 'admin'},
                'winlogon_helper': {'stealth': 8, 'reliability': 9, 'privilege': 'admin'},
                'image_file_execution': {'stealth': 6, 'reliability': 7, 'privilege': 'admin'},
                'lsa_security_package': {'stealth': 10, 'reliability': 8, 'privilege': 'system'}
            },
            'linux': {
                'systemd_service': {'stealth': 7, 'reliability': 9, 'privilege': 'user'},
                'init_d_service': {'stealth': 6, 'reliability': 8, 'privilege': 'admin'},
                'cron_job': {'stealth': 5, 'reliability': 9, 'privilege': 'user'},
                'shell_profile': {'stealth': 4, 'reliability': 8, 'privilege': 'user'},
                'desktop_autostart': {'stealth': 3, 'reliability': 7, 'privilege': 'user'},
                'kernel_module': {'stealth': 10, 'reliability': 9, 'privilege': 'root'},
                'library_preload': {'stealth': 9, 'reliability': 7, 'privilege': 'admin'},
                'ssh_authorized_keys': {'stealth': 8, 'reliability': 8, 'privilege': 'user'},
                'udev_rules': {'stealth': 8, 'reliability': 7, 'privilege': 'admin'},
                'motd_script': {'stealth': 6, 'reliability': 6, 'privilege': 'admin'},
                'pam_module': {'stealth': 9, 'reliability': 8, 'privilege': 'admin'}
            }
        }

        # Active persistence sessions
        self.active_sessions = {}

    def establish_persistence(self,
                            payload_path: str,
                            target_os: Optional[str] = None,
                            privilege_level: str = 'user',
                            stealth_level: str = 'medium',
                            redundancy: int = 1,
                            options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Establish persistence with intelligent method selection.

        Args:
            payload_path: Path to payload executable
            target_os: Target operating system ('windows', 'linux', or None for auto-detect)
            privilege_level: Current privilege level ('user', 'admin', 'root', 'system')
            stealth_level: Desired stealth level ('low', 'medium', 'high', 'maximum')
            redundancy: Number of persistence methods to establish
            options: Additional configuration options

        Returns:
            Results of persistence establishment
        """
        result = {
            'success': False,
            'target_os': target_os or self._detect_target_os(),
            'methods_established': [],
            'methods_failed': [],
            'session_id': self._generate_session_id(),
            'redundancy_achieved': 0,
            'stealth_score': 0,
            'reliability_score': 0
        }

        if options is None:
            options = {}

        try:
            self.logger.info(f"Establishing persistence with {redundancy} methods")

            # Auto-detect target OS if not specified
            if not target_os:
                result['target_os'] = self._detect_target_os()
                target_os = result['target_os']

            # Select optimal persistence methods
            selected_methods = self._select_persistence_methods(
                target_os, privilege_level, stealth_level, redundancy
            )

            if not selected_methods:
                result['error'] = f"No suitable persistence methods for {target_os}"
                return result

            # Establish each selected method
            session_info = {
                'session_id': result['session_id'],
                'target_os': target_os,
                'payload_path': payload_path,
                'methods': [],
                'created_at': time.time()
            }

            for method_info in selected_methods:
                method_name = method_info['method']
                method_options = {**options, **method_info.get('options', {})}

                self.logger.info(f"Attempting persistence method: {method_name}")

                # Execute persistence method
                method_result = self._execute_persistence_method(
                    target_os, method_name, payload_path, method_options
                )

                if method_result['success']:
                    result['methods_established'].append({
                        'method': method_name,
                        'details': method_result['details'],
                        'cleanup_info': method_result['cleanup_info'],
                        'stealth_score': method_info['stealth'],
                        'reliability_score': method_info['reliability']
                    })

                    session_info['methods'].append({
                        'method': method_name,
                        'cleanup_info': method_result['cleanup_info'],
                        'established_at': time.time()
                    })

                    result['redundancy_achieved'] += 1

                    self.logger.info(f"Successfully established {method_name}")
                else:
                    result['methods_failed'].append({
                        'method': method_name,
                        'error': method_result.get('error', 'Unknown error')
                    })

                    self.logger.warning(f"Failed to establish {method_name}: {method_result.get('error')}")

            # Calculate overall scores
            if result['methods_established']:
                total_stealth = sum(m['stealth_score'] for m in result['methods_established'])
                total_reliability = sum(m['reliability_score'] for m in result['methods_established'])
                count = len(result['methods_established'])

                result['stealth_score'] = total_stealth / count
                result['reliability_score'] = total_reliability / count
                result['success'] = True

                # Store session info
                self.active_sessions[result['session_id']] = session_info

                self.logger.info(f"Persistence established: {result['redundancy_achieved']}/{redundancy} methods")
            else:
                result['error'] = "All persistence methods failed"

            return result

        except Exception as e:
            return self.handle_establishment_error(result, e)

    def remove_persistence(self, session_id: str) -> Dict[str, Any]:
        """
        Remove all persistence methods for a session.

        Args:
            session_id: Session identifier

        Returns:
            Results of persistence removal
        """
        result = {
            'success': False,
            'session_id': session_id,
            'methods_removed': [],
            'methods_failed': [],
            'error': None
        }

        try:
            session_info = self.validate_session(session_id, self.active_sessions, result)
            if not session_info:
                return result
            target_os = session_info['target_os']

            self.logger.info(f"Removing persistence for session {session_id}")

            # Remove each method
            for method_info in session_info['methods']:
                method_name = method_info['method']
                cleanup_info = method_info['cleanup_info']

                try:
                    # Execute removal
                    removed = self._remove_persistence_method(target_os, cleanup_info)

                    if removed:
                        result['methods_removed'].append(method_name)
                        self.logger.info(f"Successfully removed {method_name}")
                    else:
                        result['methods_failed'].append({
                            'method': method_name,
                            'error': 'Removal failed'
                        })
                        self.logger.warning(f"Failed to remove {method_name}")

                except Exception as e:
                    result['methods_failed'].append({
                        'method': method_name,
                        'error': str(e)
                    })
                    self.logger.error(f"Error removing {method_name}: {e}")

            # Remove session
            del self.active_sessions[session_id]

            result['success'] = len(result['methods_removed']) > 0

            return result

        except Exception as e:
            self.logger.error(f"Persistence removal failed: {e}")
            result['error'] = str(e)
            return result

    def list_active_sessions(self) -> List[Dict[str, Any]]:
        """List all active persistence sessions."""
        sessions = []

        for session_id, session_info in self.active_sessions.items():
            sessions.append({
                'session_id': session_id,
                'target_os': session_info['target_os'],
                'payload_path': session_info['payload_path'],
                'method_count': len(session_info['methods']),
                'methods': [m['method'] for m in session_info['methods']],
                'created_at': session_info['created_at']
            })

        return sessions

    def get_session_details(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a specific session."""
        return self.active_sessions.get(session_id)


    def _select_persistence_methods(self,
                                  target_os: str,
                                  privilege_level: str,
                                  stealth_level: str,
                                  count: int) -> List[Dict[str, Any]]:
        """Select optimal persistence methods based on criteria."""
        if target_os not in self.method_rankings:
            return []

        methods = self.method_rankings[target_os]

        # Filter by privilege level
        available_methods = []
        for method, info in methods.items():
            if self._privilege_sufficient(privilege_level, info['privilege']):
                available_methods.append({
                    'method': method,
                    'stealth': info['stealth'],
                    'reliability': info['reliability'],
                    'privilege': info['privilege']
                })

        # Score and sort methods based on stealth requirements
        stealth_weights = {
            'low': 0.2,
            'medium': 0.5,
            'high': 0.8,
            'maximum': 1.0
        }

        stealth_weight = stealth_weights.get(stealth_level, 0.5)
        reliability_weight = 1.0 - stealth_weight

        for method in available_methods:
            method['score'] = (
                method['stealth'] * stealth_weight +
                method['reliability'] * reliability_weight
            )

        # Sort by score (descending)
        available_methods.sort(key=lambda x: x['score'], reverse=True)

        # Return top methods
        return available_methods[:count]

    def _privilege_sufficient(self, current: str, required: str) -> bool:
        """Check if current privilege level is sufficient for required level."""
        privilege_levels = {
            'user': 1,
            'admin': 2,
            'root': 3,
            'system': 4
        }

        current_level = privilege_levels.get(current, 1)
        required_level = privilege_levels.get(required, 1)

        return current_level >= required_level

    def _execute_persistence_method(self,
                                   target_os: str,
                                   method: str,
                                   payload_path: str,
                                   options: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a specific persistence method."""
        if target_os == 'windows' and self.windows_handler:
            return self.windows_handler.establish_persistence(payload_path, method, options)
        elif target_os == 'linux' and self.linux_handler:
            return self.linux_handler.establish_persistence(payload_path, method, options)
        else:
            return {
                'success': False,
                'error': f"No handler available for {target_os}"
            }

    def _remove_persistence_method(self, target_os: str, cleanup_info: Dict[str, Any]) -> bool:
        """Remove a specific persistence method."""
        if target_os == 'windows' and self.windows_handler:
            return self.windows_handler.remove_persistence(cleanup_info)
        elif target_os == 'linux' and self.linux_handler:
            return self.linux_handler.remove_persistence(cleanup_info)
        else:
            return False

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        import hashlib
        import random

        data = f"{time.time()}-{random.randint(1000, 9999)}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]

    def get_available_methods(self, target_os: Optional[str] = None) -> Dict[str, List[str]]:
        """Get list of available persistence methods by OS."""
        if target_os:
            if target_os in self.method_rankings:
                return {target_os: list(self.method_rankings[target_os].keys())}
            else:
                return {target_os: []}
        else:
            return {
                os: list(methods.keys())
                for os, methods in self.method_rankings.items()
            }

    def get_method_info(self, target_os: str, method: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a specific persistence method."""
        if target_os in self.method_rankings:
            return self.method_rankings[target_os].get(method)
        return None

    def recommend_methods(self,
                         target_os: str,
                         privilege_level: str,
                         stealth_level: str,
                         count: int = 3) -> List[Dict[str, Any]]:
        """Recommend optimal persistence methods for given criteria."""
        methods = self._select_persistence_methods(
            target_os, privilege_level, stealth_level, count
        )

        # Add detailed recommendations
        recommendations = []
        for method in methods:
            method_name = method['method']
            method_info = self.get_method_info(target_os, method_name)

            recommendations.append({
                'method': method_name,
                'score': method['score'],
                'stealth_score': method['stealth'],
                'reliability_score': method['reliability'],
                'privilege_required': method['privilege'],
                'description': self._get_method_description(target_os, method_name),
                'pros': self._get_method_pros(target_os, method_name),
                'cons': self._get_method_cons(target_os, method_name)
            })

        return recommendations

    def _get_method_description(self, target_os: str, method: str) -> str:
        """Get description of persistence method."""
        descriptions = {
            'windows': {
                'registry_run': 'Registry Run key persistence - executes on user login',
                'scheduled_task': 'Windows Task Scheduler persistence',
                'service': 'Windows service persistence with auto-start',
                'wmi_event': 'WMI event subscription persistence',
                'dll_hijacking': 'DLL hijacking for application persistence',
                'com_hijacking': 'COM object hijacking persistence',
                'startup_folder': 'Startup folder persistence',
                'accessibility_feature': 'Accessibility feature replacement',
                'winlogon_helper': 'Winlogon helper persistence',
                'image_file_execution': 'Image File Execution Options debugger',
                'lsa_security_package': 'LSA security package persistence'
            },
            'linux': {
                'systemd_service': 'Systemd service unit persistence',
                'init_d_service': 'Init.d service script persistence',
                'cron_job': 'Cron job scheduling persistence',
                'shell_profile': 'Shell profile script persistence',
                'desktop_autostart': 'Desktop autostart application persistence',
                'kernel_module': 'Kernel module persistence',
                'library_preload': 'LD_PRELOAD library persistence',
                'ssh_authorized_keys': 'SSH authorized keys persistence',
                'udev_rules': 'Udev rules persistence',
                'motd_script': 'Message of the day script persistence',
                'pam_module': 'PAM module persistence'
            }
        }

        return descriptions.get(target_os, {}).get(method, 'Unknown method')

    def _get_method_pros(self, target_os: str, method: str) -> List[str]:
        """Get advantages of persistence method."""
        self.logger.debug(f"Getting pros for {target_os} method: {method}")

        pros_database = {
            'windows': {
                'registry_run': ["Simple to implement", "Executes on every user login", "Low resource usage"],
                'scheduled_task': ["Flexible timing options", "Can run with elevated privileges", "Built-in Windows feature"],
                'service': ["Runs at system startup", "High privilege execution", "Automatic restart on failure"],
                'wmi_event': ["Very stealthy", "Event-driven execution", "Hard to detect"],
                'dll_hijacking': ["Leverages legitimate applications", "No new processes", "Difficult to detect"],
                'com_hijacking': ["Exploits COM registration", "Application-specific triggers", "Stealthy execution"],
                'startup_folder': ["Easy to implement", "User-level persistence", "Cross-application compatibility"],
                'accessibility_feature': ["System-level execution", "Pre-authentication access", "Always available"],
                'winlogon_helper': ["Early boot execution", "System privileges", "Persistent across reboots"],
                'image_file_execution': ["Intercepts application launches", "System-level persistence", "Hard to bypass"],
                'lsa_security_package': ["Highest privilege level", "Deep system integration", "Very difficult to detect"]
            },
            'linux': {
                'systemd_service': ["Modern init system", "Dependency management", "Automatic restart capabilities"],
                'init_d_service': ["Traditional service management", "System-wide availability", "Boot-time execution"],
                'cron_job': ["Flexible scheduling", "User and system level", "Built-in functionality"],
                'shell_profile': ["Executes on login", "User-specific", "Easy to implement"],
                'desktop_autostart': ["GUI application persistence", "User-friendly", "Cross-desktop compatibility"],
                'kernel_module': ["Deepest system access", "Very difficult to detect", "Full system control"],
                'library_preload': ["Transparent to applications", "No binary modification", "Flexible targeting"],
                'ssh_authorized_keys': ["Remote access persistence", "Cryptographically secured", "Standard protocol"],
                'udev_rules': ["Hardware event triggers", "Automatic execution", "System-level privileges"],
                'motd_script': ["Executes on SSH login", "Administrative visibility", "Simple implementation"],
                'pam_module': ["Authentication integration", "User session hooks", "System-wide coverage"]
            }
        }

        return pros_database.get(target_os, {}).get(method, ["Method-specific advantages", "Reliable execution", "Good compatibility"])

    def _get_method_cons(self, target_os: str, method: str) -> List[str]:
        """Get disadvantages of persistence method."""
        self.logger.debug(f"Getting cons for {target_os} method: {method}")

        cons_database = {
            'windows': {
                'registry_run': ["Easily detected by security tools", "Limited to user-level execution", "Obvious registry location"],
                'scheduled_task': ["Visible in Task Scheduler", "Requires task creation privileges", "Logged by Windows"],
                'service': ["Requires administrative privileges", "Visible in service manager", "May trigger security alerts"],
                'wmi_event': ["Requires administrative privileges", "Complex implementation", "May be unstable"],
                'dll_hijacking': ["Application-specific", "May break legitimate functionality", "Requires target application"],
                'com_hijacking': ["Application-specific", "May affect system stability", "Registry modifications tracked"],
                'startup_folder': ["Easily discovered by users", "User-level only", "Obvious persistence location"],
                'accessibility_feature': ["Requires system file modification", "May be detected by file integrity", "Affects accessibility"],
                'winlogon_helper': ["Requires administrative privileges", "Registry modifications logged", "May affect logon process"],
                'image_file_execution': ["Requires administrative privileges", "May break application functionality", "Registry changes tracked"],
                'lsa_security_package': ["Requires system privileges", "Complex implementation", "High detection risk if discovered"]
            },
            'linux': {
                'systemd_service': ["Requires systemd system", "Service files easily visible", "May require root privileges"],
                'init_d_service': ["Legacy system dependency", "May require root privileges", "Service scripts visible"],
                'cron_job': ["Cron entries logged", "Time-based execution only", "May be monitored"],
                'shell_profile': ["User-specific only", "Visible in profile files", "Limited to shell sessions"],
                'desktop_autostart': ["GUI-dependent", "User-level only", "Autostart files visible"],
                'kernel_module': ["Requires root privileges", "Complex implementation", "Kernel version dependent"],
                'library_preload': ["May break applications", "Environment variable dependent", "Library version compatibility"],
                'ssh_authorized_keys': ["SSH-specific only", "Key files may be monitored", "Requires SSH access"],
                'udev_rules': ["Requires root privileges", "Hardware event dependent", "Rule files visible"],
                'motd_script': ["SSH login dependent", "Script files visible", "May require administrative access"],
                'pam_module': ["Requires root privileges", "Complex configuration", "May affect authentication"]
            }
        }

        return cons_database.get(target_os, {}).get(method, ["Method-specific limitations", "May require elevated privileges", "Platform dependent"])

    def get_default_method(self) -> str:
        """Get the default persistence method for this platform."""
        from ...utils.system.os_detection import get_default_persistence_method
        return get_default_persistence_method()

    def list_available_methods(self) -> list:
        """List all available persistence methods for this platform."""
        from ...utils.system.os_detection import is_windows
        if is_windows() and self.windows_handler:
            return self.windows_handler.list_available_methods()
        elif not is_windows() and self.linux_handler:
            return self.linux_handler.list_available_methods()
        else:
            return []
