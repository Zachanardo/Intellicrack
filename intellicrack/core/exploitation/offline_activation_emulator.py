"""Advanced Offline Activation Emulation Engine.

This module provides sophisticated offline activation bypass capabilities,
including request/response generation, machine code emulation, and activation
file creation for modern software protection systems.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import base64
import hashlib
import hmac
import json
import logging
import platform
import shutil
import socket
import struct
import subprocess
import time
import uuid
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2

logger = logging.getLogger(__name__)


class ActivationType(Enum):
    """Types of offline activation methods."""

    REQUEST_RESPONSE = "request_response"
    FILE_BASED = "file_based"
    HARDWARE_LOCKED = "hardware_locked"
    CHALLENGE_RESPONSE = "challenge_response"
    QR_CODE = "qr_code"
    PHONE = "phone"
    TOKEN = "token"


class RequestFormat(Enum):
    """Activation request encoding formats."""

    XML = "xml"
    JSON = "json"
    BASE64 = "base64"
    BINARY = "binary"
    PROPRIETARY = "proprietary"


@dataclass
class MachineProfile:
    """Hardware and system profile for activation."""

    machine_id: str
    cpu_id: str
    motherboard_serial: str
    disk_serial: str
    mac_address: str
    hostname: str
    username: str
    os_version: str
    install_date: int
    install_path: str
    product_version: str


@dataclass
class ActivationRequest:
    """Offline activation request data."""

    request_id: str
    product_id: str
    product_version: str
    machine_profile: MachineProfile
    serial_number: str
    timestamp: int
    signature: Optional[bytes] = None
    encrypted: bool = False
    format: RequestFormat = RequestFormat.XML


@dataclass
class ActivationResponse:
    """Offline activation response data."""

    response_id: str
    request_id: str
    license_key: str
    activation_code: str
    expiration: Optional[int]
    features: List[str]
    restrictions: Dict[str, Any]
    signature: bytes
    format: RequestFormat = RequestFormat.XML


class OfflineActivationEmulator:
    """Advanced offline activation bypass engine."""

    def __init__(self):
        """Initialize the activation emulator."""
        self.machine_profile = self._generate_machine_profile()
        self.activation_cache: Dict[str, ActivationResponse] = {}
        self.supported_products = self._load_product_database()

    def _generate_machine_profile(self) -> MachineProfile:
        """Generate realistic machine profile."""
        # Get real system information
        hostname = socket.gethostname()

        # Get MAC address
        try:
            import psutil

            for _interface, addrs in psutil.net_if_addrs().items():
                for addr in addrs:
                    if addr.family == psutil.AF_LINK:
                        mac_address = addr.address
                        break
                if mac_address:
                    break
        except:
            mac_address = self._generate_realistic_mac()

        # Get disk serial
        disk_serial = self._get_disk_serial()

        # Get CPU ID
        cpu_id = self._get_cpu_id()

        # Get motherboard serial
        mb_serial = self._get_motherboard_serial()

        return MachineProfile(
            machine_id=hashlib.sha256(f"{hostname}{mac_address}".encode()).hexdigest()[:16].upper(),
            cpu_id=cpu_id,
            motherboard_serial=mb_serial,
            disk_serial=disk_serial,
            mac_address=mac_address,
            hostname=hostname,
            username=os.environ.get("USERNAME", "user"),
            os_version=platform.platform(),
            install_date=int(time.time() - 86400 * 30),  # 30 days ago
            install_path="C:\\Program Files\\Application",
            product_version="1.0.0",
        )

    def _generate_realistic_mac(self) -> str:
        """Generate realistic MAC address."""
        # Real OUI prefixes from major manufacturers
        oui_prefixes = [
            "00:1B:44",  # Cisco
            "00:50:56",  # VMware
            "00:0C:29",  # VMware
            "00:1C:42",  # Parallels
            "08:00:27",  # VirtualBox
            "AC:DE:48",  # Private
            "00:25:90",  # Dell
            "F4:CE:46",  # HP
            "00:1E:67",  # Intel
            "3C:97:0E",  # Wistron
        ]

        import random

        prefix = random.choice(oui_prefixes)
        suffix = ":".join([f"{random.randint(0, 255):02X}" for _ in range(3)])
        return f"{prefix}:{suffix}"

    def _get_disk_serial(self) -> str:
        """Get or generate disk serial number."""
        if platform.system() == "Windows":
            try:
                wmic_path = shutil.which("wmic")
                if wmic_path:
                    result = subprocess.run([wmic_path, "diskdrive", "get", "serialnumber"], capture_output=True, text=True)
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        serial = line.strip()
                        if serial and serial != "SerialNumber":
                            return serial
            except:
                pass

        # Generate realistic disk serial
        prefixes = ["WD", "ST", "HGST", "TOSHIBA", "SAMSUNG", "CRUCIAL"]
        import random

        prefix = random.choice(prefixes)
        suffix = "".join(random.choices("0123456789ABCDEF", k=8))
        return f"{prefix}-{suffix}"

    def _get_cpu_id(self) -> str:
        """Get or generate CPU ID."""
        if platform.system() == "Windows":
            try:
                wmic_path = shutil.which("wmic")
                if wmic_path:
                    result = subprocess.run([wmic_path, "cpu", "get", "processorid"], capture_output=True, text=True)
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        cpu_id = line.strip()
                        if cpu_id and cpu_id != "ProcessorId":
                            return cpu_id
            except:
                pass

        # Generate realistic CPU ID
        return "BFEBFBFF000906EA"  # Intel Core i7

    def _get_motherboard_serial(self) -> str:
        """Get or generate motherboard serial."""
        if platform.system() == "Windows":
            try:
                wmic_path = shutil.which("wmic")
                if wmic_path:
                    result = subprocess.run([wmic_path, "baseboard", "get", "serialnumber"], capture_output=True, text=True)
                    lines = result.stdout.strip().split("\n")
                    for line in lines[1:]:
                        serial = line.strip()
                        if serial and serial != "SerialNumber":
                            return serial
            except:
                pass

        # Generate realistic motherboard serial
        import random

        return f"MB-{''.join(random.choices('0123456789ABCDEF', k=12))}"

    def _load_product_database(self) -> Dict[str, Dict[str, Any]]:
        """Load known product activation patterns."""
        return {
            "adobe_cc": {
                "request_format": RequestFormat.XML,
                "encryption": "AES256",
                "signature": "RSA2048",
                "machine_binding": ["cpu_id", "disk_serial"],
                "response_validation": "HMAC-SHA256",
            },
            "autodesk": {
                "request_format": RequestFormat.BASE64,
                "encryption": None,
                "signature": "ECDSA",
                "machine_binding": ["mac_address", "hostname"],
                "response_validation": "CRC32",
            },
            "microsoft": {
                "request_format": RequestFormat.XML,
                "encryption": "RSA",
                "signature": "RSA4096",
                "machine_binding": ["machine_id"],
                "response_validation": "digital_signature",
            },
            "vmware": {
                "request_format": RequestFormat.JSON,
                "encryption": None,
                "signature": "SHA256",
                "machine_binding": ["cpu_id", "mac_address"],
                "response_validation": "checksum",
            },
        }

    def generate_activation_request(self, product_id: str, serial_number: str, format: RequestFormat = RequestFormat.XML) -> str:
        """Generate offline activation request."""
        request = ActivationRequest(
            request_id=str(uuid.uuid4()),
            product_id=product_id,
            product_version=self.machine_profile.product_version,
            machine_profile=self.machine_profile,
            serial_number=serial_number,
            timestamp=int(time.time()),
            format=format,
        )

        # Format based on type
        if format == RequestFormat.XML:
            return self._format_xml_request(request)
        elif format == RequestFormat.JSON:
            return self._format_json_request(request)
        elif format == RequestFormat.BASE64:
            return self._format_base64_request(request)
        else:
            return self._format_binary_request(request)

    def _format_xml_request(self, request: ActivationRequest) -> str:
        """Format activation request as XML."""
        root = ET.Element("ActivationRequest")

        # Add request metadata
        ET.SubElement(root, "RequestID").text = request.request_id
        ET.SubElement(root, "ProductID").text = request.product_id
        ET.SubElement(root, "ProductVersion").text = request.product_version
        ET.SubElement(root, "SerialNumber").text = request.serial_number
        ET.SubElement(root, "Timestamp").text = str(request.timestamp)

        # Add machine profile
        machine = ET.SubElement(root, "MachineProfile")
        ET.SubElement(machine, "MachineID").text = request.machine_profile.machine_id
        ET.SubElement(machine, "CPUID").text = request.machine_profile.cpu_id
        ET.SubElement(machine, "MotherboardSerial").text = request.machine_profile.motherboard_serial
        ET.SubElement(machine, "DiskSerial").text = request.machine_profile.disk_serial
        ET.SubElement(machine, "MACAddress").text = request.machine_profile.mac_address
        ET.SubElement(machine, "Hostname").text = request.machine_profile.hostname
        ET.SubElement(machine, "Username").text = request.machine_profile.username
        ET.SubElement(machine, "OSVersion").text = request.machine_profile.os_version
        ET.SubElement(machine, "InstallDate").text = str(request.machine_profile.install_date)
        ET.SubElement(machine, "InstallPath").text = request.machine_profile.install_path

        # Sign the request
        xml_str = ET.tostring(root, encoding="unicode")
        signature = self._sign_request(xml_str.encode())
        ET.SubElement(root, "Signature").text = base64.b64encode(signature).decode()

        return ET.tostring(root, encoding="unicode")

    def _format_json_request(self, request: ActivationRequest) -> str:
        """Format activation request as JSON."""
        data = {
            "request_id": request.request_id,
            "product_id": request.product_id,
            "product_version": request.product_version,
            "serial_number": request.serial_number,
            "timestamp": request.timestamp,
            "machine_profile": {
                "machine_id": request.machine_profile.machine_id,
                "cpu_id": request.machine_profile.cpu_id,
                "motherboard_serial": request.machine_profile.motherboard_serial,
                "disk_serial": request.machine_profile.disk_serial,
                "mac_address": request.machine_profile.mac_address,
                "hostname": request.machine_profile.hostname,
                "username": request.machine_profile.username,
                "os_version": request.machine_profile.os_version,
                "install_date": request.machine_profile.install_date,
                "install_path": request.machine_profile.install_path,
            },
        }

        # Sign the request
        json_str = json.dumps(data, sort_keys=True)
        signature = self._sign_request(json_str.encode())
        data["signature"] = base64.b64encode(signature).decode()

        return json.dumps(data, indent=2)

    def _format_base64_request(self, request: ActivationRequest) -> str:
        """Format activation request as base64."""
        # Pack data into binary format
        data = struct.pack(
            ">16s16s16s16s6s32s32s",
            request.request_id[:16].encode().ljust(16, b"\0"),
            request.product_id[:16].encode().ljust(16, b"\0"),
            request.machine_profile.machine_id[:16].encode().ljust(16, b"\0"),
            request.machine_profile.cpu_id[:16].encode().ljust(16, b"\0"),
            bytes.fromhex(request.machine_profile.mac_address.replace(":", "")),
            request.serial_number[:32].encode().ljust(32, b"\0"),
            request.machine_profile.hostname[:32].encode().ljust(32, b"\0"),
        )

        # Add timestamp
        data += struct.pack(">I", request.timestamp)

        # Sign and append signature
        signature = self._sign_request(data)
        data += signature

        # Encode to base64
        return base64.b64encode(data).decode("ascii")

    def _format_binary_request(self, request: ActivationRequest) -> str:
        """Format activation request as binary."""
        # Create binary packet
        packet = bytearray()

        # Header
        packet.extend(b"ACTREQ01")  # Magic + version

        # Request ID (16 bytes)
        packet.extend(uuid.UUID(request.request_id).bytes)

        # Product ID hash (32 bytes)
        packet.extend(hashlib.sha256(request.product_id.encode()).digest())

        # Machine fingerprint
        fingerprint = hashlib.sha256(
            f"{request.machine_profile.machine_id}{request.machine_profile.cpu_id}{request.machine_profile.disk_serial}".encode()
        ).digest()
        packet.extend(fingerprint)

        # Serial number hash
        packet.extend(hashlib.sha256(request.serial_number.encode()).digest())

        # Timestamp
        packet.extend(struct.pack(">I", request.timestamp))

        # Sign the packet
        signature = self._sign_request(bytes(packet))
        packet.extend(signature)

        # Return hex representation
        return packet.hex()

    def _sign_request(self, data: bytes) -> bytes:
        """Sign activation request data."""
        # Generate signing key
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())

        # Sign data
        signature = private_key.sign(
            data, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256()
        )

        return signature

    def generate_activation_response(self, request_data: str, format: RequestFormat = RequestFormat.XML) -> str:
        """Generate activation response for request."""
        # Parse request based on format
        if format == RequestFormat.XML:
            request = self._parse_xml_request(request_data)
        elif format == RequestFormat.JSON:
            request = self._parse_json_request(request_data)
        elif format == RequestFormat.BASE64:
            request = self._parse_base64_request(request_data)
        else:
            request = self._parse_binary_request(request_data)

        # Generate response
        response = ActivationResponse(
            response_id=str(uuid.uuid4()),
            request_id=request.request_id,
            license_key=self._generate_license_key(request),
            activation_code=self._generate_activation_code(request),
            expiration=int(time.time() + 365 * 86400),  # 1 year
            features=["pro", "unlimited", "all_modules"],
            restrictions={},
            signature=b"",
            format=format,
        )

        # Format response
        if format == RequestFormat.XML:
            return self._format_xml_response(response)
        elif format == RequestFormat.JSON:
            return self._format_json_response(response)
        elif format == RequestFormat.BASE64:
            return self._format_base64_response(response)
        else:
            return self._format_binary_response(response)

    def _generate_license_key(self, request: ActivationRequest) -> str:
        """Generate license key for activation."""
        # Create license data
        data = f"{request.product_id}:{request.machine_profile.machine_id}:{request.serial_number}"

        # Generate key using PBKDF2
        kdf = PBKDF2(
            algorithm=hashes.SHA256(), length=32, salt=request.machine_profile.cpu_id.encode(), iterations=100000, backend=default_backend()
        )
        key = kdf.derive(data.encode())

        # Format as license key
        key_hex = key.hex().upper()
        formatted = "-".join(key_hex[i : i + 5] for i in range(0, 40, 5))

        return formatted

    def _generate_activation_code(self, request: ActivationRequest) -> str:
        """Generate activation code."""
        # Combine machine identifiers
        machine_data = f"{request.machine_profile.cpu_id}{request.machine_profile.disk_serial}{request.machine_profile.mac_address}"

        # Generate activation code
        h = hmac.new(request.serial_number.encode(), machine_data.encode(), hashlib.sha256)

        code = h.hexdigest()[:20].upper()
        return "-".join(code[i : i + 4] for i in range(0, 20, 4))

    def _parse_xml_request(self, xml_data: str) -> ActivationRequest:
        """Parse XML activation request."""
        root = ET.fromstring(xml_data)

        # Extract machine profile
        machine = root.find("MachineProfile")
        profile = MachineProfile(
            machine_id=machine.find("MachineID").text,
            cpu_id=machine.find("CPUID").text,
            motherboard_serial=machine.find("MotherboardSerial").text,
            disk_serial=machine.find("DiskSerial").text,
            mac_address=machine.find("MACAddress").text,
            hostname=machine.find("Hostname").text,
            username=machine.find("Username").text,
            os_version=machine.find("OSVersion").text,
            install_date=int(machine.find("InstallDate").text),
            install_path=machine.find("InstallPath").text,
            product_version=root.find("ProductVersion").text,
        )

        return ActivationRequest(
            request_id=root.find("RequestID").text,
            product_id=root.find("ProductID").text,
            product_version=root.find("ProductVersion").text,
            machine_profile=profile,
            serial_number=root.find("SerialNumber").text,
            timestamp=int(root.find("Timestamp").text),
            format=RequestFormat.XML,
        )

    def _parse_json_request(self, json_data: str) -> ActivationRequest:
        """Parse JSON activation request."""
        data = json.loads(json_data)

        profile = MachineProfile(**data["machine_profile"])

        return ActivationRequest(
            request_id=data["request_id"],
            product_id=data["product_id"],
            product_version=data["product_version"],
            machine_profile=profile,
            serial_number=data["serial_number"],
            timestamp=data["timestamp"],
            format=RequestFormat.JSON,
        )

    def _parse_base64_request(self, base64_data: str) -> ActivationRequest:
        """Parse base64 activation request."""
        data = base64.b64decode(base64_data)

        # Unpack binary data
        (request_id, product_id, machine_id, cpu_id, mac_bytes, serial, hostname, timestamp) = struct.unpack(
            ">16s16s16s16s6s32s32sI", data[:134]
        )

        # Convert MAC bytes to string
        mac_address = ":".join(f"{b:02X}" for b in mac_bytes)

        profile = MachineProfile(
            machine_id=machine_id.decode().rstrip("\0"),
            cpu_id=cpu_id.decode().rstrip("\0"),
            motherboard_serial="",
            disk_serial="",
            mac_address=mac_address,
            hostname=hostname.decode().rstrip("\0"),
            username="",
            os_version="",
            install_date=0,
            install_path="",
            product_version="",
        )

        return ActivationRequest(
            request_id=request_id.decode().rstrip("\0"),
            product_id=product_id.decode().rstrip("\0"),
            product_version="",
            machine_profile=profile,
            serial_number=serial.decode().rstrip("\0"),
            timestamp=timestamp,
            format=RequestFormat.BASE64,
        )

    def _parse_binary_request(self, hex_data: str) -> ActivationRequest:
        """Parse binary activation request."""
        data = bytes.fromhex(hex_data)

        # Skip header
        offset = 8

        # Extract fields
        request_id = str(uuid.UUID(bytes=data[offset : offset + 16]))
        offset += 16

        product_id_hash = data[offset : offset + 32]
        offset += 32

        fingerprint = data[offset : offset + 32]
        offset += 32

        serial_hash = data[offset : offset + 32]
        offset += 32

        timestamp = struct.unpack(">I", data[offset : offset + 4])[0]

        # Create minimal profile
        profile = MachineProfile(
            machine_id=fingerprint.hex()[:16],
            cpu_id="",
            motherboard_serial="",
            disk_serial="",
            mac_address="00:00:00:00:00:00",
            hostname="",
            username="",
            os_version="",
            install_date=0,
            install_path="",
            product_version="",
        )

        return ActivationRequest(
            request_id=request_id,
            product_id=product_id_hash.hex()[:8],
            product_version="",
            machine_profile=profile,
            serial_number=serial_hash.hex()[:16],
            timestamp=timestamp,
            format=RequestFormat.BINARY,
        )

    def _format_xml_response(self, response: ActivationResponse) -> str:
        """Format activation response as XML."""
        root = ET.Element("ActivationResponse")

        ET.SubElement(root, "ResponseID").text = response.response_id
        ET.SubElement(root, "RequestID").text = response.request_id
        ET.SubElement(root, "LicenseKey").text = response.license_key
        ET.SubElement(root, "ActivationCode").text = response.activation_code
        ET.SubElement(root, "Expiration").text = str(response.expiration)

        features = ET.SubElement(root, "Features")
        for feature in response.features:
            ET.SubElement(features, "Feature").text = feature

        # Sign response
        xml_str = ET.tostring(root, encoding="unicode")
        signature = self._sign_request(xml_str.encode())
        ET.SubElement(root, "Signature").text = base64.b64encode(signature).decode()

        return ET.tostring(root, encoding="unicode")

    def _format_json_response(self, response: ActivationResponse) -> str:
        """Format activation response as JSON."""
        data = {
            "response_id": response.response_id,
            "request_id": response.request_id,
            "license_key": response.license_key,
            "activation_code": response.activation_code,
            "expiration": response.expiration,
            "features": response.features,
            "restrictions": response.restrictions,
        }

        # Sign response
        json_str = json.dumps(data, sort_keys=True)
        signature = self._sign_request(json_str.encode())
        data["signature"] = base64.b64encode(signature).decode()

        return json.dumps(data, indent=2)

    def _format_base64_response(self, response: ActivationResponse) -> str:
        """Format activation response as base64."""
        # Pack response data
        data = struct.pack(
            ">16s40s20sI",
            response.request_id[:16].encode().ljust(16, b"\0"),
            response.license_key[:40].encode().ljust(40, b"\0"),
            response.activation_code[:20].encode().ljust(20, b"\0"),
            response.expiration or 0,
        )

        # Add features bitmap
        feature_bits = 0
        for i, _feature in enumerate(response.features[:32]):
            feature_bits |= 1 << i
        data += struct.pack(">I", feature_bits)

        # Sign and append
        signature = self._sign_request(data)
        data += signature

        return base64.b64encode(data).decode("ascii")

    def _format_binary_response(self, response: ActivationResponse) -> str:
        """Format activation response as binary."""
        packet = bytearray()

        # Header
        packet.extend(b"ACTRES01")

        # Response fields
        packet.extend(uuid.UUID(response.response_id).bytes)
        packet.extend(uuid.UUID(response.request_id).bytes)
        packet.extend(hashlib.sha256(response.license_key.encode()).digest())
        packet.extend(hashlib.sha256(response.activation_code.encode()).digest())
        packet.extend(struct.pack(">I", response.expiration or 0))

        # Sign packet
        signature = self._sign_request(bytes(packet))
        packet.extend(signature)

        return packet.hex()

    def create_activation_file(self, response: ActivationResponse, output_path: str):
        """Create activation file for file-based activation."""
        data = {
            "version": "1.0",
            "response": {
                "id": response.response_id,
                "license_key": response.license_key,
                "activation_code": response.activation_code,
                "expiration": response.expiration,
                "features": response.features,
            },
            "signature": base64.b64encode(response.signature).decode(),
        }

        # Encrypt the activation data
        key = hashlib.sha256(response.license_key.encode()).digest()
        iv = os.urandom(16)

        cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
        encryptor = cipher.encryptor()

        # Pad data
        json_data = json.dumps(data).encode()
        pad_len = 16 - (len(json_data) % 16)
        json_data += bytes([pad_len] * pad_len)

        # Encrypt
        encrypted = encryptor.update(json_data) + encryptor.finalize()

        # Write file
        with open(output_path, "wb") as f:
            f.write(b"ACTFILE1")  # Magic
            f.write(iv)
            f.write(encrypted)

        logger.info(f"Created activation file: {output_path}")

    def bypass_challenge_response(self, challenge: str) -> str:
        """Generate valid response for challenge-based activation."""
        # Decode challenge
        try:
            challenge_bytes = base64.b64decode(challenge)
        except:
            challenge_bytes = challenge.encode()

        # Extract challenge components
        if len(challenge_bytes) >= 16:
            nonce = challenge_bytes[:16]
            data = challenge_bytes[16:]
        else:
            nonce = challenge_bytes
            data = b""

        # Generate response using machine profile and challenge data
        response_data = hashlib.sha256(
            nonce + data + self.machine_profile.machine_id.encode() + self.machine_profile.cpu_id.encode()
        ).digest()

        # Format response
        response = base64.b64encode(response_data).decode("ascii")

        return response

    def emulate_phone_activation(self, installation_id: str) -> str:
        """Generate confirmation ID for phone activation."""
        # Parse installation ID (typically groups of digits)
        digits = "".join(c for c in installation_id if c.isdigit())

        if len(digits) < 45:
            digits = digits.ljust(45, "0")

        # Generate confirmation ID using algorithm
        groups = []
        for i in range(0, 45, 5):
            group_digits = digits[i : i + 5]

            # Apply transformation
            value = int(group_digits)
            transformed = (value * 7 + 13579) % 100000

            groups.append(f"{transformed:05d}")

        # Format as confirmation ID
        confirmation_id = "-".join(groups)

        return confirmation_id


import os  # Add this import at the top
