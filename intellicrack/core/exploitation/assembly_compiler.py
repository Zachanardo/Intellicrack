"""
This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import struct
from typing import Dict, List, Tuple

from .payload_types import Architecture
from ...utils.logger import get_logger

"""
Assembly Compiler for Payload Generation

Compiles assembly code to machine code with support for multiple architectures
and position-independent code generation.
"""


class AssemblyCompiler:
    """
    Advanced assembly compiler with support for multiple architectures
    and position-independent code generation.
    """

    def __init__(self):
        """Initialize the assembly compiler with architecture detection and tool configuration."""
        self.logger = get_logger(__name__)
        self.nasm_path = self._find_assembler_path()
        self.gas_path = self._find_gas_path()
        self.ml_path = self._find_ml_path()

        # Architecture configurations
        self.arch_configs = {
            "x86": {
                "bits": 32,
                "assembler": "nasm",
                "format": "elf32"
            },
            "x64": {
                "bits": 64,
                "assembler": "nasm",
                "format": "elf64"
            },
            "arm": {
                "bits": 32,
                "assembler": "gas",
                "format": "elf"
            },
            "arm64": {
                "bits": 64,
                "assembler": "gas",
                "format": "elf64"
            }
        }

        self.current_arch = self._detect_architecture()
        self.temp_files = []

    def compile_assembly(self,
                        assembly_code: str,
                        architecture: Architecture,
                        position_independent: bool = True) -> bytes:
        """
        Compile assembly code to machine code.

        Args:
            assembly_code: Assembly source code
            architecture: Target architecture
            position_independent: Generate position-independent code

        Returns:
            Compiled machine code
        """
        try:
            self.logger.info(f"Compiling assembly for {architecture.value}")

            # Preprocess assembly code
            processed_code = self._preprocess_assembly(assembly_code)

            # Parse instructions
            instructions = self._parse_instructions(processed_code)

            # Resolve labels and calculate offsets
            labels, resolved_instructions = self._resolve_labels(instructions)

            # Compile to machine code
            machine_code = self._compile_instructions(
                resolved_instructions,
                architecture,
                labels,
                position_independent
            )

            self.logger.info(f"Compiled {len(instructions)} instructions to {len(machine_code)} bytes")
            return machine_code

        except Exception as e:
            self.logger.error(f"Assembly compilation failed: {e}")
            raise

    def _preprocess_assembly(self, assembly_code: str) -> str:
        """Preprocess assembly code (remove comments, normalize whitespace)."""
        lines = []
        for line in assembly_code.split("\n"):
            # Remove comments
            if ";" in line:
                line = line[:line.index(";")]

            # Strip whitespace and skip empty lines
            line = line.strip()
            if line:
                lines.append(line)

        return "\n".join(lines)

    def _parse_instructions(self, assembly_code: str) -> List[Dict]:
        """Parse assembly code into instruction objects."""
        instructions = []

        for line_num, line in enumerate(assembly_code.split("\n"), 1):
            if not line.strip():
                continue

            # Check for labels
            if line.endswith(":"):
                instructions.append({
                    "type": "label",
                    "name": line[:-1],
                    "line": line_num
                })
                continue

            # Parse instruction
            parts = line.split()
            if not parts:
                continue

            mnemonic = parts[0].lower()
            operands = []

            if len(parts) > 1:
                # Join remaining parts and split by commas
                operand_str = " ".join(parts[1:])
                operands = [op.strip() for op in operand_str.split(",")]

            instructions.append({
                "type": "instruction",
                "mnemonic": mnemonic,
                "operands": operands,
                "line": line_num,
                "original": line
            })

        return instructions

    def _resolve_labels(self, instructions: List[Dict]) -> Tuple[Dict, List[Dict]]:
        """Resolve label references and calculate offsets."""
        labels = {}
        resolved_instructions = []
        current_offset = 0

        # First pass: collect labels
        for instruction in instructions:
            if instruction["type"] == "label":
                labels[instruction["name"]] = current_offset
            else:
                resolved_instructions.append(instruction)
                # Estimate instruction size (will be refined in compilation)
                current_offset += self._estimate_instruction_size(instruction)

        # Second pass: resolve label references
        current_offset = 0
        for instruction in resolved_instructions:
            instruction["offset"] = current_offset
            current_offset += self._estimate_instruction_size(instruction)

        return labels, resolved_instructions

    def _estimate_instruction_size(self, instruction: Dict) -> int:
        """Estimate the size of an instruction in bytes."""
        mnemonic = instruction["mnemonic"]
        operands = instruction["operands"]

        # Basic size estimates (this is simplified)
        if mnemonic in ["nop", "ret", "int3"]:
            return 1
        elif mnemonic in ["push", "pop"] and len(operands) == 1:
            return 1 if self._is_register(operands[0]) else 5
        elif mnemonic in ["mov", "xor", "add", "sub", "test", "cmp"]:
            return 2 if all(self._is_register(op) for op in operands) else 6
        elif mnemonic in ["call", "jmp"]:
            return 5  # Relative call/jump
        elif mnemonic.startswith("j"):  # Conditional jumps
            return 2  # Short jump, may need to be extended
        else:
            return 3  # Default estimate

    def _is_register(self, operand: str) -> bool:
        """Check if operand is a register."""
        return operand.lower() in self.x86_registers or operand.lower() in self.x64_registers

    def _compile_instructions(self,
                            instructions: List[Dict],
                            architecture: Architecture,
                            labels: Dict[str, int],
                            position_independent: bool) -> bytes:
        """Compile resolved instructions to machine code."""
        machine_code = b""

        if architecture == Architecture.X86:
            instruction_set = self.x86_instructions
        elif architecture == Architecture.X64:
            instruction_set = self.x64_instructions
        else:
            raise ValueError(f"Unsupported architecture: {architecture}")

        for instruction in instructions:
            mnemonic = instruction["mnemonic"]
            operands = instruction["operands"]

            if mnemonic in instruction_set:
                if callable(instruction_set[mnemonic]):
                    # Complex instruction requiring compilation function
                    compiled_bytes = instruction_set[mnemonic](
                        mnemonic, operands, labels, instruction["offset"], position_independent
                    )
                else:
                    # Simple instruction with direct byte mapping
                    compiled_bytes = instruction_set[mnemonic]

                machine_code += compiled_bytes
            else:
                self.logger.warning(f"Unknown instruction: {mnemonic}")
                # Add NOP as fallback
                machine_code += b"\x90"

        return machine_code

    # x86 instruction compilation methods
    def _compile_call_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 CALL instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        if len(operands) != 1:
            raise ValueError(f"{mnemonic} requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            # Call to label - use relative addressing for position independence
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 5)  # 5 = size of call instruction
            if position_independent:
                # Ensure we use relative addressing for position independent code
                return b"\xE8" + struct.pack("<i", relative_offset)
            else:
                return b"\xE8" + struct.pack("<i", relative_offset)
        elif operand.lower() in self.x86_registers:
            # Call register
            reg_code = self.x86_registers[operand.lower()]
            return b"\xFF" + bytes([0xD0 + reg_code])
        else:
            # Call immediate address
            try:
                address = int(operand, 16) if operand.startswith("0x") else int(operand)
                if position_independent:
                    # Use RIP-relative addressing for position independence
                    relative_offset = address - (current_offset + 6)  # 6 = size of RIP-relative call
                    return b"\xFF\x15" + struct.pack("<i", relative_offset)
                else:
                    # Use absolute addressing
                    return b"\xFF\x15" + struct.pack("<I", address)
            except ValueError as e:
                self.logger.error("Value error in assembly_compiler: %s", e)
                raise ValueError(f"Invalid call target: {operand}")

    def _compile_jmp_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 JMP instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        if len(operands) != 1:
            raise ValueError("JMP requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 5)
            return b"\xE9" + struct.pack("<i", relative_offset)
        elif operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return b"\xFF" + bytes([0xE0 + reg_code])
        else:
            try:
                address = int(operand, 16) if operand.startswith("0x") else int(operand)
                if position_independent:
                    # Use RIP-relative addressing for position independence
                    relative_offset = address - (current_offset + 6)
                    return b"\xFF\x25" + struct.pack("<i", relative_offset)
                else:
                    return b"\xFF\x25" + struct.pack("<I", address)
            except ValueError as e:
                self.logger.error("Value error in assembly_compiler: %s", e)
                raise ValueError(f"Invalid jump target: {operand}")

    def _compile_push_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 PUSH instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 1:
            raise ValueError("PUSH requires exactly one operand")

        operand = operands[0]

        # Check if operand references a label
        if operand in labels:
            self.logger.debug(f"PUSH operand '{operand}' references label at offset 0x{labels[operand]:04x}")

        if operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return bytes([0x50 + reg_code])
        else:
            # Push immediate value
            try:
                value = int(operand, 16) if operand.startswith("0x") else int(operand)
                # For position-independent code, log immediate value usage
                if position_independent and abs(value) > 0xFFFF:
                    self.logger.warning(f"Large immediate value 0x{value:x} in PIC code may cause relocation issues")

                if -128 <= value <= 127:
                    return b"\x6A" + struct.pack("<b", value)
                else:
                    return b"\x68" + struct.pack("<I", value & 0xFFFFFFFF)
            except ValueError as e:
                self.logger.error("Value error in assembly_compiler: %s", e)
                raise ValueError(f"Invalid push value: {operand}")

    def _compile_pop_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 POP instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 1:
            raise ValueError("POP requires exactly one operand")

        operand = operands[0]

        # Validate operand is not a label reference (POP doesn't support direct label addressing)
        if operand in labels:
            raise ValueError(f"POP cannot directly reference label '{operand}' - use register or memory operand")

        if operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return bytes([0x58 + reg_code])
        else:
            raise ValueError(f"Invalid pop target: {operand}")

    def _compile_mov_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 MOV instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("MOV requires exactly two operands")

        dst, src = operands

        # Check for label references in source operand
        if src in labels:
            self.logger.debug(f"MOV source '{src}' references label at offset 0x{labels[src]:04x}")
            if position_independent:
                self.logger.warning("MOV with label reference in PIC code - consider RIP-relative addressing")

        # MOV register, immediate
        if dst.lower() in self.x86_registers and src.lower() not in self.x86_registers:
            reg_code = self.x86_registers[dst.lower()]
            try:
                value = int(src, 16) if src.startswith("0x") else int(src)
                # For position-independent code, warn about absolute addresses
                if position_independent and value > 0xFFFF:
                    self.logger.warning(f"Absolute address 0x{value:x} in PIC code may need relocation")
                return bytes([0xB8 + reg_code]) + struct.pack("<I", value & 0xFFFFFFFF)
            except ValueError as e:
                self.logger.error("Value error in assembly_compiler: %s", e)
                pass

        # MOV register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x89" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported MOV instruction: {dst}, {src}")

    def _compile_xor_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 XOR instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("XOR requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (XOR doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(f"XOR operand {i+1} '{operand}' cannot directly reference label - use register or memory operand")

        # XOR register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x31" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported XOR instruction: {dst}, {src}")

    def _compile_add_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 ADD instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("ADD requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (ADD doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(f"ADD operand {i+1} '{operand}' cannot directly reference label - use register or memory operand")

        # ADD register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x01" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported ADD instruction: {dst}, {src}")

    def _compile_sub_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 SUB instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("SUB requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (SUB doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(f"SUB operand {i+1} '{operand}' cannot directly reference label - use register or memory operand")

        # SUB register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x29" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported SUB instruction: {dst}, {src}")

    def _compile_test_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 TEST instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("TEST requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (TEST doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(f"TEST operand {i+1} '{operand}' cannot directly reference label - use register or memory operand")

        # TEST register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x85" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported TEST instruction: {dst}, {src}")

    def _compile_cmp_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 CMP instruction."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")

        if len(operands) != 2:
            raise ValueError("CMP requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (CMP doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(f"CMP operand {i+1} '{operand}' cannot directly reference label - use register or memory operand")

        # CMP register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x39" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported CMP instruction: {dst}, {src}")

    def _compile_conditional_jump_x86(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                                     current_offset: int, position_independent: bool) -> bytes:
        """Compile x86 conditional jump instructions."""
        self.logger.debug(f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        if len(operands) != 1:
            raise ValueError("Conditional jump requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 2)  # 2 = size of short jump

            # Use short jump if possible
            if -128 <= relative_offset <= 127:
                jump_opcodes = {
                    "je": b"\x74", "jz": b"\x74",
                    "jne": b"\x75", "jnz": b"\x75",
                    "jl": b"\x7C", "jg": b"\x7F"
                }
                return jump_opcodes.get(mnemonic.lower(), b"\x74") + struct.pack("<b", relative_offset)
            else:
                # Use near jump
                relative_offset = target_offset - (current_offset + 6)  # 6 = size of near jump
                jump_opcodes = {
                    "je": b"\x0F\x84", "jz": b"\x0F\x84",
                    "jne": b"\x0F\x85", "jnz": b"\x0F\x85",
                    "jl": b"\x0F\x8C", "jg": b"\x0F\x8F"
                }
                return jump_opcodes.get(mnemonic.lower(), b"\x0F\x84") + struct.pack("<i", relative_offset)
        else:
            raise ValueError(f"Invalid jump target: {operand}")

    # x64 instruction compilation methods (simplified versions)
    def _compile_call_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 CALL instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_call_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_jmp_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 JMP instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_jmp_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_push_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 PUSH instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_push_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_pop_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 POP instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_pop_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_mov_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 MOV instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_mov_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_xor_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 XOR instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_xor_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_add_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 ADD instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_add_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_sub_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 SUB instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_sub_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_test_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                         current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 TEST instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_test_x86(mnemonic, operands, labels, current_offset, position_independent)

    def _compile_cmp_x64(self, mnemonic: str, operands: List[str], labels: Dict[str, int],
                        current_offset: int, position_independent: bool) -> bytes:
        """Compile x64 CMP instruction."""
        self.logger.debug(f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}")
        return self._compile_cmp_x86(mnemonic, operands, labels, current_offset, position_independent)
