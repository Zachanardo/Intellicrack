"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import struct

from ...utils.logger import get_logger
from .payload_types import Architecture

"""
Assembly Compiler for Payload Generation

Compiles assembly code to machine code with support for multiple architectures
and position-independent code generation.
"""


class AssemblyCompiler:
    """Advanced assembly compiler with support for multiple architectures
    and position-independent code generation.
    """

    def __init__(self):
        """Initialize the assembly compiler with architecture detection and tool configuration."""
        self.logger = get_logger(__name__)
        self.nasm_path = self._find_assembler_path()
        self.gas_path = self._find_gas_path()
        self.ml_path = self._find_ml_path()

        # Architecture configurations
        self.arch_configs = {
            "x86": {
                "bits": 32,
                "assembler": "nasm",
                "format": "elf32",
            },
            "x64": {
                "bits": 64,
                "assembler": "nasm",
                "format": "elf64",
            },
            "arm": {
                "bits": 32,
                "assembler": "gas",
                "format": "elf",
            },
            "arm64": {
                "bits": 64,
                "assembler": "gas",
                "format": "elf64",
            },
        }

        self.current_arch = self._detect_architecture()
        self.temp_files = []

    def compile_assembly(
        self, assembly_code: str, architecture: Architecture, position_independent: bool = True
    ) -> bytes:
        """Compile assembly code to machine code.

        Args:
            assembly_code: Assembly source code
            architecture: Target architecture
            position_independent: Generate position-independent code

        Returns:
            Compiled machine code

        """
        try:
            self.logger.info(f"Compiling assembly for {architecture.value}")

            # Preprocess assembly code
            processed_code = self._preprocess_assembly(assembly_code)

            # Parse instructions
            instructions = self._parse_instructions(processed_code)

            # Resolve labels and calculate offsets
            labels, resolved_instructions = self._resolve_labels(instructions)

            # Compile to machine code
            machine_code = self._compile_instructions(
                resolved_instructions,
                architecture,
                labels,
                position_independent,
            )

            self.logger.info(
                f"Compiled {len(instructions)} instructions to {len(machine_code)} bytes"
            )
            return machine_code

        except Exception as e:
            self.logger.error(f"Assembly compilation failed: {e}")
            raise

    def _preprocess_assembly(self, assembly_code: str) -> str:
        """Preprocess assembly code (remove comments, normalize whitespace)."""
        lines = []
        for line in assembly_code.split("\n"):
            # Remove comments
            if ";" in line:
                line = line[: line.index(";")]

            # Strip whitespace and skip empty lines
            line = line.strip()
            if line:
                lines.append(line)

        return "\n".join(lines)

    def _parse_instructions(self, assembly_code: str) -> list[dict]:
        """Parse assembly code into instruction objects."""
        instructions = []

        for line_num, line in enumerate(assembly_code.split("\n"), 1):
            if not line.strip():
                continue

            # Check for labels
            if line.endswith(":"):
                instructions.append(
                    {
                        "type": "label",
                        "name": line[:-1],
                        "line": line_num,
                    }
                )
                continue

            # Parse instruction
            parts = line.split()
            if not parts:
                continue

            mnemonic = parts[0].lower()
            operands = []

            if len(parts) > 1:
                # Join remaining parts and split by commas
                operand_str = " ".join(parts[1:])
                operands = [op.strip() for op in operand_str.split(",")]

            instructions.append(
                {
                    "type": "instruction",
                    "mnemonic": mnemonic,
                    "operands": operands,
                    "line": line_num,
                    "original": line,
                }
            )

        return instructions

    def _resolve_labels(self, instructions: list[dict]) -> tuple[dict, list[dict]]:
        """Resolve label references and calculate offsets."""
        labels = {}
        resolved_instructions = []
        current_offset = 0

        # First pass: collect labels
        for instruction in instructions:
            if instruction["type"] == "label":
                labels[instruction["name"]] = current_offset
            else:
                resolved_instructions.append(instruction)
                # Estimate instruction size (will be refined in compilation)
                current_offset += self._estimate_instruction_size(instruction)

        # Second pass: resolve label references
        current_offset = 0
        for instruction in resolved_instructions:
            instruction["offset"] = current_offset
            current_offset += self._estimate_instruction_size(instruction)

        return labels, resolved_instructions

    def _estimate_instruction_size(self, instruction: dict) -> int:
        """Estimate the size of an instruction in bytes."""
        mnemonic = instruction["mnemonic"]
        operands = instruction["operands"]

        # Basic size estimates (this is simplified)
        if mnemonic in ["nop", "ret", "int3"]:
            return 1
        if mnemonic in ["push", "pop"] and len(operands) == 1:
            return 1 if self._is_register(operands[0]) else 5
        if mnemonic in ["mov", "xor", "add", "sub", "test", "cmp"]:
            return 2 if all(self._is_register(op) for op in operands) else 6
        if mnemonic in ["call", "jmp"]:
            return 5  # Relative call/jump
        if mnemonic.startswith("j"):  # Conditional jumps
            return 2  # Short jump, may need to be extended
        return 3  # Default estimate

    def _is_register(self, operand: str) -> bool:
        """Check if operand is a register."""
        return operand.lower() in self.x86_registers or operand.lower() in self.x64_registers

    def _compile_instructions(
        self,
        instructions: list[dict],
        architecture: Architecture,
        labels: dict[str, int],
        position_independent: bool,
    ) -> bytes:
        """Compile resolved instructions to machine code."""
        machine_code = b""

        if architecture == Architecture.X86:
            instruction_set = self.x86_instructions
        elif architecture == Architecture.X64:
            instruction_set = self.x64_instructions
        else:
            raise ValueError(f"Unsupported architecture: {architecture}")

        for instruction in instructions:
            mnemonic = instruction["mnemonic"]
            operands = instruction["operands"]

            if mnemonic in instruction_set:
                if callable(instruction_set[mnemonic]):
                    # Complex instruction requiring compilation function
                    compiled_bytes = instruction_set[mnemonic](
                        mnemonic,
                        operands,
                        labels,
                        instruction["offset"],
                        position_independent,
                    )
                else:
                    # Simple instruction with direct byte mapping
                    compiled_bytes = instruction_set[mnemonic]

                machine_code += compiled_bytes
            else:
                self.logger.warning(f"Unknown instruction: {mnemonic}")
                # Add NOP as fallback
                machine_code += b"\x90"

        return machine_code

    # x86 instruction compilation methods
    def _compile_call_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 CALL instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        if len(operands) != 1:
            raise ValueError(f"{mnemonic} requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            # Call to label - use relative addressing for position independence
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 5)  # 5 = size of call instruction
            if position_independent:
                # Ensure we use relative addressing for position independent code
                return b"\xe8" + struct.pack("<i", relative_offset)
            return b"\xe8" + struct.pack("<i", relative_offset)
        if operand.lower() in self.x86_registers:
            # Call register
            reg_code = self.x86_registers[operand.lower()]
            return b"\xff" + bytes([0xD0 + reg_code])
        # Call immediate address
        try:
            address = int(operand, 16) if operand.startswith("0x") else int(operand)
            if position_independent:
                # Use RIP-relative addressing for position independence
                relative_offset = address - (current_offset + 6)  # 6 = size of RIP-relative call
                return b"\xff\x15" + struct.pack("<i", relative_offset)
            # Use absolute addressing
            return b"\xff\x15" + struct.pack("<I", address)
        except ValueError as e:
            self.logger.error("Value error in assembly_compiler: %s", e)
            raise ValueError(f"Invalid call target: {operand}") from e

    def _compile_jmp_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 JMP instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        if len(operands) != 1:
            raise ValueError("JMP requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 5)
            return b"\xe9" + struct.pack("<i", relative_offset)
        if operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return b"\xff" + bytes([0xE0 + reg_code])
        try:
            address = int(operand, 16) if operand.startswith("0x") else int(operand)
            if position_independent:
                # Use RIP-relative addressing for position independence
                relative_offset = address - (current_offset + 6)
                return b"\xff\x25" + struct.pack("<i", relative_offset)
            return b"\xff\x25" + struct.pack("<I", address)
        except ValueError as e:
            self.logger.error("Value error in assembly_compiler: %s", e)
            raise ValueError(f"Invalid jump target: {operand}") from e

    def _compile_push_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 PUSH instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 1:
            raise ValueError("PUSH requires exactly one operand")

        operand = operands[0]

        # Check if operand references a label
        if operand in labels:
            self.logger.debug(
                f"PUSH operand '{operand}' references label at offset 0x{labels[operand]:04x}"
            )

        if operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return bytes([0x50 + reg_code])
        # Push immediate value
        try:
            value = int(operand, 16) if operand.startswith("0x") else int(operand)
            # For position-independent code, log immediate value usage
            if position_independent and abs(value) > 0xFFFF:
                self.logger.warning(
                    f"Large immediate value 0x{value:x} in PIC code may cause relocation issues"
                )

            if -128 <= value <= 127:
                return b"\x6a" + struct.pack("<b", value)
            return b"\x68" + struct.pack("<I", value & 0xFFFFFFFF)
        except ValueError as e:
            self.logger.error("Value error in assembly_compiler: %s", e)
            raise ValueError(f"Invalid push value: {operand}") from e

    def _compile_pop_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 POP instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 1:
            raise ValueError("POP requires exactly one operand")

        operand = operands[0]

        # Validate operand is not a label reference (POP doesn't support direct label addressing)
        if operand in labels:
            raise ValueError(
                f"POP cannot directly reference label '{operand}' - use register or memory operand"
            )

        if operand.lower() in self.x86_registers:
            reg_code = self.x86_registers[operand.lower()]
            return bytes([0x58 + reg_code])
        raise ValueError(f"Invalid pop target: {operand}")

    def _compile_mov_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 MOV instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("MOV requires exactly two operands")

        dst, src = operands

        # Check for label references in source operand
        if src in labels:
            self.logger.debug(f"MOV source '{src}' references label at offset 0x{labels[src]:04x}")
            if position_independent:
                self.logger.warning(
                    "MOV with label reference in PIC code - consider RIP-relative addressing"
                )

        # MOV register, immediate
        if dst.lower() in self.x86_registers and src.lower() not in self.x86_registers:
            reg_code = self.x86_registers[dst.lower()]
            try:
                value = int(src, 16) if src.startswith("0x") else int(src)
                # For position-independent code, warn about absolute addresses
                if position_independent and value > 0xFFFF:
                    self.logger.warning(
                        f"Absolute address 0x{value:x} in PIC code may need relocation"
                    )
                return bytes([0xB8 + reg_code]) + struct.pack("<I", value & 0xFFFFFFFF)
            except ValueError as e:
                self.logger.error("Value error in assembly_compiler: %s", e)

        # MOV register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x89" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported MOV instruction: {dst}, {src}")

    def _compile_xor_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 XOR instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("XOR requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (XOR doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(
                    f"XOR operand {i+1} '{operand}' cannot directly reference label - use register or memory operand"
                )

        # XOR register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x31" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported XOR instruction: {dst}, {src}")

    def _compile_add_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 ADD instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("ADD requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (ADD doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(
                    f"ADD operand {i+1} '{operand}' cannot directly reference label - use register or memory operand"
                )

        # ADD register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x01" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported ADD instruction: {dst}, {src}")

    def _compile_sub_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 SUB instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("SUB requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (SUB doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(
                    f"SUB operand {i+1} '{operand}' cannot directly reference label - use register or memory operand"
                )

        # SUB register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x29" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported SUB instruction: {dst}, {src}")

    def _compile_test_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 TEST instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("TEST requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (TEST doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(
                    f"TEST operand {i+1} '{operand}' cannot directly reference label - use register or memory operand"
                )

        # TEST register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x85" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported TEST instruction: {dst}, {src}")

    def _compile_cmp_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 CMP instruction."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )

        if len(operands) != 2:
            raise ValueError("CMP requires exactly two operands")

        dst, src = operands

        # Validate operands don't reference labels (CMP doesn't support direct label addressing)
        for i, operand in enumerate([dst, src]):
            if operand in labels:
                raise ValueError(
                    f"CMP operand {i+1} '{operand}' cannot directly reference label - use register or memory operand"
                )

        # CMP register, register
        if dst.lower() in self.x86_registers and src.lower() in self.x86_registers:
            dst_code = self.x86_registers[dst.lower()]
            src_code = self.x86_registers[src.lower()]
            return b"\x39" + bytes([0xC0 + (src_code << 3) + dst_code])

        raise ValueError(f"Unsupported CMP instruction: {dst}, {src}")

    def _compile_conditional_jump_x86(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x86 conditional jump instructions."""
        self.logger.debug(
            f"Compiling {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        if len(operands) != 1:
            raise ValueError("Conditional jump requires exactly one operand")

        operand = operands[0]

        if operand in labels:
            target_offset = labels[operand]
            relative_offset = target_offset - (current_offset + 2)  # 2 = size of short jump

            # Use short jump if possible
            if -128 <= relative_offset <= 127:
                jump_opcodes = {
                    "je": b"\x74",
                    "jz": b"\x74",
                    "jne": b"\x75",
                    "jnz": b"\x75",
                    "jl": b"\x7c",
                    "jg": b"\x7f",
                }
                return jump_opcodes.get(mnemonic.lower(), b"\x74") + struct.pack(
                    "<b", relative_offset
                )
            # Use near jump
            relative_offset = target_offset - (current_offset + 6)  # 6 = size of near jump
            jump_opcodes = {
                "je": b"\x0f\x84",
                "jz": b"\x0f\x84",
                "jne": b"\x0f\x85",
                "jnz": b"\x0f\x85",
                "jl": b"\x0f\x8c",
                "jg": b"\x0f\x8f",
            }
            return jump_opcodes.get(mnemonic.lower(), b"\x0f\x84") + struct.pack(
                "<i", relative_offset
            )
        raise ValueError(f"Invalid jump target: {operand}")

    # x64 instruction compilation methods (simplified versions)
    def _compile_call_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 CALL instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_call_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_jmp_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 JMP instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_jmp_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_push_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 PUSH instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_push_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_pop_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 POP instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_pop_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_mov_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 MOV instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_mov_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_xor_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 XOR instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_xor_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_add_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 ADD instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_add_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_sub_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 SUB instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_sub_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_test_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 TEST instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_test_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _compile_cmp_x64(
        self,
        mnemonic: str,
        operands: list[str],
        labels: dict[str, int],
        current_offset: int,
        position_independent: bool,
    ) -> bytes:
        """Compile x64 CMP instruction."""
        self.logger.debug(
            f"Compiling x64 {mnemonic.upper()} at offset 0x{current_offset:04x}, PIC: {position_independent}"
        )
        return self._compile_cmp_x86(
            mnemonic, operands, labels, current_offset, position_independent
        )

    def _find_assembler_path(self) -> str | None:
        """Find the path to NASM assembler on the system.

        Returns:
            Path to NASM executable or None if not found

        """
        import os
        import platform
        import shutil

        # Common NASM executable names
        nasm_names = ["nasm", "nasm.exe"] if platform.system() == "Windows" else ["nasm"]

        # First check if NASM is in PATH
        for name in nasm_names:
            nasm_path = shutil.which(name)
            if nasm_path:
                self.logger.info(f"Found NASM at: {nasm_path}")
                return nasm_path

        # Check common installation directories
        common_paths = []
        if platform.system() == "Windows":
            common_paths = [
                r"C:\Program Files\NASM",
                r"C:\Program Files (x86)\NASM",
                r"C:\NASM",
                r"C:\Tools\NASM",
            ]
        else:
            common_paths = [
                "/usr/bin",
                "/usr/local/bin",
                "/opt/nasm/bin",
                "/opt/local/bin",
            ]

        for base_path in common_paths:
            for name in nasm_names:
                full_path = os.path.join(base_path, name)
                if os.path.exists(full_path) and os.access(full_path, os.X_OK):
                    self.logger.info(f"Found NASM at: {full_path}")
                    return full_path

        self.logger.warning("NASM assembler not found on system")
        return None

    def _find_gas_path(self) -> str | None:
        """Find the path to GNU Assembler (GAS) on the system.

        Returns:
            Path to GAS executable or None if not found

        """
        import os
        import platform
        import shutil

        # Common GAS executable names
        gas_names = ["as", "gas", "as.exe"] if platform.system() == "Windows" else ["as", "gas"]

        # First check if GAS is in PATH
        for name in gas_names:
            gas_path = shutil.which(name)
            if gas_path:
                self.logger.info(f"Found GAS at: {gas_path}")
                return gas_path

        # Check common installation directories
        common_paths = []
        if platform.system() == "Windows":
            common_paths = [
                r"C:\MinGW\bin",
                r"C:\msys64\mingw64\bin",
                r"C:\msys64\mingw32\bin",
                r"C:\cygwin64\bin",
                r"C:\cygwin\bin",
            ]
        else:
            common_paths = [
                "/usr/bin",
                "/usr/local/bin",
                "/opt/binutils/bin",
            ]

        for base_path in common_paths:
            for name in gas_names:
                full_path = os.path.join(base_path, name)
                if os.path.exists(full_path) and os.access(full_path, os.X_OK):
                    self.logger.info(f"Found GAS at: {full_path}")
                    return full_path

        self.logger.warning("GNU Assembler (GAS) not found on system")
        return None

    def _find_ml_path(self) -> str | None:
        """Find the path to Microsoft Macro Assembler (MASM/ML) on the system.

        Returns:
            Path to ML executable or None if not found

        """
        import os
        import platform
        import shutil

        if platform.system() != "Windows":
            # MASM is Windows-only
            return None

        # Common ML executable names
        ml_names = ["ml64.exe", "ml.exe"]

        # First check if ML is in PATH
        for name in ml_names:
            ml_path = shutil.which(name)
            if ml_path:
                self.logger.info(f"Found MASM at: {ml_path}")
                return ml_path

        # Check common Visual Studio installation directories
        vs_paths = [
            r"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC",
            r"C:\Program Files\Microsoft Visual Studio\2022\Professional\VC\Tools\MSVC",
            r"C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC",
            r"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC",
            r"C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC",
            r"C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC",
        ]

        for vs_base in vs_paths:
            if os.path.exists(vs_base):
                # Look for ml.exe or ml64.exe in version-specific subdirectories
                for root, _dirs, files in os.walk(vs_base):
                    for name in ml_names:
                        if name in files:
                            full_path = os.path.join(root, name)
                            if os.access(full_path, os.X_OK):
                                self.logger.info(f"Found MASM at: {full_path}")
                                return full_path

        self.logger.warning("Microsoft Macro Assembler (MASM) not found on system")
        return None

    def _detect_architecture(self) -> str:
        """Detect the current system architecture.

        Returns:
            Architecture string (x86, x64, arm, arm64)

        """
        import platform

        machine = platform.machine().lower()

        if machine in ["amd64", "x86_64"]:
            return "x64"
        elif machine in ["i386", "i686", "x86"]:
            return "x86"
        elif machine in ["aarch64", "arm64"]:
            return "arm64"
        elif machine.startswith("arm"):
            return "arm"
        else:
            # Default to x64 for unknown architectures
            self.logger.warning(f"Unknown architecture: {machine}, defaulting to x64")
            return "x64"
