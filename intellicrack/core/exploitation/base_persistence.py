"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

from abc import ABC, abstractmethod
from typing import Any

from ...utils.logger import get_logger

"""
Base Persistence Module

Shared functionality for platform-specific persistence implementations.
"""


class BasePersistence(ABC):
    """Abstract base class for persistence implementations.
    Provides common functionality to eliminate code duplication.
    """

    def __init__(self):
        """Initialize the base persistence framework with platform detection and logging."""
        self.logger = get_logger(__name__)
        self.platform = self.detect_platform()

    def establish_persistence(
        self, payload_path: str, method: str, options: dict[str, Any] | None = None
    ) -> dict[str, Any]:
        """Establish persistence using specified method.

        Args:
            payload_path: Path to payload executable
            method: Persistence method to use
            options: Method-specific options

        Returns:
            Results of persistence establishment

        """
        result = {
            "success": False,
            "method": method,
            "details": {},
            "cleanup_info": {},
            "error": None,
        }

        if options is None:
            options = {}

        try:
            self.logger.info(f"Establishing persistence using {method}")

            if method not in self.persistence_methods:
                result["error"] = f"Unknown persistence method: {method}"
                return result

            # Execute persistence method
            method_func = self.persistence_methods[method]
            success, details, cleanup_info = method_func(payload_path, options)

            result["success"] = success
            result["details"] = details
            result["cleanup_info"] = cleanup_info

            if success:
                self.logger.info(f"Persistence established successfully using {method}")
            else:
                self.logger.warning(f"Failed to establish persistence using {method}")

            return result

        except Exception as e:
            self.logger.error("Exception in base_persistence: %s", e)
            return self.handle_establishment_error(result, e)

    @abstractmethod
    def get_default_method(self) -> str:
        """Get the default persistence method for this platform."""

    @abstractmethod
    def list_available_methods(self) -> list:
        """List all available persistence methods for this platform."""

    def validate_session(
        self, session_id: str, active_sessions: dict[str, Any], result: dict[str, Any]
    ) -> dict[str, Any] | None:
        """Validate session exists and return session info.

        Args:
            session_id: Session ID to validate
            active_sessions: Dictionary of active sessions
            result: Result dictionary to update with error if needed

        Returns:
            Session info if valid, None if not found

        """
        if session_id not in active_sessions:
            result["error"] = f"Session {session_id} not found"
            return None
        return active_sessions[session_id]

    def handle_persistence_error(
        self, e: Exception, details: dict[str, Any], cleanup_info: dict[str, Any]
    ) -> tuple[bool, dict[str, Any], dict[str, Any]]:
        """Handle common persistence error pattern.

        Args:
            e: Exception that occurred
            details: Details dictionary to update
            cleanup_info: Cleanup info dictionary

        Returns:
            Tuple of (False, details, cleanup_info)

        """
        details["error"] = str(e)
        return False, details, cleanup_info

    def handle_subprocess_result(
        self, result, details: dict[str, Any], cleanup_info: dict[str, Any]
    ) -> tuple[bool, dict[str, Any], dict[str, Any]]:
        """Handle common subprocess result pattern.

        Args:
            result: subprocess.run result object
            details: Details dictionary to update
            cleanup_info: Cleanup info dictionary

        Returns:
            Tuple of (success, details, cleanup_info)

        """
        if result.returncode == 0:
            return True, details, cleanup_info
        details["error"] = (
            result.stderr.strip()
            if result.stderr
            else f"Command failed with code {result.returncode}"
        )
        return False, details, cleanup_info

    def init_persistence_data(self) -> tuple[dict[str, Any], dict[str, Any]]:
        """Initialize common persistence data structures.

        Returns:
            Tuple of (details, cleanup_info) dictionaries

        """
        return {}, {}

    def cleanup_service_common_pattern(
        self, service_name: str, service_commands: dict[str, str], service_path: str | None = None
    ) -> bool:
        """Common service cleanup pattern for both Windows and Linux.

        Args:
            service_name: Name of the service to cleanup
            service_commands: Dictionary with 'stop' and 'disable' command templates
            service_path: Optional path to service file to remove

        Returns:
            True if cleanup was successful

        """
        import os
        import subprocess

        try:
            # Stop service
            if "stop" in service_commands:
                stop_cmd = service_commands["stop"].format(service_name=service_name)
                subprocess.run(stop_cmd, check=False, shell=True, capture_output=True)

            # Disable service
            if "disable" in service_commands:
                disable_cmd = service_commands["disable"].format(service_name=service_name)
                subprocess.run(disable_cmd, check=False, shell=True, capture_output=True)

            # Remove service file if provided
            if service_path and os.path.exists(service_path):
                os.remove(service_path)

            return True

        except Exception as e:
            self.logger.error(f"Service cleanup failed: {e}")
            return False

    def handle_remove_persistence_error(self, error: Exception) -> bool:
        """Common error handling pattern for remove_persistence methods.

        Args:
            error: Exception that occurred during persistence removal

        Returns:
            Always returns False to indicate failure

        """
        self.logger.error(f"Failed to remove persistence: {error}")
        return False

    def handle_establishment_error(
        self, result: dict[str, Any], error: Exception
    ) -> dict[str, Any]:
        """Common error handling pattern for persistence establishment methods.

        Args:
            result: Result dictionary to update with error information
            error: Exception that occurred during persistence establishment

        Returns:
            Updated result dictionary with error details

        """
        self.logger.error(f"Persistence establishment failed: {error}")
        result["error"] = str(error)
        return result

    def handle_persistence_method_completion(
        self, result, details: dict[str, Any], cleanup_info: dict[str, Any]
    ) -> tuple[bool, dict, dict]:
        """Common completion pattern for persistence establishment methods.
        Handles both success and failure cases with subprocess results.

        Args:
            result: subprocess.CompletedProcess result object
            details: Details dictionary to return
            cleanup_info: Cleanup information dictionary

        Returns:
            Tuple of (success, details, cleanup_info)

        """
        if result.returncode == 0:
            return True, details, cleanup_info
        return self.handle_subprocess_result(result, details, cleanup_info)

    def create_success_result(
        self,
        details: dict[str, Any],
        cleanup_info: dict[str, Any],
        additional_details: dict[str, Any] | None = None,
    ) -> tuple[bool, dict[str, Any], dict[str, Any]]:
        """Create a success result with optional additional details.

        Args:
            details: Base details dictionary
            cleanup_info: Cleanup info dictionary
            additional_details: Optional additional details to merge

        Returns:
            Tuple of (True, details, cleanup_info)

        """
        if additional_details:
            details.update(additional_details)
        return True, details, cleanup_info
