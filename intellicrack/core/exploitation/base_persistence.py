"""
Base Persistence Module

Shared functionality for platform-specific persistence implementations.
"""

import logging
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Tuple


class BasePersistence(ABC):
    """
    Abstract base class for persistence implementations.
    Provides common functionality to eliminate code duplication.
    """

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.Persistence")
        self.persistence_methods = {}

    def establish_persistence(self,
                            payload_path: str,
                            method: str,
                            options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Establish persistence using specified method.
        
        Args:
            payload_path: Path to payload executable
            method: Persistence method to use
            options: Method-specific options
            
        Returns:
            Results of persistence establishment
        """
        result = {
            'success': False,
            'method': method,
            'details': {},
            'cleanup_info': {},
            'error': None
        }

        if options is None:
            options = {}

        try:
            self.logger.info(f"Establishing persistence using {method}")

            if method not in self.persistence_methods:
                result['error'] = f"Unknown persistence method: {method}"
                return result

            # Execute persistence method
            method_func = self.persistence_methods[method]
            success, details, cleanup_info = method_func(payload_path, options)

            result['success'] = success
            result['details'] = details
            result['cleanup_info'] = cleanup_info

            if success:
                self.logger.info(f"Persistence established successfully using {method}")
            else:
                self.logger.warning(f"Failed to establish persistence using {method}")

            return result

        except Exception as e:
            return self.handle_establishment_error(result, e)

    @abstractmethod
    def get_default_method(self) -> str:
        """Get the default persistence method for this platform."""
        pass

    @abstractmethod
    def list_available_methods(self) -> list:
        """List all available persistence methods for this platform."""
        pass

    def validate_session(self, session_id: str, active_sessions: Dict[str, Any],
                        result: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Validate session exists and return session info.
        
        Args:
            session_id: Session ID to validate
            active_sessions: Dictionary of active sessions
            result: Result dictionary to update with error if needed
            
        Returns:
            Session info if valid, None if not found
        """
        if session_id not in active_sessions:
            result['error'] = f"Session {session_id} not found"
            return None
        return active_sessions[session_id]

    def handle_persistence_error(self, e: Exception, details: Dict[str, Any],
                               cleanup_info: Dict[str, Any]) -> Tuple[bool, Dict[str, Any], Dict[str, Any]]:
        """
        Handle common persistence error pattern.
        
        Args:
            e: Exception that occurred
            details: Details dictionary to update
            cleanup_info: Cleanup info dictionary
            
        Returns:
            Tuple of (False, details, cleanup_info)
        """
        details['error'] = str(e)
        return False, details, cleanup_info

    def handle_subprocess_result(self, result, details: Dict[str, Any],
                                cleanup_info: Dict[str, Any]) -> Tuple[bool, Dict[str, Any], Dict[str, Any]]:
        """
        Handle common subprocess result pattern.
        
        Args:
            result: subprocess.run result object
            details: Details dictionary to update  
            cleanup_info: Cleanup info dictionary
            
        Returns:
            Tuple of (success, details, cleanup_info)
        """
        if result.returncode == 0:
            return True, details, cleanup_info
        else:
            details['error'] = result.stderr.strip() if result.stderr else f"Command failed with code {result.returncode}"
            return False, details, cleanup_info

    def init_persistence_data(self) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Initialize common persistence data structures.
        
        Returns:
            Tuple of (details, cleanup_info) dictionaries
        """
        return {}, {}

    def cleanup_service_common_pattern(self, service_name: str, service_commands: Dict[str, str],
                                      service_path: Optional[str] = None) -> bool:
        """
        Common service cleanup pattern for both Windows and Linux.
        
        Args:
            service_name: Name of the service to cleanup
            service_commands: Dictionary with 'stop' and 'disable' command templates
            service_path: Optional path to service file to remove
            
        Returns:
            True if cleanup was successful
        """
        import os
        import subprocess

        try:
            # Stop service
            if 'stop' in service_commands:
                stop_cmd = service_commands['stop'].format(service_name=service_name)
                subprocess.run(stop_cmd, shell=True, capture_output=True)

            # Disable service
            if 'disable' in service_commands:
                disable_cmd = service_commands['disable'].format(service_name=service_name)
                subprocess.run(disable_cmd, shell=True, capture_output=True)

            # Remove service file if provided
            if service_path and os.path.exists(service_path):
                os.remove(service_path)

            return True

        except Exception as e:
            self.logger.error(f"Service cleanup failed: {e}")
            return False

    def handle_remove_persistence_error(self, error: Exception) -> bool:
        """
        Common error handling pattern for remove_persistence methods.
        
        Args:
            error: Exception that occurred during persistence removal
            
        Returns:
            Always returns False to indicate failure
        """
        self.logger.error(f"Failed to remove persistence: {error}")
        return False

    def handle_establishment_error(self, result: Dict[str, Any], error: Exception) -> Dict[str, Any]:
        """
        Common error handling pattern for persistence establishment methods.
        
        Args:
            result: Result dictionary to update with error information
            error: Exception that occurred during persistence establishment
            
        Returns:
            Updated result dictionary with error details
        """
        self.logger.error(f"Persistence establishment failed: {error}")
        result['error'] = str(error)
        return result

    def handle_persistence_method_completion(self, result, details: Dict[str, Any],
                                           cleanup_info: Dict[str, Any]) -> Tuple[bool, Dict, Dict]:
        """
        Common completion pattern for persistence establishment methods.
        Handles both success and failure cases with subprocess results.
        
        Args:
            result: subprocess.CompletedProcess result object
            details: Details dictionary to return
            cleanup_info: Cleanup information dictionary
            
        Returns:
            Tuple of (success, details, cleanup_info)
        """
        if result.returncode == 0:
            return True, details, cleanup_info
        else:
            return self.handle_subprocess_result(result, details, cleanup_info)

    def create_success_result(self, details: Dict[str, Any], cleanup_info: Dict[str, Any],
                             additional_details: Optional[Dict[str, Any]] = None) -> Tuple[bool, Dict[str, Any], Dict[str, Any]]:
        """
        Create a success result with optional additional details.
        
        Args:
            details: Base details dictionary
            cleanup_info: Cleanup info dictionary
            additional_details: Optional additional details to merge
            
        Returns:
            Tuple of (True, details, cleanup_info)
        """
        if additional_details:
            details.update(additional_details)
        return True, details, cleanup_info
