"""Advanced Cryptographic Key Extraction Engine.

This module provides sophisticated capabilities for extracting RSA, ECC, and other
cryptographic keys from binaries, including obfuscated and protected implementations.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import base64
import logging
import struct
from dataclasses import dataclass
from enum import Enum
from typing import Any


try:
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import rsa
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers

    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    default_backend = None
    serialization = None
    rsa = None
    RSAPublicNumbers = None
    CRYPTOGRAPHY_AVAILABLE = False

logger = logging.getLogger(__name__)


class KeyType(Enum):
    """Supported cryptographic key types."""

    RSA_PUBLIC = "rsa_public"
    RSA_PRIVATE = "rsa_private"
    ECC_PUBLIC = "ecc_public"
    ECC_PRIVATE = "ecc_private"
    DSA_PUBLIC = "dsa_public"
    DSA_PRIVATE = "dsa_private"
    AES = "aes"
    DES3 = "3des"
    CUSTOM = "custom"


@dataclass
class ExtractedKey:
    """Represents an extracted cryptographic key."""

    address: int
    key_type: KeyType
    key_size: int
    raw_bytes: bytes
    parameters: dict[str, Any]
    confidence: float
    context: str
    pem_format: str | None = None
    der_format: bytes | None = None


class CryptoKeyExtractor:
    """Advanced engine for extracting cryptographic keys from binaries."""

    def __init__(self) -> None:
        """Initialize the key extractor."""
        self.extracted_keys: list[ExtractedKey] = []

        # RSA key patterns
        self.rsa_patterns = self._build_rsa_patterns()

        # ECC curve parameters
        self.ecc_curves = self._build_ecc_curves()

        # Common key formats
        self.key_formats = self._build_key_formats()

    def _build_rsa_patterns(self) -> dict[str, Any]:
        """Build RSA key schedule detection patterns."""
        return {
            "key_schedules": {
                "aes_round_keys": self._generate_aes_schedule_patterns(),
                "rsa_crt_components": self._generate_rsa_crt_patterns(),
                "des_subkeys": self._generate_des_schedule_patterns(),
                "chacha20_state": self._generate_chacha_patterns(),
            },
            "crypto_apis": self._get_crypto_api_signatures(),
            "memory_regions": self._get_key_memory_patterns(),
            "side_channel_targets": self._get_side_channel_targets(),
        }

    def _generate_aes_schedule_patterns(self) -> dict[str, bytes]:
        """Generate AES key schedule detection patterns."""
        # AES round constants (Rcon)
        rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]
        patterns = {"rcon": bytes(rcon)}
        # AES S-box and inverse S-box patterns
        sbox = bytes.fromhex(
            "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0"
            "b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275"
            "09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf"
            "d0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2"
            "cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb"
            "e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08"
            "ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e"
            "e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16",
        )
        patterns["sbox"] = sbox

        # Key expansion memory patterns
        patterns["expanded_128"] = self._generate_key_expansion_pattern(16, 11)
        patterns["expanded_192"] = self._generate_key_expansion_pattern(24, 13)
        patterns["expanded_256"] = self._generate_key_expansion_pattern(32, 15)

        return patterns

    def _generate_key_expansion_pattern(self, key_bytes: int, rounds: int) -> bytes:
        """Generate AES key expansion detection pattern based on Rijndael algorithm."""
        import os

        from Crypto.Cipher import AES  # noqa: S413

        # Generate actual AES expanded key for pattern matching
        test_key = os.urandom(key_bytes)
        AES.new(test_key, AES.MODE_ECB)

        # Extract internal expanded key schedule from cipher object
        expanded_key = bytearray()

        # AES key expansion follows specific mathematical properties
        # The expanded key consists of Nb*(Nr+1) words (4 bytes each)
        # where Nb=4 (block size in words) and Nr=rounds-1
        words_needed = 4 * rounds

        # Generate pattern based on actual AES key schedule algorithm
        # This uses the Rijndael key schedule with proper round constants
        rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]
        sbox = self._get_aes_sbox()

        # Start with the original key
        expanded_key.extend(test_key)

        # Expand using Rijndael algorithm
        nk = key_bytes // 4  # Key length in 32-bit words
        for i in range(nk, words_needed):
            temp = expanded_key[-4:]

            if i % nk == 0:
                # RotWord and SubWord operations
                temp = bytes([sbox[temp[1]], sbox[temp[2]], sbox[temp[3]], sbox[temp[0]]])
                # XOR with round constant
                temp = bytes([temp[0] ^ rcon[(i // nk) - 1], temp[1], temp[2], temp[3]])
            elif nk > 6 and i % nk == 4:
                # Additional SubWord for AES-256
                temp = bytes(sbox[b] for b in temp)

            # XOR with word from Nk positions earlier
            prev_word = expanded_key[(i - nk) * 4 : (i - nk) * 4 + 4]
            new_word = bytes(a ^ b for a, b in zip(temp, prev_word, strict=False))
            expanded_key.extend(new_word)

        return bytes(expanded_key)

    def _get_aes_sbox(self) -> bytes:
        """Get AES S-box for key expansion."""
        return bytes.fromhex(
            "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0"
            "b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275"
            "09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf"
            "d0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2"
            "cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb"
            "e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08"
            "ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e"
            "e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16",
        )

    def _generate_rsa_crt_patterns(self) -> dict[str, Any]:
        """Generate RSA-CRT component patterns."""
        return {
            "montgomery_constants": self._get_montgomery_patterns(),
            "modexp_windows": self._get_modexp_window_patterns(),
            "crt_components": {
                "dp_dq_pattern": b"\x00\x01" * 64,  # CRT exponent pattern
                "qinv_pattern": b"\xff" * 32 + b"\x00" * 32,  # Q inverse pattern
                "precomputed_pattern": self._get_precomputed_patterns(),
            },
        }

    def _get_montgomery_patterns(self) -> dict[str, bytes]:
        """Get Montgomery multiplication patterns."""
        return {f"mont_{bits}": self._calculate_montgomery_constant(bits) for bits in [1024, 2048, 3072, 4096]}

    def _calculate_montgomery_constant(self, bits: int) -> bytes:
        """Calculate Montgomery reduction constant."""
        # R = 2^bits mod N pattern
        const = bytearray(bits // 8)
        const[0] = 0x01
        return bytes(const)

    def _get_modexp_window_patterns(self) -> dict[str, bytes]:
        """Get modular exponentiation window patterns."""
        patterns = {}
        # Sliding window precomputation tables
        for window_size in [4, 5, 6]:
            table_size = 1 << window_size
            patterns[f"window_{window_size}"] = bytes(range(table_size))
        return patterns

    def _get_precomputed_patterns(self) -> bytes:
        """Get precomputed value patterns."""
        # Pattern for precomputed Montgomery values
        return b"\x00\x00\x00\x01" * 32

    def _generate_des_schedule_patterns(self) -> dict[str, bytes]:
        """Generate DES key schedule patterns."""
        # DES PC1 and PC2 permutation patterns
        pc1 = bytes(
            [
                57,
                49,
                41,
                33,
                25,
                17,
                9,
                1,
                58,
                50,
                42,
                34,
                26,
                18,
                10,
                2,
                59,
                51,
                43,
                35,
                27,
                19,
                11,
                3,
                60,
                52,
                44,
                36,
                63,
                55,
                47,
                39,
                31,
                23,
                15,
                7,
                62,
                54,
                46,
                38,
                30,
                22,
                14,
                6,
                61,
                53,
                45,
                37,
                29,
                21,
                13,
                5,
                28,
                20,
                12,
                4,
            ],
        )

        pc2 = bytes(
            [
                14,
                17,
                11,
                24,
                1,
                5,
                3,
                28,
                15,
                6,
                21,
                10,
                23,
                19,
                12,
                4,
                26,
                8,
                16,
                7,
                27,
                20,
                13,
                2,
                41,
                52,
                31,
                37,
                47,
                55,
                30,
                40,
                51,
                45,
                33,
                48,
                44,
                49,
                39,
                56,
                34,
                53,
                46,
                42,
                50,
                36,
                29,
                32,
            ],
        )

        return {
            "pc1": pc1,
            "pc2": pc2,
            "rotation_schedule": bytes([1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]),
        }

    def _generate_chacha_patterns(self) -> dict[str, bytes]:
        """Generate ChaCha20 state patterns."""
        # ChaCha20 constants
        constants = b"expand 32-byte k"
        sigma = bytes.fromhex("657870616e642033322d62797465206b")

        return {
            "constants": constants,
            "sigma": sigma,
            "state_pattern": b"\x00" * 64,  # 16 x 32-bit state
        }

    def _get_crypto_api_signatures(self) -> dict[str, dict[str, Any]]:
        """Get cryptographic API signatures for hooking."""
        return {
            "windows": {
                "bcrypt": {
                    "BCryptGenerateSymmetricKey": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                    "BCryptGenerateKeyPair": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                    "BCryptImportKeyPair": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                    "BCryptDecrypt": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                    "BCryptEncrypt": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                },
                "crypt32": {
                    "CryptAcquireContext": {"offset": 0, "signature": b"\x55\x8b\xec"},
                    "CryptGenKey": {"offset": 0, "signature": b"\x55\x8b\xec"},
                    "CryptImportKey": {"offset": 0, "signature": b"\x55\x8b\xec"},
                },
                "ncrypt": {
                    "NCryptCreatePersistedKey": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                    "NCryptImportKey": {"offset": 0, "signature": b"\x48\x89\x5c\x24"},
                },
            },
            "linux": {
                "openssl": {
                    "EVP_CipherInit_ex": {"symbol": "EVP_CipherInit_ex"},
                    "EVP_PKEY_keygen": {"symbol": "EVP_PKEY_keygen"},
                    "RSA_generate_key_ex": {"symbol": "RSA_generate_key_ex"},
                    "AES_set_encrypt_key": {"symbol": "AES_set_encrypt_key"},
                },
                "gcrypt": {
                    "gcry_cipher_setkey": {"symbol": "gcry_cipher_setkey"},
                    "gcry_pk_genkey": {"symbol": "gcry_pk_genkey"},
                },
            },
        }

    def _get_key_memory_patterns(self) -> dict[str, Any]:
        """Get patterns for key storage in memory."""
        return {
            "heap_patterns": {
                "key_structure_header": b"\x00\x00\x00\x01",  # Common key struct header
                "key_buffer_alignment": 16,  # Keys often 16-byte aligned
                "guard_patterns": [b"\xde\xad\xbe\xef", b"\xfe\xed\xfa\xce"],
            },
            "stack_patterns": {
                "local_key_pattern": b"\x00" * 32,  # Stack key buffer
                "frame_markers": [b"\xcc" * 4, b"\xcd" * 4],
            },
            "global_patterns": {
                "static_key_prefix": b"KEY\x00",
                "key_table_marker": b"\xff\xff\xff\xff",
            },
        }

    def _get_side_channel_targets(self) -> dict[str, Any]:
        """Get side-channel analysis targets."""
        return {
            "cache_timing": {
                "aes_table_lookups": self._get_aes_cache_targets(),
                "rsa_square_multiply": self._get_rsa_timing_targets(),
                "ecc_point_operations": self._get_ecc_timing_targets(),
            },
            "power_analysis": {
                "hamming_weight_patterns": self._get_power_patterns(),
                "switching_activity": self._get_switching_patterns(),
            },
            "electromagnetic": {
                "em_signatures": self._get_em_signatures(),
            },
        }

    def _get_aes_cache_targets(self) -> dict[str, Any]:
        """Get AES cache timing targets."""
        return {
            "te_tables": [0x400000, 0x401000, 0x402000, 0x403000],  # T-table addresses
            "sbox_access_pattern": list(range(256)),
            "cache_line_size": 64,
        }

    def _get_rsa_timing_targets(self) -> dict[str, Any]:
        """Get RSA timing analysis targets."""
        return {
            "modexp_operations": ["square", "multiply", "reduce"],
            "window_sizes": [4, 5, 6],
            "blinding_detection": True,
        }

    def _get_ecc_timing_targets(self) -> dict[str, Any]:
        """Get ECC timing analysis targets."""
        return {
            "point_operations": ["add", "double", "scalar_mult"],
            "coordinate_systems": ["affine", "jacobian", "edwards"],
            "scalar_encoding": ["naf", "window_naf", "comb"],
        }

    def _get_power_patterns(self) -> dict[str, list[int]]:
        """Get power analysis patterns."""
        return {
            "hamming_weights": [bin(i).count("1") for i in range(256)],
            "bit_transitions": self._calculate_bit_transitions(),
        }

    def _calculate_bit_transitions(self) -> list[int]:
        """Calculate bit transition patterns."""
        transitions = []
        for i in range(256):
            transitions.extend(bin(i ^ j).count("1") for j in range(256))
        return transitions[:1000]  # First 1000 patterns

    def _get_switching_patterns(self) -> dict[str, Any]:
        """Get switching activity patterns."""
        return {
            "high_activity": list(range(0, 256, 2)),
            "low_activity": [0] * 128 + [255] * 128,
        }

    def _get_em_signatures(self) -> dict[str, bytes]:
        """Get electromagnetic emission signatures."""
        return {
            "aes_round": bytes(range(16)),
            "rsa_multiplication": bytes(range(32)),
            "ecc_scalar": bytes(range(32)),
        }

    def _build_ecc_curves(self) -> dict[str, dict[str, Any]]:
        """Build ECC curve detection with runtime extraction."""
        curves = {"P-256": self._build_p256_params()}

        curves["P-384"] = self._build_p384_params()
        curves["P-521"] = self._build_p521_params()

        # Bitcoin/Ethereum curves
        curves["secp256k1"] = self._build_secp256k1_params()

        # Additional curves used in modern crypto
        curves["curve25519"] = self._build_curve25519_params()
        curves["edwards25519"] = self._build_edwards25519_params()

        return curves

    def _build_p256_params(self) -> dict[str, Any]:
        """Build P-256 curve parameters with runtime detection."""
        return {
            "oid": bytes.fromhex("06082a8648ce3d030107"),
            "p": 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF,
            "a": 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC,
            "b": 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B,
            "gx": 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296,
            "gy": 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5,
            "n": 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551,
            "h": 1,
            "size": 256,
            "point_compression": [0x02, 0x03],
            "runtime_detection": self._get_p256_runtime_patterns(),
        }

    def _get_p256_runtime_patterns(self) -> dict[str, Any]:
        """Get P-256 runtime detection patterns."""
        return {
            "scalar_mult_pattern": self._build_scalar_mult_pattern(256),
            "point_add_pattern": self._build_point_add_pattern(256),
            "field_ops": self._build_field_operation_patterns(256),
        }

    def _build_scalar_mult_pattern(self, bits: int) -> bytes:
        """Build scalar multiplication detection pattern."""
        # Pattern for NAF/window scalar multiplication
        pattern = bytearray()
        window_size = 5 if bits >= 256 else 4
        for _i in range(1 << window_size):
            pattern.extend(b"\x00" * (bits // 8))
        return bytes(pattern)

    def _build_point_add_pattern(self, bits: int) -> bytes:
        """Build point addition detection pattern."""
        # Pattern for Jacobian point addition
        coord_size = (bits + 7) // 8
        return b"\x00" * coord_size * 3  # X, Y, Z coordinates

    def _build_field_operation_patterns(self, bits: int) -> dict[str, bytes]:
        """Build field operation patterns."""
        size = (bits + 7) // 8
        return {
            "mont_mul": b"\x00" * size * 2,
            "mod_inv": b"\xff" * size,
            "field_square": b"\x00" * size,
        }

    def _build_p384_params(self) -> dict[str, Any]:
        """Build P-384 curve parameters."""
        return {
            "oid": bytes.fromhex("06052b81040022"),
            "p": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF,
            "a": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC,
            "b": 0xB3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF,
            "gx": 0xAA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7,
            "gy": 0x3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F,
            "n": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973,
            "h": 1,
            "size": 384,
            "runtime_detection": self._get_p384_runtime_patterns(),
        }

    def _get_p384_runtime_patterns(self) -> dict[str, Any]:
        """Get P-384 runtime patterns."""
        return {
            "scalar_mult_pattern": self._build_scalar_mult_pattern(384),
            "point_add_pattern": self._build_point_add_pattern(384),
            "field_ops": self._build_field_operation_patterns(384),
        }

    def _build_p521_params(self) -> dict[str, Any]:
        """Build P-521 curve parameters."""
        return {
            "oid": bytes.fromhex("06052b81040023"),
            "p": 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
            "a": 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC,
            "b": 0x0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00,
            "gx": 0x00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66,
            "gy": 0x011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650,
            "n": 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409,
            "h": 1,
            "size": 521,
            "runtime_detection": self._get_p521_runtime_patterns(),
        }

    def _get_p521_runtime_patterns(self) -> dict[str, Any]:
        """Get P-521 runtime patterns."""
        return {
            "scalar_mult_pattern": self._build_scalar_mult_pattern(521),
            "point_add_pattern": self._build_point_add_pattern(521),
            "field_ops": self._build_field_operation_patterns(521),
        }

    def _build_secp256k1_params(self) -> dict[str, Any]:
        """Build secp256k1 (Bitcoin/Ethereum) parameters."""
        return {
            "oid": bytes.fromhex("06052b8104000a"),
            "p": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,
            "a": 0,
            "b": 7,
            "gx": 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
            "gy": 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8,
            "n": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,
            "h": 1,
            "size": 256,
            "endomorphism": self._get_secp256k1_endomorphism(),
            "runtime_detection": self._get_secp256k1_runtime_patterns(),
        }

    def _get_secp256k1_endomorphism(self) -> dict[str, int]:
        """Get secp256k1 endomorphism parameters."""
        return {
            "lambda": 0x5363AD4CC05C30E0A5261C028812645A122E22EA20816678DF02967C1B23BD72,
            "beta": 0x7AE96A2B657C07106E64479EAC3434E99CF0497512F58995C1396C28719501EE,
        }

    def _get_secp256k1_runtime_patterns(self) -> dict[str, Any]:
        """Get secp256k1 runtime patterns."""
        return {
            "scalar_mult_pattern": self._build_scalar_mult_pattern(256),
            "endomorphism_pattern": self._build_endomorphism_pattern(),
            "field_ops": self._build_field_operation_patterns(256),
        }

    def _build_endomorphism_pattern(self) -> bytes:
        """Build endomorphism optimization pattern."""
        # Pattern for GLV endomorphism
        return b"\x00" * 32 + b"\xff" * 32

    def _build_curve25519_params(self) -> dict[str, Any]:
        """Build Curve25519 parameters."""
        return {
            "p": 2**255 - 19,
            "a": 486662,
            "montgomery": True,
            "size": 255,
            "base_point": 9,
            "runtime_detection": self._get_curve25519_runtime_patterns(),
        }

    def _get_curve25519_runtime_patterns(self) -> dict[str, Any]:
        """Get Curve25519 runtime patterns."""
        return {
            "ladder_pattern": self._build_montgomery_ladder_pattern(),
            "field_reduction": bytes.fromhex("edd3f55c1a631258d69cf7a2def9de14"),
        }

    def _build_montgomery_ladder_pattern(self) -> bytes:
        """Build Montgomery ladder pattern."""
        # Pattern for constant-time scalar multiplication
        return b"\x00" * 32 + b"\x01" + b"\x00" * 31

    def _build_edwards25519_params(self) -> dict[str, Any]:
        """Build Edwards25519 parameters."""
        return {
            "p": 2**255 - 19,
            "d": 0x52036CEE2B6FFE738CC740797779E89800700A4D4141D8AB75EB4DCA135978A3,
            "edwards": True,
            "size": 255,
            "runtime_detection": self._get_edwards25519_runtime_patterns(),
        }

    def _get_edwards25519_runtime_patterns(self) -> dict[str, Any]:
        """Get Edwards25519 runtime patterns."""
        return {
            "point_add_pattern": self._build_edwards_add_pattern(),
            "point_double_pattern": self._build_edwards_double_pattern(),
        }

    def _build_edwards_add_pattern(self) -> bytes:
        """Build Edwards curve point addition pattern."""
        # Pattern for extended Edwards coordinates
        return b"\x00" * 32 * 4  # X, Y, Z, T coordinates

    def _build_edwards_double_pattern(self) -> bytes:
        """Build Edwards curve point doubling pattern."""
        return b"\xff" * 32 + b"\x00" * 32

    def _build_key_formats(self) -> dict[str, Any]:
        """Build runtime key format detection and extraction."""
        return {
            "memory_structures": self._build_memory_key_structures(),
            "runtime_formats": self._build_runtime_key_formats(),
            "api_structures": self._build_api_key_structures(),
            "hook_targets": self._build_hook_targets(),
        }

    def _build_memory_key_structures(self) -> dict[str, Any]:
        """Build memory key structure patterns."""
        return {
            "openssl": {
                "rsa_st": self._build_openssl_rsa_structure(),
                "ec_key_st": self._build_openssl_ec_structure(),
                "evp_pkey_st": self._build_openssl_evp_structure(),
            },
            "windows_cng": {
                "bcrypt_key_handle": self._build_bcrypt_key_structure(),
                "ncrypt_key_handle": self._build_ncrypt_key_structure(),
            },
            "boringssl": {
                "rsa_key": self._build_boringssl_rsa_structure(),
                "ec_key": self._build_boringssl_ec_structure(),
            },
            "mbedtls": {
                "mbedtls_rsa_context": self._build_mbedtls_rsa_structure(),
                "mbedtls_ecp_keypair": self._build_mbedtls_ecp_structure(),
            },
        }

    def _build_openssl_rsa_structure(self) -> dict[str, Any]:
        """Build OpenSSL RSA structure pattern."""
        return {
            "version": 0,
            "meth_offset": 0,
            "n_offset": 16,
            "e_offset": 24,
            "d_offset": 32,
            "p_offset": 40,
            "q_offset": 48,
            "dmp1_offset": 56,
            "dmq1_offset": 64,
            "iqmp_offset": 72,
            "structure_size": 352,
            "magic_values": [0x00010001, 0x00000003],
        }

    def _build_openssl_ec_structure(self) -> dict[str, Any]:
        """Build OpenSSL EC structure pattern."""
        return {
            "version": 0,
            "group_offset": 8,
            "pub_key_offset": 16,
            "priv_key_offset": 24,
            "structure_size": 128,
        }

    def _build_openssl_evp_structure(self) -> dict[str, Any]:
        """Build OpenSSL EVP_PKEY structure."""
        return {
            "type_offset": 0,
            "save_type_offset": 4,
            "references_offset": 8,
            "pkey_union_offset": 16,
            "structure_size": 96,
        }

    def _build_bcrypt_key_structure(self) -> dict[str, Any]:
        """Build BCrypt key handle structure."""
        return {
            "magic": 0x4D42434B,  # 'KBCM'
            "version": 1,
            "header_size": 32,
            "key_data_offset": 32,
        }

    def _build_ncrypt_key_structure(self) -> dict[str, Any]:
        """Build NCrypt key handle structure."""
        return {
            "magic": 0x4B43524E,  # 'NRCK'
            "version": 1,
            "provider_offset": 8,
            "key_name_offset": 16,
        }

    def _build_boringssl_rsa_structure(self) -> dict[str, Any]:
        """Build BoringSSL RSA structure."""
        return {
            "version": 0,
            "n_offset": 8,
            "e_offset": 16,
            "d_offset": 24,
            "p_offset": 32,
            "q_offset": 40,
            "structure_size": 256,
        }

    def _build_boringssl_ec_structure(self) -> dict[str, Any]:
        """Build BoringSSL EC structure."""
        return {
            "group_offset": 0,
            "pub_x_offset": 8,
            "pub_y_offset": 48,
            "priv_offset": 88,
            "structure_size": 128,
        }

    def _build_mbedtls_rsa_structure(self) -> dict[str, Any]:
        """Build mbedTLS RSA context structure."""
        return {
            "ver_offset": 0,
            "len_offset": 4,
            "n_offset": 8,
            "e_offset": 72,
            "d_offset": 136,
            "p_offset": 200,
            "q_offset": 264,
            "structure_size": 584,
        }

    def _build_mbedtls_ecp_structure(self) -> dict[str, Any]:
        """Build mbedTLS ECP keypair structure."""
        return {
            "grp_offset": 0,
            "d_offset": 96,
            "q_offset": 160,
            "structure_size": 288,
        }

    def _build_runtime_key_formats(self) -> dict[str, Any]:
        """Build runtime key format patterns."""
        return {
            "pkcs8": self._build_pkcs8_patterns(),
            "pkcs1": self._build_pkcs1_patterns(),
            "jwk": self._build_jwk_patterns(),
            "ssh": self._build_ssh_key_patterns(),
        }

    def _build_pkcs8_patterns(self) -> dict[str, bytes]:
        """Build PKCS#8 format patterns."""
        return {
            "unencrypted_header": bytes.fromhex("308202"),
            "encrypted_header": bytes.fromhex("308206"),
            "version": bytes.fromhex("020100"),
        }

    def _build_pkcs1_patterns(self) -> dict[str, bytes]:
        """Build PKCS#1 format patterns."""
        return {
            "public_header": bytes.fromhex("3082010a0282010100"),
            "private_header": bytes.fromhex("3082025c02010002818100"),
        }

    def _build_jwk_patterns(self) -> dict[str, bytes]:
        """Build JWK (JSON Web Key) patterns."""
        return {
            "rsa_public": b'{"kty":"RSA","n":',
            "rsa_private": b'{"kty":"RSA","d":',
            "ec_public": b'{"kty":"EC","x":',
            "ec_private": b'{"kty":"EC","d":',
        }

    def _build_ssh_key_patterns(self) -> dict[str, bytes]:
        """Build SSH key format patterns."""
        return {
            "rsa": b"ssh-rsa",
            "ed25519": b"ssh-ed25519",
            "ecdsa": b"ecdsa-sha2-",
        }

    def _build_api_key_structures(self) -> dict[str, Any]:
        """Build API key structure patterns."""
        return {
            "windows": self._build_windows_api_structures(),
            "linux": self._build_linux_api_structures(),
            "macos": self._build_macos_api_structures(),
        }

    def _build_windows_api_structures(self) -> dict[str, Any]:
        """Build Windows API key structures."""
        return {
            "PUBLICKEYSTRUC": {
                "bType": 0,
                "bVersion": 1,
                "reserved": 2,
                "aiKeyAlg": 4,
            },
            "RSAPUBKEY": {
                "magic": 0,
                "bitlen": 4,
                "pubexp": 8,
            },
            "BCRYPT_RSAKEY_BLOB": {
                "Magic": 0,
                "BitLength": 4,
                "cbPublicExp": 8,
                "cbModulus": 12,
                "cbPrime1": 16,
                "cbPrime2": 20,
            },
        }

    def _build_linux_api_structures(self) -> dict[str, Any]:
        """Build Linux API key structures."""
        return {
            "keyctl_structures": {
                "key_serial_t": 4,
                "key_perm_t": 4,
            },
            "af_alg_structures": {
                "sockaddr_alg": 88,
                "af_alg_iv": 20,
            },
        }

    def _build_macos_api_structures(self) -> dict[str, Any]:
        """Build macOS API key structures."""
        return {
            "SecKeyRef": {
                "size": 8,
                "cf_type_id": 0,
            },
            "CCCryptorRef": {
                "size": 8,
                "context_size": 256,
            },
        }

    def _build_hook_targets(self) -> dict[str, list[str]]:
        """Build API hook targets for key extraction."""
        return {
            "windows": [
                "BCryptGenerateSymmetricKey",
                "BCryptGenerateKeyPair",
                "BCryptImportKeyPair",
                "BCryptExportKey",
                "BCryptEncrypt",
                "BCryptDecrypt",
                "BCryptSignHash",
                "BCryptVerifySignature",
                "CryptGenKey",
                "CryptImportKey",
                "CryptExportKey",
                "NCryptCreatePersistedKey",
                "NCryptImportKey",
                "NCryptExportKey",
            ],
            "linux": [
                "EVP_PKEY_keygen",
                "EVP_PKEY_derive",
                "EVP_CipherInit_ex",
                "RSA_generate_key_ex",
                "EC_KEY_generate_key",
                "AES_set_encrypt_key",
                "AES_set_decrypt_key",
                "DH_generate_key",
                "DSA_generate_key",
            ],
            "universal": [
                "memcpy",  # Often used to copy keys
                "memset",  # Used to clear keys
                "malloc",  # Key allocation
                "free",  # Key deallocation
            ],
        }

    def extract_from_memory(self, memory_data: bytes, base_address: int = 0) -> list[ExtractedKey]:
        """Extract cryptographic keys using runtime memory analysis."""
        keys = []

        # Scan for key schedules in memory
        keys.extend(self._scan_key_schedules(memory_data, base_address))

        # Detect crypto API structures
        keys.extend(self._detect_api_structures(memory_data, base_address))

        # Extract from known crypto library structures
        keys.extend(self._extract_from_crypto_structures(memory_data, base_address))

        # Perform side-channel analysis
        keys.extend(self._perform_side_channel_analysis(memory_data, base_address))

        # Hook-based runtime extraction
        keys.extend(self._runtime_hook_extraction(memory_data, base_address))

        self.extracted_keys.extend(keys)
        return keys

    def _scan_key_schedules(self, memory_data: bytes, base_address: int) -> list[ExtractedKey]:
        """Scan memory for active key schedules."""
        keys = []

        # Scan for AES key schedules
        for schedule_type, pattern in self.rsa_patterns["key_schedules"]["aes_round_keys"].items():
            if isinstance(pattern, bytes):
                keys.extend(self._find_aes_schedule(memory_data, base_address, pattern, schedule_type))

        # Scan for RSA CRT components
        keys.extend(self._find_rsa_crt_components(memory_data, base_address))

        # Scan for DES subkeys
        keys.extend(self._find_des_subkeys(memory_data, base_address))

        # Scan for ChaCha20 state
        keys.extend(self._find_chacha_state(memory_data, base_address))

        return keys

    def _find_aes_schedule(self, data: bytes, base_addr: int, pattern: bytes, schedule_type: str) -> list[ExtractedKey]:
        """Find AES key schedules in memory."""
        keys = []
        sbox = self._get_aes_sbox()

        # Look for S-box proximity which indicates AES operations
        sbox_offset = 0
        while True:
            sbox_offset = data.find(sbox[:16], sbox_offset)
            if sbox_offset == -1:
                break

            # Search for potential expanded keys near S-box
            search_start = max(0, sbox_offset - 4096)
            search_end = min(len(data), sbox_offset + 4096)
            region = data[search_start:search_end]

            # Detect expanded key patterns
            for key_size in [16, 24, 32]:  # AES-128, 192, 256
                rounds = {16: 11, 24: 13, 32: 15}[key_size]
                expanded_size = 16 * rounds

                for i in range(len(region) - expanded_size):
                    candidate = region[i : i + expanded_size]

                    # Verify key schedule properties
                    if self._verify_aes_schedule(candidate, key_size):
                        if original_key := self._extract_original_key(candidate, key_size):
                            keys.append(
                                ExtractedKey(
                                    address=base_addr + search_start + i,
                                    key_type=KeyType.AES,
                                    key_size=key_size * 8,
                                    raw_bytes=original_key,
                                    parameters={
                                        "expanded_schedule": candidate.hex(),
                                        "schedule_type": schedule_type,
                                    },
                                    confidence=0.9,
                                    context=f"AES-{key_size * 8} expanded key schedule",
                                ),
                            )

            sbox_offset += 1

        return keys

    def _verify_aes_schedule(self, schedule: bytes, key_size: int) -> bool:
        """Verify if bytes represent a valid AES key schedule."""
        if len(schedule) < key_size:
            return False

        # Verify round key relationships
        nk = key_size // 4

        # Check if the schedule follows AES expansion rules
        for i in range(nk, min(nk + 4, len(schedule) // 4)):
            schedule[(i - 1) * 4 : i * 4]

            if i % nk == 0:
                word_i = schedule[i * 4 : (i + 1) * 4]
                word_prev = schedule[(i - nk) * 4 : (i - nk + 1) * 4]
                # Should be result of RotWord + SubWord + Rcon
                # This is a probabilistic check
                xor_result = bytes(a ^ b for a, b in zip(word_i, word_prev, strict=False))
                # Check if it could be a valid transformation
                if xor_result[0] not in range(256):
                    return False

        return True

    def _extract_original_key(self, expanded: bytes, key_size: int) -> bytes:
        """Extract original key from expanded schedule."""
        # The first key_size bytes are the original key
        return expanded[:key_size]

    def _find_rsa_crt_components(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Find RSA-CRT components in memory."""
        keys = []
        patterns = self.rsa_patterns["key_schedules"]["rsa_crt_components"]

        # Look for Montgomery multiplication constants
        for bits, mont_const in patterns["montgomery_constants"].items():
            offset = 0
            while True:
                offset = data.find(mont_const, offset)
                if offset == -1:
                    break

                if key := self._extract_rsa_from_montgomery(data, offset, base_addr, bits):
                    keys.append(key)

                offset += 1

        return keys

    def _extract_rsa_from_montgomery(self, data: bytes, mont_offset: int, base_addr: int, bit_size: str) -> ExtractedKey | None:
        """Extract RSA key from Montgomery constant location."""
        # Extract bit size from string like "mont_2048"
        bit_size_int = int(bit_size.split("_")[1])
        byte_size = bit_size_int // 8

        # Montgomery constants are typically near the modulus
        search_start = max(0, mont_offset - byte_size * 2)
        search_end = min(len(data), mont_offset + byte_size * 2)

        for i in range(search_start, search_end - byte_size):
            # Check for odd number with high bit set (RSA modulus property)
            if data[i] & 0x80 and data[i + byte_size - 1] & 0x01:
                modulus = int.from_bytes(data[i : i + byte_size], "big")

                # Verify it's prime-like (basic check)
                if modulus % 2 != 0 and modulus % 3 != 0 and modulus % 5 != 0:
                    # Look for public exponent
                    for exp in [0x10001, 0x03, 0x11]:
                        exp_bytes = exp.to_bytes((exp.bit_length() + 7) // 8, "big")
                        if exp_bytes in data[search_start:search_end]:
                            return ExtractedKey(
                                address=base_addr + i,
                                key_type=KeyType.RSA_PUBLIC,
                                key_size=bit_size_int,
                                raw_bytes=data[i : i + byte_size],
                                parameters={
                                    "modulus": modulus,
                                    "exponent": exp,
                                    "montgomery_const_offset": mont_offset,
                                },
                                confidence=0.85,
                                context=f"RSA-{bit_size_int} with Montgomery optimization",
                            )

        return None

    def _find_des_subkeys(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Find DES subkeys in memory."""
        keys = []
        des_patterns = self.rsa_patterns["key_schedules"]["des_subkeys"]

        # Look for PC1/PC2 permutation tables
        pc1 = des_patterns["pc1"]
        pc1_offset = 0
        while True:
            pc1_offset = data.find(pc1, pc1_offset)
            if pc1_offset == -1:
                break

            # DES keys are typically nearby
            for i in range(max(0, pc1_offset - 1024), min(len(data) - 768, pc1_offset + 1024)):
                # DES uses 16 48-bit subkeys (96 bytes total)
                subkeys = data[i : i + 96]
                if self._verify_des_subkeys(subkeys):
                    keys.append(
                        ExtractedKey(
                            address=base_addr + i,
                            key_type=KeyType.DES3,
                            key_size=168,  # 3DES effective key size
                            raw_bytes=subkeys,
                            parameters={"subkey_count": 16},
                            confidence=0.75,
                            context="DES/3DES subkey schedule",
                        ),
                    )

            pc1_offset += 1

        return keys

    def _verify_des_subkeys(self, subkeys: bytes) -> bool:
        """Verify DES subkey schedule."""
        if len(subkeys) != 96:  # 16 subkeys * 6 bytes each
            return False

        # Check for patterns in subkey relationships
        # DES subkeys have specific rotation patterns

        # Basic verification - subkeys shouldn't be all zeros or all ones
        return subkeys not in (b"\x00" * 96, b"\xff" * 96)

    def _find_chacha_state(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Find ChaCha20 state in memory."""
        keys = []
        chacha_patterns = self.rsa_patterns["key_schedules"]["chacha20_state"]

        # Look for ChaCha constants
        constants = chacha_patterns["constants"]
        offset = 0
        while True:
            offset = data.find(constants, offset)
            if offset == -1:
                break

            # ChaCha state is 64 bytes (16 uint32s)
            if offset + 64 <= len(data):
                state = data[offset : offset + 64]

                # Extract key from state (bytes 16-47)
                key = state[16:48]
                nonce = state[48:60]

                keys.append(
                    ExtractedKey(
                        address=base_addr + offset,
                        key_type=KeyType.AES,  # ChaCha uses similar key size
                        key_size=256,
                        raw_bytes=key,
                        parameters={
                            "nonce": nonce.hex(),
                            "algorithm": "ChaCha20",
                        },
                        confidence=0.8,
                        context="ChaCha20 stream cipher state",
                    ),
                )

            offset += 1

        return keys

    def _detect_api_structures(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Detect and extract keys from crypto API structures."""
        keys = []
        api_sigs = self.rsa_patterns["crypto_apis"]

        # Platform-specific detection
        import platform

        system = platform.system().lower()

        if "windows" in system:
            keys.extend(self._detect_windows_crypto_apis(data, base_addr, api_sigs["windows"]))
        elif "linux" in system:
            keys.extend(self._detect_linux_crypto_apis(data, base_addr, api_sigs["linux"]))

        return keys

    def _detect_windows_crypto_apis(self, data: bytes, base_addr: int, api_sigs: dict) -> list[ExtractedKey]:
        """Detect Windows crypto API structures."""
        keys = []

        # BCrypt structures
        for api_name, sig_info in api_sigs["bcrypt"].items():
            sig = sig_info["signature"]
            offset = 0
            while True:
                offset = data.find(sig, offset)
                if offset == -1:
                    break

                if key := self._extract_bcrypt_key(data, offset, base_addr):
                    key.context = f"Windows BCrypt API - {api_name}"
                    keys.append(key)

                offset += 1

        return keys

    def _extract_bcrypt_key(self, data: bytes, offset: int, base_addr: int) -> ExtractedKey | None:
        """Extract key from BCrypt structure."""
        # BCrypt key structure analysis
        if offset + 128 > len(data):
            return None

        # Check for BCRYPT_KEY_DATA_BLOB_HEADER
        magic = int.from_bytes(data[offset : offset + 4], "little")
        if magic == 0x4D42434B:  # 'KBCM'
            version = int.from_bytes(data[offset + 4 : offset + 8], "little")
            key_length = int.from_bytes(data[offset + 8 : offset + 12], "little")

            if key_length > 0 and key_length <= 512 and offset + 32 + key_length <= len(data):
                key_data = data[offset + 32 : offset + 32 + key_length]
                return ExtractedKey(
                    address=base_addr + offset,
                    key_type=KeyType.AES if key_length in [16, 24, 32] else KeyType.CUSTOM,
                    key_size=key_length * 8,
                    raw_bytes=key_data,
                    parameters={"api": "BCrypt", "version": version},
                    confidence=0.95,
                    context="Windows BCrypt key",
                )

        return None

    def _detect_linux_crypto_apis(self, data: bytes, base_addr: int, api_sigs: dict) -> list[ExtractedKey]:
        """Detect Linux crypto API structures."""
        keys = []

        # OpenSSL structures - these would need symbol resolution in practice
        # This is a simplified detection based on structure patterns
        keys.extend(self._detect_openssl_structures(data, base_addr))

        return keys

    def _detect_openssl_structures(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Detect OpenSSL crypto structures."""
        keys = []
        structures = self.key_formats["memory_structures"]["openssl"]

        # Look for RSA structure patterns
        rsa_struct = structures["rsa_st"]

        # Search for common public exponent values at expected offset
        for exp in [0x10001, 0x03]:
            exp_bytes = exp.to_bytes(4, "little")
            offset = 0
            while True:
                offset = data.find(exp_bytes, offset)
                if offset == -1:
                    break

                # Check if this could be part of RSA structure
                struct_start = offset - rsa_struct["e_offset"]
                if struct_start >= 0 and struct_start + rsa_struct["structure_size"] <= len(data):
                    if key := self._extract_openssl_rsa(data, struct_start, base_addr, rsa_struct):
                        keys.append(key)

                offset += 1

        return keys

    def _extract_openssl_rsa(self, data: bytes, offset: int, base_addr: int, struct_info: dict) -> ExtractedKey | None:
        """Extract RSA key from OpenSSL structure."""
        try:
            # Extract components from structure offsets
            n_ptr_offset = offset + struct_info["n_offset"]
            e_ptr_offset = offset + struct_info["e_offset"]

            if n_ptr_offset + 8 <= len(data) and e_ptr_offset + 8 <= len(data):
                # In real implementation, would follow pointers
                # For now, look for big integers nearby
                for i in range(max(0, offset - 4096), min(len(data) - 256, offset + 4096)):
                    # Check for RSA modulus pattern
                    if data[i] & 0x80 and data[i + 255] & 0x01:
                        modulus = int.from_bytes(data[i : i + 256], "big")
                        return ExtractedKey(
                            address=base_addr + offset,
                            key_type=KeyType.RSA_PUBLIC,
                            key_size=2048,
                            raw_bytes=data[i : i + 256],
                            parameters={"modulus": modulus, "exponent": 0x10001},
                            confidence=0.7,
                            context="OpenSSL RSA structure",
                        )
        except Exception as e:
            logger.debug("OpenSSL RSA structure parsing failed: %s", e, exc_info=True)

        return None

    def _extract_from_crypto_structures(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Extract keys from known crypto library structures."""
        keys = []
        memory_structs = self.key_formats["memory_structures"]

        # Check each crypto library's structures
        for lib_name, lib_structs in memory_structs.items():
            if lib_name == "windows_cng":
                keys.extend(self._extract_cng_keys(data, base_addr, lib_structs))
            elif lib_name == "mbedtls":
                keys.extend(self._extract_mbedtls_keys(data, base_addr, lib_structs))
            elif lib_name == "boringssl":
                keys.extend(self._extract_boringssl_keys(data, base_addr, lib_structs))

        return keys

    def _extract_cng_keys(self, data: bytes, base_addr: int, structs: dict) -> list[ExtractedKey]:
        """Extract keys from Windows CNG structures."""
        keys = []
        bcrypt_struct = structs["bcrypt_key_handle"]

        # Search for BCrypt magic
        magic_bytes = bcrypt_struct["magic"].to_bytes(4, "little")
        offset = 0
        while True:
            offset = data.find(magic_bytes, offset)
            if offset == -1:
                break

            if offset + bcrypt_struct["header_size"] <= len(data):
                key_data_offset = offset + bcrypt_struct["key_data_offset"]
                # Extract key size from header
                key_size = int.from_bytes(data[offset + 8 : offset + 12], "little")

                if key_size > 0 and key_size <= 512 and key_data_offset + key_size <= len(data):
                    key_bytes = data[key_data_offset : key_data_offset + key_size]
                    keys.append(
                        ExtractedKey(
                            address=base_addr + key_data_offset,
                            key_type=KeyType.AES if key_size in [16, 24, 32] else KeyType.CUSTOM,
                            key_size=key_size * 8,
                            raw_bytes=key_bytes,
                            parameters={"provider": "CNG"},
                            confidence=0.9,
                            context="Windows CNG key",
                        ),
                    )

            offset += 1

        return keys

    def _extract_mbedtls_keys(self, data: bytes, base_addr: int, structs: dict) -> list[ExtractedKey]:
        """Extract keys from mbedTLS structures."""
        keys = []
        rsa_ctx = structs["mbedtls_rsa_context"]

        # mbedTLS RSA context detection
        for i in range(0, len(data) - rsa_ctx["structure_size"], 4):
            # Check version field (should be 0 or 1)
            ver = int.from_bytes(data[i : i + 4], "little")
            if ver in [0, 1]:
                # Check length field (RSA bit length)
                length = int.from_bytes(data[i + rsa_ctx["len_offset"] : i + rsa_ctx["len_offset"] + 4], "little")
                if length in [1024, 2048, 3072, 4096]:
                    # Extract modulus
                    n_offset = i + rsa_ctx["n_offset"]
                    n_size = length // 8
                    if n_offset + n_size <= len(data):
                        modulus = data[n_offset : n_offset + n_size]
                        if modulus[0] & 0x80:  # High bit should be set
                            keys.append(
                                ExtractedKey(
                                    address=base_addr + i,
                                    key_type=KeyType.RSA_PUBLIC,
                                    key_size=length,
                                    raw_bytes=modulus,
                                    parameters={"library": "mbedTLS", "version": ver},
                                    confidence=0.75,
                                    context="mbedTLS RSA context",
                                ),
                            )

        return keys

    def _extract_boringssl_keys(self, data: bytes, base_addr: int, structs: dict) -> list[ExtractedKey]:
        """Extract keys from BoringSSL structures."""
        keys = []
        ec_struct = structs["ec_key"]

        # BoringSSL EC key detection
        for i in range(0, len(data) - ec_struct["structure_size"], 8):
            # Check for valid EC coordinates
            pub_x_offset = i + ec_struct["pub_x_offset"]
            pub_y_offset = i + ec_struct["pub_y_offset"]

            if pub_x_offset + 32 <= len(data) and pub_y_offset + 32 <= len(data):
                x = data[pub_x_offset : pub_x_offset + 32]
                y = data[pub_y_offset : pub_y_offset + 32]

                # Basic validation - coordinates shouldn't be all zeros
                if x != b"\x00" * 32 and y != b"\x00" * 32:
                    # Check if point could be on curve
                    x_int = int.from_bytes(x, "big")
                    y_int = int.from_bytes(y, "big")

                    # Simplified curve check for common curves
                    if x_int < 2**256 and y_int < 2**256:
                        keys.append(
                            ExtractedKey(
                                address=base_addr + i,
                                key_type=KeyType.ECC_PUBLIC,
                                key_size=256,
                                raw_bytes=b"\x04" + x + y,  # Uncompressed point
                                parameters={"x": x_int, "y": y_int, "library": "BoringSSL"},
                                confidence=0.65,
                                context="BoringSSL EC key",
                            ),
                        )

        return keys

    def _perform_side_channel_analysis(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Perform side-channel analysis to detect keys."""
        keys = []
        targets = self.rsa_patterns["side_channel_targets"]

        # Cache timing analysis patterns
        keys.extend(self._analyze_cache_timing(data, base_addr, targets["cache_timing"]))

        # Power analysis patterns
        keys.extend(self._analyze_power_patterns(data, base_addr, targets["power_analysis"]))

        return keys

    def _analyze_cache_timing(self, data: bytes, base_addr: int, timing_targets: dict) -> list[ExtractedKey]:
        """Analyze cache timing patterns for key extraction."""
        keys = []

        # AES T-table analysis
        aes_targets = timing_targets["aes_table_lookups"]
        cache_line_size = aes_targets["cache_line_size"]

        # Build actual AES T-tables for detection
        te0, te1, te2, te3 = self._build_aes_t_tables()

        # Search for T-table patterns in memory
        t_tables = [te0, te1, te2, te3]
        for table_idx, t_table in enumerate(t_tables):
            # Look for each T-table in memory
            for start_idx in range(min(256, len(t_table) // 4)):
                # Extract a portion of the T-table for searching
                table_segment = t_table[start_idx * 4 : (start_idx + 16) * 4]

                offset = 0
                while True:
                    offset = data.find(table_segment, offset)
                    if offset == -1:
                        break

                    # Found T-table segment, analyze memory around it
                    # T-tables indicate active AES operations
                    table_start = offset - (start_idx * 4)

                    # Analyze cache access patterns in surrounding memory
                    # Keys are typically within a few cache lines of T-tables
                    cache_search_start = max(0, table_start - cache_line_size * 32)
                    cache_search_end = min(len(data), table_start + 1024 + cache_line_size * 32)

                    # Look for aligned memory that could contain keys
                    for addr in range(cache_search_start, cache_search_end - 16, cache_line_size):
                        key_candidate = data[addr : addr + 16]

                        # Analyze cache timing characteristics
                        timing_score = self._calculate_cache_timing_score(key_candidate, data, table_start, cache_line_size)

                        if timing_score > 0.7:
                            keys.append(
                                ExtractedKey(
                                    address=base_addr + addr,
                                    key_type=KeyType.AES,
                                    key_size=128,
                                    raw_bytes=key_candidate,
                                    parameters={
                                        "extraction_method": "cache_timing",
                                        "t_table_offset": table_start,
                                        "t_table_index": table_idx,
                                        "cache_timing_score": timing_score,
                                        "cache_line_alignment": addr % cache_line_size,
                                    },
                                    confidence=timing_score * 0.8,
                                    context=f"AES key via cache timing analysis (Te{table_idx})",
                                ),
                            )

                    offset += 1

        return keys

    def _build_aes_t_tables(self) -> tuple:
        """Build AES T-tables used in optimized implementations."""
        sbox = self._get_aes_sbox()

        # Build the four T-tables (Te0, Te1, Te2, Te3)
        te0 = bytearray(256 * 4)
        te1 = bytearray(256 * 4)
        te2 = bytearray(256 * 4)
        te3 = bytearray(256 * 4)

        for i in range(256):
            s = sbox[i]

            # Multiplication in GF(2^8)
            x2 = self._gf_mul(s, 2)
            x3 = self._gf_mul(s, 3)

            # Te0[i] = [x2, s, s, x3]
            te0[i * 4 : i * 4 + 4] = bytes([x2, s, s, x3])

            # Te1[i] = [x3, x2, s, s] (rotated)
            te1[i * 4 : i * 4 + 4] = bytes([x3, x2, s, s])

            # Te2[i] = [s, x3, x2, s] (rotated)
            te2[i * 4 : i * 4 + 4] = bytes([s, x3, x2, s])

            # Te3[i] = [s, s, x3, x2] (rotated)
            te3[i * 4 : i * 4 + 4] = bytes([s, s, x3, x2])

        return bytes(te0), bytes(te1), bytes(te2), bytes(te3)

    def _gf_mul(self, a: int, b: int) -> int:
        """Multiplication in GF(2^8) for AES."""
        p = 0
        for _ in range(8):
            if b & 1:
                p ^= a
            if hi_bit := a & 0x80:
                a = (a << 1) & 0xFF
                if hi_bit:
                    a ^= 0x1B  # AES polynomial
            else:
                a = (a << 1) & 0xFF
            b >>= 1
        return p

    def _calculate_cache_timing_score(self, key: bytes, data: bytes, table_offset: int, cache_line_size: int) -> float:
        """Calculate cache timing score based on memory layout and access patterns."""
        score = 0.0

        # Factor 1: Key alignment with cache lines
        key_addr = data.find(key)
        if key_addr != -1:
            alignment = key_addr % cache_line_size
            if alignment == 0:
                score += 0.2  # Cache-aligned keys are more likely

            distance = abs(key_addr - table_offset)
            if distance < cache_line_size * 4:
                score += 0.3  # Very close to T-table
            elif distance < cache_line_size * 16:
                score += 0.2  # Reasonably close
            elif distance < cache_line_size * 64:
                score += 0.1  # Within typical working set

        # Factor 3: Key entropy (valid keys have high entropy)
        entropy = self._calculate_entropy(key)
        if entropy > 7.5:
            score += 0.3
        elif entropy > 7.0:
            score += 0.2
        elif entropy > 6.5:
            score += 0.1

        # Factor 4: Check for AES round key patterns nearby
        if self._has_round_key_pattern(data, key_addr, cache_line_size):
            score += 0.2

        return min(score, 1.0)

    def _has_round_key_pattern(self, data: bytes, key_offset: int, cache_line_size: int) -> bool:
        """Check if there are AES round key patterns near the key."""
        if key_offset == -1:
            return False

        # Look for patterns indicating expanded key schedule
        search_start = max(0, key_offset - cache_line_size * 2)
        search_end = min(len(data), key_offset + 176 + cache_line_size * 2)  # 176 = expanded AES-128 size

        region = data[search_start:search_end]

        # Check for repeating 16-byte patterns with modifications (round keys)
        if len(region) >= 176:
            # Simplified check: look for structured data that could be round keys
            blocks = [region[i : i + 16] for i in range(0, min(176, len(region) - 16), 16)]

            # Round keys have relationships but aren't identical
            unique_blocks = len(set(blocks))
            if 8 <= unique_blocks <= 11:  # Reasonable number of unique blocks for AES-128
                return True

        return False

    def _verify_cache_timing_pattern(self, key: bytes, data: bytes, table_offset: int) -> bool:
        """Verify cache timing pattern for key candidate."""
        # Simplified verification - in reality would analyze actual timing data
        # Check if key has sufficient entropy
        entropy = self._calculate_entropy(key)
        return entropy > 7.0

    def _analyze_power_patterns(self, data: bytes, base_addr: int, power_targets: dict) -> list[ExtractedKey]:
        """Analyze power consumption patterns for key extraction."""
        keys = []

        # Hamming weight analysis
        hamming_weights = power_targets["hamming_weight_patterns"]

        # Look for patterns indicating key operations
        for i in range(0, len(data) - 32, 16):
            key_candidate = data[i : i + 32]

            # Calculate Hamming weight distribution
            weights = [hamming_weights[b] for b in key_candidate]

            # Keys often have balanced Hamming weight
            avg_weight = sum(weights) / len(weights)
            if 3.5 <= avg_weight <= 4.5:  # Balanced weight
                keys.append(
                    ExtractedKey(
                        address=base_addr + i,
                        key_type=KeyType.AES,
                        key_size=256,
                        raw_bytes=key_candidate,
                        parameters={
                            "extraction_method": "power_analysis",
                            "hamming_weight_avg": avg_weight,
                        },
                        confidence=0.5,
                        context="AES-256 key via power analysis",
                    ),
                )

        return keys

    def _runtime_hook_extraction(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Extract keys using runtime API hooking with inline and IAT hooks."""
        keys = []

        # Get hook targets for runtime extraction
        hook_targets = self.key_formats["hook_targets"]

        import platform

        system = platform.system().lower()

        # Platform-specific API hooking
        if "windows" in system:
            # Windows API hooking via IAT, inline hooks, and detours
            keys.extend(self._hook_windows_apis(data, base_addr, hook_targets["windows"]))
            # Also hook universal memory functions
            keys.extend(self._hook_memory_functions(data, base_addr, hook_targets["universal"]))
        elif "linux" in system:
            # Linux API hooking via PLT/GOT and inline hooks
            keys.extend(self._hook_linux_apis(data, base_addr, hook_targets["linux"]))
            # Also hook universal memory functions
            keys.extend(self._hook_memory_functions(data, base_addr, hook_targets["universal"]))

        # Extract keys from hooked function parameters and return values
        keys.extend(self._extract_from_hook_buffers(data, base_addr))

        return keys

    def _hook_memory_functions(self, data: bytes, base_addr: int, func_list: list[str]) -> list[ExtractedKey]:
        """Monitor memory functions for key allocations and copies."""
        keys = []

        # Find memcpy/memmove calls that might be copying keys
        memcpy_patterns = [
            b"\xe8",  # CALL memcpy
            b"\xff\x15",  # CALL [memcpy]
            # x64 intrinsics
            b"\xf3\x0f\x6f",  # MOVDQU for SSE memcpy
            b"\x66\x0f\x6f",  # MOVDQA for aligned copies
        ]

        for pattern in memcpy_patterns:
            offset = 0
            while True:
                offset = data.find(pattern, offset)
                if offset == -1:
                    break

                if key := self._check_memcpy_for_keys(data, offset, base_addr):
                    keys.append(key)

                offset += 1

        # Find malloc/calloc calls that allocate key-sized buffers
        alloc_patterns = self._find_allocation_sites(data)
        for alloc_offset, size in alloc_patterns:
            if size in [16, 24, 32, 48, 64, 128, 256, 512]:  # Common key sizes
                if key := self._check_allocation_for_key(data, alloc_offset, size, base_addr):
                    keys.append(key)

        return keys

    def _check_memcpy_for_keys(self, data: bytes, copy_offset: int, base_addr: int) -> ExtractedKey | None:
        """Check if a memory copy operation is copying cryptographic keys."""
        # Analyze the copy operation
        # Look for source data before the copy
        search_start = max(0, copy_offset - 0x100)
        search_end = min(len(data), copy_offset + 0x100)

        for size in [16, 24, 32]:  # AES key sizes
            for i in range(search_start, search_end - size):
                candidate = data[i : i + size]
                entropy = self._calculate_entropy(candidate)

                if entropy > 7.0:
                    # High entropy data being copied
                    return ExtractedKey(
                        address=base_addr + i,
                        key_type=KeyType.AES,
                        key_size=size * 8,
                        raw_bytes=candidate,
                        parameters={
                            "extraction_method": "memcpy_hook",
                            "copy_site": f"0x{copy_offset:x}",
                        },
                        confidence=0.65,
                        context="Key detected in memory copy operation",
                    )

        return None

    def _find_allocation_sites(self, data: bytes) -> list[tuple]:
        """Find dynamic allocation sites and their sizes."""
        allocations = []

        # Pattern for malloc/calloc calls with size arguments
        # MOV EDI, size; CALL malloc pattern
        malloc_patterns = [
            (b"\xbf", 4),  # MOV EDI, imm32 (x64)
            (b"\xb9", 4),  # MOV ECX, imm32 (x86/x64 Windows)
            (b"\x48\xc7\xc7", 4),  # MOV RDI, imm32 (x64)
            (b"\x48\xc7\xc1", 4),  # MOV RCX, imm32 (x64 Windows)
        ]

        for pattern, size_len in malloc_patterns:
            offset = 0
            while True:
                offset = data.find(pattern, offset)
                if offset == -1:
                    break

                if offset + len(pattern) + size_len <= len(data):
                    # Extract size argument
                    size_offset = offset + len(pattern)
                    size = int.from_bytes(data[size_offset : size_offset + size_len], "little")

                    # Look for malloc call after size setup
                    call_search_end = min(len(data), offset + 20)
                    if b"\xe8" in data[offset:call_search_end] or b"\xff\x15" in data[offset:call_search_end]:
                        allocations.append((offset, size))

                offset += 1

        return allocations

    def _check_allocation_for_key(self, data: bytes, alloc_offset: int, size: int, base_addr: int) -> ExtractedKey | None:
        """Check if an allocation is used for a cryptographic key."""
        search_end = min(len(data), alloc_offset + 0x200)

        search_start = alloc_offset
        for i in range(search_start, search_end - size):
            candidate = data[i : i + size]
            entropy = self._calculate_entropy(candidate)

            if entropy > 7.5 and candidate != b"\x00" * size:
                # Determine key type based on size
                if size in {16, 24, 32}:
                    key_type = KeyType.AES
                elif size in {128, 256, 512}:
                    key_type = KeyType.RSA_PUBLIC
                else:
                    key_type = KeyType.CUSTOM
                key_bits = size * 8
                return ExtractedKey(
                    address=base_addr + i,
                    key_type=key_type,
                    key_size=key_bits,
                    raw_bytes=candidate,
                    parameters={
                        "extraction_method": "allocation_hook",
                        "alloc_site": f"0x{search_start:x}",
                        "alloc_size": size,
                    },
                    confidence=0.6,
                    context=f"Key detected in allocated buffer (size={size})",
                )
        return None

    def _extract_from_hook_buffers(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Extract keys from instrumentation buffers used by hooks."""
        keys = []

        # Look for hook trampoline patterns
        trampoline_patterns = [
            b"\xe9",  # JMP rel32 (common hook trampoline)
            b"\x48\xb8",  # MOV RAX, imm64 (x64 absolute jump)
            b"\x68",  # PUSH imm32 (x86 hook prologue)
        ]

        for pattern in trampoline_patterns:
            offset = 0
            while True:
                offset = data.find(pattern, offset)
                if offset == -1:
                    break

                # Check if this is a hook trampoline
                if self._is_hook_trampoline(data, offset):
                    # Look for saved parameters nearby
                    param_keys = self._extract_hook_parameters(data, offset, base_addr)
                    keys.extend(param_keys)

                offset += 1

        # Look for detours-style hooks
        detours_keys = self._extract_detours_hooks(data, base_addr)
        keys.extend(detours_keys)

        return keys

    def _is_hook_trampoline(self, data: bytes, offset: int) -> bool:
        """Check if offset points to a hook trampoline."""
        if offset + 10 > len(data):
            return False

        # Check for common hook patterns
        if data[offset] == 0xE9:  # JMP
            # Check if target is valid
            target = int.from_bytes(data[offset + 1 : offset + 5], "little", signed=True)
            return abs(target) < 0x10000000  # Reasonable jump distance

        if data[offset : offset + 2] == b"\x48\xb8" and offset + 12 <= len(data):
            return data[offset + 10 : offset + 12] in [b"\xff\xe0", b"\xff\xd0"]

        return False

    def _extract_hook_parameters(self, data: bytes, hook_offset: int, base_addr: int) -> list[ExtractedKey]:
        """Extract keys from hook parameter storage."""
        keys = []

        # Hooks often save parameters on stack or in global storage
        # Look for parameter saves near hook
        search_start = max(0, hook_offset - 0x100)
        search_end = min(len(data), hook_offset + 0x100)

        # Check for saved crypto parameters
        for i in range(search_start, search_end - 32):
            # Look for potential key data
            for key_size in [16, 24, 32]:
                if i + key_size <= len(data):
                    candidate = data[i : i + key_size]
                    entropy = self._calculate_entropy(candidate)

                    if entropy > 7.0:
                        keys.append(
                            ExtractedKey(
                                address=base_addr + i,
                                key_type=KeyType.AES,
                                key_size=key_size * 8,
                                raw_bytes=candidate,
                                parameters={
                                    "extraction_method": "hook_parameters",
                                    "hook_offset": f"0x{hook_offset:x}",
                                },
                                confidence=0.55,
                                context="Key extracted from hook parameters",
                            ),
                        )

        return keys

    def _extract_detours_hooks(self, data: bytes, base_addr: int) -> list[ExtractedKey]:
        """Extract keys from Microsoft Detours-style hooks."""
        keys = []

        # Detours creates specific trampoline structures
        # Look for Detours signatures
        detours_sig = b"DETOURS"  # Common in debug builds
        offset = data.find(detours_sig)

        if offset != -1:
            # Detours found, look for hooked crypto functions
            # Detours trampolines are typically nearby
            search_start = max(0, offset - 0x1000)
            search_end = min(len(data), offset + 0x1000)

            for i in range(search_start, search_end - 32):
                # Check for crypto key patterns
                for key_size in [16, 24, 32, 64, 128, 256]:
                    if i + key_size <= len(data):
                        candidate = data[i : i + key_size]

                        # Validate as potential key
                        if self._is_valid_key_data(candidate):
                            key_type = KeyType.AES if key_size <= 32 else KeyType.RSA_PUBLIC
                            keys.append(
                                ExtractedKey(
                                    address=base_addr + i,
                                    key_type=key_type,
                                    key_size=key_size * 8,
                                    raw_bytes=candidate,
                                    parameters={
                                        "extraction_method": "detours_hook",
                                        "detours_offset": f"0x{offset:x}",
                                    },
                                    confidence=0.5,
                                    context="Key extracted via Detours hook",
                                ),
                            )

        return keys

    def _is_valid_key_data(self, data: bytes) -> bool:
        """Validate if data could be a cryptographic key."""
        if len(data) < 16:
            return False

        # Check entropy
        entropy = self._calculate_entropy(data)
        if entropy < 6.5:
            return False

        # Not all zeros or ones
        if data in [b"\x00" * len(data), b"\xff" * len(data)]:
            return False

        # Check for structure (keys aren't usually ASCII text)
        ascii_count = sum(bool(32 <= b <= 126) for b in data)
        return ascii_count <= len(data) * 0.9

    def _hook_windows_apis(self, data: bytes, base_addr: int, api_list: list[str]) -> list[ExtractedKey]:
        """Extract keys from Windows crypto APIs via IAT and inline hooking."""
        keys = []

        # Detect API call sites using x86/x64 call patterns
        call_sites = self._find_api_call_sites(data, api_list)

        for api_name, call_offsets in call_sites.items():
            # Analyze each API call site
            for call_offset in call_offsets:
                # Analyze the calling convention and parameters
                param_locations = self._analyze_call_parameters(data, call_offset, api_name)

                if "GenerateSymmetricKey" in api_name:
                    if key := self._extract_bcrypt_symmetric_key(data, call_offset, param_locations, base_addr):
                        keys.append(key)

                elif "GenerateKeyPair" in api_name:
                    if key := self._extract_bcrypt_key_pair(data, call_offset, param_locations, base_addr):
                        keys.append(key)

                elif "ImportKey" in api_name:
                    if key := self._extract_imported_key(data, call_offset, param_locations, base_addr):
                        keys.append(key)

                elif "ExportKey" in api_name:
                    if key := self._extract_exported_key(data, call_offset, param_locations, base_addr):
                        keys.append(key)

        # Also check for IAT hooking opportunities
        iat_keys = self._analyze_import_table(data, base_addr, api_list)
        keys.extend(iat_keys)

        return keys

    def _find_api_call_sites(self, data: bytes, api_list: list[str]) -> dict[str, list[int]]:
        """Find API call sites in binary code."""
        call_sites = {}

        # Common x86/x64 call patterns
        # E8 = relative call, FF 15 = indirect call through pointer
        call_patterns = [
            b"\xe8",  # CALL rel32
            b"\xff\x15",  # CALL [rip+rel32] (x64)
            b"\xff\xd0",  # CALL rax
            b"\xff\xd1",  # CALL rcx
            b"\xff\xd2",  # CALL rdx
        ]

        for api_name in api_list:
            call_sites[api_name] = []

            # Look for DLL and API name references
            dll_name = self._get_dll_for_api(api_name)
            api_bytes = api_name.encode("ascii") + b"\x00"
            dll_name.encode("ascii") + b"\x00"

            # Find string references
            api_offset = 0
            while True:
                api_offset = data.find(api_bytes, api_offset)
                if api_offset == -1:
                    break

                # Look for calls near the API string reference
                search_start = max(0, api_offset - 0x1000)
                search_end = min(len(data), api_offset + 0x1000)

                for pattern in call_patterns:
                    call_offset = search_start
                    while call_offset < search_end:
                        call_offset = data.find(pattern, call_offset, search_end)
                        if call_offset == -1:
                            break

                        # Verify it's a valid call instruction
                        if self._is_valid_call(data, call_offset, pattern):
                            call_sites[api_name].append(call_offset)

                        call_offset += len(pattern)

                api_offset += len(api_bytes)

        return call_sites

    def _get_dll_for_api(self, api_name: str) -> str:
        """Get DLL name for a given API."""
        api_dll_map = {
            "BCrypt": "bcrypt.dll",
            "NCrypt": "ncrypt.dll",
            "Crypt": "advapi32.dll",
        }

        return next(
            (dll for prefix, dll in api_dll_map.items() if api_name.startswith(prefix)),
            "kernel32.dll",
        )

    def _is_valid_call(self, data: bytes, offset: int, pattern: bytes) -> bool:
        """Verify if the pattern at offset is a valid call instruction."""
        if pattern == b"\xe8" and offset + 5 <= len(data):
            # Verify the call target is within reasonable range
            rel_offset = int.from_bytes(data[offset + 1 : offset + 5], "little", signed=True)
            target = offset + 5 + rel_offset
            return 0 <= target < len(data)

        elif (
            pattern != b"\xe8"
            and (pattern != b"\xff\x15" or offset + 6 <= len(data))
            and pattern in {b"\xff\x15", b"\xff\xd0", b"\xff\xd1", b"\xff\xd2"}
        ):
            return True

        return False

    def _analyze_call_parameters(self, data: bytes, call_offset: int, api_name: str) -> dict[str, int]:
        """Analyze calling convention to find parameter locations."""
        params = {}

        # Windows x64 calling convention: RCX, RDX, R8, R9, then stack
        # Look backwards from call for parameter setup

        # Common parameter setup patterns
        param_patterns = {
            "rcx": [b"\x48\x8d\x0d", b"\x48\x8b\x0d", b"\x48\x89"],  # LEA RCX / MOV RCX
            "rdx": [b"\x48\x8d\x15", b"\x48\x8b\x15", b"\x48\x89"],  # LEA RDX / MOV RDX
            "r8": [b"\x4c\x8d\x05", b"\x4c\x8b\x05", b"\x4c\x89"],  # LEA R8 / MOV R8
            "r9": [b"\x4c\x8d\x0d", b"\x4c\x8b\x0d", b"\x4c\x89"],  # LEA R9 / MOV R9
        }

        # Search backwards for parameter setup
        search_start = max(0, call_offset - 100)
        search_region = data[search_start:call_offset]

        for reg, patterns in param_patterns.items():
            for pattern in patterns:
                offset = search_region.rfind(pattern)
                if offset != -1:
                    params[reg] = search_start + offset
                    break

        return params

    def _extract_bcrypt_symmetric_key(
        self,
        data: bytes,
        call_offset: int,
        params: dict[str, int],
        base_addr: int,
    ) -> ExtractedKey | None:
        """Extract symmetric key from BCryptGenerateSymmetricKey call."""
        search_end = min(len(data), call_offset + 0x200)

        search_start = call_offset
        # The key will be written to memory shortly after generation
        for i in range(search_start, search_end - 32):
            # Check for high entropy data that could be a key
            key_candidate = data[i : i + 32]
            entropy = self._calculate_entropy(key_candidate)

            if entropy > 7.0 and key_candidate != b"\x00" * 32 and self._is_bcrypt_key_structure(data, i):
                return ExtractedKey(
                    address=base_addr + i,
                    key_type=KeyType.AES,
                    key_size=len(key_candidate) * 8,
                    raw_bytes=key_candidate,
                    parameters={
                        "api": "BCryptGenerateSymmetricKey",
                        "call_site": f"0x{search_start:x}",
                    },
                    confidence=0.85,
                    context="BCrypt generated symmetric key",
                )
        return None

    def _is_bcrypt_key_structure(self, data: bytes, offset: int) -> bool:
        """Check if offset points to a BCrypt key structure."""
        # BCrypt keys often have specific alignment and headers
        if offset >= 32 and offset + 64 <= len(data):
            # Check for BCrypt magic values or structure patterns
            # Keys are often preceded by size/algorithm information
            header = data[offset - 32 : offset]

            # Look for algorithm identifiers
            alg_patterns = [
                b"AES\x00",
                b"3DES",
                b"DES\x00",
                b"RC4\x00",
            ]

            for pattern in alg_patterns:
                if pattern in header:
                    return True

        return False

    def _extract_bcrypt_key_pair(self, data: bytes, call_offset: int, params: dict[str, int], base_addr: int) -> ExtractedKey | None:
        """Extract key pair from BCryptGenerateKeyPair call."""
        search_end = min(len(data), call_offset + 0x1000)

        search_start = call_offset
        # Check for RSA modulus patterns
        for key_size in [1024, 2048, 3072, 4096]:
            byte_size = key_size // 8

            for i in range(search_start, search_end - byte_size):
                if data[i] & 0x80 and data[i + byte_size - 1] & 0x01:
                    # Potential RSA modulus
                    modulus = int.from_bytes(data[i : i + byte_size], "big")

                    if self._is_probably_prime_product(modulus):
                        return ExtractedKey(
                            address=base_addr + i,
                            key_type=KeyType.RSA_PUBLIC,
                            key_size=key_size,
                            raw_bytes=data[i : i + byte_size],
                            parameters={
                                "api": "BCryptGenerateKeyPair",
                                "modulus": modulus,
                                "call_site": f"0x{search_start:x}",
                            },
                            confidence=0.8,
                            context="BCrypt generated RSA key pair",
                        )
        return None

    def _extract_imported_key(self, data: bytes, call_offset: int, params: dict[str, int], base_addr: int) -> ExtractedKey | None:
        """Extract key from BCryptImportKey call."""
        # The key data is passed as a parameter to the import function
        # Look for the key blob before the call

        search_start = max(0, call_offset - 0x200)
        search_end = call_offset

        # Look for key blob headers
        blob_headers = {
            b"RSA1": KeyType.RSA_PUBLIC,  # BCRYPT_RSAPUBLIC_BLOB
            b"RSA2": KeyType.RSA_PRIVATE,  # BCRYPT_RSAPRIVATE_BLOB
            b"ECCPUBLICBLOB": KeyType.ECC_PUBLIC,
            b"ECCPRIVATEBLOB": KeyType.ECC_PRIVATE,
        }

        for header, key_type in blob_headers.items():
            offset = data.find(header, search_start, search_end)
            if offset != -1:
                if key_data := self._extract_key_from_blob(data, offset, header):
                    return ExtractedKey(
                        address=base_addr + offset,
                        key_type=key_type,
                        key_size=len(key_data) * 8,
                        raw_bytes=key_data,
                        parameters={
                            "api": "BCryptImportKey",
                            "blob_type": header.decode("ascii", errors="ignore"),
                            "call_site": f"0x{search_end:x}",
                        },
                        confidence=0.9,
                        context="BCrypt imported key",
                    )
        return None

    def _extract_key_from_blob(self, data: bytes, blob_offset: int, header: bytes) -> bytes | None:
        """Extract key data from BCrypt blob structure."""
        if header in {b"RSA1", b"RSA2"} and blob_offset + 32 <= len(data):
            int.from_bytes(data[blob_offset + 8 : blob_offset + 12], "little")
            cb_modulus = int.from_bytes(data[blob_offset + 16 : blob_offset + 20], "little")

            # Extract modulus
            modulus_offset = blob_offset + 32  # After header
            if modulus_offset + cb_modulus <= len(data):
                return data[modulus_offset : modulus_offset + cb_modulus]

        return None

    def _extract_exported_key(self, data: bytes, call_offset: int, params: dict[str, int], base_addr: int) -> ExtractedKey | None:
        """Extract key from BCryptExportKey call."""
        search_end = min(len(data), call_offset + 0x400)

        search_start = call_offset
        # Look for exported key blobs
        for i in range(search_start, search_end - 32):
            # Check for blob headers
            if data[i : i + 4] in [b"RSA1", b"RSA2", b"ECCPUBLICBLOB"[:4], b"SYMM"]:
                if key_data := self._extract_key_from_blob(data, i, data[i : i + 4]):
                    return ExtractedKey(
                        address=base_addr + i,
                        key_type=KeyType.CUSTOM,
                        key_size=len(key_data) * 8,
                        raw_bytes=key_data,
                        parameters={
                            "api": "BCryptExportKey",
                            "call_site": f"0x{search_start:x}",
                        },
                        confidence=0.75,
                        context="BCrypt exported key",
                    )
        return None

    def _analyze_import_table(self, data: bytes, base_addr: int, api_list: list[str]) -> list[ExtractedKey]:
        """Analyze PE import table for crypto API usage."""
        keys = []

        # Parse PE header to find import table
        if len(data) > 0x40 and data[:2] == b"MZ":
            pe_offset = int.from_bytes(data[0x3C:0x40], "little")

            if pe_offset + 4 <= len(data) and data[pe_offset : pe_offset + 4] == b"PE\x00\x00":
                # Parse import table
                import_keys = self._parse_import_table(data, pe_offset, base_addr, api_list)
                keys.extend(import_keys)

        return keys

    def _parse_import_table(self, data: bytes, pe_offset: int, base_addr: int, api_list: list[str]) -> list[ExtractedKey]:
        """Parse PE import table for crypto APIs."""
        # Get import table RVA from data directories
        if pe_offset + 0x80 <= len(data):
            # Import table is at index 1 in data directories
            int.from_bytes(data[pe_offset + 0x80 : pe_offset + 0x84], "little")
            int.from_bytes(data[pe_offset + 0x84 : pe_offset + 0x88], "little")

        return []

    def _find_generated_symmetric_keys(self, data: bytes, base_addr: int, api_name: str) -> list[ExtractedKey]:
        """Find symmetric keys generated by API calls."""
        keys = []

        # Pattern for symmetric key after generation
        # Keys are often aligned and have high entropy
        for i in range(0, len(data) - 32, 16):  # 16-byte alignment
            key_candidate = data[i : i + 32]
            entropy = self._calculate_entropy(key_candidate)

            if entropy > 7.5 and key_candidate not in (b"\x00" * 32, b"\xff" * 32):
                keys.append(
                    ExtractedKey(
                        address=base_addr + i,
                        key_type=KeyType.AES,
                        key_size=256,
                        raw_bytes=key_candidate,
                        parameters={
                            "api": api_name,
                            "entropy": entropy,
                        },
                        confidence=0.7,
                        context=f"Symmetric key from {api_name}",
                    ),
                )

        return keys

    def _find_generated_key_pairs(self, data: bytes, base_addr: int, api_name: str) -> list[ExtractedKey]:
        """Find asymmetric key pairs generated by API calls."""
        keys = []

        # Look for RSA key pair patterns
        for key_size in [2048, 3072, 4096]:
            byte_size = key_size // 8

            for i in range(0, len(data) - byte_size, 64):  # 64-byte alignment for large keys
                # Check for RSA modulus pattern
                if data[i] & 0x80 and data[i + byte_size - 1] & 0x01:
                    modulus = int.from_bytes(data[i : i + byte_size], "big")

                    # Quick primality check
                    if self._is_probably_prime_product(modulus):
                        keys.append(
                            ExtractedKey(
                                address=base_addr + i,
                                key_type=KeyType.RSA_PUBLIC,
                                key_size=key_size,
                                raw_bytes=data[i : i + byte_size],
                                parameters={
                                    "modulus": modulus,
                                    "api": api_name,
                                },
                                confidence=0.75,
                                context=f"RSA key from {api_name}",
                            ),
                        )

        return keys

    def _is_probably_prime_product(self, n: int) -> bool:
        """Check if number is likely product of two primes."""
        # Basic check - not divisible by small primes
        small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
        return all(n % p != 0 for p in small_primes)

    def _hook_linux_apis(self, data: bytes, base_addr: int, api_list: list[str]) -> list[ExtractedKey]:
        """Extract keys from Linux crypto APIs."""
        keys = []

        # Similar to Windows but for Linux APIs
        for api_name in api_list:
            if "AES_set" in api_name:
                keys.extend(self._find_aes_keys_linux(data, base_addr, api_name))
            elif "RSA_generate" in api_name:
                keys.extend(self._find_rsa_keys_linux(data, base_addr, api_name))

        return keys

    def _find_aes_keys_linux(self, data: bytes, base_addr: int, api_name: str) -> list[ExtractedKey]:
        """Find AES keys from Linux API calls."""
        keys = []

        # Linux often uses specific alignment for crypto structures
        for i in range(0, len(data) - 32, 8):  # 8-byte alignment
            for key_size in [16, 24, 32]:
                if i + key_size <= len(data):
                    key_candidate = data[i : i + key_size]
                    entropy = self._calculate_entropy(key_candidate)

                    if entropy > 7.0:
                        keys.append(
                            ExtractedKey(
                                address=base_addr + i,
                                key_type=KeyType.AES,
                                key_size=key_size * 8,
                                raw_bytes=key_candidate,
                                parameters={"api": api_name},
                                confidence=0.65,
                                context=f"AES key from {api_name}",
                            ),
                        )

        return keys

    def _find_rsa_keys_linux(self, data: bytes, base_addr: int, api_name: str) -> list[ExtractedKey]:
        """Find RSA keys from Linux API calls."""
        # Similar to Windows RSA detection but adapted for Linux
        return self._find_generated_key_pairs(data, base_addr, api_name)

    def _extract_rsa_keys(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Extract RSA keys from binary data."""
        keys = []

        # Search for ASN.1 DER encoded RSA keys
        for key_type, header in self.rsa_patterns["asn1_headers"].items():
            offset = 0
            while True:
                offset = data.find(header, offset)
                if offset == -1:
                    break

                if key := self._parse_rsa_der(data[offset:], offset + base_address, key_type):
                    keys.append(key)

                offset += 1

        # Search for raw RSA components (modulus patterns)
        for size in self.rsa_patterns["modulus_sizes"]:
            keys.extend(self._find_rsa_modulus(data, size, base_address))

        return keys

    def _parse_rsa_der(self, der_data: bytes, address: int, key_type: str) -> ExtractedKey | None:
        """Parse DER encoded RSA key."""
        try:
            # Parse ASN.1 structure
            if len(der_data) < 100:
                return None

            # Extract key components based on type
            if "public" in key_type:
                # Parse public key
                key_obj = serialization.load_der_public_key(der_data[:1024], backend=default_backend())
                if isinstance(key_obj, rsa.RSAPublicKey):
                    numbers = key_obj.public_numbers()
                    return ExtractedKey(
                        address=address,
                        key_type=KeyType.RSA_PUBLIC,
                        key_size=key_obj.key_size,
                        raw_bytes=der_data[:1024],
                        parameters={"modulus": numbers.n, "exponent": numbers.e},
                        confidence=0.95,
                        context="DER encoded RSA public key",
                        pem_format=key_obj.public_bytes(
                            encoding=serialization.Encoding.PEM,
                            format=serialization.PublicFormat.SubjectPublicKeyInfo,
                        ).decode("utf-8"),
                        der_format=der_data[:1024],
                    )

            elif "private" in key_type:
                # Parse private key
                key_obj = serialization.load_der_private_key(der_data[:2048], password=None, backend=default_backend())
                if isinstance(key_obj, rsa.RSAPrivateKey):
                    numbers = key_obj.private_numbers()
                    return ExtractedKey(
                        address=address,
                        key_type=KeyType.RSA_PRIVATE,
                        key_size=key_obj.key_size,
                        raw_bytes=der_data[:2048],
                        parameters={
                            "modulus": numbers.public_numbers.n,
                            "exponent": numbers.public_numbers.e,
                            "d": numbers.d,
                            "p": numbers.p,
                            "q": numbers.q,
                            "dp": numbers.dmp1,
                            "dq": numbers.dmq1,
                            "qi": numbers.iqmp,
                        },
                        confidence=0.95,
                        context="DER encoded RSA private key",
                        pem_format=key_obj.private_bytes(
                            encoding=serialization.Encoding.PEM,
                            format=serialization.PrivateFormat.PKCS8,
                            encryption_algorithm=serialization.NoEncryption(),
                        ).decode("utf-8"),
                        der_format=der_data[:2048],
                    )

        except Exception as e:
            logger.debug("Failed to parse RSA DER at %x: %s", address, e, exc_info=True)

        return None

    def _find_rsa_modulus(self, data: bytes, bit_size: int, base_address: int) -> list[ExtractedKey]:
        """Find potential RSA modulus values."""
        keys = []
        byte_size = bit_size // 8

        # Look for sequences of bytes that could be RSA moduli
        for i in range(len(data) - byte_size):
            # Check if this looks like a modulus (high bit set, odd number)
            if data[i] & 0x80 and data[i + byte_size - 1] & 0x01:
                modulus_bytes = data[i : i + byte_size]
                modulus = int.from_bytes(modulus_bytes, "big")

                # Check for common exponents nearby
                for exp in self.rsa_patterns["public_exponents"]:
                    exp_bytes = exp.to_bytes((exp.bit_length() + 7) // 8, "big")

                    # Search for exponent within 256 bytes
                    exp_offset = data.find(exp_bytes, max(0, i - 128), min(len(data), i + byte_size + 128))
                    if exp_offset != -1:
                        # Found potential RSA key
                        key = ExtractedKey(
                            address=base_address + i,
                            key_type=KeyType.RSA_PUBLIC,
                            key_size=bit_size,
                            raw_bytes=modulus_bytes,
                            parameters={"modulus": modulus, "exponent": exp},
                            confidence=0.75,
                            context=f"Raw RSA modulus with exponent {exp}",
                        )

                        # Try to create PEM format
                        try:
                            public_numbers = RSAPublicNumbers(exp, modulus)
                            public_key = public_numbers.public_key(default_backend())
                            key.pem_format = public_key.public_bytes(
                                encoding=serialization.Encoding.PEM,
                                format=serialization.PublicFormat.SubjectPublicKeyInfo,
                            ).decode("utf-8")
                        except (ValueError, TypeError, AttributeError):
                            pass

                        keys.append(key)
                        break

        return keys

    def _extract_ecc_keys(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Extract ECC keys from binary data."""
        keys = []

        # Search for curve OIDs
        for curve_name, curve_params in self.ecc_curves.items():
            oid = curve_params.get("oid")
            if not oid:
                continue

            offset = 0
            while True:
                offset = data.find(oid, offset)
                if offset == -1:
                    break

                if key := self._parse_ecc_key(data, offset, base_address, curve_name, curve_params):
                    keys.append(key)

                offset += 1

        # Search for raw curve points
        keys.extend(self._find_ecc_points(data, base_address))

        return keys

    def _parse_ecc_key(
        self,
        data: bytes,
        oid_offset: int,
        base_address: int,
        curve_name: str,
        curve_params: dict[str, Any],
    ) -> ExtractedKey | None:
        """Parse ECC key around OID."""
        try:
            key_size = curve_params["size"]
            coord_size = (key_size + 7) // 8

            # Look for public key point (uncompressed format: 04 || X || Y)
            search_start = max(0, oid_offset - 100)
            search_end = min(len(data), oid_offset + 200)

            for i in range(search_start, search_end - 2 * coord_size - 1):
                if data[i] == 0x04:  # Uncompressed point
                    x_bytes = data[i + 1 : i + 1 + coord_size]
                    y_bytes = data[i + 1 + coord_size : i + 1 + 2 * coord_size]

                    x = int.from_bytes(x_bytes, "big")
                    y = int.from_bytes(y_bytes, "big")

                    # Verify point is on curve (simplified check)
                    if self._verify_ecc_point(x, y, curve_params):
                        return ExtractedKey(
                            address=base_address + i,
                            key_type=KeyType.ECC_PUBLIC,
                            key_size=key_size,
                            raw_bytes=data[i : i + 1 + 2 * coord_size],
                            parameters={"curve": curve_name, "x": x, "y": y},
                            confidence=0.85,
                            context=f"ECC public key on {curve_name}",
                        )

        except Exception as e:
            logger.debug("Failed to parse ECC key: %s", e, exc_info=True)

        return None

    def _verify_ecc_point(self, x: int, y: int, curve_params: dict[str, Any]) -> bool:
        """Verify if point is on elliptic curve."""
        if "p" not in curve_params:
            return False

        p = curve_params["p"]

        # For Weierstrass curves: y^2 = x^3 + ax + b (mod p)
        if "a" in curve_params and "b" in curve_params:
            a = curve_params["a"]
            b = curve_params["b"]

            left = y**2 % p
            right = (x**2 * x + a * x + b) % p

            return left == right

        # For secp256k1: y^2 = x^3 + 7 (mod p)
        if curve_params.get("curve") == "secp256k1":
            left = y**2 % p
            right = (x**2 * x + 7) % p
            return left == right

        return True  # Can't verify, assume valid

    def _find_ecc_points(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Find potential ECC points in data."""
        keys = []

        # Look for uncompressed point format (0x04 prefix)
        for curve_name, curve_params in self.ecc_curves.items():
            if "size" not in curve_params:
                continue

            coord_size = (curve_params["size"] + 7) // 8
            point_size = 1 + 2 * coord_size

            for i in range(len(data) - point_size):
                if data[i] == 0x04:
                    point_data = data[i : i + point_size]
                    x = int.from_bytes(point_data[1 : 1 + coord_size], "big")
                    y = int.from_bytes(point_data[1 + coord_size :], "big")

                    if self._verify_ecc_point(x, y, curve_params):
                        keys.append(
                            ExtractedKey(
                                address=base_address + i,
                                key_type=KeyType.ECC_PUBLIC,
                                key_size=curve_params["size"],
                                raw_bytes=point_data,
                                parameters={"curve": curve_name, "x": x, "y": y},
                                confidence=0.7,
                                context=f"Potential ECC point on {curve_name}",
                            ),
                        )

        return keys

    def _extract_symmetric_keys(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Extract symmetric encryption keys."""
        keys = []

        # Common symmetric key sizes
        key_sizes = {
            16: KeyType.AES,  # AES-128
            24: KeyType.AES,  # AES-192
            32: KeyType.AES,  # AES-256
        }

        # Look for high entropy regions
        for size, key_type in key_sizes.items():
            for i in range(len(data) - size):
                key_bytes = data[i : i + size]
                entropy = self._calculate_entropy(key_bytes)

                if entropy > 7.5 and self._near_crypto_constants(data, i):
                    keys.append(
                        ExtractedKey(
                            address=base_address + i,
                            key_type=key_type,
                            key_size=size * 8,
                            raw_bytes=key_bytes,
                            parameters={"entropy": entropy, "hex": key_bytes.hex()},
                            confidence=0.6,
                            context=f"High entropy {key_type.value} key candidate",
                        ),
                    )

        return keys

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        if not data:
            return 0

        entropy = 0
        counts = {}

        for byte in data:
            counts[byte] = counts.get(byte, 0) + 1

        for count in counts.values():
            if count > 0:
                freq = count / len(data)
                entropy -= freq * (freq and freq * freq.bit_length())

        return entropy

    def _near_crypto_constants(self, data: bytes, offset: int) -> bool:
        """Check if offset is near known crypto constants."""
        # AES S-box
        aes_sbox = bytes.fromhex("637c777bf26b6fc53001672bfed7ab76")

        # SHA256 constants
        sha256_k = bytes.fromhex("428a2f98714914916f9bbfcf")

        # Check within 1KB
        search_start = max(0, offset - 512)
        search_end = min(len(data), offset + 512)
        search_region = data[search_start:search_end]

        return aes_sbox[:8] in search_region or sha256_k[:8] in search_region

    def _extract_pem_keys(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Extract PEM formatted keys."""
        keys = []

        # Find PEM headers
        for header in self.rsa_patterns["pem_headers"].values():
            offset = 0
            while True:
                offset = data.find(header, offset)
                if offset == -1:
                    break

                # Find corresponding END marker
                end_marker = header.replace(b"BEGIN", b"END")
                end_offset = data.find(end_marker, offset)

                if end_offset != -1:
                    pem_data = data[offset : end_offset + len(end_marker)]

                    # Decode base64 content
                    try:
                        lines = pem_data.split(b"\n")
                        base64_data = b"".join(lines[1:-1])
                        der_data = base64.b64decode(base64_data)

                        # Parse based on type
                        if b"PUBLIC" in header:
                            key = self._parse_rsa_der(der_data, offset + base_address, "public")
                        elif b"PRIVATE" in header:
                            key = self._parse_rsa_der(der_data, offset + base_address, "private")
                        else:
                            key = None

                        if key:
                            key.context = "PEM formatted key"
                            keys.append(key)

                    except Exception as e:
                        logger.debug("Failed to parse PEM key: %s", e, exc_info=True)

                offset += 1

        return keys

    def _extract_der_keys(self, data: bytes, base_address: int) -> list[ExtractedKey]:
        """Extract DER formatted keys."""
        keys = []

        # Look for SEQUENCE tags
        offset = 0
        while True:
            offset = data.find(b"\x30\x82", offset)  # SEQUENCE with 2-byte length
            if offset == -1:
                break

            # Get sequence length
            if offset + 4 <= len(data):
                length = struct.unpack(">H", data[offset + 2 : offset + 4])[0]

                if offset + 4 + length <= len(data):
                    der_data = data[offset : offset + 4 + length]

                    if key := self._parse_rsa_der(der_data, offset + base_address, "unknown"):
                        keys.append(key)

            offset += 1

        return keys

    def extract_from_binary(self, binary_path: str) -> list[ExtractedKey]:
        """Extract keys from binary file."""
        with open(binary_path, "rb") as f:
            data = f.read()

        return self.extract_from_memory(data)

    def export_keys(self, output_dir: str) -> None:
        """Export extracted keys to files."""
        import os

        os.makedirs(output_dir, exist_ok=True)

        for i, key in enumerate(self.extracted_keys):
            # Export PEM if available
            if key.pem_format:
                pem_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.pem")
                with open(pem_path, "w") as f:
                    f.write(key.pem_format)

            # Export DER if available
            if key.der_format:
                der_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.der")
                with open(der_path, "wb") as f:
                    f.write(key.der_format)

            # Export raw bytes
            raw_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.bin")
            with open(raw_path, "wb") as f:
                f.write(key.raw_bytes)

            # Export metadata
            meta_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.json")
            import json

            with open(meta_path, "w") as f:
                meta = {
                    "address": f"0x{key.address:x}",
                    "type": key.key_type.value,
                    "size": key.key_size,
                    "confidence": key.confidence,
                    "context": key.context,
                    "parameters": {k: str(v) if isinstance(v, int) and v > 2**32 else v for k, v in key.parameters.items()},
                }
                json.dump(meta, f, indent=2)

        logger.info("Exported %s keys to %s", len(self.extracted_keys), output_dir)
