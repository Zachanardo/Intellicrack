"""Advanced Cryptographic Key Extraction Engine.

This module provides sophisticated capabilities for extracting RSA, ECC, and other
cryptographic keys from binaries, including obfuscated and protected implementations.

Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import base64
import logging
import struct
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers

logger = logging.getLogger(__name__)


class KeyType(Enum):
    """Supported cryptographic key types."""

    RSA_PUBLIC = "rsa_public"
    RSA_PRIVATE = "rsa_private"
    ECC_PUBLIC = "ecc_public"
    ECC_PRIVATE = "ecc_private"
    DSA_PUBLIC = "dsa_public"
    DSA_PRIVATE = "dsa_private"
    AES = "aes"
    DES3 = "3des"
    CUSTOM = "custom"


@dataclass
class ExtractedKey:
    """Represents an extracted cryptographic key."""

    address: int
    key_type: KeyType
    key_size: int
    raw_bytes: bytes
    parameters: Dict[str, Any]
    confidence: float
    context: str
    pem_format: Optional[str] = None
    der_format: Optional[bytes] = None


class CryptoKeyExtractor:
    """Advanced engine for extracting cryptographic keys from binaries."""

    def __init__(self):
        """Initialize the key extractor."""
        self.extracted_keys: List[ExtractedKey] = []

        # RSA key patterns
        self.rsa_patterns = self._build_rsa_patterns()

        # ECC curve parameters
        self.ecc_curves = self._build_ecc_curves()

        # Common key formats
        self.key_formats = self._build_key_formats()

    def _build_rsa_patterns(self) -> Dict[str, Any]:
        """Build RSA key detection patterns."""
        return {
            "public_exponents": [
                0x10001,  # 65537 - most common
                0x03,  # 3
                0x11,  # 17
                0x10003,  # 65539
            ],
            "modulus_sizes": [512, 768, 1024, 1536, 2048, 3072, 4096],
            "asn1_headers": {
                "public": bytes.fromhex("30820122300d06092a864886f70d01010105000382010f003082010a0282010100"),
                "private": bytes.fromhex("308204bd020100300d06092a864886f70d0101010500"),
                "pkcs1_public": bytes.fromhex("3082010a0282010100"),
                "pkcs1_private": bytes.fromhex("3082025c02010002818100"),
            },
            "pem_headers": {
                "public": b"-----BEGIN PUBLIC KEY-----",
                "private": b"-----BEGIN RSA PRIVATE KEY-----",
                "certificate": b"-----BEGIN CERTIFICATE-----",
            },
        }

    def _build_ecc_curves(self) -> Dict[str, Dict[str, Any]]:
        """Build ECC curve parameters."""
        return {
            "P-256": {
                "oid": bytes.fromhex("06082a8648ce3d030107"),
                "p": 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF,
                "a": 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC,
                "b": 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B,
                "gx": 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296,
                "gy": 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5,
                "n": 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551,
                "size": 256,
            },
            "P-384": {
                "oid": bytes.fromhex("06052b81040022"),
                "p": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF,
                "size": 384,
            },
            "P-521": {
                "oid": bytes.fromhex("06052b81040023"),
                "p": 0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
                "size": 521,
            },
            "secp256k1": {  # Bitcoin/Ethereum
                "oid": bytes.fromhex("06052b8104000a"),
                "p": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,
                "n": 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,
                "size": 256,
            },
        }

    def _build_key_formats(self) -> Dict[str, Any]:
        """Build key format detection patterns."""
        return {
            "der": {"sequence": b"\x30", "integer": b"\x02", "bit_string": b"\x03", "octet_string": b"\x04", "object_id": b"\x06"},
            "pem": {
                "begin": b"-----BEGIN",
                "end": b"-----END",
                "base64_chars": b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            },
            "xml": {"modulus": b"<Modulus>", "exponent": b"<Exponent>", "p": b"<P>", "q": b"<Q>"},
            "json": {"kty": b'"kty"', "n": b'"n"', "e": b'"e"', "d": b'"d"'},
        }

    def extract_from_memory(self, memory_data: bytes, base_address: int = 0) -> List[ExtractedKey]:
        """Extract cryptographic keys from memory dump."""
        keys = []

        # Search for RSA keys
        keys.extend(self._extract_rsa_keys(memory_data, base_address))

        # Search for ECC keys
        keys.extend(self._extract_ecc_keys(memory_data, base_address))

        # Search for symmetric keys
        keys.extend(self._extract_symmetric_keys(memory_data, base_address))

        # Search for PEM formatted keys
        keys.extend(self._extract_pem_keys(memory_data, base_address))

        # Search for DER formatted keys
        keys.extend(self._extract_der_keys(memory_data, base_address))

        self.extracted_keys.extend(keys)
        return keys

    def _extract_rsa_keys(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Extract RSA keys from binary data."""
        keys = []

        # Search for ASN.1 DER encoded RSA keys
        for key_type, header in self.rsa_patterns["asn1_headers"].items():
            offset = 0
            while True:
                offset = data.find(header, offset)
                if offset == -1:
                    break

                # Try to parse the key
                key = self._parse_rsa_der(data[offset:], offset + base_address, key_type)
                if key:
                    keys.append(key)

                offset += 1

        # Search for raw RSA components (modulus patterns)
        for size in self.rsa_patterns["modulus_sizes"]:
            keys.extend(self._find_rsa_modulus(data, size, base_address))

        return keys

    def _parse_rsa_der(self, der_data: bytes, address: int, key_type: str) -> Optional[ExtractedKey]:
        """Parse DER encoded RSA key."""
        try:
            # Parse ASN.1 structure
            if len(der_data) < 100:
                return None

            # Extract key components based on type
            if "public" in key_type:
                # Parse public key
                key_obj = serialization.load_der_public_key(der_data[:1024], backend=default_backend())
                if isinstance(key_obj, rsa.RSAPublicKey):
                    numbers = key_obj.public_numbers()
                    return ExtractedKey(
                        address=address,
                        key_type=KeyType.RSA_PUBLIC,
                        key_size=key_obj.key_size,
                        raw_bytes=der_data[:1024],
                        parameters={"modulus": numbers.n, "exponent": numbers.e},
                        confidence=0.95,
                        context="DER encoded RSA public key",
                        pem_format=key_obj.public_bytes(
                            encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo
                        ).decode("utf-8"),
                        der_format=der_data[:1024],
                    )

            elif "private" in key_type:
                # Parse private key
                key_obj = serialization.load_der_private_key(der_data[:2048], password=None, backend=default_backend())
                if isinstance(key_obj, rsa.RSAPrivateKey):
                    numbers = key_obj.private_numbers()
                    return ExtractedKey(
                        address=address,
                        key_type=KeyType.RSA_PRIVATE,
                        key_size=key_obj.key_size,
                        raw_bytes=der_data[:2048],
                        parameters={
                            "modulus": numbers.public_numbers.n,
                            "exponent": numbers.public_numbers.e,
                            "d": numbers.d,
                            "p": numbers.p,
                            "q": numbers.q,
                            "dp": numbers.dmp1,
                            "dq": numbers.dmq1,
                            "qi": numbers.iqmp,
                        },
                        confidence=0.95,
                        context="DER encoded RSA private key",
                        pem_format=key_obj.private_bytes(
                            encoding=serialization.Encoding.PEM,
                            format=serialization.PrivateFormat.PKCS8,
                            encryption_algorithm=serialization.NoEncryption(),
                        ).decode("utf-8"),
                        der_format=der_data[:2048],
                    )

        except Exception as e:
            logger.debug(f"Failed to parse RSA DER at {address:x}: {e}")

        return None

    def _find_rsa_modulus(self, data: bytes, bit_size: int, base_address: int) -> List[ExtractedKey]:
        """Find potential RSA modulus values."""
        keys = []
        byte_size = bit_size // 8

        # Look for sequences of bytes that could be RSA moduli
        for i in range(len(data) - byte_size):
            # Check if this looks like a modulus (high bit set, odd number)
            if data[i] & 0x80 and data[i + byte_size - 1] & 0x01:
                modulus_bytes = data[i : i + byte_size]
                modulus = int.from_bytes(modulus_bytes, "big")

                # Check for common exponents nearby
                for exp in self.rsa_patterns["public_exponents"]:
                    exp_bytes = exp.to_bytes((exp.bit_length() + 7) // 8, "big")

                    # Search for exponent within 256 bytes
                    exp_offset = data.find(exp_bytes, max(0, i - 128), min(len(data), i + byte_size + 128))
                    if exp_offset != -1:
                        # Found potential RSA key
                        key = ExtractedKey(
                            address=base_address + i,
                            key_type=KeyType.RSA_PUBLIC,
                            key_size=bit_size,
                            raw_bytes=modulus_bytes,
                            parameters={"modulus": modulus, "exponent": exp},
                            confidence=0.75,
                            context=f"Raw RSA modulus with exponent {exp}",
                        )

                        # Try to create PEM format
                        try:
                            public_numbers = RSAPublicNumbers(exp, modulus)
                            public_key = public_numbers.public_key(default_backend())
                            key.pem_format = public_key.public_bytes(
                                encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo
                            ).decode("utf-8")
                        except:
                            pass

                        keys.append(key)
                        break

        return keys

    def _extract_ecc_keys(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Extract ECC keys from binary data."""
        keys = []

        # Search for curve OIDs
        for curve_name, curve_params in self.ecc_curves.items():
            oid = curve_params.get("oid")
            if not oid:
                continue

            offset = 0
            while True:
                offset = data.find(oid, offset)
                if offset == -1:
                    break

                # Try to extract ECC key around OID
                key = self._parse_ecc_key(data, offset, base_address, curve_name, curve_params)
                if key:
                    keys.append(key)

                offset += 1

        # Search for raw curve points
        keys.extend(self._find_ecc_points(data, base_address))

        return keys

    def _parse_ecc_key(
        self, data: bytes, oid_offset: int, base_address: int, curve_name: str, curve_params: Dict[str, Any]
    ) -> Optional[ExtractedKey]:
        """Parse ECC key around OID."""
        try:
            key_size = curve_params["size"]
            coord_size = (key_size + 7) // 8

            # Look for public key point (uncompressed format: 04 || X || Y)
            search_start = max(0, oid_offset - 100)
            search_end = min(len(data), oid_offset + 200)

            for i in range(search_start, search_end - 2 * coord_size - 1):
                if data[i] == 0x04:  # Uncompressed point
                    x_bytes = data[i + 1 : i + 1 + coord_size]
                    y_bytes = data[i + 1 + coord_size : i + 1 + 2 * coord_size]

                    x = int.from_bytes(x_bytes, "big")
                    y = int.from_bytes(y_bytes, "big")

                    # Verify point is on curve (simplified check)
                    if self._verify_ecc_point(x, y, curve_params):
                        return ExtractedKey(
                            address=base_address + i,
                            key_type=KeyType.ECC_PUBLIC,
                            key_size=key_size,
                            raw_bytes=data[i : i + 1 + 2 * coord_size],
                            parameters={"curve": curve_name, "x": x, "y": y},
                            confidence=0.85,
                            context=f"ECC public key on {curve_name}",
                        )

        except Exception as e:
            logger.debug(f"Failed to parse ECC key: {e}")

        return None

    def _verify_ecc_point(self, x: int, y: int, curve_params: Dict[str, Any]) -> bool:
        """Verify if point is on elliptic curve."""
        if "p" not in curve_params:
            return False

        p = curve_params["p"]

        # For Weierstrass curves: y^2 = x^3 + ax + b (mod p)
        if "a" in curve_params and "b" in curve_params:
            a = curve_params["a"]
            b = curve_params["b"]

            left = (y * y) % p
            right = (x * x * x + a * x + b) % p

            return left == right

        # For secp256k1: y^2 = x^3 + 7 (mod p)
        if curve_params.get("curve") == "secp256k1":
            left = (y * y) % p
            right = (x * x * x + 7) % p
            return left == right

        return True  # Can't verify, assume valid

    def _find_ecc_points(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Find potential ECC points in data."""
        keys = []

        # Look for uncompressed point format (0x04 prefix)
        for curve_name, curve_params in self.ecc_curves.items():
            if "size" not in curve_params:
                continue

            coord_size = (curve_params["size"] + 7) // 8
            point_size = 1 + 2 * coord_size

            for i in range(len(data) - point_size):
                if data[i] == 0x04:
                    point_data = data[i : i + point_size]
                    x = int.from_bytes(point_data[1 : 1 + coord_size], "big")
                    y = int.from_bytes(point_data[1 + coord_size :], "big")

                    if self._verify_ecc_point(x, y, curve_params):
                        keys.append(
                            ExtractedKey(
                                address=base_address + i,
                                key_type=KeyType.ECC_PUBLIC,
                                key_size=curve_params["size"],
                                raw_bytes=point_data,
                                parameters={"curve": curve_name, "x": x, "y": y},
                                confidence=0.7,
                                context=f"Potential ECC point on {curve_name}",
                            )
                        )

        return keys

    def _extract_symmetric_keys(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Extract symmetric encryption keys."""
        keys = []

        # Common symmetric key sizes
        key_sizes = {
            16: KeyType.AES,  # AES-128
            24: KeyType.AES,  # AES-192
            32: KeyType.AES,  # AES-256
        }

        # Look for high entropy regions
        for size, key_type in key_sizes.items():
            for i in range(len(data) - size):
                key_bytes = data[i : i + size]
                entropy = self._calculate_entropy(key_bytes)

                if entropy > 7.5:  # High entropy threshold
                    # Check if it's near crypto constants
                    if self._near_crypto_constants(data, i):
                        keys.append(
                            ExtractedKey(
                                address=base_address + i,
                                key_type=key_type,
                                key_size=size * 8,
                                raw_bytes=key_bytes,
                                parameters={"entropy": entropy, "hex": key_bytes.hex()},
                                confidence=0.6,
                                context=f"High entropy {key_type.value} key candidate",
                            )
                        )

        return keys

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        if not data:
            return 0

        entropy = 0
        counts = {}

        for byte in data:
            counts[byte] = counts.get(byte, 0) + 1

        for count in counts.values():
            if count > 0:
                freq = count / len(data)
                entropy -= freq * (freq and freq * freq.bit_length())

        return entropy

    def _near_crypto_constants(self, data: bytes, offset: int) -> bool:
        """Check if offset is near known crypto constants."""
        # AES S-box
        aes_sbox = bytes.fromhex("637c777bf26b6fc53001672bfed7ab76")

        # SHA256 constants
        sha256_k = bytes.fromhex("428a2f98714914916f9bbfcf")

        # Check within 1KB
        search_start = max(0, offset - 512)
        search_end = min(len(data), offset + 512)
        search_region = data[search_start:search_end]

        return aes_sbox[:8] in search_region or sha256_k[:8] in search_region

    def _extract_pem_keys(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Extract PEM formatted keys."""
        keys = []

        # Find PEM headers
        for key_type, header in self.rsa_patterns["pem_headers"].items():
            offset = 0
            while True:
                offset = data.find(header, offset)
                if offset == -1:
                    break

                # Find corresponding END marker
                end_marker = header.replace(b"BEGIN", b"END")
                end_offset = data.find(end_marker, offset)

                if end_offset != -1:
                    pem_data = data[offset : end_offset + len(end_marker)]

                    # Decode base64 content
                    try:
                        lines = pem_data.split(b"\n")
                        base64_data = b"".join(lines[1:-1])
                        der_data = base64.b64decode(base64_data)

                        # Parse based on type
                        if b"PUBLIC" in header:
                            key = self._parse_rsa_der(der_data, offset + base_address, "public")
                        elif b"PRIVATE" in header:
                            key = self._parse_rsa_der(der_data, offset + base_address, "private")
                        else:
                            key = None

                        if key:
                            key.context = "PEM formatted key"
                            keys.append(key)

                    except Exception as e:
                        logger.debug(f"Failed to parse PEM key: {e}")

                offset += 1

        return keys

    def _extract_der_keys(self, data: bytes, base_address: int) -> List[ExtractedKey]:
        """Extract DER formatted keys."""
        keys = []

        # Look for SEQUENCE tags
        offset = 0
        while True:
            offset = data.find(b"\x30\x82", offset)  # SEQUENCE with 2-byte length
            if offset == -1:
                break

            # Get sequence length
            if offset + 4 <= len(data):
                length = struct.unpack(">H", data[offset + 2 : offset + 4])[0]

                if offset + 4 + length <= len(data):
                    der_data = data[offset : offset + 4 + length]

                    # Try to parse as various key types
                    key = self._parse_rsa_der(der_data, offset + base_address, "unknown")
                    if key:
                        keys.append(key)

            offset += 1

        return keys

    def extract_from_binary(self, binary_path: str) -> List[ExtractedKey]:
        """Extract keys from binary file."""
        with open(binary_path, "rb") as f:
            data = f.read()

        return self.extract_from_memory(data)

    def export_keys(self, output_dir: str):
        """Export extracted keys to files."""
        import os

        os.makedirs(output_dir, exist_ok=True)

        for i, key in enumerate(self.extracted_keys):
            # Export PEM if available
            if key.pem_format:
                pem_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.pem")
                with open(pem_path, "w") as f:
                    f.write(key.pem_format)

            # Export DER if available
            if key.der_format:
                der_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.der")
                with open(der_path, "wb") as f:
                    f.write(key.der_format)

            # Export raw bytes
            raw_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.bin")
            with open(raw_path, "wb") as f:
                f.write(key.raw_bytes)

            # Export metadata
            meta_path = os.path.join(output_dir, f"key_{i}_{key.key_type.value}.json")
            import json

            with open(meta_path, "w") as f:
                meta = {
                    "address": f"0x{key.address:x}",
                    "type": key.key_type.value,
                    "size": key.key_size,
                    "confidence": key.confidence,
                    "context": key.context,
                    "parameters": {k: str(v) if isinstance(v, int) and v > 2**32 else v for k, v in key.parameters.items()},
                }
                json.dump(meta, f, indent=2)

        logger.info(f"Exported {len(self.extracted_keys)} keys to {output_dir}")
