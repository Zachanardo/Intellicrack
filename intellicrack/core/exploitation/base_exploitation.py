"""
Base Exploitation Module

Provides common functionality for exploitation components.
"""

import logging
import subprocess
from typing import Any, Dict, List, Optional, Tuple

from ..shared.result_utils import ResultMixin


class BaseExploitation(ResultMixin):
    """
    Base class for exploitation components.
    Provides common command execution functionality.
    """

    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)

    def handle_result_error(self, result: Dict[str, Any], error: Exception) -> Dict[str, Any]:
        """
        Handle error in result dictionary.

        Args:
            result: Result dictionary to update
            error: Exception that occurred

        Returns:
            Updated result dictionary
        """
        result['error'] = str(error)
        self.logger.error(f"Operation failed: {error}")
        return result

    def execute_command(self, command: List[str], shell: bool = False,
                       capture_output: bool = True, text: bool = True,
                       timeout: Optional[int] = None) -> Tuple[int, str, str]:
        """
        Execute a command safely with proper error handling.

        Args:
            command: Command as list of strings (or string if shell=True)
            shell: Whether to use shell execution
            capture_output: Whether to capture stdout/stderr
            text: Whether to decode output as text
            timeout: Command timeout in seconds

        Returns:
            Tuple of (returncode, stdout, stderr)
        """
        try:
            result = subprocess.run(
                command,
                shell=shell,
                capture_output=capture_output,
                text=text,
                timeout=timeout
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            self.logger.error(f"Command timed out: {command}")
            return -1, "", "Command timed out"
        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return -1, "", str(e)

    def execute_sudo_command(self, command: str, password: Optional[str] = None,
                           use_stdin: bool = True) -> Tuple[int, str, str]:
        """
        Execute a command with sudo privileges.

        Args:
            command: Command to execute with sudo
            password: Sudo password (if required)
            use_stdin: Whether to pass password via stdin (safer)

        Returns:
            Tuple of (returncode, stdout, stderr)
        """
        if password and use_stdin:
            # Safer method: pass password via stdin
            sudo_cmd = ['sudo', '-S'] + command.split()
            try:
                process = subprocess.Popen(
                    sudo_cmd,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                stdout, stderr = process.communicate(input=password + '\n')
                return process.returncode, stdout, stderr
            except Exception as e:
                self.logger.error(f"Sudo command failed: {e}")
                return -1, "", str(e)
        else:
            # No password or direct execution
            sudo_cmd = ['sudo'] + command.split()
            return self.execute_command(sudo_cmd)

    def execute_ssh_command(self, host: str, username: str, command: str,
                          password: Optional[str] = None,
                          key_file: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute command via SSH with proper security.

        Args:
            host: Target host
            username: SSH username
            command: Command to execute
            password: SSH password (optional)
            key_file: SSH key file path (optional)

        Returns:
            Result dictionary with success, output, and error
        """
        result = {
            'success': False,
            'output': '',
            'error': None,
            'exit_code': None
        }

        ssh_cmd = ['ssh', '-o', 'StrictHostKeyChecking=no', '-o', 'UserKnownHostsFile=/dev/null']

        if key_file:
            ssh_cmd.extend(['-i', key_file])

        ssh_cmd.extend([f'{username}@{host}', command])

        if password and not key_file:
            # Use sshpass but safely
            ssh_cmd = ['sshpass', '-e'] + ssh_cmd
            import os
            os.environ['SSHPASS'] = password

        try:
            returncode, stdout, stderr = self.execute_command(ssh_cmd)

            if 'SSHPASS' in os.environ:
                del os.environ['SSHPASS']

            result['success'] = (returncode == 0)
            result['output'] = stdout
            result['error'] = stderr if stderr else None
            result['exit_code'] = returncode

        except Exception as e:
            self.logger.error("Exception in base_exploitation: %s", e)
            result['error'] = str(e)

        return result
