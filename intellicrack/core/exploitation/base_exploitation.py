"""This file is part of Intellicrack.
Copyright (C) 2025 Zachary Flint

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.
"""

import logging
import subprocess
from typing import Any

from ..shared.result_utils import ResultMixin

"""
Base Exploitation Module

Provides common functionality for exploitation components.
"""


class BaseExploitation(ResultMixin):
    """Base class for exploitation components.
    Provides common command execution functionality.
    """

    def __init__(self):
        """Initialize the base exploitation framework with logging and configuration."""
        self.logger = logging.getLogger(__name__)

    def handle_result_error(self, result: dict[str, Any], error: Exception) -> dict[str, Any]:
        """Handle error in result dictionary.

        Args:
            result: Result dictionary to update
            error: Exception that occurred

        Returns:
            Updated result dictionary

        """
        result["error"] = str(error)
        self.logger.error(f"Operation failed: {error}")
        return result

    def execute_command(
        self,
        command: list[str],
        shell: bool = False,
        capture_output: bool = True,
        text: bool = True,
        timeout: int | None = None,
    ) -> tuple[int, str, str]:
        """Execute a command safely with proper error handling.

        Args:
            command: Command as list of strings (or string if shell=True)
            shell: Whether to use shell execution
            capture_output: Whether to capture stdout/stderr
            text: Whether to decode output as text
            timeout: Command timeout in seconds

        Returns:
            Tuple of (returncode, stdout, stderr)

        """
        try:
            result = subprocess.run(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                command,
                check=False,
                shell=shell,
                capture_output=capture_output,
                text=text,
                timeout=timeout,
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            self.logger.error(f"Command timed out: {command}")
            return -1, "", "Command timed out"
        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return -1, "", str(e)

    def execute_sudo_command(
        self, command: str, password: str | None = None, use_stdin: bool = True
    ) -> tuple[int, str, str]:
        """Execute a command with sudo privileges.

        Args:
            command: Command to execute with sudo
            password: Sudo password (if required)
            use_stdin: Whether to pass password via stdin (safer)

        Returns:
            Tuple of (returncode, stdout, stderr)

        """
        if password and use_stdin:
            # Safer method: pass password via stdin
            sudo_cmd = ["sudo", "-S"] + command.split()
            try:
                process = subprocess.Popen(  # nosec S603 - Legitimate subprocess usage for security research and binary analysis  # noqa: S603
                    sudo_cmd,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                )
                stdout, stderr = process.communicate(input=password + "\n")
                return process.returncode, stdout, stderr
            except Exception as e:
                self.logger.error(f"Sudo command failed: {e}")
                return -1, "", str(e)
        else:
            # No password or direct execution
            sudo_cmd = ["sudo"] + command.split()
            return self.execute_command(sudo_cmd)

    def execute_ssh_command(
        self,
        host: str,
        username: str,
        command: str,
        password: str | None = None,
        key_file: str | None = None,
    ) -> dict[str, Any]:
        """Execute command via SSH with proper security.

        Args:
            host: Target host
            username: SSH username
            command: Command to execute
            password: SSH password (optional)
            key_file: SSH key file path (optional)

        Returns:
            Result dictionary with success, output, and error

        """
        result = {
            "success": False,
            "output": "",
            "error": None,
            "exit_code": None,
        }

        ssh_cmd = ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "UserKnownHostsFile=/dev/null"]

        if key_file:
            ssh_cmd.extend(["-i", key_file])

        ssh_cmd.extend([f"{username}@{host}", command])

        if password and not key_file:
            # Use sshpass but safely
            ssh_cmd = ["sshpass", "-e"] + ssh_cmd
            import os

            os.environ["SSHPASS"] = password

        try:
            returncode, stdout, stderr = self.execute_command(ssh_cmd)

            if "SSHPASS" in os.environ:
                del os.environ["SSHPASS"]

            result["success"] = returncode == 0
            result["output"] = stdout
            result["error"] = stderr if stderr else None
            result["exit_code"] = returncode

        except Exception as e:
            self.logger.error("Exception in base_exploitation: %s", e)
            result["error"] = str(e)

        return result
